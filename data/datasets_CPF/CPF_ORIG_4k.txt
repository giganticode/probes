tr	7	public boolean initializeDb ( ) { try { if ( ! isdabaseInitialized ( ) ) { getDbConnection ( ) . createStatement ( ) . execute ( createString1 ) ; getDbConnection ( ) . createStatement ( ) . execute ( createString2 ) ; updateDb101b ( ) ; updateDb102b ( ) ; initStationData ( ) ; return true ; } if ( ! updatedTo ( APP_VERSION_101 ) && ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb101b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } if ( ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb102b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } } catch ( SQLException e ) { log . error ( "Error" , e ) ; } return false ; }
tr	9X	public Iterator < String > keysThatMatch ( String pattern ) { if ( pattern == null ) { throw new IllegalArgumentException ( ) ; } Queue < String > results = new ArrayList < String > ( size ) ; if ( root == null ) { return results . queued ( ) ; } Stack < Node < V >> nodes = new ArrayList < Node < V >> ( ) ; Stack < String > keys = new ArrayList < String > ( ) ; nodes . push ( root ) ; keys . push ( "" ) ; while ( ! nodes . empty ( ) ) { Node < V > node = nodes . pop ( ) ; String key = keys . pop ( ) ; if ( key . length ( ) == pattern . length ( ) ) { if ( node . value != null ) { results . enqueue ( key ) ; } continue ; } char c = pattern . charAt ( key . length ( ) ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } if ( c == * ) { for ( char i = ALPHABET_SIZE - 1 ; i >= 0 ; -- i ) { if ( node . next [ i ] != null ) { nodes . push ( node . next [ i ] ) ; keys . push ( key + i ) ; } } } else if ( node . next [ c ] != null ) { nodes . push ( node . next [ c ] ) ; keys . push ( key + c ) ; } } return results . queued ( ) ; }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	8	public Player [ ] getWinners ( ) { int winner = - 1 ; Player players [ ] = this . players ; for ( int i = 0 ; i < players . length && winner < 0 ; ++ i ) { Player p = players [ i ] ; if ( p . equals ( this . getBestPlayerBet ( ) ) ) { winner = i ; } } int winnerTeammate = 0 ; int loser = 0 ; int loserTeammate = 0 ; if ( winner == 0 ) { winnerTeammate = 2 ; loser = 1 ; loserTeammate = 3 ; } else if ( winner == 1 ) { winnerTeammate = 3 ; loser = 0 ; loserTeammate = 2 ; } else if ( winner == 2 ) { winnerTeammate = 0 ; loser = 1 ; loserTeammate = 3 ; } else if ( winner == 3 ) { winnerTeammate = 1 ; loser = 0 ; loserTeammate = 2 ; } int roundsWon = this . players [ winner ] . getTurnWin ( ) + this . players [ winnerTeammate ] . getTurnWin ( ) ; int roundsBet = this . players [ winner ] . getOriginalBet ( ) . getNbRounds ( ) ; Player [ ] winners ; if ( roundsWon >= roundsBet ) { winners = new Player [ ] { this . players [ winner ] , this . players [ winnerTeammate ] } ; } else { winners = new Player [ ] { this . players [ loser ] , this . players [ loserTeammate ] } ; } return winners ; }
tr	2	public void add_bits ( int bitstring , int length ) { int bitmask = 1 << ( length - 1 ) ; do if ( ( ( crc & 8000 ) == 0 ) ^ ( ( bitstring & bitmask ) == 0 ) ) { crc <<= 1 ; crc ^= polynomial ; } else crc <<= 1 ; while ( ( bitmask >>>= 1 ) != 0 ) ; }
tr	5	private void startClientMonitor ( ) { while ( noStopRequested ) { try { if ( this . timeOut > 0 ) { Iterator < Object > it = clients . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Client client = clients . get ( key ) ; if ( ! client . isReadDataFlag ( ) ) { client . close ( ) ; clients . remove ( key ) ; } else { client . setReadDataFlag ( false ) ; } } this . clientMonitor . sleep ( this . timeOut * 60 * 1000 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	1	public static synchronized SondageDao getInstance ( ) { if ( instance == null ) instance = new SondageDao ( ) ; return instance ; }
tr	0	public boolean isAlreadyExistPassenger ( Passenger passenger ) { log . debug ( "Start isAlreadyExistPassenger select" ) ; List results = em . createQuery ( "select count(*)\n" + "from Passenger passenger \n" + "where passenger.firstname = ?\n" + "and passenger.lastname = ?\n" + "and passenger.birthday = ?" ) . setParameter ( 1 , passenger . getFirstname ( ) ) . setParameter ( 2 , passenger . getLastname ( ) ) . setParameter ( 3 , passenger . getBirthday ( ) ) . getResultList ( ) ; return ( long ) results . get ( 0 ) != 0 ; }
tr	7	@ Test public void testNavigateShowDescending ( ) { for ( int i = MockFileSystem . NUM_SEASONS ; i > 0 ; i -- ) { for ( int j = MockFileSystem . NUM_EPISODES ; j > 0 ; j -- ) { int season = ( j == 1 ) ? i - 1 : i ; int expEp = ( j == 1 ) ? MockFileSystem . NUM_EPISODES : j - 1 ; EpisodeMatch toNavigate = new EpisodeMatch ( "Scrubs" , i , j ) ; EpisodeMatch expResult = new EpisodeMatch ( season , expEp ) ; EpisodeMatch result = episode . navigate ( toNavigate , EpisodeNavigator . Pointer . PREV ) ; if ( result == null && i == 1 && j == 1 ) { return ; } System . out . println ( "Navigating: " + toNavigate + " : to : " + expResult ) ; assertEquals ( expResult . getSeason ( ) , result . getSeason ( ) ) ; assertEquals ( expResult . getEpisodes ( ) , result . getEpisodes ( ) ) ; } } }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	3	public static String toString ( char what ) { switch ( what ) { case EPSILON : return "eps" ; case else : return "else" ; case BLANK : return "blank" ; default : return "" + what ; } }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetAccountPolicyRequest == false ) return false ; GetAccountPolicyRequest other = ( GetAccountPolicyRequest ) obj ; if ( other . getAccountName ( ) == null ^ this . getAccountName ( ) == null ) return false ; if ( other . getAccountName ( ) != null && other . getAccountName ( ) . equals ( this . getAccountName ( ) ) == false ) return false ; if ( other . getPolicyName ( ) == null ^ this . getPolicyName ( ) == null ) return false ; if ( other . getPolicyName ( ) != null && other . getPolicyName ( ) . equals ( this . getPolicyName ( ) ) == false ) return false ; return true ; }
tr	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; AlienAndGame obj ; int answer ; obj = new AlienAndGame ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . getNumber ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	5	@ Override public int compare ( Course course1 , Course course2 ) { if ( sortOrder == SortOrder . ASCENDING ) { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return - 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return - 1 ; } } }
tr	6	public int largestRectangleArea2 ( int [ ] height ) { if ( height == null || height . length == 0 ) return 0 ; int max = 0 ; int i = 0 ; while ( i < height . length ) { int k = i ; while ( k < height . length - 1 ) { if ( height [ k ] > height [ k + 1 ] ) { break ; } k ++ ; } i = k ; int lowest = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { lowest = Math . min ( lowest , height [ j ] ) ; int val = ( i - j + 1 ) * lowest ; max = Math . max ( max , val ) ; } i ++ ; } return max ; }
tr	2	public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case GET_LANG : return isSetGetLang ( ) ; } throw new IllegalStateException ( ) ; }
tr	9X	public boolean isMatch ( String s , String p ) { if ( p . length ( ) == 0 ) { return s . length ( ) == 0 ; } if ( p . length ( ) == 1 ) { return ( s . length ( ) == 1 ) && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ; } if ( p . charAt ( 1 ) != * ) { if ( s . length ( ) < 1 ) { return false ; } else { return ( s . charAt ( 0 ) == p . charAt ( 0 ) || p . charAt ( 0 ) == . ) && isMatch ( s . substring ( 1 ) , p . substring ( 1 ) ) ; } } while ( s . length ( ) > 0 && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ) { if ( isMatch ( s , p . substring ( 2 ) ) ) { return true ; } s = s . substring ( 1 ) ; } return isMatch ( s , p . substring ( 2 ) ) ; }
tr	8	static public void msDur ( StringBuilder sb , int ms ) { if ( ms < 0 ) { sb . append ( "-" ) ; msDur ( sb , - ms ) ; } else if ( ms < 1000 ) { sb . append ( ms ) ; sb . append ( "ms" ) ; } else if ( ms < 10000 ) { tenths ( sb , ms , 1000 ) ; sb . append ( s ) ; } else if ( ms < 60000 ) { sb . append ( ms / 1000 ) ; sb . append ( s ) ; } else if ( ms < 600000 ) { tenths ( sb , ms , 60000 ) ; sb . append ( m ) ; } else if ( ms < 3600000 ) { sb . append ( ms / 60000 ) ; sb . append ( m ) ; } else if ( ms < 36000000 ) { tenths ( sb , ms , 3600000 ) ; sb . append ( h ) ; } else if ( ms < 86400000 ) { sb . append ( ms / 3600000 ) ; sb . append ( h ) ; } else { tenths ( sb , ms , 86400000 ) ; sb . append ( d ) ; } }
tr	0	public Sprite ( BufferedImage image , int frameHeight , int numberOfTiles , int frameDurations [ ] ) { animation = new Animation ( ) ; SpriteLoader . parseSprite ( image , frameHeight , numberOfTiles , frameDurations , animation ) ; }
tr	0	public String getStr ( ) { return str ; }
tr	1	public static long readLong ( byte [ ] b , int start ) { long l = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { l <<= 8 ; l |= b [ start + i ] & ff ; } return l ; }
tr	4	public static Point2 getPositionAfterMovement ( Entity entity ) { switch ( entity . orientation ) { case NORTH : return new Point2 ( entity . position . x , entity . position . y - 1 ) ; case EAST : return new Point2 ( entity . position . x + 1 , entity . position . y ) ; case SOUTH : return new Point2 ( entity . position . x , entity . position . y + 1 ) ; case WEST : return new Point2 ( entity . position . x - 1 , entity . position . y ) ; default : return new Point2 ( entity . position . x , entity . position . y ) ; } }
tr	5	public String formatMessage ( String msg ) { ArrayList < String > messages = new ArrayList < String > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( msg ) ; while ( tokenizer . hasMoreTokens ( ) ) { messages . add ( tokenizer . nextToken ( ) ) ; } String name = messages . get ( 1 ) ; if ( messages . get ( 0 ) . equalsIgnoreCase ( "SAY" ) ) { msg = name + ": " ; for ( int i = 2 ; i < messages . size ( ) ; i ++ ) { msg += messages . get ( i ) + " " ; } } else if ( messages . get ( 0 ) . equalsIgnoreCase ( "JOIN" ) ) { msg = name + " HAS JOINED" ; } else if ( messages . get ( 0 ) . equalsIgnoreCase ( "LEAVE" ) ) { msg = name + " HAS LEFT" ; } return msg ; }
tr	7	private String [ ] getStringArray ( JComponent comp ) { if ( comp instanceof JComboBox ) { JComboBox comboBox = ( JComboBox ) comp ; List < String > list = new ArrayList < String > ( ) ; if ( comboBox . getItemCount ( ) > 0 ) { for ( int i = 0 ; i < comboBox . getItemCount ( ) ; i ++ ) { if ( ! isEmpty ( comboBox . getItemAt ( i ) ) ) { add ( list , comboBox . getItemAt ( i ) ) ; } else if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toArray ( new String [ 1 ] ) ; } else { return null ; } } else { if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; return list . toArray ( new String [ 1 ] ) ; } } } return null ; }
tr	3	protected int readStringHeaderImpl ( ) throws IOException , UBJFormatException { byte type = checkType ( "STRING" , STRING_COMPACT , STRING ) ; int length = 0 ; switch ( type ) { case STRING_COMPACT : length = read ( ) ; break ; case STRING : length = readInt32Impl ( ) ; break ; } if ( length < 0 ) throw new UBJFormatException ( pos , "Encountered a negative (invalid) length of [" + length + "] specified for the STRING value at stream position " + pos + ". Length must be >= 0." ) ; return length ; }
tr	5	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	4	public void loadAbrev ( final MyDatabase mysql ) { String SQL1 = "SELECT abrev FROM sig_professorat where idSGD='" + this . idProfesor + "' " ; try { Statement st = mysql . createStatement ( ) ; ResultSet rs1 = mysql . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { this . abrev = rs1 . getString ( "abrev" ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Profesores . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	7	public static char [ ] [ ] build_trans_block ( int [ ] key_num , String key ) { int col = key_num . length ; int row = 26 / col ; if ( row * col != 26 ) { row += 1 ; } char [ ] [ ] result = new char [ row ] [ col ] ; boolean [ ] filled = new boolean [ 26 ] ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { char cur_c = key . toUpperCase ( ) . charAt ( i ) ; int pos = cur_c - A ; if ( filled [ pos ] ) continue ; result [ cur_row ] [ cur_col ] = cur_c ; filled [ pos ] = true ; if ( cur_col == col - 1 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! filled [ i ] ) { result [ cur_row ] [ cur_col ] = ( char ) ( A + i ) ; filled [ i ] = true ; if ( cur_col == col - 1 ) { cur_col = 0 ; cur_row ++ ; } else { cur_col ++ ; } } } return result ; }
tr	0	public AsnRange to ( long end ) { return to ( Asn . of ( end ) ) ; }
tr	5	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof EulerAngles ) { EulerAngles otherAngle = ( EulerAngles ) other ; if ( FloatingPointUtils . floatEqual ( otherAngle . psi , this . psi ) && FloatingPointUtils . floatEqual ( otherAngle . theta , this . theta ) && FloatingPointUtils . floatEqual ( otherAngle . phi , this . phi ) ) { return true ; } } return false ; }
tr	6	protected List < String > getData ( ) { List < String > dataFields = new LinkedList < String > ( ) ; StringBuilder dataBuff = new StringBuilder ( ) ; char c = nextChar ( ) ; while ( c == [ ) { char prev = contents . charAt ( index ) ; c = nextChar ( ) ; while ( ( c != ] || ( c == ] && prev == \ ) ) && index < contents . length ( ) ) { dataBuff . append ( c ) ; prev = c ; c = nextChar ( ) ; } String buffValue = dataBuff . toString ( ) ; if ( buffValue . length ( ) != 0 ) { dataFields . add ( buffValue ) ; dataBuff = new StringBuilder ( ) ; } c = nextChar ( ) ; } pushChar ( ) ; return dataFields ; }
tr	3	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
tr	4	private void reHeapify ( ArrayList < Step > steps ) { int size = heapValues . length - 1 ; int child = 2 ; while ( child <= size ) { if ( ( child < size ) && ( heapValues [ child ] < heapValues [ child + 1 ] ) ) child ++ ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapCompareStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; if ( heapValues [ child / 2 ] > heapValues [ child ] ) break ; byte temp = heapValues [ child / 2 ] ; heapValues [ child / 2 ] = heapValues [ child ] ; heapValues [ child ] = temp ; arrayValues [ child / 2 ] = heapValues [ child / 2 ] ; arrayValues [ child ] = heapValues [ child ] ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapSwapStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; child *= 2 ; } }
tr	0	@ Override public boolean isList ( ) { return false ; }
tr	7	@ Override public void doMove ( ) { player = game . getCurrentPlayer ( ) ; field = game . getField ( ) ; int width = field . getWidth ( ) ; int height = field . getHeight ( ) ; evaluationResult = new EvalField ( width , height ) ; Exception exception = null ; for ( int i = 0 ; i < width * height ; i ++ ) { fieldcopy = UtilMethods . getCopyOfField ( field ) ; int x = i % width ; int y = i / width ; if ( UtilMethods . isPlacementPossible ( fieldcopy , x , y , player ) ) { String result = "" ; try { result = execute ( fieldcopy , x , y , player ) ; } catch ( Exception e ) { exception = e ; } Integer cellValue = null ; if ( result . equals ( "erfolgreich" ) ) { cellValue = getResult ( ) ; } if ( cellValue == null || cellValue < 0 ) { cellValue = 0 ; } evaluationResult . setValueAt ( x , y , cellValue ) ; } else { evaluationResult . setValueAt ( x , y , - 1 ) ; } } if ( exception != null ) { exception . printStackTrace ( ) ; showErrorMessage ( exception ) ; } chooseBestCell ( ) ; game . selectMove ( bestXCoord , bestYCoord ) ; }
tr	4	public static void run ( class < ? extends Window > clazz , class < ? > [ ] args , Object [ ] param ) { try { executeInstance ( ( Window ) clazz . getConstructor ( args ) . newInstance ( param ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	9X	public static class < ? extends Tag > getTypeClass ( int type ) { switch ( type ) { case NBTConstants . TYPE_END : return EndTag . class ; case NBTConstants . TYPE_BYTE : return ByteTag . class ; case NBTConstants . TYPE_SHORT : return ShortTag . class ; case NBTConstants . TYPE_INT : return IntTag . class ; case NBTConstants . TYPE_LONG : return LongTag . class ; case NBTConstants . TYPE_FLOAT : return FloatTag . class ; case NBTConstants . TYPE_DOUBLE : return DoubleTag . class ; case NBTConstants . TYPE_BYTE_ARRAY : return ByteArrayTag . class ; case NBTConstants . TYPE_STRING : return StringTag . class ; case NBTConstants . TYPE_LIST : return ListTag . class ; case NBTConstants . TYPE_COMPOUND : return CompoundTag . class ; case NBTConstants . TYPE_INT_ARRAY : return IntArrayTag . class ; case NBTConstants . TYPE_LISTSTRING_ARRAY : return ListStringArrayTag . class ; case NBTConstants . TYPE_LISTITEMSTACK_ARRAY : return ListItemStackArrayTag . class ; default : throw new IllegalArgumentException ( "Invalid tag type : " + type + "." ) ; } }
tr	4	public boolean remove ( Object x ) { outprint += "boolean remove Object x\n" ; int h = x . hashCode ( ) ; if ( h < 0 ) { h = - h ; } h = h % buckets . length ; Node current = buckets [ h ] ; Node previous = null ; while ( current != null ) { if ( current . data . equals ( x ) ) { if ( previous == null ) { buckets [ h ] = current . next ; } else { previous . next = current . next ; } currentSize -- ; return true ; } previous = current ; current = current . next ; } return false ; }
tr	5	@ Override public String buildResponse ( ResponseTemplate template , KeyWordList keys ) { Random rand = new Random ( ) ; String response = "" ; for ( int i = 0 ; i < template . response . length ; i ++ ) { response += template . response [ i ] ; if ( template . wordBuckets != null && i < template . wordBuckets . length ) { int select ; if ( template . wordBuckets [ i ] . length != 1 ) select = rand . nextInt ( template . wordBuckets [ i ] . length - 1 ) ; else select = 0 ; if ( fromMemory ( template . wordBuckets [ i ] [ select ] ) ) { String mem = template . wordBuckets [ i ] [ select ] . substring ( 1 ) ; response += memTable . get ( mem ) ; } else { response += template . wordBuckets [ i ] [ select ] ; } } } return response ; }
tr	3	public int checkHorizontalLinePieces ( int row , Symbol sym ) { int flag = 0 ; int column = 0 ; while ( column < board . length ) { if ( board [ row ] [ column ] != null && board [ row ] [ column ] . getSym ( ) == sym ) column += 1 ; else { flag = - 1 ; break ; } } return flag ; }
tr	2	public Rectangle union ( Rectangle rect ) { if ( rect == null || rect . isEmpty ( ) ) return this ; return union ( rect . x , rect . y , rect . width , rect . height ) ; }
tr	0	public String getImage0 ( ) { return image0 ; }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	3	public void initPanel ( ) { this . removeAll ( ) ; texte_options . setForeground ( Color . BLACK ) ; texte_options . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 40 ) ) ; texte_options . setBounds ( 360 , 20 , 500 , 50 ) ; texte . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte2 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte3 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; spinner . setModel ( new SpinnerNumberModel ( fenetre . getModele ( ) . getOptions ( ) . getTailleGrille ( ) , 10 , 20 , 1 ) ) ; switch ( fenetre . getModele ( ) . getOptions ( ) . getNiveauIA ( ) ) { case FACILE : rb_facile . setSelected ( true ) ; break ; case MOYEN : rb_moyen . setSelected ( true ) ; break ; case DIFFICILE : rb_difficile . setSelected ( true ) ; break ; } pan . setLayout ( new GridLayout ( 6 , 1 ) ) ; pan . setBounds ( 50 , 110 , 400 , 410 ) ; pan2 . setLayout ( null ) ; pan2 . setBounds ( 480 , 110 , 360 , 150 ) ; pan3 . setLayout ( null ) ; pan3 . setBounds ( 480 , 300 , 360 , 220 ) ; texte2 . setBounds ( 10 , 10 , 400 , 20 ) ; spinner . setBounds ( 150 , 50 , 60 , 40 ) ; texte3 . setBounds ( 10 , 10 , 300 , 20 ) ; rb_facile . setBounds ( 20 , 50 , 100 , 20 ) ; rb_facile . setBackground ( null ) ; rb_moyen . setBounds ( 20 , 100 , 100 , 20 ) ; rb_moyen . setBackground ( null ) ; rb_difficile . setBounds ( 20 , 150 , 100 , 20 ) ; rb_difficile . setBackground ( null ) ; b_retour . setBounds ( 10 , 550 , 100 , 50 ) ; b_jouer . setBounds ( 780 , 550 , 100 , 50 ) ; bg . add ( rb_facile ) ; bg . add ( rb_moyen ) ; bg . add ( rb_difficile ) ; check1 . setFocusable ( false ) ; check2 . setFocusable ( false ) ; check3 . setFocusable ( false ) ; check4 . setFocusable ( false ) ; check5 . setFocusable ( false ) ; getCoches ( ) ; check1 . setState ( coches [ 0 ] ) ; check2 . setState ( coches [ 1 ] ) ; check3 . setState ( coches [ 2 ] ) ; check4 . setState ( coches [ 3 ] ) ; check5 . setState ( coches [ 4 ] ) ; pan . add ( texte ) ; pan . add ( check1 ) ; pan . add ( check2 ) ; pan . add ( check3 ) ; pan . add ( check4 ) ; pan . add ( check5 ) ; pan2 . add ( texte2 ) ; pan2 . add ( spinner ) ; pan3 . add ( texte3 ) ; pan3 . add ( rb_facile ) ; pan3 . add ( rb_moyen ) ; pan3 . add ( rb_difficile ) ; this . add ( texte_options ) ; this . add ( pan ) ; this . add ( pan2 ) ; this . add ( pan3 ) ; this . add ( b_jouer ) ; this . add ( b_retour ) ; }
tr	8	@ Override public void visit ( CannyEvent cannyEvent ) { try { if ( model . getCurrentImagePath ( ) == null || model . getCurrentImagePath ( ) . isEmpty ( ) ) { throw new Exception ( "Brak pliku wej\u015Bciowego!" ) ; } String low_treshold_str = defaultViewChanger . showCannyParametersDialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new NumberFormatException ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } String high_treshold_str = defaultViewChanger . showCannyParametersDialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new NumberFormatException ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } Canny canny = new Canny ( low_treshold , high_treshold ) ; BufferedImage source ; System . out . println ( "Wczytuje plik \u017Ar\u00F3d\u0142owy..." ) ; source = ImageIO . read ( new File ( model . getCurrentImagePath ( ) ) ) ; System . out . println ( "Uruchamiam algorytm..." ) ; BufferedImage canny_image = canny . process ( source ) ; String output_name = "output/canny.png" ; saveImageToFile ( output_name , canny_image ) ; System . out . println ( "Wy\u015Bwietlam zdj\u0119cie..." ) ; defaultViewChanger . showModImage ( output_name ) ; } catch ( Exception e ) { if ( defaultViewChanger != null ) defaultViewChanger . showInformationDialog ( e . getMessage ( ) , "B\u0142\u0105d" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } }
tr	8	public Vector < Door > nearbyDoors ( Game game ) { Vector < Door > doors = new Vector < Door > ( ) ; for ( Tile tile : game . getMap ( ) . getTiles ( ) ) { if ( ! ( tile instanceof Door ) ) continue ; Door door = ( Door ) tile ; if ( door . getState ( ) == Door . OPEN ) continue ; Rectangle2D door_rect = door . getArea ( ) ; double left = door_rect . getX ( ) ; double right = left + door_rect . getWidth ( ) ; double top = door_rect . getY ( ) ; double bottom = top + door_rect . getHeight ( ) ; double x = fLocation . getX ( ) ; double y = fLocation . getY ( ) ; if ( x < left ) x = left ; if ( x > right ) x = right ; if ( y < top ) y = top ; if ( y > bottom ) y = bottom ; Point2D door_point = new Point2D . double ( x , y ) ; double distance = fLocation . distance ( door_point ) ; distance -= getSize ( ) ; if ( distance <= getReach ( ) ) doors . add ( door ) ; } return doors ; }
tr	9X	public Card [ ] pickCards ( SelectCardOptions sco , Card [ ] allcards ) { GameQuery p = new GameQuery ( QueryType . GETCARD , QueryType . CARD ) . setObject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . CARD ) return null ; if ( p . o instanceof Card [ ] || p . o instanceof String [ ] ) { String [ ] selected ; if ( p . o instanceof Card [ ] ) { ArrayList < String > a = new ArrayList < String > ( ) ; for ( Card c : ( Card [ ] ) p . o ) a . add ( c . getName ( ) ) ; selected = a . toArray ( new String [ 0 ] ) ; } else selected = ( String [ ] ) p . o ; ArrayList < Card > ret = new ArrayList < Card > ( ) ; ArrayList < Card > all = new ArrayList < Card > ( Arrays . asList ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toArray ( new Card [ 0 ] ) ; } return null ; }
tr	7	private static void printHubDetails ( int indent , Device dev ) { try { Hub h = new Hub ( dev ) ; int ports = h . getNumPorts ( ) ; boolean indicator = h . isIndicator ( ) ; indentLine ( indent , ( h . isRootHub ( ) ? "Root " : "" ) + "Hub  " + ports + " ports" ) ; indentLine ( indent , "overcurrent protection: " + h . getOverCurrentMode ( ) ) ; indentLine ( indent , "power switching: " + h . getPowerSwitchingMode ( ) ) ; if ( indicator ) indentLine ( indent , "has port indicator LEDs" ) ; if ( h . isCompound ( ) ) indentLine ( indent , "part of a compound device" ) ; indent -= 4 ; indentLine ( indent , "" ) ; for ( int i = 1 ; i <= ports ; i ++ ) { Device child = dev . getChild ( i ) ; if ( child == null ) continue ; indentLine ( indent , "<!-- Port " + i + ( h . isRemovable ( i ) ? "" : " is built-in." ) + " -->" ) ; printDevice ( indent , child ) ; } } catch ( IOException e ) { e . printStackTrace ( System . out ) ; } }
tr	9X	public boolean isPunch ( ) { switch ( this ) { case BULLET_PUNCH : case COMET_PUNCH : case DIZZY_PUNCH : case DRAIN_PUNCH : case DYNAMICPUNCH : case FIRE_PUNCH : case FOCUS_PUNCH : case HAMMER_ARM : case ICE_PUNCH : case MACH_PUNCH : case MEGA_PUNCH : case METEOR_MASH : case SHADOW_PUNCH : case SKY_UPPERCUT : case THUNDERPUNCH : return true ; default : return false ; } }
tr	6	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
tr	2	public HiddenNeuron ( double gain , double timeConstant , double bias , double selfWeight , double ... sensorWeights ) { this . gain = gain ; this . timeConstant = timeConstant ; this . bias = bias ; this . selfWeight = selfWeight ; this . connections = new ArrayList < Object [ ] > ( ) ; if ( sensorWeights . length != 5 ) try { throw new Exception ( "Wrong amount of weights passed to constructor!" ) ; } catch ( Exception ex ) { Logger . getLogger ( HiddenNeuron . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; ex . printStackTrace ( ) ; } this . sensorWeights = sensorWeights ; }
tr	2	public static void test ( String s ) { String - ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { for ( int i = 1 ; i <= s . length ( ) - c ; i ++ ) { - = s . substring ( c , c + i ) ; System . out . println ( - ) ; } } }
tr	7	HubNode ( Device dev , TreeNode parent ) throws IOException { super ( dev , parent ) ; hub = new Hub ( dev ) ; addr = dev . getAddress ( ) ; if ( isFlatTree ) { if ( hub . isRootHub ( ) ) { Bus bus = dev . getBus ( ) ; children = new USBNode [ 127 ] ; last = 0 ; for ( int i = 1 ; i <= 127 ; i ++ ) { Device d = bus . getDevice ( i ) ; if ( d != null && d != dev ) deviceAdded ( d , null ) ; } } else children = null ; } else { children = new USBNode [ hub . getNumPorts ( ) ] ; last = 0 ; for ( int i = 1 ; i <= children . length ; i ++ ) { Device d = dev . getChild ( i ) ; if ( d != null ) deviceAdded ( d , null ) ; } } }
tr	7	public void xpShopSignLinks ( PlayerInteractEvent event , String [ ] line , Player p , Sign s ) { if ( plugin . config . debug ) { plugin . Logger ( " first line [xpShop] and leftklick!" , "Debug" ) ; } if ( ! plugin . Blacklistcode . startsWith ( "1" , 11 ) ) { plugin . Logger ( " not blacklisted!" , "Debug" ) ; if ( plugin . ListenerShop . blockIsValid ( line , "Interact" , p ) ) { plugin . Logger ( "Shop Links:: " , "Debug" ) ; plugin . Logger ( "Line 1: " + line [ 0 ] , "Debug" ) ; plugin . Logger ( "Line 2: " + line [ 1 ] , "Debug" ) ; plugin . Logger ( "Line 3: " + line [ 2 ] , "Debug" ) ; plugin . Logger ( "Line 4: " + line [ 3 ] , "Debug" ) ; plugin . Logger ( " Block is valid!" , "Debug" ) ; Player player = event . getPlayer ( ) ; if ( plugin . PermissionsHandler . checkpermissions ( p , "xpShop.use" ) ) { plugin . Logger ( "Player: " + p . getName ( ) + " has the permission: xpShop.use" , "Debug" ) ; if ( line [ 1 ] . equalsIgnoreCase ( "AdminShop" ) ) { signHandler . xpShopSignBuyAdmin ( player , line , s ) ; } else { Sign sign = plugin . ListenerShop . findSign ( event . getClickedBlock ( ) ) ; if ( sign != null ) { plugin . Logger ( "sign != null!" , "Debug" ) ; if ( sign . getLine ( 0 ) . equalsIgnoreCase ( "[xpShopSafe]" ) ) { plugin . Logger ( "Safe found!" , "Debug" ) ; signHandler . xpShopSignBuyCon ( player , line , s , sign ) ; } else { plugin . PlayerLogger ( p , plugin . config . safenoSafeonShop , "Error" ) ; } } else { signHandler . xpShopSignBuy ( player , line , s ) ; } } } } } else { plugin . blacklistLogger ( p ) ; event . setCancelled ( true ) ; } }
tr	6	@ Override public byte [ ] toBytes ( Object value ) { String string = ( String ) value ; string = Normalizer . normalize ( string , Normalizer . Form . NFC ) ; if ( ! caseSensitive ) { string = string . toLowerCase ( locale ) ; } byte [ ] bytes = ENCODERS . get ( byteEncodeMode ) . toBytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new RuntimeException ( "Encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
tr	2	@ Override public String toString ( ) { final StringBuilder bld = new StringBuilder ( this . getClass ( ) . getSimpleName ( ) ) . append ( ": " ) ; if ( ! PRIMITIVES . contains ( this . name ) ) { bld . append ( this . packageName != null ? this . packageName : "[default package]" ) . append ( "." ) ; } return bld . append ( this . name ) . toString ( ) ; }
tr	3	public static void main ( String [ ] args ) { double mass , height , BMI ; mass = double . parseDouble ( args [ 0 ] ) ; height = double . parseDouble ( args [ 1 ] ) ; BMI = mass / Math . pow ( height , 2 ) ; if ( BMI < 18.5 ) System . out . println ( "Underweight" ) ; else if ( BMI < 25 ) System . out . println ( "Normal weight" ) ; else if ( BMI < 30 ) System . out . println ( "Overweight" ) ; else System . out . println ( "Obses" ) ; }
tr	6	@ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String uri = request . getRequestURI ( ) ; if ( ! uri . endsWith ( "index.htm" ) && ! uri . endsWith ( "login.htm" ) && ! uri . endsWith ( "logout.htm" ) ) { Login userData = ( Login ) request . getSession ( ) . getAttribute ( Login . class . getName ( ) ) ; if ( userData == null || Util . nullOrEmptyOrBlank ( userData . getEmail ( ) ) || ( new Date ( ) . getTime ( ) - userData . getLastAccessed ( ) ) > 30 * 60 * 1000 ) { response . sendRedirect ( "index.htm" ) ; return false ; } else { userData . setLastAccessed ( new Date ( ) . getTime ( ) ) ; } } return true ; }
tr	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location location = getLocation ( ) ; Location newLocation = findFood ( location ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( location ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
tr	2	protected void pausePlayback ( ) { if ( m_line != null ) { if ( m_status == PLAYING ) { m_line . stop ( ) ; m_status = PAUSED ; notifyEvent ( BasicPlayerEvent . PAUSED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_line . drain ( ) ; } } }
tr	0	public NoSuchColumnException ( String message , Throwable cause ) { super ( message , cause ) ; }
tr	2	@ Override public void mousePressed ( MouseEvent e ) { if ( direction == 0 ) return ; resizing = true ; Component source = e . getComponent ( ) ; pressed = e . getPoint ( ) ; SwingUtilities . convertPointToScreen ( pressed , source ) ; bounds = source . getBounds ( ) ; if ( source instanceof JComponent ) { JComponent jc = ( JComponent ) source ; autoscrolls = jc . getAutoscrolls ( ) ; jc . setAutoscrolls ( false ) ; } }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	0	public void setType ( String type ) { this . type = type ; }
tr	8	public void addEdge ( Edge edge ) { if ( edge == null ) throw new IllegalArgumentException ( ) ; if ( edge . getX ( ) < 0 || edge . getX ( ) >= vertices . length || edge . getY ( ) < 0 || edge . getY ( ) >= vertices . length ) { throw new IllegalArgumentException ( "Wrong edge parameters" ) ; } for ( Edge e : edges ) { if ( e . equals ( edge ) ) { throw new IllegalArgumentException ( "Edge with such parameters already exists" ) ; } } edges . add ( edge ) ; if ( edge . isDirected ( ) ) { vertices [ edge . getX ( ) ] . getEdges ( ) . add ( edge ) ; } else { vertices [ edge . getX ( ) ] . getEdges ( ) . add ( edge ) ; vertices [ edge . getY ( ) ] . getEdges ( ) . add ( edge ) ; } }
tr	8	public static void mouseClicked ( MouseEvent mouseEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleMouse ) { if ( comp . shouldHandleMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceMouse ( ) ) component . mouseClicked ( mouseEvent ) ; } else if ( comp . forceMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } } }
tr	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
tr	9X	@ SuppressWarnings ( "unchecked" ) public List < JZSequenceFile > partition ( List < String > inputFiles , int numPartitions , Comparator < K > comparator , String jobTaskTrackerID ) { final Comparator < K > tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( ( K ) o1 [ 0 ] , ( K ) o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < inputFiles . size ( ) ; i ++ ) { JZSequenceFile file = new JZSequenceFile ( JZFile . LocalFileSystem , inputFiles . get ( i ) , 0 , 0 ) ; inFiles . add ( file ) ; JZSequenceFile . Reader < K , List < V >> reader = new JZSequenceFile . Reader < > ( file ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } List < JZSequenceFile > outFiles = new ArrayList < JZSequenceFile > ( ) ; List < JZSequenceFile . Writer < K , List < V >>> writers = new ArrayList < JZSequenceFile . Writer < K , List < V >>> ( ) ; for ( int i = 0 ; i < numPartitions ; i ++ ) { String fileName = createPartitionFileName ( jobTaskTrackerID , i ) ; JZSequenceFile file = new JZSequenceFile ( JZFile . JZFileSystem , fileName , 0 , 0 ) ; outFiles . add ( file ) ; writers . add ( new JZSequenceFile . Writer < K , List < V >> ( file ) ) ; } List < V > list = new ArrayList < V > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; K preKey = ( K ) firstEntry [ 0 ] ; JZSequenceFile . Reader < K , List < V >> reader = ( JZSequenceFile . Reader < K , List < V >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; K key = ( K ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < K , List < V >> ) entry [ 1 ] ; List < V > value = ( List < V > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < V > ( value ) ; } if ( reader . nextKeyValue ( ) ) { K newKey = ( K ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } for ( int i = 0 ; i < numPartitions ; i ++ ) { writers . get ( i ) . close ( ) ; } return outFiles ; }
tr	4	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	5	@ Override public int hashCode ( ) { int result = gitPath != null ? gitPath . hashCode ( ) : 0 ; result = 31 * result + ( folder != null ? folder . hashCode ( ) : 0 ) ; result = 31 * result + ( filePath != null ? filePath . hashCode ( ) : 0 ) ; result = 31 * result + ( revision != null ? revision . hashCode ( ) : 0 ) ; result = 31 * result + ( charset != null ? charset . hashCode ( ) : 0 ) ; return result ; }
tr	8	@ Override public Vector3f [ ] getAllMinAlongDirection ( Vector3f [ ] result , Vector3f dir , int count , float eps ) { if ( count > 0 ) { eps /= dir . length ( ) ; float dotmindir = vertices [ 0 ] . . ( dir ) ; result [ 0 ] . set ( vertices [ 0 ] ) ; int j = 1 ; for ( int i = vertices . length - 1 ; i > 0 ; i -- ) { final float dotshapedir = vertices [ i ] . . ( dir ) ; if ( dotshapedir <= dotmindir ) { if ( dotshapedir <= dotmindir - eps ) { result [ 0 ] . set ( vertices [ i ] ) ; j = 1 ; } else if ( j < count ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } dotmindir = dotshapedir ; } else if ( j < count && dotshapedir - eps <= dotmindir ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } } for ( ; j < count ; j ++ ) { result [ j ] . set ( 0 , 0 , 0 ) ; } } return result ; }
tr	0	static Date getTimeWarp ( ) { return timeWarp ; }
tr	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	0	public int [ ] getWarps ( ) { return new int [ ] { 0 , 0 , 0 , 0 } ; }
tr	6	private void input ( ) { while ( Keyboard . next ( ) ) { if ( Keyboard . isKeyDown ( Keyboard . KEY_Q ) && Keyboard . getEventKeyState ( ) ) { this . stop ( ) ; } } if ( Mouse . getX ( ) != mpos . x || Mouse . getY ( ) != mpos . y ) { mpos . x = Mouse . getX ( ) ; mpos . y = Mouse . getY ( ) ; changed = true ; } if ( Mouse . isButtonDown ( 0 ) ) { changed = true ; } }
tr	1	@ Override public double getOutputError ( double [ ] outputError ) { double squareErrorSum = 0d ; for ( double error : outputError ) squareErrorSum += ( error * error ) * 0.5 ; return squareErrorSum ; }
tr	1	public void tradeElGamal ( boolean first ) { { p = new BigInteger ( "4988735951183711405443349413015910122453507015594895638933838601555750189585703700647655985269637551634513770201277370413860951650702374379627998821919409" ) ; BigInteger g = new BigInteger ( "4403105895869798297264918950735787070665047406714785361037216842427722734684061748868589917485012596281820467352001338223691996653533143166890875549812531" ) ; BigInteger y = new BigInteger ( "3670294064109445804998782973709772470002041046377612489028768098078250713079795031354099562309432613560558383306865142781216201315104971340333690591679721" ) ; BigInteger x = new BigInteger ( "4589946301809196862611751989088793376762175950291076147544077975213763218505486754450017554342955014202444667772016113058406939298289857995054770609176615" ) ; elGamalC_own = new ElGamalCipher ( p , g , y , x ) ; elGamalS_own = new ElGamalSignature ( p , g , y , x ) ; } if ( first ) { com . sendTo ( 1 , p . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . y . toString ( 16 ) ) ; { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } } else { { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } com . sendTo ( 0 , p . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . y . toString ( 16 ) ) ; } }
tr	9X	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ ( int ) i ] ; } } } return out ; } }
tr	1	private void putStash ( int key , V value ) { if ( stashSize == stashCapacity ) { resize ( capacity << 1 ) ; put ( key , value ) ; return ; } int index = capacity + stashSize ; keyTable [ index ] = key ; valueTable [ index ] = value ; stashSize ++ ; size ++ ; }
tr	7	private void writeFile ( String data , boolean isAppend ) { if ( ! exists ( ) ) { try { createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedWriter bfWriter = null ; try { FileWriter flWriter = null ; if ( isAppend ) { flWriter = new FileWriter ( this , true ) ; } else { flWriter = new FileWriter ( this ) ; } bfWriter = new BufferedWriter ( flWriter ) ; if ( isAppend ) { bfWriter . newLine ( ) ; } bfWriter . write ( data ) ; bfWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( bfWriter != null ) bfWriter . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } }
tr	6	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	9X	public Subscription ( Socket in_sock , iKPIC_subscribeHandler2 hand ) { final iKPIC_subscribeHandler2 f_eh = hand ; final Socket ft_kpSocket = in_sock ; InputStream reader = null ; try { reader = in_sock . getInputStream ( ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } final BufferedReader ft_in = new BufferedReader ( new InputStreamReader ( reader ) ) ; System . out . println ( "Subscription: going to start thread" ) ; Thread eventThread = new Thread ( ) { public void run ( ) { SSAP_XMLTools xmlTools = new SSAP_XMLTools ( null , null , null ) ; String msg_event = "" ; String restOfTheMessage = "" ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; int charRead = 0 ; try { while ( ( ( charRead = ft_in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) || ( ! restOfTheMessage . isEmpty ( ) ) ) { if ( ! restOfTheMessage . equals ( "" ) ) { builder . append ( restOfTheMessage ) ; restOfTheMessage = "" ; } if ( charRead != - 1 ) { builder . append ( buffer , 0 , charRead ) ; } msg_event = builder . toString ( ) ; if ( msg_event . contains ( "<SSAP_message>" ) && msg_event . contains ( "</SSAP_message>" ) ) { int index = msg_event . indexOf ( "</SSAP_message>" ) + 15 ; restOfTheMessage = msg_event . substring ( index ) ; msg_event = msg_event . substring ( 0 , index ) ; String subID = xmlTools . getSubscriptionID ( msg_event ) ; if ( xmlTools . isUnSubscriptionConfirmed ( msg_event ) ) { f_eh . kpic_UnsubscribeEventHandler ( subID ) ; return ; } else { String indSequence = xmlTools . getSSAPmsgIndicationSequence ( msg_event ) ; if ( xmlTools . isRDFNotification ( msg_event ) ) { Vector < Vector < String >> triples_n = new Vector < Vector < String >> ( ) ; triples_n = xmlTools . getNewResultEventTriple ( msg_event ) ; Vector < Vector < String >> triples_o = new Vector < Vector < String >> ( ) ; triples_o = xmlTools . getObsoleteResultEventTriple ( msg_event ) ; f_eh . kpic_RDFEventHandler ( triples_n , triples_o , indSequence , subID ) ; } else { SSAP_sparql_response resp_new = xmlTools . get_SPARQL_indication_new_results ( msg_event ) ; SSAP_sparql_response resp_old = xmlTools . get_SPARQL_indication_obsolete_results ( msg_event ) ; f_eh . kpic_SPARQLEventHandler ( resp_new , resp_old , indSequence , subID ) ; } if ( restOfTheMessage . contains ( "<SSAP_message>" ) && restOfTheMessage . contains ( "</SSAP_message>" ) ) { String test = restOfTheMessage . substring ( 0 , restOfTheMessage . indexOf ( "</SSAP_message>" ) + 15 ) ; if ( xmlTools . isUnSubscriptionConfirmed ( test ) ) { System . out . println ( "I should never print this please check" ) ; return ; } } buffer = new char [ buffsize ] ; charRead = 0 ; msg_event = "" ; builder = new StringBuilder ( ) ; } } } try { System . out . println ( "I should not go here untili unsubscribe" ) ; ft_in . close ( ) ; ft_kpSocket . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } } ; eventThread . start ( ) ; }
tr	4	@ Override public void collidedWith ( Entity other ) { if ( other instanceof UnbreakableEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof BreakableEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof BombeEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof ExplosionEntity ) { this . state = STATE . DEAD ; } else { this . setHorizontalSpeedMovement ( 1 ) ; this . setVerticalSpeedMovement ( 1 ) ; } }
tr	9X	private void move ( ACTION action2 ) { int newposX = posX ; int newposY = posY ; System . out . println ( "pos:" + posX / 32 + ":" + posY / 32 ) ; if ( currentAction == action2 ) { showFrame = ( showFrame + 1 ) % 9 ; } else { showFrame = 0 ; } switch ( action2 ) { case GODOWN : newposY = ( int ) ( posY + spead ) ; facing = DIRECTION . SOUTH ; break ; case GOUP : facing = DIRECTION . NORTH ; newposY = ( int ) ( posY - spead ) ; break ; case GOLEFT : newposX = ( int ) ( posX - spead ) ; facing = DIRECTION . WEST ; break ; case GORIGTH : newposX = ( int ) ( posX + spead ) ; facing = DIRECTION . EAST ; break ; case RUNUP : facing = DIRECTION . NORTH ; newposY = ( int ) ( posY - ( spead * 3 ) ) ; break ; case RUNDOWN : newposY = ( int ) ( posY + ( spead * 3 ) ) ; facing = DIRECTION . SOUTH ; break ; case RUNRIGTH : newposX = ( int ) ( posX + ( spead * 3 ) ) ; facing = DIRECTION . EAST ; break ; case RUNLEFT : newposX = ( int ) ( posX - ( spead * 3 ) ) ; facing = DIRECTION . WEST ; break ; default : break ; } if ( GameModel . GetWorldMap ( ) . checkPositionIsOk ( newposX + 16 , newposY + 46 , newposX + 44 , newposY + 64 - 5 ) ) { posX = newposX ; posY = newposY ; } }
tr	9X	public static void main ( String argv [ ] ) { try { if ( argv . length != 1 ) { System . err . println ( "USBD [ start | stop ]" ) ; System . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { Host host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USBD:  USB is not available." ) ; System . exit ( 1 ) ; } if ( host instanceof Remote ) { System . err . println ( "USBD: proxy already registered" ) ; System . exit ( 1 ) ; } try { HostProxy proxy = new HostProxy ( host ) ; Naming . bind ( rmiName , proxy ) ; System . err . println ( "USBD:  Bound RMI name " + rmiName ) ; } catch ( Exception e ) { System . err . println ( "USBD:  Couldn't bind to: " + rmiName ) ; if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { System . err . println ( "USBD: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { System . err . println ( "USBD: no '" + argv [ 0 ] + "' command" ) ; System . exit ( 1 ) ; } } catch ( Exception e ) { if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } }
tr	3	public Info ( java . awt . Frame parent ) throws InterruptedException { super ( parent , true ) ; initComponents ( ) ; a = new Methods ( ) . LFname ( query . GetKeyName ( ) ) ; data = query . Info ( 0 , false , a [ 1 ] , a [ 0 ] , true ) ; id . setText ( data [ 0 ] ) ; name . setText ( data [ 2 ] + "  " + data [ 1 ] ) ; gender . setText ( data [ 3 ] ) ; pos . setText ( data [ 4 ] ) ; birth . setText ( data [ 5 ] ) ; age . setText ( String . valueOf ( new Methods ( ) . DateToAge ( data [ 5 ] ) ) ) ; if ( data [ 6 ] . equals ( "" ) ) data [ 6 ] = "[no data]" ; cont . setText ( data [ 6 ] ) ; if ( data [ 7 ] . equals ( "" ) ) data [ 7 ] = "[no data]" ; addr . setText ( data [ 7 ] ) ; date . setText ( data [ 8 ] ) ; infoP . setVisible ( data [ 6 ] . equalsIgnoreCase ( "[no data]" ) || data [ 7 ] . equalsIgnoreCase ( "[no data]" ) ) ; }
tr	9X	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	9X	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	1	public String informaNomeJogador ( int posicao ) { if ( posicao == 1 ) { return jogador1 . obterNome ( ) ; } else { return jogador2 . obterNome ( ) ; } }
tr	5	public static MinimumCostInsertionInfo minimumCostInsertionPosition ( ProblemInstance problemInstance , int vehicle , int client , ArrayList < Integer > route ) { double min = 99999999 ; int chosenInsertPosition = - 1 ; double cost ; double [ ] [ ] costMatrix = problemInstance . costMatrix ; int depotCount = problemInstance . depotCount ; int depot = problemInstance . depotAllocation [ vehicle ] ; if ( route . size ( ) == 0 ) { MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; info . insertPosition = 0 ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; } cost = 0 ; cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( 0 ) ] ; cost -= ( costMatrix [ depot ] [ depotCount + route . get ( 0 ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = 0 ; } for ( int insertPosition = 1 ; insertPosition < route . size ( ) ; insertPosition ++ ) { cost = costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( insertPosition ) ] ; cost -= ( costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + route . get ( insertPosition ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = insertPosition ; } } cost = costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; cost -= ( costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depot ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = route . size ( ) ; } MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = min ; info . insertPosition = chosenInsertPosition ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	7	@ Override public long [ ] getLongData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; long [ ] out = new long [ ( int ) length ] ; long elem = ( long ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { long [ ] res = new long [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( long ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	4	public void move ( ) { m_x += m_velocityX ; m_y += m_velocityY ; if ( m_x < 0 ) { m_x = 0 ; m_velocityX = - m_velocityX ; } else if ( m_x > m_rightBound ) { m_x = m_rightBound ; m_velocityX = - m_velocityX ; } if ( m_y < 0 ) { m_y = 0 ; m_velocityY = - m_velocityY ; } else if ( m_y > m_bottomBound ) { m_y = m_bottomBound ; m_velocityY = - m_velocityY ; } }
tr	1	@ Override public Set < java . util . Map . Entry < K , V >> entrySet ( ) { if ( this . entrySet == null ) { this . entrySet = new EntrySet ( ) ; } return this . entrySet ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	2	int clip ( int t , int lo , int hi ) { return t < lo ? lo : t > hi ? hi : t ; }
tr	5	public boolean canAppend ( WriteCommand command ) throws IOException { switch ( command . opItem . op ) { case OpItem . OP_DEL : if ( command . opItem . number != this . number ) { return false ; } break ; case OpItem . OP_ADD : if ( this . dataFile . getLength ( ) + command . data . length >= JournalStore . FILE_SIZE ) { return false ; } if ( this . dataSize + command . data . length >= DataFileAppender . this . maxWriteBatchSize ) { return false ; } break ; default : throw new RuntimeException ( "Unknow op type " + command . opItem ) ; } return true ; }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case ID : if ( value == null ) { unsetId ( ) ; } else { setId ( ( Integer ) value ) ; } break ; case NOME : if ( value == null ) { unsetNome ( ) ; } else { setNome ( ( String ) value ) ; } break ; case EMAIL : if ( value == null ) { unsetEmail ( ) ; } else { setEmail ( ( String ) value ) ; } break ; case DATA : if ( value == null ) { unsetData ( ) ; } else { setData ( ( String ) value ) ; } break ; } }
tr	7	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { boolean canlogin = true ; Pattern pattern = Pattern . compile ( SecurityPattern . EMAIL_PATTERN ) ; Matcher matcher = pattern . matcher ( request . getParameter ( MappedNames . MAIL ) . toString ( ) ) ; if ( ! matcher . matches ( ) ) { request . setAttribute ( "error" , MappedErrors . MAIL_INVALIDE ) ; canlogin = false ; } pattern = Pattern . compile ( SecurityPattern . PASSWORD_PATTERN ) ; matcher = pattern . matcher ( request . getParameter ( MappedNames . PASSWORD ) . toString ( ) ) ; if ( ! matcher . matches ( ) ) { request . setAttribute ( "error" , MappedErrors . PASSWORD_INVALIDE ) ; canlogin = false ; } if ( canlogin ) { try { TransporteurDAO dao = new TransporteurDAO ( ) ; TrasporteurBean pojo = dao . getByMail ( request . getParameter ( MappedNames . MAIL ) . toString ( ) ) ; if ( ! pojo . getMail ( ) . equals ( null ) ) { if ( pojo . getPassword ( ) . equals ( request . getParameter ( MappedNames . PASSWORD ) . toString ( ) ) ) { HttpSession session = request . getSession ( true ) ; pojo . setPassword ( "" ) ; session . setAttribute ( "user" , pojo ) ; response . sendRedirect ( MappedJsp . HOME ) ; } else { request . setAttribute ( "error" , MappedErrors . MAUVAIS_PASSWORD ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } } } catch ( NullPointerException e ) { request . setAttribute ( "error" , MappedErrors . MAUVAIS_MAIL ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; request . setAttribute ( "error" , MappedErrors . GENERAL_ERROR ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } } else { this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } }
tr	7	public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
tr	6	public void openFile ( String fileName ) { if ( m_bMpegPlaying ) { m_bKeepRunning = false ; } if ( m_inputStream != null ) { try { m_inputStream . close ( ) ; } catch ( IOException e ) { showDialog ( WARNING , e . getMessage ( ) ) ; } } if ( fileName != null ) { try { try { URL url = new URL ( fileName ) ; m_inputStream = new java . io . BufferedInputStream ( url . openStream ( ) ) ; } catch ( MalformedURLException e ) { m_inputStream = new java . io . BufferedInputStream ( new FileInputStream ( fileName ) ) ; } } catch ( IOException e ) { showDialog ( ERROR , e . getMessage ( ) ) ; } } else showDialog ( ERROR , "null FileName" ) ; }
tr	2	public long inserir ( InstituicaoCooperadora instituicaocooperadora ) throws Exception { String sql = "INSERT INTO instituicaocooperadora(nome) VALUES (?)" ; long idGerado = 0 ; try { PreparedStatement stmt = ConnectionFactory . getConnection ( ) . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; stmt . setString ( 1 , instituicaocooperadora . getNome ( ) ) ; stmt . executeUpdate ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { idGerado = rs . getLong ( 1 ) ; } } catch ( SQLException e ) { throw e ; } return idGerado ; }
tr	0	public List < String > complete ( String string , int position ) { return CompletionUtil . completeStrings ( strings , string ) ; }
tr	4	public void selectSort ( int [ ] data ) { if ( data == null ) { throw new NullPointerException ( "Input array is null." ) ; } for ( int i = 0 ; i < data . length ; i ++ ) { int small = i , tmp ; for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ small ] > data [ j ] ) { small = j ; } } tmp = data [ i ] ; data [ i ] = data [ small ] ; data [ small ] = tmp ; } }
tr	2	@ Override public ArrayList < ProduktBatchKompDTO > getProduktBatchKompList ( int pbId ) throws DALException { ArrayList < ProduktBatchKompDTO > list = new ArrayList < ProduktBatchKompDTO > ( ) ; ResultSet rs = Connector . doQuery ( "SELECT pbk.*  rb.*  r.* FROM produktbatchkomponent pbk  raavarebatch rb  raavare r WHERE pbk.rb_id = rb.rb_id AND rb.raavare_id = r.raavare_id AND pbk.pb_id =  " + pbId ) ; try { while ( rs . next ( ) ) { RaavareDTO raavare = new RaavareDTO ( rs . getInt ( 10 ) , rs . getString ( 11 ) ) ; RaavareBatchDTO raavareBatch = new RaavareBatchDTO ( rs . getInt ( 5 ) , raavare , rs . getDouble ( 7 ) , rs . getTimestamp ( 8 ) , rs . getString ( 9 ) ) ; list . add ( new ProduktBatchKompDTO ( rs . getInt ( 1 ) , raavareBatch , rs . getDouble ( 3 ) , rs . getDouble ( 4 ) ) ) ; } } catch ( SQLException e ) { throw new DALException ( e ) ; } return list ; }
tr	5	public static String toString ( float [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	2	private boolean isMatchingRightChild ( ASTNode rightChild ) { if ( rightChildMatcher == null ) { return true ; } if ( rightChild == null ) { return false ; } return rightChildMatcher . matches ( this , rightChild ) ; }
tr	2	@ Override public boolean readResponse ( String [ ] first_line , InputStream in ) throws BeanstalkcException , IOException { if ( first_line [ 0 ] . equals ( "BURIED" ) ) { return true ; } else if ( first_line [ 0 ] . equals ( "NOT_FOUND" ) ) { throw new JobNotFoundException ( String . format ( "Job %d not found  it may not exist or not be reserved by this client" , job_id ) ) ; } return false ; }
tr	1	public void update ( double ad [ ] , double d ) { for ( int i = 0 ; i < mFilters . length ; i ++ ) { mFilters [ i ] . update ( ad [ i ] , d ) ; } }
tr	2	@ NotNull @ Override public FileContent fileContentBefore ( ) { if ( filePathBefore . equals ( noFilePath ) ) return FileContent . none ; LogFileContentResult logFileContentResult = vcsRoot . get ( ) . logFileContent ( filePathBefore , revisionBefore ) ; return logFileContentResult . isSuccessful ( ) ? new FileContent ( logFileContentResult . text ( ) ) : FileContent . failedToLoad ; }
tr	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
tr	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
tr	9X	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) Math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) Math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
tr	7	@ Override public JsonElement serialize ( Criteria criteria , Type type , JsonSerializationContext jsc ) { JsonObject json = new JsonObject ( ) ; json . addProperty ( "field" , criteria . getField ( ) . ordinal ( ) + 1 ) ; try { String operator = criteria . getOperator ( ) . toString ( ) ; if ( operator . equals ( Operators . StartWith . toString ( ) ) ) operator = "START%20WITH" ; else if ( operator . equals ( Operators . Equals . toString ( ) ) ) operator = URLEncoder . encode ( "=" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThan . toString ( ) ) ) operator = URLEncoder . encode ( ">" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( ">=" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThan . toString ( ) ) ) operator = URLEncoder . encode ( "<" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( "<=" , "UTF-8" ) ; json . addProperty ( "operator" , operator ) ; } catch ( UnsupportedEncodingException ex ) { Logger . getLogger ( CriteriaSerializer . class . getName ( ) ) . log ( Level . SEVERE , "Wrong encoding scheme!" , ex ) ; } json . addProperty ( "value" , criteria . getValue ( ) ) ; return json ; }
tr	0	public void validate ( ) throws org . apache . thrift7 . TException { }
tr	3	public static int getPedidosNatural ( Perfil perfil ) throws SQLException { if ( perfil != null ) { sql = "SELECT SUM(CANTIDAD) " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND " + "(COLOR = {COLOR}) AND (IDPERFIL = '{PERFIL}' ));" ; sql = sql . replace ( "{COLOR}" , Integer . toString ( ColorDP . ID_NATURAL ) ) ; sql = sql . replace ( "{PERFIL}" , perfil . getIdperf ( ) ) ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null && rs . next ( ) ) { return rs . getInt ( 1 ) ; } } } return 0 ; }
tr	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	5	@ Override public void actionPerformed ( ActionEvent e ) { JMenuItem popup = ( JMenuItem ) e . getSource ( ) ; String name = popup . getName ( ) ; switch ( name ) { case "add track" : List < TrackBean > selectedTracks = view . getSelectedTracks ( ) ; model . addTracksToPlaylist ( selectedTracks ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "add album" : AlbumBean selectedAlbum = view . getSelectedAlbum ( ) ; model . addTracksToPlaylist ( selectedAlbum . getTracks ( ) ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "clear playlist" : model . stopSong ( false ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "remove track" : removeTracks ( ) ; break ; case "get info" : view . displayInfoDialog ( view . getSelectedTracks ( ) . get ( 0 ) ) ; break ; } }
tr	3	private void addMountanSides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existTileOfType ( new Mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new MountainSide ( ) ) ; map [ i ] [ j + 2 ] . add ( new MountainSide ( ) ) ; } } } }
tr	4	public static String readAsString ( File file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; InputStream is = null ; try { is = new FileInputStream ( file ) ; is . read ( bytes ) ; } catch ( IOException e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ex ) { return null ; } } try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	0	public int getIdp ( ) { return this . idp ; }
tr	1	public void closeWriter ( ) { try { this . writer . flush ( ) ; this . writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	9X	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	2	@ Override public String filterReplacedString ( FilterBypass fb , int offset , int length , String str , AttributeSet attrs ) { if ( str == null ) return "" ; int remaining = limit - fb . getDocument ( ) . getLength ( ) + length ; if ( remaining > str . length ( ) ) { return str ; } else { return str . substring ( 0 , remaining ) ; } }
tr	8	String classToType ( class cls ) { if ( cls == Point . class ) { return "int2" ; } else if ( cls == Integer . TYPE || cls == Integer . class ) { return "int" ; } else if ( cls == double . TYPE || cls == double . class ) { return "double" ; } else if ( cls == String . class ) { return "String" ; } else if ( cls == boolean . TYPE || cls == boolean . class ) { return "boolean" ; } else { return null ; } }
tr	4	@ Override public void run ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Message > responses ) { responses . add ( MSG ( msgInfo . ROOM , msgInfo . NICK + " has been marked as away.  Use !back to rejoin." ) ) ; Name name = gameManager . m_nickToNameMap . get ( msgInfo . NICK ) ; ata . m_activePlayers . remove ( name ) ; if ( ata . m_activePlayers . size ( ) < 3 ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botendgame " + msgInfo . ROOM ) ) ; } if ( ata . m_judge . equals ( msgInfo . NICK ) ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botcleanup " + msgInfo . ROOM ) ) ; } else if ( ata . m_state == State . PLAY ) { ata . m_waiting . remove ( name ) ; if ( ata . m_waiting . size ( ) == 0 ) { ata . m_waiting . remove ( name ) ; responses . add ( MSG ( gameManager . getName ( ) , "!botchoose " + msgInfo . ROOM ) ) ; } } }
tr	1	public void executar ( AmbienteExecucao ambiente ) { try { comando . executar ( ambiente ) ; } catch ( IdentificadorJaDeclaradoException | IdentificadorNaoDeclaradoException e ) { e . printStackTrace ( ) ; } }
tr	1	public static INDITextProperty createSaveableTextProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission ) throws IllegalArgumentException { INDITextProperty tp = loadTextProperty ( driver , name ) ; if ( tp == null ) { tp = new INDITextProperty ( driver , name , label , group , state , permission ) ; tp . setSaveable ( true ) ; } return tp ; }
tr	8	private static Map < class < ? extends Entity > , Integer > getEntitiesConf ( List < AnimalQuantite > animalsList2 ) { Map < class < ? extends Entity > , Integer > entitiesConf = new HashMap < > ( ) ; for ( AnimalQuantite animalQuantite : animalsList2 ) { class < ? extends Entity > entityClass = null ; switch ( animalQuantite . getName ( ) ) { case CTHULI : entityClass = Cthuli . class ; break ; case SPIDER : entityClass = Spider . class ; break ; case ANT : entityClass = Ant . class ; break ; case HUMAN : entityClass = Human . class ; break ; } entitiesConf . put ( entityClass , animalQuantite . getNum ( ) ) ; } return entitiesConf ; }
tr	0	@ Override protected void drawComponentBody ( Graphics2D g ) { int [ ] xx = { x , x + width / 6 , x + width - width / 6 , x + width , x + width , x + width - width / 6 , x + width / 6 , x } ; int [ ] yy = { y + height / 6 , y , y , y + height / 6 , y + height - height / 6 , y + height , y + height , y + height - height / 6 } ; g . drawPolygon ( xx , yy , xx . length ) ; Stroke strokeSave = g . getStroke ( ) ; g . setStroke ( new BasicStroke ( 0.5f ) ) ; g . drawPolygon ( new int [ ] { x , x + width , x + width , x } , new int [ ] { y , y , y + height , y + height } , 4 ) ; g . setStroke ( strokeSave ) ; }
tr	4	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
tr	8	private void updateClaim ( boolean choice1 ) { switch ( claim . getStatus ( ) ) { case UnRanked : claim . rank ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ; JOptionPane . showMessageDialog ( form , "The claim has been ranked " + ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ) ; break ; case Ranked : claim . setStatus ( choice1 ? Claim . Status . Confirmed : Claim . Status . Declined ) ; if ( choice1 ) { String billingInfo = AutomaticCustomerEmulator . sendForm ( ) ; storage . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , billingInfo ) ; } else AutomaticCustomerEmulator . sendMail ( "Your claim was denied" ) ; JOptionPane . showMessageDialog ( form , "The claim has been " + ( choice1 ? "confirmed" : "declined" ) ) ; break ; default : return ; } storage . updateClaim ( claim ) ; if ( listener != null ) { listener . actionPerformed ( new ActionEvent ( this , 0 , null ) ) ; } }
tr	6	public void render ( VPoint cm , VGame vg , VGraphics g ) { if ( l > 0 ) { l -- ; } if ( l <= 0 ) { return ; } VPoint v = new VPoint ( s . x - cm . x , s . y - cm . y , s . z ) ; VPoint osv = VConvert . to2DPoint ( v . x , v . y , v . z ) ; switch ( i ) { case 1 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 2 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 32 , 32 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 2 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 8 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 16 , 16 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 3 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "bullet" , g , 7 - l , v ) ; break ; case 4 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "gauss_bullet" , g , 5 - l , v ) ; break ; default : } }
tr	5	@ Override public boolean equals ( Object o ) { return o != null && o . getClass ( ) . equals ( this . getClass ( ) ) && ( ( ( ( EduAVLTree ) o ) . root == null && this . root == null ) || ( this . root != null && this . root . equals ( ( ( EduAVLTree ) o ) . root ) ) ) ; }
tr	6	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position != 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
tr	9X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	3	public String [ ] adjudicate ( final int lineNumber , final String orig , final String [ ] hdr , final String [ ] flds ) { final int n = hdr . length ; String [ ] res = new String [ n ] ; for ( int i = 0 ; ( i < flds . length ) && ( i < n ) ; ++ i ) { res [ i ] = flds [ i ] ; } for ( int i = flds . length ; i < n ; ++ i ) { res [ i ] = "" ; } return res ; }
tr	0	public Arctg ( double acc ) { super ( acc ) ; }
tr	1	public static void inorder ( BSTNode current ) { if ( current == null ) return ; inorder ( current . getLeft ( ) ) ; System . out . print ( current . getData ( ) + " " ) ; inorder ( current . getRight ( ) ) ; }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	0	public String getFirstName ( ) { return firstName ; }
tr	0	MARKET ( String ... urlStrings ) { this . urlStrings = urlStrings ; }
tr	6	@ Override public void run ( ) { Player [ ] players = plugin . getServer ( ) . getOnlinePlayers ( ) ; Player player ; long configTime = plugin . getConfig ( ) . getInt ( "KICK_TIMER" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastMoved = 0 ; player = players [ i ] ; UserTable ut = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "userName" , player . getName ( ) ) . = ( "afk" , true ) . findUnique ( ) ; if ( ut == null ) { return ; } lastMoved = System . currentTimeMillis ( ) - ut . getAfkTime ( ) ; if ( player . isOp ( ) ) { if ( plugin . getConfig ( ) . getBoolean ( "KICK_OP" ) ) { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } else { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } }
tr	3	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ProjectUser ) ) { return false ; } ProjectUser other = ( ProjectUser ) object ; if ( ( this . projectUserPK == null && other . projectUserPK != null ) || ( this . projectUserPK != null && ! this . projectUserPK . equals ( other . projectUserPK ) ) ) { return false ; } return true ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Schedule schedule = ( Schedule ) o ; if ( id != schedule . id ) return false ; if ( seqNumber != schedule . seqNumber ) return false ; return true ; }
tr	4	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	1	public AsynchronousCursor ( int batchSize , Factory < T > factory ) { this . strategy = new AdaptiveStrategy < T > ( Math . round ( ( batchSize - 1 ) / 2 ) , batchSize , factory ) ; queue = new ArrayBlockingQueue < T > ( batchSize * 2 ) ; worker = new Worker ( ) ; new Thread ( worker ) . start ( ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
tr	4	@ Override public boolean equals ( Object other ) { if ( other == null ) { return false ; } if ( other == this ) { return true ; } if ( other . getClass ( ) . equals ( this . getClass ( ) ) ) { DayMonthInYear otherDayOfMonth = ( DayMonthInYear ) other ; return this . day == otherDayOfMonth . day && this . month == otherDayOfMonth . month ; } return false ; }
tr	0	public void setPrpMoaTipo ( String prpMoaTipo ) { this . prpMoaTipo = prpMoaTipo ; }
tr	2	public Dienbienluong findById ( java . lang . Integer id ) { log . debug ( "getting Dienbienluong instance with id: " + id ) ; try { Dienbienluong instance = ( Dienbienluong ) sessionFactory . getCurrentSession ( ) . get ( "edu.hust.k54.persistence.Dienbienluong" , id ) ; if ( instance == null ) { log . debug ( "get successful  no instance found" ) ; } else { log . debug ( "get successful  instance found" ) ; } return instance ; } catch ( RuntimeException re ) { log . error ( "get failed" , re ) ; throw re ; } }
tr	2	public boolean isAlive ( ) { if ( ! isAlive ) { if ( location != null ) { field . clear ( location ) ; location = null ; field = null ; } } return isAlive ; }
tr	9X	public static void invert ( double src [ ] [ ] , double dst [ ] [ ] ) { gaussian ( src , a ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) b [ i ] [ i ] = i == j ? 1 : 0 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = i + 1 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) b [ index [ j ] ] [ k ] -= a [ index [ j ] ] [ i ] * b [ index [ i ] ] [ k ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dst [ 4 - 1 ] [ i ] = b [ index [ 4 - 1 ] ] [ i ] / a [ index [ 4 - 1 ] ] [ 4 - 1 ] ; for ( int j = 2 ; j >= 0 ; j -- ) { dst [ j ] [ i ] = b [ index [ j ] ] [ i ] ; for ( int k = j + 1 ; k < 4 ; k ++ ) dst [ j ] [ i ] -= a [ index [ j ] ] [ k ] * dst [ k ] [ i ] ; dst [ j ] [ i ] /= a [ index [ j ] ] [ j ] ; } } }
tr	0	public static void sort ( Comparable [ ] array ) { }
tr	4	public static StroopTest createRandomColourTest ( int wordSize , TestType type ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; Random randomizer = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { int next = randomizer . nextInt ( 2 ) ; switch ( next ) { case 0 : { words . add ( WordFactory . createRandomPlainColourWord ( ) ) ; break ; } case 1 : { words . add ( WordFactory . createRandomColourWord ( ) ) ; break ; } case 2 : { words . add ( WordFactory . createRandomMixedColourWord ( ) ) ; break ; } } } return new StroopTest ( words , type , "RANDOM" , "" ) ; }
tr	7	public Vector < String > enumDatabases ( ) { Vector < String > instances = new Vector < String > ( ) ; Connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errMsg = "Can't connect to management database" ; return instances ; } Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { while ( r . next ( ) ) { String name = r . getString ( "datname" ) ; instances . add ( name ) ; } } } errMsg = null ; } catch ( SQLException e ) { errMsg = e . getMessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( SQLException e ) { } } return instances ; }
tr	9X	public void checkCollision ( JGEngineInterface eng , int srccid , int dstcid ) { if ( in_parallel_upd ) throw new JGameError ( "Recursive call" , true ) ; in_parallel_upd = true ; if ( objects . size > srcobj . length ) { srcobj = new JGObject [ objects . size + 50 ] ; dstobj = new JGObject [ objects . size + 50 ] ; } int srcsize = 0 ; int dstsize = 0 ; JGRectangle sr = tmprect1 ; JGRectangle dr = tmprect2 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o . is_suspended ) continue ; if ( ! o . getBBox ( sr ) ) continue ; if ( ( o . colid & srccid ) != 0 ) { srcobj [ srcsize ++ ] = o ; } if ( ( o . colid & dstcid ) != 0 ) { dstobj [ dstsize ++ ] = o ; } } for ( int si = 0 ; si < srcsize ; si ++ ) { JGObject srco = srcobj [ si ] ; if ( ! srco . getBBox ( sr ) ) continue ; for ( int di = 0 ; di < dstsize ; di ++ ) { JGObject dsto = dstobj [ di ] ; if ( dsto == srco ) continue ; if ( ! dsto . getBBox ( dr ) ) continue ; if ( sr . intersects ( dr ) ) { try { dsto . hit ( srco ) ; } catch ( JGameError ex ) { eng . exitEngine ( eng . dbgExceptionToString ( ex ) ) ; } catch ( Exception ex ) { eng . dbgShowException ( dsto . getName ( ) , ex ) ; } } } } flushRemoveList ( ) ; in_parallel_upd = false ; }
tr	4	public static void solve ( int k , int ct ) { int i , j ; if ( k < ct && k >= 0 ) { i = blan [ k ] / 9 ; j = blan [ k ] % 9 ; for ( int fill = 1 ; fill <= 9 ; fill ++ ) { if ( checkitnow ( i , j , fill ) ) { sudoku [ i ] [ j ] = fill ; solve ( ++ k , ct ) ; k -- ; } } sudoku [ i ] [ j ] = 0 ; } else { answer ++ ; printsudoku ( ) ; } }
tr	2	private void getReply ( DatagramSocket socket ) { while ( true ) { try { byte [ ] replybuffer = new byte [ 1024 ] ; DatagramPacket reply = new DatagramPacket ( replybuffer , replybuffer . length ) ; socket . receive ( reply ) ; System . out . println ( new String ( reply . getData ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof OAuthToken ) ) return false ; OAuthToken that = ( OAuthToken ) o ; if ( secretKeySpec != null ? ! secretKeySpec . equals ( that . secretKeySpec ) : that . secretKeySpec != null ) return false ; if ( ! token . equals ( that . token ) ) return false ; if ( ! tokenSecret . equals ( that . tokenSecret ) ) return false ; return true ; }
tr	7	public void put ( String key , MqttPersistable message ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; File backupFile = new File ( clientDir , key + MESSAGE_FILE_EXTENSION + MESSAGE_BACKUP_FILE_EXTENSION ) ; if ( file . exists ( ) ) { boolean result = file . renameTo ( backupFile ) ; if ( ! result ) { backupFile . delete ( ) ; file . renameTo ( backupFile ) ; } } try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( message . getHeaderBytes ( ) , message . getHeaderOffset ( ) , message . getHeaderLength ( ) ) ; if ( message . getPayloadBytes ( ) != null ) { fos . write ( message . getPayloadBytes ( ) , message . getPayloadOffset ( ) , message . getPayloadLength ( ) ) ; } fos . getFD ( ) . sync ( ) ; fos . close ( ) ; if ( backupFile . exists ( ) ) { backupFile . delete ( ) ; } } catch ( IOException ex ) { throw new MqttPersistenceException ( ex ) ; } finally { if ( backupFile . exists ( ) ) { boolean result = backupFile . renameTo ( file ) ; if ( ! result ) { file . delete ( ) ; backupFile . renameTo ( file ) ; } } } }
tr	4	@ Override public Pizza createPizza ( String type ) { Pizza pizza = null ; if ( type . equals ( "cheese" ) ) { pizza = new ChicagoStyleCheesePizza ( ) ; } else if ( type . equals ( "pepperoni" ) ) { pizza = new ChicagoStylePepperoniPizza ( ) ; } else if ( type . equals ( "clam" ) ) { pizza = new ChicagoStyleClamPizza ( ) ; } else if ( type . equals ( "veggie" ) ) { pizza = new ChicagoStyleVeggiePizza ( ) ; } return pizza ; }
tr	3	public static String StrFill ( String fillStr , String oldStr , int length , String place ) { StringBuffer sb = new StringBuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldStr ) ; } for ( int i = 0 ; i < ( length - oldStr . length ( ) ) ; i ++ ) { sb . append ( fillStr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldStr ) ; } return sb . toString ( ) ; }
tr	6	private JsonSchema parse ( JsonNode rawSchema , URL currentSchemaLocation ) { if ( ! rawSchema . isObject ( ) ) { throw new IllegalArgumentException ( "A valid json schema must be an object" ) ; } JsonNode ref = rawSchema . get ( "$ref" ) ; if ( ref != null ) { URL referencedSchemaLocation ; try { referencedSchemaLocation = new URL ( currentSchemaLocation , ref . textValue ( ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( "The schema reference is malformed" , e ) ; } scheduleSchemaForProcessing ( referencedSchemaLocation ) ; return new SchemaReference ( cache , referencedSchemaLocation ) ; } String type = rawSchema . get ( "type" ) . asText ( ) ; if ( isSimpleTypeSchema ( type ) ) { return parseSimpleTypeSchema ( rawSchema ) ; } else if ( isObjectSchema ( type ) ) { return parseObjectSchema ( rawSchema , currentSchemaLocation ) ; } else if ( isArraySchema ( type ) ) { return parseArraySchema ( rawSchema , currentSchemaLocation ) ; } throw new IllegalArgumentException ( "Illegal schema type " + type ) ; }
tr	0	public void draw ( Graphics g ) { double dist = Point . distance ( origX , origY , lastX , lastY ) / panel . getMap ( ) . getPixelsPerFoot ( ) ; String distTxt = FormatUtils . formatDist ( dist ) ; statusBar . setText ( "Distance: " + distTxt ) ; g . setColor ( Color . WHITE ) ; g . drawLine ( origX , origY , lastX , lastY ) ; g . drawString ( distTxt , lastX , lastY ) ; }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	5	public SLA checkSLAAllocationCostMin ( SLA slaTemplate ) { SLA slaAllocation = ( SLA ) slaTemplate . clone ( ) ; Map < String , Type [ ] > allocations = new HashMap < String , Type [ ] > ( ) ; Set < Type > allTypes = slaAllocation . getHeadNode ( ) . getConnectedTypes ( ) ; Type someType = allTypes . iterator ( ) . next ( ) ; List < Resource > orderedResources = new ArrayList < Resource > ( ) ; orderedResources . addAll ( resources . values ( ) ) ; Collections . sort ( orderedResources , new CostMinComparator ( someType . getStartTime ( ) , someType . getDuration ( ) ) ) ; Iterator < Resource > resourceIterator = orderedResources . iterator ( ) ; Iterator < Type > typeIterator = allTypes . iterator ( ) ; Resource r = resourceIterator . next ( ) ; List < Type > typesForAResource = new ArrayList < Type > ( ) ; while ( typeIterator . hasNext ( ) ) { Type t = typeIterator . next ( ) ; typesForAResource . add ( t ) ; while ( ! r . isTypesFitting ( typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ) { typesForAResource . remove ( t ) ; if ( resourceIterator . hasNext ( ) ) { if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; typesForAResource = new ArrayList < Type > ( ) ; } typesForAResource . add ( t ) ; r = resourceIterator . next ( ) ; } else { return null ; } } } if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; } slaAllocation . setAllocation ( allocations ) ; return slaAllocation ; }
tr	2	private Player getWinner ( ) { for ( Player player : playerList . getPlayers ( ) ) { if ( ! player . isBankrupt ( ) ) { return player ; } } return null ; }
tr	5	public static Integer convertStringToNumber ( String str ) { str = str . toLowerCase ( ) ; int num = ones . indexOf ( str ) ; if ( num > - 1 ) { return num ; } num = tens . indexOf ( str ) ; if ( num > - 1 ) { return num * 10 ; } String arr [ ] = str . split ( " |-" ) ; if ( arr . length == 2 ) { num = tens . indexOf ( arr [ 0 ] ) * 10 ; if ( num > - 1 ) { num += ones . indexOf ( arr [ 1 ] ) ; if ( num > 20 ) { return num ; } } } return null ; }
tr	3	public boolean hasSlot ( String name ) { if ( slots . containsKey ( name ) ) return true ; for ( MinObject proto : protos ) { if ( proto . hasSlot ( name ) ) return true ; } return false ; }
tr	3	private void initAlleles ( ) { for ( int acIndex = 0 ; acIndex < accessionCount ; acIndex ++ ) { for ( int mIndex = 0 ; mIndex < markerCount ; mIndex ++ ) { int alCnt = alleleName . get ( mIndex ) . size ( ) ; dataMatrix . get ( acIndex ) . set ( mIndex , new ArrayList < double > ( alCnt ) ) ; for ( int alIndex = 0 ; alIndex < alCnt ; alIndex ++ ) { dataMatrix . get ( acIndex ) . get ( mIndex ) . add ( null ) ; } } } }
tr	9X	private int [ ] getMinPrefMaxSumSize ( boolean isHor ) { int [ ] [ ] sizes = isHor ? colFlowSpecs . sizes : rowFlowSpecs . sizes ; int [ ] retSizes = new int [ 3 ] ; BoundSize sz = isHor ? lc . getWidth ( ) : lc . getHeight ( ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( sizes [ i ] != null ) { int [ ] size = sizes [ i ] ; for ( int sType = LayoutUtil . MIN ; sType <= LayoutUtil . MAX ; sType ++ ) { if ( sz . getSize ( sType ) != null ) { if ( i == 0 ) retSizes [ sType ] = sz . getSize ( sType ) . getPixels ( getParentSize ( container , isHor ) , container , null ) ; } else { int s = size [ sType ] ; if ( s != LayoutUtil . NOT_SET ) { if ( sType == LayoutUtil . PREF ) { int bnd = size [ LayoutUtil . MAX ] ; if ( bnd != LayoutUtil . NOT_SET && bnd < s ) s = bnd ; bnd = size [ LayoutUtil . MIN ] ; if ( bnd > s ) s = bnd ; } retSizes [ sType ] += s ; } if ( size [ LayoutUtil . MAX ] == LayoutUtil . NOT_SET || retSizes [ LayoutUtil . MAX ] > LayoutUtil . INF ) retSizes [ LayoutUtil . MAX ] = LayoutUtil . INF ; } } } } correctMinMax ( retSizes ) ; return retSizes ; }
tr	6	private static RubixPermutation parseMove ( char m ) { switch ( m ) { case F : return RubixPermutation . FRONT ; case B : return RubixPermutation . BACK ; case L : return RubixPermutation . LEFT ; case R : return RubixPermutation . RIGHT ; case U : return RubixPermutation . UP ; case D : return RubixPermutation . DOWN ; default : return RubixPermutation . IDENTITY ; } }
tr	1	public void setCode ( CodeFragment code ) { if ( code == null ) code = new CodeFragment ( ) ; this . code = code ; }
tr	8	public static String query ( int table_id , String str , int start_index , int max_fetch ) throws Exception { JSONObject result = new JSONObject ( ) ; JSONArray entry_list = new JSONArray ( ) ; Map temp = new LinkedHashMap ( ) ; int max_count , count ; int maxCount [ ] = new int [ 6 ] ; Connection Con = global . getConnection ( ) ; switch ( table_id ) { case 0 : { entry_list . clear ( ) ; start_index /= 6 ; max_fetch /= 6 ; maxCount [ 0 ] = Course . getResultCount ( Con , str ) ; maxCount [ 1 ] = Student . getResultCount ( Con , str ) ; maxCount [ 2 ] = Instructor . getResultCount ( Con , str ) ; maxCount [ 3 ] = Work . getResultCount ( Con , str ) ; maxCount [ 4 ] = Project . getResultCount ( Con , str ) ; maxCount [ 5 ] = Post . getResultCount ( Con , str ) ; max_count = 0 ; SortedSet < Pair > set = new TreeSet < Pair > ( ) ; for ( int ii = 0 ; ii < 6 ; ii ++ ) { set . add ( new Pair ( ii , maxCount [ ii ] ) ) ; max_count += maxCount [ ii ] ; } addResults ( entry_list , set , Con , str , start_index , max_fetch ) ; break ; } case 1 : { entry_list = Course . Query ( Con , str , start_index , max_fetch ) ; max_count = Course . getResultCount ( Con , str ) ; break ; } case 2 : { entry_list = Student . Query ( Con , str , start_index , max_fetch ) ; max_count = Student . getResultCount ( Con , str ) ; break ; } case 3 : { entry_list = Instructor . Query ( Con , str , start_index , max_fetch ) ; max_count = Instructor . getResultCount ( Con , str ) ; break ; } case 4 : { entry_list = Project . Query ( Con , str , start_index , max_fetch ) ; max_count = Project . getResultCount ( Con , str ) ; break ; } case 5 : { entry_list = Work . Query ( Con , str , start_index , max_fetch ) ; max_count = Work . getResultCount ( Con , str ) ; break ; } case 6 : { entry_list = Post . Query ( Con , str , start_index , max_fetch ) ; max_count = Post . getResultCount ( Con , str ) ; break ; } default : { max_count = 0 ; break ; } } count = entry_list . size ( ) ; temp . put ( "max_count" , max_count ) ; temp . put ( "count" , count ) ; temp . put ( "entries" , entry_list ) ; result . put ( "results" , temp ) ; Con . close ( ) ; return result . toJSONString ( ) ; }
tr	6	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . role != null ) { sb . append ( prefix ) . append ( "role=" ) . append ( this . role . getValue ( ) ) ; sb . append ( "&" ) ; } if ( this . name != null ) { String newPrefix = prefix + "name." ; sb . append ( this . name . toNVPString ( newPrefix ) ) ; } if ( this . fullLegalName != null ) { sb . append ( prefix ) . append ( "fullLegalName=" ) . append ( NVPUtil . encodeUrl ( this . fullLegalName ) ) ; sb . append ( "&" ) ; } if ( this . address != null ) { String newPrefix = prefix + "address." ; sb . append ( this . address . toNVPString ( newPrefix ) ) ; } if ( this . dateOfBirth != null ) { sb . append ( prefix ) . append ( "dateOfBirth=" ) . append ( NVPUtil . encodeUrl ( this . dateOfBirth ) ) ; sb . append ( "&" ) ; } if ( this . occupation != null ) { sb . append ( prefix ) . append ( "occupation=" ) . append ( NVPUtil . encodeUrl ( this . occupation ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	1	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser fc = new JFileChooser ( ) ; fc . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; int returnVal = fc . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { this . localBackupTF . setText ( fc . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } }
tr	8	public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . err . println ( "Usage: java FollowPointers input-file" ) ; return ; } String filename = args [ 0 ] ; Scanner scanner = null ; int [ ] array = null ; int size = 0 ; try { scanner = new Scanner ( new FileInputStream ( filename ) ) ; int i = 0 ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; if ( null == line || line . length ( ) == 0 ) break ; if ( 0 == i ) { size = Integer . parseInt ( line ) ; array = new int [ size ] ; } else { int val = Integer . parseInt ( line ) ; array [ i - 1 ] = val ; } i ++ ; } if ( 0 == array . length ) { System . err . println ( "Cannot process pointers" ) ; return ; } int result = followPointers ( array ) ; System . out . println ( result ) ; } catch ( Exception e ) { System . err . println ( "Error processing input file " + filename ) ; e . printStackTrace ( ) ; } finally { if ( null != scanner ) { scanner . close ( ) ; } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { WindowAdd dialog = new WindowAdd ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RecordTypeNode other = ( RecordTypeNode ) obj ; if ( fieldLists == null ) { if ( other . fieldLists != null ) return false ; } else if ( ! fieldLists . equals ( other . fieldLists ) ) return false ; return true ; }
tr	8	private String toString ( String separator , boolean braces ) { if ( size == 0 ) { return braces ? "{}" : "" ; } StringBuilder buffer = new StringBuilder ( 32 ) ; if ( braces ) { buffer . append ( { ) ; } K [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; int i = keyTable . length ; while ( i -- > 0 ) { K key = keyTable [ i ] ; if ( key == null ) { continue ; } buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; break ; } while ( i -- > 0 ) { K key = keyTable [ i ] ; if ( key == null ) { continue ; } buffer . append ( separator ) ; buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; } if ( braces ) { buffer . append ( } ) ; } return buffer . toString ( ) ; }
tr	9X	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
tr	9X	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
tr	3	static float sqrt ( float n ) { float low = 0 , high = n ; float mid = ( low + high ) / 2 ; while ( Math . abs ( mid * mid - n ) > 0.00001 ) { if ( mid * mid < n ) low = mid ; else if ( mid * mid > n ) high = mid ; mid = ( low + high ) / 2 ; } return mid ; }
tr	7	public static int getDistance ( String s , String t ) { if ( s == null ) { if ( t == null ) return 0 ; return t . length ( ) ; } if ( t == null ) return s . length ( ) ; if ( s . equals ( t ) ) return 0 ; char [ ] sArray = s . toCharArray ( ) ; char [ ] tArray = t . toCharArray ( ) ; int max = sArray . length > tArray . length ? tArray . length : sArray . length ; int distance = Math . abs ( sArray . length - tArray . length ) ; for ( int i = 0 ; i < max ; i ++ ) { if ( sArray [ i ] != tArray [ i ] ) { distance ++ ; } } return distance ; }
tr	8	private void setCharacterValue ( StringBuilder aCharacters ) throws SAXException { if ( "published" . equals ( currentElement ) ) { try { tweet . setPublished ( dateFormat . parse ( aCharacters . toString ( ) ) ) ; } catch ( ParseException anExc ) { throw new SAXException ( anExc ) ; } } else if ( ( "title" . equals ( currentElement ) ) && ( tweet != null ) ) { tweet . setTitle ( aCharacters . toString ( ) ) ; } else if ( "content" . equals ( currentElement ) ) { content . setValue ( aCharacters . toString ( ) ) ; } else if ( "twitter:lang" . equals ( currentElement ) ) { tweet . setLanguage ( aCharacters . toString ( ) ) ; } else if ( "name" . equals ( currentElement ) ) { author . setName ( aCharacters . toString ( ) ) ; } else if ( "uri" . equals ( currentElement ) ) { author . setUri ( aCharacters . toString ( ) ) ; } }
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	9X	public String buildUrl ( ) { StringBuilder urlBuilder = new StringBuilder ( ) ; StringBuilder placeHolderBuilder = new StringBuilder ( ) ; boolean placeHolderFlag = false ; for ( int i = 0 ; i < urlFormat . length ( ) ; i ++ ) { if ( urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_START ) { placeHolderBuilder = new StringBuilder ( ) ; placeHolderFlag = true ; } else if ( placeHolderFlag && urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_END ) { String placeHolder = placeHolderBuilder . toString ( ) ; if ( PROTOCOL_PLACEHOLDER . equals ( placeHolder ) ) { urlBuilder . append ( API_PROTOCOL ) ; } else if ( QUERY_PARAMETERS_PLACEHOLDER . equals ( placeHolder ) ) { StringBuilder builder = new StringBuilder ( ) ; if ( ! parametersMap . isEmpty ( ) ) { Iterator < String > iter = parametersMap . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = iter . next ( ) ; String value = parametersMap . get ( name ) ; builder . append ( name ) ; builder . append ( "=" ) ; builder . append ( value ) ; if ( iter . hasNext ( ) ) { builder . append ( "&" ) ; } } } urlBuilder . append ( builder . toString ( ) ) ; } else { urlBuilder . append ( API_URLS_PLACEHOLDER_START ) ; urlBuilder . append ( placeHolder ) ; urlBuilder . append ( API_URLS_PLACEHOLDER_END ) ; } placeHolderFlag = false ; } else if ( placeHolderFlag ) { placeHolderBuilder . append ( urlFormat . charAt ( i ) ) ; } else { urlBuilder . append ( urlFormat . charAt ( i ) ) ; } } return urlBuilder . toString ( ) ; }
tr	7	public void creerRessources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new ArrayList < case > ( ) ; List < case > availables = new ArrayList < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getNiveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( ConfigurationLoader . MAX_RESSOURCES_SPAWNS < availables . size ( ) ) { for ( int i = 0 ; i < ConfigurationLoader . MAX_RESSOURCES_SPAWNS ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new Random ( ) . nextInt ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new Random ( ) . nextInt ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new Random ( ) . nextInt ( 5 ) + 1 ) ) * ConfigurationLoader . ABONDANCE_MULTIPLICATOR ; if ( quantite > 0 ) { where . ajouterRessource ( new Ressource ( quantite ) ) ; } }
tr	4	public void run ( ) { useful = true ; UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . pushScreen ( popup ) ; } } ) ; int iterations = 0 ; while ( useful ) { try { Thread . sleep ( timeout ) ; } catch ( Exception e ) { } if ( ++ iterations > maximum ) iterations = 1 ; gaugeField . setValue ( iterations ) ; } if ( popup . isDisplayed ( ) ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . popScreen ( popup ) ; } } ) ; } }
tr	8	private void runSpikingProblem ( Evolution evo ) { outputScreen . setText ( "" ) ; int populationSize = Integer . parseInt ( populationSizeField . getText ( ) ) ; int generations = Integer . parseInt ( generationsField . getText ( ) ) ; SpikingNeuronProblem sn = ( SpikingNeuronProblem ) problem ; List < Individual > individuals = problem . createPopulation ( populationSize ) ; try { long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < generations ; i ++ ) { individuals = evo . runGeneration ( individuals ) ; Individual best = individuals . get ( 0 ) ; for ( Individual ind : individuals ) { if ( ind . age ( ) > 0 ) { if ( ind . fitness ( ) > best . fitness ( ) ) { best = ind ; } } } String formattedString = outputScreen . getText ( ) ; formattedString += "Generation " + ( i + 1 ) + ": " + best . toString ( ) + "\n" ; outputScreen . setText ( formattedString ) ; Plot2DPanel plot = new Plot2DPanel ( ) ; BaseLabel title = new BaseLabel ( "Generation: " + ( i + 1 ) + "  " + problemBox . getSelectedItem ( ) . toString ( ) + "  " + adultBox . getSelectedItem ( ) . toString ( ) + "  " + parentBox . getSelectedItem ( ) . toString ( ) + "  mutation: " + mutationRateField . getText ( ) + "%  crossover: " + crossoverRateField . getText ( ) + "%" , Color . BLACK , 0.5 , 1.1 ) ; plot . addPlotable ( title ) ; plot . addLinePlot ( "Target" , Color . RED , sn . target ) ; SpikingNeuronPhenotype snPheno = ( SpikingNeuronPhenotype ) best . phenotype ( ) ; plot . addLinePlot ( "Best individual" , Color . BLUE , snPheno . spiketrain ) ; plot . addLegend ( "SOUTH" ) ; graphpanel . add ( plot ) ; CardLayout card = ( CardLayout ) graphpanel . getLayout ( ) ; card . last ( graphpanel ) ; if ( i % 10 == 0 ) System . out . println ( ( double ) ( System . nanoTime ( ) - startTime ) / 1000000000.0 ) ; } evo . drawBestFitnessPlot ( ) ; String teXLabel = "Generations: " + generations + "\\\\" + "\n" + "Population: " + populationSize + "\\\\" + "\n" + "Adult Selection: " + adultBox . getSelectedItem ( ) . toString ( ) ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Overproduction" ) ) { teXLabel += "( \\%)\\\\\n" ; } else teXLabel += "\\\\\n" ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Generational Mixing" ) ) { teXLabel += "( Adult spots: )\n" ; } else teXLabel += "\n" ; teXLabel += "Selection Method: " + parentBox . getSelectedItem ( ) . toString ( ) + "\\\\" + "\n" + "Mutation :" + mutationRateField . getText ( ) + "\\%" + "\\\\" + "\n" + "Crossover: " + crossoverRateField . getText ( ) + "\\% \\\\" + "\n" ; System . out . println ( teXLabel ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
tr	3	MapCell getCell ( Position pos ) { Preconditions . checkArgument ( pos . getX ( ) < mapWidth && pos . getX ( ) >= 0 && pos . getY ( ) < mapHeight && pos . getY ( ) >= 0 ) ; return map [ pos . getX ( ) ] [ pos . getY ( ) ] ; }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	4	@ Override protected void imprimirTabuleiro ( TabuleiroXadrez tabuleiro ) { imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; for ( int linha = 8 ; linha >= 1 ; linha -- ) { imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimir ( linha + " " ) ; for ( int coluna = 1 ; coluna <= 8 ; coluna ++ ) { imprimir ( "|" ) ; Peca peca = tabuleiro . espiarPeca ( new Posicao ( coluna , linha ) ) ; imprimir ( PecaToString ( peca ) ) ; if ( peca == null ) imprimir ( "       " ) ; else if ( peca . getCorJogador ( ) == TipoCorJogador . BRANCO ) imprimir ( " branco" ) ; else imprimir ( " preto " ) ; } imprimirLinha ( "| " + linha ) ; } imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; }
tr	5	public Plugin ( String name ) { this . name = name ; this . propertyChange = new PropertyChangeSupport ( this ) ; if ( name . startsWith ( "serendipity_plugin" ) ) { setType ( PluginType . sidebar ) ; } else if ( name . startsWith ( "serendipity_event" ) ) { setType ( PluginType . event ) ; } else if ( name . equals ( "system" ) ) { setType ( PluginType . system ) ; } else { setType ( PluginType . template ) ; } intern = false ; if ( type . equals ( PluginType . system ) ) { intern = true ; } if ( name . equals ( "homepage" ) ) { System . out . println ( "contructor: hompage plugin type = " + getType ( ) ) ; } }
tr	6	@ SuppressWarnings ( "rawtypes" ) public static List < String > getClassNamesImplementingInterface ( class interf , String basePackage ) { List < String > classNames = new ArrayList < String > ( ) ; try { class [ ] result = getClasses ( basePackage ) ; for ( class c : result ) { if ( ! Modifier . isAbstract ( c . getModifiers ( ) ) ) { for ( class implementingInterface : c . getInterfaces ( ) ) { if ( implementingInterface . getName ( ) . equals ( interf . getName ( ) ) ) { classNames . add ( c . getCanonicalName ( ) ) ; } } } } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return classNames ; }
tr	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_1 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "i" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	1	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
tr	3	public boolean writeObject ( Object o ) throws ConnectionLostException { if ( socket == null ) throw new ConnectionLostException ( ) ; if ( o != null ) { try { oos . reset ( ) ; oos . writeObject ( o ) ; oos . flush ( ) ; return true ; } catch ( IOException e ) { System . err . println ( "Socket Exception: Cannot write to socket." ) ; socket = null ; throw new ConnectionLostException ( "Socket Exception: Cannot write to socket." ) ; } } return false ; }
tr	9X	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	6	private static void Merge ( int [ ] data , int left , int center , int right ) { int [ ] tmpArr = new int [ data . length ] ; int mid = center + 1 ; int index = left ; int tmp = left ; while ( left <= center && mid <= right ) { if ( data [ left ] <= data [ mid ] ) { tmpArr [ index ++ ] = data [ left ++ ] ; } else { tmpArr [ index ++ ] = data [ mid ++ ] ; } } while ( mid <= right ) { tmpArr [ index ++ ] = data [ mid ++ ] ; } while ( left <= center ) { tmpArr [ index ++ ] = data [ left ++ ] ; } while ( tmp <= right ) { data [ tmp ] = tmpArr [ tmp ++ ] ; } }
tr	1	public void run ( ) { if ( program != null ) { program . execute ( this ) ; } else { defaultProgram ( ) ; } }
tr	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	7	public ArrayList < UserProfile > fetchAllProfiles ( ) throws SQLConnectionException , SQLQueryException { ArrayList < UserProfile > profiles = new ArrayList < UserProfile > ( ) ; Statement st ; try { st = dbCon . createStatement ( ) ; } catch ( SQLException e ) { if ( dbCon != null ) try { dbCon . close ( ) ; } catch ( SQLException e2 ) { e2 . printStackTrace ( ) ; } throw new SQLConnectionException ( e ) ; } finally { } ResultSet rs ; try { rs = st . executeQuery ( "SELECT rowid  name FROM userprofile" ) ; } catch ( SQLException e ) { throw new SQLQueryException ( e ) ; } try { while ( rs . next ( ) ) { UserProfile up = new UserProfile ( rs . getInt ( "rowid" ) , rs . getString ( "name" ) ) ; profiles . add ( up ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } try { st . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return profiles ; }
tr	3	public RegularAnalyzer ( List < Rule > rules ) { Set < String > definedRuleNames = new HashSet < String > ( ) ; List < Rule > observedRules = new ArrayList < Rule > ( ) ; observedRules . addAll ( rules ) ; boolean foundRegular ; do { foundRegular = false ; for ( int index = observedRules . size ( ) - 1 ; index >= 0 ; index -- ) { Set < String > dependent = observedRules . get ( index ) . getElements ( ) . getDependentRuleNames ( ) ; if ( definedRuleNames . containsAll ( dependent ) ) { definedRuleNames . add ( observedRules . get ( index ) . getRuleName ( ) . toString ( ) ) ; regularRules . add ( observedRules . get ( index ) ) ; observedRules . remove ( index ) ; foundRegular = true ; continue ; } } } while ( foundRegular ) ; observedRules . clear ( ) ; }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	8	@ Override public synchronized Object getValueAt ( int rowIndex , int columnIndex ) { Utente utente = getRow ( rowIndex ) ; switch ( columnIndex ) { case 0 : return utente . getId ( ) ; case 1 : return utente . nome ; case 2 : return utente . cognome ; case 3 : return utente . userName ; case 4 : { if ( utente . getUserType ( ) == Utente . ADMIN ) return "Admin" ; if ( utente . getUserType ( ) == Utente . CLIENTE ) return "Cliente" ; if ( utente . getUserType ( ) == Utente . OPERATORE ) return "Operatore" ; } default : return null ; } }
tr	4	private Map fitnessCalculations ( List < Individual > individuals ) { Map statistics = new HashMap ( ) ; double countFitness = 0 ; double maxFitness = 0.0 ; double minFitness = 10.0 ; for ( Individual i : individuals ) { try { countFitness += i . fitness ( ) ; if ( i . fitness ( ) > maxFitness ) { maxFitness = i . fitness ( ) ; statistics . put ( "maxFitness" , maxFitness ) ; statistics . put ( "bestIndividual" , i ) ; } if ( i . fitness ( ) < minFitness ) { minFitness = i . fitness ( ) ; statistics . put ( "minFitness" , minFitness ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } statistics . put ( "avgFitness" , countFitness / individuals . size ( ) ) ; return statistics ; }
tr	2	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final AreaStats other = ( AreaStats ) obj ; if ( this . averageWeather != other . averageWeather ) { return false ; } return true ; }
tr	3	public void update ( ByteBuffer data ) throws IOException { if ( data . position ( ) != 0 ) data . flip ( ) ; output . write ( data ) ; crc . update ( data . array ( ) , 0 , data . limit ( ) ) ; if ( output . size ( ) == udo . getLength ( ) ) { setFinished ( true ) ; udo . setChecksum ( crc . getValue ( ) ) ; output . close ( ) ; Main . localIndex . insert ( dataProcessor . storeData ( udo ) ) ; } else if ( output . size ( ) > udo . getLength ( ) ) { System . out . println ( "Huge error occured  too much data!" ) ; } }
tr	5	public int getIndex ( Point p ) { final int x = p . x ; final int y = p . y ; if ( x < 0 || x >= 1 << order || y < 0 || y >= 1 << order ) return - 1 ; int index = 0 ; int sq = startsquare ; int o = order - 1 ; while ( o >= 0 ) { int i = ( ( ( ( x >> o ) & 1 ) << 1 ) | ( ( y >> o ) & 1 ) ) ; index = ( index << 2 ) | indexes [ sq ] [ i ] ; sq = squares [ sq ] [ i ] ; o -- ; } return index ; }
tr	4	public static FastFilter tag ( final String tagName , final boolean ignoreNamespace ) { if ( tagName == null || tagName . equals ( "" ) ) { return none ( ) ; } else if ( "*" . equals ( tagName ) ) { return all ( ) ; } else { return new FastFilter ( ) { @ Override public boolean filter ( Context context ) { String localName = context . element ( ) . getTagName ( ) ; if ( ignoreNamespace ) { localName = Util . stripNamespace ( localName ) ; } return tagName . equals ( localName ) ; } } ; } }
tr	2	public Object unserialize ( String s ) throws IOException { return ( s == null || s . length ( ) == 0 ) ? null : new Integer ( s ) ; }
tr	0	public void setWeight ( int weight ) { this . weight = weight ; }
tr	7	private boolean checkIntersects ( Point point ) { if ( foundSegment == null ) return false ; Segment segA = new Segment ( foundSegment . segment . getPointA ( ) , point ) ; Segment segB = new Segment ( foundSegment . segment . getPointB ( ) , point ) ; for ( Polygon p : getAllPolygons ( ) ) { for ( Segment s : p . getSegments ( ) ) { Point pt ; if ( ( pt = GeomUtils . intersectOnlyPoint ( segA , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } if ( ( pt = GeomUtils . intersectOnlyPoint ( segB , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } } } return true ; }
tr	7	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	4	public void immune ( Type primary , Type secondary ) { if ( immuneTypes . length == 0 ) { return ; } for ( int i = 0 ; i < resistantTypes . length ; i ++ ) { if ( immuneTypes [ i ] . equalsTo ( primary . showType ( ) ) || immuneTypes [ i ] . equalsTo ( secondary . showType ( ) ) ) { typeModifier = 0.0 ; } } }
tr	3	public static boolean checkFileSizeExist ( String fn , long size ) { File file = new File ( fn ) ; if ( file . exists ( ) == true && file . isFile ( ) && file . length ( ) == size ) return true ; else return false ; }
tr	7	public static List < String > getProperties ( Object bean ) throws RemoteException { List < String > result = new ArrayList < String > ( ) ; if ( bean == null ) return result ; if ( bean instanceof GenericObject ) { GenericObject o = ( GenericObject ) bean ; result . addAll ( Arrays . asList ( o . getAttributeNames ( ) ) ) ; return result ; } Method [ ] methods = bean . getClass ( ) . getMethods ( ) ; if ( methods == null || methods . length == 0 ) return result ; for ( Method m : methods ) { String name = m . getName ( ) ; if ( name . startsWith ( "get" ) && name . length ( ) > 3 ) result . add ( toProperty ( name ) ) ; } return result ; }
tr	2	public Action poolCurrentAction ( ) { if ( actions . isEmpty ( ) ) { return null ; } Action next = actions . poll ( ) ; if ( loop ) { next . reset ( ) ; actions . add ( next ) ; } return next ; }
tr	2	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	4	private void generatePressureFile ( ) { File file = new File ( this . pressFile ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; try { BufferedWriter output = new BufferedWriter ( new FileWriter ( file ) ) ; for ( Edge e : edges ) { String line ; int i = 1 ; for ( int vec : e . getFlowUnitVector ( ) ) { if ( vec != 0 ) { line = e . getNumber ( ) + " " + i + " " + vec + "\n" ; output . write ( line ) ; } i ++ ; } } output . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Model . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	2	public static void main ( String [ ] args ) { int x = 5 ; if ( x < 5 ) if ( x > 5 ) System . out . println ( b ) ; else System . out . println ( a ) ; }
tr	9X	public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { Player player = null ; if ( sender instanceof Player ) { player = ( Player ) sender ; } if ( args . length == 0 ) { if ( player == null ) { sender . sendMessage ( "This command can only be run by a player" ) ; } else { player . setLevel ( 150 ) ; player . sendMessage ( ChatColor . WHITE + "You've made yourself " + ChatColor . DARK_GREEN + "Level 150!" ) ; return true ; } } if ( args . length == 1 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; target . setLevel ( 150 ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level 150!" ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level 150 " + ChatColor . WHITE + "by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } if ( args . length == 2 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; int lvlset = Integer . parseInt ( args [ 1 ] ) ; target . setLevel ( lvlset ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level " + lvlset ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level " + lvlset + ChatColor . WHITE + " by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } return true ; }
tr	6	private static int computeLongestCycle ( String string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . toCharArray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
tr	5	public void addScoreValue ( int i ) { if ( this . currentTurn . isClosed ( ) || playerFinished ( ) ) { host . requestNextPlayerEvent ( ) ; return ; } if ( this . getRemainingScore ( ) - i < 0 ) { this . currentTurn . busted ( ) ; this . host . bust ( this ) ; return ; } this . currentTurn . addThrow ( i ) ; if ( playerFinished ( ) ) { this . host . firePlayerFinishedEvent ( ) ; } if ( this . currentTurn . hasRemainingThrows ( ) ) { checkFinishingPossibility ( ) ; } else { this . host . turnEnded ( ) ; } this . host . provideRemainingScore ( ) ; }
tr	6	public List < Document > sorting ( Map < String , Document > temp , int mode ) { List < Document > sortedList = new LinkedList < Document > ( temp . values ( ) ) ; if ( mode == 0 ) { Collections . sort ( sortedList , new Comparator < Document > ( ) { @ Override public int compare ( Document o1 , Document o2 ) { if ( o1 . getPageRank ( ) - o2 . getPageRank ( ) == 0 ) { return o1 . getTitle ( ) . compareTo ( o2 . getTitle ( ) ) ; } else { return ( o1 . getPageRank ( ) - o2 . getPageRank ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } else if ( mode == 1 ) { Collections . sort ( sortedList , new Comparator < Document > ( ) { @ Override public int compare ( Document o1 , Document o2 ) { if ( o1 . getNumViews ( ) - o2 . getNumViews ( ) == 0 ) { return o1 . getTitle ( ) . compareTo ( o2 . getTitle ( ) ) ; } else { return ( o1 . getNumViews ( ) - o2 . getNumViews ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } return sortedList ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { jfSelColor dialog = new jfSelColor ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	6	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; dead = true ; xa = 0 ; ya = 1 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	9X	protected void defineCommands ( ) { commands . put ( "quit" , new Command ( ) { public void run ( String [ ] args ) throws Exception { close ( ) ; } } ) ; commands . put ( "create" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 2 ) { gui . addNotice ( "create <pokoj> <haslo>" ) ; return ; } String roomName = args [ 0 ] ; String password = args [ 1 ] ; if ( client != null ) client . createRoom ( roomName , password ) ; } } ) ; commands . put ( "join" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 3 ) { gui . addNotice ( "join <nick> <pokoj> <haslo>" ) ; return ; } String nickname = args [ 0 ] ; String roomName = args [ 1 ] ; String password = args [ 2 ] ; if ( client != null ) { if ( currentRoom != null ) { handleCommand ( "leave" ) ; } client . joinRoom ( roomName , password , nickname ) ; currentRoom = new CurrentRoom ( roomName , nickname ) ; } } } ) ; commands . put ( "leave" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String currentRoomName = currentRoom . roomName ; String currentRoomNickname = currentRoom . nickname ; client . leaveRoom ( currentRoom . roomName , currentRoom . nickname ) ; currentRoom = null ; gui . addNotice ( String . format ( "%s opu\u015Bci\u0142(a) pok\u00F3j %s" , currentRoomNickname , currentRoomName ) ) ; gui . setStatus ( "" ) ; } } } ) ; commands . put ( "msgs" , new Command ( ) { private final String SENT_FORMAT = "dd.MM.yyyy" ; public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String sentArg = args . length > 0 ? args [ 0 ] : null ; Date sent = null ; if ( sentArg != null ) { SimpleDateFormat df = new SimpleDateFormat ( SENT_FORMAT ) ; try { sent = df . parse ( sentArg ) ; } catch ( ParseException e ) { gui . addNotice ( String . format ( "msgs: Data powinna byc w formacie `%s'" , SENT_FORMAT ) ) ; return ; } } client . showMessages ( currentRoom . roomName , sent ) ; } } } ) ; }
tr	5	@ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws IOException { UserService userService = UserServiceFactory . getUserService ( ) ; User user = userService . getCurrentUser ( ) ; String guestbookName = request . getParameter ( "guestbookName" ) ; String emailDeclared = request . getParameter ( "email" ) ; String nameDeclared = request . getParameter ( "name" ) ; if ( guestbookName == null ) { guestbookName = "default" ; } if ( emailDeclared == null ) { emailDeclared = user . getEmail ( ) ; } if ( nameDeclared == null ) { nameDeclared = user . getNickname ( ) ; } Key guestbookKey = KeyFactory . createKey ( "Guestbook" , guestbookName ) ; String content = request . getParameter ( "message" ) ; if ( content == null ) { content = "Greetings!" ; } if ( user != null ) { Entity greeting = new Entity ( "Greeting" , guestbookKey ) ; Date date = new Date ( ) ; greeting . setProperty ( "user" , user ) ; greeting . setProperty ( "date" , date ) ; greeting . setProperty ( "userId" , user . getUserId ( ) ) ; greeting . setProperty ( "federatedId" , user . getFederatedIdentity ( ) ) ; greeting . setProperty ( "domain" , user . getAuthDomain ( ) ) ; greeting . setProperty ( "content" , content ) ; greeting . setProperty ( "nameDeclared" , nameDeclared ) ; greeting . setProperty ( "emailDeclared" , emailDeclared ) ; DatastoreService ds = DatastoreServiceFactory . getDatastoreService ( ) ; ds . put ( greeting ) ; } else { log . info ( "Anonymous: " + content ) ; } response . sendRedirect ( "/guest.jsp?guestbookName=" + guestbookName ) ; }
tr	3	private static boolean iguales ( Nodo nodo1 , Nodo nodo2 ) { if ( nodo1 == null && nodo2 == null ) return true ; if ( nodo1 . equals ( nodo2 ) ) return iguales ( nodo1 . getSiguiente ( ) , nodo2 . getSiguiente ( ) ) ; return false ; }
tr	7	public boolean attack ( Square toSquare , short amount ) { Logger . debug ( gameStatus . currentPlayerIndex + ")Attack!" ) ; short defUnits = toSquare . getUnits ( ) ; short attackUnits = amount ; if ( attackUnits > units ) attackUnits = units ; short baseDefenceUnits = ( short ) gameStatus . config . getInt ( Config . KEY . BASE_DEFENCE_UNITS . getKey ( ) ) ; if ( defUnits == attackUnits ) { owner . modifyTotalUnits ( ( short ) - ( attackUnits - 1 ) ) ; toSquare . owner . modifyTotalUnits ( ( short ) - ( attackUnits - 1 ) ) ; units = 1 ; toSquare . units = 1 ; } else if ( defUnits == 0 ) { toSquare . playerLoses ( ) ; units -= amount ; toSquare . units = amount ; owner . modifySquares ( 1 ) ; toSquare . owner = owner ; } else { if ( defUnits < attackUnits ) { toSquare . playerLoses ( ) ; owner . modifySquares ( 1 ) ; owner . modifyTotalUnits ( ( short ) - ( defUnits - baseDefenceUnits ) ) ; toSquare . owner = owner ; toSquare . units = ( short ) ( attackUnits - ( defUnits - baseDefenceUnits ) ) ; units -= attackUnits ; short maxUnits = ( short ) gameStatus . config . getInt ( Config . KEY . MAX_UNITS . getKey ( ) ) ; if ( toSquare . units > maxUnits ) { units += ( toSquare . units - maxUnits ) ; toSquare . units = maxUnits ; } } else { short maxUnits = ( short ) gameStatus . config . getInt ( Config . KEY . MAX_UNITS . getKey ( ) ) ; if ( attackUnits == 1 && defUnits == maxUnits ) { Logger . debug ( "Can't move 1 unit from " + this . coordinate + " to " + toSquare . coordinate + " as destination is maxed out" ) ; return false ; } owner . modifyTotalUnits ( ( short ) - attackUnits ) ; toSquare . owner . modifyTotalUnits ( ( short ) - ( attackUnits - baseDefenceUnits ) ) ; units -= attackUnits ; toSquare . units -= ( short ) ( attackUnits - baseDefenceUnits ) ; } } return true ; }
tr	8	public void connect ( TreeLinkNode root ) { TreeLinkNode cur = root ; while ( cur != null ) { TreeLinkNode next = null ; TreeLinkNode prev = null ; while ( cur != null ) { if ( next == null ) { if ( cur . left != null ) next = cur . left ; else next = cur . right ; } if ( cur . left != null ) { if ( prev != null ) prev . next = cur . left ; prev = cur . left ; } if ( cur . right != null ) { if ( prev != null ) prev . next = cur . right ; prev = cur . right ; } cur = cur . next ; } cur = next ; } }
tr	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf (   ) + 1 ; final int endOfTag = line . indexOf (   , startOfTag + 1 ) ; if ( startOfTag < 1 || endOfTag < 1 ) { return ; } final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { final double timeLong = double . parseDouble ( strTimeTag ) ; final Date timeTag = new Date ( ( long ) timeLong . doubleValue ( ) * 1000 ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVisualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
tr	3	int pack ( Buffer opb ) { byte [ ] temp = "Xiphophorus libVorbis I 20000508" . getBytes ( ) ; opb . write ( 03 , 8 ) ; opb . write ( _vorbis ) ; opb . write ( temp . length , 32 ) ; opb . write ( temp ) ; opb . write ( comments , 32 ) ; if ( comments != 0 ) { for ( int i = 0 ; i < comments ; i ++ ) { if ( user_comments [ i ] != null ) { opb . write ( comment_lengths [ i ] , 32 ) ; opb . write ( user_comments [ i ] ) ; } else { opb . write ( 0 , 32 ) ; } } } opb . write ( 1 , 1 ) ; return ( 0 ) ; }
tr	5	public void turn ( int choice ) { if ( choice == 0 ) { attack ( true ) ; } else if ( choice == 1 ) { chooseSpell ( ) ; } else if ( choice == 2 ) { flee ( ) ; } if ( enemy . getHealth ( ) <= 0 ) { System . out . println ( "Thy enemy lies vanquished!" ) ; endBattle ( ) ; } else { attack ( false ) ; } if ( character . getHealth ( ) <= 0 ) { System . out . println ( "Thou hast been defeated!" ) ; youLose ( ) ; } }
tr	9X	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	7	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	3	public String look ( ) { StringBuffer names = new StringBuffer ( ) ; String items = currRoom . getItemNames ( ) ; String monsters = currRoom . getMonsterNames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "Items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "Monsters: " ) ; names . append ( monsters ) ; } return names . toString ( ) ; }
tr	6	public void doService ( ) { Message message = parser . nextMessage ( ) ; while ( message != null ) { switch ( message . getType ( ) ) { case CONNECT : writer . println ( "ALREADY CONNECTED!" ) ; writer . flush ( ) ; break ; case DISCONNECT : server . broadcaster . remove ( connection ) ; break ; case TEXTMSG_CLIENT : broadcastMessage ( message ) ; break ; case IMAGE_CLIENT : server . setImage ( ImageUtils . decodeImage ( message . getMatcher ( ) . group ( 1 ) ) ) ; broadcastMessage ( message ) ; break ; default : AbstractTool tool = AbstractTool . getTool ( message . getType ( ) ) ; if ( tool != null ) { server . updateImage ( tool , message ) ; broadcastMessage ( message ) ; } break ; } message = parser . nextMessage ( ) ; } }
tr	7	public void prepare ( Dish dish ) { LinkedList < Material > materials = dish . getMaterials ( ) ; for ( Material tmp : materials ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) ) { storage . setAmount ( storage . getAmount ( ) - tmp . getAmount ( ) ) ; } } } LinkedList < Ingredient > ingredients = dish . getIngredients ( ) ; for ( Ingredient tmp : ingredients ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) && storage . getAmount ( ) > 0 ) { storage . setAmount ( storage . getAmount ( ) - 1 ) ; } } } nodifyObserver ( ) ; }
tr	1	Type getType ( ) { return type == Type . kAny ? Type . kBase : type ; }
tr	2	private void addRemainBActionPerformed ( java . awt . event . ActionEvent evt ) { if ( searchDrugTable . getSelectedRow ( ) != - 1 ) { try { String drugId = searchDrugTable . getValueAt ( searchDrugTable . getSelectedRow ( ) , 0 ) . toString ( ) ; addRemainDrugId . setText ( drugId ) ; addRemainNum . setText ( "" ) ; addRemainWindow . setVisible ( true ) ; } catch ( NumberFormatException e ) { alarmText . setText ( "\u8BF7\u9009\u62E9\u6B63\u786E\u7684\u884C" ) ; alarmWindow . setVisible ( true ) ; } } }
tr	2	public Grille ( int taille , Joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setBackground ( new Color ( 0 , 0 , 0 ) ) ; this . setLayout ( new GridLayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialiserCases ( ) ; }
tr	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
tr	0	public void setRing ( boolean ring ) { this . ring = ring ; }
tr	8	public void read ( org . apache . thrift . protocol . TProtocol iprot , MentionEntity struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . I64 ) { struct . id = iprot . readI64 ( ) ; struct . setIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . screen_name = iprot . readString ( ) ; struct . setScreen_nameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
tr	6	public void relatedTexts ( SaploGroup saploGroup , SaploCollection collection , int wait , int limit ) throws SaploClientException { verifyId ( saploGroup ) ; List < SaploText > relatedTextsList = new ArrayList < SaploText > ( ) ; JSONObject params = new JSONObject ( ) ; try { params . put ( "group_id" , saploGroup . getId ( ) ) ; if ( collection != null ) { params . put ( "collection_scope" , collection . getId ( ) ) ; } else { throw new SaploClientException ( MSG_CLIENT_FIELD , CODE_CLIENT_FIELD , "collection_scope" ) ; } if ( wait >= 0 ) params . put ( "wait" , wait ) ; if ( limit > 0 ) params . put ( "limit" , limit ) ; } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } JSONRPCRequestObject request = new JSONRPCRequestObject ( client . getNextId ( ) , "group.relatedTexts" , params ) ; JSONObject rawResult = ( JSONObject ) client . sendAndReceiveAndParseResponse ( request ) ; try { JSONArray texts = rawResult . getJSONArray ( "related_texts" ) ; for ( int i = 0 ; i < texts . length ( ) ; i ++ ) { JSONObject textJson = texts . getJSONObject ( i ) ; SaploText relText = SaploText . convertFromJSONToText ( textJson ) ; relText . setRelatedToGroup ( saploGroup ) ; relatedTextsList . add ( relText ) ; } } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } saploGroup . setRelatedTexts ( relatedTextsList ) ; }
tr	2	@ Override public void handlePeerDisconnected ( SharingPeer peer ) { if ( this . connected . remove ( peer . hasPeerId ( ) ? peer . getHexPeerId ( ) : peer . getHostIdentifier ( ) ) != null ) { logger . debug ( "Peer " + peer + " disconnected  [" + this . connected . size ( ) + "/" + this . peers . size ( ) + "]." ) ; } peer . reset ( ) ; }
tr	5	@ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) servletRequest ; HttpServletResponse response = ( HttpServletResponse ) servletResponse ; User session = ( User ) request . getSession ( ) . getAttribute ( "user" ) ; String url = request . getRequestURI ( ) ; response . setHeader ( "Cache-Control" , "no-cache  no-store  must-revalidate" ) ; response . setHeader ( "Pragma" , "no-cache" ) ; response . setDateHeader ( "Expires" , 0 ) ; if ( session == null ) { if ( url . indexOf ( "/content/" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "/security/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } else { if ( url . indexOf ( "register.xhtml" ) >= 0 || url . indexOf ( "/login.xhtml" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexOf ( "logout.xhtml" ) >= 0 ) { request . getSession ( ) . removeAttribute ( "user" ) ; response . sendRedirect ( request . getContextPath ( ) + "/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } }
tr	4	@ Override Pizza createPizza ( String type ) { Pizza pizza = null ; ChicagoPizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory ( ) ; if ( type . equals ( "cheese" ) ) { pizza = new ChicagoStyleCheesePizza ( ingredientFactory ) ; } else if ( type . equals ( "pepperoni" ) ) { pizza = new ChicagoStylePepperoniPizza ( ingredientFactory ) ; } else if ( type . equals ( "clam" ) ) { pizza = new ChicagoStyleClamPizza ( ingredientFactory ) ; } else if ( type . equals ( "veggie" ) ) { pizza = new ChicagoStyleVegglePizza ( ingredientFactory ) ; } return pizza ; }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	8	@ Override protected void paintContentBorder ( Graphics g , int tabPlacement , int selectedIndex ) { int width = tabPane . getWidth ( ) ; int height = tabPane . getHeight ( ) ; Insets insets = tabPane . getInsets ( ) ; int x = insets . left ; int y = insets . top ; int w = width - insets . right - insets . left ; int h = height - insets . top - insets . bottom ; switch ( tabPlacement ) { case LEFT : x += calculateTabAreaWidth ( tabPlacement , runCount , maxTabWidth ) ; x -= tabAreaInsets . right ; w -= ( x - insets . left ) ; break ; case RIGHT : w -= calculateTabAreaWidth ( tabPlacement , runCount , maxTabWidth ) ; w += tabAreaInsets . left ; break ; case BOTTOM : h -= calculateTabAreaHeight ( tabPlacement , runCount , maxTabHeight ) ; h += tabAreaInsets . top ; break ; case TOP : default : y += calculateTabAreaHeight ( tabPlacement , runCount , maxTabHeight ) ; y -= tabAreaInsets . bottom ; h -= ( y - insets . top ) ; } if ( tabPane . getTabCount ( ) > 0 ) { Color color = UIManager . getColor ( "TabbedPane.contentAreaColor" ) ; if ( color != null ) { g . setColor ( color ) ; } else if ( colorContentBorder == null || selectedIndex == - 1 ) { g . setColor ( tabPane . getBackground ( ) ) ; } else { g . setColor ( colorContentBorder ) ; } g . fillRect ( x , y , w , h ) ; } }
tr	5	public static String toString ( int [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
tr	5	private void howMany ( int [ ] [ ] paper , int n1 , int n2 , int m1 , int m2 ) { if ( counter . contains ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ) return ; counter . add ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ; for ( int d = m1 ; d <= m2 - 1 ; d ++ ) { if ( foldsVertically ( paper , n1 , n2 , m1 , m2 , d ) ) { if ( d <= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , d + 1 , m2 ) ; } if ( d >= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , m1 , d ) ; } } } }
tr	5	public DataFrame parse ( ) throws ParseException { DataFrame retval = null ; Tag tag = null ; do { tag = readTag ( ) ; if ( tag == null ) { break ; } } while ( tag . isComment ( ) || tag . isPreamble ( ) ) ; if ( ( tag != null ) && tag . isOpenTag ( ) ) { retval = readFrame ( tag ) ; } return retval ; }
tr	9X	public void PatientDocFile ( JPanel ptPane , int loggedId ) { staffid = loggedId ; StringBuffer loggedUser = new StringBuffer ( ) ; JTextPane tpLoggedStaff = new JTextPane ( ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getId ( ) == loggedId ) { loggedUser . append ( "<b>" + staff . get ( i ) . getLname ( ) ) ; loggedUser . append ( "  " ) ; loggedUser . append ( staff . get ( i ) . getFname ( ) + "</b>" ) ; if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "gp" ) ) loggedUser . append ( "  [logged as Dr.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ns" ) ) loggedUser . append ( "  [logged as R.N.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ma" ) ) loggedUser . append ( "  [logged as Med.As.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "mo" ) ) loggedUser . append ( "  [logged as Med.Of.]" ) ; } } tpLoggedStaff . setContentType ( "text/html" ) ; tpLoggedStaff . setText ( loggedUser . toString ( ) ) ; this . function . setOpacity ( tpLoggedStaff ) ; tpLoggedStaff . setEditable ( false ) ; patientList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; function . makeElementWithBorder ( patientList , "Patients" , Color . GRAY , false ) ; patientList . setOpaque ( false ) ; patientList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; patientList . setSelectedIndex ( 0 ) ; patientList . setVisibleRowCount ( 3 ) ; function . makeElementWithBorder ( testList , "Tests" , Color . GRAY , false ) ; testList . setOpaque ( false ) ; testList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; testList . setSelectedIndex ( 0 ) ; testList . setVisibleRowCount ( 3 ) ; this . patientListSP = new JScrollPane ( this . patientList ) ; this . function . setOpacity ( this . patientListSP ) ; patientListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; this . testListSP = new JScrollPane ( this . testList ) ; this . function . setOpacity ( this . testListSP ) ; testListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; JScrollPane [ ] patientSP = new JScrollPane [ patientTP . length ] ; JScrollPane testSP = new JScrollPane ( this . testTP ) ; function . makeElementWithBorder ( testSP , "Test Results" , Color . DARK_GRAY , false ) ; testSP . setVisible ( true ) ; this . function . setOpacity ( testTP ) ; this . function . setOpacity ( testSP ) ; testTP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; final JTextPane timeTP = new JTextPane ( ) ; timeTP . setContentType ( "text/html" ) ; timeTP . setPreferredSize ( new Dimension ( 20 , 15 ) ) ; timeTP . setEditable ( false ) ; timeTP . setOpaque ( false ) ; timeTP . setBorder ( null ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( "EEEEE  MMMMM d  yyyy | h:mm:ss a" ) ; new javax . swing . Timer ( 1000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Calendar date = Calendar . getInstance ( ) ; timeTP . setText ( "<b>" + dateFormat . format ( date . getTime ( ) ) + "</b>" ) ; } } ) . start ( ) ; String [ ] lb1 = { "Patient's General Information" , "Patient's Prescriptions" , "Patient's Anamnesis" , "Patient's Diagnosis" } ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { patientTP [ i ] = new JTextPane ( ) ; patientTP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; patientSP [ i ] = new JScrollPane ( patientTP [ i ] ) ; this . function . setOpacity ( this . patientTP [ i ] ) ; this . function . setOpacity ( patientSP [ i ] ) ; patientSP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; function . makeElementWithBorder ( patientSP [ i ] , lb1 [ i ] , Color . DARK_GRAY , false ) ; patientSP [ i ] . setVisible ( true ) ; } String [ ] lb = { "Patient" , "Patient's birth date" } ; patientTF = new JTextField [ lb . length ] ; for ( int i = 0 ; i < lb . length ; i ++ ) { patientTF [ i ] = new JTextField ( 15 ) ; function . makeElementWithBorder ( patientTF [ i ] , lb [ i ] , Color . DARK_GRAY , false ) ; patientTF [ i ] . setOpaque ( false ) ; } patientTF [ 1 ] . setPreferredSize ( new Dimension ( 80 , 40 ) ) ; ptPane . add ( timeTP , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( tpLoggedStaff , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . NORTHWEST , GridBagConstraints . BOTH , new Insets ( 50 , 15 , 0 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 0 ] , new GridBagConstraints ( 1 , 0 , 2 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 1 ] , new GridBagConstraints ( 3 , 0 , 2 , 1 , 0.2 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientListSP , new GridBagConstraints ( 4 , 1 , 1 , 3 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( testListSP , new GridBagConstraints ( 4 , 4 , 1 , 1 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; int pozY = 1 ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { ptPane . add ( patientSP [ i ] , new GridBagConstraints ( 0 , pozY , 4 , 2 , 0.5 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 5 , 5 , 5 , 5 ) , 0 , 0 ) ) ; pozY += 2 ; } ptPane . add ( testSP , new GridBagConstraints ( 4 , 5 , 1 , 4 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 55 , 15 ) , 0 , 0 ) ) ; this . nextB . setText ( "Next" ) ; this . nextB . addActionListener ( this ) ; ptPane . add ( nextB , new GridBagConstraints ( 4 , 8 , 1 , 1 , 0 , 0.5 , GridBagConstraints . SOUTH , GridBagConstraints . NONE , new Insets ( 0 , 15 , 5 , 15 ) , 0 , 0 ) ) ; new javax . swing . Timer ( 500000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { function . fillPatient ( patient ) ; patientTP [ 0 ] . setText ( null ) ; } } ) . start ( ) ; patientTF [ 0 ] . addKeyListener ( this ) ; patientList . addListSelectionListener ( this ) ; testList . addListSelectionListener ( this ) ; }
tr	3	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPath ) return this . equals ( ( ASPath ) o ) ; return false ; }
tr	0	public Iterator < ChannelUser > iterChannelUsers ( ) { return users . iterator ( ) ; }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( null ) . setVisible ( true ) ; } } ) ; }
tr	8	private MoveInfo IterativeDeepeningRoot2 ( GameState position ) { current_best_score = - SCORE_INFINITY ; current_search_depth = 0 ; ArimaaMove best_move = null ; this . initial_position = position ; GameState initial_gs = position ; resetStats ( ) ; enable_search ( ) ; GameState new_position = new GameState ( ) ; eval . PreProcessRootPosition ( position ) ; MoveList root_moves = genRootMoves ( initial_gs ) ; ProcessRootMoves ( initial_position , root_moves ) ; int offset = setup_search ( initial_gs ) ; LogFile . message ( "Score Offset: " + offset ) ; try { for ( int depth = initial_search_depth ; depth <= max_search_depth ; depth ++ ) { current_search_depth = depth ; int iteration_best_score = - SCORE_INFINITY ; int new_beta = SCORE_INFINITY ; root_moves . sort ( ) ; for ( ArimaaMove move : root_moves ) { int temp_score ; if ( move . move_ordering_value >= 30000 || move . move_ordering_value <= - 30000 ) { temp_score = move . move_ordering_value ; } else { new_position . play ( move , initial_position ) ; temp_score = SearchPosition ( new_position , depth , iteration_best_score , new_beta ) ; } move . move_ordering_value = temp_score ; if ( temp_score > iteration_best_score ) { iteration_best_score = temp_score ; current_best_score = temp_score ; best_move = move ; hash_table . RecordHash ( initial_position . getPositionHash ( ) , depth , iteration_best_score , HashTable . LOWER_BOUND , move , false ) ; String text = "D:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 8 , convertScore ( iteration_best_score ) ) ; text += "     " + getPV ( initial_position ) ; LogFile . message ( text ) ; MoveInfo mi = new MoveInfo ( ) ; mi . eval_score = current_best_score ; mi . move_text = gen_turn . getOfficialArimaaNotation ( initial_position , best_move ) ; mi . pv = getPV ( position ) ; mi . nodes_searched = this . ab_nodes_searched ; mi . ply = depth ; mi . search_time_ms = time_control . getElapsedSearchTime ( ) ; thread_mi = mi ; if ( iteration_best_score >= SCORE_FORCED_WIN ) { break ; } } } String text = "F:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 7 , convertScore ( current_best_score ) ) ; text += "     " ; text += " Nodes: " + ab_nodes_searched ; text += " QNodes: " + q_nodes_searched ; text += " kNPS: " + ab_nodes_searched / ( time_control . getElapsedSearchTime ( ) + 1 ) ; LogFile . message ( text ) ; if ( isMateScore ( iteration_best_score ) ) { break ; } } } catch ( AbortSearchException ex ) { LogFile . message ( "Search Aborted!" ) ; } engine_search_completed = true ; return thread_mi ; }
tr	3	@ Override public int resolve ( ) throws Exception { Room room = getMyRoom ( ) ; if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENDOWN ) ) { room . getTurtle ( ) . setPenStatus ( true ) ; return CommandConstants . COMMAND_RETURN_TRUE ; } else if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENUP ) ) { room . getTurtle ( ) . setPenStatus ( false ) ; return CommandConstants . COMMAND_RETURN_FALSE ; } else { if ( room . getTurtle ( ) . getPenStatus ( ) ) { return CommandConstants . COMMAND_RETURN_TRUE ; } else { return CommandConstants . COMMAND_RETURN_FALSE ; } } }
tr	8	public static ArrayList < Player > getEnemies ( Player player ) { ArrayList < Player > emenies = new ArrayList < Player > ( ) ; if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( BLUE ) ) && Teams . getPlayersOfTeam ( BLUE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( BLUE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( GREEN ) ) && Teams . getPlayersOfTeam ( GREEN ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( GREEN ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( ORANGE ) ) && Teams . getPlayersOfTeam ( ORANGE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( ORANGE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( RED ) ) && Teams . getPlayersOfTeam ( RED ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( RED ) ) ; } return emenies ; }
tr	9X	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case FVB : description = "FVB" ; break ; case RVB : description = "RVB" ; break ; case RPB : description = "RPB" ; break ; case FPB : description = "FPB" ; break ; case FVW : description = "FVW" ; break ; case RVW : description = "RVW" ; break ; case RPW : description = "RPW" ; break ; case FPW : description = "FPW" ; break ; case static : description = "Static" ; break ; case OTHER : description = "Other" ; break ; } return description ; }
tr	2	public AdditionalGradeEntries read ( Integer id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AdditionalGradeEntries instance = null ; try { instance = ( AdditionalGradeEntries ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
tr	3	public Method getSelectedMethod ( ) { if ( optRaw . isSelected ( ) ) return Method . RAW ; if ( optSameOrder . isSelected ( ) ) return Method . SAME_ORDER ; if ( optKnownFirst . isSelected ( ) ) return Method . KNOWN_FIRST ; return Method . NONE_SELECTED ; }
tr	2	private byte getFlags ( ) { byte b = 0 ; if ( isRoot ) { b |= 01 ; } if ( isOrdered ) { b |= 02 ; } return b ; }
tr	1	public static void writeStringToFile ( String content , String filename , boolean append ) { FileWriter fw ; try { fw = new FileWriter ( filename , append ) ; fw . append ( content ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	6	public void Solve ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= _max ; x1 ++ ) { for ( int y1 = 0 ; y1 <= _max ; y1 ++ ) { for ( int x2 = 0 ; x2 <= _max ; x2 ++ ) { for ( int y2 = 0 ; y2 <= _max ; y2 ++ ) { if ( x1 + y1 + x2 + y2 == 0 ) { continue ; } int length1 = x1 * x1 + y1 * y1 ; int length2 = x2 * x2 + y2 * y2 ; int x3 = Math . abs ( x1 - x2 ) ; int y3 = Math . abs ( y1 - y2 ) ; int length3 = x3 * x3 + y3 * y3 ; if ( length1 + length2 == length3 ) { count ++ ; } } } } } System . out . println ( "Result=" + count / 2 ) ; }
tr	6	LocalSocket ( Socket socket , PassthroughConnection ptc ) { this . ptc = ptc ; this . socket = socket ; DataInputStream inLocal = null ; DataOutputStream outLocal = null ; try { inLocal = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream to client" ) ; if ( inLocal != null ) { try { inLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream to client" ) ; } } in = null ; out = null ; success = false ; return ; } try { outLocal = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream from client" ) ; if ( outLocal != null ) { try { outLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream from client" ) ; } } in = null ; out = null ; success = false ; return ; } in = inLocal ; out = outLocal ; success = true ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	7	public List < CodeList > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < CodeList > codeLists = new ArrayList < CodeList > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeList" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { CodeList cl = processCodeList ( se , eventReader ) ; codeLists . add ( cl ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeLists" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { endTagReached = true ; } break ; } } return codeLists ; }
tr	0	@ Override public void setPopulation ( TspPopulation p ) { population = p ; }
tr	7	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	2	public static int [ ] idea_subkeys ( byte [ ] key ) { int [ ] encryptKeys = new int [ 52 ] ; int k1 ; for ( k1 = 0 ; k1 < 8 ; ++ k1 ) encryptKeys [ k1 ] = ( ( key [ 2 * k1 ] & ff ) << 8 ) | ( key [ 2 * k1 + 1 ] & ff ) ; for ( ; k1 < 52 ; ++ k1 ) encryptKeys [ k1 ] = ( ( encryptKeys [ k1 - 8 ] << 9 ) | ( encryptKeys [ k1 - 7 ] >>> 7 ) ) & ffff ; return encryptKeys ; }
tr	3	public void execute ( String [ ] args ) { if ( userError ( stack , args , 2 , 0 ) ) { try { if ( defines . containsKey ( args [ 1 ] ) ) { stack . push ( defines . get ( args [ 1 ] ) ) ; } else { stack . push ( double . parseDouble ( args [ 1 ] ) ) ; } } catch ( NumberFormatException ex ) { System . out . println ( "ERROR IN PUSH!" ) ; ex . printStackTrace ( ) ; } } }
tr	1	public static boolean isNull ( byte [ ] key ) { if ( key == null ) { return true ; } return isNull ( key , key . length ) ; }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	4	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt || der instanceof TipoFloat ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return new TipoBooleano ( ) ; } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } }
tr	3	@ Override public Vector < ScoredDocument > runQuery ( Query query , int numResults ) { Queue < ScoredDocument > rankQueue = new PriorityQueue < ScoredDocument > ( ) ; AbstractSearcher searcher = indexer . createSearcher ( query ) ; Document doc = null ; int docid = - 1 ; while ( ( doc = searcher . nextDoc ( docid ) ) != null ) { ScoredDocument scoredDoc = runquery ( query , doc ) ; rankQueue . add ( scoredDoc ) ; if ( rankQueue . size ( ) > numResults ) { rankQueue . poll ( ) ; } docid = doc . docId ; } Vector < ScoredDocument > results = new Vector < ScoredDocument > ( ) ; ScoredDocument scoredDoc = null ; while ( ( scoredDoc = rankQueue . poll ( ) ) != null ) { results . add ( scoredDoc ) ; } Collections . sort ( results , Collections . reverseOrder ( ) ) ; return results ; }
tr	0	public BlankPOIToken ( POIQuestionMarkToken reverse ) { super ( reverse ) ; }
tr	9X	public static void main ( String [ ] args ) throws Exception { int e1TotalWins = 0 , totalDraws = 0 , e1TotalLoses = 0 , e1WinAsPlayer1 = 0 , e1DrawAsPlayer1 = 0 , e1LoseAsPlayer1 = 0 , e1WinAsPlayer2 = 0 , e1DrawAsPlayer2 = 0 , e1LoseAsPlayer2 = 0 , e2TotalWins = 0 , e2TotalLoses = 0 , e2WinAsPlayer1 = 0 , e2DrawAsPlayer1 = 0 , e2LoseAsPlayer1 = 0 , e2WinAsPlayer2 = 0 , e2DrawAsPlayer2 = 0 , e2LoseAsPlayer2 = 0 ; Board boardTest1 = null ; Board initialPositionTest1 = null ; Board [ ] boardCollectionTest1 = null ; int currentIndexTest1 = 0 ; int numberOfMoveTest1 = 0 ; Player [ ] playersTest1 = { new Player ( "BoltzmannH5" , "BoltzmannH5" , "w" , 100000 ) , new Player ( "Charles_2" , "Charles_2" , "b" , 0 ) } ; int totalNumberOfMovesTest1 = 46 ; try { FileInputStream fisTest1 = new FileInputStream ( "50_boards_3.sav" ) ; ObjectInputStream oisTest1 = new ObjectInputStream ( fisTest1 ) ; boardCollectionTest1 = ( Board [ ] ) oisTest1 . readObject ( ) ; } catch ( Exception e ) { System . err . println ( "Error" + e . getMessage ( ) ) ; } long startTime = 0 , endTime = 0 ; startTime = System . currentTimeMillis ( ) ; for ( int testIndex = 1 ; testIndex <= 100 ; ++ testIndex ) { System . out . println ( "Test1: " + testIndex + " / 100" ) ; currentIndexTest1 = 0 ; numberOfMoveTest1 = 0 ; Player tmp = playersTest1 [ 0 ] ; playersTest1 [ 0 ] = playersTest1 [ 1 ] ; playersTest1 [ 1 ] = tmp ; if ( testIndex % 2 == 1 ) { boardTest1 = boardCollectionTest1 [ ( Integer ) testIndex / 2 ] ; initialPositionTest1 = boardTest1 . duplicate ( ) ; } else { boardTest1 = initialPositionTest1 . duplicate ( ) ; } while ( numberOfMoveTest1 < totalNumberOfMovesTest1 ) { if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "BoltzmannH5" ) ) { Tuple < Integer , Integer > move ; MonteCarloH5Boltzmann mc = new MonteCarloH5Boltzmann ( boardTest1 . duplicate ( ) , playersTest1 [ currentIndexTest1 ] . getColor ( ) , numberOfMoveTest1 , totalNumberOfMovesTest1 ) ; move = mc . uct ( playersTest1 [ currentIndexTest1 ] . getSimulationNumber ( ) ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } else if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "Charles_2" ) ) { Tuple < Integer , Integer > move ; Charles_2 charles = new Charles_2 ( playersTest1 [ currentIndexTest1 ] . getColor ( ) , boardTest1 ) ; move = charles . getMove ( ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } } String gameOutcome = Rules . calculateScore ( boardTest1 ) ; BufferedWriter outputTest1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; outputTest1 . append ( "Match #" + testIndex ) ; outputTest1 . newLine ( ) ; outputTest1 . append ( "Player 1: " + playersTest1 [ 0 ] . getName ( ) + " Player 2: " + playersTest1 [ 1 ] . getName ( ) ) ; outputTest1 . newLine ( ) ; if ( gameOutcome . equals ( "0" ) ) { ++ totalDraws ; outputTest1 . append ( "Result: draw" ) ; outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1DrawAsPlayer1 ++ ; e2DrawAsPlayer2 ++ ; } else { e1DrawAsPlayer2 ++ ; e2DrawAsPlayer1 ++ ; } } else { if ( gameOutcome . equals ( playersTest1 [ 0 ] . getColor ( ) ) ) { outputTest1 . append ( "Result: " + playersTest1 [ 0 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer1 ++ ; e2LoseAsPlayer2 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer1 ++ ; e1LoseAsPlayer2 ++ ; } } else { outputTest1 . append ( "Result: " + playersTest1 [ 1 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 1 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer2 ++ ; e2LoseAsPlayer1 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer2 ++ ; e1LoseAsPlayer1 ++ ; } } outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; } } endTime = System . currentTimeMillis ( ) ; BufferedWriter output1Test1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "*Summary (100k) 3-point board (t=2.5)*" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Draw occurred: " + totalDraws ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 total wins: " + e2TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 total wins: " + e1TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Play time: " + ( endTime - startTime ) / 1000 + " seconds." ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #1 : " + e2WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #2 : " + e2WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #1 : " + e2DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #2 : " + e2DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #1 : " + e2LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #2 : " + e2LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #1 : " + e1WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #2 : " + e1WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #1 : " + e1DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #2 : " + e1DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #1 : " + e1LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #2 : " + e1LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . close ( ) ; }
tr	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	3	@ Override public void visit ( YCompositeTask t ) { visited . add ( t ) ; if ( phase == 1 ) { FSPTask c = new FSPTask ( t . name ( ) ) ; c . container ( _current_net ) ; _current_net . components ( ) . put ( c . name ( ) , c ) ; _components . put ( t , c ) ; assert t . name ( ) == c . name ( ) ; process_gates ( t , c ) ; } else if ( phase == 2 ) { ( ( FSPAbstractTask ) _components . get ( t ) ) . decomposesTo ( _nets . get ( t . decomposesTo ( ) ) ) ; process_outgoing_links ( t ) ; } else if ( phase == 3 ) { } else { } }
tr	8	private int getKingAxisVal ( int loc ) { switch ( loc ) { case 0 : case 7 : return - 4 ; case 1 : case 6 : return - 2 ; case 2 : case 5 : return 2 ; case 3 : case 4 : return 4 ; default : return 0 ; } }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	5	private void constructGUIControls ( ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager poseurStateManager = singleton . getStateManager ( ) ; canvasSplitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; appWindow = new AnimatedSpriteViewer ( ) ; PoseCanvasState zoomableCanvasState = poseurStateManager . getZoomableCanvasState ( ) ; zoomableCanvas = new PoseCanvas ( zoomableCanvasState ) ; zoomableCanvasState . setPoseCanvas ( zoomableCanvas ) ; zoomableCanvas . setBackground ( ZOOMABLE_CANVAS_COLOR ) ; northPanel = new JPanel ( ) ; northOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfRightCanvas = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; vertical = new JScrollPane ( southOfRightCanvas ) ; MediaTracker tracker = new MediaTracker ( this ) ; int idCounter = 0 ; fileToolbar = new JToolBar ( ) ; newButton = ( JButton ) initButton ( NEW_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , NEW_TOOLTIP ) ; openButton = ( JButton ) initButton ( OPEN_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , OPEN_TOOLTIP ) ; saveButton = ( JButton ) initButton ( SAVE_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_TOOLTIP ) ; saveAsButton = ( JButton ) initButton ( SAVE_AS_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_AS_TOOLTIP ) ; exportButton = ( JButton ) initButton ( EXPORT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXPORT_TOOLTIP ) ; exitButton = ( JButton ) initButton ( EXIT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXIT_TOOLTIP ) ; editToolbar = new JToolBar ( ) ; selectionButton = ( JButton ) initButton ( SELECTION_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , SELECT_TOOLTIP ) ; cutButton = ( JButton ) initButton ( CUT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , CUT_TOOLTIP ) ; copyButton = ( JButton ) initButton ( COPY_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , COPY_TOOLTIP ) ; pasteButton = ( JButton ) initButton ( PASTE_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , PASTE_TOOLTIP ) ; moveToBackButton = ( JButton ) initButton ( MOVE_TO_BACK_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_BACK_TOOLTIP ) ; moveToFrontButton = ( JButton ) initButton ( MOVE_TO_FRONT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_FRONT_TOOLTIP ) ; shapeToolbar = new JToolBar ( ) ; shapeButtonGroup = new ButtonGroup ( ) ; lineToggleButton = ( JToggleButton ) initButton ( LINE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , LINE_TOOLTIP ) ; rectToggleButton = ( JToggleButton ) initButton ( RECT_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , RECT_TOOLTIP ) ; ellipseToggleButton = ( JToggleButton ) initButton ( ELLIPSE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , ELLIPSE_TOOLTIP ) ; DefaultComboBoxModel lineThicknessModel = new DefaultComboBoxModel ( ) ; for ( int i = 0 ; i < NUM_STROKES_TO_CHOOSE_FROM ; i ++ ) { String imageFileName = STROKE_SELECTION_FILE_PREFIX + ( i + 1 ) + PNG_FILE_EXTENSION ; Image img = batchLoadImage ( imageFileName , tracker , idCounter ++ ) ; ImageIcon ii = new ImageIcon ( img ) ; lineThicknessModel . addElement ( ii ) ; } lineStrokeSelectionComboBox = new JComboBox ( lineThicknessModel ) ; zoomToolbar = new JToolBar ( ) ; zoomOutButton = ( JButton ) initButton ( ZOOM_OUT_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_OUT_TOOLTIP ) ; zoomInButton = ( JButton ) initButton ( ZOOM_IN_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_IN_TOOLTIP ) ; zoomLabel = new JLabel ( ) ; zoomLabel . setFont ( ZOOM_LABEL_FONT ) ; updateZoomLabel ( ) ; dimensionsButton = ( JButton ) initButton ( POSE_DIMENSIONS_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , CHANGE_POSE_DIMENSIONS_TOOLTIP ) ; colorSelectionToolbar = new JToolBar ( ) ; colorButtonGroup = new ButtonGroup ( ) ; outlineColorSelectionButton = ( ColorToggleButton ) initButton ( OUTLINE_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , OUTLINE_TOOLTIP ) ; outlineColorSelectionButton . setBackground ( Color . BLACK ) ; fillColorSelectionButton = ( ColorToggleButton ) initButton ( FILL_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , FILL_TOOLTIP ) ; fillColorSelectionButton . setBackground ( Color . WHITE ) ; outlineColorSelectionButton . setSelected ( true ) ; ColorPalletLoader cpl = new ColorPalletLoader ( ) ; ColorPalletState cps = new ColorPalletState ( ) ; cpl . initColorPallet ( COLOR_PALLET_SETTINGS_XML , cps ) ; colorPallet = new ColorPallet ( cps ) ; cps . setView ( colorPallet ) ; customColorSelectorButton = ( JButton ) initButton ( CUSTOM_COLOR_SELECTOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , JButton . class , null , CUSTOM_COLOR_TOOLTIP ) ; alphaLabel = new JLabel ( ALPHA_LABEL_TEXT ) ; alphaLabel . setFont ( ALPHA_LABEL_FONT ) ; alphaLabel . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider = new JSlider ( JSlider . HORIZONTAL , TRANSPARENT , OPAQUE , OPAQUE ) ; transparencySlider . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider . setMajorTickSpacing ( ALPHA_MAJOR_TICK_SPACING ) ; transparencySlider . setMinorTickSpacing ( ALPHA_MINOR_TICK_SPACING ) ; transparencySlider . setPaintLabels ( true ) ; transparencySlider . setPaintTicks ( true ) ; transparencySlider . setPaintTrack ( true ) ; transparencySlider . setToolTipText ( ALPHA_TOOLTIP ) ; transparencySlider . setSnapToTicks ( false ) ; labelPoses = appWindow . getLabelPoses ( ) ; try { imagePose = ImageIO . read ( new File ( EDITPOSE_IMAGE_FILE ) ) ; System . out . println ( "Image has read" ) ; picLabelPose = new JLabel ( new ImageIcon ( imagePose ) ) ; } catch ( IOException ex ) { System . out . println ( "Did not read Image" ) ; } jtbEdit = new JToolBar ( ) ; idCounter = 0 ; btnNewPose = ( JButton ) initButton ( NEWPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , NEWPOSE_TOOLTIP ) ; btnSavePose = ( JButton ) initButton ( SAVEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , SAVEPOSE_TOOLTIP ) ; btnOpenPose = ( JButton ) initButton ( OPENPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , OPENPOSE_TOOLTIP ) ; btnDeletePose = ( JButton ) initButton ( DELETEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DELETEPOSE_TOOLTIP ) ; btnDuplicatePose = ( JButton ) initButton ( DUPLICATEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DUPLICATEPOSE_TOOLTIP ) ; btnShiftLeftPose = ( JButton ) initButton ( SHIFTLEFT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , LEFTPOSE_TOOLTIP ) ; btnShifRighttPose = ( JButton ) initButton ( SHIFTRIGHT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , RIGHTPOSE_TOOLTIP ) ; btnSetDurationPose = ( JButton ) initButton ( DURATIONPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DURATIONPOSE_TOOLTIP ) ; northOfZoomableCanvasPanel = new JPanel ( ) ; northOfZoomableCanvasPanel . setLayout ( new BorderLayout ( ) ) ; try { if ( ! appWindow . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { this . setDisablePoseButton ( true ) ; } else { setDisablePoseButton ( false ) ; } } catch ( NullPointerException e ) { setDisablePoseButton ( false ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { Logger . getLogger ( PoseurGUI . class . getName ( ) ) . log ( Level . SEVERE , null , ie ) ; } }
tr	8	public static String [ ] splitbyLetter2 ( CharSequence text ) { list . clear ( ) ; int pos = 0 ; int len = text . length ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charAt ( i ) ; if ( c > 58 ) { if ( first ) { first = false ; buffer [ pos ++ ] = c ; continue ; } list . add ( new String ( buffer , 0 , pos ) ) ; pos = 0 ; buffer [ pos ++ ] = c ; } else if ( c == 32 || c == 10 || c == 47 || c == 13 || c == 9 ) { } else { buffer [ pos ++ ] = c ; } } list . add ( new String ( buffer , 0 , pos ) ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
tr	4	public void update ( final long newCurrent , final String optStatus ) { if ( this . upperLimit == - 1 ) { throw new IllegalArgumentException ( "This progress printer has not been initialized" ) ; } this . ownPos = newCurrent ; long sumOfSubProgresses = 0 ; this . currentPos = 0 ; for ( final ProgressPrinter subProgress : this . subProgress . keySet ( ) ) { double percentFinishedSubProgress = subProgress . getPercent ( ) / 100.0 ; long totalNumberStepsSubProgress = this . subProgress . get ( subProgress ) ; this . currentPos += ( percentFinishedSubProgress * totalNumberStepsSubProgress ) ; sumOfSubProgresses += totalNumberStepsSubProgress ; } final long remainingPart = this . upperLimit - sumOfSubProgresses ; if ( remainingPart < 0 ) { throw new IllegalArgumentException ( "Invalid part-sums of sub progresses" ) ; } this . currentPos += this . ownPos ; final float newPercent = this . currentPos > 0 ? ( ( float ) ( this . currentPos ) / this . upperLimit * 100.0f ) : 0.0f ; this . optStatus = optStatus ; this . % = newPercent ; this . fireChangeListener ( ) ; }
tr	9X	public static void main ( String [ ] args ) { boolean ok = false ; long startTime , endTime ; LinkedList < Drone > mDroneArm = new LinkedList < > ( ) ; DroneQueue droneQueue = new DroneQueue ( mDroneArm ) ; Config config = Config . getInstance ( ) ; config . load ( "config.xml" ) ; clearKMLs ( ) ; String dirs [ ] = config . getOption ( Config . GTFS_DIRS ) . split ( " " ) ; int timeGap = config . getIntOption ( Config . GTFS_TIME_GAP ) ; GraphFrame gp = null ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp = new GraphFrame ( ) ; } final String password = Config . getInstance ( ) . getOption ( Config . SERVER_PASSWORD ) ; final int port = Config . getInstance ( ) . getIntOption ( Config . SERVER_PORT ) ; GPSPortal g = new GPSPortal ( port , password ) ; int id = 1 ; final double busSpeed = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_SPEED ) ; final double busUpdateTime = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_UPDATE_SPEED ) ; boolean dronesActive = config . getBooleanOption ( Config . DRONES_ACTIVE ) ; if ( dronesActive ) { System . out . println ( "Drones Active!" ) ; } ArrayList < GTFS > gtfs = new ArrayList < > ( ) ; for ( String dir : dirs ) { dir = dir . trim ( ) ; System . out . println ( dir + "\n----------" ) ; try { startTime = System . currentTimeMillis ( ) ; GTFS current = new GTFS ( dir , timeGap ) ; gtfs . add ( current ) ; endTime = System . currentTimeMillis ( ) ; System . out . println ( dir + " loaded and parsed in " + ( ( endTime - startTime ) / 1000.0 ) + " seconds" ) ; System . out . println ( dir + " id: " + current . getID ( ) ) ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . adjustViewport ( current . getMinLon ( ) , current . getMinLat ( ) , current . getMaxLon ( ) , current . getMaxLat ( ) ) ; gp . addPaths ( current . getPaths ( ) ) ; } if ( dronesActive ) { for ( int i = 0 ; i < current . getPaths ( ) . size ( ) ; i ++ ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; if ( current . isValidService ( current . getPaths ( ) . get ( i ) . getServiceID ( ) ) && current . getPaths ( ) . get ( i ) . getEndTimecode ( ) > now ) { System . out . println ( dir + ": " + current . getPaths ( ) . get ( i ) ) ; droneQueue . addDrone ( new Drone ( id , current . getPaths ( ) . get ( i ) , busSpeed , busUpdateTime , "http://127.0.0.1:8080" , password , false ) ) ; id ++ ; } } } ok = true ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( ) ; } if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . setVisible ( true ) ; } boolean running = true ; int vListTimeout = Config . getInstance ( ) . getIntOption ( Config . VEHICLE_LIST_TIMEOUT ) ; System . out . println ( "Running..." ) ; while ( running ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; Vehicle . cleanUp ( vListTimeout ) ; droneQueue . check ( now ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( WTBBackend . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } System . gc ( ) ; running = ! droneQueue . isEmpty ( ) ; } }
tr	9X	public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , ParseException { Properties properties = new Properties ( ) ; properties . load ( Client . class . getClassLoader ( ) . getResourceAsStream ( "client.properties" ) ) ; Integer serverPort = Integer . valueOf ( properties . getProperty ( "client.server_port" , "1234" ) ) ; String serverAddress = properties . getProperty ( "client.server_address" , "localhost" ) ; ObjectOutputStream toServer = null ; ObjectInputStream fromServer = null ; Socket connectionSocket = null ; try { connectionSocket = new Socket ( serverAddress , serverPort ) ; Scanner scanner = new Scanner ( System . in ) ; toServer = new ObjectOutputStream ( connectionSocket . getOutputStream ( ) ) ; fromServer = new ObjectInputStream ( connectionSocket . getInputStream ( ) ) ; log . info ( "Connection created!" ) ; while ( ! start ( toServer , fromServer , scanner ) ) ; while ( homePage ( toServer , fromServer , scanner ) ) ; } catch ( IOException e ) { log . error ( "Can't connect to server." , e ) ; } catch ( NoSuchElementException e ) { log . error ( "User terminated session" , e ) ; } finally { if ( toServer != null ) { try { toServer . close ( ) ; } catch ( IOException e ) { log . error ( "To server stream closing error" , e ) ; } } if ( fromServer != null ) { try { fromServer . close ( ) ; } catch ( IOException e ) { log . error ( "From server stream closing error" , e ) ; } } if ( connectionSocket != null ) { try { connectionSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Connection socket closing error" , e ) ; } } } }
tr	0	public void setFinalGrades ( boolean value ) { this . finalGrades = value ; }
tr	4	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . requestEnvelope != null ) { String newPrefix = prefix + "requestEnvelope." ; sb . append ( this . requestEnvelope . toNVPString ( newPrefix ) ) ; } if ( this . createAccountKey != null ) { sb . append ( prefix ) . append ( "createAccountKey=" ) . append ( NVPUtil . encodeUrl ( this . createAccountKey ) ) ; sb . append ( "&" ) ; } if ( this . countryCode != null ) { sb . append ( prefix ) . append ( "countryCode=" ) . append ( NVPUtil . encodeUrl ( this . countryCode ) ) ; sb . append ( "&" ) ; } if ( this . languageCode != null ) { sb . append ( prefix ) . append ( "languageCode=" ) . append ( NVPUtil . encodeUrl ( this . languageCode ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	8	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
tr	7	public void actionPerformed ( ActionEvent ae ) { ADocument aDoc = ( ADocument ) textPane . getDocument ( ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; ^ ^ = textPane . getCaret ( ) ; int . = ^ . getDot ( ) ; int mark = ^ . getMark ( ) ; if ( . != mark ) return ; ADocumentFragment fragment = null ; try { Transferable tr = clipboard . getContents ( this ) ; DataFlavor flavor = new DataFlavor ( ADocumentFragment . MIME_TYPE ) ; if ( tr . isDataFlavorSupported ( flavor ) ) fragment = ( ADocumentFragment ) tr . getTransferData ( flavor ) ; else { flavor = new DataFlavor ( "application/x-java-serialized-object; class=java.lang.String" ) ; if ( tr . isDataFlavorSupported ( flavor ) ) { String s = new String ( ( ( ( String ) tr . getTransferData ( flavor ) ) ) ) ; fragment = new ADocumentFragment ( s , null , null ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( fragment == null ) return ; aDoc . startCompoundEdit ( ) ; ADocument . pasteADocFragment ( aDoc , . , fragment ) ; aDoc . endCompoundEdit ( null ) ; aDoc . fireADocumentChanged ( ) ; }
tr	2	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; if ( "writeObj" . equals ( method . getName ( ) ) ) { Object obj = args [ 0 ] ; serializer . serialize ( pWriter , obj ) ; } else if ( "readObj" . equals ( method . getName ( ) ) ) { deSerList = deSerializer . deSerialize ( ) ; return deSerList ; } return null ; }
tr	4	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
tr	5	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = 1.0 ; } else if ( x [ i ] < ( a + b ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else func [ i ] = 0.0 ; } return func ; }
tr	1	final int nextInt ( ) { if ( 0 == count -- ) { isaac ( ) ; count = SIZE - 1 ; } return ( rsl [ count ] ) ; }
tr	9X	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
tr	5	private static boolean KawigiEdit_RunTest ( int testNum , String p0 , int p1 , int p2 , boolean hasAnswer , int p3 ) { System . out . print ( "Test " + testNum + ": [" + "\"" + p0 + "\"" + " " + p1 + " " + p2 ) ; System . out . println ( "]" ) ; OneDimensionalRobotEasy obj ; int answer ; obj = new OneDimensionalRobotEasy ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . finalPosition ( p0 , p1 , p2 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p3 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p3 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	3	public void saveGame ( ) throws CannotSaveException { try { SaveFile saveFile = new SaveFile ( GameSaver . AUTO_SAVE_LOCATION ) ; FileOutputStream saveStream = new FileOutputStream ( saveFile . getFile ( ) ) ; ObjectOutputStream save = new ObjectOutputStream ( saveStream ) ; save . writeObject ( GameState . getInstance ( ) ) ; save . close ( ) ; } catch ( CannotCreateFileException e ) { throw new CannotSaveException ( "Cannot create file" ) ; } catch ( FileNotFoundException e ) { throw new CannotSaveException ( "File not found" ) ; } catch ( IOException e ) { throw new CannotSaveException ( "IO Exception" ) ; } }
tr	5	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	2	private void listAllEmail ( List < Email > emailList , POP3Session session ) { String responseStr = null ; for ( int i = 0 ; i < emailList . size ( ) ; i ++ ) { if ( emailList . get ( i ) . isDeleted ( ) == false ) { responseStr = i + 1 + " " + EmailUtil . getEmailSize ( emailList . get ( i ) ) ; session . sendResponse ( responseStr ) ; } } }
tr	3	public void modifyCourse ( ClassInfo classInfo ) { ClassInfo cInfoData = getCourse ( classInfo . getClassNumber ( ) ) ; if ( cInfoData != null ) { if ( ! classInfo . getCourseName ( ) . equalsIgnoreCase ( cInfoData . getCourseName ( ) ) ) { Course crs = new Course ( ) ; crs . setCourseID ( classInfo . getCourseNumber ( ) ) ; crs . setCourseName ( classInfo . getCourseName ( ) ) ; saveDataModify ( crs ) ; } if ( ! classInfo . getCourseSection ( ) . equalsIgnoreCase ( cInfoData . getCourseSection ( ) ) ) { SchoolClass cls = new SchoolClass ( ) ; cls . setClassNumber ( classInfo . getClassNumber ( ) ) ; cls . setClassSection ( classInfo . getCourseSection ( ) ) ; saveDataModify ( cls ) ; } } }
tr	1	@ Test public void setFormat_shouldThrowAnException_whenTypeIsNotStringAndFormatIsTime ( ) throws Exception { SimpleTypeSchema schema = new SimpleTypeSchema ( ) ; schema . setType ( SimpleType . NUMBER ) ; try { schema . setFormat ( "time" ) ; fail ( "Expected an exception" ) ; } catch ( IllegalArgumentException e ) { } }
tr	0	@ Override public void paintComponents ( Graphics g ) { g . setClip ( m_areaFill ) ; super . paintComponents ( g ) ; paintBorder ( g ) ; }
tr	4	private void refilter ( ) { filteredList . clear ( ) ; for ( PasswordEntry entry : group . getListEntry ( ) ) { if ( compare ( entry . getURL ( ) ) || compare ( entry . getTitle ( ) ) || compare ( entry . getNotes ( ) ) ) { filteredList . add ( entry ) ; } } }
tr	9X	private void doTransfer ( ) throws IOException { if ( ressourceInputStream == null ) { if ( sendHeaderInRsp ) { String header = new FileRequestResponseMessage ( ResponseCode . NEVER_TRY_AGAIN , 0 ) . Serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkOutputStream . write ( header . getBytes ( ) ) ; } networkOutputStream . close ( ) ; return ; } else { if ( offset > numAvailableData ) { logger . log ( Level . INFO , "Requested offset is not valid: requested " + offset + "  length of file: " + numAvailableData ) ; if ( sendHeaderInRsp ) networkOutputStream . write ( new FileRequestResponseMessage ( ResponseCode . OK , 0 ) . Serialize ( ) . getBytes ( ) ) ; networkOutputStream . close ( ) ; transferState = TransferStatus . Finished ; return ; } if ( offset + expectedTransferVolume > numAvailableData ) { logger . log ( Level . INFO , "Requested length of " + expectedTransferVolume + " was too large  shortened  it to " + expectedTransferVolume ) ; expectedTransferVolume = numAvailableData - offset ; } transferState = TransferStatus . Transfering ; if ( sendHeaderInRsp ) networkOutputStream . write ( ( new FileRequestResponseMessage ( ResponseCode . OK , expectedTransferVolume ) . Serialize ( ) ) . getBytes ( Message . ENCODING ) ) ; if ( bufferSize == - 1 ) { bufferSize = FALLBACK_BUFFER_SIZE ; logger . log ( Level . INFO , "Using fallback buffersize " + bufferSize ) ; } logger . info ( "sending data" ) ; ressourceInputStream . skip ( offset ) ; int bytesRead = 0 ; int bytesToRead = bufferSize ; byte [ ] buffer = new byte [ bufferSize ] ; while ( bytesToRead > 0 && keepTransferAlive && totalTransferedVolume < expectedTransferVolume && ( bytesRead = ressourceInputStream . read ( buffer , 0 , bytesToRead ) ) != - 1 ) { networkOutputStream . write ( buffer , 0 , bytesRead ) ; totalTransferedVolume += bytesRead ; if ( totalTransferedVolume + bytesToRead > expectedTransferVolume ) { bytesToRead = ( int ) ( expectedTransferVolume - totalTransferedVolume ) ; } } networkOutputStream . flush ( ) ; networkOutputStream . close ( ) ; ressourceInputStream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totalTransferedVolume == expectedTransferVolume ) transferState = TransferStatus . Finished ; else { if ( ! keepTransferAlive ) transferState = TransferStatus . Canceled ; else transferState = TransferStatus . LostConnection ; } } }
tr	5	@ Override public void enter ( BlockNode block , Deque < BlockNode > stack ) { ChangeNode previous = null ; Iterator < Node > nodes = block . - . iterator ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . next ( ) ; if ( n instanceof ChangeNode ) { ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) { previous = null ; continue ; } if ( previous != null && cn . type == previous . type ) { previous . change += cn . change ; nodes . remove ( ) ; } else { previous = cn ; } } else { previous = null ; } } }
tr	5	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
tr	1	public boolean noun2Modifier ( DataHolder dataholderHandler , String word ) { boolean isUpdated = false ; ArrayList < String > deletedPOSs = new ArrayList < String > ( ) ; deletedPOSs . add ( "s" ) ; deletedPOSs . add ( "p" ) ; deletedPOSs . add ( "n" ) ; for ( String POS : deletedPOSs ) { dataholderHandler . deleteWordPOS ( true , word , true , POS ) ; } dataholderHandler . updateDataHolder ( word , "m" , "" , "modifiers" , 1 ) ; String oldPattern = String . format ( "(^%s$|^.* %s$)" , word , word ) ; dataholderHandler . updateSentenceTag ( oldPattern , null ) ; return isUpdated ; }
tr	6	public void removePriceStep ( double startPrice , double endPrice ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; if ( startPrice < 0 || endPrice < 0 ) throw new PriceStepNegativeArgumentException ( ) ; PriceStep removeStep = null ; for ( PriceStep storedStep : priceSteps ) { if ( storedStep . getStartPrice ( ) == startPrice && storedStep . getEndPrice ( ) == endPrice ) { removeStep = storedStep ; } } if ( removeStep == null ) { throw new PriceStepIntervalNotFoundException ( ) ; } else { priceSteps . remove ( removeStep ) ; } }
tr	4	public boolean autoCheckSibMessage ( String xml , String id [ ] , String ref [ ] ) { Hashtable hashtable = SibXMLMessageParser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( String ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
tr	7	private void verifyForeignKeyConstraints ( Tuple tuple ) throws DatabaseException { for ( Schema . ForeignKey fk : schema . getForeignKeys ( ) ) { Table refTable = fk . getRefTable ( ) ; int [ ] localKeyPositions = fk . getForeignKeyPositions ( ) ; Object [ ] localKeyValues = new Object [ localKeyPositions . length ] ; Attribute . Type [ ] localKeyTypes = new Attribute . Type [ localKeyPositions . length ] ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { localKeyValues [ i ] = tuple . getValueAt ( localKeyPositions [ i ] ) ; localKeyTypes [ i ] = schema . getAttributes ( ) [ localKeyPositions [ i ] ] . getType ( ) ; } int [ ] refKeyPositions = refTable . getSchema ( ) . getPrimaryKeyPositions ( ) ; boolean matchFound = false ; for ( Tuple refTuple : refTable . getTuples ( ) ) { matchFound = true ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { if ( ! Tuple . valuesEqual ( localKeyTypes [ i ] , localKeyValues [ i ] , refTuple . getValueAt ( refKeyPositions [ i ] ) ) ) { matchFound = false ; break ; } } if ( matchFound ) break ; } if ( ! matchFound ) { throw new DatabaseException ( "Referential constraint to table '" + refTable . getName ( ) + "' not met." ) ; } } }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Type other = ( Type ) obj ; if ( collectionType != other . collectionType ) return false ; if ( javaClass == null ) { if ( other . javaClass != null ) return false ; } else if ( ! javaClass . equals ( other . javaClass ) ) return false ; return true ; }
tr	7	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Create" ; change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . folder != null && this . folder . isDirty ( ) ) { change += this . folder . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Create>\n" ; } setNotDirty ( ) ; return change ; }
tr	3	public double getDistanceAB ( ArrayList < Object > path ) { ArrayList < Object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new ArrayList < Object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( Road road : roads ) { if ( road . getNodesAttached ( ) . containsAll ( nodes ) ) { distance += road . getDistance ( ) ; } } } distance = UtilCalc . round ( distance , 2 ) ; return distance ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	5	protected void doRun ( ) { runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	5	public boolean move ( Direction direction , StringBuffer output ) throws EndGameException { boolean hasMoved = false ; if ( myPosition . isCrossable ( direction ) ) { if ( myPosition . hasCharacter ( direction ) ) { Character defender = myPosition . getCharacter ( direction ) ; if ( attack ( defender ) ) { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You attacked and killed " + defender + ". You moved " + direction ) ; hasMoved = true ; } else { if ( isDead ( ) ) throw new EndGameException ( "Player has died. GAME OVER!" ) ; output . append ( "You attacked: \n" + defender . toString ( ) + "\n" + this . toString ( ) ) ; } } else { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You moved " + direction + "." ) ; hasMoved = true ; } } else { output . append ( checkIfLockedExit ( direction ) ) ; } if ( hasMoved ) { notifyPositionChanged ( direction . getOppositeDirection ( ) ) ; } return hasMoved ; }
tr	5	public int generateDurability ( int blockY ) { int durability = baseDurability_ ; if ( variance_ > 0 ) { durability += Citadel . getRandom ( ) . nextInt ( ) % ( variance_ * 2 + 1 ) ; durability -= variance_ ; } if ( yAdjustment_ < 0.00001 || yAdjustment_ > 0.00001 ) { durability += ( int ) ( ( float ) blockY * yAdjustment_ ) ; } if ( durability < minDurability_ ) { return minDurability_ ; } if ( durability > maxDurability_ ) { return maxDurability_ ; } return durability ; }
tr	0	public void setCodTipoPagamento ( Integer codTipoPagamento ) { this . codTipoPagamento = codTipoPagamento ; }
tr	7	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
tr	5	public boolean getRGBPixels ( int x , int y , int width , int height , int [ ] pixels ) { if ( getRGBPixelsMethod != null ) try { if ( getRGBPixelsMethodType == 0 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 1 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { new Rectangle ( x , y , width , height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 2 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , new Rectangle ( x , y , width , height ) , pixels } ) ; else getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; return true ; } catch ( Exception ex ) { } int [ ] tmp = getRGBPixels ( new Rectangle ( x , y , width , height ) ) ; System . arraycopy ( tmp , 0 , pixels , 0 , width * height ) ; return false ; }
tr	4	public void creerOuvriere ( String evenementActuel , int nbLarves ) { if ( nbLarves > 1 ) { if ( nbLarves == 2 ) { ajouterFourmi ( 1 ) ; } if ( nbLarves == 4 ) { ajouterFourmi ( 2 ) ; } if ( evenementActuel . equals ( Constantes . EVEN_OUVRIERES ) ) { ajouterFourmi ( 1 ) ; } } }
tr	2	public int priseTerritoire ( Territoire t , int nbUnite ) { if ( this . nbUniteBonus >= nbUnite - 1 ) { this . nbUniteBonus -= nbUnite - 1 ; nbUnite = 1 ; } else { nbUnite -= this . nbUniteBonus ; this . nbUniteBonus = 0 ; } this . nbUniteEnMain -= nbUnite ; t . setNbUnite ( nbUnite ) ; t . setOccupant ( this ) ; this . territoiresOccupes . add ( t ) ; this . actionPriseTerritoire ( t ) ; if ( hasPower ( ) ) { this . pouvoir . actionPriseTerritoire ( t ) ; } return nbUnite ; }
tr	0	public void _fatal ( Object context ) { }
tr	8	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<BalloonStyle" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . color != null ) { kml += "<color>" + SpecialCaseFormatter . toKMLString ( this . color ) + "</color>\n" ; } if ( this . bgColor != null ) { kml += "<bgColor>" + SpecialCaseFormatter . toKMLString ( this . bgColor ) + "</bgColor>\n" ; } if ( this . textColor != null ) { kml += "<textColor>" + SpecialCaseFormatter . toKMLString ( this . textColor ) + "</textColor>\n" ; } if ( this . text != null ) { kml += "<text>" + SpecialCaseFormatter . toKMLString ( this . text ) + "</text>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</BalloonStyle>\n" ; } return kml ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	0	public void actionPerformed ( ActionEvent event ) { Main . newSet ( ) ; }
tr	5	public void packTag ( byte [ ] bytes ) { Arrays . fill ( bytes , ( byte ) 0 ) ; try { BufferTools . stringIntoByteBuffer ( TAG , 0 , 3 , bytes , 0 ) ; } catch ( UnsupportedEncodingException e ) { } packField ( bytes , title , TITLE_LENGTH , TITLE_OFFSET ) ; packField ( bytes , artist , ARTIST_LENGTH , ARTIST_OFFSET ) ; packField ( bytes , album , ALBUM_LENGTH , ALBUM_OFFSET ) ; packField ( bytes , year , YEAR_LENGTH , YEAR_OFFSET ) ; if ( genre < 128 ) { bytes [ GENRE_OFFSET ] = ( byte ) genre ; } else { bytes [ GENRE_OFFSET ] = ( byte ) ( genre - 256 ) ; } if ( track == null ) { packField ( bytes , comment , COMMENT_LENGTH_V1_0 , COMMENT_OFFSET ) ; } else { packField ( bytes , comment , COMMENT_LENGTH_V1_1 , COMMENT_OFFSET ) ; String trackTemp = numericsOnly ( track ) ; if ( trackTemp . length ( ) > 0 ) { int trackInt = Integer . parseInt ( trackTemp ) ; if ( trackInt < 128 ) { bytes [ TRACK_OFFSET ] = ( byte ) trackInt ; } else { bytes [ TRACK_OFFSET ] = ( byte ) ( trackInt - 256 ) ; } } } }
tr	0	public void addConversation ( Conversation c ) { conversations . add ( c ) ; }
tr	6	protected void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '' : prevCharIsCR = true ; break ; case '' : prevCharIsLF = true ; break ; case 	 : column -- ; column += ( tabSize - ( column % tabSize ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; }
tr	4	public static boolean isAncestorOf ( Node node , Node descendant ) { if ( node == null || descendant == null ) { return false ; } for ( Node currentNode = descendant . getParentNode ( ) ; currentNode != null ; currentNode = currentNode . getParentNode ( ) ) { if ( currentNode == node ) { return true ; } } return false ; }
tr	8	@ Override public void marshal ( Element amdSec , Document doc ) { super . marshal ( amdSec , doc ) ; String metsNs = NS . METS . ns ( ) ; if ( this . techMD != null ) { for ( MdSec mds : this . techMD ) { Element techMD = doc . createElementNS ( metsNs , "mets:techMD" ) ; mds . marshal ( techMD , doc ) ; amdSec . appendChild ( techMD ) ; } } if ( this . rightsMD != null ) { for ( MdSec mds : this . rightsMD ) { Element rightsMD = doc . createElementNS ( metsNs , "mets:rightsMD" ) ; mds . marshal ( rightsMD , doc ) ; amdSec . appendChild ( rightsMD ) ; } } if ( this . sourceMD != null ) { for ( MdSec mds : this . sourceMD ) { Element sourceMD = doc . createElementNS ( metsNs , "mets:sourceMD" ) ; mds . marshal ( sourceMD , doc ) ; amdSec . appendChild ( sourceMD ) ; } } if ( this . digiprovMD != null ) { for ( MdSec mds : this . digiprovMD ) { Element digiprovMD = doc . createElementNS ( metsNs , "mets:digiprovMD" ) ; mds . marshal ( digiprovMD , doc ) ; amdSec . appendChild ( digiprovMD ) ; } } }
tr	6	boolean line ( ) throws IOException { int lev = integer ( ) - 1 ; if ( lev == - 1 ) return false ; int c = read ( ) ; if ( c == 1 ) { int len ; bb . reset ( ) ; while ( ( len = integer ( ) ) > 0 ) { bb . extend ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { bb . put ( ( byte ) read ( ) ) ; } } event . level ( lev ) ; event . event ( bb . clone ( ) ) ; return true ; } else if ( c > 1 ) { bb . reset ( ) ; bb . extend ( 64 ) ; bb . put ( ( byte ) c ) ; while ( ( c = read ( ) ) != 0 ) bb . put ( ( byte ) c ) ; event . level ( lev ) ; event . event ( new String ( bb . getBuffer ( ) , 0 , bb . length ( ) , "UTF-8" ) ) ; return true ; } else { event . level ( lev ) ; event . event ( "" ) ; } return true ; }
tr	5	public String toString ( boolean printHeaderRow , String additionalColumnHeader , String additionalColumnValue ) { final List < Identifier > keys = new ArrayList < Identifier > ( variables . keySet ( ) ) ; Collections . sort ( keys , new Comparator < Identifier > ( ) { @ Override public int compare ( Identifier o1 , Identifier o2 ) { final int result = o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; if ( o1 . getValue ( ) . length ( ) < o2 . getValue ( ) . length ( ) ) { return - 1 ; } return result ; } } ) ; final List < String > columns = new ArrayList < > ( ) ; final List < String > values = new ArrayList < > ( ) ; final List < Integer > columnWidths = new ArrayList < > ( ) ; for ( Identifier id : keys ) { columns . add ( id . getValue ( ) ) ; values . add ( variables . get ( id ) != null ? variables . get ( id ) . toString ( true ) : null ) ; columnWidths . add ( width ( id . getValue ( ) ) ) ; } final boolean hasAdditionalColumn = StringUtils . isNotBlank ( additionalColumnHeader ) ; if ( hasAdditionalColumn ) { columns . add ( additionalColumnHeader ) ; values . add ( additionalColumnValue ) ; columnWidths . add ( width ( additionalColumnHeader ) ) ; } StringBuilder buffer = new StringBuilder ( ) ; if ( printHeaderRow ) { printHeaderLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; } printSeparatorLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; printValues ( buffer , values , columnWidths , hasAdditionalColumn ) ; return buffer . toString ( ) ; }
tr	0	public char nextChar ( ) { return ( char ) ( next ( 16 ) ) ; }
tr	3	@ Override public String toString ( ) { String name = getName ( ) ; String append = "" ; if ( name != null && ! name . equals ( "" ) ) { append = "(\"" + this . getName ( ) + "\")" ; } StringBuilder bldr = new StringBuilder ( ) ; bldr . append ( "TAG_List" + append + ": " + value . size ( ) + " entries of type " + NBTUtils . getTypeName ( type ) + "\r\n{\r\n" ) ; for ( Tag t : value ) { bldr . append ( "   " + t . toString ( ) . replaceAll ( "\r\n" , "\r\n   " ) + "\r\n" ) ; } bldr . append ( "}" ) ; return bldr . toString ( ) ; }
tr	6	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	9X	public static void startJar ( String file , String arguments ) { if ( arguments != null ) System . out . println ( "The game arguments are: " + arguments ) ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "java -jar \"" + file + "\" " + arguments ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; return ; } if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_CLOSE ) System . exit ( 0 ) ; if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_REOPEN ) Data . launcherFrame . setVisible ( false ) ; final InputStream err = p . getErrorStream ( ) ; Thread errThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { BufferedReader errReader = new BufferedReader ( new InputStreamReader ( err ) ) ; String line = null ; while ( ( line = errReader . readLine ( ) ) != null ) System . err . println ( line ) ; errReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } , "errThread" ) ; errThread . start ( ) ; InputStream in = p . getInputStream ( ) ; try { BufferedReader txtReader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = txtReader . readLine ( ) ) != null ) System . out . println ( "[game] " + line ) ; txtReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } while ( true ) if ( ! errThread . isAlive ( ) ) break ; try { in . close ( ) ; err . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	2	public static void onAllROute ( Individual individual ) { ProblemInstance problemInstance = individual . problemInstance ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { mutateRouteBy2_Opt ( individual , period , vehicle ) ; } } }
tr	3	@ Override public void delete ( TypeAttribute typeAttribute ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . delete ( typeAttribute ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	8	@ Override public TIPO_OBJETO set ( TIPO_OBJETO oBean ) throws Exception { class < TIPO_OBJETO > tipo = ( class < TIPO_OBJETO > ) ( ( ParameterizedType ) getClass ( ) . getGenericSuperclass ( ) ) . getActualTypeArguments ( ) [ 0 ] ; Method metodo_getId = tipo . getMethod ( "getId" ) ; Method metodo_setId = tipo . getMethod ( "setId" , Integer . class ) ; try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( ( Integer ) metodo_getId . invoke ( oBean ) == 0 ) { metodo_setId . invoke ( oBean , oMysql . insertOne ( strTabla ) ) ; } for ( Method method : tipo . getMethods ( ) ) { if ( ! method . getName ( ) . substring ( 3 ) . equalsIgnoreCase ( "id" ) ) { if ( method . getName ( ) . substring ( 0 , 3 ) . equalsIgnoreCase ( "get" ) ) { if ( ! method . getName ( ) . equals ( "getClass" ) ) { final class < ? > strTipoDevueltoMetodoGet = method . getReturnType ( ) ; String value = ( String ) method . invoke ( oBean ) . toString ( ) ; if ( strTipoDevueltoMetodoGet . getName ( ) . equals ( "java.util.Date" ) ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd" ) ; value = format . format ( method . invoke ( oBean ) ) ; } String strCampo = method . getName ( ) . substring ( 3 ) . toLowerCase ( Locale . ENGLISH ) ; oMysql . updateOne ( ( Integer ) metodo_getId . invoke ( oBean ) , strTabla , strCampo , value ) ; } } } } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "GenericDao.set: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } return oBean ; }
tr	5	public static void unpackConfig ( StreamLoader streamLoader ) { Stream stream = new Stream ( streamLoader . getDataForName ( "varbit.dat" ) ) ; int cacheSize = stream . readUnsignedWord ( ) ; if ( cache == null ) cache = new VarBit [ cacheSize ] ; for ( int j = 0 ; j < cacheSize ; j ++ ) { if ( cache [ j ] == null ) cache [ j ] = new VarBit ( ) ; cache [ j ] . readValues ( stream ) ; if ( cache [ j ] . aBoolean651 ) Varp . cache [ cache [ j ] . anInt648 ] . aBoolean713 = true ; } if ( stream . offset != stream . buffer . length ) System . out . println ( "varbit load mismatch" ) ; }
tr	5	@ Override public void run ( ) { String author = item . getAuthor ( ) ; String title = item . getTitle ( ) ; String dir = "./cache" ; String localCover = dir + "/cover/" + title + "-" + author + ".jpg" ; String localSong = dir + "/song/" + title + "-" + author + ".mp3" ; try { if ( item . getCover ( ) != null && item . getCover ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localCover , item . getCover ( ) ) ; item . setCover ( localCover ) ; } onCoverComplete ( item ) ; if ( item . getCover ( ) != null && item . getPath ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localSong , item . getPath ( ) ) ; item . setPath ( localSong ) ; item . setLocal ( true ) ; } onSongComplete ( item ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterPrograma ( this ) ; }
tr	7	private void applyForces ( final Iterable < Mass > masses , final Vector4 gravity , final boolean applyWindForces ) { final double deltaTSquared = params . getIntegrationTimeStep ( ) ; final Vector4 windForce = new Vector4 ( ) ; windSimulator . getCurrentWindVector ( windForce ) ; final Vector4 normalizedWindForce = new Vector4 ( windForce ) ; normalizedWindForce . normalizeInPlace ( ) ; final double maxY = params . getYResolution ( ) * 0.98 ; final GridIterator it = ( GridIterator ) masses . iterator ( ) ; while ( it . hasNext ( ) ) { final Mass mass = it . next ( ) ; if ( mass . hasFlags ( Mass . FLAG_FIXED | Mass . FLAG_SELECTED ) ) { continue ; } Vector4 sumForces = new Vector4 ( ) ; for ( Spring s : mass . springs ) { if ( s . m1 == mass ) { sumForces . plusInPlace ( s . force ) ; } else { sumForces . minusInPlace ( s . force ) ; } } if ( applyWindForces ) { final Mass rightNeighbour = it . rightNeighbour ( ) ; final Mass bottomNeighbour = it . bottomNeighbour ( ) ; if ( rightNeighbour != null & bottomNeighbour != null ) { sumForces . plusInPlace ( calculateWindForce ( mass , rightNeighbour , bottomNeighbour , normalizedWindForce , windForce ) ) ; } } sumForces . plusInPlace ( gravity ) ; final Vector4 tmp = new Vector4 ( mass . currentPosition ) ; final Vector4 posDelta = mass . currentPosition . minus ( mass . previousPosition ) ; Vector4 dampening = posDelta . multiply ( params . getSpringDampening ( ) ) ; sumForces . minusInPlace ( dampening ) ; sumForces . multiplyInPlace ( 1.0 / ( mass . mass * deltaTSquared ) ) ; posDelta . plusInPlace ( sumForces ) ; posDelta . clampMagnitudeInPlace ( params . getMaxParticleSpeed ( ) ) ; mass . currentPosition . plusInPlace ( posDelta ) ; if ( mass . currentPosition . y > maxY ) { mass . currentPosition . y = maxY ; } mass . previousPosition = tmp ; } }
tr	0	public JTextField getTextNombre ( ) { return TextNombre ; }
tr	9X	public String SimplifyPath ( String path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charAt ( 0 ) != / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) == / ) start ++ ; if ( start == pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) == / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
tr	7	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 29 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 122 ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_from ( "er" ) ; break ; } return true ; }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	8	public void setActivePanel ( final PanelType type ) { if ( this . frame != null ) { this . frame . dispose ( ) ; } switch ( type ) { case START : this . frame = new PlainPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case CLUBS : this . frame = new ClubPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case GYM : this . frame = new GymPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG : this . frame = new GamePanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG_DIR : this . frame = new AllGamesPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case TEAMS : this . frame = new TeamPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case RANKING : this . frame = new RankingPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; } this . sfb . setWeights ( new int [ ] { 30 , 70 } ) ; }
tr	2	public JSONArray ( Collection copyFrom ) { this ( ) ; if ( copyFrom != null ) { for ( Iterator it = copyFrom . iterator ( ) ; it . hasNext ( ) ; ) { put ( JSONObject . wrap ( it . next ( ) ) ) ; } } }
tr	6	public Text parse ( String pathToFile ) { Text text = null ; try { FileInputStream fstream = new FileInputStream ( pathToFile ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fstream ) ) ; ResourceBundle bundle ; bundle = ResourceBundle . getBundle ( ApplicationValue . BUNDLE_LOCATION ) ; String textLine ; text = new Text ( ) ; while ( ( textLine = br . readLine ( ) ) != null ) { if ( ( textLine . matches ( bundle . getString ( ApplicationValue . HEADER ) ) || ( textLine . trim ( ) . matches ( bundle . getString ( ApplicationValue . OUTPUT ) ) ) ) ) { text . add ( splitSentenceByWordsAndPunctuation ( textLine ) ) ; } else { if ( isCode ( textLine ) ) { text . add ( new Listing ( textLine ) ) ; } else { Pattern sentencePattern = Pattern . compile ( bundle . getString ( ApplicationValue . SENTENCE ) ) ; Matcher sentenceMatcher = sentencePattern . matcher ( textLine ) ; while ( sentenceMatcher . find ( ) ) { String sentenceString = sentenceMatcher . group ( ) ; text . add ( splitSentenceByWordsAndPunctuation ( sentenceString ) ) ; } } } } } catch ( IOException e ) { log . error ( e ) ; } return text ; }
tr	8	public double getHammingDis ( int [ ] actDeps , int [ ] actLabs , int [ ] predDeps , int [ ] predLabs ) { double dis = 0 ; for ( int i = 1 ; i < actDeps . length ; ++ i ) if ( options . learnLabel ) { if ( labelLossType == 0 ) { if ( actDeps [ i ] != predDeps [ i ] ) dis += 0.5 ; if ( actLabs [ i ] != predLabs [ i ] ) dis += 0.5 ; } else if ( actDeps [ i ] != predDeps [ i ] || actLabs [ i ] != predLabs [ i ] ) dis += 1 ; } else { if ( actDeps [ i ] != predDeps [ i ] ) dis += 1 ; } return dis ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	5	JavaExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mFonts = fonts ; mNoExampleButton = new JButton ( "Export Fonts" ) ; mExampleButton = new JButton ( "Export Fonts + Example Code" ) ; mCancelButton = new JButton ( "Cancel" ) ; mNoExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( false ) ; } } ) ; mExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( true ) ; } } ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; Font font = new Font ( "Verdana" , Font . BOLD , 18 ) ; for ( JButton b : new JButton [ ] { mNoExampleButton , mExampleButton , mCancelButton } ) { b . setFont ( font ) ; add ( b ) ; } setLayout ( new Layout ( ) ) ; mDialog = new JDialog ( ( Window ) parent , "Export Options" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 450 , 280 ) ; mDialog . setResizable ( false ) ; mDialog . setLocationRelativeTo ( parent ) ; mDialog . setVisible ( true ) ; }
tr	7	static final public void sum ( ) throws ParseException { term ( ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : case MINUS : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : jj_consume_token ( + ) ; break ; case MINUS : jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } term ( ) ; } }
tr	5	public void sortDyes ( ) { Vector < DyeParent > newDyes = new Vector < DyeParent > ( ) ; Vector < DyeParent > newLakks = new Vector < DyeParent > ( ) ; Vector < DyeParent > newMetals = new Vector < DyeParent > ( ) ; Vector < DyeParent > newFluos = new Vector < DyeParent > ( ) ; for ( int i = 0 ; i < PPC . calcObj . getAllDyeTypes ( ) . size ( ) ; i ++ ) { if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Dye . class ) { newDyes . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Lakk . class ) { newLakks . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Metal . class ) { newMetals . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Fluo . class ) { newFluos . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } } PPC . calcObj . getAllDyeTypes ( ) . removeAllElements ( ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newDyes ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newLakks ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newMetals ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newFluos ) ; }
tr	8	public static List < File > getFilesFromDir ( String directory , List < String > exclusionPattern ) { if ( directory == null || directory . equals ( "" ) ) { return null ; } File directoryToScan = new File ( directory ) ; File [ ] dirList = directoryToScan . listFiles ( ) ; List < File > fixedSizeResult = Arrays . asList ( dirList ) ; List < File > result = new ArrayList < > ( fixedSizeResult ) ; for ( File potentialDir : dirList ) { if ( potentialDir . isDirectory ( ) ) { result . addAll ( getFilesFromDir ( potentialDir . getAbsolutePath ( ) , exclusionPattern ) ) ; } } List < Integer > fileToRemove = new ArrayList < > ( ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { for ( int j = 0 ; j < exclusionPattern . size ( ) ; j ++ ) { if ( result . get ( i ) . getAbsolutePath ( ) . indexOf ( exclusionPattern . get ( j ) ) > 0 ) { fileToRemove . add ( i ) ; j = exclusionPattern . size ( ) ; } } } for ( int i = fileToRemove . size ( ) - 1 ; i >= 0 ; i -- ) { result . remove ( fileToRemove . get ( i ) . intValue ( ) ) ; } return result ; }
tr	1	public void startRepairGUI ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { frame = new RepairGUI ( ) ; frame . setVisible ( true ) ; result = query . query ( nameTBL , 1 , nameID ) ; maxID = query . getLastID ( nameTBL , nameID ) ; insertValues ( result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	7	public void addItem ( Item item , int amount ) { System . out . println ( "added " + amount + " of " + item + " to " + owner ) ; if ( item . isStackable ( ) ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( objectType [ i ] . id == item . id && objectType [ i ] . subID == item . subID && objectNumber [ i ] < 999 ) { objectNumber [ i ] = objectNumber [ i ] + amount ; return ; } } } for ( int i = 0 ; i < size ; i ++ ) { if ( objectType [ i ] . id == 0 ) { objectType [ i ] = item ; objectNumber [ i ] = amount ; return ; } } System . out . println ( "warning  inventory is full" ) ; }
tr	5	private Point chooseRandomLocation ( ) { Point randomLocation ; ArrayList < Point > listOfEmptyLocations = new ArrayList < > ( ) ; Location [ ] [ ] locations = this . board . getBoardLocations ( ) ; for ( int row = 0 ; row < locations . length ; row ++ ) { Location [ ] rowLocations = locations [ row ] ; for ( int col = 0 ; col < rowLocations . length ; col ++ ) { Player playerAtLocation = rowLocations [ col ] . getPlayer ( ) ; if ( playerAtLocation == null ) { listOfEmptyLocations . add ( new Point ( row , col ) ) ; } } } int noOfEmptyLocations = listOfEmptyLocations . size ( ) ; if ( noOfEmptyLocations == 0 ) { return null ; } else if ( listOfEmptyLocations . size ( ) == 1 ) { randomLocation = listOfEmptyLocations . get ( 0 ) ; return randomLocation ; } else { int randomNumber = new Random ( ) . nextInt ( noOfEmptyLocations ) ; randomLocation = listOfEmptyLocations . get ( randomNumber ) ; return randomLocation ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new RelVendasPorVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	0	public final void set ( double xl , double yl , double xh , double yh ) { boundaryLowX = xl ; boundaryLowY = yl ; boundaryHiX = xh ; boundaryHiY = yh ; }
tr	9X	public boolean connect ( SharingPeer peer ) { boolean retry = false ; boolean sentObfuscatedHandshake = false ; do { Socket socket = new Socket ( ) ; InetSocketAddress address = new InetSocketAddress ( peer . getIp ( ) , peer . getPort ( ) ) ; logger . info ( "Connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( IOException ioe ) { logger . warn ( "Could not connect to " + peer + ": " + ioe . getMessage ( ) ) ; return false ; } try { byte [ ] remotePeerId = ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ; if ( this . forceObfuscation ) sentObfuscatedHandshake = this . sendObfuscatedHandshake ( socket , remotePeerId , this . forceObfuscation ) ; else sentObfuscatedHandshake = this . sendHandshake ( socket , remotePeerId , peer . supportsObfuscation ( ) ) ; Handshake hs = this . validateHandshake ( socket , ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ) ; this . fireNewPeerConnection ( socket , hs . getPeerId ( ) ) ; return true ; } catch ( ParseException pe ) { logger . info ( "Invalid handshake from " + this . socketRepr ( socket ) + ": " + pe . getMessage ( ) ) ; if ( sentObfuscatedHandshake && peer . supportsObfuscation ( ) ) { peer . supportsObfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( IOException e ) { } } catch ( IOException ioe ) { logger . info ( "An error occured while reading an incoming " + "handshake: " + ioe . getMessage ( ) ) ; try { if ( ! socket . isClosed ( ) ) socket . close ( ) ; } catch ( IOException e ) { } } } while ( retry ) ; return false ; }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	8	public ArrayList < ArrayList < State >> printTrace ( String string , ArrayList < Automaton > disTA ) { String actions [ ] = string . split ( " " ) ; ArrayList < ArrayList < State >> states ; for ( ArrayList < State > state : startStates ) { states = new ArrayList < ArrayList < State >> ( ) ; ArrayList < State > searchState = state ; states . add ( searchState ) ; for ( String action : actions ) { boolean matchFound = false ; if ( adjList != null ) { Set < EdgeOfZoneGraph > edges = adjList . get ( searchState ) ; if ( edges != null ) { Iterator < EdgeOfZoneGraph > it = edges . iterator ( ) ; while ( it . hasNext ( ) ) { EdgeOfZoneGraph edge = ( EdgeOfZoneGraph ) it . next ( ) ; if ( edge . getAction ( ) . equals ( action ) ) { states . add ( edge . getEndState ( ) ) ; searchState = edge . getEndState ( ) ; matchFound = true ; break ; } } } } if ( ! matchFound ) { return null ; } } if ( isFinal ( states . get ( states . size ( ) - 1 ) , disTA ) ) { return states ; } } return null ; }
tr	2	private Viability initiateViability ( File habitatFolder ) throws IOException , InterruptedException { File viabilityCSV = new File ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY ) ; if ( ! viabilityCSV . exists ( ) || ! viabilityCSV . isFile ( ) ) throw new FileDoesntExist ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY , "but file with parameters of viability is strongly required" ) ; String fileContent = getFullFileContent ( viabilityCSV ) ; String preparedContent = preparer . getPreparedContent ( fileContent , ViabilityReader . INPUT_AREA ) ; saver . saveForCurrentPoint ( habitatFolder . getName ( ) , VIABILITY , preparedContent ) ; return new ViabilityReader ( preparedContent ) . getViability ( ) ; }
tr	6	public String next ( int n ) throws JSONException { if ( n == 0 ) { return "" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( "Substring bounds error" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; }
tr	1	public void edit ( Frame frame ) { if ( frame . getKeyDuration ( ) < 0 ) { Animation parent = ( Animation ) frame . getParent ( ) ; frame . setKeyDuration ( parent . getDefaultKeyDuration ( ) * multiplier ) ; } frame . setKeyDuration ( frame . getKeyDuration ( ) * multiplier ) ; }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	8	private static ArrayList < EncFSFile > getPath ( String path ) throws IOException { ArrayList < EncFSFile > result = new ArrayList < EncFSFile > ( ) ; EncFSFile curFile ; boolean found ; if ( path . equals ( EncFSVolume . ROOT_PATH ) ) { result . add ( volume . getRootDir ( ) ) ; return result ; } if ( path . startsWith ( EncFSVolume . PATH_SEPARATOR ) ) { curFile = volume . getRootDir ( ) ; } else { curFile = curDir ; } StringTokenizer st = new StringTokenizer ( path , EncFSVolume . PATH_SEPARATOR ) ; while ( st . hasMoreTokens ( ) ) { String pathElement = st . nextToken ( ) ; found = false ; if ( curFile . isDirectory ( ) ) { EncFSFile [ ] files = curFile . listFiles ( ) ; for ( EncFSFile file : files ) { if ( file . getName ( ) . equals ( pathElement ) ) { result . add ( file ) ; curFile = file ; found = true ; } } } else { if ( st . hasMoreTokens ( ) ) { throw new FileNotFoundException ( "'" + pathElement + "' is not a directory!" ) ; } else { result . add ( curFile ) ; found = true ; } } if ( ! found ) { throw new FileNotFoundException ( "Path '" + path + "' not found!" ) ; } } return result ; }
tr	6	public int iConomyversion ( ) { if ( iConomyversion == 0 ) { try { if ( packageExists ( new String [ ] { "net.milkbowl.vault.economy.Economy" } ) ) { iConomyversion = 2 ; plugin . getLogger ( ) . info ( "hooked into Vault" ) ; } else if ( packageExists ( new String [ ] { "com.nijikokun.register.payment.Methods" } ) ) { iConomyversion = 1 ; plugin . getLogger ( ) . info ( "hooked into Register" ) ; } else if ( packageExists ( new String [ ] { "com.iConomy.iConomy" , "com.iConomy.system.Account" , "com.iConomy.system.Holdings" } ) ) { iConomyversion = 5 ; plugin . getLogger ( ) . info ( "hooked into iConomy5" ) ; } else if ( packageExists ( new String [ ] { "com.iCo6.system.Accounts" } ) ) { iConomyversion = 6 ; plugin . getLogger ( ) . info ( "hooked into iConomy6" ) ; } else { plugin . getLogger ( ) . severe ( "cant hook into iConomy5  iConomy6  Vault or Register. Downloading Vault!" ) ; plugin . getLogger ( ) . severe ( " ************ Please download and configure Vault!!!!! **********" ) ; } } catch ( Exception E ) { E . printStackTrace ( ) ; iConomyversion = 0 ; } return iConomyversion ; } else { return 2 ; } }
tr	7	public void connect ( TreeLinkNode root ) { if ( root == null || root . left == null || root . right == null ) { return ; } if ( root . left != null ) { root . left . next = root . right ; } if ( root . right != null && root . next != null ) { root . right . next = root . next . left == null ? null : root . next . left ; } connect ( root . left ) ; connect ( root . right ) ; }
tr	9X	private static Expression parseExpression ( ProgramNode program , Scanner s , CodeParser cp , PrefixProcessor p ) { if ( Parser . gobble ( "fuelLeft" , s ) ) return new SensorNode ( SensorType . FUELLEFT ) ; else if ( Parser . gobble ( "oppLR" , s ) ) return new SensorNode ( SensorType . OPPLR ) ; else if ( Parser . gobble ( "oppFB" , s ) ) return new SensorNode ( SensorType . OPPFB ) ; else if ( Parser . gobble ( "numBarrels" , s ) ) return new SensorNode ( SensorType . NUMBARRELS ) ; else if ( Parser . gobble ( "barrelLR" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELLR ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelLR with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "barrelFB" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELFB ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelFB with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "wallDist" , s ) ) return new SensorNode ( SensorType . WALLDIST ) ; else if ( s . hasNext ( variable ) ) return new VariableNode ( program , s . next ( variable ) ) ; else if ( s . hasNext ( Parser . NUMPAT ) ) return new NumberNode ( double . parseDouble ( s . next ( Parser . NUMPAT ) ) ) ; else return new OperationNode ( ) . parse ( s , cp , p ) ; }
tr	6	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; String p2 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 1 , 0 } ; p1 = new int [ ] { 0 , 1 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 0 , 1 } ; p1 = new int [ ] { 1 , 0 } ; p2 = "Impossible" ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 3 , 1 , 2 , 0 } ; p1 = new int [ ] { 0 , 2 , 1 , 3 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 3 , 1 , 2 , 0 } ; p1 = new int [ ] { 3 , 2 , 0 , 1 } ; p2 = "Impossible" ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	5	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	4	public void addTile ( Vector3d [ ] corners , Color c , boolean isSolid , boolean isConcave ) { Vector < Vector3d > wire1 = new Vector < > ( ) ; Vector < Vector3d > wire2 = new Vector < > ( ) ; float h1 = corners [ 0 ] . z + corners [ 2 ] . z ; float h2 = corners [ 1 ] . z + corners [ 3 ] . z ; if ( h1 < h2 && isConcave || h1 > h2 && ! isConcave ) { wire1 . addElement ( corners [ 0 ] ) ; wire1 . addElement ( corners [ 1 ] ) ; wire1 . addElement ( corners [ 2 ] ) ; wire1 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; wire2 . addElement ( corners [ 3 ] ) ; wire2 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; } else { wire1 . addElement ( corners [ 0 ] ) ; wire1 . addElement ( corners [ 1 ] ) ; wire1 . addElement ( corners [ 3 ] ) ; wire1 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; wire2 . addElement ( corners [ 3 ] ) ; wire2 . addElement ( corners [ 1 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; } addWire ( wire1 , c , isSolid , true ) ; addWire ( wire2 , c , isSolid , true ) ; }
tr	5	@ Test public void testPacketSending ( ) throws SocketException { MicroSecondsTimeStamp stamper = mock ( MicroSecondsTimeStamp . class ) ; when ( stamper . timeStamp ( ) ) . thenReturn ( 0 ) ; UtpAlgorithm algorithm = new UtpAlgorithm ( stamper , new InetSocketAddress ( 51235 ) ) ; UtpAlgConfiguration . SEND_IN_BURST = true ; UtpAlgConfiguration . MAX_BURST_SEND = 3 ; int packetLength = 1000 ; algorithm . setMaxWindow ( packetLength * 10 ) ; UtpTimestampedPacketDTO pkt5 = createPacket ( 5 , packetLength ) ; UtpTimestampedPacketDTO pkt6 = createPacket ( 6 , packetLength ) ; UtpTimestampedPacketDTO pkt7 = createPacket ( 7 , packetLength ) ; UtpTimestampedPacketDTO pkt8 = createPacket ( 8 , packetLength ) ; UtpTimestampedPacketDTO pkt9 = createPacket ( 9 , packetLength ) ; algorithm . markPacketOnfly ( pkt5 . utpPacket ( ) , pkt5 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt6 . utpPacket ( ) , pkt6 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt7 . utpPacket ( ) , pkt7 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt8 . utpPacket ( ) , pkt8 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt9 . utpPacket ( ) , pkt9 . dataGram ( ) ) ; assertEquals ( 5 * ( UtpPacketUtils . DEF_HEADER_LENGTH + packetLength ) , algorithm . getCurrentWindow ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; algorithm . setMaxWindow ( packetLength * 4 ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } algorithm . setMaxWindow ( 10 * packetLength ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; }
tr	2	public void simulateOneStep ( ) { step ++ ; startSickness ( startKans ) ; List < Actor > newActors = new ArrayList < Actor > ( ) ; for ( Iterator < Actor > it = actors . iterator ( ) ; it . hasNext ( ) ; ) { Actor actor = it . next ( ) ; actor . act ( newActors ) ; if ( ! actor . isActive ( ) ) { it . remove ( ) ; } } actors . addAll ( newActors ) ; statusUpdate ( ) ; }
tr	9X	private void btnLaunchActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . process != null ) { this . expectExit = true ; this . process . destroy ( ) ; return ; } String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean isNix = osName . contains ( "ux" ) || osName . contains ( "ix" ) || osName . contains ( "mac" ) ; String memValue = cbMemory . getSelectedItem ( ) . toString ( ) ; String screenWidth = txtWidth . getText ( ) ; String screenHeight = txtHeight . getText ( ) ; if ( ! isValidInteger ( memValue ) ) { JOptionPane . showMessageDialog ( this , "Invalid memory value specified!" , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( ! isValidInteger ( screenWidth ) || ! isValidInteger ( screenWidth ) ) { JOptionPane . showMessageDialog ( this , "Invalid screen width/height specified!" , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } String launchCommand = LaunchCommandBuilder . getLaunchCommand ( this . loggedUsername , this . session , memValue , screenWidth , screenHeight ) ; String gameDir = ConfigManager . getInstance ( ) . pathToJar ; if ( this . syncState != SyncState . COMPLETE ) { if ( JOptionPane . showConfirmDialog ( this , "Synchronization with server isn't done.\nAre you sure to launch unsynchronized client?" , "Client not synchronized" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . CANCEL_OPTION ) { return ; } } if ( this . currentState != LauncherState . LOGGED_IN ) { if ( JOptionPane . showConfirmDialog ( this , "You are not logged in. If you launch game without login you can't join the Kubach servers.\nAre you sure to launch client without login?" , "You are not logged in" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . CANCEL_OPTION ) { return ; } } final String SCRIPT_NAME = "launch.sh" ; if ( isNix ) { try { String scriptPath = gameDir + File . separator + SCRIPT_NAME ; Files . write ( Paths . get ( scriptPath ) , ( "#!/bin/sh\n" + "cd \"" + gameDir + "\"\n" + launchCommand ) . getBytes ( "UTF-8" ) , ( new File ( scriptPath ) . exists ( ) ) ? StandardOpenOption . WRITE : StandardOpenOption . CREATE_NEW ) ; launchCommand = "sh " + SCRIPT_NAME ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } Process proc ; try { proc = new ProcessBuilder ( launchCommand . split ( " " ) ) . directory ( new File ( gameDir ) ) . start ( ) ; } catch ( IOException ex ) { JOptionPane . showMessageDialog ( this , "Unable to start process: " + ex . toString ( ) , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } StreamGobbler errorGobbler = new StreamGobbler ( proc . getErrorStream ( ) ) ; StreamGobbler outputGobbler = new StreamGobbler ( proc . getInputStream ( ) ) ; errorGobbler . start ( ) ; outputGobbler . start ( ) ; ConfigManager . getInstance ( ) . getProperties ( ) . setProperty ( "memory" , memValue ) ; ConfigManager . getInstance ( ) . saveProperties ( ) ; ConfigManager . getInstance ( ) . setResolution ( screenWidth , screenHeight ) ; if ( ! isNix ) { this . process = proc ; this . expectExit = false ; btnLaunch . setText ( "Kill" ) ; ProcessMonitorWorker pmw = new ProcessMonitorWorker ( this , this . process ) ; pmw . execute ( ) ; } }
tr	1	protected void sendConnectionHeaderIfNotAlreadyPresent ( PrintWriter pw , Map < String , String > header ) { if ( ! headerAlreadySent ( header , "connection" ) ) { pw . print ( "Connection: keep-alive\r\n" ) ; } }
tr	4	@ Override public void add ( E pdato , int index ) { if ( 0 > index || _lenght < index ) { throw new IndexOutOfBoundsException ( "Fuera de rango: " + index ) ; } else if ( index == 0 ) { addi ( pdato ) ; } else if ( index == _lenght ) { add ( pdato ) ; } else { NodeDouble < E > tmp = getIndex ( index ) ; NodeDouble < E > tmp2 = new NodeDouble < E > ( pdato ) ; tmp . getPrev ( ) . setNext ( tmp2 ) ; tmp2 . setPrev ( tmp . getPrev ( ) ) ; tmp . setPrev ( tmp2 ) ; tmp2 . setNext ( tmp ) ; _lenght ++ ; } }
tr	3	public List < VariableAppearance > getAltAppearances ( ParsingContext context ) { List < VariableAppearance > result = new ArrayList < VariableAppearance > ( ) ; for ( String variableName : detectedVariableNames ) { for ( int i = 0 ; i < altPrefixRegexps . size ( ) ; i ++ ) { String completeRegexp = altPrefixRegexps . get ( i ) + variableName + altSuffixRegexps . get ( i ) ; Matcher matcher = Pattern . compile ( completeRegexp ) . matcher ( context . getContent ( ) ) ; while ( matcher . find ( ) ) { result . add ( new VariableAppearance ( matcher . group ( ) , variableName , globalContext , context , "" ) ) ; } } } return result ; }
tr	8	public static void main ( String [ ] args ) { String filename = "SimpleDynamicScenario.txt" ; String outputPath = "./" ; if ( args . length >= 2 ) { filename = args [ 0 ] ; outputPath = args [ 1 ] ; } if ( args . length > 2 ) System . err . println ( "WARNING: Only two arguments required. Ignoring arguments after the first two." ) ; if ( args . length <= 1 ) { System . err . println ( "WARNING: Two arguments required <setup_file_name> <ouput_dir_path>. Running simulation with default values \"properties.txt\" and \"./\"." ) ; } sfp = new SetupFileParser ( ) ; sfp . parseFileForProperties ( filename ) ; StandAloneSimulation sas = new StandAloneSimulation ( outputPath , "RunFrom" + ( new File ( filename ) ) . getName ( ) . replace ( "." , "_" ) + System . currentTimeMillis ( ) , sfp . generalProps . getProperty ( "seed" ) != null ? Integer . parseInt ( sfp . generalProps . getProperty ( "seed" ) ) : 0 , sfp . generalProps . getProperty ( "useDerby" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "useDerby" ) ) : true ) ; try { sas . setup ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } sas . runSimulation ( ) ; boolean printKPIs = sfp . generalProps . getProperty ( "printKPIs" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "printKPIs" ) ) : false ; if ( printKPIs ) sas . printKPIs ( ) ; }
tr	9X	public class findClass ( String className ) { final class aClass = handleGenaratedClass ( className ) ; if ( aClass != null ) { return aClass ; } byte classByte [ ] ; class result = null ; result = ( class ) classes . get ( className ) ; if ( result != null ) { return result ; } try { return findSystemClass ( className ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( jarFiles . size ( ) > 0 ) { for ( LibraryEntity jarFile : jarFiles ) { final String [ ] libNames = jarFile . getLibNames ( ) ; for ( String libName : libNames ) { JarFile jar = new JarFile ( ApplicationSettings . getInstance ( ) . getLibraryBasePath ( ) + libName ) ; final Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry element = entries . nextElement ( ) ; final String accClassName = element . getName ( ) . replaceAll ( "/" , "." ) ; if ( ( className + ".class" ) . equals ( accClassName ) ) { InputStream is = jar . getInputStream ( element ) ; ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; int nextValue = is . read ( ) ; while ( - 1 != nextValue ) { byteStream . write ( nextValue ) ; nextValue = is . read ( ) ; } classByte = byteStream . toByteArray ( ) ; result = defineClass ( className , classByte , 0 , classByte . length , null ) ; classes . put ( className , result ) ; return result ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	8	public static void release ( Object ... releasables ) { for ( Object obj : releasables ) { if ( obj != null ) { try { if ( obj instanceof ServerSocket ) { ( ( ServerSocket ) obj ) . close ( ) ; } else if ( obj instanceof Socket ) { ( ( Socket ) obj ) . close ( ) ; } else if ( obj instanceof Process ) { ( ( Process ) obj ) . destroy ( ) ; } else if ( obj instanceof Closeable ) { ( ( Closeable ) obj ) . close ( ) ; } else { throw new IllegalArgumentException ( "This method does not not how to release objects of type " + obj . getClass ( ) ) ; } } catch ( IOException ex ) { } catch ( RuntimeException ex ) { } } } }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	5	public static boolean findIfThereIsAPart_hashmap ( List < Stock > stocks , int target ) { Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { Integer value = stocks . get ( i ) . getValue ( ) ; if ( ! map . containsKey ( value ) ) { map . put ( value , 0 ) ; } Integer t = map . get ( value ) ; t += 1 ; map . put ( value , t ) ; } for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { int current = stocks . get ( i ) . getValue ( ) ; int another = target - current ; if ( map . get ( another ) >= ( current == another ? 2 : 1 ) ) { return true ; } } return false ; }
tr	4	public Cachable fetch ( CacheToken token ) { if ( ! cacheTokensLRUMap . containsKey ( token . getCacheID ( ) ) ) { cacheTokensLRUMap . put ( token . getCacheID ( ) , token ) ; } switch ( token . getOrigin ( ) ) { case DB : return DatabaseOperations . fetchFromCache ( token . getCacheID ( ) ) ; case MEMORY : return cached . get ( token . getCacheID ( ) ) ; case new : default : return null ; } }
tr	2	public void setMV ( String s ) throws ADataException { if ( s == null ) { mv = null ; return ; } if ( ! ( s . equals ( MENTAL ) | s . equals ( VITAL ) | s . equals ( SUPEREGO ) | s . equals ( SUPERID ) ) ) throw new ADataException ( ) ; this . mv = s ; }
tr	2	@ Override public int compareTo ( PathNode o ) { if ( cost < o . cost ) return - 1 ; if ( cost > o . cost ) return 1 ; return 0 ; }
tr	7	public void drawPolygon ( double [ ] x , double [ ] y , JGColor [ ] col , int len , boolean filled , boolean pf_relative ) { if ( buf_gfx == null ) return ; int [ ] xpos = new int [ 3 ] ; int [ ] ypos = new int [ 3 ] ; xpos [ 0 ] = el . scaleXPos ( x [ 0 ] , pf_relative ) ; ypos [ 0 ] = el . scaleYPos ( y [ 0 ] , pf_relative ) ; xpos [ 1 ] = el . scaleXPos ( x [ 1 ] , pf_relative ) ; ypos [ 1 ] = el . scaleYPos ( y [ 1 ] , pf_relative ) ; xpos [ 2 ] = el . scaleXPos ( x [ len - 1 ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ len - 1 ] , pf_relative ) ; if ( ! filled ) { if ( col != null ) setColor ( buf_gfx , col [ 1 ] ) ; buf_gfx . drawLine ( xpos [ 0 ] , ypos [ 0 ] , xpos [ 1 ] , ypos [ 1 ] ) ; if ( col != null ) setColor ( buf_gfx , col [ 0 ] ) ; buf_gfx . drawLine ( xpos [ 2 ] , ypos [ 2 ] , xpos [ 0 ] , ypos [ 0 ] ) ; } for ( int i = 2 ; i < len ; i ++ ) { xpos [ 2 ] = el . scaleXPos ( x [ i ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ i ] , pf_relative ) ; if ( col != null ) setColor ( buf_gfx , col [ i ] ) ; if ( filled ) { buf_gfx . fillPolygon ( xpos , ypos , 3 ) ; } else { buf_gfx . drawLine ( xpos [ 1 ] , ypos [ 1 ] , xpos [ 2 ] , ypos [ 2 ] ) ; } xpos [ 1 ] = xpos [ 2 ] ; ypos [ 1 ] = ypos [ 2 ] ; } }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; T2 < ? , ? > other = ( T2 < ? , ? > ) obj ; if ( _first == null ) { if ( other . _first != null ) return false ; } else if ( ! _first . equals ( other . _first ) ) return false ; if ( _second == null ) { if ( other . _second != null ) return false ; } else if ( ! _second . equals ( other . _second ) ) return false ; return true ; }
tr	6	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	1	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
tr	8	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	5	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { ClientServiceImpl csi = new ClientServiceImpl ( conn ) ; Client client = new Client ( ) ; setNewClientProperty ( client ) ; if ( client . getFirstName ( ) . equals ( "" ) || client . getLastName ( ) . equals ( "" ) || client . getBirthDay ( ) == null || client . getPassportNumber ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0430\u044E\u0449\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0435!" ) ; } else { csi . insert ( client ) ; JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D!" ) ; close ( ) ; } } catch ( ExsistDoubleClient ex ) { JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442!" ) ; } }
tr	5	private Stmt stmt ( ) throws SyntaxException { Stmt toBeReturned = null ; if ( isKind ( currentToken , IDENT ) ) { toBeReturned = assignStmt ( ) ; } else if ( isKind ( currentToken , pause ) ) { toBeReturned = pauseStmt ( ) ; } else if ( isKind ( currentToken , _while ) ) { toBeReturned = iterationStmt ( ) ; } else if ( isKind ( currentToken , _if ) ) { toBeReturned = alternativeStmt ( ) ; } else if ( isKind ( currentToken , ; ) ) { consume ( ) ; } else { throw new SyntaxException ( currentToken , "Either of " + Arrays . asList ( ; , IDENT , pause , _while , _if ) + " was expected here." ) ; } return toBeReturned ; }
tr	0	public Vector3D add ( Vector3D otherVector ) { return new Vector3D ( this . getX ( ) + otherVector . getX ( ) , this . getY ( ) + otherVector . getY ( ) , this . getZ ( ) + otherVector . getZ ( ) ) ; }
tr	2	@ Override public double calculateCostOfProductsBySupplier ( int supplierID ) throws Exception { double totalCost = 0.00 ; try { Result < ProductGateway > result = null ; result = ProductGateway . getProductsBySupplier ( supplierID ) ; Iterator < ProductGateway > iter = result . Items . iterator ( ) ; while ( iter . hasNext ( ) ) { ProductGateway item = iter . next ( ) ; totalCost += item . Price ; } } catch ( Exception e ) { throw e ; } return totalCost ; }
tr	5	@ Override public void mousePressed ( MouseEvent me ) { int w = gridRenderer . getWidth ( ) / gridColumns ; int col = me . getX ( ) / w ; int h = gridRenderer . getHeight ( ) / gridRows ; int row = me . getY ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getButton ( ) == MouseEvent . BUTTON1 ) { if ( tilesRemaining > 0 ) { value ++ ; tilesRemaining -- ; } if ( tilesRemaining == 0 ) { saveAsButton . setEnabled ( true ) ; } } else if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( value > 0 ) { value -- ; tilesRemaining ++ ; saveAsButton . setEnabled ( false ) ; } } grid [ col ] [ row ] = value ; updateTilesRemainingLabel ( ) ; gridRenderer . repaint ( ) ; }
tr	2	public Set < Point > getPossibleMoves ( PlayerToken player ) { Set < Point > result = new HashSet < Point > ( ) ; Point loc = tokenLocs . get ( player ) ; for ( Point p : getAdjacentSquares ( player ) ) { if ( isMovable ( loc , p ) ) { result . add ( p ) ; } } return result ; }
tr	4	@ Override public void caretUpdate ( CaretEvent e ) { Document3 doc = ( ( EditorTextArea3 ) e . getSource ( ) ) . getOmDocument ( ) ; if ( doc != null ) { if ( ( ( EditorController ) Core . getEditor ( ) ) . getCurrentTranslation ( ) != null ) { int start_trans = doc . getTranslationStart ( ) ; int end_trans = start_trans + Core . getEditor ( ) . getCurrentTranslation ( ) . length ( ) ; if ( e . getDot ( ) >= start_trans && e . getDot ( ) <= end_trans ) { sessionlog . GetLog ( ) . CaretUpdate ( e . getMark ( ) + 1 , e . getDot ( ) + 1 ) ; } } } }
tr	1	@ Override public Hotel get ( String nom ) throws Exception { Session session = null ; Hotel hotel = null ; try { session = HibernateUtil . getSessionFactory ( ) . getCurrentSession ( ) ; session . beginTransaction ( ) ; hotel = ( Hotel ) session . get ( Hotel . class , nom ) ; } catch ( RuntimeException e ) { session . getTransaction ( ) . rollback ( ) ; throw new Exception ( "hotelNoExisteix" ) ; } return hotel ; }
tr	7	public void addOperator ( BinaryOperator operator ) { if ( ! functionContextStack . isEmpty ( ) ) { Integer sizeOperators = functionContextStack . peek ( ) . getSizeOperatorsForParameters ( ) ; if ( sizeOperators != null ) { while ( ! operatorStack . isEmpty ( ) && sizeOperators != operatorStack . size ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { final BinaryOperator binaryOperator = operatorStack . pop ( ) ; applyOperator ( binaryOperator ) ; } } } else { while ( ! operatorStack . isEmpty ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { applyOperator ( operatorStack . pop ( ) ) ; } } operatorStack . push ( operator ) ; }
tr	1	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	2	public void processLogout ( Login login ) { if ( login != null && ! Util . nullOrEmptyOrBlank ( login . getEmail ( ) ) ) { Volunteer volunteer = getVolunteerByEmail ( login . getEmail ( ) ) ; LoggedInVolunteer loggedInVolunteer = volunteer . getLogin ( ) ; loggedInVolunteer . setLoggedout ( new Date ( ) ) ; sessionFactory . getCurrentSession ( ) . update ( loggedInVolunteer ) ; } }
tr	8	public void init ( ) { try { Level . loadBehaviors ( new DataInputStream ( ResourcesManager . class . getResourceAsStream ( "res/tiles.dat" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } if ( level == null ) if ( isCustom ) { MyLevelGenerator clg = new MyLevelGenerator ( ) ; GamePlay gp = new GamePlay ( ) ; gp = gp . read ( "player.txt" ) ; currentLevel = ( Level ) clg . generateLevel ( gp ) ; String detailedInfo = FileHandler . readFile ( "DetailedInfo.txt" ) ; } else currentLevel = new RandomLevel ( 320 , 15 , levelSeed , levelDifficulty , levelType ) ; try { level = currentLevel . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } Art . startMusic ( 1 ) ; paused = false ; Sprite . spriteContext = this ; sprites . clear ( ) ; layer = new LevelRenderer ( level , graphicsConfiguration , 320 , 240 ) ; for ( int i = 0 ; i < 2 ; i ++ ) { int scrollSpeed = 4 >> i ; int w = ( ( level . getWidth ( ) * 16 ) - 320 ) / scrollSpeed + 320 ; int h = ( ( level . getHeight ( ) * 16 ) - 240 ) / scrollSpeed + 240 ; Level bgLevel = BgLevelGenerator . createLevel ( w / 32 + 1 , h / 32 + 1 , i == 0 , levelType ) ; bgLayer [ i ] = new BgRenderer ( bgLevel , graphicsConfiguration , 320 , 240 , scrollSpeed ) ; } double oldX = 0 ; if ( mario != null ) oldX = mario . x ; mario = new Mario ( this ) ; sprites . add ( mario ) ; startTime = 1 ; timeLeft = 200 * 15 ; tick = 0 ; switchPoints = new ArrayList < double > ( ) ; int squareSize = 16 ; int sections = 10 ; double startX = 32 ; double endX = level . getxExit ( ) * squareSize ; if ( ! isCustom && recorder == null ) recorder = new DataRecorder ( this , ( RandomLevel ) level , keys ) ; gameStarted = false ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
tr	0	public boolean inGameStateNextFrame ( String state ) { return el . inGameStateNextFrame ( state ) ; }
tr	3	@ Override public void setInitialized ( short mask , float value ) { switch ( mask ) { case Constants . F_MASK : f = value ; break ; case Constants . X_MASK : x = value ; break ; case Constants . Y_MASK : y = value ; break ; default : break ; } }
tr	4	@ Override public void setChild ( int childIndex , GeneTrait child ) { if ( objectType == null ) { if ( childIndex < childTypes . size ( ) ) { childGenes . put ( childIndex , child ) ; } else { throw new IllegalArgumentException ( "No such child index: " + childIndex ) ; } } else { if ( childIndex == 0 ) { object = child ; } else if ( childIndex - 1 < childTypes . size ( ) ) { childGenes . put ( childIndex - 1 , child ) ; } else { throw new IllegalArgumentException ( "No such child index: " + childIndex ) ; } } }
tr	6	public Settings ( JPanel content ) { JPanel theContent = new JPanel ( new GridLayout ( 12 , 1 , 0 , 5 ) ) ; auxButton . setFocusPainted ( false ) ; radButton . setFocusPainted ( false ) ; cdButton . setFocusPainted ( false ) ; climateLabel = new JLabel ( "Climate" ) ; climateLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; climateControl . setMinorTickSpacing ( 1 ) ; Hashtable labelTable = new Hashtable ( ) ; labelTable . put ( new Integer ( 0 ) , new JLabel ( "Cold" ) ) ; labelTable . put ( new Integer ( CLIMATE_MAX ) , new JLabel ( "Hot" ) ) ; climateControl . setLabelTable ( labelTable ) ; climateControl . setPaintLabels ( true ) ; ventLabel = new JLabel ( "Ventilation Fan" ) ; ventLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; ventButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { ventButton . setText ( "On" ) ; ventButton . setBackground ( Color . decode ( "#92CD00" ) ) ; } else { ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; } } } ) ; soundLabel = new JLabel ( "Sound" ) ; soundLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; radioLabel = new JLabel ( "Volume" ) ; radioLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; frequency . setText ( "107.10" ) ; musicCards . add ( radioCard , "Radio controller" ) ; musicCards . add ( cdCard , "CD controller" ) ; musicCards . add ( auxCard , "AUX controller" ) ; Hashtable volLabelTable = new Hashtable ( ) ; volLabelTable . put ( new Integer ( 0 ) , new JLabel ( "0" ) ) ; volLabelTable . put ( new Integer ( 10 ) , new JLabel ( "1" ) ) ; volLabelTable . put ( new Integer ( 20 ) , new JLabel ( "2" ) ) ; volLabelTable . put ( new Integer ( 30 ) , new JLabel ( "3" ) ) ; volLabelTable . put ( new Integer ( 40 ) , new JLabel ( "4" ) ) ; volLabelTable . put ( new Integer ( 50 ) , new JLabel ( "5" ) ) ; volLabelTable . put ( new Integer ( 60 ) , new JLabel ( "6" ) ) ; volLabelTable . put ( new Integer ( 70 ) , new JLabel ( "7" ) ) ; volLabelTable . put ( new Integer ( 80 ) , new JLabel ( "8" ) ) ; volLabelTable . put ( new Integer ( 90 ) , new JLabel ( "9" ) ) ; volLabelTable . put ( new Integer ( 100 ) , new JLabel ( "10" ) ) ; volLabelTable . put ( new Integer ( 110 ) , new JLabel ( "11" ) ) ; radVolControl . setLabelTable ( volLabelTable ) ; radVolControl . setPaintLabels ( true ) ; freqButton . setText ( "AM" ) ; freqButton . setFocusPainted ( false ) ; freqButton . setBackground ( Color . decode ( "#393939" ) ) ; freqButton . setForeground ( Color . decode ( "#FFFFFF" ) ) ; freqButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { freqButton . setText ( "FM" ) ; } else { freqButton . setText ( "AM" ) ; } } } ) ; radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; freqLabel = new JLabel ( "Frequency:" ) ; freqLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; JPanel musicButtons = new JPanel ( new GridLayout ( 1 , 3 ) ) ; radButton . setText ( "RADIO" ) ; radButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "Radio controller" ) ; } } ) ; musicButtons . add ( radButton ) ; auxButton . setText ( "AUX" ) ; auxButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { auxButton . setBackground ( Color . decode ( "#92CD00" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "AUX controller" ) ; } } ) ; musicButtons . add ( auxButton ) ; cdButton . setText ( "CD" ) ; cdButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "CD controller" ) ; } } ) ; musicButtons . add ( cdButton ) ; radioCard . add ( freqLabel ) ; radioCard . add ( frequency ) ; radioCard . add ( freqButton ) ; auxCard . add ( new JLabel ( "AUX Connected..." ) ) ; JPanel cdButtons = new JPanel ( new GridLayout ( 1 , 6 ) ) ; JButton playBtn = new JButton ( "Play" ) ; playBtn . setFocusPainted ( false ) ; playBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( playBtn ) ; JButton pauseBtn = new JButton ( "Pause" ) ; pauseBtn . setFocusPainted ( false ) ; pauseBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Paused" ) ; } } ) ; cdButtons . add ( pauseBtn ) ; JButton stopBtn = new JButton ( "Stop" ) ; stopBtn . setFocusPainted ( false ) ; stopBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Stopped" ) ; } } ) ; cdButtons . add ( stopBtn ) ; JButton prevBtn = new JButton ( "PREV" ) ; prevBtn . setFocusPainted ( false ) ; prevBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( prevBtn ) ; JButton nextBtn = new JButton ( "next" ) ; nextBtn . setFocusPainted ( false ) ; nextBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( nextBtn ) ; JButton eject = new JButton ( "Eject" ) ; eject . setFocusPainted ( false ) ; cdButtons . add ( eject ) ; cdCard . add ( cdButtons ) ; cdCard . add ( cdStatusLabel ) ; settings . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; theContent . add ( settings ) ; theContent . add ( climateLabel ) ; theContent . add ( climateControl ) ; theContent . add ( ventLabel ) ; theContent . add ( ventButton ) ; theContent . add ( soundLabel ) ; theContent . add ( radioLabel ) ; theContent . add ( radVolControl ) ; theContent . add ( musicButtons ) ; theContent . add ( musicCards ) ; add ( theContent ) ; }
tr	2	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Agregar ( ) . setVisible ( true ) ; } } ) ; }
tr	6	protected byte [ ] convertPasswordToKey ( String password ) { if ( password == null ) return null ; int count = password . length ( ) ; if ( count < 8 ) password += "         " . substring ( count ) ; byte [ ] pw = password . getBytes ( ) ; count = pw . length ; int pos = 0 ; byte [ ] key = new byte [ 7 ] ; for ( ; ; ) { for ( int n = 0 ; n < 7 ; n ++ ) { int p1 = pw [ pos + n ] & FF ; p1 >>= n ; int p2 = pw [ pos + n + 1 ] & FF ; p2 <<= ( 7 - n ) ; key [ n ] = ( byte ) ( p1 + p2 ) ; } pos += 8 ; if ( pos == count ) return key ; int pending = count - pos ; if ( pending < 8 ) pos -= 8 - pending ; encrypt ( key , pw , pos , 8 ) ; } }
tr	3	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
tr	8	public SharingPanel ( int w , int h ) { super ( ) ; this . width = w ; this . height = h ; this . isSelected = false ; this . setBackground ( Constants . backColor ) ; this . setLayout ( null ) ; this . selectedInfo = "" ; bgImg = new JLabel ( new ImageIcon ( Constants . BackgroudPath . shareListBG . getPath ( ) ) ) ; bgImg . setBounds ( 0 , 0 , width , height ) ; shareTo = new ImageIcon [ 3 ] ; shareTo [ 0 ] = new ImageIcon ( Constants . IconPath . shareToIcon1 . getPath ( ) ) ; shareTo [ 1 ] = new ImageIcon ( Constants . IconPath . shareToIcon2 . getPath ( ) ) ; shareTo [ 2 ] = new ImageIcon ( Constants . IconPath . shareToIcon3 . getPath ( ) ) ; shareFrom = new ImageIcon [ 3 ] ; shareFrom [ 0 ] = new ImageIcon ( Constants . IconPath . shareFromIcon1 . getPath ( ) ) ; shareFrom [ 1 ] = new ImageIcon ( Constants . IconPath . shareFromIcon2 . getPath ( ) ) ; shareFrom [ 2 ] = new ImageIcon ( Constants . IconPath . shareFromIcon3 . getPath ( ) ) ; handler = new ActionHandler ( ) ; tableModel = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; tableModel . setColumnIdentifiers ( new String [ ] { "    User ID" , "    Directory" , "  Status" , "" , "" , "" } ) ; table = new JTable ( ) { public class getColumnClass ( int column ) { return getValueAt ( 0 , column ) . getClass ( ) ; } } ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . setRowHeight ( 30 ) ; table . setFont ( Constants . Font1 ) ; table . setModel ( tableModel ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 130 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 150 ) ; table . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 100 ) ; for ( int i = 3 ; i < 6 ; i ++ ) { table . getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMinWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMaxWidth ( 0 ) ; } table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) && ! editMode ) { isSelected = true ; selectedInfo = "" ; if ( table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareTo [ 0 ] ) || table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareFrom [ 0 ] ) ) { initialize ( ) ; if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Target" ) ) { selectedInfo = "Target" ; } else if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Requester" ) ) { selectedInfo = "Requester" ; } } changePanel ( ) ; } } } ) ; header = table . getTableHeader ( ) ; header . setFont ( Constants . Font2 ) ; header . setEnabled ( false ) ; renderer = new DefaultTableCellRenderer ( ) ; renderer . setHorizontalAlignment ( JLabel . CENTER ) ; renderer . setFont ( getFont ( ) . deriveFont ( 80f ) ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( renderer ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( renderer ) ; scroll = new JScrollPane ( table , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setBounds ( 200 , 200 , 400 , 250 ) ; btn = new JButton [ 4 ] ; btn [ 0 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . confirmBtn1 . getPath ( ) ) ) ; btn [ 0 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . confirmBtn2 . getPath ( ) ) ) ; btn [ 1 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . cancelBtn1 . getPath ( ) ) ) ; btn [ 1 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . cancelBtn2 . getPath ( ) ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) { btn [ i ] . setBounds ( 420 + ( i * 100 ) , 160 , 80 , 30 ) ; btn [ i ] . addActionListener ( handler ) ; } this . add ( scroll ) ; this . add ( bgImg ) ; }
tr	7	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	7	private Bed getBed ( CommandLine cmd ) { Bed bed = null ; if ( cmd . hasOption ( "hostel_id" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "bed_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setNumber ( new Integer ( cmd . getOptionValue ( "bed_number" ) ) ) ; } if ( cmd . hasOption ( "room_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setRoomNo ( new Integer ( cmd . getOptionValue ( "room_number" ) ) ) ; } if ( bed != null ) bed . setTariff ( null ) ; return bed ; }
tr	8	public long findMinimumValue ( long x , long y ) { long turns = Math . round ( Math . sqrt ( x + y ) ) ; if ( turns * turns != x + y || x == 2 || y == 2 ) { return - 1 ; } else if ( x == 0 ) { return 0 ; } else if ( x <= 2 * turns ) { return ( x % 2 == 0 ? 2 : 1 ) ; } else if ( x == 2 * turns + 1 ) { return 3 ; } else { int i = 0 ; for ( ; x > 2 * turns + 1 ; i ++ ) { x -= 2 * turns - 1 ; turns -- ; } return i + findMinimumValue ( x , y ) ; } }
tr	1	public String getMapType ( SwarmSymbolTable symbolTable ) { try { SwarmSymbolMap map = symbolTable . lookupMap ( myIdentifier . getIdentifierName ( ) ) ; return map . getTypeName ( ) ; } catch ( SwarmSymbolNotFoundException e ) { return null ; } }
tr	7	public boolean verifyInput ( ) { name = name . replace ( "'" , "" ) ; location = location . replace ( "'" , "" ) ; if ( mainMenu_id < 0 || vegMenu_id < 0 || client_id < 0 ) { return false ; } if ( numGuests < 0 || totalLengthOfEvent < 0 ) { return false ; } if ( ! status . matches ( "pending" ) && ! status . matches ( "confirmed" ) ) { return false ; } return true ; }
tr	0	public Prenotazione ( ) { super ( ) ; }
tr	7	public boolean equals ( Object obj ) { if ( obj == null || getClass ( ) != obj . getClass ( ) ) return false ; Note other = ( Note ) obj ; if ( endTime != other . endTime ) return false ; if ( ! pitch . equals ( other . pitch ) ) return false ; if ( startTime != other . startTime ) return false ; if ( ! track . equals ( other . track ) ) return false ; if ( velocity != other . velocity ) return false ; return true ; }
tr	5	private void labelVertex ( Segment segment , long crossProduct , Path path ) { if ( crossProduct > 0 ) { if ( path . isInverted ) segment . end . type = Vertex . OUTIE ; else segment . end . type = Vertex . INNIE ; } else if ( crossProduct < 0 ) { if ( path . isInverted ) segment . end . type = Vertex . INNIE ; else segment . end . type = Vertex . OUTIE ; } else if ( segment . start . type != Vertex . NOT_SET ) segment . end . type = segment . start . type ; else segment . end . type = Vertex . INNIE ; }
tr	4	static void createNewPearltree ( Panel panel , boolean active ) { final Label item = createLabel ( ) ; final FlowPanel description = new FlowPanel ( ) ; item . setText ( "a new pearltree" ) ; if ( WebContent . onIpad ) { description . setStylePrimaryName ( PRIMARY_STYLE_NEWPEARLTREE ) ; panel . add ( description ) ; HTML newPearltreeBox = PopupElements . createHtml ( ) ; newPearltreeBox . setStylePrimaryName ( PopupElements . PRIMARY_STYLE_AVATARBOX ) ; newPearltreeBox . addStyleDependentName ( PopupElements . STYLE_SPECIAL_PADDING ) ; newPearltreeBox . setHTML ( NEW_PEARLTREE ) ; description . add ( newPearltreeBox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! WebContent . onIpad ) { item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_BOLD ) ; item . addStyleDependentName ( STYLE_PADDING ) ; } item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_ITEM ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { if ( WebContent . onIpad ) { description . addStyleDependentName ( STYLE_SELECTED_TIMER ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { DOM . removeElementAttribute ( TreeListUI . panelInside . getElement ( ) , "id" ) ; PopupControl . changeUI ( PopupUIs . NewTree ) ; } } ; t . schedule ( 120 ) ; } else { PopupControl . changeUI ( PopupUIs . NewTree ) ; } } } ) ; } else { item . addStyleDependentName ( STYLE_INACTIVE ) ; } }
tr	6	public String getType ( VesselType type ) { switch ( type ) { case SWIMMER : return "1 - Human (swimmer)" ; case SPEED_BOAT : return "2 - Speed Boat" ; case FISHING_BOAT : return "3 - Fishing Boat" ; case CARGO_BOAT : return "4 - Cargo Vessel" ; case PASSENGER_VESSEL : return "5 - Passenger Vessel" ; case UNKNOWN : return "6 - Unknown" ; default : return "6 - Unknown" ; } }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	9X	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
tr	6	private boolean publish ( Uri topic_uri , Object data , boolean exclude_me , String [ ] exclude , String [ ] eligible ) { ArrayNode request = json_mapper_ . createArrayNode ( ) ; request . add ( is_server_ ? kEvent : kPublish ) ; request . add ( topic_uri . toString ( ) ) ; request . addPOJO ( data ) ; if ( exclude_me ) { request . add ( exclude_me ) ; } else if ( exclude != null ) { request . addPOJO ( exclude ) ; } if ( eligible != null ) { if ( request . size ( ) < 4 ) { request . addPOJO ( new String [ ] { } ) ; } request . addPOJO ( eligible ) ; } try { return sender_ . sendText ( json_mapper_ . writeValueAsString ( request ) ) ; } catch ( JsonProcessingException e ) { return false ; } }
tr	3	public Ouvrage rechOuvrage ( String isbn ) { Ouvrage ouv = this . getOuvrage ( isbn ) ; if ( ouv == null ) { Message dialog = new Message ( "Ouvrage inconnu" ) ; } else { if ( this . getVue ( ) instanceof VueSaisieExemplaire ) { ouv . addObserver ( this . getVue ( ) ) ; this . getVue ( ) . setEtat ( Vue . inter1 ) ; ( ( VueSaisieExemplaire ) this . getVue ( ) ) . alimente ( ouv ) ; } if ( this . getVue ( ) instanceof VueConsultOuvrage ) { this . getVue ( ) . setEtat ( Vue . finale ) ; ( ( VueConsultOuvrage ) this . getVue ( ) ) . alimente ( ouv ) ; } } return ouv ; }
tr	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new DeliverClient ( ) . setVisible ( true ) ; } catch ( UnknownHostException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	6	public static boolean isValidShuffleDynamicProgramming ( String str1 , String str2 , String str3 ) { if ( str1 == null || str2 == null || str3 == null ) { return false ; } if ( str1 . length ( ) + str2 . length ( ) != str3 . length ( ) ) { return false ; } if ( str1 . isEmpty ( ) ) { return str2 . equals ( str3 ) ; } if ( str2 . isEmpty ( ) ) { return str1 . equals ( str3 ) ; } return isValidShuffleRecursiveDynamicProgramming ( str1 , str2 , str3 , 0 , 0 , 0 , new HashSet < > ( ) ) ; }
tr	4	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
tr	8	@ Override protected void doAction ( int option ) { switch ( option ) { case 1 : listAllPlaylists ( ) ; pause ( ) ; break ; case 2 : allSongsInPlaylist ( ) ; break ; case 3 : addPlaylist ( ) ; break ; case 4 : removePlaylist ( ) ; break ; case 5 : ReorderPlaylist ( ) ; break ; case 6 : addSongPlaylist ( ) ; break ; case 7 : removeSongPlaylist ( ) ; break ; case EXIT_VALUE : doActionExit ( ) ; } }
tr	5	public double readDouble ( String prompt , double low , double high ) { String msg = null ; while ( true ) { String line = readLine ( prompt ) ; try { double d = double . valueOf ( line ) . doubleValue ( ) ; if ( d >= low && d <= high ) return d ; msg = "Value is outside the range [" + low + ":" + high + "]" ; } catch ( NumberFormatException ex ) { msg = "Illegal numeric format" ; } showErrorMessage ( msg ) ; if ( prompt == null ) prompt = "Retry: " ; } }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
tr	9X	public static BufferedImage rotate ( BufferedImage src , Rotation rotation , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( rotation == null ) throw new IllegalArgumentException ( "rotation cannot be null" ) ; if ( DEBUG ) log ( 0 , "Rotating Image [%s]..." , rotation ) ; int newWidth = src . getWidth ( ) ; int newHeight = src . getHeight ( ) ; AffineTransform tx = new AffineTransform ( ) ; switch ( rotation ) { case CW_90 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( newWidth , 0 ) ; tx . rotate ( Math . toRadians ( 90 ) ) ; break ; case CW_270 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( 0 , newHeight ) ; tx . rotate ( Math . toRadians ( - 90 ) ) ; break ; case CW_180 : tx . translate ( newWidth , newHeight ) ; tx . rotate ( Math . toRadians ( 180 ) ) ; break ; case FLIP_HORZ : tx . translate ( newWidth , 0 ) ; tx . scale ( - 1.0 , 1.0 ) ; break ; case FLIP_VERT : tx . translate ( 0 , newHeight ) ; tx . scale ( 1.0 , - 1.0 ) ; break ; } BufferedImage result = createOptimalImage ( src , newWidth , newHeight ) ; Graphics2D g2d = ( Graphics2D ) result . createGraphics ( ) ; g2d . drawImage ( src , tx , null ) ; g2d . dispose ( ) ; if ( DEBUG ) log ( 0 , "Rotation Applied in %d ms  result [width=%d  height=%d]" , System . currentTimeMillis ( ) - t , result . getWidth ( ) , result . getHeight ( ) ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	1	public User getByID ( Line line ) { try { return getByID ( line . getString ( "userid" ) ) ; } catch ( Exception ex ) { } return getByID ( line . toString ( ) ) ; }
tr	6	private void method130 ( int j , int k , int l , int i1 , int j1 , int k1 , int l1 , int i2 , int j2 ) { Class30_Sub1 class30_sub1 = null ; for ( Class30_Sub1 class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetFirst ( ) ; class30_sub1_1 != null ; class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetNext ( ) ) { if ( class30_sub1_1 . anInt1295 != l1 || class30_sub1_1 . anInt1297 != i2 || class30_sub1_1 . anInt1298 != j1 || class30_sub1_1 . anInt1296 != i1 ) continue ; class30_sub1 = class30_sub1_1 ; break ; } if ( class30_sub1 == null ) { class30_sub1 = new Class30_Sub1 ( ) ; class30_sub1 . anInt1295 = l1 ; class30_sub1 . anInt1296 = i1 ; class30_sub1 . anInt1297 = i2 ; class30_sub1 . anInt1298 = j1 ; method89 ( class30_sub1 ) ; aClass19_1179 . insertHead ( class30_sub1 ) ; } class30_sub1 . anInt1291 = k ; class30_sub1 . anInt1293 = k1 ; class30_sub1 . anInt1292 = l ; class30_sub1 . anInt1302 = j2 ; class30_sub1 . anInt1294 = j ; }
tr	4	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
tr	3	private JPanel getCenterPanel ( ) { if ( centerPanel == null ) { centerPanel = new JPanel ( ) ; centerPanel . setLayout ( new MigLayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttonGameBoard [ i ] [ j ] . setSize ( 40 , 40 ) ; centerPanel . add ( buttonGameBoard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerPanel ; }
tr	9X	private Object readLiteral ( ) throws JSONException { String literal = nextToInternal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } else if ( "null" . equalsIgnoreCase ( literal ) ) { return JSONObject . null ; } else if ( "true" . equalsIgnoreCase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsIgnoreCase ( literal ) ) { return boolean . false ; } if ( literal . indexOf ( . ) == - 1 ) { int base = 10 ; String number = literal ; if ( number . startsWith ( "0x" ) || number . startsWith ( "0X" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startsWith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longValue = long . parseLong ( number , base ) ; if ( longValue <= Integer . MAX_VALUE && longValue >= Integer . MIN_VALUE ) { return ( int ) longValue ; } else { return longValue ; } } catch ( NumberFormatException e ) { } } try { return double . valueOf ( literal ) ; } catch ( NumberFormatException ignored ) { } return new String ( literal ) ; }
tr	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; HostRef other = ( HostRef ) obj ; if ( hostId == null ) { if ( other . hostId != null ) return false ; } else if ( ! hostId . equals ( other . hostId ) ) return false ; return true ; }
tr	2	public int generarBoleto ( int sucursal_id , int usuario_id ) { Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; PreparedStatement pst2 ; ResultSet rs ; int idObtenido = 0 ; String queryInsertar = "INSERT INTO boletos(sucursal_id  usuario_id) VALUES (" + sucursal_id + " " + usuario_id + ")" ; String queryObtenerId = "SELECT max(boleto_id) as id FROM boletos" ; try { pst = cn . prepareStatement ( queryInsertar ) ; pst2 = cn . prepareStatement ( queryObtenerId ) ; pst . executeUpdate ( ) ; rs = pst2 . executeQuery ( ) ; while ( rs . next ( ) ) { idObtenido = rs . getInt ( "id" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , "Error al generar el boleto: " + ex ) ; } return idObtenido ; }
tr	0	public int process_id ( ) { return 2 ; }
tr	3	private void checkBoxCollisions ( ) { for ( ImageView r : model . getBoxes ( ) ) { if ( r . isVisible ( ) && ball . intersects ( r . getBoundsInParent ( ) ) ) { model . getBoxesLeft ( ) . set ( model . getBoxesLeft ( ) . get ( ) - 1 ) ; r . setVisible ( false ) ; } } }
tr	7	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; xa = shell . facing * 2 ; ya = - 5 ; flyDeath = true ; if ( spriteTemplate != null ) spriteTemplate . isDead = true ; deadTime = 100 ; winged = false ; hPic = - hPic ; yPicO = - yPicO + 16 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	9X	public int getConfig ( int uid , int x , int y , int z ) { Ground tile = groundArray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallObject != null && tile . wallObject . uid == uid ) return tile . wallObject . objConf & ff ; if ( tile . wallDecoration != null && tile . wallDecoration . uid == uid ) return tile . wallDecoration . objConf & ff ; if ( tile . groundDecoration != null && tile . groundDecoration . uid == uid ) return tile . groundDecoration . objConf & ff ; for ( int e = 0 ; e < tile . entityCount ; e ++ ) if ( tile . interactiveObjects [ e ] . uid == uid ) return tile . interactiveObjects [ e ] . objConf & ff ; return - 1 ; }
tr	9X	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
tr	6	private String getIndexText ( int index , int colour ) { assert ( colour == PL_WHITE || colour == PL_BLACK ) ; assert ( index >= 0 && index <= 15 ) ; String result = "" ; result += col_text [ index % 8 ] ; if ( colour == PL_WHITE ) { result += ( index <= 7 ) ? "2" : "1" ; } if ( colour == PL_BLACK ) { result += ( index <= 7 ) ? "7" : "8" ; } return result ; }
tr	4	private void addContent ( ) { ScheduleDAO sdao = new ScheduleDAO ( db . connection ) ; for ( String day : StaticRes . WEEK_DAY_LIST ) { List < Schedule > list = sdao . getScheduleByDayList ( day ) ; TableModel model = new ScheduleTableModel ( list ) ; table = new JTable ( model ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 100 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 17 ) ; table . setRowHeight ( 20 ) ; table . addMouseListener ( new java . awt . event . MouseAdapter ( ) { @ Override public void mouseClicked ( java . awt . event . MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 && evt . getButton ( ) == MouseEvent . BUTTON1 ) { int row = ( ( JTable ) evt . getSource ( ) ) . rowAtPoint ( evt . getPoint ( ) ) ; ; if ( row >= 0 ) { Schedule schedule = ( Schedule ) ( ( JTable ) evt . getSource ( ) ) . getValueAt ( row , - 1 ) ; Teacher teacher = ( Teacher ) cbTeacher . getSelectedItem ( ) ; submit ( schedule , teacher ) ; } } } } ) ; tabbedPane . addTab ( day , new JScrollPane ( table ) ) ; } }
tr	2	public static void assert_are_of_type ( class expected_type , Object ... objects ) { for ( Object object : objects ) { if ( ! object . getClass ( ) . isInstance ( expected_type ) ) { assert . fail ( String . format ( "Expecting type [%s] GOT [%s]" , expected_type , object . getClass ( ) ) ) ; } } }
tr	0	public boolean isDataFlavorSupported ( DataFlavor flavor ) { return false ; }
tr	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isOpenV ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( toBottom [ idx ] ) { percolates = true ; } ufTop . union ( idx , theTOP ) ; } else { connectIfDestOpen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectIfDestOpen ( idx , row , col - 1 ) ; } if ( col < N ) { connectIfDestOpen ( idx , row , col + 1 ) ; } if ( row == N ) { if ( toTop [ idx ] ) { percolates = true ; } } else { connectIfDestOpen ( idx , row + 1 , col ) ; } } }
tr	3	synchronized public int getPlayerIndex ( String ip , int port ) { for ( int i = 0 ; i < playersArr . length ; i ++ ) { if ( ( playersArr [ i ] != null ) && ( playersArr [ i ] . matches ( ip , port ) ) ) return i ; } return - 1 ; }
tr	8	public static int countPath3 ( int m , int n ) { if ( m < 0 || n < 0 ) { return 0 ; } if ( m == 0 && n == 0 ) { return 1 ; } if ( m == 0 && n != 0 ) { return 1 ; } if ( n == 0 && m != 0 ) { return 1 ; } return countPath3 ( m - 1 , n ) + countPath3 ( m , n - 1 ) ; }
tr	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
tr	5	public String getString ( String key ) { for ( int i = messages . size ( ) - 1 ; i >= 0 ; i -- ) { Object messageContainer = messages . get ( i ) ; if ( messageContainer instanceof Properties && ( ( Properties ) messageContainer ) . containsKey ( key ) ) return ( ( Properties ) messageContainer ) . getProperty ( key ) ; if ( messageContainer instanceof ResourceBundle && containsKey ( ( ResourceBundle ) messageContainer , key ) ) return ( ( ResourceBundle ) messageContainer ) . getString ( key ) ; } return null ; }
tr	5	public ArrayList < ClosedTransaction > closeLong ( TransactionHistory th ) { int closeAmount = th . getAmount ( ) * - 1 ; if ( this . openAmount <= 0 || closeAmount <= 0 ) { throw new InvalidCloseAction ( ) ; } double closePrice = th . getPrice ( ) ; Date closeTime = th . getTime ( ) ; if ( closeAmount > this . openAmount ) { throw new NotEnoughAmountToClose ( closeAmount ) ; } this . openAmount -= closeAmount ; ArrayList < ClosedTransaction > closed = new ArrayList < ClosedTransaction > ( ) ; int remainToClose = closeAmount ; while ( remainToClose > 0 ) { OpenTransaction node = this . openList . getFirst ( ) ; int nodeAmount = node . getOpenAmount ( ) ; if ( remainToClose >= nodeAmount ) { ClosedTransaction ct = node . close ( closeTime , closePrice , nodeAmount ) ; closed . add ( ct ) ; this . openList . removeFirst ( ) ; remainToClose -= nodeAmount ; } else { ClosedTransaction ct = node . close ( closeTime , closePrice , remainToClose ) ; closed . add ( ct ) ; node . setOpenAmount ( nodeAmount - remainToClose ) ; remainToClose = 0 ; } } return closed ; }
tr	7	private void loadFileData ( File modFile ) { try { Document doc = builder . build ( modFile ) ; Element rootNode = doc . getRootElement ( ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "ThingDef" ) ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . hasAttributes ( ) ) { if ( e . getAttribute ( "ParentName" ) == null ) { continue ; } if ( e . getAttributeValue ( "ParentName" ) . equals ( "BaseGun" ) || e . getAttributeValue ( "ParentName" ) . equals ( "BaseEquipment" ) ) { app . getWeaponHandler ( ) . createNewWeapon ( e . getChildText ( "label" ) , e . getChildText ( "defName" ) ) ; } } } } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
tr	2	public static double [ ] [ ] makeGear ( int nTeeth ) { int n = 4 * nTeeth ; double P [ ] [ ] = new double [ n + 2 ] [ 6 ] ; for ( int i = 0 ; i <= n ; i += 2 ) { double theta = 2 * Math . PI * i / n ; double r = i % 4 == 0 ? 1 : 1 - Math . PI / nTeeth ; P [ i ] [ 0 ] = P [ i + 1 ] [ 0 ] = r * Math . cos ( theta ) ; P [ i ] [ 1 ] = P [ i + 1 ] [ 1 ] = r * Math . sin ( theta ) ; P [ i ] [ 2 ] = P [ i + 1 ] [ 2 ] = 0 ; P [ i ] [ 3 ] = Math . cos ( theta - Math . PI / 4 ) ; P [ i ] [ 4 ] = Math . sin ( theta - Math . PI / 4 ) ; P [ i ] [ 5 ] = 0 ; P [ i + 1 ] [ 3 ] = Math . cos ( theta + Math . PI / 4 ) ; P [ i + 1 ] [ 4 ] = Math . sin ( theta + Math . PI / 4 ) ; P [ i + 1 ] [ 5 ] = 0 ; } return P ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent e ) { Vastaustyyppi tyyppi = null ; String kysymysTekstina = kysymys . getText ( ) ; int tyyppiIndeksi = vastaustyyppi . getSelectedIndex ( ) ; if ( tyyppiIndeksi == 0 ) { tyyppi = Vastaustyyppi . AVOIN ; } else if ( tyyppiIndeksi == 1 ) { tyyppi = Vastaustyyppi . LIKERT ; } else if ( tyyppiIndeksi == 2 ) { tyyppi = Vastaustyyppi . ASTEIKKO ; } else if ( tyyppiIndeksi == 3 ) { tyyppi = Vastaustyyppi . KOLMIKENTTA ; } if ( e . getSource ( ) == valmis ) { if ( ! kysymysTekstina . isEmpty ( ) ) { valikko . lisaaKysymys ( kysymysTekstina , tyyppi ) ; } if ( valikko . annaKyselynKoko ( ) == 0 ) { lisaystieto . setText ( "Lis\u00E4\u00E4 ensin kysymys!" ) ; return ; } valikko . vaihdaValikko ( Valikko . LUONTILOPETUS ) ; } if ( e . getSource ( ) == lisaa ) { if ( kysymysTekstina . isEmpty ( ) ) { lisaystieto . setText ( "T\u00E4yt\u00E4 kysymys!" ) ; return ; } valikko . lisaaKysymys ( kysymysTekstina , tyyppi ) ; lisaystieto . setText ( "Lis\u00E4tty! Kysymyksi\u00E4: " + valikko . annaKyselynKoko ( ) ) ; kysymys . setText ( "" ) ; } }
tr	8	private void method117 ( Stream stream ) { stream . initBitAccess ( ) ; int j = stream . readBits ( 1 ) ; if ( j == 0 ) return ; int k = stream . readBits ( 2 ) ; if ( k == 0 ) { anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 1 ) { int l = stream . readBits ( 3 ) ; myPlayer . moveInDir ( false , l ) ; int k1 = stream . readBits ( 1 ) ; if ( k1 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 2 ) { int i1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , i1 ) ; int l1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 3 ) { plane = stream . readBits ( 2 ) ; int j1 = stream . readBits ( 1 ) ; int i2 = stream . readBits ( 1 ) ; if ( i2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; int k2 = stream . readBits ( 7 ) ; int l2 = stream . readBits ( 7 ) ; myPlayer . setPos ( l2 , k2 , j1 == 1 ) ; } }
tr	8	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
tr	4	public void testFetchGroupsForUser ( ) { Group [ ] groups = ga . fetchGroupsForUser ( 1 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 2 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 3 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 1 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 1 ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 5 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 2 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 2 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 2 ] . isIsactive ( ) ) ; } }
tr	2	private void botonEliminarUsuarioActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . tablaAdministracionUsuarios . getSelectedRow ( ) > - 1 ) { String codigo = ( String ) this . conectorTablaUsuarios . getValueAt ( this . tablaAdministracionUsuarios . getSelectedRow ( ) , 0 ) ; int respuesta = JOptionPane . showConfirmDialog ( this . botonEliminarUsuario , "\u00BFRealmente desea eliminar \n al usuario " + codigo + "?" , "Confirme eliminaci\u00F3n" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( respuesta == JOptionPane . YES_OPTION ) { Usuario u = this . modeloApp . obtenerUsuarioConCodigo ( codigo ) ; this . modeloApp . eliminarUsuario ( u ) ; this . conectorTablaUsuarios . cargarUsuarios ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Debe seleccionar un\nusuario de la tabla" , "Usuario no seleccionado" , JOptionPane . INFORMATION_MESSAGE ) ; } }
tr	5	@ Override public final void instantiate ( ) { instanceId = generateInstanceId ( ) ; if ( this instanceof ParentTrait ) { ParentTrait parentThis = ( ParentTrait ) this ; for ( int i = 0 ; i < parentThis . getChildCount ( ) ; i ++ ) { if ( ! ( parentThis instanceof ReferenceTrait ) || ! ( ( ReferenceTrait ) parentThis ) . isBackReference ( i ) ) { GeneTrait childGene = parentThis . getChild ( i ) ; if ( childGene != null ) { childGene . instantiate ( ) ; } } } } }
tr	5	public static int diasMes ( String mesInt ) { int result ; String mes = mesInt . toLowerCase ( ) ; switch ( mes ) { case "febrero" : result = 28 ; break ; case "abril" : case "junio" : case "septiembre" : case "noviembre" : result = 30 ; break ; default : result = 31 ; break ; } return result ; }
tr	7	public CardCertificatesPane ( boolean ca , ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; String label = null ; baseIndex = ca ? 0 : 3 ; clearButtons = new JButton [ 3 ] ; viewButtons = new JButton [ 3 ] ; certNames = new JTextField [ 3 ] ; if ( ! ca ) { verifyButtons = new JButton [ 3 ] ; verifyFlags = new JTextField [ 3 ] ; } totalCerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalCerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; if ( ca ) { label = "CA Cert" ; } else { label = ulabels [ i ] + " Cert" ; } add ( new JLabel ( label + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; button = new JButton ( "Get from Card" ) ; button . setActionCommand ( "cardgetcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Load..." ) ; button . setActionCommand ( "loadcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certNames [ i ] = new JTextField ( 30 ) ; certNames [ i ] . setFont ( MainGUI . FONT ) ; certNames [ i ] . setEditable ( false ) ; components . add ( certNames [ i ] ) ; add ( certNames [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Clear" ) ; button . setActionCommand ( "clearcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; clearButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcardcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; viewButtons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new JButton ( "Verify" ) ; button . setActionCommand ( "verifycert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; verifyButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyFlags [ i ] = new JTextField ( 6 ) ; verifyFlags [ i ] . setFont ( MainGUI . FONT ) ; verifyFlags [ i ] . setEditable ( false ) ; components . add ( verifyFlags [ i ] ) ; add ( verifyFlags [ i ] , c ) ; } c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } updateCertsStatus ( ) ; setBorder ( BorderFactory . createTitledBorder ( ( ca ? "CA" : "User" ) + " Certificates" ) ) ; }
tr	1	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
tr	5	public void setGoalRandom ( ) { if ( this . goals . isEmpty ( ) ) { this . goal = null ; return ; } if ( this . randomGoals . isEmpty ( ) ) { this . randomGoals . addAll ( this . goals ) ; Collections . shuffle ( this . randomGoals , RANDOM ) ; } this . goal = this . randomGoals . remove ( 0 ) ; if ( this . goal . robotNumber >= this . robots . length ) { this . setGoalRandom ( ) ; } if ( this . isSolution01 ( ) && ( this . randomGoals . size ( ) > 0 ) ) { final Goal goal01 = this . goal ; this . setGoalRandom ( ) ; this . randomGoals . add ( goal01 ) ; } }
tr	9X	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
tr	8	protected long skipBytes ( long bytes ) throws BasicPlayerException { long totalSkipped = 0 ; if ( m_dataSource instanceof File ) { int previousStatus = m_status ; m_status = SEEKING ; long skipped = 0 ; try { synchronized ( m_audioInputStream ) { notifyEvent ( BasicPlayerEvent . SEEKING , getEncodedStreamPosition ( ) , - 1 , null ) ; initAudioInputStream ( ) ; if ( m_audioInputStream != null ) { while ( totalSkipped < ( bytes - SKIP_INACCURACY_SIZE ) ) { skipped = m_audioInputStream . skip ( bytes - totalSkipped ) ; if ( skipped == 0 ) break ; totalSkipped = totalSkipped + skipped ; if ( totalSkipped == - 1 ) throw new BasicPlayerException ( BasicPlayerException . SKIPNOTSUPPORTED ) ; } } } notifyEvent ( BasicPlayerEvent . SEEKED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_status = OPENED ; if ( previousStatus == PLAYING ) startPlayback ( ) ; else if ( previousStatus == PAUSED ) { startPlayback ( ) ; pausePlayback ( ) ; } } catch ( IOException e ) { throw new BasicPlayerException ( e ) ; } } return totalSkipped ; }
tr	3	void getLatestVersions ( vslIndexView < String > cur , StringBuffer out ) throws vslInputException { if ( cur . getNextViews ( ) == null ) { if ( cur . isDelete ( ) ) { out . append ( " DELETED " ) ; } else { out . append ( " " ) . append ( cur . getData ( ) ) . append ( " " ) ; } } else { for ( vslIndexView < String > nv : cur . getNextViews ( ) ) { getLatestVersions ( nv , out ) ; } } }
tr	7	public Response multPartURL ( String url , PostParameter [ ] params , ImageItem item , boolean authenticated ) throws WeiboException { PostMethod post = new PostMethod ( url ) ; try { org . apache . commons . httpclient . HttpClient client = getHttpClient ( ) ; long t = System . currentTimeMillis ( ) ; Part [ ] parts = null ; if ( params == null ) { parts = new Part [ 1 ] ; } else { parts = new Part [ params . length + 1 ] ; } if ( params != null ) { int i = 0 ; for ( PostParameter entry : params ) { parts [ i ++ ] = new StringPart ( entry . getName ( ) , ( String ) entry . getValue ( ) ) ; } parts [ parts . length - 1 ] = new ByteArrayPart ( item . getContent ( ) , item . getName ( ) , item . getContentType ( ) ) ; } post . setRequestEntity ( new MultipartRequestEntity ( parts , post . getParams ( ) ) ) ; List < Header > headers = new ArrayList < Header > ( ) ; if ( authenticated ) { if ( oauth == null ) { } String authorization = null ; if ( null != oauth ) { authorization = oauth . generateAuthorizationHeader ( "POST" , url , params , oauthToken ) ; } else { throw new IllegalStateException ( "Neither user ID/password combination nor OAuth consumer key/secret combination supplied" ) ; } headers . add ( new Header ( "Authorization" , authorization ) ) ; log ( "Authorization: " + authorization ) ; } client . getHostConfiguration ( ) . getParams ( ) . setParameter ( "http.default-headers" , headers ) ; client . executeMethod ( post ) ; Response response = new Response ( ) ; response . setResponseAsString ( post . getResponseBodyAsString ( ) ) ; response . setStatusCode ( post . getStatusCode ( ) ) ; log ( "multPartURL URL:" + url + "  result:" + response + "  time:" + ( System . currentTimeMillis ( ) - t ) ) ; return response ; } catch ( Exception ex ) { throw new WeiboException ( ex . getMessage ( ) , ex , - 1 ) ; } finally { post . releaseConnection ( ) ; } }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	9X	@ Override public Party getEnemyParty ( int level ) { Party party = new Party ( ) ; Random gen = new Random ( ) ; if ( level == 1 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Goblin ( ) ) ; else party . add ( new Rat ( ) ) ; } else if ( level == 2 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Orc ( ) ) ; else party . add ( new Zombie ( ) ) ; } else if ( level == 3 ) { party . add ( new Spider ( ) ) ; } else if ( level == 5 ) { party . add ( new Ogre ( ) ) ; } else if ( level == 7 ) { party . add ( new Gargoyle ( ) ) ; } else if ( level == 15 ) { party . add ( new Dragon ( ) ) ; } else { do { int enemy = gen . nextInt ( level ) + 1 ; party . addAll ( getEnemyParty ( enemy ) ) ; level = level - enemy ; } while ( level != 0 ) ; } return party ; }
tr	1	public double getRadius ( ) { if ( launched ) return 0 ; return 15 ; }
tr	8	public static int [ ] [ ] readIntMatrix ( ) { while ( true ) { String [ ] lineTokens = readString ( ) . split ( "/" ) ; if ( lineTokens . length > 1 ) { String [ ] [ ] tokens = new String [ lineTokens . length ] [ ] ; int columns = 0 ; for ( int line = 0 ; line < lineTokens . length ; line ++ ) { tokens [ line ] = lineTokens [ line ] . split ( " " ) ; if ( tokens [ line ] . length > columns ) { columns = tokens [ line ] . length ; } } if ( columns > 0 ) { int [ ] [ ] array = new int [ lineTokens . length ] [ columns ] ; try { for ( int line = 0 ; line < tokens . length ; line ++ ) { for ( int column = 0 ; column < tokens [ line ] . length ; column ++ ) { array [ line ] [ column ] = Integer . parseInt ( tokens [ line ] [ column ] ) ; } } return array ; } catch ( NumberFormatException e ) { System . err . println ( ERROR_INVALID_INT ) ; } } else { System . out . println ( ERROR_EMPTY_LINE ) ; } } else { System . out . println ( ERROR_ONE_LINE_ARRAY ) ; } } }
tr	0	private void initializeComponents ( ) { this . setLayout ( new BorderLayout ( ) ) ; ingredientPanel = new IngredientPanel ( ) ; ingredientPanel . addChangeListener ( this ) ; textPanel = new JPanel ( new BorderLayout ( ) ) ; textPane = new JTextArea ( ) ; textPane . setLineWrap ( true ) ; textPane . setLineWrap ( true ) ; textPane . setWrapStyleWord ( true ) ; textPane . setEditable ( true ) ; textPane . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; textScrollPane = new JScrollPane ( textPane ) ; textScrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; textScrollPane . setPreferredSize ( new Dimension ( 450 , 200 ) ) ; headline = new JTextField ( ) ; headline . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; this . setPreferredSize ( new Dimension ( 750 , 250 ) ) ; }
tr	7	private void handleActionComplete ( MqttToken token ) throws MqttException { final String methodName = "handleActionComplete" ; synchronized ( token ) { log . fine ( className , methodName , "705" , new Object [ ] { token . internalTok . getKey ( ) } ) ; token . internalTok . notifyComplete ( ) ; if ( ! token . internalTok . isNotified ( ) ) { if ( mqttCallback != null && token instanceof MqttDeliveryToken && token . isComplete ( ) ) { mqttCallback . deliveryComplete ( ( MqttDeliveryToken ) token ) ; } fireActionEvent ( token ) ; } if ( token instanceof MqttDeliveryToken && token . isComplete ( ) ) { token . internalTok . setNotified ( true ) ; } if ( token . isComplete ( ) ) { clientState . notifyComplete ( token ) ; } } }
tr	6	public static Map < String , boolean > getAllChildren ( final String node , final Set < String > playerPermArray ) { final LinkedList < String > stack = new LinkedList < String > ( ) ; final Map < String , boolean > alreadyVisited = new HashMap < String , boolean > ( ) ; stack . push ( node ) ; alreadyVisited . put ( node , true ) ; while ( ! stack . isEmpty ( ) ) { final String now = stack . pop ( ) ; final Map < String , boolean > children = AdminPerms . getChildren ( now ) ; if ( children != null && ! playerPermArray . contains ( "-" + now ) ) { for ( final String childName : children . keySet ( ) ) { if ( ! alreadyVisited . containsKey ( childName ) ) { stack . push ( childName ) ; alreadyVisited . put ( childName , children . get ( childName ) ) ; } } } } alreadyVisited . remove ( node ) ; if ( ! alreadyVisited . isEmpty ( ) ) { return alreadyVisited ; } return null ; }
tr	8	private void buildMenu ( ) { jmbMenu = new JMenuBar ( ) ; JMenu jmFile = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.file" , "File" ) ) ; JMenuItem jmiConnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.connect" , "Connect" ) ) ; JMenuItem jmiDisconnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.disconnect" , "Disconnect" ) ) ; JMenuItem jmiOpen = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.openExisting" , "Open Existing" ) ) ; JMenuItem jmiRemove = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.remove" , "Remove Existing" ) ) ; JMenuItem jmiPrint = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.print" , "Print" ) ) ; JMenuItem jmiSave = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.save" , "Save As CSV" ) ) ; JMenuItem jmiExit = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.exit" , "Exit" ) ) ; jmFile . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.file.acc" , "f" ) ) . charAt ( 0 ) ) ; jmiConnect . addActionListener ( new File_New ( ) ) ; jmiDisconnect . addActionListener ( new File_Disconnect ( ) ) ; jmiOpen . addActionListener ( new File_Open ( this ) ) ; jmiRemove . addActionListener ( new File_Remove ( ) ) ; jmiPrint . addActionListener ( new File_Print ( ) ) ; jmiSave . addActionListener ( new File_Save ( ) ) ; jmiExit . addActionListener ( new File_Exit ( ) ) ; jmFile . add ( jmiConnect ) ; jmFile . add ( jmiDisconnect ) ; jmFile . add ( jmiOpen ) ; jmFile . add ( jmiRemove ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiPrint ) ; jmFile . add ( jmiSave ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiExit ) ; JMenu jmView = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.view" , "View" ) ) ; JMenuItem jmiConnections = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connections" ) ) ; JMenuItem jmiClients = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connected Clients" ) ) ; jmView . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.view.acc" , "v" ) ) . charAt ( 0 ) ) ; jmiConnections . addActionListener ( new View_Connections ( ) ) ; jmiClients . addActionListener ( new View_Clients ( ) ) ; jmView . add ( jmiConnections ) ; jmView . add ( jmiClients ) ; JMenu jmPrefs = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.preferences" , "Preferences" ) ) ; JMenu jmLnF = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.lnf" , "Look and Feel" ) ) ; JMenu jmLocale = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.locale" , "Locale" ) ) ; JMenu jmLogging = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.logging" , "Logging" ) ) ; JMenuItem jmiXSDDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.XSDDir" , "Set Schema Location" ) ) ; JMenuItem jmiLogDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.LogsDir" , "Set Log Directory" ) ) ; jmPrefs . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.preferences.acc" , "p" ) ) . charAt ( 0 ) ) ; UIManager . LookAndFeelInfo [ ] lafThisSystem = UIManager . getInstalledLookAndFeels ( ) ; ButtonGroup bgLnF = new ButtonGroup ( ) ; for ( int i = 0 ; i < lafThisSystem . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lafThisSystem [ i ] . getName ( ) ) ; jrbMI . addActionListener ( new Prefs_LnF ( lafThisSystem [ i ] . getClassName ( ) , this , mrbGui . getRBLocale ( ) ) ) ; if ( lafThisSystem [ i ] . getClassName ( ) . equals ( pGui . get ( "mars.lnf" , "javax.swing.plaf.metal.MetalLookAndFeel" ) ) ) { jrbMI . setSelected ( true ) ; } bgLnF . add ( jrbMI ) ; jmLnF . add ( jrbMI ) ; } String strNumOfLangs = mrbGui . getRBString ( "mars.locales.numberOfLocales" , "Unknown" ) ; Vector vecLangs = new Vector ( ) ; if ( strNumOfLangs . equals ( "Unknown" ) ) { vecLangs . add ( new String [ ] { "US English" , "en_US" } ) ; } else { Integer intLangAmount = new Integer ( strNumOfLangs ) ; for ( int i = 1 ; i <= intLangAmount . intValue ( ) ; i ++ ) { vecLangs . add ( new String [ ] { mrbGui . getRBString ( "mars.locales." + i , "US English" ) , mrbGui . getRBString ( "mars.locales.code." + i , "en_US" ) } ) ; } } String savedLocale = new String ( pGui . get ( "mars.locale.lang" , "en" ) + "_" + pGui . get ( "mars.locale.country" , "US" ) ) ; ButtonGroup bgLocale = new ButtonGroup ( ) ; for ( int i = 0 ; i < vecLangs . size ( ) ; i ++ ) { String [ ] lang = ( String [ ] ) vecLangs . get ( i ) ; JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lang [ 0 ] , new ImageIcon ( "images/" + lang [ 1 ] + ".png" ) ) ; jrbMI . addActionListener ( new Prefs_Locale ( lang [ 1 ] ) ) ; if ( lang [ 1 ] . equals ( savedLocale ) ) { jrbMI . setSelected ( true ) ; } bgLocale . add ( jrbMI ) ; jmLocale . add ( jrbMI ) ; } String [ ] strLog = new String [ ] { "Severe" , "Warning" , "Info" , "Config" , "Fine" , "Finer" , "Finest" , "All" , "Off" } ; ButtonGroup bgLogs = new ButtonGroup ( ) ; for ( int i = 0 ; i < strLog . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( strLog [ i ] ) ; jrbMI . addActionListener ( new Prefs_Logging ( strLog [ i ] ) ) ; if ( pGui . get ( "mars.logLevel" , "All" ) . equals ( strLog [ i ] ) ) { jrbMI . setSelected ( true ) ; } bgLogs . add ( jrbMI ) ; jmLogging . add ( jrbMI ) ; } jmiXSDDir . addActionListener ( new Prefs_SetDir ( "XSD" , this ) ) ; jmiLogDir . addActionListener ( new Prefs_SetDir ( "Log" , this ) ) ; jmPrefs . add ( jmLnF ) ; jmPrefs . add ( jmLocale ) ; jmPrefs . add ( jmLogging ) ; jmPrefs . add ( jmiXSDDir ) ; jmPrefs . add ( jmiLogDir ) ; JMenu jmWindow = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.window" , "Window" ) ) ; JMenuItem jmiTile = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.tile" , "Tile All" ) ) ; JMenuItem jmiCascade = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.cascade" , "Cascade" ) ) ; JMenuItem jmiMinimise = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.minimise" , "Minimise" ) ) ; jmWindow . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.window.acc" , "w" ) ) . charAt ( 0 ) ) ; jmiTile . addActionListener ( new Window_Tile ( ) ) ; jmiCascade . addActionListener ( new Window_Cascade ( ) ) ; jmiMinimise . addActionListener ( new Window_Minimise ( ) ) ; jmWindow . add ( jmiTile ) ; jmWindow . add ( jmiCascade ) ; jmWindow . add ( jmiMinimise ) ; JMenu jmHelp = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.help" , "Help" ) ) ; JMenuItem jmiAbout = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.about" , "About" ) ) ; JMenuItem jmiLicense = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.license" , "License" ) ) ; jmHelp . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.help.acc" , "h" ) ) . charAt ( 0 ) ) ; jmiAbout . addActionListener ( new Help_About ( ) ) ; jmiLicense . addActionListener ( new Help_License ( ) ) ; jmHelp . add ( jmiAbout ) ; jmHelp . add ( jmiLicense ) ; jmbMenu . add ( jmFile ) ; jmbMenu . add ( jmView ) ; jmbMenu . add ( jmPrefs ) ; jmbMenu . add ( jmWindow ) ; jmbMenu . add ( jmHelp ) ; }
tr	3	@ Override public Storeable deserialize ( Table table , String value ) throws ParseException { JsonArray json = ( ( new JsonParser ( ) . parse ( value ) ) ) . getAsJsonArray ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int i = 0 ; i < json . size ( ) ; ++ i ) { values . add ( json . get ( i ) ) ; } Storeable storeable ; try { storeable = createFor ( table , values ) ; } catch ( IndexOutOfBoundsException e ) { throw new ParseException ( "Invalud number of arguments!" , 0 ) ; } catch ( ColumnFormatException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return storeable ; }
tr	9X	public static < K , T > Map < K , T > runIdempotentJobsWithRetries ( ExecutorService es , Map < K , ? extends Callable < T >> tasks , final int maxRounds , final IJobListener < K , T > jobListener ) { Map < K , T > out = new HashMap < K , T > ( ) ; Set < K > remainingTasks = new HashSet < K > ( tasks . keySet ( ) ) ; long round = 0 ; while ( remainingTasks . size ( ) > 0 && round ++ < maxRounds ) { List < K > keys = new LinkedList < K > ( remainingTasks ) ; Collections . shuffle ( keys ) ; Map < K , Future < T >> futures = new HashMap < K , Future < T >> ( ) ; for ( final K k : keys ) { final Callable < T > task = tasks . get ( k ) ; futures . put ( k , es . submit ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { try { T result = task . call ( ) ; if ( jobListener != null ) { jobListener . jobDone ( k , result ) ; } return result ; } catch ( Exception e ) { if ( jobListener != null ) { jobListener . jobException ( k , e ) ; } throw e ; } } } ) ) ; } Set < K > done = new HashSet < K > ( ) ; for ( K k : futures . keySet ( ) ) { try { T result = futures . get ( k ) . get ( ) ; out . put ( k , result ) ; done . add ( k ) ; } catch ( Exception e ) { logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } for ( K d : done ) { remainingTasks . remove ( d ) ; } } if ( remainingTasks . size ( ) > 0 ) { logger . warnf ( "% d tasks not completed" , remainingTasks . size ( ) ) ; } return out ; }
tr	7	public void run ( ) { final String methodName = "run" ; MqttWireMessage message = null ; while ( running && ( out != null ) ) { try { message = clientState . get ( ) ; if ( message != null ) { log . fine ( className , methodName , "802" , new Object [ ] { message . getKey ( ) , message } ) ; if ( message instanceof MqttAck ) { out . write ( message ) ; out . flush ( ) ; } else { MqttToken token = tokenStore . getToken ( message ) ; if ( token != null ) { synchronized ( token ) { out . write ( message ) ; out . flush ( ) ; clientState . notifySent ( message ) ; } } } } else { log . fine ( className , methodName , "803" ) ; running = false ; } } catch ( MqttException me ) { handleRunException ( message , me ) ; } catch ( Exception ex ) { handleRunException ( message , ex ) ; } } log . fine ( className , methodName , "805" ) ; }
tr	6	private void readPolar ( ) throws IOException { long currTime ; while ( isRead ) { currTime = System . currentTimeMillis ( ) ; int msg = inputStream . read ( ) ; if ( msg == 254 ) { printMessage ( "\n" + System . currentTimeMillis ( ) + ": " ) ; polarMessageTmp = new PolarMessage ( System . currentTimeMillis ( ) ) ; } else if ( msg == - 1 ) { System . out . println ( "Roz\u0142\u0105czono" ) ; stopRead ( ) ; break ; } else if ( polarMessageTmp != null && polarMessageTmp . setNextValue ( msg ) ) { message = new PolarMessage ( System . currentTimeMillis ( ) ) ; message . setHr ( polarMessageTmp . getHr ( ) ) ; } if ( currTime - System . currentTimeMillis ( ) > 3000 ) { System . out . println ( "Zbyt d\u0142ugi czas oczekiwania" ) ; } printMessage ( " " + msg ) ; } }
tr	1	public int getMaxQuantity ( int quantity ) { if ( currentQuantity + quantity > maxQuantity ) { throw new StoreProblemException ( ) ; } return currentQuantity + quantity ; }
tr	6	public static String truncateWhenUTF8 ( final String s , final int maxBytes ) { int b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charAt ( i ) ; int skip = 0 ; int more ; if ( c <= 007f ) { more = 1 ; } else if ( c <= 07FF ) { more = 2 ; } else if ( c <= d7ff ) { more = 3 ; } else if ( c <= DFFF ) { more = 4 ; skip = 1 ; } else { more = 3 ; } if ( b + more > maxBytes ) { return s . substring ( 0 , i ) ; } b += more ; i += skip ; } return s ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
tr	9X	@ SuppressWarnings ( "SimplifiableIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitLog gitLog = ( GitLog ) o ; if ( gitPath != null ? ! gitPath . equals ( gitLog . gitPath ) : gitLog . gitPath != null ) return false ; if ( folder != null ? ! folder . equals ( gitLog . folder ) : gitLog . folder != null ) return false ; if ( timeRange != null ? ! timeRange . equals ( gitLog . timeRange ) : gitLog . timeRange != null ) return false ; if ( commandLine != null ? ! commandLine . equals ( gitLog . commandLine ) : gitLog . commandLine != null ) return false ; return externalSubCommands != null ? externalSubCommands . equals ( gitLog . externalSubCommands ) : gitLog . externalSubCommands == null ; }
tr	3	static Header fromString ( String stringHeader ) throws MalformedRequestException { String [ ] parts = stringHeader . split ( ": " ) ; if ( parts . length != 2 ) { throw new MalformedRequestException ( "unknown format of Header [" + stringHeader + "]" ) ; } for ( HTTPHeader m : HTTPHeader . values ( ) ) { if ( stringHeader . startsWith ( m . headerText ) ) { return new Header ( m , parts [ 1 ] ) ; } } return new Header ( HTTPHeader . UnknownHeader , parts [ 1 ] ) ; }
tr	1	public long getTimeRunning ( class < ? extends Event > type ) { return this . timeRunning . get ( type ) ; }
tr	4	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	3	public EnterTeams ( MainGUI gui ) { initComponents ( ) ; this . gui = gui ; GraphicsEnvironment g = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = g . getScreenDevices ( ) ; int width = devices [ 0 ] . getDisplayMode ( ) . getWidth ( ) ; int height = devices [ 0 ] . getDisplayMode ( ) . getHeight ( ) ; int w = this . getSize ( ) . width ; int h = this . getSize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setLocation ( x , y ) ; numberOfMatchesField . setValue ( 1 ) ; matchField . setValue ( 1 ) ; saveMatchesButton . setEnabled ( false ) ; teamArray = new JTextField [ 6 ] ; teamArray [ 0 ] = redAllianceTeam1 ; teamArray [ 1 ] = redAllianceTeam2 ; teamArray [ 2 ] = redAllianceTeam3 ; teamArray [ 3 ] = blueAllianceTeam1 ; teamArray [ 4 ] = blueAllianceTeam2 ; teamArray [ 5 ] = blueAllianceTeam3 ; if ( ! "" . equals ( Competition . getCompetitionName ( ) ) || Competition . getCompetitionName ( ) != null ) { competitionNameField . setText ( Competition . getCompetitionName ( ) ) ; } if ( Competition . getNumberOfMatches ( ) != 0 ) { numberOfMatchesField . setValue ( Competition . getNumberOfMatches ( ) ) ; } DynamicArray teams = new DynamicArray ( 20 ) ; }
tr	0	public Response delete ( String url , boolean authenticated ) throws WeiboException { return httpRequest ( url , null , authenticated , "DELETE" ) ; }
tr	4	@ Override protected void paintComponent ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; g2d . setColor ( Color . BLACK ) ; g2d . setStroke ( new BasicStroke ( 2 ) ) ; for ( int i = 0 ; i <= World . SIZE ; i ++ ) { Line2D hline = new Line2D . double ( 0 , i * GRID_SIZE , 600 , i * GRID_SIZE ) ; Line2D vline = new Line2D . double ( i * GRID_SIZE , 0 , i * GRID_SIZE , 600 ) ; g2d . draw ( hline ) ; g2d . draw ( vline ) ; } for ( Point fuel : world . getAvailableFuel ( ) ) { int x = fuel . x * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getWidth ( ) / 2 ; int y = fuel . y * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getHeight ( ) / 2 ; g2d . drawImage ( fuelImage , x , y , null ) ; } for ( int i = 1 ; i <= 2 ; i ++ ) { Robot rob ; if ( ( rob = world . getRobot ( i ) ) != null ) rob . draw ( g2d , getTimeRatio ( ) ) ; } }
tr	0	public static void resetTestVars ( ) { calledMakePixel = false ; makePixelR = - 1 ; makePixelG = - 1 ; makePixelB = - 1 ; }
tr	9X	private Map < String , List < String >> decodeParams ( String s ) { Map < String , List < String >> params = new LinkedHashMap < String , List < String >> ( ) ; String name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addParam ( params , name , "" ) ; } return params ; }
tr	4	private void valider ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { boolean select = true ; int selectionCorrige = 0 ; int selection = tableau . getSelectedRow ( ) ; try { selectionCorrige = listeAchats . getTableau ( ) . getRowSorter ( ) . convertRowIndexToModel ( selection ) ; } catch ( Exception e ) { select = false ; JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "error_no_ticket_selected" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } if ( select ) { try { Achat achat = ( Achat ) listeAchats . getObjetByIndex ( selectionCorrige ) ; if ( ! achat . getPaye ( ) ) { achat . setPayer ( true ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "ticket_already_paid" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( Exception e1 ) { Constantes . afficherException ( e1 ) ; } } } } ) ; }
tr	2	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
tr	7	@ Override public void itemStateChanged ( ItemEvent e ) { Object source = e . getSource ( ) ; if ( source == m_add ) { m_tensorPanel . setTypeChangeEnabled ( true ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_INITIAL_PICK ) ; System . out . println ( "click into the display to add a feature" ) ; } else if ( source == m_remove ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to remove it" ) ; } else if ( source == m_select ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to select it" ) ; } else if ( source == m_flowReflect ) { updateVectorField ( ) ; } else if ( source == m_showSeparatrices ) { if ( m_showSeparatrices . getState ( ) ) { m_disp . addGeometry ( m_separatrices ) ; } else { m_disp . removeGeometry ( m_separatrices ) ; } m_disp . update ( m_separatrices ) ; } else if ( source == m_direction ) { updateVectorField ( ) ; } else { assert false : "Unhandled item changed: " + source ; } }
tr	9X	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ 2000000 ] ; for ( int i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; int a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primeList . add ( a ) ; break ; } } long sum = 0 ; for ( int i = 0 ; i < primeList . size ( ) - 1 ; i ++ ) sum += lowestMultiple ( primeList . get ( i ) , primeList . get ( i + 1 ) ) ; System . out . println ( sum ) ; }
tr	0	public final void testGetName ( ) { Player player = new Player ( "Fred" ) ; assert . assertEquals ( player . getName ( ) , "Fred" ) ; }
tr	0	public String getDate ( ) { return date ; }
tr	9X	private Objective loadObjective ( TagCompound tag ) { try { TagBase tbname = tag . getTag ( "name" ) ; if ( ! ( tbname instanceof TagString ) ) return null ; TagBase tbtarget = tag . getTag ( "target" ) ; if ( ! ( tbtarget instanceof TagString ) ) return null ; TagBase tbtypes = tag . getTag ( "type" ) ; if ( ! ( tbtypes instanceof TagString ) ) return null ; ObjectiveType t = QuestManager . getInstance ( ) . getRegisteredObjectiveType ( ( ( TagString ) tbtypes ) . data ) ; if ( t == null ) return null ; Objective o = new Objective ( tag . getName ( ) , ( ( TagString ) tbname ) . data , t , ( ( TagString ) tbtarget ) . data ) ; TagBase tbicoid = tag . getTag ( "iconid" ) ; if ( tbicoid instanceof TagInt ) o . setItemIconId ( ( ( TagInt ) tbicoid ) . data ) ; TagBase tbopt = tag . getTag ( "optional" ) ; if ( tbopt instanceof TagByte ) o . setOptional ( ( ( TagByte ) tbopt ) . data == 1 ) ; TagBase tbvis = tag . getTag ( "visible" ) ; if ( tbvis instanceof TagByte ) o . setVisible ( ( ( TagByte ) tbvis ) . data == 1 ) ; TagBase rewards = tag . getTag ( "rewards" ) ; if ( rewards instanceof TagList ) { for ( TagBase b : ( ( TagList ) rewards ) . get ( ) ) { if ( b instanceof TagCompound ) { QuestAction a = loadAction ( ( TagCompound ) b ) ; if ( a != null ) o . addReward ( a ) ; } } } TagBase desc = tag . getTag ( "description" ) ; ArrayList < String > dsc = new ArrayList < String > ( ) ; if ( desc instanceof TagList ) { for ( TagBase b : ( ( TagList ) desc ) . get ( ) ) { if ( b instanceof TagString ) { dsc . add ( ( ( TagString ) b ) . data ) ; } } } o . setDescription ( dsc ) ; return o ; } catch ( IllegalArgumentException iae ) { return null ; } }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	7	public static QuestionCalculation decode ( String encodedQuestionCalculation ) throws DecodeException { QuestionCalculation res ; if ( encodedQuestionCalculation . substring ( 0 , 19 ) . compareTo ( "#QuestionCalculaion" ) == 0 ) { res = new QuestionCalculation ( ) ; int i = 19 ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Integer > tmp_opd = decodeOperands ( encodedQuestionCalculation . substring ( 20 , i ) ) ; res . setOperands ( tmp_opd ) ; i ++ ; int beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Character > tmp_opt = decodeOperators ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_opt . size ( ) == tmp_opt . size ( ) + 1 : "incorrect size of operators table" ; res . setOperators ( tmp_opt ) ; i ++ ; beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } int tmp_lth = Integer . valueOf ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_lth < 0 : "negative length" ; res . setLength ( tmp_lth ) ; i ++ ; encodedQuestionCalculation = encodedQuestionCalculation . substring ( i ) ; Question . decode ( res , encodedQuestionCalculation ) ; } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	1	@ Override public boolean equals ( Object other ) { if ( other instanceof NewId ) { return this . equals ( ( NewId ) other ) ; } return false ; }
tr	3	public static void resetVersion ( ) { DataOutputStream dos = null ; try { File dir = new File ( getWorkingDirectory ( ) + File . separator + "bin" + File . separator ) ; File versionFile = new File ( dir , "version" ) ; dos = new DataOutputStream ( new FileOutputStream ( versionFile ) ) ; dos . writeUTF ( "0" ) ; dos . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { try { dos . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	3	public void registerNamedComponent ( Component component ) { if ( component . getName ( ) == null || "" . equals ( component . getName ( ) ) ) { throw new IllegalArgumentException ( "Component name must be set if it's going to be registered." ) ; } if ( namedComponents . containsKey ( component . getName ( ) ) ) { } namedComponents . put ( component . getName ( ) , component ) ; }
tr	5	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { System . out . println ( "Please enter 3 numbers" ) ; int first = sc . nextInt ( ) ; int second = sc . nextInt ( ) ; int third = sc . nextInt ( ) ; if ( first == 0 && second == 0 && third == 0 ) { break ; } if ( ( first + second + third ) % 3 == 0 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } } }
tr	6	private void returnStatement_rest ( ) throws Exception { Instruction r = null ; if ( scan . sym == Token . ident || scan . sym == Token . num || scan . sym == Token . openparen || scan . sym == Token . call ) { if ( inMain ) { throw new Exception ( "Attempt to return value from __MAIN__" ) ; } r = new Ret ( expression ( ) ) ; } else { r = inMain ? new End ( ) : new Ret ( ) ; } currentBB . addInstruction ( r ) ; }
tr	9X	public static Integer getIntegerFromSubString ( String target , String prefix , String suffix ) { if ( target == null ) return null ; Integer retVal = null ; try { String tmp = target ; if ( prefix != null && target . contains ( prefix ) ) { int sz = prefix . length ( ) ; int in = target . indexOf ( prefix ) ; tmp = target . substring ( in + sz ) ; } if ( tmp != null && suffix != null && target . contains ( suffix ) ) { int suf = tmp . indexOf ( suffix ) ; if ( suf <= 0 && suffix . equals ( " " ) ) suf = tmp . length ( ) ; tmp = tmp . substring ( 0 , suf ) ; retVal = IntUtils . getIntegerFromString ( tmp . trim ( ) ) ; } } catch ( Exception e ) { LOGGER . log ( Level . INFO , "Not a big deal that we couldn't find an int from substring...going to return null" , e ) ; retVal = null ; } return retVal ; }
tr	9X	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } MarketData currBar = this . bidTs . get ( i ) ; MarketData prevBar = this . bidTs . get ( i - 1 ) ; if ( ! order . HasPosition ( product ) ) { state = 0 ; } double currBody = currBar . getClose ( ) - currBar . getOpen ( ) ; double prevBody = prevBar . getClose ( ) - prevBar . getOpen ( ) ; double point = CurrencyTable . getPoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevBody > 0 && currBody < 0 ; boolean cond2 = currBar . getOpen ( ) >= prevBar . getClose ( ) ; boolean cond3 = currBar . getClose ( ) <= prevBar . getOpen ( ) ; boolean cond4 = currBody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bidTs . get ( i ) . getClose ( ) ; order . MarketSell ( product , entryTime , entryPrice , 2 ) ; this . stopPrice = prevBar . getClose ( ) + 100 * point ; this . r = this . stopPrice - this . entryPrice ; this . takeProfit = this . entryPrice - r ; order . StopBuy ( product , entryTime , this . stopPrice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { order . MarketBuy ( product , currBar . getStart ( ) , this . takeProfit , 1 ) ; order . CancelAllPendingOrders ( product ) ; this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . CancelAllPendingOrders ( product ) ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; } } }
tr	2	@ Override public Validator < AbstractConverter > getValidator ( ) { return new Validator < AbstractConverter > ( ) { @ Override public Set < ConstraintViolation > validate ( AbstractConverter item ) { Set < ConstraintViolation > constraints = new HashSet < ConstraintViolation > ( ) ; Map < String , ConverterParameter > params = item . getParametersMap ( ) ; ConverterParameter param = params . get ( "colFileSizeInBytes" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the column with filesize in bytes data" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "colFileSizeConvert" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the output column" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } return constraints ; } } ; }
tr	8	public static Highscore [ ] load ( InputStream in ) throws IOException { Vector highscores = new Vector ( 20 , 40 ) ; InputStreamReader inr = new InputStreamReader ( in ) ; String line ; while ( ( line = jgame . impl . EngineLogic . readline ( inr ) ) != null ) { Vector fields = new Vector ( 5 , 10 ) ; Vector tokens = jgame . impl . EngineLogic . tokenizeString ( line , 	 ) ; for ( Enumeration e = tokens . elements ( ) ; e . hasMoreElements ( ) ; ) { String tok = ( String ) e . nextElement ( ) ; if ( tok . equals ( "`" ) ) tok = "" ; fields . addElement ( tok ) ; } Highscore hs = null ; if ( fields . size ( ) == 1 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , "" ) ; } if ( fields . size ( ) >= 2 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , ( String ) fields . elementAt ( 1 ) ) ; } if ( fields . size ( ) >= 3 ) { hs . fields = new String [ fields . size ( ) - 2 ] ; for ( int i = 2 ; i < fields . size ( ) ; i ++ ) { hs . fields [ i - 2 ] = ( String ) fields . elementAt ( i ) ; } } highscores . addElement ( hs ) ; } Highscore [ ] ret = new Highscore [ highscores . size ( ) ] ; for ( int i = 0 ; i < highscores . size ( ) ; i ++ ) { ret [ i ] = ( Highscore ) highscores . elementAt ( i ) ; } return ret ; }
tr	4	public Identifier BookBed ( Identifier userId , Identifier searchId ) { ArrayList < SearchBean < FreeBedDetailBean >> results = getLastSearchResult ( ) ; for ( SearchBean < FreeBedDetailBean > search : results ) { if ( search . getSearchId ( ) . equals ( searchId ) ) { FreeBedDetailBean bedDetail = search . getObjectInfo ( ) ; Identifier hostelId = search . getObjectId ( ) ; Booking booking = new Booking ( ) ; booking . setBedIds ( bedDetail . getBedIds ( ) ) ; ArrayList < Tariff > bedReservations = new ArrayList < Tariff > ( ) ; for ( int i = 0 ; i < booking . getBedIds ( ) . size ( ) ; i ++ ) { Tariff tariff = new Tariff ( bedDetail . getPrice ( ) . get ( i ) , bedDetail . getCheckIn ( ) , bedDetail . getCheckOut ( ) ) ; bedReservations . add ( tariff ) ; } booking . setBedReservations ( bedReservations ) ; booking . setBookingDate ( GenericUtility . getCurrentDateWithoutTime ( ) ) ; booking . setHostelId ( hostelId ) ; booking . setStatus ( BookingStatus . RESERVED ) ; booking . setUserId ( userId ) ; try { return Bookings . getInstance ( ) . create ( booking ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidIdentifierException | InvalidParameterException | ConflictException | IdentifierNotFoundException e ) { } } } return null ; }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	7	@ Override public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] == true ) s = s . concat ( "1" ) ; else s = s . concat ( "0" ) ; if ( i == 5 || i == 10 || i == 15 || i == 20 || i == 25 ) s = s . concat ( " " ) ; } return s ; }
tr	7	public String queryAllOrder ( Order order , Pagination pagination , HttpServletRequest request ) throws ServiceException { if ( pagination == null ) { pagination = new Pagination ( ) ; } Map < String , Object > queryMap = new HashMap < String , Object > ( ) ; queryMap . put ( "order" , order ) ; int count = 0 ; try { count = orderDaoImpl . count ( queryMap , SqlConstants . ORDER_COUNT ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } if ( count == 0 ) { logger . info ( OtherConstants . HAVE_NO_ORDER ) ; return OtherConstants . HAVE_NO_ORDER ; } pagination . setCount ( count ) ; queryMap . put ( OtherConstants . START_ROW , pagination . getStartRow ( ) ) ; queryMap . put ( OtherConstants . END_ROW , pagination . getEndRow ( ) ) ; List < Order > orders = new ArrayList < Order > ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = orderDaoImpl . query ( queryMap , SqlConstants . ORDER_QUERY ) ; for ( Object object : list ) { Order o = ( Order ) object ; String userID = o . getUserID ( ) ; User user = ( User ) userDaoImpl . find ( userID , SqlConstants . USER_FIND_BY_ID ) ; if ( user != null ) { o . setLoginName ( user . getLoginName ( ) ) ; } @ SuppressWarnings ( "rawtypes" ) List list2 = detailDaoImpl . query ( o , SqlConstants . DETAIL_QUERY_BY_ORDERID ) ; List < Detail > details = new ArrayList < Detail > ( ) ; for ( Object object2 : list2 ) { Detail detail = ( Detail ) object2 ; Price price = ( Price ) orderingDaoImpl . find ( detail . getPriceID ( ) , SqlConstants . PRICE_FIND_BY_ID ) ; price . setDicName ( detail . getDicName ( ) ) ; detail . setPrice ( price ) ; details . add ( detail ) ; } o . setDetails ( details ) ; orders . add ( o ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } request . setAttribute ( OtherConstants . CURRENT_ORDER_LIST , orders ) ; request . setAttribute ( OtherConstants . PAGE_INFO , pagination ) ; return null ; }
tr	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ProcedureHeadingNode that = ( ProcedureHeadingNode ) o ; if ( fparams != null ? ! fparams . equals ( that . fparams ) : that . fparams != null ) return false ; if ( subject != null ? ! subject . equals ( that . subject ) : that . subject != null ) return false ; return true ; }
tr	6	public Vector < Vector < Object >> getFolderContentsTable ( ) { Vector < Vector < Object >> tableData = new Vector < > ( ) ; List < FileInfo > files = getFolderContents ( ) ; logger . debug ( "Found " + files . size ( ) + " entries for " + path . toString ( ) ) ; for ( FileInfo file : files ) { Vector < Object > row = null ; if ( file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/folder.png" ) ) ; } else { row . add ( new ImageIcon ( "res/folder_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } for ( FileInfo file : files ) { Vector < Object > row = null ; if ( ! file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/file.png" ) ) ; } else { row . add ( new ImageIcon ( "res/file_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } return tableData ; }
tr	3	public static Texture [ ] [ ] replaceColors ( Texture [ ] [ ] textures , int [ ] fromColors , int [ ] toColors ) { if ( textures . length == 0 ) return null ; Texture [ ] [ ] newTextures = new Texture [ textures . length ] [ textures [ 1 ] . length ] ; for ( int i = 0 ; i < textures . length ; i ++ ) for ( int j = 0 ; j < textures [ 1 ] . length ; j ++ ) newTextures [ i ] [ j ] = textures [ i ] [ j ] . replaceColors ( fromColors , toColors ) ; return newTextures ; }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	6	protected final Object computeRange ( ) { final List < double [ ] > raRange = new ArrayList < double [ ] > ( ) ; final double [ ] decRange = new double [ 2 ] ; if ( this . isPolesCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isNorthPoleCollision ( ) ) { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isSouthPoleCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; if ( this . isBorderRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMaxRaCollision ( ) ) { raRange . add ( new double [ ] { raUser - sizeArray [ 0 ] / 2.0 , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMinRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , raUser + sizeArray [ 0 ] / 2.0 } ) ; raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } } return Arrays . asList ( raRange , decRange ) ; }
tr	5	private long checkClientTimeouts ( int timeout ) { Set < Integer > disconnectedClientIds = new HashSet < Integer > ( ) ; long oldestClientCommunicationTime = - 1 ; synchronized ( CONNECTION_LOCK ) { if ( ! isRunning ) return - 1 ; long now = System . currentTimeMillis ( ) ; oldestClientCommunicationTime = now ; for ( Iterator < Integer > iter = clients . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { int clientId = iter . next ( ) ; ClientInfo client = clients . get ( clientId ) ; if ( client . getTimeOfLastCommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedClientIds . add ( clientId ) ; } else if ( client . getTimeOfLastCommunication ( ) < oldestClientCommunicationTime ) oldestClientCommunicationTime = client . getTimeOfLastCommunication ( ) ; } } for ( int clientId : disconnectedClientIds ) { logger . fine ( "Client " + clientId + " timed out" ) ; onClientDisconnected ( clientId , Server . CLIENT_TIMED_OUT ) ; } return oldestClientCommunicationTime ; }
tr	7	private void ulozitActionPerformed ( java . awt . event . ActionEvent evt ) { PanelRegistraceTymu fr = PanelRegistraceTymu . this ; EntityManager em = DBTools . getInstance ( ) . getEm ( ) ; EntityTransaction tx = DBTools . getInstance ( ) . getTx ( ) ; System . out . println ( "" ) ; System . out . println ( "ULOZIT" ) ; System . out . println ( "" ) ; String sql = "select * from kategorie where nazev=?" ; Query query = DBTools . getInstance ( ) . getEm ( ) . createNativeQuery ( sql , Kategorie . class ) ; query . setParameter ( 1 , fr . kategorieCombo . getSelectedItem ( ) . toString ( ) ) ; Kategorie kat = ( Kategorie ) query . getSingleResult ( ) ; tx . begin ( ) ; Tym tym = Tym . createTym ( fr . JmenoTymuField . getText ( ) , kat ) ; em . persist ( tym ) ; tx . commit ( ) ; tym = em . find ( Tym . class , tym . getTym_id ( ) ) ; System . out . println ( tym ) ; tx . begin ( ) ; TableModel jtm = fr . jezdecTable . getModel ( ) ; for ( int i = 0 ; i < jtm . getRowCount ( ) ; i ++ ) { long val = ( long ) jtm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyl vybran jezdec!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; tho . setJe_jezdec ( true ) ; em . persist ( tho ) ; } } TableModel ptm = fr . prisediciTable . getModel ( ) ; for ( int i = 0 ; i < ptm . getRowCount ( ) ; i ++ ) { long val = ( long ) ptm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni prisedici!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; em . persist ( tho ) ; } } TableModel ktm = fr . koneTable . getModel ( ) ; for ( int i = 0 ; i < ktm . getRowCount ( ) ; i ++ ) { long val = ( long ) ktm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni kone!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Kun k = em . find ( Kun . class , val ) ; System . out . println ( k ) ; TymyHasKone thk = TymyHasKone . createTymMaKone ( tym . getTym_id ( ) , k . getKun_id ( ) ) ; em . persist ( thk ) ; } } try { tx . commit ( ) ; tx . begin ( ) ; tym . setZavodId ( em . find ( Zavody . class , 1 ) ) ; em . persist ( tym ) ; tx . commit ( ) ; dispose ( ) ; } catch ( RollbackException e ) { System . out . println ( "ERROR -> rollback" ) ; JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Do\u0161lo k chyb\u011B: " + e . getMessage ( ) , "Chyba" , JOptionPane . ERROR_MESSAGE ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; } }
tr	3	public static boolean hasSubmitParameter ( ServletRequest request , String name ) { assert . notNull ( request , "Request must not be null" ) ; if ( request . getParameter ( name ) != null ) { return true ; } for ( String suffix : SUBMIT_IMAGE_SUFFIXES ) { if ( request . getParameter ( name + suffix ) != null ) { return true ; } } return false ; }
tr	5	public void inst_main ( String args [ ] ) { int iterations = 1000 ; String options = "" ; if ( args != null && args . length > 0 ) iterations = Integer . parseInt ( args [ 0 ] ) ; if ( args != null && args . length > 1 ) options = args [ 1 ] ; long startTime = System . currentTimeMillis ( ) ; for ( int j = 0 ; j < iterations ; ++ j ) { chainTest ( 100 ) ; projectionTest ( 100 ) ; } long endTime = System . currentTimeMillis ( ) ; total_ms = endTime - startTime ; System . out . println ( "DeltaBlue\tJava\t" + options + "\t" + iterations + "x\t" + ( ( double ) total_ms / iterations ) + " ms" ) ; }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	2	public void loadExtension ( class < ? > cls ) { try { enableExtension ( this . instantiateExtension ( cls ) ) ; } catch ( ExtensionException e ) { MinePing . staticlogger . log ( Level . SEVERE , "Failed to load Extension: " + e ) ; } }
tr	2	@ Override public void action ( RuleContext _localctx , int ruleIndex , int actionIndex ) { switch ( ruleIndex ) { case 34 : WS_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; case 37 : COMMENTLIN_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; } }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	0	private byte [ ] toBytes ( String s ) { return s . getBytes ( ) ; }
tr	3	public DeliverType getDeliverTypeById ( long deliverTypeId ) { Session session = null ; DeliverType deliverType = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; deliverType = ( DeliverType ) session . load ( DeliverType . class , deliverTypeId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return deliverType ; }
tr	2	public static boolean isPrime ( int checkNumber ) { double root = Math . sqrt ( checkNumber ) ; for ( int i = 2 ; i <= root ; i ++ ) { if ( checkNumber % i == 0 ) { return false ; } } return true ; }
tr	7	static public Automaton concatenate ( Automaton a1 , Automaton a2 ) { if ( a1 . isSingleton ( ) && a2 . isSingleton ( ) ) return BasicAutomata . makeString ( a1 . singleton + a2 . singleton ) ; if ( isEmpty ( a1 ) || isEmpty ( a2 ) ) return BasicAutomata . makeEmpty ( ) ; boolean deterministic = a1 . isSingleton ( ) && a2 . isDeterministic ( ) ; if ( a1 == a2 ) { a1 = a1 . cloneExpanded ( ) ; a2 = a2 . cloneExpanded ( ) ; } else { a1 = a1 . cloneExpandedIfRequired ( ) ; a2 = a2 . cloneExpandedIfRequired ( ) ; } for ( State s : a1 . getAcceptStates ( ) ) { s . accept = false ; s . addEpsilon ( a2 . initial ) ; } a1 . deterministic = deterministic ; a1 . clearHashCode ( ) ; a1 . checkMinimizeAlways ( ) ; return a1 ; }
tr	3	public Coordinate getCoordinates ( ) { if ( lat != null && lon != null ) { return new Coordinate ( lon , lat ) ; } else if ( grid != null ) { return LocatorUtil . loc2degminsec ( grid ) ; } else { return null ; } }
tr	2	public void registerProcessor ( OspreyProcessor < ? > processor ) { if ( null != processors . putIfAbsent ( processor . interest ( ) , processor ) ) { LOGGER . warn ( "Register Processor[" + processor . interest ( ) + "  " + processor + "]." , new Exception ( ) ) ; } }
tr	7	private static void test8 ( ) throws FileNotFoundException { String input = "new\n" + "pick up cell key\n" + "unlock cell door with cell key\n" + "quit\n" + "y\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( input . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( 13 , "The guard walks toward your cell." ) ; output . put ( 14 , ">> You unlock the cell door." ) ; output . put ( 15 , "The guard peers into the cell  checking that the door is secured." ) ; output . put ( 16 , "The door swings open." ) ; output . put ( 17 , "You have been caught." ) ; output . put ( 18 , "YOU LOSE!" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test8 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test8 passed" ) ; } } else { System . out . println ( "test8 failed: error" ) ; } } }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	7	private String getDayOfWeek ( int d ) { switch ( d ) { case Calendar . MONDAY : return "lunes" ; case Calendar . TUESDAY : return "martes" ; case Calendar . WEDNESDAY : return "mi\u00E9rcoles" ; case Calendar . THURSDAY : return "jueves" ; case Calendar . FRIDAY : return "viernes" ; case Calendar . SATURDAY : return "sabado" ; case Calendar . SUNDAY : return "domingo" ; } return "ERROR" ; }
tr	5	public void clicked ( Vec2f gamePosition ) { Vec2i mapPosition = new Vec2i ( ( int ) ( gamePosition . x / SQUARE_SIZE ) , ( int ) ( gamePosition . y / SQUARE_SIZE ) ) ; if ( isPlayerUnit ( mapPosition ) ) { Unit unit = units . get ( mapPosition ) ; unit . select ( ) ; if ( selected != null && ! selected . equals ( unit ) ) { selected . unselect ( ) ; } selected = unit ; } else { if ( selected != null && isPassable ( mapPosition ) ) { getPathTo ( selected , mapPosition ) ; } } }
tr	6	public List < double > classifyInstance ( Datum attributesDatum ) { List < double > attributesList = attributesDatum . getAttributes ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Input ) ; i ++ ) { neuralMap . get ( NetworkLevel . Input ) . get ( i ) . setNodeValue ( attributesList . get ( i ) ) ; } for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; i ++ ) { double totalHiddenInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Input ) ; j ++ ) { double inputNodeValue = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getNodeValue ( ) ; double inputNodeWeight = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getOutputWeightAt ( i ) ; totalHiddenInput += inputNodeValue * inputNodeWeight ; } totalHiddenInput += biasNode . getOutputWeightAt ( i ) * biasNode . getNodeValue ( ) ; double hiddenNodeValue = 1.0 / ( 1 + Math . pow ( Math . E , - totalHiddenInput ) ) ; neuralMap . get ( NetworkLevel . Hidden ) . get ( i ) . setNodeValue ( hiddenNodeValue ) ; } ArrayList < double > intermediateValues = new ArrayList < double > ( ) ; double simpleTotal = 0 ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double totalOutputInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; j ++ ) { double hiddenNodeValue = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getNodeValue ( ) ; double hiddenNodeWeight = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getOutputWeightAt ( i ) ; totalOutputInput += hiddenNodeValue * hiddenNodeWeight ; } totalOutputInput += biasNode . getOutputWeightAt ( i + nodeLevelNumber . get ( NetworkLevel . Hidden ) ) * biasNode . getNodeValue ( ) ; intermediateValues . add ( totalOutputInput ) ; simpleTotal += Math . pow ( Math . E , totalOutputInput ) ; } ArrayList < double > finalValues = new ArrayList < double > ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double trueOutputValue ; trueOutputValue = Math . pow ( Math . E , intermediateValues . get ( i ) ) / simpleTotal ; neuralMap . get ( NetworkLevel . Output ) . get ( i ) . setNodeValue ( trueOutputValue ) ; finalValues . add ( trueOutputValue ) ; } return finalValues ; }
tr	5	public void runScript ( InputStream stream ) throws JStrykerException , IllegalArgumentException { if ( stream == null ) { throw new IllegalArgumentException ( "Stream cannot be null." ) ; } try { List < String > commands = parse ( stream ) ; for ( String command : commands ) { Statement statement = null ; try { statement = connection . createStatement ( ) ; statement . execute ( command . toString ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( SQLException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	3	public NotebookJTableModel ( NotebookDao dbSource , String query ) { if ( dbSource == null ) { throw new IllegalArgumentException ( "Notebook table model ben\u00F6tigt eine Datenbankquelle != null" ) ; } this . dbSource = dbSource ; if ( query == null || query . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Notebook table model query String darf nicht null oder leer sein!" ) ; } this . query = query ; this . getDBContents ( ) ; }
tr	5	public static Platform getPlatform ( String platform ) { if ( isLinux ( platform ) ) { return LINUX ; } else if ( isWindows ( platform ) ) { return WINDOWS ; } else if ( isSolaris ( platform ) ) { return OPENSOLARIS ; } else if ( isFreeBSD ( platform ) ) { return FREEBSD ; } else if ( isMac ( platform ) ) { return MAC ; } return null ; }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	7	@ Override public boolean done ( ArrayList < Node > nw , int fab ) { int a = ( ( BeaconFAB ) nw . get ( 0 ) . getFAB ( fab ) ) . A ; Set < Integer > armies = new HashSet < Integer > ( ) ; int min = Integer . MAX_VALUE ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( Node N : nw ) { armies . add ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A ) ; sw = ( ( BeaconFAB ) N . getFAB ( fab ) ) . D ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A != a ) { res = false ; } } return res ; }
tr	9X	public static AbstractUIItem createItem ( FeatureType t , Panel panel ) { switch ( t ) { case Constant : return new ConstantUIItem ( panel ) ; case Sink : return new SinkUIItem ( panel ) ; case Source : return new SourceUIItem ( panel ) ; case Saddle : return new SaddleUIItem ( panel ) ; case Center : return new CenterUIItem ( panel ) ; case Focus : return new FocusUIItem ( panel ) ; case ConvergingElement : return new ConvergingElementUIItem ( panel ) ; case DivergingElement : return new DivergingElementUIItem ( panel ) ; case Generic : return new GenericUIItem ( panel ) ; } assert false : "Unhandled type: " + t ; return null ; }
tr	2	@ Override public int compareTo ( Match o ) { if ( this . gameStartMs > o . gameStartMs ) return 1 ; else if ( this . gameStartMs < o . gameStartMs ) return - 1 ; return 0 ; }
tr	9X	private String getSelect ( List < String > tables , Map < String , Object > params ) { if ( tables . size ( ) < 1 ) { return "ERROR: The tables list is empty" ; } StringBuffer sql = new StringBuffer ( ) ; sql . append ( "SELECT " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } sql . append ( " FROM " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table ) ; sql . append ( " " ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } if ( params . isEmpty ( ) ) { return sql . toString ( ) ; } sql . append ( " WHERE " ) ; int i = 0 ; for ( String paramName : params . keySet ( ) ) { Object paramValue = params . get ( paramName ) ; sql . append ( paramName ) ; sql . append ( "=" ) ; if ( paramValue instanceof java . sql . Date ) { sql . append ( "'" ) ; sql . append ( paramValue ) ; sql . append ( "'" ) ; } else if ( paramValue instanceof String ) { sql . append ( "\"" ) ; sql . append ( paramValue ) ; sql . append ( "\"" ) ; } else { sql . append ( paramValue ) ; } if ( i < params . size ( ) - 1 ) { sql . append ( " AND " ) ; } i ++ ; } return sql . toString ( ) ; }
tr	4	public String hash ( ) { if ( this . lshCode != null ) { return this . lshCode ; } if ( ! this . lshCodeValid ) { return null ; } LshBinStruct tmp = new LshBinStruct ( ) ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { tmp . checksum [ k ] = swapByte ( this . lshBin . checksum [ k ] ) ; } tmp . lValue = swapByte ( this . lshBin . lValue ) ; tmp . Q = swapByte ( this . lshBin . Q ) ; for ( int i = 0 ; i < CODE_SIZE ; i ++ ) { tmp . tmpCode [ i ] = this . lshBin . tmpCode [ CODE_SIZE - 1 - i ] ; } this . lshCode = toHex ( tmp . checksum ) ; this . lshCode += toHex ( new int [ ] { tmp . lValue } ) ; this . lshCode += toHex ( new int [ ] { tmp . Q } ) ; this . lshCode += toHex ( tmp . tmpCode ) ; return this . lshCode ; }
tr	6	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	0	public static List < Integer > commonDivisors ( final int a , final int b ) { notZeroCheck ( a ) ; notZeroCheck ( b ) ; return listIntersection ( divisors ( a ) , divisors ( b ) ) ; }
tr	0	public TasquesPendents ( String any , IClient client ) { this . client = client ; this . any = any ; initialize ( ) ; }
tr	6	public void addPoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	5	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
tr	7	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	4	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	9X	private boolean r_Step_4 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_5 , 19 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "s" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "t" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; } return true ; }
tr	5	public boolean isDefined ( ) { return ( this . x1 != null && this . x2 != null && this . y1 != null && this . y2 != null && this . z1 != null && this . z2 != null ) ; }
tr	9X	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	3	private void displayURL ( URL url ) { try { if ( url != null ) { htmlPane . setPage ( url ) ; } else { htmlPane . setText ( "File Not Found" ) ; if ( DEBUG ) { System . out . println ( "Attempted to display a null URL." ) ; } } } catch ( IOException e ) { System . err . println ( "Attempted to read a bad URL: " + url ) ; } }
tr	4	private void resizeTable ( ) { int newLen ; int i = 0 ; while ( primes [ i ] <= table . length ) i ++ ; newLen = primes [ i ] ; int oldItems = numItems ; DataCount < E > [ ] oldTable = table ; E [ ] oldKeyArr = keyArr ; table = ( DataCount < E > [ ] ) new DataCount [ newLen ] ; keyArr = ( E [ ] ) new Object [ newLen ] ; numItems = 0 ; for ( i = 0 ; i < oldItems ; i ++ ) { E nextData = oldKeyArr [ i ] ; int hashFind = hasherH . hash ( nextData ) % oldTable . length ; while ( comparator . compare ( oldTable [ hashFind ] . data , nextData ) != 0 ) { hashFind = ( hashFind + hasherG . hash ( nextData ) ) % oldTable . length ; } E data = oldTable [ hashFind ] . data ; incCount ( data ) ; int hashCode = hasherH . hash ( data ) % table . length ; while ( comparator . compare ( table [ hashCode ] . data , data ) != 0 ) { hashCode = ( hashCode + hasherG . hash ( data ) ) % table . length ; } table [ hashCode ] . count = oldTable [ hashFind ] . count ; } }
tr	6	public void openDefaultWindows ( ) { try { if ( activeInventory == null ) { activeInventory = new InventoryFrame ( ) ; activeInventory . setVisible ( true ) ; } else { activeInventory . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( activeStats == null ) { activeStats = new StatsFrame ( ) ; activeStats . setVisible ( true ) ; } else { activeStats . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( activeLog == null ) { activeLog = new TextLogFrame ( ) ; activeLog . logTextBox . setText ( loggedMessages ) ; activeLog . setVisible ( true ) ; } else { activeLog . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	1	public void makeEven ( ) { if ( population . size ( ) % 2 == 1 ) { population . remove ( 0 ) ; } }
tr	8	public GetDataBySubjectPanel ( JFrame frame , QueryDefinition query ) throws Exception { super ( frame , query , new GetDataBySubject ( query . getDocument ( ) ) ) ; JTabbedPane panel = new JTabbedPane ( ) ; ItemSet < SubjectID > subItems = new ItemSet < SubjectID > ( ) { @ Override public void add ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . addSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubjectCount ( ) ; } @ Override public SubjectID get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubject ( index ) ; } @ Override public void set ( int index , String name , Object value ) { SubjectID id = this . get ( index ) ; if ( name . equals ( "Contributor" ) ) { id . setContributor ( ( Contributor ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < SubjectID > subjectsPanel = new ItemTablePanel < SubjectID > ( SubjectID . class , subItems ) ; panel . add ( "Subject IDs" , subjectsPanel ) ; ItemSet < Parameter > paramItems = new ItemSet < Parameter > ( ) { @ Override public void add ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . addParameter ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeParameters ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameterCount ( ) ; } @ Override public Parameter get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameter ( index ) ; } @ Override public void set ( int index , String name , Object value ) { Parameter id = this . get ( index ) ; if ( name . equals ( "Name" ) ) { id . setName ( ( String ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < Parameter > paramsPanel = new ItemTablePanel < Parameter > ( Parameter . class , paramItems ) ; panel . add ( "Parameters" , paramsPanel ) ; ItemSet < LogEntry > logItems = new ItemSet < LogEntry > ( ) { @ Override public void add ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . addLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLogCount ( ) ; } @ Override public LogEntry get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLog ( index ) ; } @ Override public void set ( int index , String name , Object value ) { LogEntry id = this . get ( index ) ; if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < LogEntry > logPanel = new ItemTablePanel < LogEntry > ( LogEntry . class , logItems ) ; panel . add ( "Logs" , logPanel ) ; JPanel otherPanel = new JPanel ( ) ; otherPanel . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints cMain = new GridBagConstraints ( ) ; cMain . fill = GridBagConstraints . HORIZONTAL ; cMain . anchor = GridBagConstraints . PAGE_START ; cMain . gridx = 0 ; cMain . gridy = 0 ; JPanel trxIdPanel = new JPanel ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; trxIdPanel . setLayout ( new GridBagLayout ( ) ) ; otherPanel . add ( trxIdPanel , cMain ) ; panel . add ( "Other" , otherPanel ) ; trxIdPanel . setBorder ( BorderFactory . createTitledBorder ( "Transaction ID" ) ) ; this . btnGroup = new ButtonGroup ( ) ; ActionListener btnActions = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { if ( GetDataBySubjectPanel . this . rdoBtnStatic . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( true ) ; GetDataBySubjectPanel . this . trxIdTextField . grabFocus ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . static ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnRandom . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . Random ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnNone . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . None ) ; } } } ; this . rdoBtnNone = new JRadioButton ( "None" , true ) ; this . rdoBtnNone . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnNone ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . gridx = 0 ; c . gridy = 0 ; trxIdPanel . add ( this . rdoBtnNone , c ) ; this . rdoBtnRandom = new JRadioButton ( "Random" ) ; this . rdoBtnRandom . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnRandom ) ; c . gridx = 0 ; c . gridy = 1 ; trxIdPanel . add ( this . rdoBtnRandom , c ) ; this . rdoBtnStatic = new JRadioButton ( "Static" ) ; this . rdoBtnStatic . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnStatic ) ; c . gridx = 0 ; c . gridy = 2 ; trxIdPanel . add ( this . rdoBtnStatic , c ) ; this . trxIdTextField = new JTextField ( ) ; this . trxIdTextField . addActionListener ( this ) ; this . trxIdTextField . setEditable ( false ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 0.5 ; c . gridx = 1 ; c . gridy = 2 ; trxIdPanel . add ( this . trxIdTextField , c ) ; JPanel bufferPanel = new JPanel ( ) ; cMain . gridx = 0 ; cMain . gridy = 1 ; cMain . weightx = 1 ; cMain . weighty = 1 ; otherPanel . add ( bufferPanel , cMain ) ; this . trxIdTextField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent arg0 ) { String text = GetDataBySubjectPanel . this . trxIdTextField . getText ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionId ( text ) ; stateChanged ( null ) ; } @ Override public void insertUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } @ Override public void removeUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } } ) ; this . addFirstTab ( "Fields" , panel ) ; }
tr	5	public boolean recordLogin ( InetAddress origin , String userName ) { boolean ret = false ; Watch time = new Watch ( ) ; String incQuery = "UPDATE History SET lastLoginIndex = lastLoginIndex + 1 MOD length WHERE userName = '" + userName + "';" ; String delQuery = "DELETE LogIn FROM LogIn JOIN History ON(LogIn.hid = History.hid) WHERE LogIn.index = ((History.lastLoginIndex + 1) MOD length) AND History.userName = '" + userName + "';" ; String query = "INSERT INTO LogIn(hid  ip  month  day  year  `index`  hours  minutes)" + " SELECT hid  INET_ATON('" + origin . getHostAddress ( ) + "')  " + time . getMonth ( ) + "  " + time . getDate ( ) + "  " + time . getYear ( ) + "  lastLoginIndex MOD length  " + time . getHours ( ) + "  " + time . getMinutes ( ) + " " + "FROM History " + "WHERE userName = '" + userName + "';" ; try { connect ( ) ; Statement stmt = connection . createStatement ( ) ; stmt . executeUpdate ( delQuery ) ; connection . setAutoCommit ( false ) ; stmt . executeUpdate ( incQuery ) ; stmt . executeUpdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( SQLException e ) { e . printStackTrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( SQLException e1 ) { e1 . printStackTrace ( ) ; } } finally { if ( connection != null ) try { connection . setAutoCommit ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return ret ; }
tr	0	@ Override public T evaluate ( T x , T y , T z ) throws AbstractException { T resFirst = first . evaluate ( x , y , z ) ; T resSecond = second . evaluate ( x , y , z ) ; return resFirst . sum ( resSecond ) ; }
tr	5	public static String replaceVariablesWithKeyword ( final String line ) { String text = line ; Pattern pattern = Pattern . compile ( "([_A-Za-z0-9\\.]{1 50})(?=(| )[\\;\\ \\+-\\=\\<\\>\\)\\[\\!])" ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { final String match = matcher . group ( ) ; String result = "\u00BAV" ; if ( utils . text . equals ( match , "true" ) ) { result = "\u00BATE" ; } else if ( utils . text . equals ( match , "false" ) ) { result = "\u00BAF" ; } else if ( utils . text . equals ( match , "null" ) ) { result = "\u00BANU" ; } else if ( utils . text . equals ( match , "return" ) ) { result = "\u00BAR" ; } text = text . replace ( matcher . group ( ) , result ) ; } return text ; }
tr	8	public ArrayList < Point > checkMove2 ( Stack < TTTBoard > boards , char player ) { ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; ArrayList < TTTBoard > tempArray = new ArrayList < TTTBoard > ( ) ; while ( ! boards . isEmpty ( ) ) { TTTBoard aBoard = boards . pop ( ) ; ArrayList < Point > spots = aBoard . getEmptySpots ( ) ; char turn = getChar ( spots . size ( ) ) ; ArrayList < TTTBoard > tempArray2 = new ArrayList < TTTBoard > ( ) ; for ( int i = 0 ; i < spots . size ( ) ; i ++ ) { TTTBoard board = new TTTBoard ( aBoard ) ; board . getBoard ( ) [ spots . get ( i ) . x ] [ spots . get ( i ) . y ] = turn ; if ( spots . size ( ) < 6 ) { if ( board . checkWin ( ) ) { if ( turn == player ) { winningSpots . add ( board . getStart ( ) ) ; break ; } else { break ; } } else { tempArray2 . add ( board ) ; } } else { tempArray . add ( board ) ; } } if ( tempArray2 . size ( ) == spots . size ( ) ) { tempArray . addAll ( tempArray2 ) ; } } if ( winningSpots . isEmpty ( ) && tempArray . get ( 0 ) . getEmptySpots ( ) . size ( ) != 0 ) { boards . addAll ( tempArray ) ; winningSpots = checkMove2 ( boards , player ) ; } return winningSpots ; }
tr	1	public CashOffice registerCashOffice ( CashOffice cashOffice ) { int index = cashOffices . indexOf ( cashOffice ) ; if ( index == - 1 ) { addCashOffice ( cashOffice ) ; return cashOffice ; } else { CashOffice foundedCashOffice = cashOffices . get ( index ) ; return foundedCashOffice ; } }
tr	5	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
tr	4	public static boolean setLocked ( final boolean locked ) { if ( isLocked ( ) == locked ) return true ; if ( ! setExpanded ( true ) ) return false ; WidgetChild tc = getLockButton ( ) ; return tc . visible ( ) && tc . click ( true ) && new TimedCondition ( 1500 ) { @ Override public boolean isDone ( ) { return isLocked ( ) == locked ; } } . waitStop ( ) ; }
tr	8	private void jMenuItem1ActionPerformed ( java . awt . event . ActionEvent evt ) { final String inputValue = JOptionPane . showInputDialog ( "Enter a chatroom name" ) ; final JButton btnClose = new JButton ( "x" ) ; if ( inputValue . isEmpty ( ) ) { JOptionPane . showMessageDialog ( GUI . this , "Please enter a name." , "Input Error" , JOptionPane . WARNING_MESSAGE ) ; } else { try { client . sendJoinChatRoomMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatRoomUsersMessage ) ) return ; final ChatRoomUsersMessage ulm = ( ChatRoomUsersMessage ) m ; if ( ulm . getChatRoom ( ) . equals ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ) { userList . setModel ( new javax . swing . AbstractListModel ( ) { List < String > strings = ulm . getUsers ( ) ; public int getSize ( ) { return strings . size ( ) ; } public Object getElementAt ( int i ) { return strings . get ( i ) ; } } ) ; } } } ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof JoinChatRoomMessage ) ) return ; try { client . sendChatRoomUserListMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } final JTextArea jta = new JTextArea ( ) ; tabbedPane . addTab ( inputValue , null , jta , null ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatTextMessage ) ) return ; final ChatTextMessage ulm = ( ChatTextMessage ) m ; jta . append ( "[" + ulm . getUsername ( ) + "]: " + ulm . getText ( ) + "\n" ) ; } } ) ; int index = tabbedPane . indexOfTab ( inputValue ) ; JPanel pnlTab = new JPanel ( ) ; pnlTab . setOpaque ( false ) ; JLabel lblTitle = new JLabel ( inputValue ) ; pnlTab . add ( lblTitle ) ; pnlTab . add ( btnClose ) ; tabbedPane . setTabComponentAt ( index , pnlTab ) ; btnClose . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCloseActionPerformed ( evt ) ; } private void btnCloseActionPerformed ( ActionEvent evt ) { Point mousePos = tabbedPane . getMousePosition ( ) ; int mouseX = mousePos . x ; int mouseY = mousePos . y ; int index = tabbedPane . indexAtLocation ( mouseX , mouseY ) ; Component selected = tabbedPane . getComponentAt ( index ) ; if ( selected != null ) { tabbedPane . remove ( selected ) ; } } } ) ; jta . append ( "[System]: Joined " + inputValue + "\n" ) ; ChatClientApplicationGUI . removeServerMessageListener ( this ) ; } } ) ; } }
tr	0	public BaseLight ( Vector3f color , float intensity ) { this . color = color ; this . intensity = intensity ; }
tr	6	protected String convertToSingleByteAlphabet ( String target ) { if ( target == null ) { return target ; } final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { final char currentChar = target . charAt ( i ) ; if ( currentChar >= ff21 && currentChar <= ff3a ) { sb . append ( doConvertToSingleByteCharacter ( currentChar ) ) ; } else if ( currentChar >= ff41 && currentChar <= ff5a ) { sb . append ( doConvertToSingleByteCharacter ( currentChar ) ) ; } else { sb . append ( currentChar ) ; } } return sb . toString ( ) ; }
tr	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
tr	8	private void handlePhysicalInteract ( PlayerInteractEvent event ) { if ( event . isCancelled ( ) ) return ; Location l = event . getClickedBlock ( ) . getLocation ( ) ; l . setY ( l . getY ( ) - 2 ) ; if ( l . getBlock ( ) . getState ( ) instanceof Sign ) { Sign s = ( Sign ) l . getBlock ( ) . getState ( ) ; String [ ] msg = s . getLines ( ) ; boolean oo = false ; String ms = "" ; for ( String m : msg ) { if ( ! m . isEmpty ( ) && m . substring ( 0 , 1 ) . equals ( "/" ) ) { Bukkit . dispatchCommand ( event . getPlayer ( ) , m . substring ( 1 ) ) ; } else { if ( oo ) { ms += m + " " ; } } if ( m . toLowerCase ( ) . equals ( "[tell]" ) ) { oo = true ; } } if ( ! ms . isEmpty ( ) ) event . getPlayer ( ) . sendMessage ( ChatColor . DARK_AQUA + ChatColor . translateAlternateColorCodes ( "&" . charAt ( 0 ) , ms ) ) ; } }
tr	9X	public Administratorapp ( ) throws FileNotFoundException , IOException { int i ; BufferedReader fisier ; try { listModelSecretari = new DefaultListModel ( ) ; listModelProfesori = new DefaultListModel ( ) ; listModelElevi = new DefaultListModel ( ) ; fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Secretar" ) ) listModelSecretari . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Profesor" ) ) listModelProfesori . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } initComponents ( ) ; BufferedReader fisier2 = new BufferedReader ( new FileReader ( "clase" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier2 . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( int j = 0 ; j < vector . size ( ) ; j ++ ) clasaDeSters . addItem ( vector . get ( j ) ) ; BufferedReader fisier3 = new BufferedReader ( new FileReader ( "fmaterii" ) ) ; ArrayList < String > vector2 = new ArrayList < > ( ) ; for ( String line ; ( line = fisier3 . readLine ( ) ) != null ; ) { vector2 . add ( line ) ; } for ( int k = 0 ; k < vector . size ( ) ; k ++ ) materieDeSters . addItem ( vector2 . get ( k ) ) ; }
tr	3	private void refreshObservers ( ) { if ( client . isConnect ( ) ) { Integer studentsCount = client . getStudentsCount ( ) ; if ( studentsCount == null ) { studentsCount = - 1 ; } maxObserver . setText ( Integer . toString ( studentsCount ) ) ; Integer viewSize = client . getViewSize ( ) ; if ( viewSize == null ) { viewSize = - 1 ; } observer . setText ( Integer . toString ( viewSize ) ) ; } }
tr	0	private void finaliza ( ) { this . dispose ( ) ; }
tr	0	public int getPeopleOnStation ( ) { return peopleOnStation ; }
tr	2	@ Override public String process ( HttpServletRequest request ) throws MissingRequiredParameter { String nombre = request . getParameter ( "nombre" ) ; try { connection = dataSource . getConnection ( ) ; statement = connection . createStatement ( ) ; ResultSet resultSet = null ; String query = "SELECT * FROM farmacias WHERE nombre='" + nombre + "'" ; resultSet = statement . executeQuery ( query ) ; resultSet . next ( ) ; int idfarmacia = resultSet . getInt ( "id_farmacia" ) ; if ( idfarmacia != 0 ) { statement . execute ( "delete from farmacias where id_farmacia ='" + idfarmacia + "';" ) ; } } catch ( SQLException e ) { return "{\"status\":\"KO\"  \"result\": \"Error en el acceso a la base de datos.\"}" ; } String result = "{\"status\":\"OK\"  \"result\": \"Farmacia eliminada correctamente.\"}" ; return result ; }
tr	5	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	1	protected String [ ] getFontStyleNames ( ) { if ( fontStyleNames == null ) { int i = 0 ; fontStyleNames = new String [ 4 ] ; fontStyleNames [ i ++ ] = ( "Plain" ) ; fontStyleNames [ i ++ ] = ( "Bold" ) ; fontStyleNames [ i ++ ] = ( "Italic" ) ; fontStyleNames [ i ++ ] = ( "BoldItalic" ) ; } return fontStyleNames ; }
tr	9X	public void setDimension ( String dimension ) { if ( dimension == null ) dimensionGroup . clearSelection ( ) ; else if ( dimension . equals ( AData . D1 ) ) d1 . setSelected ( true ) ; else if ( dimension . equals ( AData . D2 ) ) d2 . setSelected ( true ) ; else if ( dimension . equals ( AData . D3 ) ) d3 . setSelected ( true ) ; else if ( dimension . equals ( AData . D4 ) ) d4 . setSelected ( true ) ; else if ( dimension . equals ( AData . ODNOMERNOST ) ) odno . setSelected ( true ) ; else if ( dimension . equals ( AData . MALOMERNOST ) ) malo . setSelected ( true ) ; else if ( dimension . equals ( AData . MNOGOMERNOST ) ) mnogo . setSelected ( true ) ; else if ( dimension . equals ( AData . INDIVIDUALNOST ) ) indi . setSelected ( true ) ; if ( dimensionGroup . getSelection ( ) != null ) clearDimensionSelection . setEnabled ( true ) ; else clearDimensionSelection . setEnabled ( false ) ; }
tr	2	public void open ( URL location , String referer ) throws IOException { String host = location . getHost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; String path = location . getPath ( ) + "?" + location . getQuery ( ) ; int port = location . getPort ( ) ; if ( port == - 1 ) port = 80 ; socket . setSoTimeout ( 5000 ) ; socket . connect ( new InetSocketAddress ( host , port ) , 5000 ) ; PrintWriter pw = new PrintWriter ( socket . getOutputStream ( ) , true ) ; pw . println ( "GET " + path + " HTTP/1.1" ) ; pw . println ( "Host: " + host ) ; pw . println ( "Referer: " + referer ) ; pw . println ( "Accept: */*" ) ; pw . println ( "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" ) ; pw . println ( "Connection: Keep-Alive" ) ; pw . println ( ) ; instream = socket . getInputStream ( ) ; getResponse ( ) ; }
tr	8	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
tr	5	public void resetBoard ( ) { for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { m_Pieces [ i ] [ j ] = NONE_PIECE ; } } m_Pieces [ 3 ] [ 3 ] = WHITE_PIECE ; m_Pieces [ 4 ] [ 4 ] = WHITE_PIECE ; m_Pieces [ 3 ] [ 4 ] = BLACK_PIECE ; m_Pieces [ 4 ] [ 3 ] = BLACK_PIECE ; for ( int x = 0 ; x < WIDTH ; x ++ ) { for ( int y = 0 ; y < HEIGHT ; y ++ ) { if ( m_Pieces [ x ] [ y ] == null ) { m_Pieces [ x ] [ y ] = NONE_PIECE ; } } } }
tr	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
tr	9X	public float getProjection ( Vector v ) throws GeometryException { if ( v . getDimensions ( ) < 3 && this . getDimensions ( ) > 3 || v . getDimensions ( ) > 3 && this . getDimensions ( ) < 3 || ( v . getDimensions ( ) < 3 && this . getDimensions ( ) < 3 && this . getDimensions ( ) != v . getDimensions ( ) ) ) throw new GeometryException ( "Vector projections require vectors of same dimensionality" ) ; float dp = 0.0f ; for ( int i = 0 ; i < ( ( this . getDimensions ( ) > 3 ) ? 3 : this . getDimensions ( ) ) ; i ++ ) dp += v . getCoordinate ( i ) * this . getCoordinate ( i ) ; return dp / this . getMeasure ( ) ; }
tr	4	private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == '' || c == '' || excluded . indexOf ( c ) != - 1 ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
tr	2	@ Override public synchronized boolean checkToken ( Token token ) { for ( Token to : tokens ) { if ( token . equals ( to ) ) { return true ; } } return false ; }
tr	0	public void windowDeiconified ( WindowEvent e ) { }
tr	1	@ Override public void paint ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; if ( image != null ) { synchronized ( image ) { g2d . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_SPEED ) ; g2d . drawImage ( image , 0 , 0 , null ) ; } } else { super . paint ( g2d ) ; } }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	6	private void create ( String resource ) { InputStream input = getClass ( ) . getResourceAsStream ( resource ) ; if ( input != null ) { FileOutputStream output = null ; try { out . getParentFile ( ) . mkdirs ( ) ; output = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ 8192 ] ; int length ; while ( ( length = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , length ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { input . close ( ) ; } catch ( Exception ignored ) { } try { if ( output != null ) output . close ( ) ; } catch ( Exception ignored ) { } } } }
tr	9X	private Object readValue ( ) throws JSONException { switch ( read ( 2 ) ) { case 0 : return new Integer ( read ( ! bit ( ) ? 4 : ! bit ( ) ? 7 : 14 ) ) ; case 1 : byte [ ] bytes = new byte [ 256 ] ; int length = 0 ; while ( true ) { int c = read ( 4 ) ; if ( c == endOfNumber ) { break ; } bytes [ length ] = bcd [ c ] ; length += 1 ; } Object value ; try { value = JSONObject . stringToValue ( new String ( bytes , 0 , length , "US-ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new JSONException ( e ) ; } this . values . register ( value ) ; return value ; case 2 : return getAndTick ( this . values , this . bitreader ) ; case 3 : return readJSON ( ) ; default : throw new JSONException ( "Impossible." ) ; } }
tr	4	private void mnuSaveAsTemplateActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser jfc = new JFileChooser ( ) ; jfc . setFileFilter ( new FileNameExtensionFilter ( "xml Datei" , "xml" ) ) ; if ( jfc . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File f = jfc . getSelectedFile ( ) ; if ( ! f . getName ( ) . endsWith ( ".xml" ) ) f = new File ( f . getAbsolutePath ( ) + ".xml" ) ; try { SemesterLoader . saveAsTemplate ( f , semesterList ) ; } catch ( JDOMException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	6	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new BSTNode ( data ) ; return ; } BSTNode currentNode = overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new BSTNode ( data ) ; return ; } currentNode = currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new BSTNode ( data ) ; return ; } currentNode = currentNode . right ; } } }
tr	3	public byte [ ] toBytes ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutput out = null ; try { out = new ObjectOutputStream ( bos ) ; out . writeObject ( this ) ; byte [ ] yourBytes = bos . toByteArray ( ) ; return yourBytes ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( IOException ex ) { } try { bos . close ( ) ; } catch ( IOException ex ) { } } }
tr	4	public static void normalize ( double [ ] [ ] xs ) { double sum = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) sum += xs [ i ] [ j ] ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) xs [ i ] [ j ] /= sum ; }
tr	3	private boolean r_reflexive ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_3 , 2 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; } return true ; }
tr	4	public static BitSet fromByteArray ( byte [ ] bytes ) { BitSet bits = new BitSet ( ) ; for ( int i = 0 ; i < bytes . length * 8 ; i ++ ) { if ( ( bytes [ bytes . length - i / 8 - 1 ] & ( 1 << ( i % 8 ) ) ) > 0 ) { bits . set ( i ) ; } } for ( int k = bits . size ( ) - 1 ; k >= 0 ; k -- ) { System . out . print ( ( bits . get ( k ) ) ? "1" : "0" ) ; } System . out . println ( ) ; return bits ; }
tr	3	public boolean method537 ( ) { if ( anIntArray658 == null ) return true ; boolean flag = true ; for ( int j = 0 ; j < anIntArray658 . length ; j ++ ) if ( ! Model . method463 ( anIntArray658 [ j ] ) ) flag = false ; return flag ; }
tr	8	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	7	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
tr	3	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	3	public void execute ( ) { Session session = null ; String _commandString ; String _output ; int _countCommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "Started processing Unix Commands On Server :" ) ; this . result . append ( this . hostName ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countCommands = this . commands . size ( ) ; while ( _countCommands > _index ) { _commandString = this . commands . get ( _index ) ; this . result . append ( "Executing :" ) ; this . result . append ( _commandString ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectServer . openSession ( ) ; _output = executeCommand ( session , _commandString ) ; this . result . append ( _output ) ; } catch ( IOException e ) { AtomShellException _shellException = new AtomShellException ( e ) ; _shellException . setCustomMessage ( "Unable to Open a Session on Server IP :" + this . hostName ) ; } catch ( AtomShellException e ) { this . result . append ( e . getCustomMessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectServer . close ( ) ; }
tr	3	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getOpenChar ( ) ) ; if ( elements != null ) { for ( INode elt : elements ) { sb . append ( elt . toString ( ) ) ; sb . append ( " " ) ; } } if ( elements . size ( ) > 1 ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; sb . append ( getCloseChar ( ) ) ; return sb . toString ( ) ; }
tr	0	@ Override public IGameController getController ( ) { return controller ; }
tr	6	public static void main ( String [ ] args ) throws Exception { long start = System . currentTimeMillis ( ) ; Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice-1.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice1.out" ) ) ) ; int NumCase = in . nextInt ( ) ; in . nextLine ( ) ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { long min , max ; min = in . nextLong ( ) ; max = in . nextLong ( ) ; int count = 0 ; long sqrt_min = ( long ) Math . sqrt ( min ) , sqrt_max = ( long ) Math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( IsPalin ( i ) && IsPalin ( i * i ) ) { count ++ ; } } System . out . println ( " Case #" + curCase + ": " + count ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "\u8FD0\u884C\u65F6\u95F4\uFF1A" + ( end - start ) + "ms" ) ; }
tr	1	public void addShutDownHook ( ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { try { shutDown ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	6	public static Player fromXml ( org . w3c . dom . Node playerRoot , MonteCarloPlayer player ) { NamedNodeMap attrs = playerRoot . getAttributes ( ) ; player . description = "" ; if ( attrs . getNamedItem ( "playout" ) != null ) { try { Field field = PlayoutStrategy . class . getField ( attrs . getNamedItem ( "playout" ) . getNodeValue ( ) ) ; player . playout = ( PlayoutStrategy ) field . get ( null ) ; player . description += String . format ( "playout=%s" , field . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "finalMove" ) != null ) { try { Field field = FinalNodeSelectionStrategy . class . getField ( attrs . getNamedItem ( "finalMove" ) . getNodeValue ( ) ) ; player . finalNode = ( FinalNodeSelectionStrategy ) field . get ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "maxTurnTime" ) != null ) { try { player . MAX_TURN_TIME = long . parseLong ( attrs . getNamedItem ( "maxTurnTime" ) . getNodeValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } player . description = String . format ( "playout=%s final=%s" , player . playout , player . finalNode ) ; return player ; }
tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	8	public static void main ( String [ ] args ) { int X , m ; int a1 , a2 , a3 ; int m1 , m2 , m3 ; int M1 , M2 , M3 ; int y1 , y2 , y3 ; y1 = y2 = y3 = 1 ; Scanner in = new Scanner ( System . in ) ; a1 = in . nextInt ( ) ; m1 = in . nextInt ( ) ; a2 = in . nextInt ( ) ; m2 = in . nextInt ( ) ; a3 = in . nextInt ( ) ; m3 = in . nextInt ( ) ; m = m1 * m2 * m3 ; M1 = m / m1 ; M2 = m / m2 ; M3 = m / m3 ; for ( int i = 1 ; i <= M1 ; i ++ ) { if ( congruent ( M1 * i , 1 , m1 ) ) { y1 = i ; break ; } } for ( int i = 1 ; i <= M2 ; i ++ ) { if ( congruent ( M2 * i , 1 , m2 ) ) { y2 = i ; break ; } } for ( int i = 1 ; i <= M3 ; i ++ ) { if ( congruent ( M3 * i , 1 , m3 ) ) { y3 = i ; break ; } } X = a1 * M1 * y1 + a2 * M2 * y2 + a3 * M3 * y3 ; int answer = 1 ; for ( int i = 1 ; i <= X ; i ++ ) { if ( congruent ( X , i , m ) ) { answer = i ; break ; } } System . out . println ( "A resposta \u00E9 " + answer ) ; System . out . println ( "Se a resposta dada n\u00E3o est\u00E1 num intervalo dado pelo problema  apenas adicione " + m + " \u00E0 resposta at\u00E9 que esteja" ) ; }
tr	5	public JSONRPCResponseObject sendAndReceive ( JSONRPCRequestObject message ) throws SaploClientException { RestClient client = new RestClient ( ) ; if ( clientProxy != null ) { ClientConfig config = new ClientConfig ( ) ; config . proxyHost ( clientProxy . getHost ( ) ) ; config . proxyPort ( clientProxy . getPort ( ) ) ; if ( clientProxy . isSecure ( ) ) { } client = new RestClient ( config ) ; } Resource resource = client . resource ( uri + "?" + params ) ; ClientResponse response = resource . post ( message . toString ( ) ) ; String responseString = response . getEntity ( String . class ) ; int statusCode = response . getStatusCode ( ) ; if ( statusCode != HttpStatus . SC_OK ) throw new SaploClientException ( ResponseCodes . MSG_API_DOWN_EXCEPTION , ResponseCodes . CODE_API_DOWN_EXCEPTION , statusCode ) ; JSONTokener tokener = new JSONTokener ( responseString ) ; Object rawResponseMessage ; try { rawResponseMessage = tokener . nextValue ( ) ; } catch ( JSONException e ) { throw new SaploClientException ( ResponseCodes . MSG_MALFORMED_RESPONSE , ResponseCodes . CODE_MALFORMED_RESPONSE ) ; } JSONObject responseMessage = ( JSONObject ) rawResponseMessage ; if ( responseMessage == null ) throw new ClientError ( "Invalid response type - " + rawResponseMessage ) ; return new JSONRPCResponseObject ( responseMessage ) ; }
tr	7	public int minPathSum ( int [ ] [ ] grid ) { int sum = 0 ; if ( grid == null || grid . length == 0 || grid [ 0 ] . length == 0 ) return sum ; int [ ] prev = new int [ grid [ 0 ] . length ] ; int [ ] curr = new int [ grid [ 0 ] . length ] ; prev [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) prev [ j ] = prev [ j - 1 ] + grid [ 0 ] [ j ] ; for ( int i = 1 ; i < grid . length ; i ++ ) { curr [ 0 ] = prev [ 0 ] + grid [ i ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) { curr [ j ] = Math . min ( prev [ j ] , curr [ j - 1 ] ) + grid [ i ] [ j ] ; } for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; int [ ] tmp = curr ; curr = prev ; prev = tmp ; } return prev [ prev . length - 1 ] ; }
tr	5	public boolean switchProposal ( boolean forward ) { if ( forward ) { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getNextRR ( ) ; } else { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getPreviousRR ( ) ; } if ( this . myCurrentProposalRR == null ) { return false ; } String i1 = Integer . toBinaryString ( this . myCurrentProposalRR . getBinaryCounter ( ) ) ; while ( i1 . length ( ) < this . getBinaryCounterSize ( ) ) { i1 = "0" + i1 ; } for ( int i = 0 ; i < this . getBinaryCounterSize ( ) ; i ++ ) { boolean propose = i1 . charAt ( i ) == 1 ? true : false ; Policy . getInstance ( ) . getDataColumnByIndex ( i ) . setIsPropose ( propose ) ; } return true ; }
tr	2	private Set < Strategy > buildStrategies ( Strategy strategy , int breakpointNumber , int [ ] breakpoints , int [ ] [ ] actionPercentages ) { Set < Strategy > strategies = new HashSet < Strategy > ( ) ; for ( int [ ] actionPercentageSet : actionPercentages ) { Strategy s = new Strategy ( strategy ) ; Tactic nextTactic = new Tactic ( actionPercentageSet ) ; s . putNewTactic ( nextTactic ) ; if ( breakpointNumber < AISettings . DEFAULT_BREAKPOINTS . length - 1 ) { strategies . addAll ( buildStrategies ( s , breakpointNumber + 1 , breakpoints , actionPercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
tr	7	public boolean collision ( HashMap < Body , Personnage > personnages ) { if ( world == null ) return false ; Personnage persCourant ; CollisionEvent [ ] evenement = world . getContacts ( body ) ; float Normal_x ; for ( int i = 0 ; i < evenement . length ; i ++ ) { Normal_x = evenement [ i ] . getNormal ( ) . getX ( ) ; if ( Normal_x < - 0.5 || Normal_x > 0.5 ) { if ( evenement [ i ] . getBodyB ( ) == body ) { persCourant = personnages . get ( evenement [ i ] . getBodyA ( ) ) ; if ( persCourant != null && cible ( persCourant ) ) persCourant . toucher ( valeurDmg ) ; return true ; } } } return false ; }
tr	3	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	8	public static void main ( String [ ] args ) { MyStore < Integer > a = new MyStore < Integer > ( ) ; a . add ( 1 ) ; a . add ( 2 ) ; a . add ( 3 ) ; a . add ( 4 ) ; a . add ( 5 ) ; System . out . println ( "a" + a ) ; MyStore < Integer > b = new MyStore < Integer > ( ) ; b . add ( 2 ) ; b . add ( 6 ) ; System . out . println ( "b" + b ) ; int res = b . moveToMe ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( res ) ; a . add ( 3 ) ; a . add ( 6 ) ; a . add ( 7 ) ; b . add ( 9 ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; MyStore < Integer > result = b . removeAllMatching ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( "res" + result ) ; MyStore < Integer > c = new MyStore < Integer > ( ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; MyStore < Integer > d = new MyStore < Integer > ( ) ; d . add ( 1 ) ; d . add ( 2 ) ; d . add ( 3 ) ; d . add ( 4 ) ; d . add ( 5 ) ; Iterator < Integer > it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 3 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { Integer val = it . next ( ) ; if ( val == 1 ) { it . remove ( ) ; } if ( val == 2 ) { it . remove ( ) ; } if ( val == 5 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 4 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; RunnableWithArgs funct = new RunnableWithArgs ( ) { @ Override public void run ( Object args ) { } } ; res = d . addAll ( c , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; }
tr	7	private boolean placeRandomTeleportLocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new IllegalArgumentException ( "Invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new IllegalArgumentException ( "Invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new IllegalArgumentException ( "Invalid argument: the randomlocation array-holder is not of length 2" ) ; ArrayList < int [ ] > availableLocations = new ArrayList < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availableLocations . add ( new int [ ] { i , j } ) ; } } } if ( availableLocations . size ( ) == 0 ) { java . lang . System . out . println ( "Warning: You have a teleporter in a map with no spaces" ) ; return false ; } Random random = new Random ( ) ; random . setSeed ( java . lang . System . currentTimeMillis ( ) ) ; int index = random . nextInt ( availableLocations . size ( ) ) ; int [ ] chosen = availableLocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
tr	2	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	0	public BigRational ( ) { this ( BigDecimal . ZERO ) ; }
tr	0	public BIOSwitch ( String onString , String offString ) { super ( onString ) ; create ( ) ; setOffString ( offString ) ; }
tr	1	public MainMenuView ( Checkmate c ) { super ( c ) ; JLabel titleLabel = new JLabel ( "Checkmate 3000 Network AI Edition" ) ; titleLabel . setForeground ( Color . WHITE ) ; titleLabel . setFont ( new Font ( Font . SANS_SERIF , Font . PLAIN , 42 ) ) ; titleLabel . setSize ( 680 , 50 ) ; titleLabel . setLocation ( c . getWidth ( ) / 2 - titleLabel . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.200 ) ) ; add ( titleLabel ) ; JButton localButton = new JButton ( "Local Game" ) ; localButton . setSize ( 150 , 35 ) ; localButton . setLocation ( c . getWidth ( ) / 2 - localButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.480 ) ) ; localButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . LOCAL ) ; } } ) ; add ( localButton ) ; JButton hostButton = new JButton ( "Host Game" ) ; hostButton . setSize ( 150 , 35 ) ; hostButton . setLocation ( c . getWidth ( ) / 2 - hostButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.555 ) ) ; hostButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . HOST ) ; } } ) ; add ( hostButton ) ; JButton joinButton = new JButton ( "Join Game" ) ; joinButton . setSize ( 150 , 35 ) ; joinButton . setLocation ( c . getWidth ( ) / 2 - joinButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.630 ) ) ; joinButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . JOIN ) ; } } ) ; add ( joinButton ) ; JButton logButton = new JButton ( "View Logged Game" ) ; logButton . setSize ( 150 , 35 ) ; logButton . setLocation ( c . getWidth ( ) / 2 - logButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.705 ) ) ; logButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . LOG ) ; } } ) ; add ( logButton ) ; JButton quitButton = new JButton ( "Quit Game" ) ; quitButton . setSize ( 150 , 35 ) ; quitButton . setLocation ( c . getWidth ( ) / 2 - quitButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.780 ) ) ; quitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { int wantsExit = JOptionPane . showConfirmDialog ( myCheckmate , "Are you sure you want to exit the program?" , "Exit Program?" , JOptionPane . YES_NO_OPTION ) ; if ( wantsExit == JOptionPane . YES_OPTION ) { System . exit ( 0 ) ; } } } ) ; add ( quitButton ) ; }
tr	7	private CfgGroup readGroup ( final CfgGroup group , final BufferedReader reader ) throws IOException { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return group ; } line = line + "\r\n" ; final String trimmedLine = line . trim ( ) ; if ( trimmedLine . equals ( "}" ) ) { group . addFooterLine ( new CfgRawLine ( line ) ) ; return group ; } if ( trimmedLine . equals ( "{" ) ) { group . addHeaderLine ( new CfgRawLine ( line ) ) ; continue ; } if ( trimmedLine . startsWith ( "//" ) ) { continue ; } if ( trimmedLine . isEmpty ( ) ) { continue ; } final int indexOfEquals = trimmedLine . indexOf ( = ) ; if ( indexOfEquals < 0 ) { final CfgLine groupNameLine = new CfgRawLine ( line ) ; final CfgGroup subgroup = new CfgGroup ( groupNameLine ) ; readGroup ( subgroup , reader ) ; group . addSubgroup ( subgroup ) ; } else { final CfgLine cfgLine = new CfgKeyValueLine ( line ) ; group . addLine ( cfgLine ) ; } } }
tr	0	public boolean hasToChargeMove ( ) { return chargingMoveCount > 0 ; }
tr	5	private int findShortestPath ( ) throws IllegalStateException { int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= graph . V ( ) ; i ++ ) { for ( int j = 1 ; j <= graph . V ( ) ; j ++ ) { if ( i == j && d [ i ] [ j ] [ graph . V ( ) ] < 0 ) { throw new IllegalStateException ( "Negative cycle!" ) ; } if ( d [ i ] [ j ] [ graph . V ( ) ] < min ) { min = d [ i ] [ j ] [ graph . V ( ) ] ; } } } return min ; }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	4	private static Node < Integer > partitionList2 ( Node < Integer > node , int x ) { Node < Integer > before = null ; Node < Integer > after = null ; while ( node != null ) { Node < Integer > next = node . getNext ( ) ; if ( node . getData ( ) < x ) { node . setNext ( before ) ; before = node ; } else { node . setNext ( after ) ; after = node ; } node = next ; } if ( before == null ) { return after ; } Node < Integer > head = before ; while ( before . getNext ( ) != null ) { before = before . getNext ( ) ; } before . setNext ( after ) ; return head ; }
tr	7	public void generateAggregatedReport ( ) { long start , end ; start = System . currentTimeMillis ( ) ; File reportFile = new File ( reportFileName ) ; PrintWriter reportOut = null ; boolean once = true ; try { reportOut = new PrintWriter ( reportFile ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } reportOut . println ( "Report Generation Time   " + timeStamp ) ; for ( int instanceNo = 0 ; instanceNo < instanceFiles . length ; instanceNo ++ ) { ProblemInstance problemInstance = createProblemInstance ( instanceFiles [ instanceNo ] , singleOutputFileName ) ; Scheme6 ga = new Scheme6 ( problemInstance ) ; if ( once ) { once = false ; reportOut . format ( "Number Of Generation  Population Size  Offspring Population Size  LoadPenalty  RouteTime Penalty\n" ) ; reportOut . format ( "%d  %d  %d  %f  %f\n" , ga . NUMBER_OF_GENERATION , ga . POPULATION_SIZE , ga . NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; reportOut . println ( ) ; reportOut . println ( ) ; reportOut . format ( "Instance Name  Min  Avg  Max  Feasible \n" ) ; } double min = FFFFFF ; double max = - 1 ; double sum = 0 ; double avg ; int feasibleCount = 0 ; for ( int i = 0 ; i < runSize ; i ++ ) { Individual sol = ga . run ( ) ; if ( sol . isFeasible == true ) { feasibleCount ++ ; } sum += sol . costWithPenalty ; if ( sol . costWithPenalty > max ) max = sol . costWithPenalty ; if ( sol . costWithPenalty < min ) min = sol . costWithPenalty ; } avg = sum / runSize ; reportOut . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; reportOut . flush ( ) ; System . out . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; } end = System . currentTimeMillis ( ) ; long duration = ( end - start ) / 1000 ; long minute = duration / 60 ; long seconds = duration % 60 ; reportOut . println ( "\nELAPSED TIME : " + minute + " minutes " + seconds + " seconds" ) ; reportOut . flush ( ) ; reportOut . close ( ) ; }
tr	0	public String getMessage ( ) { return super . getMessage ( ) + SEPARATOR + getErrnoString ( ) + " [" + errno + "] " ; }
tr	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	6	protected void sendRequest ( StatesOfClient state ) { resetState ( ) ; setState ( state ) ; pmfc . printWhichStateIsTesting ( ) ; try { if ( CURL_HTTP_PORT != 443 ) { client = vertx . createHttpClient ( ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } else { client = vertx . createHttpClient ( ) . setSSL ( true ) . setTrustAll ( true ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } mCurlCommandsSetter = mCurlCommandsSetterFactory . createSetter ( getState ( ) ) ; mCurlCommandsSetter . execute ( state ) ; pmfc . printCurrentRequestAndPathInCurlCommand ( ) ; requestSendFromClienttoServer = client . request ( BehaviorOfCurlCommandsSetter . currentRequest , BehaviorOfCurlCommandsSetter . currentPath , new Handler < HttpClientResponse > ( ) { @ Override public void handle ( HttpClientResponse responseRecievedAtClientFromServer ) { statusCode = responseRecievedAtClientFromServer . statusCode ( ) ; responseRecievedAtClientFromServer . bodyHandler ( new Handler < Buffer > ( ) { @ Override public void handle ( Buffer body ) { try { try { pmfc . printMessageFromServer ( body ) ; currentServerResponseInJsonFormat = new JsonObject ( body . toString ( ) ) ; getDataFromDB ( ) ; } catch ( Exception e ) { } mAssertionChecker = mAssertionCheckerFactory . createChecker ( getState ( ) ) ; mAssertionChecker . execute ( getState ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { pmfc . printEnd ( ) ; testComplete ( ) ; } } } ) ; } } ) . exceptionHandler ( new Handler < Throwable > ( ) { @ Override public void handle ( Throwable t ) { t . printStackTrace ( ) ; } } ) ; try { headersSetUp ( ) ; jsonBodySetUp ( ) ; } catch ( Exception e ) { } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } finally { if ( client != null ) { client . close ( ) ; } } }
tr	9X	private void distributePoints ( int mouseX , int mouseY ) { if ( pointsRequested && id != - 1 && requestedPointsLeft != - 1 ) { if ( requestedPointsLeft > 0 && id != - 2 ) { for ( int x = 0 ; x < windowslist . size ( ) ; x ++ ) { if ( windowslist . get ( x ) . getID ( ) == id ) { if ( Mouse . isButtonDown ( 0 ) ) { if ( windowslist . get ( x ) . getPoint ( mouseX , mouseY ) ) { requestedPointsLeft -- ; } } } } } else if ( requestedPointsLeft > 0 && id == - 2 ) { if ( Mouse . isButtonDown ( 0 ) ) { if ( activePane . getPoint ( mouseX , mouseY ) ) { requestedPointsLeft -- ; } } } else { id = - 1 ; pointsRequested = false ; requestedPointsLeft = - 1 ; } } }
tr	9X	public boolean isValidSudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = Character . getNumericValue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = Character . getNumericValue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = Character . getNumericValue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
tr	4	@ Override public int attachSoundEffect ( SoundEffect effect , int channel ) { if ( channel > chEffects . size ( ) ) throw new IndexOutOfBoundsException ( "Channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getChannelCount ( ) != channelCount ) throw new IllegalArgumentException ( "The effects channel count must be same as this mixers channel count!" ) ; mEffects . add ( effect ) ; return mEffects . size ( ) - 1 ; } else { if ( effect . getChannelCount ( ) != getInputChannelOutputChannelCount ( channel ) ) throw new IllegalArgumentException ( "The effects channel count must be the same as input channels channel count!" ) ; ArrayList < SoundEffect > e = chEffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	4	@ Test public void doPriorityQueue ( ) { init ( ) ; int count = 0 ; while ( true ) { Point x = prQueue . poll ( ) ; squares . add ( x ) ; Point [ ] ppp = getPotentialPoints ( x , getCrossPoint ( x ) ) ; prQueue . add ( ppp [ 0 ] ) ; prQueue . add ( ppp [ 1 ] ) ; if ( count > 800000 ) break ; count ++ ; if ( x . hx == 3 && x . hy == 3 ) System . out . println ( "RESULT " + squares . size ( ) ) ; } System . out . println ( squares . get ( 49 ) . hx + " " + squares . get ( 49 ) . hy ) ; }
tr	0	public Parler ( String message ) { this ( 0 , message ) ; }
tr	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	7	private Message nextTypeMessage ( List < MessageType > list ) throws IOException { Message message = null ; String header ; int ret = Message . INVALID_MSG , messageLen ; do { header = reader . readLine ( ) ; if ( header == null ) return null ; header += "\n" ; messageLen = Message . validateHeader ( header , list ) ; if ( messageLen < 0 ) continue ; for ( int i = 0 ; i < messageLen ; i ++ ) { header += reader . readLine ( ) + "\n" ; } message = new Message ( header ) ; ret = message . matches ( ) ; if ( ( ret == Message . VALID_MSG ) && ! list . contains ( message . getType ( ) ) ) { ret = Message . INVALID_MSG ; } } while ( header != null && ret != Message . VALID_MSG ) ; return message ; }
tr	0	public EvaluationUtilityTest ( ) { }
tr	4	private static class < ? > getPrimitiveClass ( final class < ? > componentType ) { if ( Integer . class . isAssignableFrom ( componentType ) ) { return int . class ; } if ( double . class . isAssignableFrom ( componentType ) ) { return double . class ; } throw new UnsupportedOperationException ( "Mapping not implemented" ) ; }
tr	5	public final boolean isValidRate ( final String rate ) { final String methodName = "isValidRate" ; DatabaseLogger . entering ( CLASS_NAME , methodName , rate ) ; boolean validRate = true ; if ( isEmptyValue ( rate ) ) { validRate = false ; } else if ( ! rate . startsWith ( "$" ) ) { validRate = false ; } else { try { final String rateAmount = rate . substring ( 1 ) ; double rateDouble = double . parseDouble ( rateAmount ) ; if ( ( rateDouble <= 0 ) || ( rateDouble > DatabaseConstants . MAX_RATE_VALUE ) ) { validRate = false ; } } catch ( NumberFormatException e ) { validRate = false ; } } DatabaseLogger . exiting ( CLASS_NAME , methodName , validRate ) ; return validRate ; }
tr	4	public void repairGeneTree ( Abaddon abaddon ) { while ( ! uncheckedGenes . isEmpty ( ) ) { GeneTrait currentGene = uncheckedGenes . remove ( 0 ) ; if ( currentGene instanceof ParentTrait ) { ParentTrait currentParent = ( ParentTrait ) currentGene ; for ( int i = 0 ; i < currentParent . getChildCount ( ) ; i ++ ) { GeneTrait currentChild = currentParent . getChild ( i ) ; if ( ! genes . contains ( currentChild ) ) { abaddon . growChild ( this , currentParent , i ) ; } } } } }
tr	7	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	7	public char leerDato ( ) { char dato ; if ( isESTA_EN_RAM ( ) ) { if ( pos < data . length ( ) ) { dato = data . charAt ( pos ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } else { if ( "" . equals ( prox ) && lector . hasNext ( ) ) { prox = lector . next ( ) ; } else if ( "" . equals ( prox ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( pos >= prox . length ( ) ) { pos = 0 ; if ( lector . hasNext ( ) ) { prox = lector . next ( ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } dato = prox . charAt ( pos ) ; } pos ++ ; return dato ; }
tr	7	private void loginSubmitButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String userName = userNameText . getText ( ) ; String password = passwordText . getText ( ) ; boolean accountAvailable = false ; int accountID = 0 ; int permission = 0 ; String accountPassword = "" ; String firstName = "" ; String lastName = "" ; DatabaseConnection dbConnect = new DatabaseConnection ( ) ; Connection conn = dbConnect . connectToDB ( ) ; String sql = "SELECT COUNT(Username) as accountAvailable FROM `HD_Accounts` WHERE Username = '" + userName + "'" ; ResultSet rs = dbConnect . getResults ( conn , sql ) ; try { if ( rs . next ( ) ) { if ( rs . getInt ( "accountAvailable" ) == 1 ) { accountAvailable = true ; sql = "SELECT * FROM `HD_Accounts` where Username = '" + userName + "'" ; rs = dbConnect . getResults ( conn , sql ) ; while ( rs . next ( ) ) { accountID = rs . getInt ( "id" ) ; accountPassword = rs . getString ( "Password" ) ; firstName = rs . getString ( "FirstName" ) ; lastName = rs . getString ( "LastName" ) ; permission = rs . getInt ( "Permission" ) + 1 ; } } } } catch ( SQLException ex ) { Logger . getLogger ( HelpDeskMainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( ! accountAvailable && ! accountPassword . equals ( password ) ) { failure ++ ; if ( failure == 3 ) { this . dispose ( ) ; failureAlert . setVisible ( true ) ; } else { softFailureAlert . setVisible ( true ) ; userNameText . setText ( "" ) ; passwordText . setText ( "" ) ; } } else { this . dispose ( ) ; new LandingForm ( permission , accountID ) . setVisible ( true ) ; } }
tr	9X	public void initConvexe ( ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; next . convexe = new Convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { Classe classe = vectClasses . elementAt ( classes [ i ] ) ; if ( classe . envDessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getK ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . envDessinee ) { next . convexe . calculBarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	0	public void setY ( float y ) { this . y = y ; }
tr	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } else if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { Node < E > tmp = getIndex ( index - 1 ) ; tmp . setNext ( tmp . getNext ( ) . getNext ( ) ) ; _lenght -- ; } }
tr	3	public void add ( int index , E value ) { if ( ( index < 0 ) || ( index > this . size ) ) { return ; } if ( index == 0 ) { this . addFront ( value ) ; } else { this . addAfter ( this . nodeAtPosition ( index - 1 ) , value ) ; } this . size ++ ; }
tr	4	public double evaluteTheStrategy ( ) { double sellSum = 0 ; double buySum = 0 ; int count = 0 ; int NumberOfSell = this . getNumberOfSell ( ) ; for ( GeneratedSignal gs : genSigList ) { if ( gs . getType ( ) . equals ( "sell" ) ) { sellSum += gs . getPrice ( ) ; } else if ( gs . getType ( ) . equals ( "buy" ) && count < NumberOfSell ) { buySum += gs . getPrice ( ) ; count ++ ; } } return ( sellSum - buySum ) ; }
tr	5	public String checkDataEntry ( ) { if ( efastAnalysisPanel1 . parameterScreen . directoryChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) . equals ( "" ) || efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . parametersModel . contains ( "None Entered" ) ) { return "No parameters have been selected" ; } else { try { Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) ) ; Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Number of curves and parameter samples must be integers" ; } } }
tr	2	public void update ( ) { super . update ( ) ; if ( this . isClicked ( ) && ( Timer . getTime ( ) - this . lastClick ) > 200 ) { this . state = ! this . state ; this . lastClick = Timer . getTime ( ) ; } }
tr	8	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	7	public void processMouseDragged ( int x , int y ) { Rectangle2D . double poseArea = zoomableCanvasState . getPoseArea ( ) ; int incX = x - lastMouseDraggedX ; int incY = y - lastMouseDraggedY ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( state == PoseurState . DRAG_SHAPE_STATE ) { if ( poseArea . contains ( x , y ) ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; incX /= zoomLevel ; incY /= zoomLevel ; Rectangle2D . double truePoseArea = trueCanvasState . getPoseArea ( ) ; selectedShape . moveShape ( incX , incY , truePoseArea ) ; repaintCanvases ( ) ; } else { setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } } else if ( state == PoseurState . COMPLETE_SHAPE_STATE ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX >= poseArea . getWidth ( ) ) || ( poseSpaceY >= poseArea . getHeight ( ) ) ) { setState ( PoseurState . CREATE_SHAPE_STATE ) ; shapeInProgress = null ; return ; } shapeInProgress . updateShapeInProgress ( poseSpaceX , poseSpaceY ) ; repaintCanvases ( ) ; } }
tr	3	public static void startClient ( ) { if ( ( client != null ) && client . isAlive ( ) ) { return ; } try { client = new Client ( ( Inet4Address ) Inet4Address . getLocalHost ( ) , Constants . port ) ; client . start ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	4	public static void main ( String [ ] args ) { SelectionSort ss = new SelectionSort ( 10 ) ; System . out . println ( ss . toString ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; System . out . println ( ss . toString ( ) ) ; }
tr	8	public final float getPixelUnitFactor ( boolean isHor ) { switch ( PlatformDefaults . getLogicalPixelBase ( ) ) { case PlatformDefaults . BASE_FONT_SIZE : Font font = c . getFont ( ) ; FontMetrics fm = c . getFontMetrics ( font != null ? font : SUBST_FONT ) ; Point . float p = FM_MAP . get ( fm ) ; if ( p == null ) { Rectangle2D r = fm . getStringBounds ( "X" , c . getGraphics ( ) ) ; p = new Point . float ( ( ( float ) r . getWidth ( ) ) / 6f , ( ( float ) r . getHeight ( ) ) / 13.27734375f ) ; FM_MAP . put ( fm , p ) ; } return isHor ? p . x : p . y ; case PlatformDefaults . BASE_SCALE_FACTOR : float s = isHor ? PlatformDefaults . getHorizontalScaleFactor ( ) : PlatformDefaults . getVerticalScaleFactor ( ) ; if ( s != null ) return s ; return ( isHor ? getHorizontalScreenDPI ( ) : getVerticalScreenDPI ( ) ) / ( float ) PlatformDefaults . getDefaultDPI ( ) ; default : return 1f ; } }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	8	@ Override protected void process ( ) { StringTokenizer t = new StringTokenizer ( fileL . getListString ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasMoreTokens ( ) ; files ++ ) { String s = t . nextToken ( ) ; String title = Print . titleString ( "--" , s ) ; if ( showAllFiles ) { Print . ln ( title ) ; title = null ; } int i = 0 ; try ( BufferedReader in = new BufferedReader ( new FileReader ( s ) ) ) { for ( int line = 1 ; ( s = in . readLine ( ) ) != null ; line ++ ) if ( fnameFilter . accept ( s ) ) { if ( title != null ) { Print . ln ( title ) ; title = null ; } Print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( IOException ioe ) { Sys . warning ( ioe . toString ( ) ) ; } if ( i > 0 || showAllFiles ) { Print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } Print . ln ( Print . separator ( "==========================" ) ) ; Print . ln ( "Totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	2	public static boolean isPrime ( long n ) { log ( "Checking " + n ) ; boolean isPrime = n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; if ( isPrime ) log ( "Prime found " + n ) ; return isPrime ; }
tr	9X	private void spawnGroundItem ( int i , int j ) { NodeList class19 = groundArray [ plane ] [ i ] [ j ] ; if ( class19 == null ) { worldController . method295 ( plane , i , j ) ; return ; } int k = fa0a1f01 ; Object obj = null ; for ( Item item = ( Item ) class19 . reverseGetFirst ( ) ; item != null ; item = ( Item ) class19 . reverseGetNext ( ) ) { ItemDef itemDef = ItemDef . forID ( item . ID ) ; int l = itemDef . value ; if ( itemDef . stackable ) l *= item . anInt1559 + 1 ; if ( l > k ) { k = l ; obj = item ; } } class19 . insertTail ( ( ( Node ) ( obj ) ) ) ; Object obj1 = null ; Object obj2 = null ; for ( Item class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetFirst ( ) ; class30_sub2_sub4_sub2_1 != null ; class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetNext ( ) ) { if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && obj1 == null ) obj1 = class30_sub2_sub4_sub2_1 ; if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj1 ) ) . ID && obj2 == null ) obj2 = class30_sub2_sub4_sub2_1 ; } int i1 = i + ( j << 7 ) + 60000000 ; worldController . method281 ( i , i1 , ( ( Animable ) ( obj1 ) ) , method42 ( plane , j * 128 + 64 , i * 128 + 64 ) , ( ( Animable ) ( obj2 ) ) , ( ( Animable ) ( obj ) ) , plane , j ) ; }
tr	0	private Vector < Arete > ajoute ( int p , Vector < Arete > v ) { DoubletVect < Arete > dVect = separe ( ens . elementAt ( p ) , v ) ; int [ ] tab = compte ( dVect . v1 , p ) ; Vector < Arete > vEnPlus = nouvellesAretes ( p , tab , p ) ; return concat ( dVect . v2 , vEnPlus ) ; }
tr	1	public void actionPerformed ( ActionEvent e ) { String albumName = albumNameTF . getText ( ) ; try { makeAlbumPopUp . this . photosScreen . makeAlbum ( albumName ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } }
tr	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
tr	6	@ Override public Article find ( int id ) { Article found = null ; PreparedStatement pst = null ; ResultSet rs = null ; try { pst = this . connect ( ) . prepareStatement ( "select * from Article where id= ?" ) ; pst . setInt ( 1 , id ) ; rs = pst . executeQuery ( ) ; System . out . println ( "recherche individuelle r\u00E9ussie" ) ; if ( rs . next ( ) ) { found = new Article ( rs . getInt ( "id" ) , rs . getString ( "titre" ) , rs . getString ( "resume" ) , rs . getDate ( "date" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "recherche individuelle echou\u00E9" , ex ) ; } finally { try { if ( rs != null ) rs . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation result set echou\u00E9" , ex ) ; } try { if ( pst != null ) pst . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation prepared statement echou\u00E9" , ex ) ; } } return found ; }
tr	1	public static boolean isInteger ( String s ) { try { Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return false ; } return true ; }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	6	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	4	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String scomplete = scan . nextLine ( ) ; while ( ! scomplete . equals ( "#" ) ) { String [ ] scompleteArray = scomplete . split ( " " ) ; String s1 = scompleteArray [ 0 ] ; String s2 = scompleteArray [ 1 ] ; int [ ] [ ] m = new int [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; dir [ ] [ ] direcciones = new dir [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; fill ( s2 , s1 , m , direcciones ) ; ArrayList < dir > res = trace ( m , direcciones , s2 , s1 ) ; int acarreo = 0 ; char last = a ; for ( int i = res . size ( ) - 1 ; i > - 1 ; i -- ) { if ( res . get ( i ) . pre . charAt ( 0 ) == I ) { acarreo ++ ; } res . get ( i ) . acarreo ( acarreo ) ; System . out . print ( res . get ( i ) . Stringify ( ) ) ; if ( res . get ( i ) . pre . charAt ( 0 ) == D ) { acarreo -- ; } } System . out . print ( "E\n" ) ; scomplete = scan . nextLine ( ) ; } }
tr	4	private Node < V > addNextLessGreater ( Node < V > node , char c ) { while ( node . letter != c ) { if ( c < node . letter ) { if ( node . less == null ) { node . less = new Node < V > ( c ) ; return node . less ; } node = node . less ; } else { if ( node . greater == null ) { node . greater = new Node < V > ( c ) ; return node . greater ; } node = node . greater ; } } return node ; }
tr	3	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex == - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
tr	2	public String getHeader ( String key ) { for ( Header h : headers ) { if ( h . getName ( ) . equals ( key ) ) { return h . getValue ( ) ; } } return null ; }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	0	public int getRowCount ( ) { return data . length ; }
tr	4	public ListIterator < T > listIterator ( int start ) throws IndexOutOfBoundsException { if ( start < 0 || start > size ) throw new IndexOutOfBoundsException ( "Invalid start index: " + start ) ; Node cur = null ; for ( int i = 0 ; i < start ; ++ i ) { cur = ( cur == null ) ? head : cur . next ; } return listIterator ( start - 1 , cur ) ; }
tr	8	public static Level validateLevel ( String level ) throws DiscoException { if ( level . equalsIgnoreCase ( "ALL" ) ) return Level . ALL ; else if ( level . equalsIgnoreCase ( "TRACE" ) ) return Level . TRACE ; else if ( level . equalsIgnoreCase ( "DEBUG" ) ) return Level . DEBUG ; else if ( level . equalsIgnoreCase ( "INFO" ) ) return Level . INFO ; else if ( level . equalsIgnoreCase ( "WARN" ) ) return Level . WARN ; else if ( level . equalsIgnoreCase ( "ERROR" ) ) return Level . ERROR ; else if ( level . equalsIgnoreCase ( "FATAL" ) ) return Level . FATAL ; else if ( level . equalsIgnoreCase ( "OFF" ) ) return Level . OFF ; else throw new DiscoException ( "Log Level [" + level + "] not valid" ) ; }
tr	7	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
tr	3	public static boolean isLeapYear ( int y ) { if ( ( y % 4 == 0 && y % 100 != 100 ) || y % 400 == 0 ) return true ; else return false ; }
tr	7	public void __doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = ( Context ) req . getSession ( ) . getAttribute ( Authtoken . TOKEN ) ; if ( ctx == null ) { ctx = new Context ( ) ; } String questionId = new String ( ) ; if ( req . getPathInfo ( ) != null ) { questionId = "/" + Question . RESOURCE_NAME + "/" + req . getPathInfo ( ) . replaceAll ( "/" , "" ) ; } if ( ! questionId . equals ( "" ) ) { Message request = new Message ( ctx ) ; request . put ( Question . ID , questionId ) ; Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; Message profileReq = new Message ( ctx ) ; Message profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , response . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; response . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; List < Map < String , String >> answers = new ArrayList < Map < String , String >> ( ) ; Message answerResp , voteResp ; for ( Map < String , String > ref : response . getReferences ( Question . ANSWERS ) ) { request = new Message ( ctx ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; answerResp = new Message ( ctx ) ; new AnswerService ( ) . doGet ( request , answerResp ) ; Map < String , String > answer = new HashMap < String , String > ( ) ; answer . put ( Answer . ID , answerResp . get ( Answer . ID ) ) ; answer . put ( Answer . CONTENT , answerResp . get ( Answer . CONTENT ) ) ; answer . put ( Answer . VOTES , answerResp . get ( Answer . VOTES ) ) ; answer . put ( Document . AUTHOR , answerResp . get ( Document . AUTHOR ) ) ; answer . put ( System . TIMESTAMP , answerResp . get ( System . TIMESTAMP ) ) ; profileReq = new Message ( ctx ) ; profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , answerResp . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; answer . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; if ( ctx != null ) { request = new Message ( ctx ) ; request . put ( Profile . ID , ctx . getLoggedInUserProfileId ( ) ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; voteResp = new Message ( ctx ) ; new VoteService ( ) . doGet ( request , voteResp ) ; if ( voteResp . containsField ( Vote . ID ) ) { answer . put ( Vote . ID , voteResp . get ( Vote . ID ) ) ; answer . put ( Vote . VOTE , voteResp . get ( Vote . VOTE ) ) ; } } answers . add ( answer ) ; } req . setAttribute ( Answer . RESOURCE_NAME , answers ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , Question . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "View Question" ) ; eventRequest . put ( Event . OBJECT , questionId ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_VIEW , req , resp ) ; } else { Message request = new Message ( ctx ) ; if ( req . getParameter ( QuestionSearchIndex . QUERY_STRING ) != null ) { request . put ( QuestionSearchIndex . QUERY_STRING , req . getParameter ( QuestionSearchIndex . QUERY_STRING ) ) ; } else { request . put ( QuestionSearchIndex . QUERY_STRING , "" ) ; } Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; response . put ( QuestionSearchIndex . QUERY_STRING , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , QuestionSearchIndex . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "Search Question" ) ; eventRequest . put ( Event . OBJECT , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_SEARCH_VIEW , req , resp ) ; } }
tr	7	public List < List < String >> partition ( String s ) { List < List < String >> result = new ArrayList < > ( ) ; if ( s == null || s . length ( ) == 0 ) return result ; boolean isP [ ] [ ] = new boolean [ s . length ( ) ] [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { isP [ i ] [ i ] = true ; } for ( int i = 0 ; i + 1 < s . length ( ) ; i ++ ) { isP [ i ] [ i + 1 ] = s . charAt ( i ) == s . charAt ( i + 1 ) ; } for ( int i = 0 , j = 2 ; j < s . length ( ) ; j ++ ) { for ( int k = i , l = j ; l < s . length ( ) ; k ++ , l ++ ) { isP [ k ] [ l ] = isP [ k + 1 ] [ l - 1 ] && s . charAt ( k ) == s . charAt ( l ) ; } } dfs ( s , 0 , result , new ArrayList < String > ( ) , isP ) ; return result ; }
tr	4	public Tile cross ( Tile currentTile , Character crosser ) { if ( crosser == null || currentTile == null ) { throw new IllegalArgumentException ( "currentTile and crosser cannot be null" ) ; } if ( ! crosser . equals ( currentTile . getCharacter ( ) ) ) { throw new IllegalArgumentException ( "The given character must be on the given tile" ) ; } if ( ! canCross ( crosser ) ) { throw new IllegalArgumentException ( "The given character is not capable of crossing this edge" ) ; } Tile destination = getOtherTile ( currentTile ) ; currentTile . removeCharacter ( ) ; destination . addCharacter ( crosser ) ; return destination ; }
tr	9X	private List < Student > getStudents ( final Mode inputMode , final List < Object > params ) { final List < Student > students = new Vector < Student > ( ) ; if ( isConnect ( ) ) { sendPackage ( new package ( inputMode , params ) ) ; Object obj ; while ( true ) { try { obj = ois . readObject ( ) ; } catch ( final IOException e ) { System . out . println ( "can't read" ) ; break ; } catch ( final ClassNotFoundException e ) { System . out . println ( "can't read" ) ; break ; } if ( obj != null ) { if ( isPackage ( obj ) ) { final package pack = ( package ) obj ; final Mode mode = pack . getMode ( ) ; switch ( mode ) { case SEARCH1 : receiveStudents ( students , pack ) ; return students ; case SEARCH2 : receiveStudents ( students , pack ) ; return students ; case SEARCH3 : receiveStudents ( students , pack ) ; return students ; case GET_CURR_PAGE : receiveStudents ( students , pack ) ; return students ; case GET_NEXT_PAGE : receiveStudents ( students , pack ) ; return students ; case GET_PREV_PAGE : receiveStudents ( students , pack ) ; return students ; default : System . out . println ( "default" ) ; break ; } System . out . println ( ) ; break ; } } } } return students ; }
tr	2	public void prepareForStartingAttempt ( ) { ArrayList < FieldElement > startingElements = getElements ( "arcanoid.model.Ball" ) ; int width = ( int ) startingElements . get ( 0 ) . size ( ) . width ( ) ; int startPos = startingElements . get ( 0 ) . position ( ) . x + width / 2 ; int yPos = startingElements . get ( 0 ) . position ( ) . y ; for ( int i = 1 ; i < startingElements . size ( ) ; i ++ ) { if ( i < 3 ) { startingElements . get ( i ) . setPosition ( new Point ( startPos - i * 20 - width * i , yPos ) ) ; } else { startingElements . get ( i ) . setPosition ( new Point ( startPos + ( i - 2 ) * 20 + width * ( i - 2 ) , yPos ) ) ; } } }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	4	public int numCoreArgs ( ) { int cnt = 0 ; for ( int i = 0 , n = arglbids . length ; i < n ; ++ i ) if ( arglbids [ i ] >= 0 && arglbs [ i ] . length ( ) < 3 && arglbs [ i ] . startsWith ( "A" ) ) ++ cnt ; return cnt ; }
tr	2	@ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof abort_result ) return this . equals ( ( abort_result ) that ) ; return false ; }
tr	6	void checkNotLinked ( ) { if ( min != null && min . isLinkedDeep ( ) || pref != null && pref . isLinkedDeep ( ) || max != null && max . isLinkedDeep ( ) ) throw new IllegalArgumentException ( "Size may not contain links" ) ; }
tr	9X	public void storePast ( PastData past ) { if ( past . zip . equalsIgnoreCase ( "denver co" ) ) past . zip = "80201" ; String prefix = past . zip + " " + timeFormat . format ( past . date ) + " " + past . today + " " + past . occurredDate ; if ( past . overallPast . high != null || past . overallPast . precip != null ) { String str = prefix ; str = str + " " ; if ( past . overallPast . high != null ) str = str + past . overallPast . high . toString ( ) ; str = str + " " ; if ( past . overallPast . precip != null ) str = str + past . overallPast . precip . toString ( ) ; str = str + " " ; DAout . println ( str ) ; } if ( past . hourlyPast . length != 0 ) { for ( int i = 0 ; i < past . hourlyPast . length ; i ++ ) { String str = prefix ; str = str + " " + past . hourlyPast [ i ] . hour ; str = str + " " ; if ( past . hourlyPast [ i ] . temp != null ) str = str + past . hourlyPast [ i ] . temp . toString ( ) ; str = str + " " ; if ( past . hourlyPast [ i ] . conditions != null ) str = str + past . hourlyPast [ i ] . conditions ; str = str + " " ; if ( past . hourlyPast [ i ] . precip != null ) str = str + past . hourlyPast [ i ] . precip . toString ( ) ; str = str + " " ; HAout . println ( str ) ; } } }
tr	0	public Integer getNum ( ) { return num ; }
tr	3	private String findTag ( String text , String startToken , String endToken , int fromIndex ) { int startIndex = text . indexOf ( startToken , fromIndex ) ; int endIndex = text . indexOf ( endToken , startIndex ) ; if ( startIndex >= 0 && endIndex > 0 && endIndex > startIndex ) return text . substring ( startIndex , endIndex + endToken . length ( ) ) ; return null ; }
tr	8	@ Override protected void handleAttribute ( XMLStreamReader parser , int i ) { if ( parser . getAttributeLocalName ( i ) == "Font" ) { fontType = Font . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontColor" ) { fontColor = setColorKeepAlpha ( fontColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontAlpha" ) { fontColor = setAlphaKeepColor ( fontColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "Opac" ) { opac = true ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundColor" ) { backgroundColor = setColorKeepAlpha ( backgroundColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundAlpha" ) { backgroundColor = setAlphaKeepColor ( backgroundColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextX" ) { TextX = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextY" ) { TextY = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } super . handleAttribute ( parser , i ) ; }
tr	8	private boolean interpolateCollection ( Object obj , String basePath , Field field ) throws IllegalAccessException , InterpolationException { Collection c = ( Collection ) field . get ( obj ) ; if ( c != null && ! c . isEmpty ( ) ) { List originalValues = new ArrayList ( c ) ; try { c . clear ( ) ; } catch ( UnsupportedOperationException e ) { warningCollector . add ( new ObjectInterpolationWarning ( "Field is an unmodifiable collection. Skipping interpolation." , basePath + "." + field . getName ( ) , e ) ) ; return true ; } for ( Object value : originalValues ) { if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { c . add ( interpolated ) ; } else { c . add ( value ) ; } } else { c . add ( value ) ; if ( value . getClass ( ) . isArray ( ) ) { evaluateArray ( value , basePath + "." + field . getName ( ) ) ; } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "." + field . getName ( ) ) ) ; } } } else { c . add ( value ) ; } } } return false ; }
tr	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	5	public static void main ( String [ ] args ) { RedBlackTree < Integer > t = new RedBlackTree < > ( ) ; final int NUMS = 400000 ; final int GAP = 35461 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( i ) ; if ( t . findMin ( ) != 1 || t . findMax ( ) != NUMS - 1 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 1 ; i < NUMS ; i ++ ) if ( ! t . contains ( i ) ) System . out . println ( "Find error1!" ) ; }
tr	6	public void clickActionListener ( final JButton btn ) { btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { for ( int i = 0 ; i < suggestedButtonsNames . length ; i ++ ) if ( existingBoats . contains ( suggestedButtonsNames [ i ] ) ) { System . out . println ( "Ne mozes postaviti brod na to polje!" ) ; return ; } int sifraBroda = workingFrame . updateLabels ( ) ; if ( ( sifraBroda ) != - 1 ) { for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) { if ( myButtonGameBoard [ i ] [ j ] . isBorderPainted ( ) ) { existingBoats . add ( myButtonGameBoard [ i ] [ j ] . getName ( ) ) ; myButtonGameBoard [ i ] [ j ] . setIcon ( shipImage ) ; gameBoardMask . FillStartMatrix ( i , j , sifraBroda ) ; } } } gameBoardMask . ispisi ( ) ; logicMatrix = gameBoardMask . gameBoard ; } } ) ; }
tr	0	@ XmlElementDecl ( namespace = "" , name = "xRequest" ) public JAXBElement < BigInteger > createXRequest ( BigInteger value ) { return new JAXBElement < BigInteger > ( _XRequest_QNAME , BigInteger . class , null , value ) ; }
tr	8	public BinaryStrings ( double mutationRate , double recombinationRate , int recombinationSplit , int maxMutations ) { try { if ( recombinationRate > 1.0 || recombinationRate < 0.0 ) { throw new Exception ( "Crossover rate outside range 0.0-1.0" ) ; } this . recombinationRate = recombinationRate ; if ( recombinationSplit > 2 || recombinationSplit < 1 ) { throw new Exception ( "Crossover split is outside range  accepted values are 1 and 2  got " + recombinationSplit ) ; } this . recombinationSplit = recombinationSplit ; if ( mutationRate > 1.0 || mutationRate < 0.0 ) { throw new Exception ( "Mutation rate outside range 0.0-1.0" ) ; } this . mutationRate = mutationRate ; if ( maxMutations < 1 ) throw new Exception ( "Can't have 0 or negative mutations!" ) ; this . maxMutations = maxMutations ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	3	public static void main ( String [ ] args ) { SalariedEmployee salariedEmployee = new SalariedEmployee ( "John" , "Smith" , "111-11-1111" , 800.00 ) ; HourlyEmployee hourlyEmployee = new HourlyEmployee ( "Karen" , "Price" , "222-22-2222" , 16.75 , 40 ) ; CommissionEmployee commissionEmployee = new CommissionEmployee ( "Sue" , "Jones" , "333-33-3333" , 10000 , .06 ) ; BasePlusCommissionEmployee basePlusCommissionEmployee = new BasePlusCommissionEmployee ( "Bob" , "Lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; System . out . println ( "Employees processed individually:\n" ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , salariedEmployee , "earned" , salariedEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyEmployee , "earned" , hourlyEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , commissionEmployee , "earned" , commissionEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , basePlusCommissionEmployee , "earned" , basePlusCommissionEmployee . earnings ( ) ) ; Employee [ ] employees = new Employee [ 4 ] ; employees [ 0 ] = salariedEmployee ; employees [ 1 ] = hourlyEmployee ; employees [ 2 ] = commissionEmployee ; employees [ 3 ] = basePlusCommissionEmployee ; System . out . println ( "Employees processed polymorphically:\n" ) ; for ( Employee currentEmployee : employees ) { System . out . println ( currentEmployee ) ; if ( currentEmployee instanceof BasePlusCommissionEmployee ) { BasePlusCommissionEmployee employee = ( BasePlusCommissionEmployee ) currentEmployee ; employee . setBaseSalary ( 1.10 * employee . getBaseSalary ( ) ) ; System . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getBaseSalary ( ) ) ; } System . out . printf ( "earned $% .2f\n\n" , currentEmployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) System . out . printf ( "Employee %d is a %s\n" , j , employees [ j ] . getClass ( ) . getName ( ) ) ; }
tr	0	public Logger getLogger ( ) { return this . logger ; }
tr	8	public void method545 ( Stream stream , Class29 class29 ) { int i = stream . readUnsignedByte ( ) ; anIntArray665 [ 0 ] = i >> 4 ; anIntArray665 [ 1 ] = i & f ; if ( i != 0 ) { anIntArray668 [ 0 ] = stream . readUnsignedWord ( ) ; anIntArray668 [ 1 ] = stream . readUnsignedWord ( ) ; int j = stream . readUnsignedByte ( ) ; for ( int k = 0 ; k < 2 ; k ++ ) { for ( int l = 0 ; l < anIntArray665 [ k ] ; l ++ ) { anIntArrayArrayArray666 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; } } for ( int i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( int j1 = 0 ; j1 < anIntArray665 [ i1 ] ; j1 ++ ) if ( ( j & 1 << i1 * 4 << j1 ) != 0 ) { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; } else { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray666 [ i1 ] [ 0 ] [ j1 ] ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray667 [ i1 ] [ 0 ] [ j1 ] ; } } if ( j != 0 || anIntArray668 [ 1 ] != anIntArray668 [ 0 ] ) class29 . method326 ( stream ) ; } else { anIntArray668 [ 0 ] = anIntArray668 [ 1 ] = 0 ; } }
tr	0	public void arrayToTable ( Type type ) { int array = newLocal ( type ) ; int table = newLocal ( OBJ_TABLE ) ; int limit = newLocal ( INT_TYPE ) ; int counter = newLocal ( INT_TYPE ) ; Type entry = getEntryType ( type ) ; Label loopBody = new Label ( ) ; Label loopEnd = new Label ( ) ; dup ( ) ; storeLocal ( array ) ; arrayLength ( ) ; storeLocal ( limit ) ; push0 ( ) ; storeLocal ( counter ) ; newInstance ( OBJ_TABLE ) ; dup ( ) ; visitMethodInsn ( INVOKESPECIAL , TABLE , "<init>" , "()V" ) ; storeLocal ( table ) ; goto ( loopEnd ) ; visitLabel ( loopBody ) ; loadLocal ( table ) ; loadLocal ( counter ) ; push1 ( ) ; math ( ADD , INT_TYPE ) ; loadLocal ( array ) ; loadLocal ( counter ) ; arrayLoad ( entry ) ; varToLua ( entry ) ; visitMethodInsn ( INVOKEVIRTUAL , TABLE , "rawset" , "(ILjava/lang/Object;)V" ) ; iinc ( counter , 1 ) ; visitLabel ( loopEnd ) ; loadLocal ( counter ) ; loadLocal ( array ) ; arrayLength ( ) ; ifICmp ( < , loopBody ) ; loadLocal ( table ) ; }
tr	2	public void Insertar ( String dato , String cuentaBancaria ) { NodoDeLista nuevo ; nuevo = new NodoDeLista ( ) ; nuevo . setDato ( dato ) ; nuevo . setCuentaBancaria ( cuentaBancaria ) ; if ( raiz == null ) { nuevo . setSiguiente ( null ) ; raiz = nuevo ; } else { NodoDeLista auxiliar = raiz ; while ( auxiliar . getSiguiente ( ) != null ) { auxiliar = auxiliar . getSiguiente ( ) ; } auxiliar . setSiguiente ( nuevo ) ; } }
tr	6	private int [ ] getToken ( String line , int startingPoint ) { int [ ] ret = new int [ 3 ] ; if ( splitter != null ) { int nextSplit = line . indexOf ( splitter , startingPoint ) ; ret [ 0 ] = startingPoint ; ret [ 1 ] = nextSplit >= 0 ? nextSplit : line . length ( ) ; ret [ 2 ] = nextSplit >= 0 ? nextSplit + splitter . length ( ) : line . length ( ) - 1 ; } else { int startBeginner = line . indexOf ( fieldStarter , startingPoint ) ; ret [ 0 ] = startBeginner >= 0 ? startBeginner + fieldStarter . length ( ) : line . length ( ) ; int startEnder = line . indexOf ( fieldStopper , ret [ 0 ] ) ; ret [ 1 ] = startEnder >= 0 ? startEnder : line . length ( ) - 1 ; ret [ 2 ] = startEnder >= 0 ? startEnder + fieldStopper . length ( ) : line . length ( ) - 1 ; } return ret ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ListaDinamica ( ) . setVisible ( true ) ; } } ) ; }
tr	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	4	public static boolean getActionState ( int player , ACTION a ) { if ( player < 0 || player + 1 > KeyboardInput . number_players ) { DebugConsole . PrintError ( "Invalid player number: " + player ) ; return false ; } if ( KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] == true && KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] == true ) { KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] = false ; KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] = false ; return true ; } else return false ; }
tr	7	public void killHappenedAt ( PointI p , int mobSize , boolean wasSplashDamage ) { if ( ( p . x < 0 ) || ( p . y < 0 ) || ( p . x >= w ) || ( p . y >= h ) ) return ; double amount = 1f / mobSize / mobSize ; for ( int y = 0 ; y < mobSize ; y ++ ) { for ( int x = 0 ; x < mobSize ; x ++ ) { if ( wasSplashDamage ) { splashKillCounts [ p . y + y ] [ p . x + x ] += amount ; } else { normalKillCounts [ p . y + y ] [ p . x + x ] += amount ; } } } }
tr	1	public static final < T extends Node < T >> void checkSameGraphs ( final Graph < T > g1 , final Graph < T > g2 ) { if ( g1 . getName ( ) . equals ( g2 . getName ( ) ) == false ) { throw new IllegalStateException ( "The two graphs are not same." ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Menu ( ) . setVisible ( true ) ; } } ) ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	6	@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { super . startElement ( uri , localName , qName , attributes ) ; if ( qName . equals ( "question" ) ) { String type = attributes . getValue ( "type" ) ; String num = attributes . getValue ( "number" ) ; if ( type != null && num != null ) { int n = Integer . parseInt ( num ) ; if ( type . equals ( "multiple_choice" ) ) this . reader . setContentHandler ( new MultipleChoiceHandler ( this . reader , this , n ) ) ; else if ( type . equals ( "short_answer" ) ) this . reader . setContentHandler ( new ShortAnswerHandler ( this . reader , this , n ) ) ; else if ( type . equals ( "file_submission" ) ) this . reader . setContentHandler ( new FileSubmissionHandler ( this . reader , this , n ) ) ; } } }
tr	7	public String getPopulationDetails ( Field field ) { StringBuffer buffer = new StringBuffer ( ) ; if ( ! countsValid ) { generateCounts ( field ) ; } for ( class key : counters . keySet ( ) ) { Counter info = counters . get ( key ) ; int stringLength = info . getName ( ) . length ( ) ; buffer . append ( info . getName ( ) . substring ( 10 , stringLength ) ) ; buffer . append ( ": " ) ; buffer . append ( info . getCount ( ) ) ; buffer . append (   ) ; if ( info . getName ( ) . equals ( "src.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Bear" ) ) { bearCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Grass" ) ) { grassCount = info . getCount ( ) ; } } return buffer . toString ( ) ; }
tr	4	@ Override public int compareTo ( Card o ) { if ( rank . getValue ( ) < o . rank . getValue ( ) ) { return - 1 ; } else if ( rank . getValue ( ) > o . rank . getValue ( ) ) { return 1 ; } return suit . getValue ( ) < o . suit . getValue ( ) ? - 1 : suit . getValue ( ) == o . suit . getValue ( ) ? 0 : 1 ; }
tr	7	public Object getValueAt ( Object node , int column ) { FileNode fn = ( FileNode ) node ; try { switch ( column ) { case 0 : return fn . getFile ( ) . getName ( ) ; case 1 : if ( fn . isTotalSizeValid ( ) ) { return new Integer ( ( int ) ( ( FileNode ) node ) . totalSize ( ) ) ; } return null ; case 2 : return fn . isLeaf ( ) ? "File" : "Directory" ; case 3 : return fn . lastModified ( ) ; } } catch ( SecurityException se ) { } return null ; }
tr	3	@ Override public String toString ( ) { String result = null ; for ( SNode < E > nodeIt = this . frontNode ; nodeIt != null ; nodeIt = nodeIt . nextNode ) { if ( result == null ) { result = "[" + nodeIt . getElement ( ) . toString ( ) + "]" ; } else { result += " " + nodeIt . getElement ( ) . toString ( ) ; } } return result == null ? "empty" : result ; }
tr	2	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	0	private PlayerPanel buildSecondPlayerPanel ( ) { return new ComputerPlayerPanel ( controller , PlayerSide . RIGHT ) ; }
tr	0	public boolean checkForFever ( final Person p , final Megameter m ) { return m . isBreathing ( p ) ; }
tr	2	public TestClient ( int port , String name ) { try { count ++ ; socket = new Socket ( InetAddress . getLocalHost ( ) , port ) ; this . name = name ; this . setName ( "TestClientThread-" + count ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	3	@ Override public void printOptions ( ) { if ( getSuccessors ( ) == null || getSuccessors ( ) . size ( ) == 0 ) { return ; } Printer . print ( Settings_Output . OUT_OPTION_HEAD , "Please choose an option" ) ; Integer i = 0 ; for ( final IAction action : getSuccessors ( ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , action . getName ( ) , action . getDescription ( ) ) ; i ++ ; } }
tr	8	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; this . isAltitudeModeDirty = false ; if ( this . location != null && this . location . isDirty ( ) ) { this . location . setRecursiveNotDirty ( ) ; } if ( this . orientation != null && this . orientation . isDirty ( ) ) { this . orientation . setRecursiveNotDirty ( ) ; } if ( this . scale != null && this . scale . isDirty ( ) ) { this . scale . setRecursiveNotDirty ( ) ; } if ( this . link != null && this . link . isDirty ( ) ) { this . link . setRecursiveNotDirty ( ) ; } }
tr	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new DoctorClient ( ) ; } catch ( UnknownHostException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	7	public void setSelectedOC ( OutputConnector selectedOC , Component comp ) { if ( this . selectedOC != null ) this . selectedOC . setSelected ( true ) ; this . selectedOC = selectedOC ; this . selectedOC . setSelected ( true ) ; connectables = new ArrayList < InputConnector > ( ) ; for ( Component e : getElements ( ) ) { if ( e == comp ) continue ; if ( e instanceof InputStub ) continue ; for ( Connector c : e . getConnectors ( ) ) { if ( c instanceof InputConnector ) if ( ! ( ( InputConnector ) c ) . isConnected ( ) ) connectables . add ( ( InputConnector ) c ) ; } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SpikeTester ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public static void main ( String [ ] args ) { System . setOut ( new VOut ( System . out ) ) ; VEngineLogo vl = new VEngineLogo ( ) ; vl . setVisible ( true ) ; cfg = VFileReader . readCFG ( new File ( new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) + "/configurations/game.cfg" ) ) ; cfg . s ( "home" , new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) ) ; cfg . s ( "modhome" , new File ( System . getProperty ( "user.home" ) + "/.vau/mods/" + cfg . g ( "mod" ) + "/" ) . getAbsolutePath ( ) + "/" ) ; for ( String param : args ) { try { String [ ] pr = param . split ( "=" ) ; cfg . s ( pr [ 0 ] , pr [ 1 ] ) ; } catch ( Exception e ) { } } System . out . println ( cfg ) ; try { System . setProperty ( "java.library.path" , new File ( cfg . g ( "home" ) + "/native" ) . getAbsolutePath ( ) ) ; Field fieldSysPath = ClassLoader . class . getDeclaredField ( "sys_paths" ) ; fieldSysPath . setAccessible ( true ) ; try { fieldSysPath . set ( null , null ) ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( IllegalAccessException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } } catch ( NoSuchFieldException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( SecurityException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } Music openingMenuMusic ; try { openingMenuMusic = new Music ( new File ( System . getProperty ( "user.home" ) + "/.vau/music/watchword.ogg" ) . getAbsolutePath ( ) ) ; if ( cfg . g ( "music" ) . equals ( "enabled" ) ) { openingMenuMusic . loop ( ) ; } } catch ( SlickException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } VGraphics . start ( ) ; VProcessor . add ( new vexamples . units . VPlayer ( ) ) ; VProcessor . add ( new vexamples . units . VUnit ( ) ) ; VProcessor . add ( new vexamples . units . VBullet ( ) ) ; VMenu vm = new VMenu ( ) ; vl . setVisible ( false ) ; }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	8	public String evaluateRiskColumn_innerMethod ( TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { System . err . println ( "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = columnRiskEvaluator ( mySQLFactory ) ; return result ; }
tr	3	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
tr	9X	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Option option = ( Option ) o ; if ( idoption != option . idoption ) return false ; if ( surveyIdsurvey != option . surveyIdsurvey ) return false ; if ( content != null ? ! content . equals ( option . content ) : option . content != null ) return false ; if ( number != null ? ! number . equals ( option . number ) : option . number != null ) return false ; return true ; }
tr	6	public static void copyFilebyBufferedOutputStream ( File file ) throws IOException { FileInputStream fis = null ; BufferedInputStream bis = null ; FileOutputStream fos = null ; BufferedOutputStream bos = null ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; fos = new FileOutputStream ( file . getName ( ) + ".bak" ) ; bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { bos . write ( buffer , 0 , bytesRead ) ; } bos . flush ( ) ; } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( bis != null ) bis . close ( ) ; if ( fos != null ) fos . close ( ) ; if ( bos != null ) bos . close ( ) ; } }
tr	4	private void setUsersState ( int state ) { final int columnId = 0 ; if ( tableUsers . getSelectedRow ( ) != - 1 ) { int userId = ( Integer ) tableUsers . getValueAt ( tableUsers . getSelectedRow ( ) , columnId ) ; Statement statement = null ; ResultSet result = null ; try { statement = usersDAO . getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( usersDAO . getAllQuery ( ) ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == userId ) { break ; } } result . updateInt ( "USERSTATE" , state ) ; result . updateRow ( ) ; usersDAO = new UsersDAO ( ) ; usersDAO . initTableModel ( tableUsers , usersDAO . listAll ( ) ) ; } catch ( SQLException exc ) { JOptionPane . showMessageDialog ( this , "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } } else { JOptionPane . showMessageDialog ( this , "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435!" ) ; return ; } }
tr	3	public FHashMap < Key , Val > less ( Key key ) { Object t = less ( tree , key , hashCode ( key ) ) ; if ( t == tree ) return this ; else if ( t == null && dflt == null ) return emptyMap ( ) ; else return new FHashMap < Key , Val > ( t , dflt ) ; }
tr	3	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	1	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { editNameLabel = new javax . swing . JLabel ( ) ; editNameField = new javax . swing . JTextField ( ) ; editTypeLabel = new javax . swing . JLabel ( ) ; editTypeDropdown = new javax . swing . JComboBox ( ) ; editValueLabel = new javax . swing . JLabel ( ) ; editCancelButton = new javax . swing . JButton ( ) ; editSaveButton = new javax . swing . JButton ( ) ; editValueField = new javax . swing . JTextField ( ) ; editValueValidationLabel = new javax . swing . JLabel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setTitle ( "Editing key " + key ) ; editNameLabel . setText ( "Key:" ) ; editNameField . setText ( this . key ) ; editTypeLabel . setText ( "Type:" ) ; editTypeDropdown . setModel ( new javax . swing . DefaultComboBoxModel ( ValueTypes . values ( ) ) ) ; editTypeDropdown . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editTypeDropdownActionPerformed ( evt ) ; } } ) ; editValueLabel . setText ( "Value:" ) ; editCancelButton . setText ( "Cancel" ) ; editCancelButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editCancelButtonActionPerformed ( evt ) ; } } ) ; editSaveButton . setText ( "Save" ) ; editSaveButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editSaveButtonActionPerformed ( evt ) ; } } ) ; editValueField . setText ( this . value != null ? this . value . toString ( ) : "" ) ; editValueField . setInputVerifier ( new EditValueFieldInputVerifier ( ) ) ; editValueField . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { editValueFieldKeyTyped ( evt ) ; } } ) ; editValueValidationLabel . setIcon ( UIManager . getIcon ( "OptionPane.warningIcon" ) ) ; editValueValidationLabel . setText ( "jLabel1" ) ; editValueValidationLabel . setVisible ( false ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( editNameLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editNameField ) . addComponent ( editTypeLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editTypeDropdown , 0 , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editValueLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addGap ( 0 , 244 , short . MAX_VALUE ) . addComponent ( editSaveButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editCancelButton ) ) . addComponent ( editValueField ) . addComponent ( editValueValidationLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( editNameLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editNameField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editTypeLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editTypeDropdown , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editValueLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editValueField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addComponent ( editValueValidationLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 79 , short . MAX_VALUE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( editCancelButton ) . addComponent ( editSaveButton ) ) . addContainerGap ( ) ) ) ; pack ( ) ; }
tr	7	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	1	@ Test public void testGetArgument ( ) { initializeArguments ( ) ; InputDefinition definition = new InputDefinition ( ) ; definition . addArguments ( Arrays . asList ( ( InputArgument ) foo ) ) ; assertEquals ( "getArgument() returns a InputArgument by its name" , foo , definition . getArgument ( "foo" ) ) ; try { definition . getArgument ( "bar" ) ; fail ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" ) ; } catch ( Exception e ) { assertTrue ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" , e instanceof IllegalArgumentException ) ; assertEquals ( "The \"bar\" argument does not exist." , e . getMessage ( ) ) ; } }
tr	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
tr	7	@ Override public synchronized int registerClient ( String client_name , String first_tag , String second_tag ) { try { final NameComponent [ ] clientName = { new NameComponent ( client_name , "Object" ) } ; final Client client = ClientHelper . narrow ( namingContext . resolve ( clientName ) ) ; if ( first_tag . equals ( "T" ) || second_tag . equals ( "T" ) ) { clientUpdater . appendTemperatureClient ( client ) ; } if ( first_tag . equals ( "P" ) || second_tag . equals ( "P" ) ) { clientUpdater . appendPressureClient ( client ) ; } if ( first_tag . equals ( "H" ) || second_tag . equals ( "H" ) ) { clientUpdater . appendHumidityClient ( client ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return 0 ; }
tr	8	private QuerySet < T > isNull ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . trim ( ) . toLowerCase ( ) ; query = query . replace ( "__isnull" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; boolean isNull = boolean . parseBoolean ( queryComponents [ 1 ] ) ; Field field = null ; try { if ( fieldName . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { if ( isNull ) { if ( field . get ( model ) == null ) { querySet . add ( model ) ; } } else { if ( field . get ( model ) != null ) { querySet . add ( model ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
tr	7	@ Override public void processCommand ( String ... args ) throws SystemCommandException { String matriculation = args [ 0 ] ; String result = "" ; Student student = facade . selectStudent ( matriculation ) ; if ( student != null ) { result += "Matriculation:\t" + student . getMatriculation ( ) + "\n" + "Name:\t" + student . getSurname ( ) + "  " + student . getForename ( ) + "\n" + "Programme:\t" + student . getProgramme ( ) + "\n" ; Internship internship = student . getInternship ( ) ; if ( internship != null ) { result += "Status:\t" + internship . getStatus ( ) + "\n" + "Manager:\t" + internship . getManager ( ) + "\n" + "Email:\t" + internship . getManagerEmail ( ) + "\n" ; } Role role = internship . getRole ( ) ; if ( role != null ) result += "Role\t:" + role . getTitle ( ) + "\n" + "Begin:\t" + formatDate ( role . getStart ( ) ) + "\n" + "End:\t" + formatDate ( role . getEnd ( ) ) + "\n" + "Salary:\t" + role . getSalary ( ) + "\n" + "Location\t:" + role . getLocation ( ) + "\n" ; Employer employer = internship . getEmployer ( ) ; if ( employer != null ) result += "Employer:\t" + employer . getName ( ) ; Visit visit = internship . getVisit ( ) ; if ( visit != null ) { Visitor visitor = visit . getVisitor ( ) ; if ( visitor != null ) result += "Visitor:\t" + visitor . getName ( ) + "\n" ; UoGGrade grade = visit . getGrade ( ) ; if ( grade != null ) { result += "Grade:\t" + grade + "\n" ; result += "Description:\t" + visit . getDescription ( ) + "\n" ; } } } dialogue . sendMessage ( result ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new viewNGram ( ) . setVisible ( true ) ; } } ) ; }
tr	3	public void switchFullscreen ( ) { if ( fullscreen == false ) { throw new IllegalStateException ( "This window not supports fullscreen mode!" ) ; } if ( state == WindowState . WINDOW ) { Rectangle rc = this . getBounds ( ) ; boolean resizable = this . isResizable ( ) ; this . properties = new FrameProperties ( getX ( ) , getY ( ) , ( int ) rc . getWidth ( ) , ( int ) rc . getHeight ( ) , resizable ) ; } if ( device . getFullScreenWindow ( ) == null ) { FrameProperties properties = new FrameProperties ( 0 , 0 , getFullWidth ( ) , getFullHeight ( ) , false ) ; this . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; this . state = WindowState . FULLSCREEN ; properties . append ( this ) ; device . setFullScreenWindow ( this ) ; updateDisplay ( ) ; return ; } device . setFullScreenWindow ( null ) ; this . setExtendedState ( JFrame . NORMAL ) ; this . state = WindowState . WINDOW ; properties . append ( this ) ; updateDisplay ( ) ; }
tr	6	public void write ( SelectionKey key ) throws IOException { loggerNetworkClient . info ( "WRITE: " ) ; FileService fileService ; ByteBuffer wBuff = ByteBuffer . allocate ( NetworkInfo . BUF_SIZE ) ; SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; int toWrite ; synchronized ( key ) { while ( wbuf . size ( ) > 0 ) { byte [ ] bbuf = wbuf . get ( 0 ) ; wbuf . remove ( 0 ) ; if ( bbuf . length < NetworkInfo . BUF_SIZE ) { wBuff . clear ( ) ; wBuff . put ( bbuf ) ; wBuff . flip ( ) ; } else { toWrite = NetworkInfo . BUF_SIZE ; wBuff . clear ( ) ; wBuff . put ( bbuf , 0 , toWrite ) ; wBuff . flip ( ) ; } int numWritten = socketChannel . write ( wBuff ) ; loggerNetworkClient . info ( "I wrote " + numWritten + " bytes on the socket associated with the key" + key ) ; if ( this . dataToSend instanceof FileService ) { fileService = ( FileService ) dataToSend ; offset += numWritten ; network . med . acceptFileTransfer ( fileService . serviceName , 100 * offset / sizeToWrite ) ; } if ( numWritten < bbuf . length ) { byte [ ] newBuf = new byte [ bbuf . length - numWritten ] ; for ( int i = numWritten ; i < bbuf . length ; i ++ ) { newBuf [ i - numWritten ] = bbuf [ i ] ; } wbuf . add ( 0 , newBuf ) ; break ; } if ( wbuf . size ( ) == 0 ) { key . interestOps ( SelectionKey . OP_READ ) ; } } } }
tr	6	public String nextTo ( String delimiters ) { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	5	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	5	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	5	public static void connectHelper2 ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left != null && root . right != null ) { TreeLinkNode rootLeft = root . right . left ; TreeLinkNode rootRight = root . left . right ; while ( rootLeft != null && rootRight != null ) { rootRight . next = rootLeft ; rootRight = rootRight . right ; rootLeft = rootLeft . left ; } connectHelper2 ( root . left ) ; connectHelper2 ( root . right ) ; } }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	2	public void run ( ) { for ( String name : names ) { Apple apple = new Apple ( name ) ; dispatcher . dataReceived ( apple ) ; System . out . println ( "Built apple: " + apple ) ; try { Thread . sleep ( 900 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } dispatcher . dataReceived ( new Key ( all ( Apple . class ) ) ) ; }
tr	7	public static boolean logIn ( String username , String password , JFrame frame ) { try { System . out . println ( "Checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The username is invalid  please try an other one." , "Invalid Username" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The password is invalid  please try an other one." , "Invalid Password" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=existsPlayer&name=" + username ) ) { JOptionPane . showMessageDialog ( frame , "The player does not exits." + "Please try an other username." , "Player does not exist" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=login&name=" + username + "&pass=" + password ) ) { JOptionPane . showMessageDialog ( frame , "The combination of username and passowrd is incorrect." + System . lineSeparator ( ) + "Please try again.'" + System . lineSeparator ( ) + "If you have forgotten your password  visit sinius15.com." , "Invalid login" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "There seems to be a problem with the connection to the server" + System . lineSeparator ( ) + "You can start the game in offline mode if you still want to play." + System . lineSeparator ( ) + "We are verry sorry for the inconvenience caused." , "Problem" , JOptionPane . ERROR_MESSAGE ) ; return false ; } return true ; }
tr	1	void configure ( ImageAnalyzerFactory mediator ) throws TesseractException { mediator . handle . setPageSegMode ( psm ) ; for ( String name : properties . keySet ( ) ) { String value = properties . get ( name ) ; mediator . handle . setVariable ( name , value ) ; } }
tr	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	2	public void append ( Color fg , Color bg , String text ) { try { StyledDocument doc = ( StyledDocument ) getDocument ( ) ; Style style = doc . addStyle ( "StyleName" , null ) ; if ( bg != null ) StyleConstants . setBackground ( style , bg ) ; StyleConstants . setForeground ( style , fg ) ; doc . insertString ( doc . getLength ( ) , text , style ) ; } catch ( BadLocationException ignored ) { } }
tr	9X	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	2	public void save ( String filename ) { PrintWriter pw = null ; try { pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( filename ) ) ) ; pw . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; pw . println ( "<dmc prob=\"" + totalProb + "\">" ) ; for ( State st : this . estats ) { st . writeMarkov ( pw ) ; } pw . println ( "</dmc>" ) ; } catch ( IOException ex ) { System . err . println ( "Error saving DMC" ) ; } finally { pw . close ( ) ; } }
tr	6	@ Override public ArrayList < Sign > getSigns ( Location loc ) { Location sloc ; List < BlockFace > checklist = new ArrayList < BlockFace > ( ) ; checklist . add ( BlockFace . NORTH ) ; checklist . add ( BlockFace . EAST ) ; checklist . add ( BlockFace . SOUTH ) ; checklist . add ( BlockFace . WEST ) ; ArrayList < Sign > signList = new ArrayList < Sign > ( ) ; loc . setY ( loc . getBlockY ( ) - 2 ) ; if ( loc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) loc . getBlock ( ) . getState ( ) ) ; } loc . setY ( loc . getBlockY ( ) + 1 ) ; for ( BlockFace bf : checklist ) { sloc = loc . getBlock ( ) . getRelative ( bf ) . getLocation ( ) ; if ( sloc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) sloc . getBlock ( ) . getState ( ) ) ; } } loc . setY ( loc . getBlockY ( ) + 1 ) ; for ( BlockFace bf : checklist ) { sloc = loc . getBlock ( ) . getRelative ( bf ) . getLocation ( ) ; if ( sloc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) sloc . getBlock ( ) . getState ( ) ) ; } } loc . setY ( loc . getBlockY ( ) + 1 ) ; if ( loc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) loc . getBlock ( ) . getState ( ) ) ; } return signList ; }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProcDescriptor other = ( ProcDescriptor ) obj ; if ( labelInAssembler != other . labelInAssembler ) return false ; if ( lokal == null ) { if ( other . lokal != null ) return false ; } else if ( ! lokal . equals ( other . lokal ) ) return false ; return true ; }
tr	3	private void carregaPreuTipusHabitacions ( ) { String [ ] nomsHotels = { "Palace" , "Hilton" , "Metropolitan" , "Arts" , "Catalunya" , "Pensi\u00F3n Pepe" , "Bonjour" , "Oulala" } ; String [ ] nomsTipus = { "Individual" , "Doble" , "Matrimoni" } ; float [ ] preus = { 100 , 200 , 250 } ; for ( int i = 0 ; i < nomsHotels . length ; ++ i ) { for ( int j = 0 ; j < nomsTipus . length ; ++ j ) { PreuTipusHabitacio pth = new PreuTipusHabitacio ( ) ; pth . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pth . setPreu ( preus [ j ] ) ; if ( j == 0 ) { AbsoluteDiscountPreuStrategy adps = new AbsoluteDiscountPreuStrategy ( ) ; adps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; adps . setDescompte ( 30 ) ; pth . setStrategy ( adps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( adps ) ; } else { PercentDiscountPreuStrategy pdps = new PercentDiscountPreuStrategy ( ) ; pdps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pdps . setPerc ( 0.7F ) ; pth . setStrategy ( pdps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( pdps ) ; } } } }
tr	4	@ Test public void testNaissanceSoldats ( ) { SalleSoldat testSoldat = new SalleSoldat ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testSoldat . naissanceSoldats ( 2 , sn ) ; assertEquals ( 1 , testSoldat . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testSoldat . naissanceSoldats ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testSoldat . naissanceSoldats ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
tr	8	public boolean wordBreak2 ( String s , Set < String > dict ) { if ( s == null || s . length ( ) == 0 || dict == null ) { return true ; } int length = s . length ( ) ; boolean [ ] dp = new boolean [ length + 1 ] ; for ( boolean b : dp ) { b = false ; } dp [ length ] = true ; for ( int i = length - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < length ; j ++ ) { String - = s . substring ( i , j + 1 ) ; if ( dict . contains ( - ) == true && dp [ j + 1 ] == true ) { dp [ i ] = true ; break ; } } } return dp [ 0 ] ; }
tr	3	public void add ( Category category ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . save ( category ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	0	public boolean blocksLineOfSight ( ) { return false ; }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	8	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p >= N && q >= N ) { return false ; } else if ( a >= M && b >= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	9X	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; int [ ] p2 ; int p3 ; double p4 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 5 } ; p3 = 10 ; p4 = 0.5D ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.0D ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 10 } ; p1 = new int [ ] { 10 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.4142135623730951D ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 11 , - 11 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 11 , - 11 } ; p2 = new int [ ] { 10 , 10 , 10 , 10 } ; p3 = 31 ; p4 = 0.3548387096774194D ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 100 } ; p1 = new int [ ] { 100 } ; p2 = new int [ ] { 1 } ; p3 = 10 ; p4 = 1.0D ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 1000000000 } ; p1 = new int [ ] { 1000000000 } ; p2 = new int [ ] { 1000000000 } ; p3 = 1000000000 ; p4 = 0.41421356237309503D ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 20 , - 20 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 20 , - 20 } ; p2 = new int [ ] { 50 , 50 , 50 , 50 } ; p3 = 100 ; p4 = 0.3D ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 , - 60 , - 62 , - 60 , 63 , - 97 } ; p1 = new int [ ] { - 72 , 67 , 61 , - 8 , - 32 , 89 } ; p2 = new int [ ] { 6 , 7 , 8 , 7 , 5 , 6 } ; p3 = 918 ; p4 = 0.9407071068962471D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 187730043 , 932334096 , 59236807 , - 602044448 , 441157147 , 569003535 , 563472630 , 493784941 , - 928345136 , - 198534684 , - 507361726 , - 486699261 , - 705601684 , - 671249417 , - 79879427 , 71698248 , 146683444 , 414416326 , 53196305 , - 666818573 , 178619454 , - 893182413 , 224302710 , 296990194 , - 885921154 , - 173521881 , - 493092068 , 900325848 , - 353242967 , - 631482448 , 112982750 , 553248219 , 264762102 , - 318102799 , - 836641673 , - 812311860 , - 73259832 , 609869565 , 650010687 , 155243096 , - 107417345 , 634247427 , - 841502473 , - 651719520 , - 958664893 , 480384188 , - 691415372 , 36346544 , 706329659 , 126652235 , 44403422 , - 263265167 , - 349491074 , 120258505 , 485027199 , - 240466308 , - 456782932 , 192953958 , - 261803363 , - 198063552 , 980391799 , 997148607 , 417112854 , - 333017353 , - 945493557 , 371446553 , 251150037 , - 960076588 , - 360362805 , - 305175580 , 208353048 , - 437834549 , - 420355623 , - 668454094 , 180494692 , 755143595 , 249998094 , 537726369 , 343336414 , 495586169 , 35446018 , 131243302 , 501744441 , 739753520 , - 876687692 , 560013605 , - 443087342 , 455209428 , 333669368 , 398118304 , - 695213876 , 527566904 , - 463103162 , - 317355625 , 641069703 , - 947785900 , - 532490870 , - 963111776 , - 727898154 , 748858912 } ; p1 = new int [ ] { 452827103 , 247175647 , 11753377 , - 611873763 , - 531081305 , 859586805 , - 868286674 , - 876539858 , 304963335 , 990345765 , - 859353631 , - 475065113 , - 574709927 , 131112520 , - 846074893 , 464742988 , - 41360301 , 899849149 , - 266820064 , - 251052777 , 226747686 , 876712903 , - 350309643 , 131456902 , - 799664596 , 453822371 , - 617483392 , 755895436 , - 72097080 , 199834107 , - 619495741 , - 922106677 , 229012084 , 419002428 , 38711443 , 293733516 , 633211140 , - 65526196 , - 776215532 , - 491310115 , - 23818472 , 792447417 , 726536324 , - 686011537 , - 140383515 , - 569321731 , - 402939093 , - 125768005 , - 18416939 , 127783325 , - 67341991 , - 322587512 , - 296995968 , - 536590267 , 437613161 , - 206640690 , - 825549222 , 102733497 , - 399947312 , 55751657 , 527107031 , - 152726436 , - 821534503 , 267030010 , - 528297582 , - 897079824 , - 521362885 , 1225411 , 460297398 , 596603062 , - 270748768 , 211858545 , - 654848212 , - 353416243 , 955853430 , - 447642704 , 739273996 , - 118039293 , 583896289 , - 253276293 , 632398992 , 560349797 , 222539806 , 677153439 , - 804423594 , - 285780470 , 782032960 , 23986706 , - 812231058 , 344193048 , 491603558 , 956077657 , - 97237599 , - 644202406 , - 311702606 , 645844112 , 47834815 , - 802896183 , 472801824 , 658244534 } ; p2 = new int [ ] { 4 , 7 , 4 , 4 , 5 , 1 , 8 , 4 , 5 , 7 , 8 , 3 , 5 , 5 , 9 , 5 , 8 , 5 , 6 , 7 , 7 , 8 , 10 , 6 , 10 , 6 , 3 , 4 , 5 , 1 , 5 , 8 , 9 , 8 , 2 , 3 , 1 , 9 , 8 , 5 , 8 , 6 , 9 , 2 , 2 , 9 , 9 , 2 , 6 , 4 , 8 , 2 , 4 , 9 , 7 , 5 , 5 , 2 , 1 , 9 , 2 , 5 , 6 , 10 , 4 , 9 , 4 , 4 , 10 , 1 , 10 , 9 , 8 , 10 , 2 , 2 , 9 , 10 , 3 , 4 , 6 , 10 , 5 , 1 , 9 , 3 , 5 , 5 , 4 , 5 , 5 , 5 , 1 , 10 , 6 , 7 , 1 , 1 , 10 , 2 } ; p3 = 1000000000 ; p4 = 0.999999094D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 196 , 450 , 79 , - 220 , - 916 , 991 , - 451 , 462 , - 58 , - 353 , - 500 , 783 , 816 , 511 } ; p1 = new int [ ] { 188 , 681 , - 234 , - 330 , - 14 , 991 , - 969 , 347 , - 458 , - 940 , 454 , - 28 , 767 , - 620 } ; p2 = new int [ ] { 64 , 31 , 60 , 49 , 65 , 100 , 1 , 98 , 33 , 66 , 52 , 45 , 69 , 2 } ; p3 = 1484 ; p4 = 0.22007657635156566D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	2	public String toString ( ) { String s = "{" ; for ( Location loc : getOccupiedLocations ( ) ) { if ( s . length ( ) > 1 ) s += "  " ; s += loc + "=" + get ( loc ) ; } return s + "}" ; }
tr	4	public static java . util . Date toUtilDateFromStrDateByFormat ( String p_strDate , String p_format ) throws ParseException { java . util . Date l_date = null ; java . text . DateFormat df = new java . text . SimpleDateFormat ( p_format ) ; if ( p_strDate != null && ( ! "" . equals ( p_strDate ) ) && p_format != null && ( ! "" . equals ( p_format ) ) ) { l_date = df . parse ( p_strDate ) ; } return l_date ; }
tr	9X	public List < Location > adjacentLocations ( Location location ) { assert location != null : "Null location passed to adjacentLocations" ; List < Location > locations = new LinkedList < Location > ( ) ; if ( location != null ) { int row = location . getRow ( ) ; int col = location . getCol ( ) ; for ( int roffset = - 1 ; roffset <= 1 ; roffset ++ ) { int nextRow = row + roffset ; if ( nextRow >= 0 && nextRow < depth ) { for ( int coffset = - 1 ; coffset <= 1 ; coffset ++ ) { int nextCol = col + coffset ; if ( nextCol >= 0 && nextCol < width && ( roffset != 0 || coffset != 0 ) ) { locations . add ( new Location ( nextRow , nextCol ) ) ; } } } } Collections . shuffle ( locations , rand ) ; } return locations ; }
tr	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final SondageReponse other = ( SondageReponse ) obj ; if ( this . id != other . id ) { return false ; } if ( this . id_sondage != other . id_sondage ) { return false ; } if ( this . choix != other . choix ) { return false ; } return true ; }
tr	9X	private boolean findBranchingRoute ( Agent a , Box obstacle ) { dir boxDir = null ; BacktrackTree root = new BacktrackTree ( a . desire . box . getAtField ( ) , a . getAtField ( ) , null ) ; BacktrackTree currentNode = null ; Set < BacktrackTree > closedSet = new HashSet < BacktrackTree > ( ) ; LinkedList < BacktrackTree > queue = new LinkedList < BacktrackTree > ( ) ; HashMap < Field , ArrayList < Field >> exploredStates = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( a . desire . box . getAtField ( ) ) ; exploredStates . put ( a . getAtField ( ) , tempList ) ; queue . add ( root ) ; currentNode = queue . pop ( ) ; while ( currentNode . boxLocation != a . desire . goal ) { boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > foundCommands = a . addPossibleCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation ) ; for ( Command command : foundCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( exploredStates . containsKey ( agentLocation ) ) { if ( exploredStates . get ( agentLocation ) . contains ( boxLocation ) ) continue ; else { exploredStates . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; exploredStates . put ( agentLocation , tempListe ) ; } BacktrackTree bt = new BacktrackTree ( boxLocation , agentLocation , command ) ; bt . parent = currentNode ; boolean setupInClosedSet = false ; for ( BacktrackTree closedTree : closedSet ) { if ( closedTree . agentLocation . x == bt . agentLocation . x && closedTree . agentLocation . y == bt . agentLocation . y && closedTree . boxLocation . x == bt . boxLocation . x && closedTree . boxLocation . y == bt . boxLocation . y ) { setupInClosedSet = true ; } } if ( ! setupInClosedSet ) { queue . add ( bt ) ; closedSet . add ( bt ) ; } } if ( queue . isEmpty ( ) ) { return false ; } currentNode = queue . pop ( ) ; } ArrayList < Command > commands = new ArrayList < Command > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; for ( Command command : commands ) { a . commandQueueDONOTUSE . add ( command ) ; } return true ; }
tr	4	public boolean contain ( Ticket ticket ) { if ( ! parkIsNull ( ) && park . contain ( ticket ) ) { return true ; } for ( ParkBoy boy : this . parkBoyList ) { if ( boy . contain ( ticket ) ) { return true ; } } return false ; }
tr	9X	public String fillStaffInfo ( String staffPos ) { DB . db . openConnection ( ) ; ResultSet rs = DB . db . staff ( ) ; StringBuffer info = new StringBuffer ( ) ; try { info . append ( "<table>" ) ; while ( rs . next ( ) ) { ResultSet res = DB . db . position ( rs . getInt ( "posid" ) ) ; while ( res . next ( ) ) { if ( res . getString ( "posdesc" ) . equalsIgnoreCase ( staffPos ) ) { if ( staffPos . equalsIgnoreCase ( "gp" ) ) { info . append ( "<tr><td>Dr. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ns" ) ) { info . append ( "<tr><td>R.N. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ma" ) ) { info . append ( "<tr><td>Med.As. <b>" ) ; } info . append ( rs . getString ( "lname" ) ) ; info . append ( "  " + rs . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( rs . getString ( "phone" ) + "</b></td></tr>" ) ; ResultSet ress = DB . db . qualification ( rs . getInt ( "qualid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Qualification: <b>" ) ; info . append ( ress . getString ( "qualdesc" ) + "</b></td></tr>" ) ; } ResultSet rss = DB . db . staffSchedule ( rs . getInt ( "id" ) ) ; while ( rss . next ( ) ) { ress = DB . db . hospital ( rss . getInt ( "hospid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Hospital: <b>" ) ; info . append ( ress . getString ( "name" ) + "</b></td></tr>" ) ; } } info . append ( "<tr></tr>" ) ; } } } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StartMedOfficer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
tr	1	private void printMessage ( String messageOut ) { if ( debug ) { System . out . print ( messageOut ) ; } }
tr	1	private void zero ( ) throws JSONException { if ( probe ) { log ( 0 ) ; } write ( 0 , 1 ) ; }
tr	4	public CalculatorFrame ( ) { setBounds ( 250 , 150 , 500 , 200 ) ; setLayout ( null ) ; setTitle ( "Super Calculator" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setResizable ( false ) ; calcPanel = new CalculatorPanel ( this ) ; add ( calcPanel ) ; setVisible ( true ) ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoSave ( ) ; } } @ Override public void windowOpened ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoOpen ( ) ; } } } ) ; System . out . println ( "Auto round: " + Settings . AUTOROUND . get ( ) ) ; }
tr	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( album == null ) ? 0 : album . hashCode ( ) ) ; result = prime * result + ( ( artist == null ) ? 0 : artist . hashCode ( ) ) ; result = prime * result + ( ( comment == null ) ? 0 : comment . hashCode ( ) ) ; result = prime * result + genre ; result = prime * result + ( ( title == null ) ? 0 : title . hashCode ( ) ) ; result = prime * result + ( ( track == null ) ? 0 : track . hashCode ( ) ) ; result = prime * result + ( ( year == null ) ? 0 : year . hashCode ( ) ) ; return result ; }
tr	0	public FenetreSupprimer ( ListeObjet listeObjets ) { this . setTitle ( Langue . getTraduction ( "delete_confirmation" ) ) ; JPanel fenetre = new JPanel ( new BorderLayout ( ) ) ; fenetre . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 5 , 10 ) ) ; this . add ( fenetre ) ; JButton buttonAnnuler = new JButton ( new AnnulerAction ( this , Langue . getTraduction ( "cancel" ) ) ) ; JButton buttonSupprimer = new JButton ( new ValiderSupprimerAction ( listeObjets , this ) ) ; JPanel panelSouth = new JPanel ( ) ; panelSouth . add ( buttonSupprimer ) ; panelSouth . add ( buttonAnnuler ) ; fenetre . add ( panelSouth , "South" ) ; JLabel label = new JLabel ( Langue . getTraduction ( "delete_query" ) ) ; fenetre . add ( label , "Center" ) ; this . afficherDialog ( ) ; }
tr	4	@ Override public void showHints ( int level ) { for ( int x = 1 ; x <= 16 ; x ++ ) { for ( int y = 1 ; y <= 16 ; y ++ ) { Point p = new Point ( x , y ) ; if ( ! isReadOnly ( p ) ) { BitSet markUp = getHints ( p , level ) ; if ( level == 0 ) { System . out . println ( String . format ( "(%s  %s) : %s" , x , y , markUp ) ) ; } else { System . out . println ( String . format ( "(%s  %s) : %s [%s]" , x , y , markUp , getHints ( p , 0 ) ) ) ; } } } } System . out . println ( ) ; }
tr	6	public void sortBy ( String order ) { DefaultMutableTreeNode tmpNode = null ; DefaultMutableTreeNode curNodeCopy = null ; SortTreeModel treeModelTmp = null ; DefaultMutableTreeNode rootTmp = new DefaultMutableTreeNode ( rootNodeTxt ) ; if ( order . equals ( "name" ) ) { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorName ( ) ) ; sortedByName = true ; } else { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorDate ( ) ) ; sortedByName = false ; } sortByNameMenuItem . setEnabled ( ! sortedByName ) ; sortByDateMenuItem . setEnabled ( sortedByName ) ; for ( @ SuppressWarnings ( "rawtypes" ) Enumeration e = ( ( DefaultMutableTreeNode ) treeModel . getRoot ( ) ) . breadthFirstEnumeration ( ) ; e . hasMoreElements ( ) ; ) { DefaultMutableTreeNode curNode = ( DefaultMutableTreeNode ) e . nextElement ( ) ; Object obj = curNode . getUserObject ( ) ; if ( obj instanceof Item ) { Item currentItem = ( Item ) obj ; if ( currentItem . isDir ( ) ) curNodeCopy = new FolderNode ( currentItem ) ; else curNodeCopy = new LeafNode ( currentItem , ( ( LeafNode ) curNode ) . getDownPerc ( ) , ( ( LeafNode ) curNode ) . getStatus ( ) ) ; Object objPar = ( ( DefaultMutableTreeNode ) curNode . getParent ( ) ) . getUserObject ( ) ; if ( objPar instanceof Item ) { if ( ( tmpNode = getItemInTree ( ( Item ) objPar , treeModelTmp ) ) != null ) { treeModelTmp . insertNodeInto ( curNodeCopy , tmpNode ) ; } } else { treeModelTmp . insertNodeInto ( curNodeCopy , rootTmp ) ; } } } rootNode = rootTmp ; treeModel = treeModelTmp ; tree . setModel ( treeModel ) ; }
tr	1	private GPSFunctionalityVerfiedActivity getVerifyGPSActvity ( ) { if ( gpsFunctionalityVerfiedActiviy != null ) { gpsFunctionalityVerfiedActiviy = new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } return gpsFunctionalityVerfiedActiviy ; }
tr	4	public void applyTransformation ( int frameId ) { if ( vertexSkin == null ) return ; if ( frameId == - 1 ) return ; Animation animationFrame = Animation . forFrameId ( frameId ) ; if ( animationFrame == null ) return ; Skins skins = animationFrame . animationSkins ; vertexModifierX = 0 ; vertexModifierY = 0 ; vertexModifierZ = 0 ; for ( int stepId = 0 ; stepId < animationFrame . frameCount ; stepId ++ ) { int opcode = animationFrame . opcodeTable [ stepId ] ; transformFrame ( skins . opcodes [ opcode ] , skins . skinList [ opcode ] , animationFrame . transformationX [ stepId ] , animationFrame . transformationY [ stepId ] , animationFrame . transformationZ [ stepId ] ) ; } }
tr	0	public void setNbRows ( int nb ) { rows = nb ; }
tr	8	@ Override public String replace ( String [ ] args , Page page ) { String image = "" ; String link = "" ; String alt = "image" ; for ( String arg : args ) { if ( arg . startsWith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startsWith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startsWith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startsWith ( "http:" ) ) { image = arg ; } else if ( arg . endsWith ( ".gif" ) || arg . endsWith ( ".png" ) ) { image = arg ; } else { throw new UnsupportedOperationException ( "Unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	4	public String toString ( ) { String s = "" ; try { s = String . format ( "{%s: id = %s  " , this . getClass ( ) . getSimpleName ( ) , this . getClass ( ) . getSuperclass ( ) . getDeclaredField ( "id" ) . get ( this ) ) ; Field [ ] fields = this . getClass ( ) . getDeclaredFields ( ) ; for ( Field f : fields ) { f . setAccessible ( true ) ; if ( f . getName ( ) . equals ( "serialVersionUID" ) ) continue ; if ( f . getName ( ) . equalsIgnoreCase ( "objects" ) ) continue ; s += String . format ( "%s = %s  " , f . getName ( ) , f . get ( this ) ) ; } s = s . substring ( 0 , s . lastIndexOf ( " " ) ) ; s += "}" ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return s ; }
tr	9X	@ Override protected void doInBackground ( ) { File dir = new File ( MainClass . NANOPOSTS_DIR ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { publish ( new SyncTaskState ( new Rule ( ) , "" , "Can't load nanoposts directory!" , 0 ) ) ; return null ; } File [ ] files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File directory , String fileName ) { return fileName . endsWith ( ".nanopost.png" ) ; } } ) ; File dirOutbox = new File ( MainClass . OUTBOX_DIR ) ; if ( ! dirOutbox . exists ( ) || ! dirOutbox . isDirectory ( ) ) { publish ( new SyncTaskState ( new Rule ( ) , "" , "Can't load outbox directory!" , 0 ) ) ; return null ; } File [ ] outbox = dirOutbox . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File directory , String fileName ) { return fileName . endsWith ( ".nanopost.png" ) ; } } ) ; int currentProgress = 0 ; this . totalProgressValue = files . length + outbox . length ; for ( File f : files ) { try { byte [ ] dataBytes = ImageUtils . tryToDecodeSteganoImage ( ByteUtils . readBytesFromFile ( f ) , boardCode ) ; try { NanoPost nanoPost = NanoPostFactory . getNanoPostFromBytes ( dataBytes , false ) ; nanoPost . setSourceImageData ( ByteUtils . readBytesFromFile ( f ) ) ; nanoPost . setOutbox ( false ) ; nbf . addNanoPostToList ( nanoPost ) ; currentProgress ++ ; publish ( new SyncTaskState ( new Rule ( ) , "" , nanoPost . toString ( ) , currentProgress ) ) ; } catch ( MalformedNanoPostException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | IOException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } for ( File f : outbox ) { try { byte [ ] dataBytes = ImageUtils . tryToDecodeSteganoImage ( ByteUtils . readBytesFromFile ( f ) , boardCode ) ; try { NanoPost nanoPost = NanoPostFactory . getNanoPostFromBytes ( dataBytes , true ) ; nanoPost . setSourceImageData ( ByteUtils . readBytesFromFile ( f ) ) ; nanoPost . setOutbox ( true ) ; nbf . addNanoPostToList ( nanoPost ) ; currentProgress ++ ; publish ( new SyncTaskState ( new Rule ( ) , "" , "outbox: " + nanoPost . toString ( ) , currentProgress ) ) ; } catch ( MalformedNanoPostException ex ) { System . out . println ( "[Invalid nanopost in outbox]: " + f . toString ( ) ) ; } } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | IOException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } publish ( new SyncTaskState ( new Rule ( ) , "" , "Complete" , this . totalProgressValue ) ) ; return null ; }
tr	9X	public Prototype load ( ) throws IOException { Prototype proto = new Prototype ( ) ; proto . source = readLuaString ( ) ; stream . skipBytes ( 8 ) ; proto . numUpvalues = read ( ) ; proto . numParams = read ( ) ; proto . isVararg = ( read ( ) & 2 ) != 0 ; proto . maxStacksize = read ( ) ; int length = 0 ; length = readInt ( ) ; int [ ] code = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) code [ index ] = readInt ( ) ; length = readInt ( ) ; Object [ ] constants = new Object [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { Object value = null ; int type = read ( ) ; switch ( type ) { case TYPE_NIL : break ; case TYPE_BOOLEAN : value = read ( ) != 0 ? boolean . true : boolean . false ; break ; case TYPE_NUMBER : value = double . longBitsToDouble ( readLong ( ) ) ; break ; case TYPE_STRING : value = readLuaString ( ) ; break ; default : throw new LuaException ( "Unknown constant type: " + type ) ; } constants [ index ] = value ; } length = readInt ( ) ; Prototype [ ] protos = new Prototype [ length ] ; for ( int index = 0 ; index < length ; index ++ ) protos [ index ] = load ( ) ; length = readInt ( ) ; int [ ] lines = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) lines [ index ] = readInt ( ) ; length = readInt ( ) ; LocalVar [ ] locals = new LocalVar [ length ] ; for ( int index = 0 ; index < length ; index ++ ) locals [ index ] = new LocalVar ( readLuaString ( ) , readInt ( ) , readInt ( ) ) ; length = readInt ( ) ; String [ ] upvalues = new String [ length ] ; for ( int index = 0 ; index < length ; index ++ ) upvalues [ index ] = readLuaString ( ) ; proto . code = code ; proto . constants = constants ; proto . prototypes = protos ; proto . lines = lines ; proto . locals = locals ; proto . upvalues = upvalues ; return proto ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case FILTRAR : ctrlInformacion . filtrarContratos ( ) ; break ; case NOTAS_APTO_VER : ctrlInformacion . cargarDialogoVerNotasParticulares ( ) ; break ; case NOTAS_GRAL_VER : ctrlInformacion . cargarDialogoVerNotasGenerales ( ) ; break ; case NOTA_APTO_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaParticular ( ) ; break ; case NOTA_GRAL_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaGeneral ( ) ; break ; case RECARGAR_CONTRATOS : ctrlInformacion . cargarContratos ( ) ; break ; case VER_DATOS_RESPONSABLES : ctrlInformacion . cargarDialogoVerDatosResponsables ( ) ; break ; case VER_TELEFONOS : ctrlInformacion . cargarDialogoVerTelefonos ( ) ; break ; } }
tr	2	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	1	public List < Expediente > getExpedientes ( Integer idFuncionario ) throws SQLException { List < Expediente > expedientes = new ArrayList < Expediente > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM expedientes WHERE idFuncionario = ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { Expediente expediente = new Expediente ( ) ; expediente . setId ( rs . getInt ( "id" ) ) ; expediente . setDiaSemana ( rs . getInt ( "DiaSemana" ) ) ; expedientes . add ( expediente ) ; } return expedientes ; }
tr	7	public void generateCrowdForOneDay ( ) { int oneHour = 3600 ; int requests ; int bufetRand = 5 ; int bufetOff = 2 ; requests = ( int ) ( Math . random ( ) * bufetRand ) + bufetOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "bufet" ) , stationMap . get ( "dormi" ) , ( int ) ( 1.5 * oneHour ) , ( int ) ( oneHour ) ) ; } int dormiRand = 15 ; int dormiOff = 10 ; requests = ( int ) ( Math . random ( ) * dormiRand ) + dormiOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "dormi" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 6 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnice1Rand = 15 ; int predavalnice1Off = 15 ; requests = ( int ) ( Math . random ( ) * predavalnice1Rand ) + predavalnice1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "menza" ) , ( int ) ( 11 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza1Rand = 10 ; int menza1Off = 6 ; requests = ( int ) ( Math . random ( ) * menza1Rand ) + menza1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza2Rand = 10 ; int menza2Off = 4 ; requests = ( int ) ( Math . random ( ) * menza2Rand ) + menza2Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "dormi" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza3Rand = 3 ; int menza3Off = 2 ; requests = ( int ) ( Math . random ( ) * menza3Rand ) + menza3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "postaja" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnica3Rand = 3 ; int predavalnica3Off = 2 ; requests = ( int ) ( Math . random ( ) * predavalnica3Rand ) + predavalnica3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "dormi" ) , ( int ) ( 16 * oneHour ) , ( int ) ( 6 * oneHour ) ) ; } }
tr	2	public static void debug ( Connection con ) throws Exception { System . out . println ( "\nDUMP OF TABLE GEOLOC:" ) ; Statement stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT geohash  subject  predicate  lat_lon_object  lat  lon FROM geoloc" ) ; while ( rs . next ( ) ) System . out . println ( "geoloc row: " + rs . getString ( "geohash" ) + " " + rs . getString ( "subject" ) + " " + rs . getString ( "predicate" ) + " " + rs . getString ( "lat_lon_object" ) + " " + rs . getFloat ( "lat" ) + " " + rs . getFloat ( "lon" ) ) ; System . out . println ( ) ; System . out . println ( "\nDUMP OF TABLE FREE TEXT PREDICATES:" ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( "SELECT predicate FROM free_text_predicates" ) ; while ( rs . next ( ) ) System . out . println ( "free_text_predicates row: " + rs . getString ( "predicate" ) ) ; System . out . println ( ) ; }
tr	6	public static String getCommonPrefix ( Automaton a ) { if ( a . isSingleton ( ) ) return a . singleton ; StringBuilder b = new StringBuilder ( ) ; HashSet < State > visited = new HashSet < State > ( ) ; State s = a . initial ; boolean done ; do { done = true ; visited . add ( s ) ; if ( ! s . accept && s . transitions . size ( ) == 1 ) { Transition t = s . transitions . iterator ( ) . next ( ) ; if ( t . min == t . max && ! visited . contains ( t . to ) ) { b . append ( t . min ) ; s = t . to ; done = false ; } } } while ( ! done ) ; return b . toString ( ) ; }
tr	1	private IGameMap createGameMap ( String path ) { IGameMap map = injector . getInstance ( IGameMap . class ) ; try ( InputStream in = getClass ( ) . getResourceAsStream ( path ) ) { map . readMap ( in ) ; } catch ( IOException ex ) { assert . fail ( ex . getMessage ( ) ) ; } return map ; }
tr	1	@ Test public void testSplitLeafs ( ) { StringBuilder expected = new StringBuilder ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { bpTree . put ( i , i ) ; expected . append ( "<put>" ) . append ( "<not-contain-key>" ) . append ( "<get>" ) . append ( "<not-contain>" ) . append ( "<leaf-put>" ) . append ( "<new-key>" ) ; } expected . append ( "<create-new-root>" ) ; assertThat ( bpTree . getWay ( ) , is ( expected . toString ( ) ) ) ; }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	0	public boolean isSchoolAnnouncements ( ) { return schoolAnnouncements ; }
tr	1	@ Test public void testByZero ( ) { try { DivisionResult dr = Util . divideByApproximatelyEqualParts ( 2 , 0 ) ; fail ( "ae expected  but obtained " + dr ) ; } catch ( ArithmeticException ae ) { } }
tr	4	public static double [ ] [ ] produitMat ( double [ ] [ ] m1 , double [ ] [ ] m2 ) { int n1 = m1 . length ; int l1 = m1 [ 0 ] . length ; int n2 = m2 . length ; int l2 = m2 [ 0 ] . length ; double [ ] [ ] res = new double [ n1 ] [ l2 ] ; if ( ! ( l1 == n2 ) ) { System . out . println ( "Tailles non concordantes" ) ; } else { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < l2 ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int l = 0 ; l < l1 ; l ++ ) { res [ i ] [ j ] += m1 [ i ] [ l ] * m2 [ l ] [ j ] ; } } } } return res ; }
tr	3	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
tr	6	public static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	8	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; long p0 ; int p1 ; int p2 ; String p3 ; p0 = 10 ; p1 = 6 ; p2 = 3 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 5 ; p2 = 3 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 50 ; p1 = 100 ; p2 = 2 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 120 ; p1 = 10 ; p2 = 11 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 10 ; p2 = 9999 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000 ; p1 = 100 ; p2 = 10 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000010000100001 ; p1 = 1100011 ; p2 = 1000000000 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , true , p3 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	8	public static Object subtract ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) - ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) - ( ( Number ) val1 ) . intValue ( ) ; } return val0 == null ? null : val1 == null ? val0 : Classes . toString ( val0 ) . replace ( Classes . toString ( val1 ) , "" ) ; }
tr	1	@ Override public void done ( Object data , FlickrException ex ) { if ( data != null ) { setButton . setText ( null ) ; setButton . setIcon ( new ImageIcon ( ( Image ) data ) ) ; } }
tr	9X	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
tr	6	public static boolean clicked ( int button ) { if ( button == MouseEvent . BUTTON1 ) return m1 && ! oldm1 ; else if ( button == MouseEvent . BUTTON2 ) return m2 && ! oldm2 ; else if ( button == MouseEvent . BUTTON3 ) return m3 && ! oldm3 ; else return false ; }
tr	3	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; if ( level != 1 ) { jPanel1 . setEnabled ( false ) ; jButton2 . setEnabled ( false ) ; jButton3 . setEnabled ( false ) ; jButton4 . setEnabled ( false ) ; jButton6 . setEnabled ( false ) ; } double catNumeber = DbUtil . loadCategories ( ) . length ; int rows = ( int ) Math . ceil ( catNumeber / 5 ) ; jPanel2 . setLayout ( new GridLayout ( rows , 5 , 4 , 4 ) ) ; jPanel3 . setVisible ( false ) ; String array [ ] [ ] = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < catNumeber ; i ++ ) { final JButton btn = new JButton ( String . valueOf ( array [ i ] [ 1 ] ) ) ; JPanel buttonPane = new JPanel ( ) ; btn . setName ( String . valueOf ( array [ i ] [ 0 ] ) ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae2 ) { jPanel2 . setVisible ( false ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; try { loadItems ( btn . getName ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; buttonPane . add ( btn ) ; jPanel2 . add ( buttonPane ) ; } add ( jPanel2 ) ; pack ( ) ; setVisible ( true ) ; }
tr	5	public Location findFood ( Location location ) { Field field = getField ( ) ; List < Location > adjacent = field . adjacentLocations ( getLocation ( ) ) ; Iterator < Location > it = adjacent . iterator ( ) ; while ( it . hasNext ( ) ) { Location where = it . next ( ) ; Object animal = field . getObjectAt ( where ) ; if ( animal instanceof Rabbit ) { Rabbit rabbit = ( Rabbit ) animal ; if ( rabbit . isActive ( ) ) { rabbit . setDead ( ) ; foodLevel = foodValue ; return where ; } } else if ( animal instanceof Fox ) { Fox fox = ( Fox ) animal ; if ( fox . isActive ( ) ) { fox . setDead ( ) ; foodLevel = foodValue ; return where ; } } } return null ; }
tr	9X	@ Override public int build ( int start , int length , int floor , MyLevel level ) { this . tubeHeight = floor - MyLevel . random . nextInt ( 2 ) - 2 ; int xTube = start + 1 + MyLevel . random . nextInt ( 4 ) ; for ( int x = start ; x < start + length ; x ++ ) { if ( x > xTube + 1 ) { xTube += 3 + MyLevel . random . nextInt ( 4 ) ; this . tubeHeight = floor - MyLevel . random . nextInt ( 2 ) - 2 ; } if ( xTube >= start + length - 2 ) xTube += 10 ; if ( x == xTube && MyLevel . random . nextInt ( 11 ) < level . difficulty + 1 ) { level . setSpriteTemplate ( x , this . tubeHeight , new SpriteTemplate ( Enemy . ENEMY_FLOWER , false ) ) ; level . ENEMIES ++ ; } for ( int y = 0 ; y < level . height ; y ++ ) { if ( y >= floor ) { level . setBlock ( x , y , MyLevel . GROUND ) ; } else { if ( ( x == xTube || x == xTube + 1 ) && y >= this . tubeHeight ) { int xPic = 10 + x - xTube ; if ( y == this . tubeHeight ) { level . setBlock ( x , y , ( byte ) ( xPic + 0 * 16 ) ) ; } else { level . setBlock ( x , y , ( byte ) ( xPic + 1 * 16 ) ) ; } } } } } return length ; }
tr	6	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	3	public String getHealthText ( ) { double health = getHealth ( ) ; if ( health > 0.75 ) { return "excellently" ; } else if ( health > 0.50 ) { return "well" ; } else if ( health > 0.25 ) { return "decently" ; } else { return "poorly" ; } }
tr	6	public final void levelDone ( ) { if ( ! inGameState ( "InGame" ) || inGameState ( "LevelDone" ) || inGameState ( "LifeLost" ) || inGameState ( "GameOver" ) ) return ; clearKey ( key_continuegame ) ; removeGameState ( "StartLevel" ) ; removeGameState ( "StartGame" ) ; seqtimer = 0 ; if ( leveldone_ticks > 0 ) { if ( leveldone_ingame ) addGameState ( "LevelDone" ) ; else setGameState ( "LevelDone" ) ; new JGTimer ( leveldone_ticks , true , "LevelDone" ) { public void alarm ( ) { levelDoneToStartLevel ( ) ; } } ; } else { levelDoneToStartLevel ( ) ; } }
tr	8	private String handleRequest ( String input ) throws IOException , IllegalArgumentException { System . out . println ( input ) ; String nameReg = "[a-zA-Z0-9\\.]+" ; String regex = "(boards)|(newBoard " + nameReg + ")|" + "(switch " + nameReg + " " + nameReg + " " + nameReg + ")|" + "(exit " + nameReg + ")|(users " + nameReg + ")|" + "(checkAndAddUser " + nameReg + " " + nameReg + ")|" + "(draw " + nameReg + "( " + nameReg + ")+)" ; if ( ! input . matches ( regex ) ) { System . out . println ( "Invalid input: " + input ) ; return null ; } String [ ] tokens = input . split ( " " ) ; if ( tokens [ 0 ] . equals ( "boards" ) ) { return boards ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "newBoard" ) ) { return newBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "switch" ) ) { return switchBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "exit" ) ) { return exit ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "draw" ) ) { return draw ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "checkAndAddUser" ) ) { return checkAndAddUser ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "users" ) ) { return users ( tokens ) ; } throw new UnsupportedOperationException ( ) ; }
tr	2	private void selectElement ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON1 && e . getSource ( ) != table ) table . clearSelection ( ) ; }
tr	1	@ Override public void setDataVector ( Vector newData , Vector columnNames ) { if ( newData == null ) { throw new IllegalArgumentException ( "setDataVector1() - Null parameter" ) ; } super . setDataVector ( dataVector , columnNames ) ; dataVector = newData ; attributiveModel = new DefaultCellAttribute ( dataVector . size ( ) , columnIdentifiers . size ( ) ) ; newRowsAdded ( new TableModelEvent ( this , 0 , getRowCount ( ) - 1 , TableModelEvent . ALL_COLUMNS , TableModelEvent . INSERT ) ) ; }
tr	2	public Node expand ( Board board , String mcColor ) { String newColor ; Random generator = new Random ( ) ; int randomIndex = generator . nextInt ( this . untriedMoves . size ( ) ) ; Tuple < Integer , Integer > move = this . untriedMoves . get ( randomIndex ) ; this . untriedMoves . remove ( randomIndex ) ; try { board . makeMove ( move , color ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( this . color . equals ( "w" ) ) { newColor = "b" ; } else { newColor = "w" ; } Node node = new Node ( this , move , newColor , board , this . moveNumber + 1 , mcColor ) ; this . children . add ( node ) ; return node ; }
tr	7	private class < ? > [ ] resolveBoundClasses ( List < String > classNames ) { List < class < ? >> classObjects = new ArrayList < class < ? >> ( ) ; for ( String className : classNames ) { ClassLoader cl = getClassLoader ( ) ; try { class < ? > c = class . forName ( className , true , cl ) ; classObjects . add ( c ) ; } catch ( ClassNotFoundException e ) { CheckedExceptions . throwAsUnchecked ( e ) ; } } return classObjects . toArray ( new class < ? > [ classObjects . size ( ) ] ) ; }
tr	5	private File loadXmlResource ( ) { File nodesFile = null ; String resource = "/cz/cvut/fit/nodes.xml" ; URL res = getClass ( ) . getResource ( resource ) ; if ( res . toString ( ) . startsWith ( "jar:" ) ) { try { InputStream input = getClass ( ) . getResourceAsStream ( resource ) ; nodesFile = File . createTempFile ( "nodesfile" , ".tmp" ) ; OutputStream out = new FileOutputStream ( nodesFile ) ; int read ; byte [ ] bytes = new byte [ 1024 ] ; while ( ( read = input . read ( bytes ) ) != - 1 ) { out . write ( bytes , 0 , read ) ; } nodesFile . deleteOnExit ( ) ; } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; } } else { nodesFile = new File ( res . getFile ( ) ) ; } if ( nodesFile != null && ! nodesFile . exists ( ) ) { throw new RuntimeException ( "Error: File " + nodesFile + " not found!" ) ; } return nodesFile ; }
tr	5	public Writer write ( Writer writer ) throws JSONException { try { boolean b = false ; int len = length ( ) ; writer . write ( [ ) ; for ( int i = 0 ; i < len ; i += 1 ) { if ( b ) { writer . write (   ) ; } Object v = this . myArrayList . get ( i ) ; if ( v instanceof JSONObject ) { ( ( JSONObject ) v ) . write ( writer ) ; } else if ( v instanceof JSONArray ) { ( ( JSONArray ) v ) . write ( writer ) ; } else { writer . write ( JSONObject . valueToString ( v ) ) ; } b = true ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	9X	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) != null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) != null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
tr	6	public static int getUTF8 ( byte [ ] str , int start , MutableInteger ch ) { int c , n , i , bytes ; c = ( ( int ) str [ start ] ) & FF ; if ( ( c & E0 ) == C0 ) { n = c & 31 ; bytes = 2 ; } else if ( ( c & F0 ) == E0 ) { n = c & 15 ; bytes = 3 ; } else if ( ( c & F8 ) == F0 ) { n = c & 7 ; bytes = 4 ; } else if ( ( c & FC ) == F8 ) { n = c & 3 ; bytes = 5 ; } else if ( ( c & FE ) == FC ) { n = c & 1 ; bytes = 6 ; } else { ch . value = c ; return 0 ; } for ( i = 1 ; i < bytes ; ++ i ) { c = ( ( int ) str [ start + i ] ) & FF ; n = ( n << 6 ) | ( c & 3F ) ; } ch . value = n ; return bytes - 1 ; }
tr	1	public static TextureRegion get ( int x , int y , int width , int height ) { if ( texture == null ) texture = new Texture ( "spritesheet.png" , GL_LINEAR , GL_LINEAR ) ; return new TextureRegion ( texture , x , y , width , height ) ; }
tr	5	public Image getTileImage ( int x , int y ) { switch ( level . fields [ y ] [ x ] ) { case dest : return iDest ; case floor : return iFloor ; case grass : return iGrass ; case src : return iSrc ; case wall : return iWall ; default : return null ; } }
tr	6	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
tr	4	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	5	public void createGameObject ( int btnval ) { System . out . println ( "Create Game Object Button pressed" ) ; GrandView grand = findGrandView ( ) ; SavedEntityState state = grand . getSavedStates ( ) . getSelectedState ( ) ; if ( state != null ) { GameEntity entity = new GameEntity ( ) ; if ( entity . getState ( ) == null ) System . out . println ( "Major Error :: EntityState null :: ModifiersView" ) ; entity . getState ( ) . setReference ( state ) ; entity . getState ( ) . initializeFromReference ( ) ; GameEntityView gev = grand . getGameEntity ( ) ; gev . setCurrent ( entity ) ; System . out . println ( "GameEntityView redraw :: ModifiersView" ) ; gev . redrawView ( ) ; } else { System . out . println ( "Minor Error :: No Saved State Selected :: ModifiersView" ) ; } for ( int i = 0 ; i < getSubviews ( ) . size ( ) ; i ++ ) if ( getSubviews ( ) . get ( i ) instanceof Button ) { Button temp = ( Button ) getSubviews ( ) . get ( i ) ; if ( temp . getIndex ( ) == btnval ) temp . setSelected ( false ) ; } }
tr	2	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	9X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	7	public static String readSeatNumbers ( ) { boolean tryAgain ; do { tryAgain = false ; str = scan . nextLine ( ) ; for ( String s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryAgain = true ; } else if ( s . charAt ( 0 ) < A && s . charAt ( 0 ) > Z ) { tryAgain = true ; } else { try { Integer . parseInt ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( NumberFormatException exception ) { tryAgain = true ; } } if ( tryAgain ) { System . out . print ( "Seats No input is invalid! Try again: " ) ; break ; } } } while ( tryAgain ) ; return str ; }
tr	1	public void set ( int index , Object element ) throws illegalIndexException { if ( index < 0 ) { throw new illegalIndexException ( ) ; } tablica_stosu [ index ] = element ; }
tr	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
tr	3	private void doPrint ( String s ) { for ( int newline = s . indexOf ( '' ) ; newline >= 0 ; newline = s . indexOf ( '' ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
tr	7	@ Override public boolean validateData ( ) { code = textFieldCode . getText ( ) . trim ( ) ; names = textFieldNames . getText ( ) . trim ( ) ; birthday = dateChooserBirthday . getDate ( ) ; email = textFieldEmail . getText ( ) . trim ( ) ; String key ; if ( code . length ( ) == 0 ) { key = "app.warning.teacher.code.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldCode ) ; return false ; } if ( DialogAction . INSERT . equals ( dialogAction ) ) { if ( teacherController . existsCode ( code ) ) { key = "app.warning.teacher.code.already.exists" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldCode ) ; return false ; } } if ( names . length ( ) == 0 ) { key = "app.warning.teacher.name.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldNames ) ; return false ; } if ( birthday == null ) { key = "app.warning.teacher.birthday.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; dateChooserBirthday . requestFocusInWindow ( ) ; return false ; } if ( email . length ( ) == 0 ) { key = "app.warning.teacher.email.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldEmail ) ; return false ; } if ( ! isCorrectEmailFormat ( email ) ) { key = "app.warning.teacher.email.wrong.format" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldEmail ) ; return false ; } return true ; }
tr	4	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	9X	public void handleGameData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct: " + length ) ; } else { acceptUpdatedMoveable ( data [ j - 2 ] , data [ j - 1 ] ) ; } } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { acceptDroppedBomb ( data [ j - 4 ] , data [ j - 3 ] , data [ j - 2 ] , data [ j - 1 ] ) ; } } } } } }
tr	1	@ Test public void testIdentifierOptionalPresentButNull ( ) throws TemplateException { Identifier variable = new Identifier ( "$variable?" , new Cursor ( "-:l1:c1" ) ) ; populateModel ( "variable" , null ) ; try { variable . writeObject ( null , model , null ) ; fail ( "An exception must be raised." ) ; } catch ( TemplateIgnoreRenderingException e ) { assertEquals ( "Ignore rendering because key 'variable' is not present or has null value in the model map at position '-:l1:c1'." , e . getMessage ( ) ) ; } }
tr	8	private Section processSection ( StartElement se , XMLEventReader eventReader , String derivedNamespace ) throws XMLStreamException { Section s = new Section ( ) ; Iterator < Attribute > attributes = se . getAttributes ( ) ; while ( attributes . hasNext ( ) ) { Attribute attr = attributes . next ( ) ; s . addAttribute ( attr . getName ( ) . getLocalPart ( ) , attr . getValue ( ) ) ; } boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Obs" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { Obs o = processObs ( se , eventReader ) ; s . getObs ( ) . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Section" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { endTagReached = true ; } } } return s ; }
tr	1	public int step ( int state , char c ) { if ( classmap == null ) return transitions [ state * points . length + getCharClass ( c ) ] ; else return transitions [ state * points . length + classmap [ c - Character . MIN_VALUE ] ] ; }
tr	5	public Posicion obtenerPosicionRelativa ( final Posicion posicion , final int offset ) { int indice = - 1 ; for ( int i = 0 ; i < posiciones . size ( ) && indice == - 1 ; i ++ ) { if ( posiciones . get ( i ) == posicion ) { indice = i ; } } int posicionRelativa = indice + offset ; if ( posicionRelativa < 0 || posicionRelativa > posiciones . size ( ) - 1 ) { return new PosicionInexistente ( ) ; } return posiciones . get ( posicionRelativa ) ; }
tr	1	public static SoundManager create ( class < ? > clazz ) throws IllegalArgumentException { return create ( clazz , new String ( ) ) ; }
tr	4	@ Override public boolean equals ( Object that ) { if ( that == this ) return true ; if ( that == null || ! getClass ( ) . equals ( that . getClass ( ) ) ) return false ; Row other = ( Row ) that ; return option . equals ( other . option ) && description . equals ( other . description ) ; }
tr	0	protected void start ( ) { start ( null ) ; }
tr	2	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	8	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
tr	7	private void searchUser ( ActionEvent e ) { String userName = this . userName . getText ( ) ; String userNo = this . userNO . getText ( ) ; if ( userName == null || Constants . STR_NULL . equals ( userName . trim ( ) ) ) { userName = Constants . STR_NULL ; } if ( userNo == null || Constants . STR_NULL . equals ( userNo . trim ( ) ) ) { userNo = Constants . STR_NULL ; } Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . IN_USERNAME , userName ) ; param . put ( Constants . IN_USERNO , userNo ) ; System . out . println ( param ) ; List < Map < String , Object >> list = null ; try { list = userDao . searchUser ( param ) ; } finally { if ( null == list || Constants . NUM_ZERO == list . size ( ) ) { return ; } else { int size = list . size ( ) ; data = new String [ size ] [ 2 ] ; int i = 0 ; for ( Map < String , Object > item : list ) { data [ i ] [ 0 ] = item . get ( Constants . USER_NO ) ; data [ i ] [ 1 ] = item . get ( Constants . USER_NAME ) ; i ++ ; } refreshTable ( ) ; } } }
tr	3	protected JSONRPCBridge findBridge ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; JSONRPCBridge json_bridge = null ; if ( session != null ) { json_bridge = ( JSONRPCBridge ) session . getAttribute ( "JSONRPCBridge" ) ; } if ( json_bridge == null ) { json_bridge = JSONRPCBridge . getGlobalBridge ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Using global bridge." ) ; } } return json_bridge ; }
tr	4	private void setEventLimitFlags ( ) { Settings_Event . EVENT_LIMIT_REACHED_LOW = ( Settings_Event . RUNNING_EVENTS_LOW >= Settings_Event . MAX_RUNNING_EVENTS_LOW ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_MID = ( Settings_Event . RUNNING_EVENTS_MID >= Settings_Event . MAX_RUNNING_EVENTS_MID ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_HIGH = ( Settings_Event . RUNNING_EVENTS_HIGH >= Settings_Event . MAX_RUNNING_EVENTS_HIGH ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_ALL = ( Settings_Event . RUNNING_EVENTS_ALL >= Settings_Event . MAX_RUNNING_EVENTS_ALL ) ? true : false ; }
tr	1	public final ProgramaContext programa ( ) throws RecognitionException { ProgramaContext _localctx = new ProgramaContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_programa ) ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 10 ) ; seqComando ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	1	public void divide ( int ncol , int nrow ) { canvasPads . setSize ( this . getSize ( ) . width , this . getSize ( ) . height , ncol , nrow ) ; int ncharts = canvasPads . getNPads ( ) ; series . clear ( ) ; for ( int loop = 0 ; loop < ncharts ; loop ++ ) { ScGroupSeries chart = new ScGroupSeries ( new ScRegion ( canvasPads . getX ( loop ) , canvasPads . getY ( loop ) , canvasPads . getWidth ( loop ) , canvasPads . getHeight ( loop ) ) ) ; series . add ( chart ) ; } }
tr	3	public static Shader createShader ( String name ) { BufferedReader vertex ; try { vertex = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { return null ; } BufferedReader fragment ; try { fragment = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { try { vertex . close ( ) ; } catch ( IOException e2 ) { } return null ; } return createShader ( name , vertex , fragment ) ; }
tr	0	@ Override public String getVarName ( ) { return this . name ; }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	8	protected void UnZip ( ) throws PrivilegedActionException { String path = ( String ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws Exception { return ( new StringBuilder ( ) ) . append ( Util . getWorkingDirectory ( ) ) . append ( File . separator ) . toString ( ) ; } final GameUpdater this$0 ; { this$0 = GameUpdater . this ; } } ) ; String szZipFilePath = ( new StringBuilder ( String . valueOf ( path ) ) ) . append ( "bin" ) . append ( File . separator ) . append ( "additional.zip" ) . toString ( ) ; File f = new File ( szZipFilePath ) ; if ( ! f . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; if ( f . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot file: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; System . out . println ( "Enter path to extract files: " ) ; String szExtractPath = path ; File f1 = new File ( szExtractPath ) ; if ( ! f1 . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szExtractPath ) . toString ( ) ) ; if ( ! f1 . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot directory: " ) ) . append ( szExtractPath ) . toString ( ) ) ; Vector zipEntries = new Vector ( ) ; try { teststring = szExtractPath + "/buildcraft" ; File fil = new File ( teststring ) ; del_cat ( fil ) ; teststring = szExtractPath + "/config" ; File fil2 = new File ( teststring ) ; del_cat ( fil2 ) ; teststring = szExtractPath + "/mods" ; File fil3 = new File ( teststring ) ; del_cat ( fil3 ) ; teststring = szExtractPath + "/redpower" ; File fil4 = new File ( teststring ) ; del_cat ( fil4 ) ; teststring = szExtractPath + "/resources" ; File fil5 = new File ( teststring ) ; del_cat ( fil5 ) ; ZipFile zf = new ZipFile ( szZipFilePath ) ; for ( Enumeration en = zf . entries ( ) ; en . hasMoreElements ( ) ; zipEntries . addElement ( ( ZipEntry ) en . nextElement ( ) ) ) ; for ( int i = 0 ; i < zipEntries . size ( ) ; i ++ ) { ZipEntry ze = ( ZipEntry ) zipEntries . elementAt ( i ) ; extractFromZip ( szZipFilePath , szExtractPath , ze . getName ( ) , zf , ze ) ; } zf . close ( ) ; if ( ! f . isDirectory ( ) ) f . delete ( ) ; System . out . println ( "Done!" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	2	@ Override public void close ( final String guiName ) { if ( ! guiThreads . get ( guiName ) . isAlive ( ) ) { return ; } running = false ; try { guiThreads . get ( guiName ) . join ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	4	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	1	private String [ ] camposOrdem ( ) { String camposPesquisa [ ] = new String [ estruturaTabela . size ( ) ] ; for ( int i = 0 ; i < estruturaTabela . size ( ) ; i ++ ) { camposPesquisa [ i ] = estruturaTabela . get ( i ) . getCampo ( ) ; } jCBOrdemPesq . setModel ( new javax . swing . DefaultComboBoxModel ( camposPesquisa ) ) ; return camposPesquisa ; }
tr	3	public boolean contains ( int val ) { System . out . printf ( "Looking for %d:%n" , val ) ; Node c = root ; while ( c != null ) if ( c . value == val ) { System . out . println ( " -> Requested value was found." ) ; return true ; } else if ( val < c . value ) { c = c . left ; System . out . printf ( " -> Requested value is smaller than %d : Going left." , c . value ) ; } else { c = c . right ; System . out . printf ( " -> Requested value is bigger than %d : Going right." , c . value ) ; } System . out . println ( " -> Requested value was not found." ) ; return false ; }
tr	9X	static Object get ( Object subtree , Object key , int khash ) { if ( subtree == null ) return NO_ELEMENT ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , khash ) ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( ( bin_srch_res & BIN_SEARCH_FOUND_MASK ) == BIN_SEARCH_FOUND && eql ( key , ary [ idx ] ) ) return ary [ idx + ( ary . length >> 1 ) ] ; else return NO_ELEMENT ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int nkhash = node . khash ; if ( khash == nkhash ) { if ( nkey instanceof EquivalentMap ) { ArrayList < Entry > al = ( ( EquivalentMap ) nkey ) . contents ; for ( int i = 0 , len = al . size ( ) ; i < len ; ++ i ) { Entry ent = al . get ( i ) ; if ( eql ( key , ent . key ) ) return ent . value ; } return NO_ELEMENT ; } else if ( eql ( key , nkey ) ) return node . value ; else return NO_ELEMENT ; } else if ( khash < nkhash ) return get ( node . left , key , khash ) ; else return get ( node . right , key , khash ) ; } }
tr	1	public void serverCutText ( String str ) { if ( viewer . acceptClipboard . getValue ( ) ) clipboardDialog . serverCutText ( str ) ; }
tr	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_Storable ( swigCPtr ) ; } swigCPtr = 0 ; } }
tr	9X	public static void arraycopy ( final float [ ] src , final int srcPos , final FloatLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setFloat ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } } }
tr	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
tr	1	public final void update ( Graphics g ) { if ( graphics == null ) graphics = g ; shouldClearScreen = true ; raiseWelcomeScreen ( ) ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	3	public static Polynomial createFromBytes ( byte [ ] bytes ) { TreeSet < BigInteger > dgrs = createDegreesCollection ( ) ; int degree = 0 ; for ( int i = bytes . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( ( ( ( bytes [ i ] >> j ) & 1 ) == 1 ) ) { dgrs . add ( BigInteger . valueOf ( degree ) ) ; } degree ++ ; } } return new Polynomial ( dgrs ) ; }
tr	5	public static void main ( String [ ] args ) { ArrayList < Integer > answers = new ArrayList < Integer > ( ) ; for ( int i = 1 ; answers . size ( ) < 124 ; i += 2 ) { int a = 1 ; int b = 1 ; int c = 1 ; boolean divisible = false ; for ( int n = 0 ; n < 1000000 && ! divisible ; n ++ ) { int temp = a + b + c ; temp %= i ; if ( temp == 0 ) divisible = true ; a = b ; b = c ; c = temp ; } if ( ! divisible ) answers . add ( i ) ; } System . out . print ( answers . get ( answers . size ( ) - 1 ) ) ; }
tr	2	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	1	public void saveLang ( ) { try { lang . save ( langFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	6	public static String encodeParameters ( List < PostParameter > postParams , String splitter , boolean quot ) { StringBuffer buf = new StringBuffer ( ) ; for ( PostParameter param : postParams ) { if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } buf . append ( splitter ) ; } buf . append ( encode ( param . name ) ) . append ( "=" ) ; if ( quot ) { buf . append ( "\"" ) ; } buf . append ( encode ( param . value ) ) ; } if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } } return buf . toString ( ) ; }
tr	2	private void closeSocket ( ) { try { if ( socket != null ) { socket . close ( ) ; socket = null ; } } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not close network socket: " + e . getMessage ( ) ) ; } socket = null ; }
tr	2	@ Override public int getInt ( long i ) { if ( ptr != 0 ) { return ( int ) ( Utilities . UNSAFE . getShort ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( int ) data [ 0 ] ; } else { return ( int ) data [ ( int ) i ] ; } } }
tr	3	void initialize ( int d ) { this . matArray = new Material [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . tileState = new int [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . cleanColor = new Material ( ) ; this . cleanColor . setAmbient ( 0.7 , 0.7 , 0.7 ) ; this . cleanColor . setDiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleanColor . setSpecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredColor = new Material ( ) ; this . coveredColor . setAmbient ( 0.1 , 0.1 , 0.1 ) ; this . coveredColor . setDiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredColor . setSpecular ( .5 , .5 , .5 , 10 ) ; this . redColor = new Material ( ) ; this . redColor . setAmbient ( 0.9 , 0.1 , 0.1 ) ; this . redColor . setDiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redColor . setSpecular ( .95 , .15 , .15 , 10 ) ; this . yellowColor = new Material ( ) ; this . yellowColor . setAmbient ( 0.9 , 0.9 , 0.1 ) ; this . yellowColor . setDiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowColor . setSpecular ( .95 , .95 , .15 , 10 ) ; this . blueColor = new Material ( ) ; this . blueColor . setAmbient ( 0.1 , 0.1 , 0.9 ) ; this . blueColor . setDiffuse ( 0.15 , 0.15 , 0.95 ) ; this . blueColor . setSpecular ( .15 , .15 , .95 , 10 ) ; this . greenColor = new Material ( ) ; this . greenColor . setAmbient ( 0.1 , 0.9 , 0.1 ) ; this . greenColor . setDiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greenColor . setSpecular ( .15 , .95 , .15 , 10 ) ; this . orangeColor = new Material ( ) ; this . orangeColor . setAmbient ( 0.98 , 0.5 , 0.25 ) ; this . orangeColor . setDiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangeColor . setSpecular ( .99 , .52 , .27 , 10 ) ; this . purpleColor = new Material ( ) ; this . purpleColor . setAmbient ( 0.9 , 0.1 , 0.9 ) ; this . purpleColor . setDiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purpleColor . setSpecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getNumFaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getDimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getDimension ( ) ; column ++ ) { this . getFace ( face ) [ row ] [ column ] . setMaterial ( this . coveredColor ) ; this . tileState [ face ] [ row ] [ column ] = 0 ; } } } }
tr	4	public static void setAppleMenus ( String title ) { try { System . setProperty ( "apple.laf.useScreenMenuBar" , "true" ) ; System . setProperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "ClassNotFoundException: " + e . getMessage ( ) ) ; } catch ( InstantiationException e ) { System . out . println ( "InstantiationException: " + e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { System . out . println ( "IllegalAccessException: " + e . getMessage ( ) ) ; } catch ( UnsupportedLookAndFeelException e ) { System . out . println ( "UnsupportedLookAndFeelException: " + e . getMessage ( ) ) ; } }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	6	public Builder mergeFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { com . google . protobuf . UnknownFieldSet . Builder unknownFields = com . google . protobuf . UnknownFieldSet . newBuilder ( this . getUnknownFields ( ) ) ; while ( true ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; } break ; } case 10 : { bitField0_ |= 00000001 ; type_ = input . readBytes ( ) ; break ; } case 16 : { bitField0_ |= 00000002 ; gov_ = input . readInt32 ( ) ; break ; } case 24 : { bitField0_ |= 00000004 ; dep_ = input . readInt32 ( ) ; break ; } } } }
tr	6	private void modificarActionPerformed ( java . awt . event . ActionEvent evt ) { String carnet = f_carne . getText ( ) . toString ( ) ; String fecha = f_fecha . getText ( ) . toString ( ) ; Hora inicio = new Hora ( f_inicio . getText ( ) . toString ( ) . trim ( ) ) ; boolean validos = false ; while ( ! validos ) { if ( Hora . validarFormato ( inicio . getCadena ( ) ) ) { inicio = new Hora ( f_inicio . getText ( ) . toString ( ) ) ; } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese una hora en formato militar" ) ; notificacion . setVisible ( true ) ; } if ( ! Hora . validarFormatoFecha ( fecha ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ingrese la fecha en el formato indicado" ) ; notificacion . setVisible ( true ) ; } if ( B_A_estudiante . validaCarnet ( carnet ) ) { if ( null == B_A_estudiante . consultarEstudiante ( carnet ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ese estudiante no existe" ) ; notificacion . setVisible ( true ) ; } } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese un carnet valido" ) ; notificacion . setVisible ( true ) ; } B_A_horas labor = B_A_horas . consultarLabor ( carnet . trim ( ) , fecha . trim ( ) , inicio ) ; if ( null != labor ) { validos = true ; Modificar_observaciones ventana = new Modificar_observaciones ( labor ) ; ventana . setVisible ( true ) ; this . setVisible ( false ) ; break ; } else { Notificacion notificacion = new Notificacion ( this , true , "Esa labor no existe" ) ; notificacion . setVisible ( true ) ; break ; } } }
tr	2	private boolean hasOutput ( ) { return method . equals ( "POST" ) || method . equals ( "PUT" ) && ! data . isEmpty ( ) ; }
tr	2	@ Override public void put ( Point point , double value ) { if ( value != 0.5 ) cells . put ( point , value ) ; else if ( cells . containsKey ( point ) ) { cells . remove ( point ) ; } }
tr	2	public void update ( float deltaTimeElapsedMs ) { speedX = bg1 . getSpeedX ( ) * 5 ; tileX += Util . factorByElapsedTimeMs ( speedX , deltaTimeElapsedMs ) ; tileBoundary . setBounds ( tileX , tileY , 40 , 40 ) ; if ( tileBoundary . intersects ( Player . perimeter ) && type != 0 ) { checkHorizontalCollision ( ) ; checkVerticalCollision ( ) ; } }
tr	4	private void setTextFieldVerifiers ( ) { final JComponent [ ] componentArr = new JComponent [ ] { textFieldName , textFieldMinAmount , textFieldMaxAmount , textFieldDuration , textFieldStartPay , textFieldPercent , textAreaDescription } ; final TextFieldVerifier verifier = new TextFieldVerifier ( ) ; for ( JComponent component : componentArr ) { component . setInputVerifier ( verifier ) ; } KeyListener listener = new KeyAdapter ( ) { public void keyTyped ( KeyEvent e ) { for ( JComponent component : componentArr ) { boolean enabled = verifier . verify ( component ) ; if ( enabled == false ) { buttonSave . setEnabled ( enabled ) ; break ; } buttonSave . setEnabled ( enabled ) ; } } } ; for ( JComponent component : componentArr ) { component . addKeyListener ( listener ) ; } }
tr	1	public static GTHome getHome ( ) { if ( home == null ) home = new GTHomeImpl ( ) ; return home ; }
tr	3	void actionVerifyCert ( int num ) { X509Certificate c = certificates [ num ] ; X509Certificate cacert = certificates [ caCertsPane . getCACertNum ( ) ] ; if ( cacert == null ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "No loaded CA certificate selected." ) ; return ; } try { c . verify ( cacert . getPublicKey ( ) ) ; userCertsPane . setVerified ( num , true ) ; } catch ( SignatureException se ) { userCertsPane . setVerified ( num , false ) ; } catch ( Exception ex ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "Verification of signature failed." ) ; } }
tr	6	public String pillcaseSearch ( String pillId ) { String status = "" ; String payer = "" ; String pillAmount = "" ; String number = "" ; String pillName = "" ; String pillNum = "" ; String str = "select distinct pl.payer p.pill_num rl.status pl.pill_amount p.number p.pill_name from pill p pill_list pl recepit_list rl where pl.id='" + pillId + "' and  p.pill_num=pl.pill_id and rl.receipt_id=pl.id and rl.pillOrEquip='1' order by p.pill_name;" ; System . out . println ( "pillcaseSearch________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; sb . append ( "<tr> <td>\u836F\u54C1\u540D\u79F0</td> <td>\u6570\u91CF</td> <td>\u5E93\u5B58\u6570\u91CF</td> </tr> " ) ; while ( num . next ( ) ) { pillNum = num . getString ( "pill_num" ) ; status = num . getString ( "status" ) ; payer = num . getString ( "payer" ) ; pillAmount = num . getString ( "pill_amount" ) ; number = num . getString ( "number" ) ; pillName = num . getString ( "pill_name" ) ; sb . append ( " <tr><td><input type=\"text\" value=\"" + pillName + "\" readonly><input type=\"text\" value=\"" + pillNum + "\" style=\"display:none\" name=\"pillid\"></td>" ) ; sb . append ( "<td><input type=\"text\" value=\"" + pillAmount + "\" name=\"pillAmount\" readonly> </td><td><input type=\"text\" value=\"" + number + "\" name=\"pillNum\" readonly></td></tr>" ) ; sb . append ( "<input type=\"text\"  value=\"" + pillId + "\" name=\"id\" style=\"display:none\">" ) ; } if ( status . equals ( "1" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u672A\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } else if ( status . equals ( "2" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u5DF2\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } if ( payer == null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u672A\u4ED8\u836F</td> </tr>" ) ; } else if ( payer != null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u5DF2\u4ED8\u836F</td> </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	8	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	9X	public static Method getMostSpecificMethod ( Method method , class < ? > targetClass ) { if ( method != null && isOverridable ( method , targetClass ) && targetClass != null && ! targetClass . equals ( method . getDeclaringClass ( ) ) ) { try { if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { try { return targetClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException ex ) { return method ; } } else { Method specificMethod = ReflectionUtils . findMethod ( targetClass , method . getName ( ) , method . getParameterTypes ( ) ) ; return ( specificMethod != null ? specificMethod : method ) ; } } catch ( SecurityException ex ) { } } return method ; }
tr	2	protected void criarMetaObjeto ( ) { framePai . dispose ( ) ; switch ( listaSemiPontos . size ( ) ) { case 1 : this . criarPonto ( ) ; break ; case 2 : this . criarReta ( ) ; break ; default : this . criarPoligono ( ) ; } }
tr	3	@ Test public void test ( ) { try { ClassBean bean = new ClassOperator ( ) . operClass ( ClassBean . class ) ; System . out . println ( bean . getFeature ( ) ) ; System . out . println ( bean . getName ( ) ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } }
tr	9X	public static int testPublic ( int testNum ) { String inputFilename = String . format ( "tests/test%02d.crx" , testNum ) ; String outputFilename = String . format ( "tests/test%02d.rea" , testNum ) ; String expectedFilename = String . format ( "tests/test%02d.out" , testNum ) ; String astFilename = String . format ( "tests/test%02d.ast" , testNum ) ; Scanner s = null ; try { s = new Scanner ( new FileReader ( inputFilename ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return NOT_ACCESSABLE ; } Parser p = new Parser ( s ) ; ast . Command syntaxTree = p . parse ( ) ; try { PrintStream outputStream = new PrintStream ( outputFilename ) ; PrintStream astStream = new PrintStream ( astFilename ) ; if ( p . hasError ( ) ) { outputStream . println ( "Error parsing file." ) ; outputStream . println ( p . errorReport ( ) ) ; outputStream . close ( ) ; astStream . println ( "Error parsing file." ) ; astStream . println ( p . errorReport ( ) ) ; astStream . close ( ) ; } else { PrettyPrinter pretty = new PrettyPrinter ( ) ; syntaxTree . accept ( pretty ) ; astStream . println ( pretty . toString ( ) ) ; astStream . close ( ) ; types . TypeChecker tc = new types . TypeChecker ( ) ; tc . check ( syntaxTree ) ; if ( tc . hasError ( ) ) { outputStream . println ( "Error type-checking file." ) ; outputStream . println ( tc . errorReport ( ) ) ; outputStream . close ( ) ; } else { outputStream . println ( "Crux Program has no type errors." ) ; } } } catch ( IOException e ) { System . err . println ( "Error opening output file: \"" + outputFilename + "\"" ) ; e . printStackTrace ( ) ; return IO_ERROR ; } BufferedReader bufferedexpected ; BufferedReader bufferedoutput ; String lineExpected ; String lineOutput ; try { bufferedexpected = new BufferedReader ( new FileReader ( expectedFilename ) ) ; bufferedoutput = new BufferedReader ( new FileReader ( outputFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return IO_ERROR ; } int result = PASS ; try { while ( ( lineExpected = bufferedexpected . readLine ( ) ) != null ) { lineOutput = bufferedoutput . readLine ( ) ; if ( lineOutput == null ) { result = FAIL ; break ; } lineExpected = lineExpected . replaceAll ( "\\s+$" , "" ) ; lineOutput = lineOutput . replaceAll ( "\\s+$" , "" ) ; if ( ! lineExpected . equals ( lineOutput ) ) { result = FAIL ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; result = IO_ERROR ; } try { bufferedoutput . close ( ) ; bufferedexpected . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; }
tr	9X	public String longestPalindrome ( String s ) { if ( s == null ) return null ; char [ ] array = s . toCharArray ( ) ; int n = s . length ( ) ; int maxLen = 1 ; int beginIndex = 0 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { table [ i ] [ j ] = true ; continue ; } table [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( array [ i ] == array [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; maxLen = 2 ; beginIndex = i ; } } for ( int len = 3 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; if ( array [ i ] == array [ j ] && table [ i + 1 ] [ j - 1 ] ) { table [ i ] [ j ] = true ; beginIndex = i ; maxLen = len ; } } } return s . substring ( beginIndex , beginIndex + maxLen ) ; }
tr	6	@ Override public boolean podeSeMover ( Posicao origem , Posicao destino , TabuleiroXadrez tabuleiro ) { if ( super . podeSeMover ( origem , destino , tabuleiro ) && tabuleiro . podeRealizarMovimentacao ( origem , destino ) ) if ( ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) == 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) > 0 ) || ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) > 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 0 ) ) return true ; return false ; }
tr	1	@ Override public int hashCode ( ) { int hash = 0 ; hash += ( id != null ? id . hashCode ( ) : 0 ) ; return hash ; }
tr	1	private List < DirFiles > getDirWithFiles ( String dirPath ) { List < DirFiles > ls = new ArrayList < AnalRunner . DirFiles > ( ) ; for ( File f : getDirList ( dirPath ) ) { DirFiles dirFiles = new DirFiles ( f . getName ( ) ) ; dirFiles . addFileList ( getFileList ( f . getAbsolutePath ( ) ) ) ; ls . add ( dirFiles ) ; } return ls ; }
tr	4	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
tr	1	public Object1 method296 ( int i , int j , int k ) { Ground class30_sub3 = groundArray [ i ] [ j ] [ k ] ; if ( class30_sub3 == null ) return null ; else return class30_sub3 . obj1 ; }
tr	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( AlcoholPolicy == null ) ? 0 : AlcoholPolicy . hashCode ( ) ) ; result = prime * result + ( ( CancellationDeadLine == null ) ? 0 : CancellationDeadLine . hashCode ( ) ) ; result = prime * result + ( ( CancellationPenalty == null ) ? 0 : CancellationPenalty . hashCode ( ) ) ; result = prime * result + ( ( CheckInTime == null ) ? 0 : CheckInTime . hashCode ( ) ) ; result = prime * result + ( ( CheckOutTime == null ) ? 0 : CheckOutTime . hashCode ( ) ) ; result = prime * result + ( ( SmokingPolicy == null ) ? 0 : SmokingPolicy . hashCode ( ) ) ; return result ; }
tr	8	@ Override public void keyPressed ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_UP : this . editor . getCursor ( ) . selectLineUp ( ) ; break ; case KeyEvent . VK_DOWN : this . editor . getCursor ( ) . selectLineDown ( ) ; break ; case KeyEvent . VK_LEFT : this . editor . getCursor ( ) . movePositionLeft ( ) ; break ; case KeyEvent . VK_RIGHT : this . editor . getCursor ( ) . movePositionRight ( ) ; break ; case KeyEvent . VK_DELETE : if ( this . editor . getCursor ( ) . getCurrentPosition ( ) < this . editor . getCursor ( ) . getCurrentLine ( ) . length ( ) ) this . editor . getSelectedLine ( ) . deleteCharAt ( this . editor . getSelectedCharacterNb ( ) ) ; break ; case KeyEvent . VK_BACK_SPACE : if ( this . editor . getCursor ( ) . getCurrentPosition ( ) > 0 ) { this . editor . getSelectedLine ( ) . deleteCharAt ( this . editor . getSelectedCharacterNb ( ) - 1 ) ; this . editor . getCursor ( ) . movePositionLeft ( ) ; } break ; } view . getDocument ( ) . setText ( this . editor . print ( ) ) ; }
tr	5	public Calendar getMaxDueDate ( ) { Calendar result = Calendar . getInstance ( ) ; Calendar max = null ; Calendar toCheck ; if ( tasks != null && tasks . size ( ) > 0 ) { for ( Task t : tasks ) { toCheck = t . getDueDate ( ) ; if ( max == null || toCheck . compareTo ( max ) > 0 ) { max = toCheck ; } } result . set ( Calendar . YEAR , max . get ( Calendar . YEAR ) ) ; result . set ( Calendar . MONTH , max . get ( Calendar . MONTH ) ) ; result . set ( Calendar . DAY_OF_MONTH , max . get ( Calendar . DAY_OF_MONTH ) ) ; } return result ; }
tr	8	public void start ( ) { if ( this . isRunning || this . simulationResult != null ) { return ; } this . latch = new CountDownLatch ( this . nrOfWorkers ) ; int roundsPerWorker = getNrOfRoundsPerWorker ( this . nrOfWorkers ) ; this . executor = Executors . newFixedThreadPool ( this . nrOfWorkers ) ; int workerUpdateInterval = getUpdateInterval ( this . nrOfWorkers ) ; for ( int i = 0 ; i < this . nrOfWorkers ; i ++ ) { SimulationWorker worker ; WorkerBuilder builder ; if ( this . gameType == PokerType . TEXAS_HOLDEM ) { builder = TexasHoldemWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA ) { builder = OmahaWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA_HILO ) { builder = OmahaHiLoWorker . builder ( ) ; } else if ( this . gameType == PokerType . FOMAHA ) { builder = FiveCardOmahaWorker . builder ( ) ; } else { builder = FiveCardOmahaHiLoWorker . builder ( ) ; } builder . setCommunityCards ( this . communityCards ) . setNotifier ( this ) . setRounds ( roundsPerWorker ) . setUpdateInterval ( workerUpdateInterval ) ; for ( PlayerProfile profile : this . profiles ) { builder . addPlayer ( profile ) ; } worker = builder . build ( ) ; this . executor . execute ( worker ) ; this . workers . add ( worker ) ; } this . startTime = System . currentTimeMillis ( ) ; this . isRunning = true ; Thread masterThread = new Thread ( new Supervisor ( ) ) ; masterThread . setDaemon ( true ) ; masterThread . start ( ) ; SimulationEvent event = new SimulationEvent ( SimulationEvent . EVENT_SIM_STARTED , this . nrOfWorkers ) ; this . notifiable . onSimulationStart ( event ) ; }
tr	8	public boolean isSuperset ( Collection < ? > coll ) { if ( coll == this ) return true ; else if ( size ( ) < coll . size ( ) ) return false ; else if ( coll instanceof FLinkedHashSet ) { FLinkedHashSet < Object > flhs = ( FLinkedHashSet < Object > ) coll ; return FHashSet . isSubset ( flhs . set_tree , set_tree ) ; } else if ( coll instanceof FHashSet ) { FHashSet fhs = ( FHashSet ) coll ; return FHashSet . isSubset ( fhs . tree , set_tree ) ; } else if ( ! ( coll instanceof Set ) ) return false ; else { for ( Object elt : coll ) if ( ! FHashSet . contains ( set_tree , elt , hashCode ( elt ) ) ) return false ; return true ; } }
tr	0	protected void informNextPlayerToGo ( String currentIP , int currentPort ) { int nextPlayerToGo = getNextTurnPlayerID ( pg . getPlayerIndex ( currentIP , currentPort ) ) ; srvrWaitingOnPlayerIndex = nextPlayerToGo ; pg . broadcastMessage ( "sTurn " + pg . getPlayer ( nextPlayerToGo ) . getNickName ( ) ) ; }
tr	2	protected void markCreatedNode ( Node newNode ) { if ( ! ( newNode instanceof ObjectNode ) ) return ; if ( ! containsAncestor ( createdNodes , newNode ) ) { Node . createdNodes . add ( newNode ) ; } }
tr	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	8	public boolean equals ( consultar_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	9X	public static < KEY , VALUE > Map < KEY , VALUE > runIdempotentTasks ( Collection < ? extends IDependentTask < KEY , VALUE >> tasks , ExecutorService es , int maxRounds ) throws Exception { final Map < KEY , VALUE > out = new HashMap < KEY , VALUE > ( ) ; Map < KEY , IDependentTask < KEY , VALUE >> allTasks = new HashMap < KEY , MraUtils . IDependentTask < KEY , VALUE >> ( ) ; for ( IDependentTask < KEY , VALUE > t : tasks ) { allTasks . put ( t . getTaskID ( ) , t ) ; } Set < KEY > remaining = new HashSet < KEY > ( allTasks . keySet ( ) ) ; Set < KEY > done = new HashSet < KEY > ( ) ; Map < KEY , Integer > failures = new HashMap < KEY , Integer > ( ) ; while ( remaining . size ( ) > 0 ) { Set < KEY > toRun = new HashSet < KEY > ( ) ; for ( KEY k : remaining ) { if ( done . containsAll ( allTasks . get ( k ) . getDependsOn ( ) ) ) { toRun . add ( k ) ; } } if ( toRun . size ( ) == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } Map < KEY , Future < VALUE >> futures = new HashMap < KEY , Future < VALUE >> ( ) ; int submitted = 0 ; for ( KEY k : toRun ) { final IDependentTask < KEY , VALUE > t = allTasks . get ( k ) ; boolean block = false ; if ( failures . containsKey ( k ) ) { if ( failures . get ( k ) > maxRounds ) { block = true ; } } if ( ! block ) { submitted ++ ; futures . put ( k , es . submit ( new Callable < VALUE > ( ) { @ Override public VALUE call ( ) throws Exception { return t . call ( out ) ; } } ) ) ; } } if ( submitted == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } for ( KEY k : futures . keySet ( ) ) { try { out . put ( k , futures . get ( k ) . get ( ) ) ; done . add ( k ) ; } catch ( Exception e ) { if ( failures . containsKey ( k ) ) { failures . put ( k , failures . get ( k ) + 1 ) ; } else { failures . put ( k , 1 ) ; } logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } remaining . removeAll ( done ) ; } return out ; }
tr	6	private static int outcode ( double pX , double pY , double rectX , double rectY , double rectWidth , double rectHeight ) { int out = 0 ; if ( rectWidth <= 0 ) { out |= OUT_LEFT | OUT_RIGHT ; } else if ( pX < rectX ) { out |= OUT_LEFT ; } else if ( pX > rectX + rectWidth ) { out |= OUT_RIGHT ; } if ( rectHeight <= 0 ) { out |= OUT_TOP | OUT_BOTTOM ; } else if ( pY < rectY ) { out |= OUT_TOP ; } else if ( pY > rectY + rectHeight ) { out |= OUT_BOTTOM ; } return out ; }
tr	1	public int [ ] getAction_Per_State_As_Array ( ) { int ret [ ] = new int [ noOfStates ] ; for ( int i = 0 ; i < noOfStates ; i ++ ) { ret [ i ] = action_Per_State . get ( i ) ; } return ret ; }
tr	3	public void updateScoreWithEmptyProbList ( long submissionId , long questId ) { PreparedStatement statement = null ; Connection connection = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Updating the score of an user in a questionnaire: " + questId ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; statement . setLong ( 1 , submissionId ) ; statement . setLong ( 2 , questId ) ; DeadLockHandler . executeUpdate ( statement ) ; } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( null , statement , connection ) ; } }
tr	0	@ Override public void paint ( Graphics g ) { Graphics2D canvas = ( Graphics2D ) g ; clearCanvas ( canvas ) ; drawRectangle ( canvas ) ; }
tr	6	public static void display ( MapInfo mapInfo ) { StdDraw . setXscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setYscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setPenColor ( StdDraw . RED ) ; StdDraw . setPenColor ( StdDraw . BLACK ) ; for ( int row = 1 ; row < mapInfo . getMapSize ( ) - 1 ; row ++ ) { for ( int column = 1 ; column < mapInfo . getMapSize ( ) - 1 ; column ++ ) { if ( mapInfo . getCell ( row , column ) . isSouth ( ) ) StdDraw . line ( row + 1 , column , row + 1 , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isNorth ( ) ) StdDraw . line ( row , column , row , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isWest ( ) ) StdDraw . line ( row , column , row + 1 , column ) ; if ( mapInfo . getCell ( row , column ) . isEast ( ) ) StdDraw . line ( row , column + 1 , row + 1 , column + 1 ) ; } } StdDraw . show ( 1000 ) ; }
tr	2	protected MemoryEfficientString subSequence ( int start , int end ) { if ( start < 0 || end > ( data . length ) ) { throw new IllegalArgumentException ( "Illegal range " + start + "-" + end + " for sequence of length " + data . length ) ; } byte [ ] newdata = new byte [ end - start ] ; System . arraycopy ( data , start , newdata , 0 , end - start ) ; return new MemoryEfficientString ( newdata ) ; }
tr	7	public void delete ( K key ) { BinaryTreeNode < K , V > node = search ( key ) ; BinaryTreeNode < K , V > parent = node . getParent ( ) ; if ( node == null ) return ; if ( node . hasLeft ( ) && node . hasRight ( ) ) { BinaryTreeNode < K , V > successor = node . getNext ( ) ; if ( node . getRight ( ) . equals ( successor ) ) { successor . moveTo ( node ) ; } else { successor . getParent ( ) . setLeft ( successor . getRight ( ) ) ; successor . setRight ( null ) ; successor . transplant ( node ) ; } } else if ( node . hasLeft ( ) ) { node . getLeft ( ) . moveTo ( node ) ; } else if ( node . hasRight ( ) ) { node . getRight ( ) . moveTo ( node ) ; } else { if ( parent . isLeftChild ( this ) ) { parent . setLeft ( null ) ; } else { parent . setRight ( null ) ; } } }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	4	private List < Word > getCandidates ( Word word , Map < Character , Character > l2lEncrypt ) { List < Word > candidates = new LinkedList < Word > ( ) ; Map < Integer , List < Word >> wordsMap = dict . get ( word . getLength ( ) ) ; if ( wordsMap == null ) { return candidates ; } List < Word > words = wordsMap . get ( word . getNbrSimilarLetters ( ) ) ; if ( words == null ) { return candidates ; } for ( Word w : words ) { if ( w . equals ( word , l2lEncrypt ) ) { candidates . add ( w ) ; } } return candidates ; }
tr	9X	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	5	protected com . akamon . slots . model . BetClass ParseBetClass ( BetClass xmlBetClass ) throws SlotModelException { int baseBet = xmlBetClass . basebet ; String betMultList = xmlBetClass . betMultList ; if ( betMultList . equals ( "*" ) || betMultList . toUpperCase ( ) . equals ( "ALL" ) ) return new com . akamon . slots . model . BetClass ( baseBet ) ; else { HashSet < Integer > betMults = new HashSet < Integer > ( ) ; String [ ] splitBetMultList = betMultList . split ( " " ) ; for ( int i = 0 ; i < splitBetMultList . length ; i ++ ) { try { int betMult = Integer . parseInt ( splitBetMultList [ i ] ) ; if ( betMults . contains ( betMult ) ) throw new com . akamon . slots . model . SlotModelException ( "Bet class has duplicate bet multipliers: " + betMultList ) ; betMults . add ( betMult ) ; } catch ( Exception e ) { throw new com . akamon . slots . model . SlotModelException ( "Invalid bet class value: " + splitBetMultList [ i ] ) ; } } return new com . akamon . slots . model . BetClass ( baseBet , betMults ) ; } }
tr	0	public void setFPublic ( BigInteger value ) { this . fPublic = value ; }
tr	9X	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Icon" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isXDirty ) { change += "<x>" + this . x + "</x>\n" ; this . isXDirty = false ; } if ( this . isYDirty ) { change += "<y>" + this . y + "</y>\n" ; this . isYDirty = false ; } if ( this . isWDirty ) { change += "<w>" + this . w + "</w>\n" ; this . isWDirty = false ; } if ( this . isHDirty ) { change += "<h>" + this . h + "</h>\n" ; this . isHDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Icon>\n" ; } setNotDirty ( ) ; return change ; }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case QUEUE_NAME : if ( value == null ) { unset_queue_name ( ) ; } else { set_queue_name ( ( String ) value ) ; } break ; case MAX_ITEMS : if ( value == null ) { unset_max_items ( ) ; } else { set_max_items ( ( Integer ) value ) ; } break ; case TIMEOUT_MSEC : if ( value == null ) { unset_timeout_msec ( ) ; } else { set_timeout_msec ( ( Integer ) value ) ; } break ; case AUTO_ABORT_MSEC : if ( value == null ) { unset_auto_abort_msec ( ) ; } else { set_auto_abort_msec ( ( Integer ) value ) ; } break ; } }
tr	3	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	8	public void method344 ( int i , int j , int k ) { for ( int i1 = 0 ; i1 < myPixels . length ; i1 ++ ) { int j1 = myPixels [ i1 ] ; if ( j1 != 0 ) { int k1 = j1 >> 16 & ff ; k1 += i ; if ( k1 < 1 ) k1 = 1 ; else if ( k1 > 255 ) k1 = 255 ; int l1 = j1 >> 8 & ff ; l1 += j ; if ( l1 < 1 ) l1 = 1 ; else if ( l1 > 255 ) l1 = 255 ; int i2 = j1 & ff ; i2 += k ; if ( i2 < 1 ) i2 = 1 ; else if ( i2 > 255 ) i2 = 255 ; myPixels [ i1 ] = ( k1 << 16 ) + ( l1 << 8 ) + i2 ; } } }
tr	0	public Location ( int x , int y ) { this . x = x ; this . y = y ; }
tr	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	3	public String getMimetype ( String paramString ) { int i = paramString . lastIndexOf ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramString . length ( ) ) ) { String str1 = paramString . substring ( i + 1 ) ; if ( this . extensionToMimetypeMap . keySet ( ) . contains ( str1 ) ) { String str2 = ( String ) this . extensionToMimetypeMap . get ( str1 ) ; logger . info ( "Recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "Extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "File name has no extension  mime type cannot be recognised for: " + paramString ) ; } return "application/octet-stream" ; }
tr	9X	public String toString ( ) { String s = "" ; Node n = this ; while ( n != null ) { s += "[Node type=" ; s += nodeTypeString [ n . type ] ; s += " element=" ; if ( n . element != null ) s += n . element ; else s += "null" ; if ( n . type == TextNode || n . type == CommentTag || n . type == ProcInsTag ) { s += " text=" ; if ( n . textarray != null && n . start <= n . end ) { s += "\"" ; s += Lexer . getString ( n . textarray , n . start , n . end - n . start ) ; s += "\"" ; } else { s += "null" ; } } s += " content=" ; if ( n . content != null ) s += n . content . toString ( ) ; else s += "null" ; s += "]" ; if ( n . next != null ) s += " " ; n = n . next ; } return s ; }
tr	8	public static List < String > getAlbumsImages ( String link ) { List < String > dataSets = new ArrayList < String > ( ) ; link = link . replace ( "http://tu.duowan.com/g/" , "" ) . replace ( ".html" , "" ) . replace ( "/" , "" ) ; int num = - 1 ; try { num = Integer . parseInt ( link , 16 ) ; } catch ( Exception e ) { } if ( num == - 1 ) { return dataSets ; } String srollUrl = "http://tu.duowan.com/scroll/" + num + ".html" ; Document doc = ConnUtil . getHtmlDocument ( srollUrl ) ; if ( doc == null ) { return dataSets ; } loadPage ( doc , dataSets ) ; Elements pages = doc . select ( "div.mod-page" ) ; if ( pages != null && pages . size ( ) > 0 ) { showMsg ( pages . toString ( ) ) ; for ( Element el : pages ) { Elements pageLinks = el . select ( "a" ) ; for ( int i = 1 ; i < pageLinks . size ( ) ; i ++ ) { String pageUrl = pageLinks . get ( i ) . attr ( "href" ) ; srollUrl = "http://tu.duowan.com/" + pageUrl ; Document pagedoc = ConnUtil . getHtmlDocument ( srollUrl ) ; if ( pagedoc != null ) { loadPage ( pagedoc , dataSets ) ; } } } } showMsg ( "size" + dataSets . size ( ) ) ; return dataSets ; }
tr	1	public void buyGem ( Gem gem ) { if ( MagicPower . decrease ( gem ) ) { map . setGem ( gem ) ; } else listener . onError ( TDActionListener . NO_MP ) ; }
tr	3	@ Override public < T > T accept ( ParseTreeVisitor < ? extends T > visitor ) { if ( visitor instanceof SSTVisitor ) return ( ( SSTVisitor < ? extends T > ) visitor ) . visitComparesignals ( this ) ; else return visitor . visitChildren ( this ) ; }
tr	1	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	5	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	6	private String getPage ( int page , Map < String , Object > map ) { int factor = 5 ; int index = ( page - 1 ) * factor ; int listSize = map . size ( ) ; if ( index > listSize ) { return "" ; } int upper = index + factor ; if ( upper >= listSize ) { upper = listSize ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( ChatColor . RED ) . append ( plugin . getName ( ) ) . append ( "\n" ) . append ( ChatColor . RESET ) ; sb . append ( "Page " ) . append ( page ) . append ( "/" ) . append ( ( int ) Math . ceil ( ( double ) listSize / ( double ) factor ) ) ; sb . append ( "\n" ) . append ( ChatColor . RESET ) ; String [ ] list = map . keySet ( ) . toArray ( new String [ listSize ] ) ; Arrays . sort ( list ) ; for ( int i = index ; i < upper ; i ++ ) { Object test = map . get ( list [ i ] ) ; if ( test != null ) { if ( test instanceof SubCommand ) { SubCommand db = ( SubCommand ) map . get ( list [ i ] ) ; sb . append ( db . getHelp ( ) [ 0 ] ) . append ( " - " ) . append ( db . getHelp ( ) [ 1 ] ) ; } if ( i != upper - 1 ) { sb . append ( "\n" ) ; } } } sb . append ( '' ) . append ( ChatColor . YELLOW ) . append ( "Use /ttp help <command> to get help for a specific command" ) ; return sb . toString ( ) ; }
tr	1	public void test_SimpleDateFormat_parse_minusYyyy ( ) { final String target = "-2007-04-05 00:00:00" ; final SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date date ; try { date = format . parse ( target ) ; } catch ( ParseException e ) { throw new RuntimeException ( "Failed to parse the string: " + target , e ) ; } String actual = toString ( date , "GGGyyyy-MM-dd HH:mm:ss.SSS" ) ; log ( actual ) ; assertEquals ( "\u7D00\u5143\u524D2008-04-05 00:00:00.000" , actual ) ; assertNotNull ( date ) ; }
tr	2	@ Override public InputStream getInputStream ( ) throws IOException { switch ( failValue ) { case 0 : return new InputStream ( ) { @ Override public int read ( ) throws IOException { return 1 ; } } ; case 1 : return null ; default : throw new IOException ( ) ; } }
tr	9X	public boolean isPalindrome ( String s ) { if ( s == null ) return false ; if ( s . equals ( "" ) ) return true ; String sLow = s . toLowerCase ( ) ; char [ ] S = sLow . toCharArray ( ) ; int left = 0 , right = s . length ( ) - 1 ; while ( left < right ) { while ( ( S [ left ] < 0 || S [ left ] > 9 ) && ( S [ left ] < a || S [ left ] > z ) && ( left < right ) ) { left ++ ; } while ( ( S [ right ] < 0 || S [ right ] > 9 ) && ( S [ right ] < a || S [ right ] > z ) && ( left < right ) ) { right -- ; } if ( S [ left ++ ] != S [ right -- ] ) return false ; } return true ; }
tr	5	private void jButton16ActionPerformed ( java . awt . event . ActionEvent evt ) { String s = ( String ) listaElevi . getSelectedValue ( ) ; liceu . Administrator admin = new liceu . Administrator ( ) ; admin . delUser ( s ) ; BufferedReader fisier ; try { fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } listModelElevi . clear ( ) ; for ( int i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Administratorapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Administratorapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	1	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
tr	9X	private void doBounds ( List < Timeslot > slots , boolean isLabs , boolean hasLabs , boolean hasTuts ) { if ( ! alreadyRUN ) { if ( isLabs && ! hasTuts ) alreadyRUN = true ; else if ( ! isLabs && hasTuts ) { alreadyRUN = true ; } save . setEnabled ( true ) ; int startRow ; if ( isLabs ) { startRow = 0 ; } else startRow = sessionBoundsLabs . size ( ) + 5 ; ArrayList < Bounds > sessionBounds = new ArrayList < Bounds > ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . insets = new Insets ( 2 , 2 , 2 , 2 ) ; c . fill = GridBagConstraints . VERTICAL ; JPanel panel ; if ( isLabs ) panel = innerLabsPanel ; else panel = innerTutorialsPanel ; panel . removeAll ( ) ; c . weightx = 0.5 ; c . gridx = 0 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Session Name " ) ) ; c . gridx = 1 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Min      " ) ) ; c . gridx = 2 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Max      " ) ) ; c . gridx = 3 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Pref. Min" ) ) ; c . gridx = 4 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Pref. Max" ) ) ; String sectionTitle = "" ; if ( isLabs ) { sectionTitle = "LABS" ; } else { sectionTitle = "TUTS" ; } createTitleRow ( panel , 3 + startRow , sectionTitle ) ; for ( int i = 0 ; i < slots . size ( ) ; i ++ ) { Bounds timeslotBounds = new Bounds ( slots . get ( i ) ) ; sessionBounds . add ( timeslotBounds ) ; String slotTitle = slots . get ( i ) . toString ( ) ; timeslotBounds . createInputBoxes ( panel , i + 4 + startRow , slotTitle ) ; } if ( isLabs ) sessionBoundsLabs = sessionBounds ; else sessionBoundsTuts = sessionBounds ; } innerLabsPanel . setOpaque ( false ) ; innerTutorialsPanel . setOpaque ( false ) ; labsPanel . setOpaque ( false ) ; tutorialsPanel . setOpaque ( false ) ; labsPanel . setPreferredSize ( new Dimension ( innerLabsPanel . getWidth ( ) , ( int ) ( heightOfBounds ) ) ) ; tutorialsPanel . setPreferredSize ( new Dimension ( innerTutorialsPanel . getWidth ( ) , ( int ) ( heightOfBounds ) ) ) ; frame . validate ( ) ; frame . pack ( ) ; }
tr	2	public List < WishList > find ( int idu ) throws InstanceNotFoundException { List < WishList > list = new ArrayList < WishList > ( ) ; try { Connection connection = DataSourceUtils . getConnection ( dataSource ) ; PreparedStatement statement = connection . prepareStatement ( "SELECT idu  idp FROM wishlist WHERE idu=?" ) ; statement . setInt ( 1 , idu ) ; ResultSet resultSet = statement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new WishList ( resultSet . getInt ( 2 ) , resultSet . getInt ( 1 ) ) ) ; } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return list ; }
tr	9X	public void generate ( Point start ) { Stack < Point > waysToExpand = new Stack < > ( ) ; exitFound = false ; final List < Point > nextOptions = new ArrayList < > ( 4 ) ; waysToExpand . add ( start ) ; while ( ! waysToExpand . isEmpty ( ) ) { Point p = waysToExpand . pop ( ) ; if ( canBecomeWhite ( p ) ) { arr . setWhite ( p ) ; if ( onTheEdge ( p ) && p . differsFrom ( start ) ) { exitFound = true ; } if ( isBlack ( p . up ( ) ) && canBecomeWhite ( p . up ( ) ) ) nextOptions . add ( p . up ( ) ) ; if ( isBlack ( p . down ( ) ) && canBecomeWhite ( p . down ( ) ) ) nextOptions . add ( p . down ( ) ) ; if ( isBlack ( p . left ( ) ) && canBecomeWhite ( p . left ( ) ) ) nextOptions . add ( p . left ( ) ) ; if ( isBlack ( p . right ( ) ) && canBecomeWhite ( p . right ( ) ) ) nextOptions . add ( p . right ( ) ) ; Collections . shuffle ( nextOptions ) ; int c = 0 ; for ( Point t : nextOptions ) { waysToExpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextOptions . clear ( ) ; } } }
tr	7	public boolean isSolid ( int x , int y ) { if ( x < 0 || y < 0 || x >= surface . length || y >= surface . length ) return true ; if ( surface [ x ] [ y ] . isSolid ( ) ) return true ; for ( Entity e : entities ) { if ( e . isSolid ( x , y ) ) return true ; } return false ; }
tr	4	public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof Tir ) ) return false ; Tir tmp = ( Tir ) o ; if ( ! tmp . position . equals ( position ) ) return false ; if ( tmp . joueur != joueur ) return false ; return true ; }
tr	3	static private final int jjMoveStringLiteralDfa14_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 12 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , active0 ) ; return 14 ; } switch ( curChar ) { case 79 : return jjMoveStringLiteralDfa15_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 13 , active0 ) ; }
tr	6	protected void resolveUnclaimedPoints ( FaceList newFaces ) { Vertex vtxNext = unclaimed . first ( ) ; for ( Vertex vtx = vtxNext ; vtx != null ; vtx = vtxNext ) { vtxNext = vtx . next ; double maxDist = tolerance ; Face maxFace = null ; for ( Face newFace = newFaces . first ( ) ; newFace != null ; newFace = newFace . next ) { if ( newFace . mark == Face . VISIBLE ) { double dist = newFace . distanceToPlane ( vtx . pnt ) ; if ( dist > maxDist ) { maxDist = dist ; maxFace = newFace ; } if ( maxDist > 1000 * tolerance ) { break ; } } } if ( maxFace != null ) { addPointToFace ( vtx , maxFace ) ; } else { } } }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	2	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	9X	public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c !=   ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c ==   ) { break ; } if ( c !=   ) { if ( c == '' || c == '' || c == 0 ) { return ja ; } throw x . syntaxError ( "Bad character '" + c + "' (" + ( int ) c + ")." ) ; } c = x . next ( ) ; } } }
tr	2	public void listen ( int port ) { try { server = new ServerSocket ( port ) ; listening = true ; while ( listening ) { new HTTPClient ( server . accept ( ) ) . start ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	1	public T getValue ( ) { if ( available == false ) { throw new RuntimeException ( "Value not available" ) ; } return value ; }
tr	4	private void assignRoutesWithClosestDepotWithNeighbourCheckHeuristic ( ) { boolean [ ] clientMap = new boolean [ problemInstance . customerCount ] ; int assigned = 0 ; while ( assigned < problemInstance . customerCount ) { int clientNo = Utility . randomIntInclusive ( problemInstance . customerCount - 1 ) ; if ( clientMap [ clientNo ] ) continue ; clientMap [ clientNo ] = true ; assigned ++ ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { if ( periodAssignment [ period ] [ clientNo ] == false ) continue ; int depot = RouteUtilities . closestDepot ( clientNo ) ; insertClientToRouteThatMinimizesTheIncreaseInActualCost ( clientNo , depot , period ) ; } } }
tr	6	private int compare ( Object x , Object y ) { if ( x == null ) return ( y == null ? 0 : - 1 ) ; else if ( y == null ) return 1 ; else { if ( x instanceof EquivalentSet ) x = ( ( EquivalentSet ) x ) . contents . get ( 0 ) ; if ( y instanceof EquivalentSet ) y = ( ( EquivalentSet ) y ) . contents . get ( 0 ) ; if ( comp != null ) return comp . compare ( ( Elt ) x , ( Elt ) y ) ; else { Comparable cx = ( Comparable ) x ; Comparable cy = ( Comparable ) y ; return cx . compareTo ( cy ) ; } } }
tr	8	public < T > Put insert ( T instance ) { try { Field key = clazz . getField ( "key" ) ; byte [ ] keyRow = ( byte [ ] ) key . get ( instance ) ; Put update = new Put ( keyRow ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( f . isAnnotationPresent ( HRowKey . class ) ) { continue ; } else if ( f . isAnnotationPresent ( HMapFamily . class ) ) { Map m = ( Map ) f . get ( instance ) ; HMapFamily annotation = f . getAnnotation ( HMapFamily . class ) ; update = insertMapFamily ( update , m , annotation ) ; } else if ( f . isAnnotationPresent ( HProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HProperty annotation = f . getAnnotation ( HProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HMapProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HMapProperty annotation = f . getAnnotation ( HMapProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HListProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HListProperty annotation = f . getAnnotation ( HListProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else { log . debug ( String . format ( "Skipping field %s as it has no supported annotations" , f . getName ( ) ) ) ; } } return update ; } catch ( NoSuchFieldException e ) { log . error ( "Field not found" , e ) ; return null ; } catch ( IllegalAccessException e ) { log . error ( "Access exception" , e ) ; return null ; } }
tr	3	@ Override public void tick ( Input input , double delta ) { if ( this . dummy . getCommands ( ) . isEmpty ( ) ) { double ran = Math . random ( ) ; if ( ran >= 0.5 ) { } else { this . dummy . wait ( Math . random ( ) * 0.4 ) ; } ran = Math . random ( ) ; if ( ran >= 0.2 ) { this . dummy . getCommands ( ) . add ( new JumpCommand ( this . dummy ) ) ; } } }
tr	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
tr	2	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
tr	2	public void setThresholds ( List < U > thresholds ) throws Exception { if ( thresholds . size ( ) != neurons . size ( ) ) { throw new Exception ( "threshold count doesnt match neuron count in this layer" ) ; } for ( int i = 0 ; i < neurons . size ( ) ; i ++ ) { neurons . get ( i ) . setThreshold ( thresholds . get ( i ) ) ; } }
tr	3	public static boolean onOneLine ( XY xy , XY xy2 ) { if ( xy2 . getX ( ) == xy . getX ( ) ) { return true ; } if ( xy2 . getY ( ) == xy . getY ( ) ) { return true ; } int dx = Math . abs ( xy2 . getX ( ) - xy . getX ( ) ) ; int dy = Math . abs ( xy2 . getY ( ) - xy . getY ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
tr	8	public void executeSearch ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( "text/xml" ) ; Writer writer = response . getWriter ( ) ; String [ ] ownerIds = request . getParameterValues ( OWNERID ) ; if ( ownerIds == null || ownerIds . length != 1 ) { logger . debug ( "User didn't supply an ownerId" ) ; System . err . println ( ownerIds ) ; String error = "You must supply an ownerId" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String ownerId = ownerIds [ 0 ] ; String [ ] filterParamss = request . getParameterValues ( FILTERPARAMS ) ; if ( filterParamss == null || filterParamss . length != 1 ) { logger . debug ( "User didn't supply any filterParams" ) ; String error = "You must supply one set of filterParams" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String filterParams = filterParamss [ 0 ] ; FilterParams filterParamsObj = new FilterParams ( ) ; try { JAXBContext context = JAXBContext . newInstance ( FilterParams . class ) ; Unmarshaller um = context . createUnmarshaller ( ) ; filterParamsObj = ( FilterParams ) um . unmarshal ( new StringReader ( filterParams ) ) ; } catch ( JAXBException jbe ) { logger . warn ( "user supplied badly formed filterParams" ) ; String error = "Please make sure the filterParams is well formatted" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } try { DetermineWorkToDo work = new DetermineWorkToDo ( null , ownerId , filterParamsObj ) ; Integer jobSize = work . FilterCompoundsInDatabase ( ) . size ( ) ; response . setStatus ( 200 ) ; writer . write ( CreateShortReturn . createShortResponse ( jobSize . toString ( ) , false ) ) ; } catch ( AmazonServiceException ase ) { logger . error ( ase ) ; String error = "Error in AWS please try again later." ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( AmazonClientException ace ) { logger . error ( ace ) ; String error = "Internal error please try again" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( SQLException sqle ) { logger . error ( sqle ) ; String error = "Error connecting to SQL please try again later" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } }
tr	9X	public void DesativaCampos ( ) { for ( Component c : tela . getjPFicha ( ) . getComponents ( ) ) { if ( c instanceof JComboBox ) { ( ( JComboBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JCheckBox ) { ( ( JCheckBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JTextField ) { ( ( JTextField ) c ) . setEnabled ( false ) ; } if ( c instanceof JDateChooser ) { ( ( JDateChooser ) c ) . setEnabled ( false ) ; } if ( c instanceof JScrollPane ) { for ( Component co : ( ( JScrollPane ) c ) . getComponents ( ) ) { if ( co instanceof JViewport ) { for ( Component com : ( ( JViewport ) co ) . getComponents ( ) ) { if ( com instanceof JTextArea ) { ( ( JTextArea ) com ) . setEnabled ( false ) ; } } } } } } }
tr	2	@ Override public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( name . equals ( NAMESPACES_FEATURE ) || name . equals ( NAMESPACE_PREFIXES_FEATURE ) ) { return true ; } else { throw new SAXNotRecognizedException ( "Feature Not Supported: " + name ) ; } }
tr	6	public void log ( Level level , String str ) { if ( level . intValue ( ) >= LogLevel . intValue ( ) ) { StringBuilder out = new StringBuilder ( ) ; out . append ( "[" + clazz . getName ( ) + "]" ) ; out . append ( "[" + level . getName ( ) + "]" ) ; Time currentTime ; if ( Simulator . getWorld ( ) != null && Simulator . getWorld ( ) . getCurrentTime ( ) != null ) currentTime = Simulator . getWorld ( ) . getCurrentTime ( ) ; else currentTime = null ; out . append ( "[" + ( ( currentTime != null ) ? currentTime : "no time" ) + "]" ) ; out . append ( str ) ; if ( Simulator . getGUI ( ) != null ) { if ( level . intValue ( ) > FINE . intValue ( ) ) { JTextArea text = Simulator . getGUI ( ) . getLogWindow ( ) . getTextArea ( ) ; text . append ( out . toString ( ) + "\n" ) ; text . setCaretPosition ( text . getText ( ) . length ( ) ) ; } else { System . out . println ( out ) ; } } else { System . out . println ( out ) ; } } }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	4	public void testFileContent ( ) throws IOException { long start = System . currentTimeMillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; long end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	9X	public static LinkedList < String > generateAttackPlans ( AttackModel attack_model ) throws IOException , ScriptException { String attack_file = InfoEnum . current_directory + "/dlv/attack/attack_model.dl" ; Inference . writeFile ( attack_file , attack_model . generateFormalExpression ( InfoEnum . ALL_MODELS ) , false ) ; for ( Element e : attack_model . getElements ( ) ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ) { if ( re . getOutLinks ( ) . size ( ) == 0 ) { Inference . writeFile ( attack_file , "satisfied(" + re . getId ( ) + ")." , true ) ; break ; } } } String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/attack/find_alternative_attacks.rule " + attack_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < LinkedList < String >> all_alternatives = new LinkedList < LinkedList < String >> ( ) ; LinkedList < String > alternative_description = new LinkedList < String > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { LinkedList < String > one_alternative = new LinkedList < String > ( ) ; line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; boolean validity = false ; for ( String s : result ) { if ( s . startsWith ( "result" ) ) { String id = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( " " ) ) ; String target = s . substring ( s . indexOf ( " " ) + 1 , s . indexOf ( ")" ) ) . replace ( "_" , " " ) ; Element node = attack_model . findElementById ( id ) ; if ( node != null ) { if ( node . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { one_alternative . add ( "perform " + node . getName ( ) + " to " + target ) ; validity = true ; } } else { System . out . println ( "result elements cannot be found." ) ; } } else if ( s . startsWith ( "unachievable" ) ) { validity = false ; break ; } } if ( validity ) { all_alternatives . add ( one_alternative ) ; } } int number = 0 ; for ( LinkedList < String > list : all_alternatives ) { number ++ ; String temp = "Attack alterntive " + number + "(" + list . size ( ) + " attack)" + ":{" ; String attacks = "" ; for ( String attack : list ) { attacks += attack + "  " ; } temp += attacks . substring ( 0 , attacks . length ( ) - 2 ) ; temp += "}" ; alternative_description . add ( temp ) ; } return alternative_description ; }
tr	8	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	0	public boolean containsFamily ( String family ) { return families . contains ( family ) ; }
tr	9X	public final ExpressaoContext expressao ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; ExpressaoContext _localctx = new ExpressaoContext ( _ctx , _parentState , _p ) ; ExpressaoContext _prevctx = _localctx ; int _startState = 6 ; enterRecursionRule ( _localctx , RULE_expressao ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 54 ) ; switch ( _input . LA ( 1 ) ) { case int : { _localctx = new InteiroContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 47 ) ; match ( int ) ; } break ; case 16 : { _localctx = new LeiaContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 48 ) ; match ( 16 ) ; } break ; case ID : { _localctx = new IdContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 49 ) ; match ( ID ) ; } break ; case 10 : { _localctx = new ExpParContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 50 ) ; match ( 10 ) ; setState ( 51 ) ; expressao ( 0 ) ; setState ( 52 ) ; match ( 2 ) ; } break ; default : throw new NoViableAltException ( this ) ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 67 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 65 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 3 , _ctx ) ) { case 1 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 56 ) ; if ( ! ( 4 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "4 >= $_p" ) ; setState ( 57 ) ; match ( 7 ) ; setState ( 58 ) ; expressao ( 5 ) ; } break ; case 2 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 59 ) ; if ( ! ( 3 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "3 >= $_p" ) ; setState ( 60 ) ; match ( 6 ) ; setState ( 61 ) ; expressao ( 4 ) ; } break ; case 3 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 62 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 63 ) ; match ( 8 ) ; setState ( 64 ) ; expressao ( 3 ) ; } break ; } } } setState ( 69 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
tr	2	public T first ( UnaryFunction < T , boolean > predicate ) { while ( hasNext ( ) ) { final T value = next ( ) ; if ( predicate . invoke ( value ) ) { return value ; } } throw new NoSuchElementException ( ) ; }
tr	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
tr	7	private boolean isRowEmpty ( int rowIndex ) { if ( rowIndex < getRowCount ( ) - 1 ) { return ( ( participantList . get ( rowIndex ) . getFirstName ( ) == null || participantList . get ( rowIndex ) . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( participantList . get ( rowIndex ) . getLastName ( ) == null || participantList . get ( rowIndex ) . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } else { return ( ( lastRow . getFirstName ( ) == null || lastRow . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( lastRow . getLastName ( ) == null || lastRow . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } }
tr	3	public int maximum ( Node root ) { int root_val , left_val , right_val , max = Integer . MIN_VALUE ; if ( root != null ) { root_val = root . key ; left_val = maximum ( root . left ) ; right_val = maximum ( root . right ) ; if ( left_val > right_val ) max = left_val ; else max = - right_val ; if ( root_val > max ) max = root_val ; } return max ; }
tr	0	public byte getNotSettable ( ) { return notSettable ; }
tr	2	public void addThird ( Timeslot t ) { if ( t instanceof Lab ) { addThirdLab ( t ) ; } else if ( t instanceof Tutorial ) { addThirdTut ( t ) ; } }
tr	9X	private void parsePacket ( ) throws MpegDecodeException , IOException { Statistics . startLog ( PARSE_PACKET_STRING ) ; System . out . println ( "Parsing packet" ) ; if ( m_ioTool . getBits ( 24 ) != 1 ) { Debug . println ( Debug . ERROR , "Synchronization error in packet" ) ; throw new MpegDecodeException ( "Synchronization error in packet" ) ; } int streamId = m_ioTool . getBits ( 8 ) ; int pktLength = m_ioTool . getBits ( 16 ) ; if ( streamId != PRIVATE_STREAM2 ) { pktLength -= parseTimeStamps ( ) ; } if ( ( streamId & E0 ) == C0 ) { decodeAudio ( pktLength ) ; } else { if ( ( F0 & streamId ) == E0 ) { decodeVideo ( pktLength ) ; } else if ( ( F0 & streamId ) == F0 ) { ; } else { switch ( streamId ) { case RESERVED_STREAM : case PRIVATE_STREAM1 : case PADDING_STREAM : case PRIVATE_STREAM2 : break ; default : Debug . println ( Debug . ERROR , "Unknown Stream: " + streamId ) ; throw new MpegDecodeException ( "Unknown Stream: " + streamId ) ; } } } Statistics . endLog ( PARSE_PACKET_STRING ) ; }
tr	7	void updateGui ( String fieldname ) { Object fieldval = fieldvalues . get ( fieldname ) ; Object fieldcom = fieldcomponents . get ( fieldname ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; if ( fieldcom instanceof JCheckBox ) { ( ( JCheckBox ) fieldcom ) . setSelected ( ( ( boolean ) fieldval ) . booleanValue ( ) ) ; } else if ( fieldcom instanceof JColorChooser ) { JColorChooser jcc = ( JColorChooser ) fieldcom ; jcc . setColor ( ( Color ) fieldval ) ; } else if ( fieldcom instanceof KeyField ) { ( ( KeyField ) fieldcom ) . setValue ( ( ( Integer ) fieldval ) . intValue ( ) ) ; } else if ( fieldcom instanceof JTextField ) { JTextField textfield = ( JTextField ) fieldcom ; if ( fieldtype . equals ( "int" ) || fieldtype . equals ( "double" ) ) { textfield . setText ( "" + fieldval ) ; } else if ( fieldtype . equals ( "String" ) ) { textfield . setText ( "" + fieldval ) ; } } }
tr	0	@ Override public void handleEvent ( MatchEndedEvent domainEvent ) { PlayerReport playerReport = accountReportRepository . findById ( domainEvent . getAggregateId ( ) ) ; List < MatchReport > gamesStatistic = new ArrayList < MatchReport > ( ) ; gamesStatistic . addAll ( playerReport . getGamesStatistic ( ) ) ; gamesStatistic . add ( new MatchReport ( domainEvent . getAggregateId ( ) , domainEvent . getMatchResult ( ) ) ) ; accountReportRepository . add ( new PlayerReport ( domainEvent . getAggregateId ( ) , gamesStatistic , playerReport . getPlayerName ( ) ) ) ; }
tr	9X	public void postInstall ( ) { String plUser = Configuration . getConfig ( Configuration . CONFIG_PIPELINE_USER ) ; String startServer = Configuration . getConfig ( Configuration . START_PIPELINE_SERVER ) ; String configureServer = Configuration . getConfig ( Configuration . CONFIGURE_PIPELINE_SERVER ) ; String startClient = Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT ) ; boolean needsServerStart = startServer != null ? boolean . parseBoolean ( startServer ) : false ; boolean needsConfigureServer = configureServer != null ? boolean . parseBoolean ( configureServer ) : false ; boolean needsClientStart = startClient != null ? boolean . parseBoolean ( startClient ) : false ; if ( needsClientStart || needsConfigureServer || needsServerStart ) { StringBuilder cmd = new StringBuilder ( System . getProperty ( "user.dir" ) ) ; cmd . append ( "/install_files/postInstall.sh " ) ; cmd . append ( plUser ) ; cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . CONFIG_PIPELINE_LOCATION ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsServerStart ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsConfigureServer ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsClientStart ) ) ; if ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) != null ) { cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) ) ; } Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( cmd . toString ( ) ) ; if ( ! needsConfigureServer ) { StreamReader isr = new StreamReader ( p . getInputStream ( ) , 1 ) ; StreamReader esr = new StreamReader ( p . getErrorStream ( ) , 2 ) ; isr . start ( ) ; esr . start ( ) ; p . waitFor ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null && ! needsConfigureServer ) NativeCalls . releaseProcess ( p ) ; if ( needsConfigureServer ) Configuration . setConfig ( Configuration . CONFIGURE_PIPELINE_SERVER , "false" ) ; } } }
tr	2	public void removeBogusLegs ( ) { Iterator < Leg > it = legs . iterator ( ) ; while ( it . hasNext ( ) ) { Leg leg = it . next ( ) ; if ( leg . isBogusNonTransitLeg ( ) ) { it . remove ( ) ; } } }
tr	8	public void connect1 ( TreeLinkNode root ) { if ( root == null ) return ; Queue < TreeLinkNode > curLev = new LinkedList < TreeLinkNode > ( ) ; curLev . add ( root ) ; while ( ! curLev . isEmpty ( ) ) { Queue < TreeLinkNode > nextLev = new LinkedList < TreeLinkNode > ( ) ; while ( ! curLev . isEmpty ( ) ) { TreeLinkNode cur = curLev . poll ( ) ; if ( cur . left != null ) nextLev . add ( cur . left ) ; if ( cur . right != null ) nextLev . add ( cur . right ) ; if ( ! curLev . isEmpty ( ) ) { TreeLinkNode curNext = curLev . peek ( ) ; if ( curNext . left != null ) nextLev . add ( cur . left ) ; if ( curNext . right != null ) nextLev . add ( cur . right ) ; cur . next = curNext ; } } curLev = nextLev ; } }
tr	6	public Color getColor ( VesselType type ) { switch ( type ) { case SWIMMER : return Color . PINK ; case SPEED_BOAT : return Color . GREEN ; case FISHING_BOAT : return Color . CYAN ; case CARGO_BOAT : return Color . ORANGE ; case PASSENGER_VESSEL : return Color . MAGENTA ; case UNKNOWN : return Color . WHITE ; default : return Color . WHITE ; } }
tr	4	public static byte [ ] decodeFromFile ( String filename ) throws java . io . IOException { byte [ ] decodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = null ; int length = 0 ; int numBytes = 0 ; if ( file . length ( ) > Integer . MAX_VALUE ) { throw new java . io . IOException ( "File is too big for this convenience method (" + file . length ( ) + " bytes)." ) ; } buffer = new byte [ ( int ) file . length ( ) ] ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . DECODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) { length += numBytes ; } decodedData = new byte [ length ] ; System . arraycopy ( buffer , 0 , decodedData , 0 , length ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return decodedData ; }
tr	2	public static void changeSize ( final File file , final long newSize ) { try { RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; randomAccessFile . setLength ( newSize ) ; randomAccessFile . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	2	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SchoolYear other = ( SchoolYear ) obj ; if ( end == null ) { if ( other . end != null ) return false ; } else if ( ! end . equals ( other . end ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( start == null ) { if ( other . start != null ) return false ; } else if ( ! start . equals ( other . start ) ) return false ; return true ; }
tr	1	public synchronized boolean method234 ( int i , byte abyte0 [ ] , int j ) { boolean flag = method235 ( true , j , i , abyte0 ) ; if ( ! flag ) flag = method235 ( false , j , i , abyte0 ) ; return flag ; }
tr	9X	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
tr	5	public static boolean isValidWeekInMonthCode ( final int code ) { switch ( code ) { case FIRST_WEEK_IN_MONTH : case SECOND_WEEK_IN_MONTH : case THIRD_WEEK_IN_MONTH : case FOURTH_WEEK_IN_MONTH : case LAST_WEEK_IN_MONTH : return true ; default : return false ; } }
tr	3	public int hyppaaTulevaSana ( String syote ) { int matka = 0 ; while ( matka < syote . length ( ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( " " ) ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( ")" ) ) ) { matka ++ ; } return matka ; }
tr	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof InviteRes ) ) { return false ; } final InviteRes _cast = ( InviteRes ) _other ; if ( inviteRes == null ? _cast . inviteRes != inviteRes : ! inviteRes . equals ( _cast . inviteRes ) ) { return false ; } return true ; }
tr	3	@ EventHandler ( priority = EventPriority . LOWEST ) public void lever ( PlayerInteractEvent event ) { Action action = event . getAction ( ) ; if ( action == Action . LEFT_CLICK_BLOCK || action == Action . RIGHT_CLICK_BLOCK ) { if ( event . getClickedBlock ( ) . getType ( ) == Material . LEVER ) { prevent ( event , event . getPlayer ( ) , "lever interact" ) ; } } }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	1	double getLongitudeInDegrees ( double row , double positionInRow ) { double offset = getPositionOffset ( row ) ; double rowLength = getRowLength ( row ) ; if ( rowLength == 0 ) { return 0 ; } double adjustedPosition = ( positionInRow + offset ) % rowLength ; return 360.0 * adjustedPosition / rowLength ; }
tr	0	public UserSessionVO getUserSessionVO ( ) { return userSessionVO ; }
tr	6	public static String replaceAll ( String origin , String oldPart , String replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldPart == null || oldPart . length ( ) == 0 ) { return origin ; } int index = origin . indexOf ( oldPart ) ; if ( index < 0 ) { return origin ; } StringBuffer sb = new StringBuffer ( origin ) ; do { sb . replace ( index , index + oldPart . length ( ) , replacement ) ; origin = sb . toString ( ) ; index = origin . indexOf ( oldPart ) ; } while ( index != - 1 ) ; return origin ; }
tr	9X	public void outDem ( String s , int color , boolean bold ) { String sortie = "" ; sortie += "\u001B[" ; if ( bold ) sortie += "1;" ; switch ( color ) { case 0 : sortie += "30" ; break ; case 1 : sortie += "31" ; break ; case 2 : sortie += "32" ; break ; case 3 : sortie += "33" ; break ; case 4 : sortie += "34" ; break ; case 5 : sortie += "35" ; break ; case 6 : sortie += "36" ; break ; case 7 : sortie += "37" ; break ; } sortie += "mServeur " + Global . TCP_PORT + " : " + s + "\u001B[0m\n" ; try { Thread . sleep ( ( int ) Math . abs ( Math . random ( ) * 20 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . print ( sortie ) ; }
tr	9X	public static int countDayInMonth ( long month ) { Date d = new Date ( month ) ; int monthIndex = d . getMonth ( ) ; int year = d . getYear ( ) ; switch ( monthIndex ) { case 0 : case 2 : case 4 : case 6 : case 7 : case 9 : case 11 : return 31 ; case 1 : return isLeapYear ( year ) ? 29 : 28 ; default : return 30 ; } }
tr	1	public static PrivateKey readPrivateKeyFromDER ( String fileName ) { try { InputStream fl = fullStream ( fileName ) ; byte [ ] key = new byte [ fl . available ( ) ] ; KeyFactory kf = KeyFactory . getInstance ( "RSA" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec ( key ) ; PrivateKey privK = kf . generatePrivate ( keysp ) ; return privK ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( null == obj ) { return false ; } if ( this == obj ) { return true ; } if ( obj instanceof PostParameter ) { PostParameter that = ( PostParameter ) obj ; if ( file != null ? ! file . equals ( that . file ) : that . file != null ) return false ; return this . name . equals ( that . name ) && this . value . equals ( that . value ) ; } return false ; }
tr	9X	public void actionPerformed ( ActionEvent e ) { if ( GridButton . class . isInstance ( e . getSource ( ) ) ) { GridButton b = ( GridButton ) e . getSource ( ) ; switch ( b . getColumn ( ) ) { case ( 0 ) : { client . openFile ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } case ( 1 ) : { int n = JOptionPane . showConfirmDialog ( this , "Delete " + networkFiles . get ( b . getRow ( ) ) + " from the network?" , "Are you sure?" , JOptionPane . YES_NO_OPTION ) ; if ( n == 0 ) client . deleteFileFromNetwork ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } case ( 2 ) : { int n = JOptionPane . showConfirmDialog ( this , "Delete " + networkFiles . get ( b . getRow ( ) ) + " locally?" , "Are you sure?" , JOptionPane . YES_NO_OPTION ) ; if ( n == 0 ) client . deleteLocalFile ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } default : { break ; } } } else if ( JButton . class . isInstance ( e . getSource ( ) ) ) { JButton b = ( JButton ) e . getSource ( ) ; if ( b == loginButton ) { this . updateStatusLabel ( "Logging into the system. Please wait..." ) ; client . loginSystem ( ) ; } else if ( b == logoutButton ) { this . updateStatusLabel ( "Logging out the system. Please wait..." ) ; logoutStatusWindow = new LogoutStatusWindow ( this ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { client . logoutSystem ( ) ; } } ) . start ( ) ; } else if ( b == addFileButton ) { if ( client . getSessionState ( ) ) { int returnValue = fileChooser . showOpenDialog ( this ) ; if ( returnValue == JFileChooser . APPROVE_OPTION ) { client . importFile ( fileChooser . getSelectedFile ( ) ) ; } } } else if ( b == infoButton ) { LinkedNodesWindow l = new LinkedNodesWindow ( this ) ; client . TESTprintOwnerFiles ( ) ; } else if ( b == settingsButton ) { SettingsWindow s = new SettingsWindow ( this ) ; } } }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	5	public String getLatestTransmissionAttempt ( ) { if ( transmissionAttempts == 0 ) { return "no attempt yet" ; } switch ( transmissionAttempts ) { case 1 : return "first attempt" ; case 2 : return "second attempt" ; case 3 : return "third attempt" ; case 4 : return "fourth attempt" ; default : return "attempt #" + transmissionAttempts ; } }
tr	0	public final int getSolutionMemoryMegabytes ( ) { return this . solutionMemoryMegabytes ; }
tr	5	private final void isaac ( ) { int i , x , y ; b += ++ c ; for ( i = 0 ; i < SIZE ; ++ i ) { x = mem [ i ] ; switch ( i & 3 ) { case 0 : a ^= a << 13 ; break ; case 1 : a ^= a >>> 6 ; break ; case 2 : a ^= a << 2 ; break ; case 3 : a ^= a >>> 16 ; break ; } a += mem [ ( i + SIZE / 2 ) & ( SIZE - 1 ) ] ; mem [ i ] = y = mem [ ( ( x ) & MASK ) >> 2 ] + a + b ; rsl [ i ] = b = mem [ ( ( y >> SIZEL ) & MASK ) >> 2 ] + x ; } }
tr	1	@ Override public Object [ ] [ ] getAll ( ) { DAOFactory factory = DAOFactory . getDAOFactory ( ) ; TeacherDAO dao = factory . getTeacherDAO ( ) ; List < Teacher > teachers = dao . selectAll ( ) ; Object [ ] [ ] rowData = new Object [ teachers . size ( ) ] [ 4 ] ; for ( int i = 0 ; i < teachers . size ( ) ; i ++ ) { Teacher teacher = teachers . get ( i ) ; rowData [ i ] [ 0 ] = teacher . getCode ( ) ; rowData [ i ] [ 1 ] = teacher . getNames ( ) ; rowData [ i ] [ 2 ] = dateFormatHelper . format ( teacher . getBirthday ( ) ) ; rowData [ i ] [ 3 ] = teacher . getEmail ( ) ; } return rowData ; }
tr	9X	public static Op IT ( Op a , Op b ) { if ( a == null ) return null ; if ( b == null ) return a ; int at = a . getOpType ( ) , bt = b . getOpType ( ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . INSERT_CHAR ) return ii ( ( Insertion ) a , ( Insertion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . DELETE_CHAR ) return dd ( ( Deletion ) a , ( Deletion ) b ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . DELETE_CHAR ) return id ( ( Insertion ) a , ( Deletion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . INSERT_CHAR ) return di ( ( Deletion ) a , ( Insertion ) b ) ; return null ; }
tr	1	public final void startup ( ) { if ( ! running ) { running = true ; doStartup ( ) ; } }
tr	8	public boolean isInitial ( int c ) { return Character . isLetter ( c ) || c == * || c == / || c == > || c == < || c == = || c == ? || c == ! || c == . ; }
tr	4	private Nodo buscarNodo ( String padre ) { Nodo tmp1 = this . raiz ; Nodo tmp2 = tmp1 ; StringTokenizer path = new StringTokenizer ( padre , "/" ) ; String s ; while ( path . hasMoreTokens ( ) ) { s = path . nextToken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerHijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguienteHermano ; } } return tmp2 ; }
tr	7	public int Compare ( SpamSumSignature signature1 , SpamSumSignature signature2 ) { long block_size1 , block_size2 ; long score ; byte [ ] s1 , s2 ; byte [ ] s1_1 , s1_2 ; byte [ ] s2_1 , s2_2 ; if ( null == signature1 || null == signature2 ) { return - 1 ; } block_size1 = signature1 . getBlockSize ( ) ; block_size2 = signature2 . getBlockSize ( ) ; if ( block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2 ) { return 0 ; } s1 = eliminate_sequences2 ( signature1 . getHashPart1 ( ) ) ; s2 = eliminate_sequences2 ( signature2 . getHashPart1 ( ) ) ; s1_1 = s1 ; s2_1 = s2 ; s1_2 = eliminate_sequences2 ( signature1 . getHashPart2 ( ) ) ; s2_2 = eliminate_sequences2 ( signature2 . getHashPart2 ( ) ) ; if ( block_size1 == block_size2 ) { long score1 , score2 ; score1 = score_strings ( s1_1 , s2_1 , block_size1 ) ; score2 = score_strings ( s1_2 , s2_2 , block_size2 ) ; score = Math . max ( score1 , score2 ) ; } else if ( block_size1 == block_size2 * 2 ) { score = score_strings ( s1_1 , s2_2 , block_size1 ) ; } else { score = score_strings ( s1_2 , s2_1 , block_size2 ) ; } return ( int ) score ; }
tr	4	public void testIsWinner ( ) { beginTest ( "countFields method" ) ; boolean result ; for ( int i = 0 ; i < 31 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 32 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , false , result ) ; setUp ( ) ; for ( int i = 0 ; i < 32 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 33 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , true , result ) ; }
tr	2	public boolean verifyStudentFields ( ) { if ( studentNameField . getText ( ) . length ( ) == 0 || ! Util . isNumeric ( studentGroupField . getText ( ) ) ) { JOptionPane . showMessageDialog ( null , Window . geti18nString ( ADialog . STUDENT_NAME_OR_GROUP_ISN_T_CORRECT ) ) ; return false ; } return true ; }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	7	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	9X	public void rotateCounterClockwise ( ) { boolean temp [ ] [ ] = new boolean [ PIECE_SIZE ] [ PIECE_SIZE ] ; for ( int i = 0 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { temp [ i ] [ j ] = currentShape [ j ] [ PIECE_SIZE - i - 1 ] ; } } currentShape = temp ; while ( shiftUp ( ) ) ; int tmp = width ; width = height ; height = tmp ; switch ( state ) { case 0 : state = 3 ; break ; case 1 : state = 0 ; break ; case 2 : state = 1 ; break ; case 3 : state = 2 ; break ; case 4 : state = 7 ; break ; case 5 : state = 4 ; break ; case 6 : state = 5 ; break ; case 7 : state = 6 ; break ; } }
tr	2	public void aiUp ( ) { if ( Realm . player . x == x && Realm . player . y == ( y - 1 ) ) { attack ( ) ; } else { walkUp ( ) ; } }
tr	9X	private boolean createHostel ( Element hostel ) { NodeList nameList = hostel . getElementsByTagName ( "name" ) ; NodeList addressList = hostel . getElementsByTagName ( "address" ) ; NodeList contactList = hostel . getElementsByTagName ( "contact" ) ; NodeList policyList = hostel . getElementsByTagName ( "restrictions" ) ; NodeList bedList = hostel . getElementsByTagName ( "availability" ) ; if ( nameList == null || nameList . getLength ( ) != 1 || addressList == null || addressList . getLength ( ) != 1 || contactList == null || contactList . getLength ( ) != 1 || policyList == null || policyList . getLength ( ) != 1 ) { return false ; } Node nameNode = nameList . item ( 0 ) ; Node addressNode = addressList . item ( 0 ) ; Node contactNode = contactList . item ( 0 ) ; Node policyNode = policyList . item ( 0 ) ; if ( nameNode . getNodeType ( ) != Node . ELEMENT_NODE || addressNode . getNodeType ( ) != Node . ELEMENT_NODE || contactNode . getNodeType ( ) != Node . ELEMENT_NODE || policyNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return false ; } Address address = createAddress ( ( Element ) addressNode ) ; Contact contact = createContact ( ( Element ) contactNode ) ; Policy policy = createPolicy ( ( Element ) policyNode ) ; Identifier hostelId ; ArrayList < Identifier > bedIds = new ArrayList < Identifier > ( ) ; Hostel hostelInfo = new Hostel ( nameNode . getTextContent ( ) , address , contact , policy , bedIds ) ; try { hostelId = Hostels . getInstance ( ) . create ( hostelInfo ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { e . printStackTrace ( ) ; return false ; } for ( int bedCount = 0 ; bedCount < bedList . getLength ( ) ; bedCount ++ ) { Node bedNode = bedList . item ( bedCount ) ; if ( bedNode . getNodeType ( ) == Node . ELEMENT_NODE ) { createBed ( ( Element ) bedNode , hostelId ) ; } } return true ; }
tr	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	1	public static < T > FunctionExecutor < T > createGet ( final FeatureDefinition < ? extends Property < T >> propertyDefinition ) { return new FunctionExecutor < T > ( ) { @ Override public T invoke ( FunctionInvocation < T > invocation , Object ... arguments ) throws ExecutorInvocationException { invocation . next ( arguments ) ; return invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; } } ; }
tr	2	@ Test public void insertTest ( ) { final String type = "executeQueryTest" ; final Database connect = new Database ( "questions_test" ) ; final Hashtable < enum < ? > , Object > vals = new Hashtable < enum < ? > , Object > ( ) ; vals . put ( DatabaseAbstractQuestion . Column . TYPE , type ) ; vals . put ( DatabaseAbstractQuestion . Column . SHOW , "TRUE" ) ; connect . insert ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ; assertNotNull ( connect . select ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ) ; connect . delete ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ; connect . disconnect ( ) ; }
tr	4	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	7	public RegisterFrame ( ServerManager theServer , String theUrl , int thePort , int theListenPort ) { super ( "Registrar Usuario" ) ; controller = new RegisterController ( theServer , theUrl , thePort ) ; server = theServer ; url = theUrl ; port = thePort ; listenPort = theListenPort ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { createLoginFrame ( ) ; } } ) ; setBounds ( 100 , 100 , 661 , 403 ) ; contentPane = new JPanel ( ) ; contentPane . setBackground ( Color . WHITE ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new BorderLayout ( 0 , 10 ) ) ; JLabel lblRegistrarUsuario = new JLabel ( "Registrar Usuario" ) ; lblRegistrarUsuario . setFont ( new Font ( "Tahoma" , Font . BOLD , 18 ) ) ; lblRegistrarUsuario . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( lblRegistrarUsuario , BorderLayout . NORTH ) ; JPanel panelBotton = new JPanel ( ) ; panelBotton . setBackground ( Color . WHITE ) ; contentPane . add ( panelBotton , BorderLayout . SOUTH ) ; panelBotton . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 ) ) ; JButton btnRegister = new JButton ( "Registrarse" ) ; btnRegister . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { try { controller . register ( usernameTxt . getText ( ) , new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) , firstNameTxt . getText ( ) , lastNameTxt . getText ( ) , emailTxt . getText ( ) ) ; JOptionPane . showMessageDialog ( null , "Registro exitoso!  ahora podra usar el servicio de chat" , "Registro exitoso" , JOptionPane . INFORMATION_MESSAGE ) ; createLoginFrame ( ) ; } catch ( RegisterException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; btnRegister . setIcon ( new ImageIcon ( RegisterFrame . class . getResource ( "/chat/client/view/resources/registerIcon.png" ) ) ) ; panelBotton . add ( btnRegister ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { createLoginFrame ( ) ; } } ) ; panelBotton . add ( btnCancel ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new GridLayout ( 0 , 2 , 0 , 0 ) ) ; ImagePanel imagePanel = new ImagePanel ( Toolkit . getDefaultToolkit ( ) . getImage ( RegisterFrame . class . getResource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagePanel ) ; JPanel panel_1 = new JPanel ( ) ; panel_1 . setBackground ( Color . WHITE ) ; panel . add ( panel_1 ) ; GridBagLayout gbl_panel_1 = new GridBagLayout ( ) ; gbl_panel_1 . columnWidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowHeights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnWeights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowWeights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setLayout ( gbl_panel_1 ) ; JLabel label = new JLabel ( "Nombre de Usuario:" ) ; label . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernameTxt = new JTextField ( ) ; usernameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidUsername ( usernameTxt . getText ( ) ) ) { lblUserNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblUserNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; usernameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; usernameTxt . setColumns ( 20 ) ; GridBagConstraints gbc_usernameTxt = new GridBagConstraints ( ) ; gbc_usernameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_usernameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_usernameTxt . gridx = 1 ; gbc_usernameTxt . gridy = 0 ; panel_1 . add ( usernameTxt , gbc_usernameTxt ) ; lblUserNameError = new JLabel ( "" ) ; lblUserNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblUserNameError = new GridBagConstraints ( ) ; gbc_lblUserNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblUserNameError . gridx = 2 ; gbc_lblUserNameError . gridy = 0 ; panel_1 . add ( lblUserNameError , gbc_lblUserNameError ) ; JLabel label_1 = new JLabel ( "Contrase\u00F1a:" ) ; label_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_1 = new GridBagConstraints ( ) ; gbc_label_1 . anchor = GridBagConstraints . EAST ; gbc_label_1 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordTxt = new JPasswordField ( ) ; passwordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! controller . isValidPassword ( new String ( passwordTxt . getPassword ( ) ) ) ) { lblPasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblPasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; passwordTxt . setColumns ( 20 ) ; passwordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_passwordTxt = new GridBagConstraints ( ) ; gbc_passwordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_passwordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordTxt . gridx = 1 ; gbc_passwordTxt . gridy = 1 ; panel_1 . add ( passwordTxt , gbc_passwordTxt ) ; lblPasswordError = new JLabel ( "" ) ; lblPasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblPasswordError = new GridBagConstraints ( ) ; gbc_lblPasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblPasswordError . gridx = 2 ; gbc_lblPasswordError . gridy = 1 ; panel_1 . add ( lblPasswordError , gbc_lblPasswordError ) ; JLabel label_2 = new JLabel ( "Repetir contrase\u00F1a:" ) ; label_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_2 = new GridBagConstraints ( ) ; gbc_label_2 . anchor = GridBagConstraints . EAST ; gbc_label_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; rePasswordTxt = new JPasswordField ( ) ; rePasswordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isRePasswordEqualToPassword ( new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) ) ) { lblRepasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblRepasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; rePasswordTxt . setColumns ( 20 ) ; rePasswordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_rePasswordTxt = new GridBagConstraints ( ) ; gbc_rePasswordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_rePasswordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_rePasswordTxt . gridx = 1 ; gbc_rePasswordTxt . gridy = 2 ; panel_1 . add ( rePasswordTxt , gbc_rePasswordTxt ) ; lblRepasswordError = new JLabel ( "" ) ; lblRepasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblRepasswordError = new GridBagConstraints ( ) ; gbc_lblRepasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblRepasswordError . gridx = 2 ; gbc_lblRepasswordError . gridy = 2 ; panel_1 . add ( lblRepasswordError , gbc_lblRepasswordError ) ; JLabel label_3 = new JLabel ( "Nombre(s):" ) ; label_3 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_3 = new GridBagConstraints ( ) ; gbc_label_3 . anchor = GridBagConstraints . EAST ; gbc_label_3 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstNameTxt = new JTextField ( ) ; firstNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidFirstName ( firstNameTxt . getText ( ) ) ) { lblFirstNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblFirstNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; firstNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; firstNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_firstNameTxt = new GridBagConstraints ( ) ; gbc_firstNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_firstNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_firstNameTxt . gridx = 1 ; gbc_firstNameTxt . gridy = 3 ; panel_1 . add ( firstNameTxt , gbc_firstNameTxt ) ; lblFirstNameError = new JLabel ( "" ) ; lblFirstNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblFirstNameError = new GridBagConstraints ( ) ; gbc_lblFirstNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblFirstNameError . gridx = 2 ; gbc_lblFirstNameError . gridy = 3 ; panel_1 . add ( lblFirstNameError , gbc_lblFirstNameError ) ; JLabel label_4 = new JLabel ( "Apellido(s):" ) ; label_4 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_4 = new GridBagConstraints ( ) ; gbc_label_4 . anchor = GridBagConstraints . EAST ; gbc_label_4 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastNameTxt = new JTextField ( ) ; lastNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidLastName ( lastNameTxt . getText ( ) ) ) { lblLastNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblLastNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; lastNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lastNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_lastNameTxt = new GridBagConstraints ( ) ; gbc_lastNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_lastNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lastNameTxt . gridx = 1 ; gbc_lastNameTxt . gridy = 4 ; panel_1 . add ( lastNameTxt , gbc_lastNameTxt ) ; lblLastNameError = new JLabel ( "" ) ; lblLastNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblLastNameError = new GridBagConstraints ( ) ; gbc_lblLastNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblLastNameError . gridx = 2 ; gbc_lblLastNameError . gridy = 4 ; panel_1 . add ( lblLastNameError , gbc_lblLastNameError ) ; JLabel label_5 = new JLabel ( "E-mail:" ) ; label_5 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_5 = new GridBagConstraints ( ) ; gbc_label_5 . anchor = GridBagConstraints . EAST ; gbc_label_5 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailTxt = new JTextField ( ) ; emailTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidEmail ( emailTxt . getText ( ) ) ) { lblEmailError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblEmailError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; emailTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; emailTxt . setColumns ( 50 ) ; GridBagConstraints gbc_emailTxt = new GridBagConstraints ( ) ; gbc_emailTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_emailTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_emailTxt . gridx = 1 ; gbc_emailTxt . gridy = 5 ; panel_1 . add ( emailTxt , gbc_emailTxt ) ; lblEmailError = new JLabel ( "" ) ; lblEmailError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblEmailError = new GridBagConstraints ( ) ; gbc_lblEmailError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblEmailError . gridx = 2 ; gbc_lblEmailError . gridy = 5 ; panel_1 . add ( lblEmailError , gbc_lblEmailError ) ; lblError = new JLabel ( "" ) ; lblError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblError = new GridBagConstraints ( ) ; gbc_lblError . gridwidth = 3 ; gbc_lblError . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblError . gridx = 0 ; gbc_lblError . gridy = 6 ; panel_1 . add ( lblError , gbc_lblError ) ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	4	public void removeDeadTransitions ( ) { clearHashCode ( ) ; if ( isSingleton ( ) ) return ; Set < State > states = getStates ( ) ; Set < State > live = getLiveStates ( states ) ; for ( State s : states ) { Set < Transition > st = s . transitions ; s . resetTransitions ( ) ; for ( Transition t : st ) if ( live . contains ( t . to ) ) s . transitions . add ( t ) ; } reduce ( ) ; }
tr	7	@ Deprecated public < T > T toObject ( String input ) { final XmlPullParser xpp ; try { xpp = xmlPullParserFactory . newPullParser ( ) ; } catch ( XmlPullParserException e ) { throw new RuntimeException ( e . toString ( ) , e ) ; } final State state = stateFactory . get ( exceptionHandler ) ; try { xpp . setInput ( new StringReader ( input ) ) ; int eventType = xpp . getEventType ( ) ; do { if ( eventType == XmlPullParser . START_DOCUMENT ) { state . begin ( ) ; } else if ( eventType == XmlPullParser . START_TAG ) { state . processStartElement ( xpp , this ) ; } else if ( eventType == XmlPullParser . END_TAG ) { state . processEndElement ( ) ; } else if ( eventType == XmlPullParser . TEXT ) { state . processText ( xpp , this ) ; } eventType = xpp . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; state . end ( ) ; } catch ( Exception e ) { exceptionHandler . handle ( e ) ; } return ( T ) state . getObject ( ) ; }
tr	5	public Type get ( int index ) { if ( index >= length ) return new BooleanValue ( false ) ; else if ( index < 0 && Math . abs ( index ) <= length ) return elements [ length + index ] ; else if ( index < 0 && Math . abs ( index ) > length ) return new BooleanValue ( false ) ; return elements [ index ] ; }
tr	6	public static void SetBusqueda ( String dir ) { if ( dir . contains ( "http" ) == true || dir . contains ( "www" ) == true || dir . contains ( ".com" ) == true || dir . contains ( ".es" ) == true ) { dir = dir . replace ( "http://" , "" ) ; dir = dir . replace ( "https://" , "" ) ; try { web . getEngine ( ) . load ( "http://" + dir ) ; } catch ( Exception e ) { web . getEngine ( ) . load ( "https://" + dir ) ; } } else { String search = getStaticWords ( dir ) ; try { web . getEngine ( ) . load ( search ) ; } catch ( Exception e ) { } } }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	4	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	0	public boolean RemoveContact ( long nIndexContact ) { return otapiJNI . AddressBook_RemoveContact ( swigCPtr , this , removeRefContact ( nIndexContact ) ) ; }
tr	7	public static String timeToString3 ( Date date ) { if ( date == null ) return "\u65E0" ; long milliSecond = System . currentTimeMillis ( ) - date . getTime ( ) ; int ss = 1000 ; int mi = ss * 60 ; int hh = mi * 60 ; long day = hh * 24 ; long month = day * 30 ; long year = month * 12 ; long years = ( milliSecond ) / year ; long months = ( long ) ( ( milliSecond - years * year ) / month ) ; long days = ( milliSecond - years * year - months * month ) / day ; long hour = ( long ) ( ( milliSecond - years * year - months * month - days * day ) / hh ) ; long minute = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh ) / mi ) ; long second = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh - minute * mi ) / ss ) ; String result = "" ; if ( years != 0 ) { result += years + "\u5E74\u524D" ; } else if ( months != 0 ) { result += months + "\u6708\u524D" ; } else if ( days != 0 ) { result += days + "\u5929\u524D" ; } else if ( hour != 0 ) { result += hour + "\u5C0F\u65F6\u524D" ; } else if ( minute != 0 ) { result += minute + "\u5206\u949F\u524D" ; } else if ( second != 0 ) { result += second + "\u79D2\u524D" ; } return result ; }
tr	3	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( i == DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i == DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
tr	4	@ Override public boolean equals ( Object otherObject ) { if ( this == otherObject ) return true ; if ( null == otherObject ) return false ; if ( getClass ( ) != otherObject . getClass ( ) ) return false ; StringsList other = ( StringsList ) otherObject ; return super . equals ( other ) && count == other . count ; }
tr	4	public static boolean endsWithIgnoreCase ( String str , String suffix ) { if ( str == null || suffix == null ) { return false ; } if ( str . endsWith ( suffix ) ) { return true ; } if ( str . length ( ) < suffix . length ( ) ) { return false ; } String lcStr = str . substring ( str . length ( ) - suffix . length ( ) ) . toLowerCase ( ) ; String lcSuffix = suffix . toLowerCase ( ) ; return lcStr . equals ( lcSuffix ) ; }
tr	8	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getActionCommand ( ) . equals ( "tower" ) ) clickState = ClickState . tower ; else if ( arg0 . getActionCommand ( ) . equals ( "swamp" ) ) clickState = ClickState . swamp ; else if ( arg0 . getActionCommand ( ) . equals ( "elfrune" ) ) clickState = ClickState . elf ; else if ( arg0 . getActionCommand ( ) . equals ( "manrune" ) ) { clickState = ClickState . man ; } else if ( arg0 . getActionCommand ( ) . equals ( "dwarfrune" ) ) clickState = ClickState . dwarf ; else if ( arg0 . getActionCommand ( ) . equals ( "hobbitrune" ) ) clickState = ClickState . hobbit ; else if ( arg0 . getActionCommand ( ) . equals ( "reloadrune" ) ) clickState = ClickState . reload ; else if ( arg0 . getActionCommand ( ) . equals ( "rangerune" ) ) clickState = ClickState . range ; }
tr	1	public static long sum ( long ... values ) { long sum = 0 ; for ( long l : values ) { sum += l ; } return sum ; }
tr	2	public void rempirListEtude ( ) { String Sreqlist ; listEtude . removeAllItems ( ) ; Sreqlist = "select * from ASSOCIATION join ETUDE " + "on ASSOCIATION.IDCONVENTION = ETUDE.IDCONVENTION " + "WHERE IDETUDIANT =" + idetudiant ; try { listEtude . addItem ( "Selectionner l'\u00E9tude \u00E0 d\u00E9tailler" ) ; openConnection ( ) ; java . sql . Statement reqlist = conn . createStatement ( ) ; java . sql . ResultSet resullist = reqlist . executeQuery ( Sreqlist ) ; while ( resullist . next ( ) ) { listEtude . addItem ( makeObj ( resullist . getInt ( "IDCONVENTION" ) + " -- " + resullist . getString ( "NOMETUDE" ) ) ) ; } reqlist . close ( ) ; resullist . close ( ) ; closeConnection ( ) ; } catch ( java . sql . SQLException e ) { ModelInfo . addElement ( "Erreur execution requete " + e . getMessage ( ) ) ; affAccompte . setModel ( ModelInfo ) ; } }
tr	3	private void setField ( String propertyName , Object value , Object target ) throws IllegalAccessException { final class targetClass = target . getClass ( ) ; final Field field = getField ( targetClass , propertyName ) ; if ( null != field ) { if ( field . getType ( ) . isAssignableFrom ( value . getClass ( ) ) ) { field . setAccessible ( true ) ; field . set ( target , value ) ; } } else { log . debug ( "field '{}' does not exist on {}" , new Object [ ] { propertyName , targetClass } ) ; if ( Collection . class . isAssignableFrom ( targetClass ) ) { log . debug ( "{} is a Collection" , targetClass ) ; ( ( Collection ) target ) . add ( value ) ; } else { log . debug ( "{} NOT is a Collection" , targetClass ) ; } } }
tr	9X	public void renderTile ( int plane , int x , int y , int clippingPath , int clippingPathRotation , int textureId , int vertexHeightSW , int vertexHeightSE , int vertexHeightNE , int vertexHeightNW , int k2 , int l2 , int i3 , int j3 , int k3 , int l3 , int i4 , int j4 , int k4 , int l4 ) { if ( clippingPath == 0 ) { PlainTile tile = new PlainTile ( k2 , l2 , j3 , i3 , k4 , - 1 , false ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } if ( clippingPath == 1 ) { PlainTile tile = new PlainTile ( k3 , l3 , j4 , i4 , l4 , textureId , vertexHeightSW == vertexHeightSE && vertexHeightSW == vertexHeightNE && vertexHeightSW == vertexHeightNW ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } ShapedTile tile = new ShapedTile ( x , vertexHeightSW , vertexHeightSE , vertexHeightNW , vertexHeightNE , y , clippingPathRotation , textureId , clippingPath , k2 , k3 , l2 , l3 , j3 , j4 , i3 , i4 , l4 , k4 ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . shapedTile = tile ; }
tr	0	public int getCodigo ( ) { return codigo ; }
tr	5	private void jmiBkpBDActionPerformed ( java . awt . event . ActionEvent evt ) { int resp ; resp = RealizarBackupMySQL . showOpenDialog ( this ) ; if ( resp == JFileChooser . APPROVE_OPTION ) { try { InterfazSCHCG metodo = ( InterfazSCHCG ) registry . lookup ( "conex" ) ; boolean todo_ok = metodo . GenerarBackupMySQL ( RealizarBackupMySQL . getSelectedFile ( ) . toString ( ) ) ; if ( todo_ok ) { JOptionPane . showMessageDialog ( this , "Informacion" , "Archivo generado" , JOptionPane . INFORMATION_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( this , "Error" , "Se produjo un error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( RemoteException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NotBoundException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else if ( resp == JFileChooser . CANCEL_OPTION ) { JOptionPane . showMessageDialog ( this , "Ha sido cancelada la generacion de restaurar" ) ; } }
tr	2	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
tr	5	@ Override public float [ ] getFloatData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = data [ 0 ] ; } return out ; } else { float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( float ) data [ i ] ; } return out ; } } }
tr	9X	public Point getConnectionPoint ( Point ep ) { Point A = new Point ( position . x , position . y ) ; Point B = new Point ( position . x + getWidth ( ) , position . y ) ; Point C = new Point ( position . x , position . y + getHeight ( ) ) ; Point D = new Point ( position . x + getWidth ( ) , position . y + getHeight ( ) ) ; double distAB = new Line2D . float ( A , B ) . ptLineDist ( ep ) ; double distBD = new Line2D . float ( B , D ) . ptLineDist ( ep ) ; double distDC = new Line2D . float ( D , C ) . ptLineDist ( ep ) ; double distAC = new Line2D . float ( A , C ) . ptLineDist ( ep ) ; if ( distAB < distBD && distAB < distDC && distAB < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , position . y ) ; } else if ( distBD < distAB && distBD < distDC && distBD < distAC ) { return new Point ( ( position . x + getWidth ( ) ) , ( position . y + getHeight ( ) ) ) ; } else if ( distDC < distAB && distDC < distBD && distDC < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , ( position . y + getHeight ( ) ) ) ; } else if ( distAC < distAB && distAC < distBD && distAC < distDC ) { return new Point ( position . x , ( position . y + getHeight ( ) ) / 2 ) ; } else { return null ; } }
tr	6	public void start ( ) throws IllegalStateException { if ( instructions == null || endgamewindow == null || gameboard == null || lobby == null || loginsingup == null || newgame == null ) throw new IllegalStateException ( ) ; done = false ; attempConnection ( ) ; setState ( ModelStates . loginsingup ) ; newgame . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; endgamewindow . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; Thread myThread = new Thread ( this ) ; myThread . start ( ) ; }
tr	8	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
tr	9X	private static StringBuilder build ( final StringBuilder result , final Object subject , final int indent ) { if ( null == subject ) return result . append ( null ) ; else if ( subject . getClass ( ) . isArray ( ) ) return buildIterable ( result , new ArrayIterator ( subject ) , indent ) ; else if ( subject instanceof Map < ? , ? > ) return buildIterable ( result , ( ( Map < ? , ? > ) subject ) . entrySet ( ) . iterator ( ) , indent ) ; else if ( subject instanceof Iterable < ? > ) return buildIterable ( result , ( ( Iterable < ? > ) subject ) . iterator ( ) , indent ) ; else if ( subject instanceof Map . Entry < ? , ? > ) return buildEntry ( result , ( Map . Entry < ? , ? > ) subject , indent ) ; else return result . append ( subject . toString ( ) ) ; }
tr	0	@ Override public String visit ( AssignmentExpressionNode node ) { return EMPTY ; }
tr	6	@ Override public int loginUsuario ( String login , String password ) throws RemoteException { int result = - 1 ; ArrayList < UsuarioInt > usuarios = obtenerUsuarios ( ) ; for ( UsuarioInt usuario : usuarios ) { if ( login . compareTo ( usuario . getLogin ( ) ) == 0 && password . compareTo ( usuario . getPassword ( ) ) == 0 ) { if ( usuario . getAdmin ( ) ) { result = 2 ; } else { result = 1 ; } } else if ( login . compareTo ( usuario . getLogin ( ) ) == 0 || password . compareTo ( usuario . getPassword ( ) ) == 0 ) { result = 0 ; } } return result ; }
tr	0	public synchronized long getHMillis ( ) { return ( long ) ( p . H * 1000.0 ) ; }
tr	7	@ Override public void setFailState ( int failState ) { if ( this . failstate == Fallible . DEAD && failState != Fallible . DEAD ) throw new IllegalStateException ( "Cannot change fail state: node is already DEAD" ) ; switch ( failState ) { case OK : this . failstate = Fallible . OK ; break ; case DEAD : this . index = - 1 ; this . failstate = Fallible . DEAD ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof Cleanable ) { ( ( Cleanable ) this . protocol [ i ] ) . onKill ( ) ; } break ; case DOWN : this . failstate = Fallible . DOWN ; break ; default : throw new IllegalArgumentException ( "failState=" + failState ) ; } }
tr	5	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( ClientFrame . this . client . isConnected ( ) ) { ClientFrame . this . client . disconnect ( ) ; } }
tr	9X	@ SuppressWarnings ( "unchecked" ) private void addDirectory ( File directory , Map < String , Object > mapping ) { File [ ] files = directory . listFiles ( ) ; if ( files == null || files . length == 0 ) { return ; } for ( File file : files ) { if ( file . isHidden ( ) ) { continue ; } String name = file . getName ( ) ; if ( name . length ( ) == 0 ) { continue ; } String var = null ; if ( file . isFile ( ) ) { int index = name . lastIndexOf ( . ) ; if ( index > 0 ) { name = name . substring ( 0 , index ) ; } } if ( name . startsWith ( "${" ) ) { int index = name . indexOf ( } ) ; if ( index > 0 ) { var = name . substring ( 2 , index ) ; name = "$" ; } } Map < String , Object > map = ( Map < String , Object > ) mapping . get ( name ) ; if ( map == null ) { map = new HashMap < String , Object > ( ) ; mapping . put ( name , map ) ; } if ( var != null && var . length ( ) > 0 ) { map . put ( "." , var ) ; } if ( file . isDirectory ( ) ) { addDirectory ( file , map ) ; } } }
tr	5	public void Editar ( Produto produto ) throws Exception { if ( produto == null ) { throw new Exception ( "Selecione um produto" ) ; } if ( produto . getIdProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o id do produto." ) ; } if ( produto . getNomeProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir o nome do produto." ) ; } if ( produto . getTipoProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir tipo do produto." ) ; } if ( produto . getValorProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o valor unit\u00E1rio do produto." ) ; } ProdutoController . obterInstancia ( ) . Editar ( produto ) ; }
tr	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
tr	6	private void watchCandidate ( LeaderOffer previousOffer ) throws KeeperException , InterruptedException { LOG . info ( "{} not elected leader. Watching node {}" , leaderOffer , previousOffer ) ; Stat stat = zooKeeper . exists ( previousOffer . getOffer ( ) , new Watcher ( ) { public void process ( WatchedEvent event ) { if ( event . getType ( ) . equals ( Watcher . Event . EventType . NodeDeleted ) ) { if ( ! event . getPath ( ) . equals ( LeaderElectionService . this . leaderOffer . getOffer ( ) ) ) { LOG . debug ( "Node {} deleted. Need to run through the election process." , event . getPath ( ) ) ; try { determine ( ) ; } catch ( KeeperException e ) { failed ( e ) ; } catch ( InterruptedException e ) { failed ( e ) ; } } } } } ) ; if ( stat != null ) { LOG . info ( "Becoming follower with node {}  We're watching {}" , leaderOffer , previousOffer ) ; if ( leaderElectionAware != null ) { leaderElectionAware . onFollower ( leaderOffer ) ; } } else { LOG . debug ( "We were behind {} but it looks like died. Back to determination." , previousOffer ) ; determine ( ) ; } }
tr	0	public void setBankSwiftNo ( String bankSwiftNo ) { this . bankSwiftNo = bankSwiftNo ; }
tr	3	public int [ ] getActions ( Game game , long timeDue ) { int [ ] directions = new int [ Game . NUM_GHOSTS ] ; for ( int i = 0 ; i < directions . length ; i ++ ) if ( game . ghostRequiresAction ( i ) ) { if ( Game . rnd . nextFloat ( ) < CONSISTENCY ) directions [ i ] = game . getNextGhostDir ( i , game . getCurPacManLoc ( ) , attract , Game . DM . PATH ) ; else { int [ ] possibleDirs = game . getPossibleGhostDirs ( i ) ; directions [ i ] = possibleDirs [ G . rnd . nextInt ( possibleDirs . length ) ] ; } } return directions ; }
tr	6	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	3	public static boolean areEqual ( DummyKVStorable [ ] first , DummyKVStorable [ ] second ) { if ( first . length != second . length ) return false ; for ( int i = 0 ; i < first . length ; i ++ ) { if ( ! first [ i ] . equals ( second [ i ] ) ) { System . out . println ( "First entry: " + first [ i ] ) ; System . out . println ( "Second entry: " + second [ i ] ) ; return false ; } } return true ; }
tr	3	protected void closeStreams ( ) throws IOException { if ( this . fileReader != null ) { this . fileReader . close ( ) ; this . fileReader = null ; } if ( this . outputFile != null ) { if ( this . outputWriter != null ) { this . outputWriter . close ( ) ; this . outputWriter = null ; } } }
tr	5	public int hitTest ( int x , int y ) { if ( y > SPACE && y < SPACE + ITEM_HEIGHT ) { int t = x - startLeft ; if ( t > 0 && ( t % ( ITEM_WIDTH + SPACE_WIDTH ) < ITEM_WIDTH ) ) { int index = t / ( ITEM_WIDTH + SPACE_WIDTH ) ; if ( index < CableBattle . propsBar . list . size ( ) ) { return index ; } } } return - 1 ; }
tr	6	private void comparePackageParts ( TIPP p1 , TIPP p2 ) throws Exception { Collection < TIPPSection > s1 = p1 . getSections ( ) ; Collection < TIPPSection > s2 = p2 . getSections ( ) ; assertNotNull ( s1 ) ; assertNotNull ( s2 ) ; for ( TIPPSection s : s1 ) { TIPPSectionType type = s . getType ( ) ; List < ? extends TIPPFile > o1 = s . getFileResources ( ) ; TIPPSection _s = p2 . getSection ( type ) ; assertEquals ( s , _s ) ; List < ? extends TIPPFile > o2 = _s . getFileResources ( ) ; assertNotNull ( o1 ) ; assertNotNull ( o2 ) ; assertEquals ( o1 , o2 ) ; Iterator < ? extends TIPPFile > fit1 = o1 . iterator ( ) ; Iterator < ? extends TIPPFile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasNext ( ) ) { TIPPFile f1 = fit1 . next ( ) ; assertTrue ( fit2 . hasNext ( ) ) ; TIPPFile f2 = fit2 . next ( ) ; assertEquals ( f1 , f2 ) ; try ( InputStream is1 = p1 . getFile ( f1 ) ; InputStream is2 = p2 . getFile ( f2 ) ) { verifyBytes ( is1 , is2 ) ; } } } }
tr	7	public static String extractTitleFrom ( String filePath ) { String title = null ; try { Mp3File mp3File = new Mp3File ( filePath ) ; if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; title = id3v2Tag . getTitle ( ) ; } else if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; title = id3v1Tag . getTitle ( ) ; } } catch ( UnsupportedTagException e ) { e . printStackTrace ( ) ; } catch ( InvalidDataException e ) { System . out . print ( "Invalid Data" ) ; return " - Unknown Title" ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( title == null ) { int lastSlash = filePath . lastIndexOf ( \ ) ; if ( filePath . lastIndexOf ( / ) > lastSlash ) lastSlash = filePath . lastIndexOf ( / ) ; title = filePath . substring ( lastSlash + 1 ) . replaceAll ( "\\.mp3$" , "" ) ; } return title ; }
tr	4	private String toString ( Object obj ) { if ( null == obj ) { return "" ; } if ( obj . getClass ( ) . isArray ( ) ) { return Utils . join ( ( Object [ ] ) obj ) ; } if ( obj instanceof Collection ) { return Utils . join ( ( Collection < ? > ) obj ) ; } return obj . toString ( ) ; }
tr	1	@ Override public void commit ( ) { if ( currentTransaction != null ) currentTransaction . commit ( ) ; }
tr	8	@ Override public void write ( int theByte ) throws IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = EncFSBase64 . decode4to3 ( buffer , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new IOException ( "Invalid character in Base64 data." ) ; } } }
tr	4	public static ChineseCharacter searchCharacter ( Integer [ ] intersection , int floatingPart , int straightStroke , int complexStroke ) { intersections = intersection ; floatingParts = floatingPart ; straightStrokes = straightStroke ; complexStrokes = complexStroke ; EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { PossibleChineseCharactersPanel . clearList ( ) ; Arrays . sort ( intersections ) ; for ( ChineseCharacter c : UniversalDataStorage . database ) { if ( c . getFloatingParts ( ) == floatingParts && Arrays . toString ( c . getIntersections ( ) . toArray ( ) ) . equals ( Arrays . toString ( intersections ) ) && ( c . getComplexStrokes ( ) + c . getStraightStrokes ( ) ) == ( complexStrokes + straightStrokes ) ) { String pinyin = c . getPinyin ( ) ; String character = c . getCharacter ( ) ; String meaning = c . getMeaning ( ) ; chinesecharacter = new ChineseCharacter ( pinyin , character , meaning , floatingParts , new ArrayList < Integer > ( Arrays . asList ( intersections ) ) , straightStrokes , complexStrokes ) ; System . out . println ( chinesecharacter ) ; PossibleChineseCharactersPanel . addToList ( chinesecharacter ) ; LogManager . logThing ( "Character found:" + chinesecharacter + " " + TimeManager . getCurrentTimeAndDate ( ) ) ; } } } } ) ; return chinesecharacter ; }
tr	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	3	@ Override public boolean addItemToInventory ( Item item ) { if ( isRoomInInventory ( ) ) { for ( int i = 0 ; i < getInventorySize ( ) ; i ++ ) { if ( getItemInSlot ( i ) == null ) { setItemInSlot ( i , item ) ; break ; } } return true ; } else { return false ; } }
tr	6	@ Override public int updateByLogic ( Object ... pojos ) throws DataAccessException { int r = 0 ; for ( Object obj : pojos ) { SqlUpdGenerator sqlGenerator = new SqlUpdGenerator ( obj , false ) ; try { r += execute ( sqlGenerator . getSql ( ) , sqlGenerator . getArgs ( ) ) ; } catch ( IllegalArgumentException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( IllegalAccessException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( NoSuchFieldException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( SecurityException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( ParseException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } } return r ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( ) . setVisible ( true ) ; } } ) ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = opt ( key ) ; if ( object == null ) { put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	7	public static void domNodeToTree ( Node domNode , TreeDomNode parentTreeNode , boolean displayNodeValue ) { if ( domNode instanceof Text ) return ; TreeDomNode treeNode = new TreeDomNode ( domNode , displayNodeValue ) ; parentTreeNode . add ( treeNode ) ; NamedNodeMap attributeNodes = domNode . getAttributes ( ) ; if ( ( attributeNodes != null ) && ( attributeNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < attributeNodes . getLength ( ) ; i ++ ) { treeNode . add ( new TreeDomNode ( attributeNodes . item ( i ) , displayNodeValue ) ) ; } } NodeList childNodes = domNode . getChildNodes ( ) ; if ( ( childNodes != null ) && ( childNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) domNodeToTree ( childNodes . item ( i ) , treeNode , displayNodeValue ) ; } }
tr	6	public void addEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null ) { vFrom = new Vertex ( vi ) ; vs . add ( vFrom ) ; } if ( vi != vj ) { if ( vTo == null ) { vTo = new Vertex ( vj ) ; vs . add ( vTo ) ; } vFrom . adjacent . add ( vTo ) ; vTo . adjacent . add ( vFrom ) ; } else { vFrom . adjacent . add ( vFrom ) ; } }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSuppliersEntity that = ( PhpposSuppliersEntity ) o ; if ( personId != that . personId ) return false ; if ( accountNumber != null ? ! accountNumber . equals ( that . accountNumber ) : that . accountNumber != null ) return false ; return true ; }
tr	8	public boolean areAnagramsCount ( String a , String b ) { if ( a == null && b == null ) return false ; else if ( a == null || b == null ) return false ; else { int [ ] count = new int [ 256 ] ; char [ ] ac = a . toCharArray ( ) ; for ( char c : ac ) { count [ c ] ++ ; } char [ ] bc = b . toCharArray ( ) ; for ( char c : bc ) { count [ c ] -- ; } for ( int i : count ) { if ( i != 0 ) return false ; } } return true ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TestClass testClass = ( TestClass ) o ; if ( x != testClass . x ) return false ; if ( y != testClass . y ) return false ; return true ; }
tr	8	public void decode ( InputStream stream , int length , CharBuffer buffer ) throws IllegalArgumentException , IOException { if ( stream == null ) throw new IllegalArgumentException ( "stream cannot be null" ) ; if ( length < 0 ) throw new IllegalArgumentException ( "length [" + length + "] must be >= 0." ) ; if ( buffer == null ) throw new IllegalArgumentException ( "buffer cannot be null and must be a CharBuffer with a large enough capacity to hold at least 'length' (" + length + ") characters." ) ; if ( length > buffer . capacity ( ) ) throw new IllegalArgumentException ( "length [" + length + "] is larger than the capacity [" + buffer . capacity ( ) + "] of the given buffer; the CharBuffer must be big enough to contain all the characters decoded from the given InputStream." ) ; if ( length == 0 ) buffer . clear ( ) ; else { bBuffer . clear ( ) ; buffer . clear ( ) ; decoder . reset ( ) ; int read = 0 ; while ( length > 0 && ( read = stream . read ( rBuffer , 0 , length ) ) != - 1 ) { length -= read ; bBuffer . position ( 0 ) ; bBuffer . limit ( read ) ; decoder . decode ( bBuffer , buffer , ( length == 0 ) ) ; } if ( length > 0 ) throw new IOException ( "End of Stream encountered before all requested bytes [" + ( length + read ) + "] could be read. Unable to read the last " + length + " remaining bytes." ) ; decoder . flush ( buffer ) ; } }
tr	8	public int applyBonatoTest ( double [ ] variances ) { int i = signals . get ( 0 ) . size ( ) / 2 ; int onset = Integer . MAX_VALUE ; for ( int k = 0 ; k < sensorSize ; k ++ ) { bonatoSigns . get ( k ) . clear ( ) ; cumulativeSignsCounter [ k ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int j_k1 = signals . get ( k ) . get ( j * 2 ) ; int j_k2 = signals . get ( k ) . get ( ( j * 2 ) + 1 ) ; double g_j = Math . pow ( ( j_k1 + j_k2 ) , 2 ) / variances [ k ] ; if ( g_j > this . threshold_h ) { bonatoSigns . get ( k ) . add ( true ) ; cumulativeSignsCounter [ k ] ++ ; } else { bonatoSigns . get ( k ) . add ( false ) ; cumulativeSignsCounter [ k ] = 0 ; } } for ( int j = 0 ; j < sensorSize ; j ++ ) { if ( cumulativeSignsCounter [ j ] > threshold_m ) { System . out . println ( "onset" ) ; for ( int j2 = 0 ; j2 < i ; j2 ++ ) { if ( bonatoSigns . get ( k ) . get ( j2 ) ) { if ( j2 * 2 < onset ) { onset = j2 * 2 ; System . out . println ( "onset" ) ; } break ; } } } } } return onset ; }
tr	2	public static String getUserMessage ( int statusCode ) { if ( statusCode == Response . SC_SERVICE_UNAVAILABLE ) { return "Pearltrees is currently unavailable. Please retry later." ; } if ( statusCode == Response . SC_SEE_OTHER ) { return "Please enable cookies to use the bookmarklet." ; } return "Pearltrees is currently unreachable. Please check your internet connection or retry later." ; }
tr	7	private void jButtonAddCustomerActionPerformed ( java . awt . event . ActionEvent evt ) { if ( "" . equals ( Fnamefield . getText ( ) ) || "" . equals ( Snamefield . getText ( ) ) || "" . equals ( Countryfield . getText ( ) ) || "" . equals ( Emailfield . getText ( ) ) || "" . equals ( Phonefield . getText ( ) ) || "" . equals ( Addressfield . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "One or more fields are left empty. Please make sure all fields are filled properly" ) ; } else { con . createNewCustomer ( Fnamefield . getText ( ) , Snamefield . getText ( ) , Countryfield . getText ( ) , Emailfield . getText ( ) , Integer . parseInt ( Phonefield . getText ( ) ) , Addressfield . getText ( ) ) ; boolean status = con . saveCustomer ( ) ; if ( status ) { Statuslabel . setText ( "Customer saved" ) ; } else { Statuslabel . setText ( "Customer could not be saved!" ) ; } } }
tr	3	private void setUIDesign ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Metal" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MantenimientoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } }
tr	0	@ Override public String getGrammarFileName ( ) { return "Enquanto.g4" ; }
tr	9X	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
tr	4	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
tr	3	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { PrintWriter out = response . getWriter ( ) ; request . setCharacterEncoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setContentType ( "text/html;charset=UTF-8" ) ; search com = new search ( ) ; String id [ ] = request . getParameterValues ( "id" ) ; String docTellId [ ] = request . getParameterValues ( "docTellId" ) ; String docId [ ] = request . getParameterValues ( "docId" ) ; String docTellContent [ ] = request . getParameterValues ( "docTellContent" ) ; String excuteDate [ ] = request . getParameterValues ( "excuteDate" ) ; String excuteId [ ] = request . getParameterValues ( "excuteId" ) ; String docTellType [ ] = request . getParameterValues ( "docTellType" ) ; String stopDate [ ] = request . getParameterValues ( "stopDate" ) ; String patientId = request . getParameter ( "patientId" ) ; for ( int i = 0 ; i < docTellId . length ; i ++ ) { r = com . docTellFind ( id [ i ] ) ; if ( r ) { e = com . docTellUpdate ( id [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] ) ; } else { System . out . println ( docTellId [ i ] ) ; e = com . docTellInsert ( id [ i ] , docTellId [ i ] , docId [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] , patientId ) ; } } if ( e ) { response . sendRedirect ( request . getContextPath ( ) + "/wardManagement/patientList.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } }
tr	4	@ Override public boolean parseField ( String name , String value ) { if ( super . parseField ( name , value ) ) { return true ; } if ( name != null && value != null ) { PeripheralFieldHandler handler = EnumUtils . lookup ( PeripheralFieldHandler . class , name ) ; if ( handler != null ) { return handler . handle ( device , value ) ; } else { return false ; } } return false ; }
tr	1	protected void loadPage ( JEditorPane pane , HyperlinkEvent evt ) { try { pane . setPage ( evt . getURL ( ) ) ; } catch ( IOException e ) { System . err . println ( e . getLocalizedMessage ( ) ) ; } }
tr	5	public void read_scalefactor ( Bitstream stream , Header header ) { super . read_scalefactor ( stream , header ) ; if ( channel2_allocation != 0 ) { switch ( channel2_scfsi ) { case 0 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 1 : channel2_scalefactor1 = channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 2 : channel2_scalefactor1 = channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 3 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; } prepare_sample_reading ( header , channel2_allocation , 1 , channel2_factor , channel2_codelength , channel2_c , channel2_d ) ; } }
tr	3	public AbstractItem ( ItemConfiguration config , String key , String [ ] sval , int [ ] ival , Triplet [ ] tval ) { this . key = key ; strings = new String [ config . stringLabels . length ] ; ints = new int [ config . intLabels . length ] ; triplets = new Triplet [ config . tripletLabels . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { strings [ i ] = sval [ i ] ; } for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = ival [ i ] ; } for ( int i = 0 ; i < triplets . length ; i ++ ) { triplets [ i ] = tval [ i ] ; } }
tr	1	public void skipPast ( String to ) { this . myIndex = this . mySource . indexOf ( to , this . myIndex ) ; if ( this . myIndex < 0 ) { this . myIndex = this . mySource . length ( ) ; } else { this . myIndex += to . length ( ) ; } }
tr	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
tr	3	public List < double > toOrderedList ( ) { List < double > distr = new ArrayList < double > ( ) ; for ( int i = 0 ; i < this . getRows ( ) ; i ++ ) { for ( int j = 0 ; j < this . getColumns ( ) ; j ++ ) { if ( ! this . isSparse ( i , j ) ) distr . add ( this . getSimilarity ( i , j ) ) ; } } Collections . sort ( distr ) ; return distr ; }
tr	9X	private void readValues ( Buffer stream , int i ) { do { int opcode = stream . getUnsignedByte ( ) ; if ( opcode == 0 ) return ; if ( opcode == 1 ) stream . getUnsignedByte ( ) ; else if ( opcode == 2 ) stream . getUnsignedByte ( ) ; else if ( opcode == 3 ) anIntArray703 [ anInt702 ++ ] = i ; else if ( opcode == 4 ) { } else if ( opcode == 5 ) type = stream . getUnsignedLEShort ( ) ; else if ( opcode == 6 ) { } else if ( opcode == 7 ) stream . getInt ( ) ; else if ( opcode == 8 ) aBoolean713 = true ; else if ( opcode == 10 ) stream . getString ( ) ; else if ( opcode == 11 ) aBoolean713 = true ; else if ( opcode == 12 ) stream . getInt ( ) ; else if ( opcode == 13 ) { } else System . out . println ( "Error unrecognised config code: " + opcode ) ; } while ( true ) ; }
tr	9X	@ SuppressWarnings ( "unchecked" ) public static boolean isNotEmpty ( Object obj ) { if ( obj == null ) { return false ; } else if ( obj instanceof Collection ) { if ( ( ( Collection ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof List ) { if ( ( ( List ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Map ) { if ( ( ( Map ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Set ) { if ( ( ( Set ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Vector ) { if ( ( ( Vector ) obj ) . size ( ) <= 0 ) return false ; } else { if ( obj . toString ( ) . trim ( ) . length ( ) <= 0 || "null" . equals ( obj . toString ( ) . trim ( ) ) ) return false ; } return true ; }
tr	2	public void setValue ( int value ) { if ( value < this . minValue ) { this . value = minValue ; } else if ( value > maxValue ) { this . value = maxValue ; } else { this . value = value ; } this . slider . reactToChanges ( new CustomSliderEvent ( slider , this . value ) ) ; this . textField . reactToChanges ( new CustomTextFieldEvent ( textField , Integer . toString ( this . value ) ) ) ; }
tr	2	public static BookSection fromJson ( JsonElement elem ) { JsonObject obj = elem . getAsJsonObject ( ) ; String header = obj . has ( HEADER ) ? obj . getAsJsonPrimitive ( HEADER ) . getAsString ( ) : null ; LinkedList < String > names = new LinkedList < String > ( ) ; for ( JsonElement probElem : obj . get ( PROBLEMS ) . getAsJsonArray ( ) ) { names . add ( probElem . getAsString ( ) ) ; } return new BookSection ( header , names ) ; }
tr	3	private void checkConvexCut ( Point [ ] points , Point a , Point n ) { Point [ ] [ ] hullp = convexCut ( convexHull ( points ) , a , n ) ; System . out . println ( Arrays . deepToString ( hullp ) ) ; assertTrue ( isConvex ( hullp ) ) ; for ( Point p : points ) { int type = isInConvex ( p , hullp ) ; double d = a . subtract ( p ) . . ( n ) ; if ( approxEquals ( d , 0 ) ) assertTrue ( type == 2 ) ; else if ( d > 0 ) assertTrue ( type != 0 ) ; else assertTrue ( type == 0 ) ; } }
tr	1	private Particle createLandmineParticle ( double theta , Point2D . double pos ) { Particle p = new Particle ( theta , 0.0 , 0.0 , ( Landmine . PARTICLE_LIFE / ( int ) Globals . SLEEP_TIME ) , pos , new Dimension ( 24 , 24 ) , Images . LANDMINE_PARTICLE ) { @ Override public void update ( ) { if ( this . isAlive ( ) ) this . life -- ; } @ Override public void draw ( Graphics2D g2d ) { double x = this . pos . x - ( this . size . width / 2 ) ; double y = this . pos . y - ( this . size . height / 2 ) ; g2d . drawImage ( this . image , ( int ) x , ( int ) y , null ) ; } } ; return p ; }
tr	8	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
tr	7	boolean testAndSet ( Obstacle obs ) { if ( isDirty ) return false ; if ( excludedObstacles . contains ( obs ) ) return false ; Segment seg1 = new Segment ( obs . topLeft , obs . bottomRight ) ; Segment seg2 = new Segment ( obs . topRight , obs . bottomLeft ) ; for ( int s = 0 ; s < points . size ( ) - 1 ; s ++ ) { points . getPoint ( CURRENT , s ) ; points . getPoint ( NEXT , s + 1 ) ; if ( seg1 . intersects ( CURRENT , NEXT ) || seg2 . intersects ( CURRENT , NEXT ) || obs . contains ( CURRENT ) || obs . contains ( NEXT ) ) { isDirty = true ; return true ; } } return false ; }
tr	7	public static String [ ] delimitedListToStringArray ( String str , String delimiter , String charsToDelete ) { if ( str == null ) { return new String [ 0 ] ; } if ( delimiter == null ) { return new String [ ] { str } ; } List < String > result = new ArrayList < String > ( ) ; if ( "" . equals ( delimiter ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result . add ( deleteAny ( str . substring ( i , i + 1 ) , charsToDelete ) ) ; } } else { int pos = 0 ; int delPos ; while ( ( delPos = str . indexOf ( delimiter , pos ) ) != - 1 ) { result . add ( deleteAny ( str . substring ( pos , delPos ) , charsToDelete ) ) ; pos = delPos + delimiter . length ( ) ; } if ( str . length ( ) > 0 && pos <= str . length ( ) ) { result . add ( deleteAny ( str . substring ( pos ) , charsToDelete ) ) ; } } return toStringArray ( result ) ; }
tr	3	public void initializeGrid ( int [ ] [ ] exportedGrid ) { int rows = b . numRows ; int columns = b . numColumns ; for ( int y = 0 ; y < rows ; y ++ ) { for ( int x = 0 ; x < columns ; x ++ ) { int state = exportedGrid [ y ] [ x ] ; b . setGameGridCircle ( x , y , state ) ; if ( state != 0 ) { b . setDrawCounter ( b . getDrawCounter ( ) + 1 ) ; } } } }
tr	5	public Request < DescribeInstanceTypesRequest > marshall ( DescribeInstanceTypesRequest describeInstanceTypesRequest ) { if ( describeInstanceTypesRequest == null ) { throw new AmazonClientException ( "Invalid argument passed to marshall(...)" ) ; } Request < DescribeInstanceTypesRequest > request = new DefaultRequest < > ( describeInstanceTypesRequest , "AmazonEC2" ) ; request . addParameter ( "Action" , "DescribeInstanceTypes" ) ; request . addParameter ( "Version" , "2013-10-15" ) ; List < String > instanceTypesList = describeInstanceTypesRequest . getInstanceTypes ( ) ; int instanceTypesListIndex = 1 ; for ( String instanceTypesListValue : instanceTypesList ) { if ( instanceTypesListValue != null ) { request . addParameter ( "InstanceType." + instanceTypesListIndex , StringUtils . fromString ( instanceTypesListValue ) ) ; } instanceTypesListIndex ++ ; } if ( describeInstanceTypesRequest . getAvailability ( ) != null ) { request . addParameter ( "Availability" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getAvailability ( ) ) ) ; } if ( describeInstanceTypesRequest . getVerbose ( ) != null ) { request . addParameter ( "Verbose" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getVerbose ( ) ) ) ; } return request ; }
tr	2	public Session createSession ( String uriString , String params , ClientProxy proxy , Map < String , Object > httpParams ) { try { URI uri = new URI ( uriString ) ; SessionFactory found = registry . get ( uri . getScheme ( ) ) ; if ( found == null ) throw new ClientError ( "Could not open URI '" + uriString + "'. Unknown scheme - '" + uri . getScheme ( ) + "'." + "Make sure you have registered your SessionFactory with this transport." ) ; return found . newSession ( uri , params , proxy , httpParams ) ; } catch ( URISyntaxException e ) { throw new ClientError ( e ) ; } }
tr	9X	public static Method getAsMethodOfPublicBase ( class < ? > c , Method m ) { for ( class < ? > iface : c . getInterfaces ( ) ) { for ( Method im : iface . getMethods ( ) ) { if ( isMatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getSuperclass ( ) ; if ( sc == null ) { return null ; } for ( Method scm : sc . getMethods ( ) ) { if ( isMatch ( scm , m ) ) { return scm ; } } return getAsMethodOfPublicBase ( sc , m ) ; }
tr	1	void removeWindow ( ) { if ( viewport != null ) viewport . dispose ( ) ; viewport = null ; }
tr	5	public void send ( final String name , final String node , final OtpErlangObject msg ) { try { final String currentNode = home . node ( ) ; if ( node . equals ( currentNode ) ) { send ( name , msg ) ; } else if ( node . indexOf ( @ , 0 ) < 0 && node . equals ( currentNode . substring ( 0 , currentNode . indexOf ( @ , 0 ) ) ) ) { send ( name , msg ) ; } else { final OtpCookedConnection conn = home . getConnection ( node ) ; if ( conn == null ) { return ; } conn . send ( self , name , msg ) ; } } catch ( final Exception e ) { } }
tr	5	@ SuppressWarnings ( { "unchecked" } ) public static < T > boolean equalsLists ( List < T > left , List < T > right , class < T > valueType ) { if ( left . size ( ) != right . size ( ) ) { return false ; } boolean equals = true ; if ( valueType . isArray ( ) && valueType . getComponentType ( ) == byte . TYPE ) { for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( Arrays . equals ( ( byte [ ] ) right . get ( i ) , ( byte [ ] ) left . get ( i ) ) == false ) { equals = false ; break ; } } } else { equals = left . equals ( right ) ; } return equals ; }
tr	8	private ChatRemoteManager ( ) { addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . QUIT ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( connection != null ) { connection . close ( ) ; } interrupt ( ) ; } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CONNECT_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( params != null && params . containsKey ( "host" ) ) { try { connection = new ServerConnection ( params . get ( "host" ) , Main . TCP_SERVERPORT ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_SUCCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } catch ( NetworkException e ) { e . printStackTrace ( ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_FAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGE ; } @ Override protected void onAction ( final HashMap < String , String > params ) { if ( params != null && params . containsKey ( "username" ) ) { if ( connection . auth ( params . get ( "username" ) ) ) { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_NAMECHANGE ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } else { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGEFAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . FETCHUSER_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { try { String response = connection . requestUserList ( ) ; final HashMap < String , String > userList = InfoParser . parseInfoResponse ( response ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . FETCHUSER_PROCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return userList ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	9X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Apply" ) ) { this . dispose ( ) ; System . out . println ( "aaaa" ) ; Tuple < String , Tuple < String , Integer >> player1Data = player1 . getPlayerData ( ) ; Tuple < String , Tuple < String , Integer >> player2Data = player2 . getPlayerData ( ) ; int deadFields = this . deadFields . getDeadFieldNumber ( ) ; System . out . println ( deadFields ) ; System . out . println ( "bbb" ) ; Player [ ] players = { new Player ( player1Data . getFirstElement ( ) , player1Data . getSecondElement ( ) . getFirstElement ( ) , "w" , player1Data . getSecondElement ( ) . getSecondElement ( ) ) , new Player ( player2Data . getFirstElement ( ) , player2Data . getSecondElement ( ) . getFirstElement ( ) , "b" , player2Data . getSecondElement ( ) . getSecondElement ( ) ) , } ; System . out . println ( "ccc" ) ; try { masterGui . newGame ( players , deadFields ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "ddd" ) ; } }
tr	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
tr	2	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	0	public void setRunning ( boolean state ) { running = state ; }
tr	7	private void updatePermissions ( ) { bukkitPermissions = new LinkedHashMap < String , Permission > ( ) ; if ( subgroups == null ) { subgroups = new ArrayList < String > ( ) ; } if ( ! permissions . containsKey ( Config . getDefaultWorld ( ) ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + Config . getDefaultWorld ( ) , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; Permission permission = new Permission ( "droxperms.meta.group." + name + "." + Config . getDefaultWorld ( ) , "Group-Permissions for group " + name + " on world " + Config . getDefaultWorld ( ) , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( Config . getDefaultWorld ( ) , permission ) ; } for ( String world : Config . getWorlds ( ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + world , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; if ( permissions . get ( world ) != null ) { children . putAll ( permissions . get ( world ) ) ; } Permission permission = new Permission ( "droxperms.meta.group." + name + "." + world , "Group-Permissions for group " + name + " on world " + world , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( world , permission ) ; } Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup , true ) ; } children . putAll ( globalPermissions ) ; Permission permission = new Permission ( "droxperms.meta.group." + name , "Group-Permissions for group " + name , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; }
tr	3	public static Matrix4 multiply ( Matrix4 m1 , Matrix4 m2 ) { Matrix4 C = new Matrix4 ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) C . A [ i ] [ j ] += m1 . A [ i ] [ k ] * m2 . A [ k ] [ j ] ; return C ; }
tr	2	private void siirraNappula ( Point p ) { if ( ! peli . logiikka . loppu ( ) && Pelilauta . hiiriPaalla ( p ) ) { int kor = ykoordinaatti ( p . y ) ; int lev = xkoordinaatti ( p . x ) ; peli . siirto ( 7 - korMis , levMis , 7 - kor , lev ) ; } }
tr	6	void copyBGToBuf ( Graphics bufg , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 ) { if ( sx2 <= sx1 || sy2 <= sy1 ) return ; int barrelx = el . scaleXPos ( el . moduloFloor ( el . xofs , el . tilex ) , false ) ; int barrely = el . scaleYPos ( el . moduloFloor ( el . yofs , el . tiley ) , false ) ; int barreldx = ( sx1 == 0 ) ? barrelx : 0 ; int barreldy = ( sy1 == 0 ) ? barrely : 0 ; barrelx = ( sx1 == 0 ) ? 0 : barrelx ; barrely = ( sy1 == 0 ) ? 0 : barrely ; int dx2 = dx1 + sx2 - sx1 ; int dy2 = dy1 + sy2 - sy1 ; bufg . drawImage ( background , dx1 * el . scaledtilex - barreldx , dy1 * el . scaledtiley - barreldy , dx2 * el . scaledtilex - barreldx , dy2 * el . scaledtiley - barreldy , barrelx + sx1 * el . scaledtilex , barrely + sy1 * el . scaledtiley , barrelx + sx2 * el . scaledtilex , barrely + sy2 * el . scaledtiley , this ) ; }
tr	2	public AccountPermissions read ( String id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AccountPermissions instance = null ; try { instance = ( AccountPermissions ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
tr	8	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	9X	public byte detectMapType ( ) { if ( this . file == null ) return new byte ( null ) . byteValue ( ) ; String fileName = this . file . getName ( ) ; ArrayList < byte > possiblities = new ArrayList < byte > ( ) ; if ( fileName . indexOf ( "map-AirD" ) > - 1 ) possiblities . add ( Channel . TYPE_AIR ) ; if ( fileName . indexOf ( "map-CableD" ) > - 1 ) possiblities . add ( Channel . TYPE_CABLE ) ; if ( fileName . indexOf ( "map-SateD" ) > - 1 ) possiblities . add ( Channel . TYPE_SAT ) ; if ( fileName . endsWith ( "clone.bin" ) ) possiblities . add ( Channel . TYPE_CLONE ) ; if ( possiblities . size ( ) == 1 ) return possiblities . get ( 0 ) . byteValue ( ) ; if ( possiblities . size ( ) == 0 ) { possiblities . add ( Channel . TYPE_AIR ) ; possiblities . add ( Channel . TYPE_CABLE ) ; possiblities . add ( Channel . TYPE_SAT ) ; possiblities . add ( Channel . TYPE_CLONE ) ; } HashMap < byte , String > captions = new HashMap < byte , String > ( 4 ) ; captions . put ( Channel . TYPE_AIR , "Air" ) ; captions . put ( Channel . TYPE_CABLE , "Cable" ) ; captions . put ( Channel . TYPE_SAT , "Satellite" ) ; captions . put ( Channel . TYPE_CLONE , "Clone File" ) ; String [ ] choices = new String [ possiblities . size ( ) ] ; for ( byte b : possiblities ) { choices [ possiblities . indexOf ( b ) ] = captions . get ( b ) ; } String chosenType = ( String ) JOptionPane . showInputDialog ( null , "Could not detect correct file type. Please choose the right one:" , "File Type" , JOptionPane . WARNING_MESSAGE , null , choices , choices [ 0 ] ) ; if ( chosenType != null && chosenType . length ( ) > 0 ) { for ( Map . Entry < byte , String > entry : captions . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( chosenType ) ) return ( ( byte ) entry . getKey ( ) ) . byteValue ( ) ; } } return new byte ( null ) . byteValue ( ) ; }
tr	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	9X	public int moveToMe ( MyStore < T > other ) { if ( other . size == 0 ) return 0 ; if ( this . size == 0 ) { this . moveAll ( other . size , other . head , this . tail , other ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return this . size ; } int initialMySize = this . size ; int initialOtherSize = other . size ; Container < T > thisOld = this . head ; Container < T > otherOld = other . head ; Container < T > thisCurrent = this . head . next ; Container < T > otherCurrent = other . head . next ; int otherRemaining = other . size ; int moved = 0 ; boolean done = false ; while ( true ) { int result = this . compare ( thisCurrent . el , otherCurrent . el ) ; if ( result == 0 ) { if ( otherCurrent . next != null ) { otherOld = otherCurrent ; otherCurrent = otherCurrent . next ; otherRemaining -- ; } else { done = true ; break ; } if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } else if ( result > 0 ) { otherOld . next = otherCurrent . next ; other . size -- ; thisOld . next = otherCurrent ; otherCurrent . next = thisCurrent ; this . size ++ ; moved ++ ; thisOld = otherCurrent ; if ( other . tail == otherCurrent ) { other . tail = otherOld ; } if ( otherOld . next != null ) { otherCurrent = otherOld . next ; otherRemaining -- ; } else { done = true ; break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } if ( ! done ) { this . moveAll ( otherRemaining , otherOld , thisCurrent , other ) ; moved += otherRemaining ; } assert ( this . size == initialMySize + moved ) ; assert ( other . size == initialOtherSize - moved ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return moved ; }
tr	1	@ Override public void mouseExited ( MouseEvent e ) { try { setImg ( ImageIO . read ( new File ( "img/button/button.png" ) ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	1	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getPolicyNames ( ) != null ) sb . append ( "PolicyNames: " + getPolicyNames ( ) + " " ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
tr	0	public String getSrcText ( ) { return "" ; }
tr	0	@ Override public FullVersion getVersion ( ) { return version ; }
tr	6	private static Method getLongAddMethod ( class < ? > valueClass ) throws NoSuchMethodException , SecurityException { if ( valueClass . equals ( boolean . class ) ) return CMDLineParser . class . getMethod ( "addBooleanOption" , char . class , String . class ) ; if ( valueClass . equals ( Integer . class ) ) return CMDLineParser . class . getMethod ( "addIntegerOption" , char . class , String . class ) ; if ( valueClass . equals ( double . class ) ) return CMDLineParser . class . getMethod ( "addDoubleOption" , char . class , String . class ) ; if ( valueClass . equals ( String . class ) ) return CMDLineParser . class . getMethod ( "addStringOption" , char . class , String . class ) ; if ( valueClass . equals ( Range . class ) ) return CMDLineParser . class . getMethod ( "addRangeOption" , char . class , String . class ) ; return null ; }
tr	2	public Map < String , Map < String , Object >> loadAsMap ( String key ) throws IOException { Map < String , Map < String , Object >> map = new HashMap < String , Map < String , Object >> ( ) ; LineIterator iterator = new LineIterator ( new FileReader ( file ) ) ; while ( iterator . hasNext ( ) ) { Map < String , Object > json = JsonOutput . MAPPER . readValue ( iterator . nextLine ( ) , Map . class ) ; if ( json . containsKey ( key ) ) { map . put ( json . get ( key ) . toString ( ) , json ) ; } } return map ; }
tr	3	public static Node reverseK ( Node head , int k ) { Node current = head ; Node next = null ; Node prev = null ; int count = 0 ; while ( current != null && count < k ) { next = current . getNext ( ) ; current . setNext ( prev ) ; prev = current ; current = next ; count ++ ; } if ( next != null ) { head . setNext ( reverseK ( next , k ) ) ; } return prev ; }
tr	3	public Queue getQueueById ( long queueId ) { Session session = null ; Queue queue = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; queue = ( Queue ) session . load ( Queue . class , queueId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return queue ; }
tr	6	public static WeightedGraph readGraph ( InputStream is ) { int V = 0 ; Scanner fileScanner = new Scanner ( is ) ; if ( fileScanner . hasNextInt ( ) ) { V = fileScanner . nextInt ( ) ; System . err . println ( "V " + V ) ; } int E = 0 ; if ( fileScanner . hasNextInt ( ) ) { E = fileScanner . nextInt ( ) ; System . err . println ( "E " + E ) ; } WeightedGraph result = new WeightedGraph ( V , E ) ; while ( fileScanner . hasNextLine ( ) ) { String str = fileScanner . nextLine ( ) ; Scanner lineScanner = new Scanner ( str ) ; if ( lineScanner . hasNextInt ( ) ) { int v1 = lineScanner . nextInt ( ) ; if ( lineScanner . hasNextInt ( ) ) { int v2 = lineScanner . nextInt ( ) ; if ( lineScanner . hasNextInt ( ) ) { int weight = lineScanner . nextInt ( ) ; result . addEdge ( new Edge ( v1 , v2 , weight ) ) ; } } } lineScanner . close ( ) ; } fileScanner . close ( ) ; return result ; }
tr	1	public int setRib ( String rib ) { if ( rib . length ( ) > ConfigGlobale . longueurRIB ) { return - 1 ; } else { this . rib = rib ; return 0 ; } }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	2	public GameBoard ( int mines , int height , int width ) { board = new Square [ height ] [ width ] ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { board [ i ] [ j ] = new Square ( ) ; } } this . mines = mines ; this . height = height ; this . width = width ; }
tr	0	public void setPassword ( String password ) { this . password = password ; }
tr	7	public String toString ( ) { String str = "" ; if ( frameData != null ) { for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { String st = "" ; for ( int f = 0 ; f < frameData . length ; f ++ ) if ( frameData [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + frameData [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pauseData . length ; f ++ ) if ( pauseData [ f ] ) str += " " + f ; } return str ; }
tr	7	public static int [ ] getPrimes ( int max ) { int [ ] primes = new int [ max + 1 ] ; for ( int i = 2 ; i <= max ; i ++ ) { primes [ i ] = i ; } int total = max - 1 ; for ( int i = 2 ; i <= Math . sqrt ( max ) ; i ++ ) { for ( int j = i ; j <= max ; ) { j += i ; if ( j <= max && primes [ j ] > 0 ) { primes [ j ] = 0 ; total -- ; } } } int [ ] totalprimes = new int [ total ] ; int temp = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > 0 ) { totalprimes [ temp ] = primes [ i ] ; temp ++ ; } } return totalprimes ; }
tr	3	public Polygon getPolygon ( String s_nameCity ) { Polygon polygonToReturn = new Polygon ( ) ; for ( District district : model . getListDistrict ( ) ) { for ( City city : district . getListCity ( ) ) { if ( city . getS_name ( ) . equals ( s_nameCity ) ) { int i_x = district . getI_x ( ) * model . getI_nbHorizontalSquareInDistrict ( ) + city . getI_x ( ) + ( district . getI_y ( ) % 2 ) * model . getI_nbHorizontalSquareInDistrict ( ) / 2 ; int i_y = district . getI_y ( ) * model . getI_nbVerticalSquareInDistrict ( ) + city . getI_y ( ) ; Point point2D = new Point ( i_x , i_y ) ; polygonToReturn . setPoint2D ( point2D ) ; polygonToReturn . setPoint3D ( convert2DTo3D ( point2D ) ) ; return polygonToReturn ; } } } return polygonToReturn ; }
tr	2	public Object getValueAt ( int row , int col ) { Object [ ] entries = meterReadings . keySet ( ) . toArray ( ) ; Date entry = ( Date ) entries [ row ] ; if ( col == 0 ) return meterReadings . get ( entry ) . getReadingDate ( ) ; else if ( col == 1 ) { return meterReadings . get ( entry ) . getReading ( ) ; } else throw new IndexOutOfBoundsException ( "MeterReadingViewTableModel provides a 4-column table  column-index " + col + " is illegal." ) ; }
tr	7	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	9X	public static GregorianCalendar lireDate ( String date ) { boolean ok = false ; String [ ] champsDate ; int jour = 1 ; int mois = 0 ; int an = 0 ; GregorianCalendar dateSaisie = null ; champsDate = date . split ( "/" ) ; ok = true ; if ( champsDate . length >= 1 ) { try { mois = Integer . parseInt ( champsDate [ 0 ] ) ; if ( ( mois < 1 ) || ( mois > 12 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { mois = moisCourant ( ) ; } if ( champsDate . length == 2 ) { try { an = Integer . parseInt ( champsDate [ 1 ] ) ; if ( ( an < 1900 ) || ( an > 2100 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { an = anneeCourante ( ) ; } if ( ok ) { dateSaisie = new GregorianCalendar ( an , mois - 1 , jour ) ; return dateSaisie ; } else { return null ; } }
tr	4	public Descriptor compile ( SymbolTable table ) { Descriptor d = null ; if ( type instanceof IdentNode ) { String s = ( ( IdentNode ) type ) . getIdentName ( ) ; if ( s . equals ( "integer" ) ) { d = new SimpleTypeDescriptor ( Type . INTEGER ) ; } else if ( s . equals ( "boolean" ) ) { d = new SimpleTypeDescriptor ( Type . boolean ) ; } else if ( s . equals ( "string" ) ) { d = new SimpleTypeDescriptor ( Type . STRING ) ; } else { d = table . descriptorFor ( s ) ; } } else { d = type . compile ( table ) ; } IdentListNode n = ( IdentListNode ) node ; n . compileParams ( table , d ) ; typeOfSection = d ; return null ; }
tr	4	public static TMDrillModel TMgetAllTweetsByKeyword ( String keywords ) { ArrayList < tweetModel > results = new ArrayList < tweetModel > ( ) ; tweetModel t ; TMDrillModel tmDrillModel = new TMDrillModel ( ) ; String tablename = "temp-" + keywords ; tablename = tablename . replaceAll ( " " , "|" ) ; tablename = tablename . replaceAll ( ";" , "|" ) ; tablename = tablename . replaceAll ( " " , "" ) ; System . out . println ( tablename ) ; keywords = keywords . replaceAll ( " " , "%' and message like '%" ) ; keywords = keywords . replaceAll ( ";" , "%' or message like '%" ) ; System . out . println ( keywords ) ; try { Connection c = DBFactory . getConnection ( ) ; PreparedStatement ps = c . prepareStatement ( "DROP TABLE IF EXISTS `" + tablename + "`; " ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "CREATE TABLE `" + tablename + "` (" + "`username` varchar(20) NOT NULL " + "`date` varchar(30) NOT NULL " + "`message` varchar(180) NOT NULL" + ")ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "INSERT INTO `" + tablename + "` (username  date  message) " + "SELECT username  date  message FROM `tweets` " + "WHERE message like '%" + keywords + "%';" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "SELECT * from `" + tablename + "`;" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { t = new tweetModel ( ) ; t . setUsername ( rs . getString ( "username" ) ) ; t . setDate ( rs . getString ( "date" ) ) ; t . setMessage ( cleanTweet ( rs . getString ( "message" ) ) ) ; results . add ( t ) ; } rs . close ( ) ; ps . close ( ) ; c . close ( ) ; System . out . println ( "******************************* " ) ; TopicModel tm = new TopicModel ( ) ; if ( results . isEmpty ( ) ) { tmDrillModel = new TMDrillModel ( - 1 ) ; } else { tm . importData ( results ) ; tm . trainTopics ( ) ; tmDrillModel = new TMDrillModel ( 0 , tablename , tm . getAllTopics ( ) ) ; } } catch ( ClassNotFoundException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return tmDrillModel ; }
tr	4	public static void main ( String args [ ] ) { if ( args . length == 0 ) { try { System . out . println ( "Enter file path:" ) ; wc ( new InputStreamReader ( System . in ) ) ; System . out . println ( lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ; } else { int twords = 0 , tchars = 0 , tlines = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { try { words = chars = lines = 0 ; wc ( new FileReader ( args [ i ] ) ) ; twords += words ; tchars += chars ; tlines += lines ; System . out . println ( args [ i ] + ": " + lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . out . println ( args [ i ] + ": error." ) ; } } System . out . println ( "total: " + tlines + " " + twords + " " + tchars ) ; } }
tr	4	public static boolean writeSalesOrder ( MessageHeader header , List < com . adammargherio . xml . schemas . salesorder . LineItem > items ) { if ( conn == null ) { getConnection ( ) ; } try { String sql = "INSERT INTO tblETSalesHeader VALUES (? ? ? ? ? ? ?)" ; PreparedStatement peHeader = conn . prepareStatement ( sql ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . LineItem l : items ) { try { String item = "INSERT INTO tblETSalesDetail VALUES (? ? ? ? ? ?)" ; PreparedStatement peItem = conn . prepareStatement ( item ) ; peItem . setString ( 1 , l . getLineNo ( ) ) ; peItem . setString ( 2 , l . getItemCode ( ) ) ; peItem . setString ( 3 , l . getProductName ( ) ) ; peItem . setInt ( 4 , l . getQuantity ( ) . intValue ( ) ) ; peItem . setString ( 5 , l . getUnitOfMeasure ( ) ) ; peItem . setInt ( 6 , l . getBasePrice ( ) . intValue ( ) ) ; peItem . execute ( ) ; conn . commit ( ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } } return true ; }
tr	1	public void demote ( Instance instance ) { super . demote ( instance ) ; double rate = - ( double ) time * demotionRate ; s . add ( FeatureVector . staticScale ( rate , instance ) ) ; if ( bias ) sBiasValue += rate ; }
tr	3	public static JsonObjectBuilder rewriteJson ( JsonObjectBuilder copyInto , JsonValue tree , String key ) { switch ( tree . getValueType ( ) ) { case OBJECT : JsonObject obj = ( JsonObject ) tree ; for ( String name : obj . keySet ( ) ) { copyInto = rewriteJson ( copyInto , obj . get ( name ) , name ) ; } break ; case STRING : JsonString st = ( JsonString ) tree ; copyInto . add ( key , st . getString ( ) ) ; break ; default : break ; } return copyInto ; }
tr	6	public void fourth ( ) { someMan = new Man ( ) ; someMan . setBirthplace ( Event . COUNTRY ) ; someMan . putToHand ( new Fish ( Color . YELLOW , Size . LITTLE ) ) ; someMan . setAction ( new Action ( Options . NOTHING , "SHOVE FISH IN EAR" ) ) ; artur = new Artur ( ) ; artur . setFocus ( new CornflakesPacket ( ) ) ; if ( Dentrassi . getInstance ( ) . getUnderwear ( ) != null && getSomeMan ( ) != null && getMatrixes ( ) != null && getSomeMan ( ) . getBirthplace ( ) . equals ( Event . COUNTRY ) ) { for ( Eye eye : getArtur ( ) . getEyes ( ) ) { if ( eye . getFocus ( ) . getClass ( ) == CornflakesPacket . class ) { getArtur ( ) . setState ( State . SURE ) ; break ; } } } }
tr	0	public int getHeight ( int layer ) { return layers . get ( layer ) . getHeight ( ) ; }
tr	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
tr	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof DecafParserListener ) ( ( DecafParserListener ) listener ) . enterId1 ( this ) ; }
tr	8	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	8	public boolean IsInverse ( GameDirection Direction ) { if ( this == GameDirection . UP && Direction == GameDirection . DOWN ) return true ; if ( this == GameDirection . DOWN && Direction == GameDirection . UP ) return true ; if ( this == GameDirection . LEFT && Direction == GameDirection . RIGHT ) return true ; if ( this == GameDirection . RIGHT && Direction == GameDirection . LEFT ) return true ; return false ; }
tr	7	public List < String > getUnionList ( List < String > list1 , List < String > list2 ) { List < String > totalList = new ArrayList < > ( ) ; if ( list1 . size ( ) > list2 . size ( ) ) { for ( String obj : list1 ) { totalList . add ( obj ) ; } for ( String obj : list2 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } else { for ( String obj : list2 ) { totalList . add ( obj ) ; } for ( String obj : list1 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } return totalList ; }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	5	private void getKeyRange ( BSTNode < Integer , String > node , int key1 , int key2 , SList < Integer > result ) { if ( node != null ) { int key = node . getKey ( ) ; if ( key1 <= key ) getKeyRange ( node . getLeftChild ( ) , key1 , key2 , result ) ; if ( key1 <= key && key <= key2 ) result . addLast ( key ) ; if ( key <= key2 ) getKeyRange ( node . getRightChild ( ) , key1 , key2 , result ) ; } }
tr	4	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	9X	private String rec ( String S , String A , String B , int a , int b ) { if ( a == A . length ( ) && b == B . length ( ) ) return "" ; if ( visited [ a ] [ b ] ) return memo [ a ] [ b ] ; String res = null ; int cur = S . length ( ) - ( A . length ( ) - a ) - ( B . length ( ) - b ) ; if ( a < A . length ( ) && matches ( S . charAt ( cur ) , A . charAt ( a ) ) ) { String best = rec ( S , A , B , a + 1 , b ) ; if ( best != null ) { if ( res == null || res . compareTo ( A . charAt ( a ) + best ) > 0 ) res = A . charAt ( a ) + best ; System . out . println ( res ) ; } } if ( b < B . length ( ) && matches ( S . charAt ( cur ) , B . charAt ( b ) ) ) { String best = rec ( S , A , B , a , b + 1 ) ; if ( best != null ) { if ( res == null || res . compareTo ( B . charAt ( b ) + best ) > 0 ) res = B . charAt ( b ) + best ; System . out . println ( res ) ; } } memo [ a ] [ b ] = res ; visited [ a ] [ b ] = true ; return res ; }
tr	2	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
tr	0	public void setIndId ( Integer indId ) { this . indId = indId ; }
tr	6	public void start ( String args [ ] ) { try { this . host = args [ 0 ] ; this . tcpPort = Integer . parseInt ( args [ 1 ] ) ; this . analyticServerRef = args [ 2 ] ; } catch ( NumberFormatException e ) { logger . error ( "Seconds argument has to be an integer" ) ; } catch ( ArrayIndexOutOfBoundsException e ) { logger . error ( "Too few arguments" ) ; } PropertyConfigurator . configure ( "src/log4j.properties" ) ; readProperties ( ) ; managementClient = new ManagementClient ( analyticServerRef ) ; managementClient . start ( ) ; managementClient . processInput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { LoadTestClient client = new LoadTestClient ( host , tcpPort ) ; testClients . add ( client ) ; if ( auctionsPerMin > 0 ) client . createAuctions ( auctionsPerMin , auctionDuration ) ; if ( bidsPerMin > 0 ) client . bidAuctions ( bidsPerMin ) ; executorService . execute ( client ) ; } LoadTestClient updater = new LoadTestClient ( host , tcpPort ) ; testClients . add ( updater ) ; updater . updateList ( updateIntervalSec ) ; executorService . execute ( updater ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { input . readLine ( ) ; input . close ( ) ; } catch ( IOException ex ) { logger . error ( "IO Exception on System Standard Input" ) ; } shutdown ( ) ; }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	1	public static String camelCaseName ( String name ) { return isEmpty ( name ) ? "" : Character . toLowerCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; }
tr	8	@ Test public void testPertenece2 ( ) { boolean expected = false ; boolean actual = arbolito . pertenece ( 8 ) && arbolito . pertenece ( 3 ) && arbolito . pertenece ( 6 ) && arbolito . pertenece ( 1 ) && arbolito . pertenece ( 16 ) && arbolito . pertenece ( 4 ) && arbolito . pertenece ( 7 ) && arbolito . pertenece ( 14 ) && arbolito . pertenece ( 13 ) ; assertEquals ( expected , actual ) ; }
tr	3	private Object firstKey ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return ary [ 0 ] ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) { if ( node . key instanceof EquivalentMap ) return ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) . key ; else return node . key ; } else return firstKey ( node . left ) ; } }
tr	9X	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	3	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new ArrayList < Plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getModule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerDe ( this . vecteur_vitesse ) ; this . plots . add ( new Plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
tr	2	private static List < String > readStringSubKeys ( Preferences root , int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { List < String > results = new ArrayList < String > ( ) ; int [ ] handles = ( int [ ] ) regOpenKey . invoke ( root , new Object [ ] { new Integer ( hkey ) , toCstr ( key ) , new Integer ( KEY_READ ) } ) ; if ( handles [ 1 ] != REG_SUCCESS ) { return null ; } int [ ] info = ( int [ ] ) regQueryInfoKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; int count = info [ 0 ] ; int maxlen = info [ 3 ] ; for ( int index = 0 ; index < count ; index ++ ) { byte [ ] name = ( byte [ ] ) regEnumKeyEx . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) , new Integer ( index ) , new Integer ( maxlen + 1 ) } ) ; results . add ( new String ( name ) . trim ( ) ) ; } regCloseKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; return results ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	1	public void delete ( Tongiao persistentInstance ) { log . debug ( "deleting Tongiao instance" ) ; try { sessionFactory . getCurrentSession ( ) . delete ( persistentInstance ) ; log . debug ( "delete successful" ) ; } catch ( RuntimeException re ) { log . error ( "delete failed" , re ) ; throw re ; } }
tr	7	protected void prepare_sample_reading ( Header header , int allocation , int channel , float [ ] factor , int [ ] codelength , float [ ] c , float [ ] d ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) { groupingtable [ channel ] = table_cd_groupingtables [ allocation ] ; factor [ 0 ] = table_cd_factor [ allocation ] ; codelength [ 0 ] = table_cd_codelength [ allocation ] ; c [ 0 ] = table_cd_c [ allocation ] ; d [ 0 ] = table_cd_d [ allocation ] ; } else { if ( subbandnumber <= 2 ) { groupingtable [ channel ] = table_ab1_groupingtables [ allocation ] ; factor [ 0 ] = table_ab1_factor [ allocation ] ; codelength [ 0 ] = table_ab1_codelength [ allocation ] ; c [ 0 ] = table_ab1_c [ allocation ] ; d [ 0 ] = table_ab1_d [ allocation ] ; } else { groupingtable [ channel ] = table_ab234_groupingtables [ allocation ] ; if ( subbandnumber <= 10 ) { factor [ 0 ] = table_ab2_factor [ allocation ] ; codelength [ 0 ] = table_ab2_codelength [ allocation ] ; c [ 0 ] = table_ab2_c [ allocation ] ; d [ 0 ] = table_ab2_d [ allocation ] ; } else if ( subbandnumber <= 22 ) { factor [ 0 ] = table_ab3_factor [ allocation ] ; codelength [ 0 ] = table_ab3_codelength [ allocation ] ; c [ 0 ] = table_ab3_c [ allocation ] ; d [ 0 ] = table_ab3_d [ allocation ] ; } else { factor [ 0 ] = table_ab4_factor [ allocation ] ; codelength [ 0 ] = table_ab4_codelength [ allocation ] ; c [ 0 ] = table_ab4_c [ allocation ] ; d [ 0 ] = table_ab4_d [ allocation ] ; } } } }
tr	4	private static String readLine ( int lineNumber ) { BufferedReader reader = null ; String line = "" ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; int i = 0 ; for ( String curLine ; ( curLine = reader . readLine ( ) ) != null ; i ++ ) { if ( i == lineNumber ) line = curLine ; } } catch ( IOException e ) { } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } return line ; }
tr	9X	private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI / 2.0 ) : ( Math . PI / 2.0 ) ; } if ( xa < 1.0 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { double temp = 1.0 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * temp * temp + 8.0 ) * temp ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { double denom = 1.0 / ( 1.0 + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1.0 + temp2 ; double zb = - ( za - 1.0 - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1.0 + epsA * epsA ) ; double result ; double resultb ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; result = za + zb ; resultb = - ( result - za - zb ) ; if ( leftPlane ) { final double pia = 1.5707963267948966 * 2.0 ; final double pib = 6.123233995736766E-17 * 2.0 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; resultb = - ( result - za - zb ) ; } if ( negate ^ leftPlane ) { result = - result ; } return result ; }
tr	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
tr	3	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
tr	7	private void setupLinks ( ) { final int rawlinksnum = this . links . size ( ) ; int [ ] rawlinks = new int [ rawlinksnum * Link . LINK_SIZE ] ; int idx = 0 ; for ( int i = 0 ; i < rawlinksnum ; i ++ ) { final int [ ] link = this . links . get ( i ) ; final int src = link [ 0 ] ; final int dst = link [ 1 ] ; final int widx = link [ 2 ] ; rawlinks [ idx ] = src ; idx ++ ; rawlinks [ idx ] = dst ; idx ++ ; rawlinks [ idx ] = widx ; idx ++ ; } Link . sortDstMaj ( rawlinks , Link . ORDER_ASC ) ; int [ ] links = Link . eliminateRedundantLinks ( rawlinks ) ; if ( links . length % Link . LINK_SIZE != 0 ) { throw new LinkArrayCorrupt ( ) ; } this . structure . links = links ; final int linksnum = links . length / Link . LINK_SIZE ; this . structure . linksnum = linksnum ; int woff = 1 ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = links [ idx + Link . IDX_SRC ] ; final int dst = links [ idx + Link . IDX_DST ] ; final int widx = links [ idx + Link . IDX_WEIGHT ] ; this . indeg [ dst ] ++ ; this . outdeg [ src ] ++ ; final int lsrc = this . layermap [ src ] ; final int ldst = this . layermap [ dst ] ; if ( lsrc >= ldst ) { this . structure . recurrent = true ; } if ( widx == WEIGHT_NEEDED ) { links [ idx + Link . IDX_WEIGHT ] = woff ; woff ++ ; } else if ( widx == Link . NOWEIGHT ) { links [ idx + Link . IDX_WEIGHT ] = 0 ; } idx += Link . LINK_SIZE ; } this . structure . weightsnum = ( woff - 1 ) ; int [ ] linksrev = links . clone ( ) ; Link . sortSrcMaj ( linksrev , Link . ORDER_ASC ) ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = linksrev [ idx + Link . IDX_SRC ] ; final int dst = linksrev [ idx + Link . IDX_DST ] ; linksrev [ idx + Link . IDX_DST ] = src ; linksrev [ idx + Link . IDX_SRC ] = dst ; idx += Link . LINK_SIZE ; } this . structure . linksrev = linksrev ; }
tr	0	public MiniGameEventRelayer ( MiniGame initGame ) { game = initGame ; }
tr	6	private void startLevel ( ) { if ( currentlesson . isNoteLevel ( ) ) { if ( ! noteLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + noteLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isRhythmLevel ( ) ) { if ( ! rhythmLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + rhythmLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isScoreLevel ( ) ) { if ( ! scoreLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + scoreLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } }
tr	9X	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	7	public static double doDefAbilityBasePowerMod ( ActivePokemon defender , Move move , double damage ) { if ( defender . hasAbility ( Ability . THICK_FAT ) && ( move . isType ( Type . ICE ) || move . isType ( Type . FIRE ) ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . HEATPROOF ) && move . isType ( Type . FIRE ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . DRY_SKIN ) && move . isType ( Type . FIRE ) ) { damage *= 1.25 ; } damage = ( int ) damage ; return damage ; }
tr	4	@ Override public void processDrawing ( ) { if ( rsAlreadyLoaded || loadingError || genericLoadingError ) { showErrorScreen ( ) ; return ; } drawCycle ++ ; if ( ! loggedIn ) drawLoginScreen ( false ) ; else drawGameScreen ( ) ; anInt1213 = 0 ; }
tr	1	@ Override public String getMessage ( ) { String msg = super . getMessage ( ) ; for ( String name : badValues . keySet ( ) ) { msg += "\n\t" + name + " = " + badValues . get ( name ) ; } return msg ; }
tr	3	@ Override public void tick ( ) { counter ++ ; if ( counter == tickDivider ) { counter = 0 ; if ( enemyUnits . size ( ) > 0 ) { Slime slime = new Slime ( ) ; rune . modifySlime ( slime ) ; for ( EnemyUnit enemy : enemyUnits ) { enemy . gotSlowed ( slime ) ; } } } }
tr	5	static private Vector < double [ ] > sampleResults ( Vector < Future < Vector < double [ ] >>> results , int bins ) throws Exception { int nDescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; System . out . println ( "Printing for " + nDescriptors + " descriptors" ) ; Vector < double [ ] > descriptors = new Vector < double [ ] > ( nDescriptors ) ; for ( int d = 0 ; d < nDescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( Future < Vector < double [ ] >> result : results ) { Vector < double [ ] > samples = result . get ( ) ; int samplesPerBin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesPerBin && b * samplesPerBin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesPerBin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
tr	9X	public static String getResultXMLString ( SimulationFinalResult result ) { if ( result == null ) { return "" ; } StringBuilder xml = new StringBuilder ( ) ; xml . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>" ) . append ( LINE_END ) . append ( "<simulation>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<playercount>" ) . append ( result . getNrOfPlayers ( ) ) . append ( "</playercount>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<rounds>" ) . append ( result . getRounds ( ) ) . append ( "</rounds>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<type>" ) . append ( result . getPokerType ( ) . toString ( ) ) . append ( "</type>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<threads>" ) . append ( result . getNrOfThreads ( ) ) . append ( "</threads>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<duration unit=\"milliseconds\">" ) . append ( result . getDuration ( ) ) . append ( "</duration>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "</meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<players>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) ; PlayerProfile profile = result . getPlayer ( i - 1 ) ; xml . append ( "<handtype>" ) ; xml . append ( profile . getHandType ( ) . toString ( ) ) ; xml . append ( "</handtype>" ) ; xml . append ( LINE_END ) ; if ( profile . getHandType ( ) == HandType . EXACTCARDS ) { Card [ ] cards = profile . getCards ( ) ; for ( Card card : cards ) { xml . append ( getNestingCharacters ( 3 ) ) . append ( "<card>" ) . append ( card . toString ( ) ) . append ( "</card>" ) . append ( LINE_END ) ; } } else if ( profile . getHandType ( ) == HandType . RANGE ) { Range range = profile . getRange ( ) ; for ( int row = 0 ; row < 13 ; row ++ ) { for ( int col = 0 ; col < 13 ; col ++ ) { if ( range . getValue ( row , col ) ) { xml . append ( getNestingCharacters ( 3 ) ) ; xml . append ( "<cardtype>" ) ; xml . append ( Range . rangeNames [ row ] [ col ] ) ; xml . append ( "</cardtype>" ) ; xml . append ( LINE_END ) ; } } } } xml . append ( getNestingCharacters ( 2 ) ) ; xml . append ( "</player>" ) ; xml . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "</players>" ) ; xml . append ( LINE_END ) ; Card [ ] flop = result . getFlop ( ) ; Card turn = result . getTurn ( ) ; Card river = result . getRiver ( ) ; if ( flop != null || turn != null || river != null ) { xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "<community>" ) ; xml . append ( LINE_END ) ; if ( flop != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"1\">" ) . append ( flop [ 0 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"2\">" ) . append ( flop [ 1 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"3\">" ) . append ( flop [ 2 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) ; } if ( turn != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<turn>" ) . append ( turn . toString ( ) ) . append ( "</turn>" ) . append ( LINE_END ) ; } if ( river != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<river>" ) . append ( river . toString ( ) ) . append ( "</river>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</community>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "<result>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<wins>" ) . append ( result . getFormattedWinPercentage ( i - 1 ) ) . append ( "</wins>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<loses>" ) . append ( result . getFormattedLosePercentage ( i - 1 ) ) . append ( "</loses>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<ties>" ) . append ( result . getFormattedTiePercentage ( i - 1 ) ) . append ( "</ties>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "</player>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</result>" ) . append ( LINE_END ) . append ( "</simulation>" ) ; return xml . toString ( ) ; }
tr	2	@ Override public void onPairFailed ( ) { synchronized ( mListeners ) { for ( DiscoveryListener listener : mListeners ) { try { listener . onPairFailed ( ) ; } catch ( RuntimeException e ) { System . out . println ( "Error notifying listener." ) ; } } } System . out . println ( "onPairFailed" ) ; }
tr	5	private void updateNPCs ( Stream stream , int i ) { anInt839 = 0 ; anInt893 = 0 ; method139 ( stream ) ; method46 ( i , stream ) ; method86 ( stream ) ; for ( int k = 0 ; k < anInt839 ; k ++ ) { int l = anIntArray840 [ k ] ; if ( npcArray [ l ] . anInt1537 != loopCycle ) { npcArray [ l ] . desc = null ; npcArray [ l ] = null ; } } if ( stream . currentOffset != i ) { signlink . reporterror ( myUsername + " size mismatch in getnpcpos - pos:" + stream . currentOffset + " psize:" + i ) ; throw new RuntimeException ( "eek" ) ; } for ( int i1 = 0 ; i1 < npcCount ; i1 ++ ) if ( npcArray [ npcIndices [ i1 ] ] == null ) { signlink . reporterror ( myUsername + " null entry in npc list - pos:" + i1 + " size:" + npcCount ) ; throw new RuntimeException ( "eek" ) ; } }
tr	1	public static void input ( float delta ) { if ( nextScene != null ) { updateLoadScene ( ) ; } rootNode . input ( delta ) ; }
tr	9X	public PaymentDialog ( Member member , ClassType ct , String message , int flag ) { messageTextArea . setText ( message ) ; globalMember = member ; globalClassType = ct ; globalFlag = flag ; makePaymentButton = new JButton ( "Make Payment" ) ; makePaymentButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Common . makePayment ( paymentTypeList . getSelectedValue ( ) , globalMember , ( Date ) utilDateModel . getValue ( ) , getPaymentAmount ( ) ) ; updatePaymentStatus ( globalMember , globalClassType ) ; dispose ( ) ; new PaymentDialog ( globalMember , globalClassType , "Payment made for " + globalMember . getName ( ) + "\n of " + getPaymentAmount ( ) + " for " + paymentTypeList . getSelectedValue ( ) . getPaymentTypeName ( ) + "\n up to date: " + ( ( Date ) utilDateModel . getValue ( ) ) . toString ( ) , globalFlag ) ; } } ) ; makePaymentButton . setEnabled ( false ) ; exitButton = new JButton ( "Exit" ) ; exitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { dispose ( ) ; if ( globalFlag == 0 ) new MemberCheckInInterface ( globalClassType ) ; } } ) ; BufferedImage tkdIcon = CommonUI . getTkdIcon ( ) ; BufferedImage skyIcon = CommonUI . getSkyIcon ( ) ; BufferedImage kickIcon = CommonUI . getKickIcon ( ) ; Image img = null ; switch ( ct ) { case TAEKWONDO : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; break ; case SKYBOXING : img = new ImageIcon ( skyIcon ) . getImage ( ) ; break ; case KICKBOXING : img = new ImageIcon ( kickIcon ) . getImage ( ) ; break ; case OTHER : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; default : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; } setIconImage ( img ) ; this . setTitle ( "Enter Payment for " + member . getName ( ) ) ; utilDateModel . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { System . out . println ( "DateModel changed" ) ; setDateSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; panel . add ( paymentToPanel , BorderLayout . CENTER ) ; paymentTypeList . setListData ( Common . getPaymentTypes ( ct ) . toArray ( new PaymentType [ 1 ] ) ) ; paymentTypeList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { JList < PaymentType > tempList = ( JList < PaymentType > ) arg0 . getSource ( ) ; PaymentType pt = tempList . getSelectedValue ( ) ; paymentAmountTextField . setText ( String . format ( "%9.2f" , pt . getPaymentAmount ( ) ) ) ; setPaymentAmountFieldSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; listPanel . add ( paymentTypeList ) ; panel . add ( listPanel , BorderLayout . WEST ) ; paymentAmountPanel . add ( paymentAmountLabel ) ; paymentAmountPanel . add ( paymentAmountTextField ) ; buttonPanel . add ( paymentAmountPanel , BorderLayout . NORTH ) ; buttonPanel . add ( makePaymentButton , BorderLayout . WEST ) ; buttonPanel . add ( exitButton , BorderLayout . SOUTH ) ; panel . add ( buttonPanel , BorderLayout . SOUTH ) ; paymentStatusPanel . add ( paymentStatusTextArea , BorderLayout . NORTH ) ; paymentStatusPanel . add ( messageTextArea , BorderLayout . SOUTH ) ; updatePaymentStatus ( member , ct ) ; panel . add ( paymentStatusPanel , BorderLayout . EAST ) ; this . getContentPane ( ) . add ( panel ) ; this . setSize ( CommonUI . FULLSCREEN ) ; this . setVisible ( true ) ; }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	5	public boolean isWallhugPosition ( int x , int y ) { if ( getFreeCount ( x , y ) != 2 ) return false ; else if ( isEmpty ( moveLeft ( x ) , y ) && isEmpty ( moveRight ( x ) , y ) ) return false ; else if ( isEmpty ( x , moveUp ( y ) ) && isEmpty ( x , moveDown ( y ) ) ) return false ; else return true ; }
tr	6	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { try { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; } catch ( Exception e ) { System . out . println ( "Image not found" ) ; } }
tr	1	public boolean createAccount ( String login , String password ) { if ( logins . containsKey ( login + password ) ) { return false ; } else { logins . put ( login + password , null ) ; return true ; } }
tr	6	public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double absAsinh ; if ( a > 0.167 ) { absAsinh = FastMath . log ( FastMath . sqrt ( a * a + 1 ) + a ) ; } else { final double a2 = a * a ; if ( a > 0.097 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 - a2 * ( 1.0 / 15.0 - a2 * ( 1.0 / 17.0 ) * 15.0 / 16.0 ) * 13.0 / 14.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.0036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } } return negative ? - absAsinh : absAsinh ; }
tr	8	@ Override public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { if ( value . getClass ( ) . getName ( ) . contains ( "PageNames" ) ) { ( ( PageNames ) value ) . setPageName ( ( String ) selectBox . getSelectedItem ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "PictureNames" ) ) { ( ( PictureNames ) value ) . setSelectedPictureIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "SoundNames" ) ) { ( ( SoundNames ) value ) . setSelectedSoundIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ButtonFunctionType" ) ) { ( ( ButtonFunctionType ) value ) . setButtonFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ValueFormatType" ) ) { ( ( ValueFormatType ) value ) . setValueFormat ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedFunctionType" ) ) { ( ( LedFunctionType ) value ) . setLedFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedVisibleType" ) ) { ( ( LedVisibleType ) value ) . setLedVisible ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } } }
tr	9X	public void bindTexture ( String key ) { if ( ! key . equals ( sCurrentlyBound ) || currentlyBound == null ) { sCurrentlyBound = key ; glEnable ( GL_TEXTURE_2D ) ; switch ( key ) { case "null" : glDisable ( GL_TEXTURE_2D ) ; currentlyBound = null ; break ; case "terrain" : terrain . bind ( ) ; currentlyBound = terrain ; break ; case "player" : player . bind ( ) ; currentlyBound = player ; break ; case "debug" : debug . bind ( ) ; currentlyBound = debug ; break ; case "text" : text . bind ( ) ; currentlyBound = text ; break ; case "constructionMenu" : constructionMenu . bind ( ) ; currentlyBound = constructionMenu ; break ; case "debugmenu" : debugMenu . bind ( ) ; currentlyBound = debugMenu ; break ; case "panes" : panes . bind ( ) ; currentlyBound = panes ; break ; case "zed" : zed . bind ( ) ; currentlyBound = zed ; break ; case "entities" : entities . bind ( ) ; currentlyBound = entities ; break ; case "items" : items . bind ( ) ; currentlyBound = items ; break ; case "playerpane" : playerpane . bind ( ) ; currentlyBound = playerpane ; break ; default : System . out . println ( "Tried to bind a texture that doesn't exist" ) ; System . out . println ( key ) ; Boot . shutdownGracefully ( ) ; } glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ; } }
tr	1	public List < SchoolVO > getSchools ( ) { if ( schools == null ) { schools = new ArrayList < SchoolVO > ( ) ; } return this . schools ; }
tr	8	@ Override public boolean hasNext ( ) { if ( hasNextCalled ) return hasNext ; hasNextCalled = true ; if ( n == 0 ) return false ; if ( ! started ) { for ( int i = 0 ; ( subset [ i ] = i ) < k - 1 ; i ++ ) ; started = true ; hasNext = true ; return true ; } else { int i ; for ( i = k - 1 ; i >= 0 && subset [ i ] == n - k + i ; i -- ) ; if ( i < 0 ) { hasNext = false ; return false ; } else { subset [ i ] ++ ; for ( ++ i ; i < k ; i ++ ) subset [ i ] = subset [ i - 1 ] + 1 ; hasNext = true ; return true ; } } }
tr	4	private static Object [ ] subseq ( Object [ ] ary , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == ary . length ) return ary ; else { int len = hi - lo ; Object [ ] a = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) a [ i ] = ary [ i + lo ] ; return a ; } }
tr	0	public boolean jogador1EhVencedor ( ) { return jogador1 . ehVencedor ( ) ; }
tr	0	public StatTracker ( int health , int will , int power , int afinity , int clarity ) { super ( ) ; initialiseComponants ( health , will , afinity , power , clarity ) ; update ( ) ; }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	2	@ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( 2048 ) ; super . toString ( sb ) . append ( " { " ) ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( stats [ i ] . count != 0 ) { sb . append ( "\n        " ) . append ( stats [ i ] . toString ( ) ) ; } } return sb . append ( " }" ) . toString ( ) ; }
tr	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	2	private void AddNewUpdateTime ( float newTime ) { float addTime = newTime ; if ( addTime > 50 ) { addTime = 50 ; } if ( updateTimes . size ( ) >= NUM_UPDATE_TIMES ) { updateTimes . remove ( 0 ) ; } updateTimes . add ( newTime ) ; runTime += newTime ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterEscreva ( this ) ; }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	9X	public static Object getDummyObject ( class cls ) { Object obj = null ; try { Constructor < ? > ctor = cls . getDeclaredConstructor ( ) ; Reflector . ensureIsAccessible ( ctor ) ; obj = ctor . newInstance ( ) ; } catch ( NoSuchMethodException e1 ) { final Constructor < ? > ctor = cls . getConstructors ( ) [ 0 ] ; class [ ] paramTypes = ctor . getParameterTypes ( ) ; List < Object > params = new ArrayList < Object > ( ) ; for ( class paramType : paramTypes ) params . add ( paramType . isPrimitive ( ) ? getTypeDefaultValue ( paramType . getName ( ) ) : null ) ; try { obj = ctor . newInstance ( params . toArray ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } catch ( SecurityException e1 ) { e1 . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } finally { return obj ; } }
tr	3	public ArithmeticParser ( String [ ] programSource ) throws ParserParsingException { super ( programSource [ programSource . length - 1 ] ) ; this . context = new EvaluationContext ( ) ; for ( int i = 0 ; i < programSource . length - 1 ; i ++ ) { String [ ] parts = programSource [ i ] . replace ( " " , "" ) . split ( "=" ) ; Tree tree = new ExpressionsTreeParser ( parts [ 1 ] ) . getRootTree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { Matcher matcher = FUNCTION_DEFINITION_PATTERN . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new RuntimeException ( "Wrong definition" ) ; String functionName = matcher . group ( 1 ) ; String argumentName = matcher . group ( 2 ) ; context . addFunctionValue ( functionName , argumentName , tree ) ; } else { context . addVarValue ( parts [ 0 ] , tree ) ; } } }
tr	5	@ Override public void work ( ) { try { Vertex v = getClickedVertex ( ) ; if ( v == null ) { gui . console ( "Choose a vertex" ) ; return ; } doFillVertex = true ; Queue < Vertex > q = new LinkedList < Vertex > ( ) ; v . visited = true ; q . add ( v ) ; while ( ! q . isEmpty ( ) ) { v = q . poll ( ) ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { Vertex w = e . dest ; if ( ! w . visited ) { w . visited = true ; q . add ( w ) ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } catch ( Exception e ) { } clearAll ( ) ; repaint ( ) ; }
tr	1	public IValue peek ( ) { if ( _stack . isEmpty ( ) ) { return null ; } return _stack . peek ( ) ; }
tr	5	private boolean complexStroke ( ChineseStroke p ) { boolean b = false ; if ( p . size ( ) >= 2 ) { for ( int i = 0 ; i < ( p . size ( ) - 2 ) ; i ++ ) { ChineseLine cl1 = new ChineseLine ( p . get ( i ) [ 0 ] , p . get ( i + 1 ) [ 0 ] , p . get ( i + 1 ) [ 1 ] , p . get ( i ) [ 1 ] ) ; ChineseLine cl2 = new ChineseLine ( p . get ( i + 1 ) [ 0 ] , p . get ( i + 2 ) [ 0 ] , p . get ( i + 2 ) [ 1 ] , p . get ( i + 1 ) [ 1 ] ) ; if ( Math . abs ( cl1 . totaldegrees - cl2 . totaldegrees ) > 70 && ( cl1 . totaldegrees > 80 || cl2 . totaldegrees > 80 ) ) { b = true ; } } } return b ; }
tr	2	public void setAttributes ( Point leftest , Point rightest ) { if ( leftest != null ) { leftAngle = Tools . round ( src . getDirection ( leftest ) , 10000 ) ; leftDist = src . getDistance ( leftest ) ; } if ( rightest != null ) { rightAngle = Tools . round ( src . getDirection ( rightest ) , 10000 ) ; rightDist = src . getDistance ( rightest ) ; } }
tr	5	public void update ( final World w ) { for ( short x = 0 ; x < sideLength ; x ++ ) { for ( short y = 0 ; y < sideLength ; y ++ ) { short tileX = ( short ) ( x + ( coords . getX ( ) * sideLength ) ) ; short tileY = ( short ) ( y + ( coords . getY ( ) * sideLength ) ) ; final Tile t = getTile ( x , y ) ; if ( ( t == Tiles . air ) || ( t == null ) ) { new Packet03Tile ( t , tileX , tileY ) . writeDataToServer ( ) ; } if ( t . doesTick ( ) ) { t . update ( w , tileX , tileY ) ; } } } }
tr	7	public synchronized void update ( ) { Tile . WATER . update ( ) ; for ( int i = 0 ; i < mobs . size ( ) ; i ++ ) { if ( ! mobs . get ( i ) . isRemoved ( ) && mobs . get ( i ) != null ) { mobs . get ( i ) . update ( ) ; } else { mobs . remove ( i ) ; } } for ( int i = 0 ; i < particles . size ( ) ; i ++ ) { if ( ! particles . get ( i ) . isRemoved ( ) ) { particles . get ( i ) . update ( ) ; } else { particles . remove ( i ) ; } } for ( int i = 0 ; i < projectiles . size ( ) ; i ++ ) { if ( ! projectiles . get ( i ) . isRemoved ( ) ) { projectiles . get ( i ) . update ( ) ; } else { projectiles . remove ( i ) ; } } }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	8	public int threeSumClosest ( int [ ] num , int target ) { Arrays . sort ( num ) ; int n = num . length ; if ( n < 3 ) { int sum = 0 ; for ( int i : num ) { sum += i ; } return sum ; } int closest = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { closest += num [ i ] ; } for ( int i = 0 ; i <= n - 3 ; i ++ ) { int a = num [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c == target ) { return target ; } else if ( a + b + c > target ) { end -- ; } else { start ++ ; } if ( Math . abs ( a + b + c - target ) < Math . abs ( closest - target ) ) { closest = a + b + c ; } } } return closest ; }
tr	7	@ Override public void handleCommand ( CommandMessage m ) { String args [ ] = m . getArgs ( ) ; switch ( args . length ) { case 0 : case 1 : return ; default : switch ( args [ 1 ] ) { case "stop" : logger . info ( "request stop command: " + args [ 2 ] ) ; plugins . stopPlugin ( args [ 2 ] ) ; ph . sendMessage ( "Plugin " + args [ 2 ] + " byl zastaven." ) ; return ; case "start" : logger . info ( "request start command: " + args [ 2 ] ) ; if ( plugins . startPlugin ( args [ 2 ] ) ) { ph . sendMessage ( "Plugin " + args [ 2 ] + " byl spu\u0161t\u011Bn." ) ; } return ; } case 2 : switch ( args [ 1 ] ) { case "reload" : plugins . reload ( ) ; ph . sendMessage ( "Plugin " + args [ 2 ] + " byl zastaven." ) ; return ; } break ; } }
tr	3	public void add ( T item ) { Node node = new Node ( item ) ; if ( current == null ) { node . next = head ; node . prev = null ; if ( head != null ) head . prev = node ; head = node ; } else { node . next = current . next ; node . prev = current ; if ( current . next != null ) current . next . prev = node ; current . next = node ; } ++ idx ; current = node ; ++ size ; }
tr	2	private void parseErrorFromFile ( String filename , Kind ... expectedErrorKind ) { TokenStream stream = null ; try { stream = new TokenStream ( new BufferedReader ( new FileReader ( filename ) ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } Scanner s = new Scanner ( stream ) ; try { s . scan ( ) ; Parser p = new Parser ( stream ) ; p . parse ( ) ; int numErrors = p . errorList . size ( ) ; assertEquals ( expectedErrorKind . length , numErrors ) ; } catch ( LexicalException e ) { System . out . println ( "Lexical error parsing program: " ) ; System . out . println ( filename ) ; System . out . println ( e . toString ( ) ) ; System . out . println ( "---------" ) ; fail ( ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || obj . getClass ( ) != this . getClass ( ) ) { return false ; } WordPOSKey myWordPOSKey = ( WordPOSKey ) obj ; boolean case1 = ( this . word == null ) ? myWordPOSKey . getWord ( ) == null : this . word . equals ( myWordPOSKey . getWord ( ) ) ; boolean case2 = ( this . pos == null ) ? myWordPOSKey . getPOS ( ) == null : this . pos . equals ( myWordPOSKey . getPOS ( ) ) ; return ( case1 && case2 ) ; }
tr	5	public static Pair < Integer , Integer > linearCongruence ( int a , int b , final int n ) { positiveCheck ( n ) ; a = normalizeIntModulo ( a , n ) ; b = normalizeIntModulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new Pair < > ( 0 , 1 ) ; final int numberOfSolutions = gcd ( a , n ) ; if ( b % numberOfSolutions != 0 ) return new Pair < > ( ) ; int bezoutCoefficientA ; if ( a > n ) bezoutCoefficientA = bezout ( a , n ) . get ( 1 ) ; else bezoutCoefficientA = bezout ( n , a ) . get ( 2 ) ; final int shiftedModulus = n / numberOfSolutions ; int x = ( bezoutCoefficientA * b ) / numberOfSolutions ; x = normalizeIntModulo ( x , shiftedModulus ) ; return new Pair < > ( x , shiftedModulus ) ; }
tr	9X	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	1	protected void checkKey ( K k ) { if ( k == null ) { throw new InvalidKeyException ( "Invalid key: null." ) ; } }
tr	9X	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
tr	2	public State safeNext ( Character c , boolean v ) { if ( next ( c ) == null ) { State st = new State ( "" + c ) ; st . setParent ( this ) ; next . put ( c , st ) ; } State nx = next ( c ) ; if ( v ) nx . visit ( ) ; return nx ; }
tr	5	public int [ ] compute ( int source ) { ZippedArray arr = ZippedArray . arrayWithDefaultValue ( 1000 ) ; int n = graph . getVerticesCount ( ) ; arr . set ( 0 , 0 , source ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { int oldValue = ( Integer ) arr . get ( i - 1 , v ) ; int minValue = Integer . MAX_VALUE ; List < Edge > edges = graph . getEdgesTo ( v ) ; for ( Edge edge : edges ) { int x = edge . getX ( ) ; int w = edge . getWeight ( ) ; int t = ( Integer ) arr . get ( i - 1 , x ) + w ; if ( t < minValue ) minValue = t ; } arr . set ( Math . min ( oldValue , minValue ) , i , v ) ; } } int [ ] result = new int [ graph . getVerticesCount ( ) ] ; for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { result [ i ] = ( Integer ) arr . get ( n - 1 , i ) ; } return result ; }
tr	4	public int getElapsed ( ) { if ( getStart ( ) == null || getEnd ( ) == null || ! hasActuallyStarted ( ) || hasEnded ( ) ) { return - 1 ; } return Util . safeLongToInt ( Util . getDeltaT ( start , new GregCalPlus ( ) ) ) ; }
tr	1	@ Override public void remove ( K key ) { if ( recursive ) { this . rootNode = removeRec ( this . rootNode , key ) ; } else { removeIt ( key ) ; } }
tr	3	@ Override protected void onButtonReleased ( GuiButton button ) { if ( button . id == 0 ) { this . parent . setBoard ( this . board ) ; GuiScreen . setGui ( this . parent ) ; } else if ( button . id == 1 ) { this . selectPage ( this . page - 1 ) ; } else if ( button . id == 2 ) { this . selectPage ( this . page + 1 ) ; } else { this . select ( button . id - 3 ) ; } }
tr	6	public static class getType ( class c ) { if ( c == null ) { Logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getActualType ( c . getGenericSuperclass ( ) ) ; if ( ct != null ) return ct ; Type [ ] interfaces = c . getGenericInterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( Type t : interfaces ) { ct = getActualType ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	4	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
tr	1	public LinkSetNode ( int s , int d , NodeColor nodeColor , LinkSetNode left , LinkSetNode right ) { if ( s > d ) { this . s = s ; this . d = d ; } else { this . s = d ; this . d = s ; } this . color = nodeColor ; this . left = left ; this . right = right ; }
tr	2	public static void main ( String args [ ] ) { String [ ] words = new String [ 2 ] ; String [ ] more = new String [ 2 ] ; ArrayList < String > str = new ArrayList < String > ( ) ; String strng ; for ( int i = 0 ; i < words . length ; i ++ ) words [ i ] = "words" + i ; for ( int i = 0 ; i < more . length ; i ++ ) more [ i ] = "more" + i ; str = merge ( words , more ) ; System . out . println ( str ) ; strng = makeSentence ( words ) ; System . out . println ( words ) ; }
tr	7	@ Override protected void handleMethodAttribute ( final String name , final byte [ ] data , final int offset , final long length , final ConstantPool constantPool ) { if ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Signature . equals ( name ) ) { parseSignature ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Deprecated . equals ( name ) ) { parseDeprecated ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_Synthetic . equals ( name ) ) { parseSynthetic ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Exceptions . equals ( name ) ) { parseExceptions ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Code . equals ( name ) ) { parseCode ( data , offset , constantPool ) ; } else { System . err . println ( "Unhandled method attribute: " + name ) ; } }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
tr	0	protected BombImage ( Content parent , Game game , Point position , int range , Date end ) { super ( parent , game , position , range , end ) ; }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	4	@ Override public void draw ( Graphics2D g2d ) { final AffineTransform transform = g2d . getTransform ( ) ; g2d . translate ( ( x * CELL_SIZE * 2 ) , ( y * CELL_SIZE * 2 ) ) ; if ( count > 0 ) { atoms [ 0 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 0 ) ; g2d . translate ( ( double ) CELL_SIZE , 0d ) ; if ( count > 1 ) { atoms [ 1 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 1 ) ; g2d . translate ( ( double ) - CELL_SIZE , ( double ) CELL_SIZE ) ; if ( count > 2 ) { atoms [ 2 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 2 ) ; g2d . translate ( ( double ) CELL_SIZE , 0d ) ; if ( count > 3 ) { atoms [ 3 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 3 ) ; g2d . setTransform ( transform ) ; }
tr	3	void readFromZip ( String fileName ) throws SAXException , TransformerConfigurationException , XMLStreamException , IOException { try { zipIn = new ZipFile ( fileName ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } if ( zipIn != null ) { while ( visuPages . getTabCount ( ) > 0 ) visuPages . removeTabAt ( 0 ) ; hardwareOptDlg . dispose ( ) ; hardwareOptDlg = new HardwarePropertiesDialog ( this ) ; hardwareOptDlg . setLocation ( 220 , 120 ) ; pictures . clearArchive ( ) ; pictures . loadLibraryFromArchive ( zipIn ) ; sounds . clearArchive ( ) ; sounds . loadLibraryFromArchive ( zipIn ) ; ZipEntry visuZipObj = zipIn . getEntry ( "Visu.xml" ) ; InputStream zipInStream = zipIn . getInputStream ( visuZipObj ) ; parseXMLStream ( zipInStream ) ; zipIn . close ( ) ; } }
tr	4	public void execute ( ) { alive = true ; while ( alive ) { try { gameManager . update ( ) ; if ( gameManager . isSwitchGame ( ) ) { final SharedGameData gameData = SharedGameData . getInstance ( ) ; gameData . levelUp ( ) ; gameManager = GameManagerFactory . getNextGame ( ) ; gameManager . init ( ) ; gameManager . setSwitchGame ( false ) ; gameManager . changeGameState ( GameState . INITIALIZING ) ; } if ( changedGame != null ) { changedGame . init ( ) ; gameManager = changedGame ; changedGame = null ; } } catch ( final Exception e ) { e . printStackTrace ( ) ; } } }
tr	4	@ Override public void input ( float delta ) { float movAmt = speed * delta ; if ( Input . getKey ( leftKey ) ) move ( getTransform ( ) . getRot ( ) . getLeft ( ) , movAmt ) ; if ( Input . getKey ( rightKey ) ) move ( getTransform ( ) . getRot ( ) . getRight ( ) , movAmt ) ; if ( Input . getKey ( downKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , - movAmt ) ; else if ( Input . getKey ( upKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , movAmt ) ; }
tr	7	void funcargs ( ExpDesc f ) { FuncState fs = this . fs ; ExpDesc args = new ExpDesc ( ) ; int base , nparams ; int line = this . linenumber ; switch ( this . t . token ) { case ( : { if ( line != this . lastline ) this . syntaxerror ( "ambiguous syntax (function call x new statement)" ) ; this . next ( ) ; if ( this . t . token == ) ) args . k = VVOID ; else { this . explist1 ( args ) ; fs . setmultret ( args ) ; } this . check_match ( ) , ( , line ) ; break ; } case { : { this . constructor ( args ) ; break ; } case TK_STRING : { this . codestring ( args , this . t . ts ) ; this . next ( ) ; break ; } default : { this . syntaxerror ( "function arguments expected" ) ; return ; } } FuncState . _assert ( f . k == VNONRELOC ) ; base = f . info ; if ( hasmultret ( args . k ) ) nparams = FuncState . LUA_MULTRET ; else { if ( args . k != VVOID ) fs . exp2nextreg ( args ) ; nparams = fs . freereg - ( base + 1 ) ; } f . init ( VCALL , fs . codeABC ( FuncState . OP_CALL , base , nparams + 1 , 2 ) ) ; fs . fixline ( line ) ; fs . freereg = base + 1 ; }
tr	0	public double getPriceLevel3 ( ) { return priceLevel3 ; }
tr	2	public void deleteShowTime ( Date time , Movie movie ) { for ( ShowTime showTime : showTimeDAO . getShowTimes ( movie ) ) { if ( time == showTime . getTime ( ) ) { showTimeDAO . deleteShowTime ( showTime ) ; } } }
tr	3	public void eval ( Environment e ) { switch ( type ) { case Value : e . value ( e . thing ( this ) ) ; break ; case Name : e . value ( this ) ; break ; case Call : e . call ( this ) ; break ; default : throw new Error ( String . format ( "Primitive '%s' not implemented!" , value ) ) ; } }
tr	2	private boolean allCons ( int i , int n , String word ) { int startIndex = i - n ; int endIndex = i ; for ( int j = startIndex ; j < endIndex ; j ++ ) { if ( vowels . contains ( word . charAt ( j ) ) ) { return false ; } } return true ; }
tr	3	public Matrix getU ( ) { Matrix X = new Matrix ( n , n ) ; double [ ] [ ] U = X . getArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i <= j ) { U [ i ] [ j ] = LU [ i ] [ j ] ; } else { U [ i ] [ j ] = 0.0 ; } } } return X ; }
tr	1	public void restoreDecks ( ) { int k = OPEN_DECK_SIZE - open_deck . size ( ) ; if ( deck . size ( ) < k ) { deck . addAll ( discarded ) ; discardeds . push ( discarded ) ; discarded = new CardBag ( ) ; } else { discardeds . push ( null ) ; } CardBag cs = deck . draw ( k , random ) ; deck_restorations . push ( cs ) ; open_deck . addAll ( cs ) ; }
tr	8	public void searchContacts ( String search ) { try { ArrayList < Contact > results = new ArrayList < > ( 1 ) ; String [ ] searchArray = search . split ( " " ) ; for ( Contact c : contacts ) { if ( c . getFirstName ( ) . contains ( searchArray [ 0 ] ) ) results . add ( c ) ; else if ( c . getLastName ( ) . contains ( searchArray [ searchArray . length - 1 ] ) ) results . add ( c ) ; else if ( c . getPhone ( ) . contains ( search ) ) results . add ( c ) ; else if ( c . getEmail ( ) . contains ( search ) ) results . add ( c ) ; } if ( results . size ( ) < 1 ) throw new ContactNotFoundException ( ) ; System . out . println ( "Search results:" ) ; for ( Contact c : results ) { System . out . println ( c ) ; } confirmDeleteRecords ( results ) ; } catch ( ContactNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; return ; } }
tr	7	public void radixSort ( int [ ] data ) { int max = data [ 0 ] , radix = 1 ; ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( max < data [ i ] ) { max = data [ i ] ; } } Node [ ] bucket = new Node [ 10 ] ; for ( int i = 0 ; i < bucket . length ; i ++ ) { bucket [ i ] = new Node ( ) ; } while ( max / radix > 0 ) { for ( int i = 0 ; i < data . length ; i ++ ) { bucket [ ( data [ i ] / radix ) % 10 ] . list . add ( data [ i ] ) ; } int pos = 0 ; for ( int i = 0 ; i < bucket . length ; i ++ ) { for ( int j = 0 ; j < bucket [ i ] . list . size ( ) ; j ++ ) { data [ pos ++ ] = bucket [ i ] . list . get ( j ) ; } bucket [ i ] . list . clear ( ) ; } radix *= 10 ; } }
tr	7	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	6	public static void openFile ( File file ) { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) ) ; if ( ( OSDetector . isWindows ( ) ) && ( file . isFile ( ) ) ) { int exitCode = runWindows ( file ) ; if ( exitCode == 0 ) { return ; } else { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) + " failed with windows method. (fall back to default action)" ) ; } } if ( ! Desktop . isDesktopSupported ( ) ) { throw new UnsupportedOperationException ( "Desktop is not supported (fatal)" ) ; } Desktop desktop = Desktop . getDesktop ( ) ; if ( ! desktop . isSupported ( Desktop . Action . OPEN ) ) { throw new UnsupportedOperationException ( "Desktop doesn't support the OPEN action (fatal)" ) ; } try { URI uri = file . getCanonicalFile ( ) . toURI ( ) ; desktop . open ( new File ( uri ) ) ; } catch ( IOException e ) { Debug . printException ( e ) ; } }
tr	2	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	3	private static < T > void removeDuplicatesBuffer ( Node < T > list ) { if ( list == null ) { throw new IllegalArgumentException ( ) ; } Set < T > unique = new HashSet < T > ( ) ; unique . add ( list . getData ( ) ) ; while ( list . getNext ( ) != null ) { Node < T > current = list ; while ( unique . contains ( current . getNext ( ) . getData ( ) ) ) { current = current . getNext ( ) ; } unique . add ( current . getNext ( ) . getData ( ) ) ; list . setNext ( current . getNext ( ) ) ; list = list . getNext ( ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	8	private final static boolean isVowel ( String in , int at , int length ) { if ( ( at < 0 ) || ( at >= length ) ) return false ; char it = in . charAt ( at ) ; if ( ( it == A ) || ( it == E ) || ( it == I ) || ( it == O ) || ( it == U ) || ( it == Y ) ) return true ; return false ; }
tr	1	public void set_wheelchair_boarding ( String in ) { try { _wheelchair_boarding = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
tr	9X	public final static byte [ ] encodeToByte ( byte [ ] sArr , boolean lineSep ) { if ( sArr == null || sArr . length == 0 ) return new byte [ 0 ] ; int sLen = sArr . length ; int eLen = ( sLen / 3 ) * 3 ; int cCnt = ( ( sLen - 1 ) / 3 + 1 ) << 2 ; int dLen = cCnt + ( lineSep ? ( cCnt - 1 ) / 76 << 1 : 0 ) ; byte [ ] dArr = new byte [ dLen ] ; for ( int s = 0 , d = 0 , cc = 0 ; s < eLen ; ) { int i = ( sArr [ s ++ ] & ff ) << 16 | ( sArr [ s ++ ] & ff ) << 8 | ( sArr [ s ++ ] & ff ) ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 18 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 12 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ i & 3f ] ; if ( lineSep && ++ cc == 19 && d < dLen - 2 ) { dArr [ d ++ ] = '' ; dArr [ d ++ ] = '' ; cc = 0 ; } } int left = sLen - eLen ; if ( left > 0 ) { int i = ( ( sArr [ eLen ] & ff ) << 10 ) | ( left == 2 ? ( ( sArr [ sLen - 1 ] & ff ) << 2 ) : 0 ) ; dArr [ dLen - 4 ] = ( byte ) CA [ i >> 12 ] ; dArr [ dLen - 3 ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ dLen - 2 ] = left == 2 ? ( byte ) CA [ i & 3f ] : ( byte ) = ; dArr [ dLen - 1 ] = = ; } return dArr ; }
tr	2	@ Override public void insertContent ( int pos , Line line ) { if ( pos > this . length ( ) || pos < 0 ) { throw new DocumentException ( "Impossible to insert something in this line at this position!" ) ; } this . getContent ( ) . insert ( pos , line . getContent ( ) ) ; }
tr	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Survey survey = ( Survey ) o ; if ( idsurvey != survey . idsurvey ) return false ; if ( date != null ? ! date . equals ( survey . date ) : survey . date != null ) return false ; if ( question != null ? ! question . equals ( survey . question ) : survey . question != null ) return false ; return true ; }
tr	8	public boolean execute ( CommandSender sender , String [ ] args ) { String groupName = args [ 0 ] ; GroupManager groupManager = Citadel . getGroupManager ( ) ; Faction group = groupManager . getGroup ( groupName ) ; if ( group == null ) { sendMessage ( sender , ChatColor . RED , "Group doesn't exist" ) ; return true ; } String senderName = sender . getName ( ) ; if ( ! group . isFounder ( senderName ) && ! group . isModerator ( senderName ) && ! group . isMember ( senderName ) ) { sendMessage ( sender , ChatColor . RED , "Invalid permission to access this group" ) ; return true ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cGroup Name:\u00A7e " ) . append ( groupName ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cOwner:\u00A7e " ) . append ( group . getFounder ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cModerators:\u00A7e " ) . append ( groupManager . getModeratorsOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cMembers:\u00A7e " ) . append ( groupManager . getMembersOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; if ( group . isFounder ( senderName ) || group . isModerator ( senderName ) ) { String password = group . getPassword ( ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cPassword:\u00A7e " ) . append ( password ) . toString ( ) ) ; String joinable = "" ; if ( password != null && ! password . equalsIgnoreCase ( "null" ) ) { joinable = "Yes" ; } else { joinable = "No" ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cJoinable:\u00A7e " ) . append ( joinable ) . toString ( ) ) ; } return true ; }
tr	2	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	4	@ Override public Node compile ( ) { boolean fc = first instanceof Comment ; boolean sc = second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return second . compile ( ) ; if ( sc ) return first . compile ( ) ; return new Block ( first . compile ( ) , second . compile ( ) ) ; }
tr	7	public static void polcof ( final double [ ] xa , final double [ ] ya , final double [ ] cof ) { int k , j , i , n = xa . length ; double xmin ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; for ( j = 0 ; j < n ; j ++ ) { x [ j ] = xa [ j ] ; y [ j ] = ya [ j ] ; } for ( j = 0 ; j < n ; j ++ ) { double [ ] x_t = new double [ n - j ] ; double [ ] y_t = new double [ n - j ] ; for ( k = 0 ; k < n - j ; k ++ ) { x_t [ k ] = x [ k ] ; y_t [ k ] = y [ k ] ; } Poly_interp interp = new Poly_interp ( x , y , n - j ) ; cof [ j ] = interp . rawinterp ( 0 , 0. ) ; xmin = 1.0e99 ; k = - 1 ; for ( i = 0 ; i < n - j ; i ++ ) { if ( abs ( x [ i ] ) < xmin ) { xmin = abs ( x [ i ] ) ; k = i ; } if ( x [ i ] != 0.0 ) y [ i ] = ( y [ i ] - cof [ j ] ) / x [ i ] ; } for ( i = k + 1 ; i < n - j ; i ++ ) { y [ i - 1 ] = y [ i ] ; x [ i - 1 ] = x [ i ] ; } } }
tr	1	@ Override protected void put ( Message request , Message response ) { request . put ( Document . ID , request . get ( Vote . ID ) ) ; Message origVote = new Message ( request . getContext ( ) ) ; new PersistentDocumentService ( ) . doGet ( request , origVote ) ; Message updateReq = new Message ( request . getContext ( ) ) ; updateReq . putAllFields ( origVote . getFields ( ) ) ; updateReq . putAllReferences ( origVote . getReferences ( ) ) ; updateReq . put ( Vote . VOTE , request . get ( Vote . VOTE ) ) ; new PersistentDocumentService ( ) . doPut ( updateReq , response ) ; new AnswerService ( ) . doPut ( request , response ) ; if ( request . get ( Vote . VOTE ) . equals ( Vote . VOTE_UP ) ) { Message answerResponse = new Message ( request . getContext ( ) ) ; new AnswerService ( ) . doGet ( request , answerResponse ) ; request . put ( Profile . ID , answerResponse . get ( Document . AUTHOR ) ) ; request . put ( Profile . POINTS , "" + Vote . POINTS_FOR_VOTE_UP ) ; new ProfileService ( ) . doPut ( request , response ) ; } }
tr	7	private ItemGraphic newItem ( Item item ) { ItemGraphic itemG = new ItemGraphic ( ) { @ Override public void paint ( Graphics graph ) { } @ Override public Object getParent ( ) { return null ; } @ Override public Point getBoardPosition ( ) { return null ; } } ; if ( item instanceof Bomb ) { itemG = newBomb ( ( Bomb ) item ) ; } else if ( item instanceof Wall ) { itemG = newWall ( ( Wall ) item ) ; } else if ( item instanceof SpeedBuff ) { itemG = newSpeedBuff ( ( SpeedBuff ) item ) ; } else if ( item instanceof RangeBuff ) { itemG = newRangeBuff ( ( RangeBuff ) item ) ; } else if ( item instanceof LifeBuff ) { itemG = newLifeBuff ( ( LifeBuff ) item ) ; } else if ( item instanceof DropBuff ) { itemG = newDropBuff ( ( DropBuff ) item ) ; } else if ( ! ( item instanceof Ground ) ) { System . out . println ( "Objet inconnu." ) ; } return itemG ; }
tr	5	public void next ( boolean respectRandom ) { if ( ! randomOrder || ! respectRandom ) { index ++ ; if ( index >= record . getRecordCount ( ) ) { index = 0 ; } } else if ( respectRandom ) { index = rand . nextInt ( record . getRecordCount ( ) ) ; } currentRecord = record . getRecordNumber ( index , false ) ; if ( currentRecord . getExtra1 ( ) . indexOf ( "rem=s" ) >= 0 ) { next ( ) ; } }
tr	8	public static Pair < Integer > traverse_spiral ( int cur_row , int cur_col , int square_len ) { int midpoint = ( square_len - 1 ) / 2 ; int next_col = cur_col ; int next_row = cur_row ; if ( cur_row == square_len / 2 && cur_col == midpoint ) { next_col = - 1 ; next_row = - 1 ; } else if ( cur_row <= midpoint ) { if ( cur_col < cur_row - 1 ) { next_row -- ; } else if ( cur_col < square_len - 1 - cur_row ) { next_col ++ ; } else if ( next_col != midpoint ) { next_row ++ ; } } else { if ( cur_col > cur_row ) { next_row ++ ; } else if ( cur_col > square_len - 1 - cur_row ) { next_col -- ; } else { next_row -- ; } } Pair < Integer > p = new Pair < Integer > ( next_row , next_col ) ; return p ; }
tr	1	@ Override public E actual ( ) { if ( actual == null ) { throw new NullPointerException ( "Error: no se puede acceder el dato actual!" ) ; } return actual . getDato ( ) ; }
tr	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
tr	1	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; JSONTokener x = new JSONTokener ( string ) ; while ( x . more ( ) ) { String name = Cookie . unescape ( x . nextTo ( = ) ) ; x . next ( = ) ; jo . put ( name , Cookie . unescape ( x . nextTo ( ; ) ) ) ; x . next ( ) ; } return jo ; }
tr	8	public static void changeProtocolMetadataFile ( String tmpMetadataFile , String identifier ) { String newMetadataFile = "/tmp/PRO" + System . currentTimeMillis ( ) + ".xml" ; FileWriter fichero = null ; PrintWriter pw = null ; File archivo = new File ( tmpMetadataFile ) ; try { fichero = new FileWriter ( newMetadataFile ) ; BufferedReader in = new BufferedReader ( new FileReader ( archivo ) ) ; pw = new PrintWriter ( fichero ) ; String data = "" ; data = in . readLine ( ) ; String spaces = "" ; boolean secId = false ; while ( data != null ) { if ( data . indexOf ( "<identifier>" ) != - 1 ) { secId = true ; } int s = data . indexOf ( "<entry>" ) ; if ( s != - 1 && secId ) { secId = false ; for ( int i = 0 ; i < s ; i ++ ) spaces += " " ; data = spaces + "<entry>" + identifier + "</entry>" ; } pw . println ( data ) ; data = in . readLine ( ) ; } in . close ( ) ; } catch ( IOException e ) { System . out . println ( "unable to find file" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; Process proc = Runtime . getRuntime ( ) . exec ( "cp " + newMetadataFile + " " + tmpMetadataFile ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } }
tr	0	@ Override public HandlerList getHandlers ( ) { return handlers ; }
tr	7	public ClassificationCodeType codeType ( ) { if ( "Flg" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "MemberStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ServiceRank" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "Region" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "WithdrawalReason" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductCategory" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } return ClassificationCodeType . String ; }
tr	9X	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	3	public void set ( ProfesorBean oProfesorBean ) throws Exception { try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( oProfesorBean . getId ( ) == 0 ) { oProfesorBean . setId ( oMysql . insertOne ( "profesor" ) ) ; } oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "id_usuario" , Integer . toString ( oProfesorBean . getId_usuario ( ) ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "dni" , oProfesorBean . getDni ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "nombre" , oProfesorBean . getNombre ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape1" , oProfesorBean . getApe1 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape2" , oProfesorBean . getApe2 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "sexo" , oProfesorBean . getSexo ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "telefono" , oProfesorBean . getTelefono ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "email" , oProfesorBean . getEmail ( ) ) ; if ( oProfesorBean . getId_usuario ( ) > 0 ) { oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" , oProfesorBean . getPassword ( ) ) ; oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" , oProfesorBean . getLogin ( ) ) ; } else { oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" ) ; oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" ) ; } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "ProfesorDao.setProfesor: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } }
tr	5	@ Override public boolean onRequest ( HttpRequest request , HttpResponse response ) throws Exception { String filePath = request . getRequestedFilePath ( ) ; if ( urlToMapTo != null ) { if ( ! filePath . startsWith ( urlToMapTo ) ) return false ; filePath = filePath . substring ( urlToMapTo . length ( ) ) ; } File file = new File ( directory , filePath ) ; if ( ! file . isFile ( ) || ! file . canRead ( ) || ! file . getAbsolutePath ( ) . startsWith ( directory . getAbsolutePath ( ) ) ) return false ; IOFileChannelInputBuffer buffer = new IOFileChannelInputBuffer ( new FileInputStream ( file ) . getChannel ( ) ) ; response . setHeader ( "content-type" , mimeNameMap . getContentTypeFor ( file . getAbsolutePath ( ) ) ) ; response . setBodyBuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	8	public boolean baca ( String no_beli ) { boolean adaKesalahan = false ; Connection cn = null ; this . no_beli = no_beli ; listKwitansi = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select * from kwitansi where no_beli='" + no_beli + "'" ; sta = cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; listKwitansi = new Object [ rset . getRow ( ) ] [ 4 ] ; rset . first ( ) ; int i = 0 ; do { if ( ! rset . getString ( "kode_buku" ) . equals ( "" ) ) { listKwitansi [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getInt ( "jumlah" ) , rset . getInt ( "harga" ) } ; } i ++ ; } while ( rset . next ( ) ) ; sta . close ( ) ; rset . close ( ) ; if ( listKwitansi . length > 0 ) { adaKesalahan = false ; } } catch ( Exception ex ) { adaKesalahan = true ; } } } return ! adaKesalahan ; }
tr	4	public boolean checkType ( Object obj ) { return ( ( obj instanceof java . lang . byte && ( ( byte ) obj ) . byteValue ( ) >= 0 ) || ( obj instanceof java . lang . short && ( ( short ) obj ) . shortValue ( ) >= 0 && ( ( short ) obj ) . shortValue ( ) <= 255 ) ) ; }
tr	7	private void insertDatabaseOperation ( Object object , Connection connection , DatabaseOperation databaseOperation ) { try { if ( ! object . getClass ( ) . isAnnotationPresent ( Table . class ) ) { throw new JStrykerException ( "Object(" + object + ") isn't Entity" ) ; } Table table = object . getClass ( ) . getAnnotation ( Table . class ) ; StringBuilder builder = new StringBuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isAnnotationPresent ( transient . class ) ) { continue ; } Column annotation = field . getAnnotation ( Column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getName ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; String string = builder . toString ( ) ; execute ( null , connection , new ByteArrayInputStream ( string . getBytes ( ) ) , databaseOperation ) ; } catch ( IllegalAccessException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	2	public void setStationData ( String call , String locator , String qrzUser , String qrzPass , double lat , double lon , String hamUser , String hamPass ) throws SQLException { Connection con = getDbConnection ( ) ; String query0 = "DELETE FROM SATION_DATA" ; con . prepareCall ( query0 ) . execute ( ) ; String query = "INSERT INTO SATION_DATA (CALL_ID LOCATOR LONGITUDE LATITUDE QRZ_USER QRZ_PASS HAM_USER HAM_PASS) VALUES (? ? ? ? ? ? ? ?)" ; java . sql . PreparedStatement stm = con . prepareStatement ( query ) ; int index = 1 ; stm . setString ( index ++ , call ) ; stm . setString ( index ++ , locator ) ; stm . setDouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setDouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setString ( index ++ , qrzUser ) ; stm . setString ( index ++ , qrzPass ) ; stm . setString ( index ++ , hamUser ) ; stm . setString ( index ++ , hamPass ) ; stm . execute ( ) ; }
tr	2	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
tr	6	@ Test public void testEncodingSchemeCompleteSerialisationVoice ( ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . MULAW_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 01 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/MuLaw-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . CVSD ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 02 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/CVSD Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . ADPCM ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 03 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/ADPCM Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_16 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 04 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-16 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 05 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . VQ ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 06 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/VQ Encoding Scheme record" , e ) ; } }
tr	3	public void testMapBranch ( ) { Mapping mapping = new Mapping ( ) ; VirtualNode virtualNode = requests . get ( 0 ) . getVirtualNodes ( ) . get ( 0 ) ; VirtualLink virtualLink = ( VirtualLink ) virtualNode . getAttachedLinks ( ) . get ( 0 ) ; VirtualNode virtualDestinyNode = ( VirtualNode ) virtualLink . getNodeAttachedTo ( virtualNode ) ; for ( PhysicalNode physicalNode : substrateNetwork . getHashNodes ( ) . values ( ) ) { if ( ! mapping . isNodeMapped ( virtualNode ) && physicalNode . canHost ( virtualNode ) ) { mapping . addNodeMapping ( virtualNode , physicalNode ) ; } } assertTrue ( mapper . mapBranch ( virtualNode , virtualDestinyNode , virtualLink , substrateNetwork , mapping ) ) ; }
tr	1	private Request getBaseRequest ( Iterator < String > titles ) { try { Request ret = new Request ( BASE ) ; String joinedTitles = combineStrings ( titles , 50 ) ; ret . addQuery ( TITLES_KEY , joinedTitles ) ; return ret ; } catch ( MalformedURLException impossible ) { impossible . printStackTrace ( ) ; return null ; } }
tr	2	private DefaultConstructorFactory getDefaultConstructorFactory ( ) { lock . lock ( ) ; try { DefaultConstructorFactory factory = null ; try { factory = new SunDefaultConstructorFactory ( ) ; } catch ( Exception e ) { } if ( factory == null ) factory = new NoDefaultConstructorFactory ( ) ; return factory ; } finally { lock . unlock ( ) ; } }
tr	4	public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) { change = false ; for ( n = all ( ) ; n . hasMoreElements ( ) ; ) { nt = ( non_terminal ) n . nextElement ( ) ; for ( p = nt . productions ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; prod_first = prod . check_first_set ( ) ; if ( ! prod_first . is_subset_of ( nt . _first_set ) ) { change = true ; nt . _first_set . add ( prod_first ) ; } } } } }
tr	4	public boolean saveToFile ( String path ) { logger . info ( "Write all shares into " + path ) ; if ( path == null || ! path . endsWith ( ".ht" ) ) { throw new IllegalArgumentException ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { FileWriter writer = new FileWriter ( path , false ) ; writer . write ( convertSharesToString ( ) ) ; writer . close ( ) ; } catch ( FileNotFoundException e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( IOException e ) { logger . warning ( "Could not write to file '" + path + "' - " + e . getMessage ( ) ) ; return false ; } return true ; }
tr	5	public Component getTableCellRendererComponent ( JTable table , Object val , boolean sel , boolean foc , int r , int c ) { JLabel label ; if ( val == Attendance . PRESENT ) label = new JLabel ( new ImageIcon ( check_icon ) ) ; else if ( val == Attendance . ABSENT ) label = new JLabel ( "-" , SwingConstants . CENTER ) ; else if ( val instanceof BidCounter ) label = new BidLabel ( ( BidCounter ) val ) ; else if ( val instanceof Player ) label = new JLabel ( val . toString ( ) , SwingConstants . LEFT ) ; else label = new JLabel ( val . toString ( ) , SwingConstants . CENTER ) ; label . setFont ( table . getFont ( ) ) ; if ( sel ) { label . setOpaque ( true ) ; label . setBackground ( SystemColor . textHighlight ) ; label . setForeground ( SystemColor . textHighlightText ) ; } return label ; }
tr	2	public void updateValues ( ) { speed += acceleration ; speed *= dampingFactor ; iconCoordinateY += speed ; if ( iconCoordinateY < 0 ) { speed = - speed ; } if ( ( getHeight ( ) - icon . getHeight ( null ) ) < iconCoordinateY ) { speed = - speed ; } }
tr	8	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	3	public JSONWriter array ( ) throws JSONException { if ( this . mode == i || this . mode == o || this . mode == a ) { this . push ( null ) ; this . append ( "[" ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced array." ) ; }
tr	4	@ Override protected void checkPD ( ) { switch ( pd ) { case CLOCK6 : case CLOCK12 : sqNumWidth = 1 ; sqNumHeight = 4 ; break ; case CLOCK3 : case CLOCK9 : default : sqNumWidth = 4 ; sqNumHeight = 1 ; break ; } }
tr	5	public void kill ( ) { if ( socket == null ) return ; try { oos . close ( ) ; } catch ( IOException e ) { } try { ois . close ( ) ; } catch ( IOException e ) { } try { bis . close ( ) ; } catch ( IOException e ) { } try { socket . close ( ) ; socket = null ; } catch ( IOException e ) { } }
tr	6	@ SuppressWarnings ( "deprecation" ) public static void insertTestData ( Connection databaseConnection ) throws SQLException { List < Student > studentList = new ArrayList < Student > ( ) ; studentList . add ( new Student ( "firstname_1" , "lastname_1" , new Date ( 80 , 1 , 1 ) , 2.1 ) ) ; studentList . add ( new Student ( "firstname_2" , "lastname_2" , new Date ( 80 , 1 , 2 ) , 2.2 ) ) ; studentList . add ( new Student ( "firstname_3" , "lastname_3" , new Date ( 80 , 1 , 3 ) , 2.3 ) ) ; studentList . add ( new Student ( "firstname_4" , "lastname_4" , new Date ( 80 , 1 , 4 ) , 2.4 ) ) ; studentList . add ( new Student ( "firstname_5" , "lastname_5" , new Date ( 80 , 1 , 5 ) , 2.5 ) ) ; studentList . add ( new Student ( "firstname_6" , "lastname_6" , new Date ( 80 , 1 , 6 ) , 2.6 ) ) ; studentList . add ( new Student ( "firstname_7" , "lastname_7" , new Date ( 80 , 1 , 7 ) , 2.7 ) ) ; studentList . add ( new Student ( "firstname_8" , "lastname_8" , new Date ( 80 , 1 , 8 ) , 2.8 ) ) ; PreparedStatement preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO STUDENT (FIRSTNAME  LASTNAME  BIRTHDATE  GPA) VALUES (? ? ? ?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Student student : studentList ) { preparedStatement . setString ( 1 , student . firstname ) ; preparedStatement . setString ( 2 , student . lastname ) ; preparedStatement . setDate ( 3 , student . birthdate ) ; preparedStatement . setDouble ( 4 , student . gpa ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { student . id = resultSet . getInt ( 1 ) ; } } List < Course > courseList = new ArrayList < Course > ( ) ; courseList . add ( new Course ( "course_1" ) ) ; courseList . add ( new Course ( "course_2" ) ) ; courseList . add ( new Course ( "course_3" ) ) ; courseList . add ( new Course ( "course_4" ) ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO COURSE (NAME) VALUES (?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Course course : courseList ) { preparedStatement . setString ( 1 , course . name ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { course . id = resultSet . getInt ( 1 ) ; } } Map < Integer , String > studentGradeMap = new HashMap < Integer , String > ( ) ; studentGradeMap . put ( 1 , "A" ) ; studentGradeMap . put ( 2 , "A-" ) ; studentGradeMap . put ( 3 , "B+" ) ; studentGradeMap . put ( 4 , "B" ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO GRADE (STUDENT_ID  COURSE_ID  GRADE) VALUES (? ? ?)" ) ; for ( int i = 0 ; i < courseList . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( i + 1 ) * 2 ; j ++ ) { int studentID = studentList . get ( j ) . id ; int courseID = courseList . get ( i ) . id ; String grade = studentGradeMap . get ( i + 1 ) ; preparedStatement . setInt ( 1 , studentID ) ; preparedStatement . setInt ( 2 , courseID ) ; preparedStatement . setString ( 3 , grade ) ; preparedStatement . executeUpdate ( ) ; } } }
tr	6	private static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	6	public int [ ] plusOne ( int [ ] digits ) { int carry = 1 ; if ( digits == null || digits . length == 0 ) { return digits ; } for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { int sum = digits [ i ] + carry ; digits [ i ] = sum % 10 ; carry = sum / 10 ; if ( carry == 0 ) { break ; } } int [ ] result = null ; if ( carry > 0 ) { result = new int [ digits . length + 1 ] ; result [ 0 ] = carry ; for ( int i = 1 ; i <= digits . length ; i ++ ) { result [ i ] = digits [ i - 1 ] ; } } else { result = digits ; } return result ; }
tr	8	public void run ( ) { while ( ! mServerDisconnected ) { ArrayList < NetworkMessage > messages = GetMessages ( mUnsanitizedMessages ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { NetworkMessage current = messages . get ( i ) ; current . Sanatize ( ) ; String message = current . GetMessage ( ) ; StringTokenizer st = new StringTokenizer ( message ) ; try { int id = Integer . parseInt ( st . nextToken ( ) ) ; ConnectedClient client = GetClient ( id ) ; if ( client != null ) { client . MessageRecieved ( ) ; } String command = st . nextToken ( ) ; if ( command . equalsIgnoreCase ( "ping" ) ) { client . PingRecieved ( ) ; } else if ( command . equalsIgnoreCase ( "connect" ) ) { if ( client == null ) { System . out . println ( "someone connected" ) ; ConnectedClient newClient = new ConnectedClient ( GetNextID ( ) , current . GetAddress ( ) , current . GetPort ( ) ) ; mClients . add ( newClient ) ; } } else { throw new Exception ( ) ; } } catch ( Exception e ) { AddMessage ( message , current . GetAddress ( ) , current . GetPort ( ) , mMessages ) ; } } try { Thread . sleep ( 10 ) ; } catch ( Exception e ) { } } }
tr	3	public String getResultDetail ( int index ) { if ( ! detail ) return null ; if ( index < 0 || index >= getResultCount ( ) ) throw new IllegalArgumentException ( class + ": illegal value for index" ) ; return details . get ( index ) ; }
tr	4	public void construct2DMatrixFromStringSet ( int currentRow , int startIndex , int numRows , int numColumns , List < String > rawData ) { String sCurrentLine = "" ; String _convertedPattern = "" ; int trackNumberOfRows = 0 ; int sIndex = 0 ; _pattern = new String [ numRows ] ; while ( true ) { sCurrentLine = rawData . get ( currentRow ) . substring ( startIndex , startIndex + numColumns ) ; sIndex = 0 ; if ( trackNumberOfRows == numRows ) break ; _convertedPattern = "" ; while ( sIndex < sCurrentLine . length ( ) ) { _convertedPattern += ( sCurrentLine . charAt ( sIndex ) == + ? 1 : 0 ) ; sIndex ++ ; } _pattern [ trackNumberOfRows ] = String . valueOf ( binaryToDecimal ( _convertedPattern ) ) ; trackNumberOfRows ++ ; } }
tr	5	public AList < Song > getTracksByGenre ( Genre g ) { AList < Song > tracksByGenre = new AList < Song > ( ) ; for ( SListIterator < Record > iterator = createIterator ( ) ; iterator . isValid ( ) ; iterator . moveNext ( ) ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( AListIterator < Song > iterator2 = iterator . getCurrentElem ( ) . getSide ( j ) . getSideTracklist ( ) . createIterator ( ) ; iterator2 . isValid ( ) ; iterator2 . moveNext ( ) ) { if ( iterator2 . getCurrentElem ( ) . getGenre ( ) . equals ( g ) ) { tracksByGenre . addLast ( iterator2 . getCurrentElem ( ) ) ; } } } } if ( tracksByGenre . isEmpty ( ) ) { return null ; } else { return tracksByGenre ; } }
tr	6	private RequirementElement parseAttackElementInfo ( List < String > factors ) { RequirementElement new_elem = new RequirementElement ( ) ; if ( factors . get ( 2 ) . equals ( "Circle" ) && ! factors . get ( 3 ) . equals ( "empty" ) ) { new_elem = new NewAntiGoal ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; new_elem . setType ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ; String sg_name = factors . get ( 3 ) ; new_elem . setName ( sg_name . trim ( ) ) ; ( ( NewAntiGoal ) new_elem ) . extractInfoFromName ( ) ; } else if ( checkCircle ( factors . get ( 7 ) ) ) { } else { new_elem = new RequirementElement ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; if ( factors . get ( 2 ) . equals ( "Hexagon" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . TASK . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "Rectangle" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . DOMAIN_ASSUMPTION . name ( ) ) ; } else if ( factors . get ( 3 ) . equals ( "empty" ) & factors . get ( 2 ) . equals ( "Circle" ) & factors . get ( 10 ) . equals ( "0" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ; } else { } new_elem . setName ( factors . get ( 3 ) ) ; } String [ ] temp2 = factors . get ( 11 ) . split ( " " ) ; new_elem . origin_x = double . parseDouble ( temp2 [ 0 ] . replace ( " " , "." ) ) ; new_elem . origin_y = double . parseDouble ( temp2 [ 1 ] . replace ( " " , "." ) ) ; return new_elem ; }
tr	4	@ Override public void keyReleased ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) upPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_RIGHT ) rightPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) downPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_LEFT ) leftPressed = false ; }
tr	2	void setProgressBar ( double pos ) { progress_bar = pos ; if ( ! is_initialised && initpainter != null ) repaint ( 100 ) ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	3	@ Override public void dispose ( ) { for ( ObjectMap < String , Object > entry : data . values ( ) ) { for ( Object resource : entry . values ( ) ) { if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } }
tr	1	public int take ( int index ) { if ( register . get ( index ) ) { lastappend . remove ( index ) ; stack . add ( index ) ; } lastappend . add ( index ) ; register . set ( index , true ) ; return index ; }
tr	3	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	4	public static ArrayList < String > getCluster ( String token ) { if ( singleton == null ) { singleton = new BrownFeaturizer ( ) ; singleton . init ( new Model ( ) ) ; } ArrayList < String > list = new ArrayList < String > ( ) ; String cluster = singleton . mappingS . get ( token ) ; if ( cluster == null ) { cluster = "NONE" ; } else { for ( int len : LEN ) { if ( cluster . length ( ) >= len ) { String pf = cluster . substring ( 0 , len ) ; list . add ( "CLUST_" + len + "_" + pf ) ; } } list . add ( "CLUST_ALL_" + cluster ) ; } return list ; }
tr	4	public LetterElement getElementAt ( final int x , final int y ) { final int col = ( x - XFUDGE ) >= 0 ? ( ( x - XFUDGE ) / CELL_WIDTH ) : 0 ; final int row = ( y - YFUDGE ) >= 0 ? ( ( y - YFUDGE ) / CELL_HEIGHT ) : 0 ; if ( ( col < COLS ) && ( row < ROWS ) ) { return matrix [ col ] [ row ] ; } else { return null ; } }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	8	public static void main ( String [ ] args ) { final Random rnd = new Random ( System . currentTimeMillis ( ) ) ; final int input = 2 ; final int hidden = 8 ; final int trainset_size = 5000 ; final int testset_size = 100 ; final int epochs = 4000 ; final double learningrate = 0.004 ; final double momentum = 0.9 ; final MLPGenerator gen = new MLPGenerator ( ) ; gen . inputLayer ( input ) ; gen . hiddenLayer ( hidden , CellType . SIGMOID , true , - 1.0 ) ; gen . outputLayer ( 1 , CellType . SIGMOID ) ; final Net mlp = gen . generate ( ) ; mlp . initializeWeights ( rnd ) ; final SampleSet trainset = generateData ( trainset_size + testset_size , 0.5f , rnd ) ; final SampleSet testset = trainset . split ( testset_size , rnd ) ; GradientDescent trainer = new GradientDescent ( ) ; trainer . setEpochs ( epochs ) ; trainer . setLearningRate ( learningrate ) ; trainer . setMomentum ( momentum ) ; trainer . setPermute ( true ) ; trainer . setRnd ( rnd ) ; trainer . setTargetError ( 10E-5 ) ; trainer . setNet ( mlp ) ; trainer . setTrainingSet ( trainset ) ; trainer . addListener ( new NetTrainerListener ( ) { @ Override public void started ( NetTrainer trainer ) { } @ Override public void finished ( NetTrainer trainer ) { } @ Override public void epoch ( NetTrainer trainer ) { final int ep = trainer . getEpoch ( ) + 1 ; if ( ( ep ) % ( epochs / 16 ) != 0 && ep != 1 ) return ; final BufferedImage img = new BufferedImage ( 800 , 800 , BufferedImage . TYPE_INT_RGB ) ; double [ ] p = new double [ 2 ] ; double [ ] o = new double [ 2 ] ; for ( int y = 0 ; y < img . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getWidth ( ) ; x ++ ) { p [ 0 ] = ( ( double ) x ) / ( ( double ) ( img . getWidth ( ) ) ) ; p [ 1 ] = ( ( double ) y ) / ( ( double ) ( img . getHeight ( ) ) ) ; mlp . reset ( ) ; mlp . input ( p , 0 ) ; mlp . compute ( ) ; mlp . output ( o , 0 ) ; int v = ( ( int ) ( o [ 0 ] * 255 ) ) ; img . setRGB ( x , y , ( ( v >> 1 ) << 8 ) | v ) ; } } final Graphics2D g = ( Graphics2D ) img . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Sample s : trainset ) { int x = ( int ) ( ( double ) ( img . getWidth ( ) - 1 ) * s . getInput ( ) [ 0 ] ) ; int y = ( int ) ( ( double ) ( img . getHeight ( ) - 1 ) * s . getInput ( ) [ 1 ] ) ; if ( s . getTarget ( ) [ 0 ] > 0.5 ) { g . setColor ( CLASS_1 ) ; } else { g . setColor ( CLASS_2 ) ; } g . fillOval ( x - 2 , y - 2 , 5 , 5 ) ; } JFrame frame = new JFrame ( "Geometry Learning - Epoch: " + ep ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel panel = new JPanel ( ) { private static final long serialVersionUID = - 4307908552010057652 ; @ Override protected void paintComponent ( Graphics gfx ) { super . paintComponent ( gfx ) ; gfx . drawImage ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , null ) ; } } ; panel . setPreferredSize ( new Dimension ( img . getWidth ( ) , img . getHeight ( ) ) ) ; frame . add ( panel ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } } ) ; trainer . train ( ) ; System . out . println ( ) ; ClassificationValidator val = new ClassificationValidator ( mlp ) ; for ( Sample s : trainset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on trainset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; val . reset ( ) ; for ( Sample s : testset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on testset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; }
tr	9X	public static boolean edgeTest ( double [ ] [ ] a , double [ ] [ ] b ) { double tmpPoint [ ] ; if ( a [ 0 ] [ X ] > a [ 1 ] [ X ] ) { tmpPoint = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = tmpPoint ; } if ( b [ 0 ] [ X ] > b [ 1 ] [ X ] ) { tmpPoint = b [ 0 ] ; b [ 0 ] = b [ 1 ] ; b [ 1 ] = tmpPoint ; } if ( a [ 0 ] [ Y ] == a [ 1 ] [ Y ] && b [ 0 ] [ Y ] == b [ 1 ] [ Y ] ) { if ( ( a [ 0 ] [ Y ] == b [ 0 ] [ Y ] ) && ( between ( b , a [ 0 ] [ X ] , X ) || between ( b , a [ 1 ] [ X ] , X ) ) ) { return true ; } return false ; } if ( a [ 0 ] [ X ] == a [ 1 ] [ X ] ) { if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) { if ( ( a [ 0 ] [ X ] == b [ 0 ] [ X ] ) && ( between ( b , a [ 0 ] [ Y ] , Y ) || between ( b , a [ 1 ] [ Y ] , Y ) ) ) { return true ; } return false ; } return wallTest ( b , a ) ; } else if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) return wallTest ( a , b ) ; return segmentTest ( a , b ) ; }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } Ѕtring data = Ѕtring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	4	public void scheduledTask ( InspectorOpenTask task ) { List < State > allowedParents = new ArrayList < > ( ) ; allowedParents . add ( State . SCHEDULED_TASKS_HEADER ) ; allowedParents . add ( State . SCHEDULED_TASK ) ; traverseUp ( allowedParents ) ; if ( this . hierarchy . peek ( ) != State . SCHEDULED_TASK ) this . hierarchy . push ( State . SCHEDULED_TASK ) ; printString ( new StringBuilder ( ) . append ( "<span style=color:" ) . append ( task . isAsync ( ) ? "#3072aa;>" : "#000;>" ) . append ( " [" ) . append ( task . getPluginName ( ) ) . append ( "] (ID: " ) . append ( task . getId ( ) ) . append ( ") " ) . append ( task . isAsync ( ) ? "Async" : "NotAsync" ) . append ( task . isRecurring ( ) ? "  Repeating: " + task . getRecurringPeriod ( ) + " ticks - " : " - " ) . append ( task . getClassName ( ) ) . append ( "</span>" ) . toString ( ) ) ; }
tr	0	public void setPassword ( String password ) { this . password = password ; }
tr	0	public void setWireframe ( boolean enabled ) { wireframeEnabled = enabled ; }
tr	6	public void run ( ) { Message m = Parser . extractRequest ( fromClient ) ; Node child = m . contents . getFirstChild ( ) ; if ( ! child . getLocalName ( ) . equals ( Parser . connectRequest ) ) { return ; } System . out . println ( "Receiving: " + m ) ; String xmlString = Message . responseHeader ( m . id ( ) ) + "<connectResponse id='" + id + "'/></response>" ; Message r = new Message ( xmlString ) ; if ( ! sendMessage ( r ) ) { System . err . println ( "Unable to respond to connect Request from remote Client." ) ; return ; } Server . register ( id , this ) ; while ( ( m = Parser . extractRequest ( fromClient ) ) != null ) { Message response = handler . process ( this , m ) ; if ( ! sendMessage ( response ) ) { break ; } } if ( handler instanceof IShutdownHandler ) { ( ( IShutdownHandler ) handler ) . logout ( Server . getState ( id ) ) ; } Server . unregister ( id ) ; try { fromClient . close ( ) ; toClient . close ( ) ; client . close ( ) ; } catch ( IOException e ) { System . err . println ( "Unable to close connection:" + e . getMessage ( ) ) ; } }
tr	3	@ Override public int storeProject ( String name , String description ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newProjectId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (name  description)" ) . append ( " VALUES " ) . append ( "('" + name + "'  '" + description + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newProjectId = rs . getInt ( 1 ) ; } rs . getStatement ( ) . close ( ) ; rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newProjectId ; }
tr	6	private boolean r_Step_3 ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_4 , 7 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "al" ) ; break ; case 2 : slice_from ( "ic" ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	3	public int getPort ( ) { String num = getString ( "Port" ) ; if ( num == null || num . equals ( "" ) ) { return DEFAULT_PORT ; } try { return Integer . parseInt ( num , 10 ) ; } catch ( NumberFormatException ex ) { logger . warning ( "Bad value for listening port (" + num + ")" ) ; throw new IllegalStateException ( "Bad value for listening port (" + num + ")" , ex ) ; } }
tr	6	public void mouseClicked ( MouseEvent me ) { try { if ( me . getSource ( ) == jb_connexion ) { login = jtf_login . getText ( ) ; password = String . valueOf ( jpf_password . getPassword ( ) ) ; System . out . println ( "Email : " + login ) ; System . out . println ( "MotDePasse : " + password ) ; User u = null ; Connection co = bs . getConnection ( ) ; System . out . println ( "avant IF" ) ; if ( User . checkPresence ( bs , login , password ) ) { System . out . println ( "debut IF" ) ; u = User . findByLogs ( login , password , bs ) ; groupe = UserType . findById ( u . getId_ut ( ) , bs ) . getName_ut ( ) ; System . out . println ( "OK : " + groupe ) ; afficherMenuPrincipal ( ) ; setResizable ( true ) ; setExtendedState ( MAXIMIZED_BOTH ) ; } else { System . out . println ( "NON OK" ) ; } } if ( me . getSource ( ) == jb_mdp_oublie ) { if ( SwingUtilities . isLeftMouseButton ( me ) ) { } if ( SwingUtilities . isRightMouseButton ( me ) ) { } } } catch ( Exception e ) { System . out . println ( "Exception" ) ; e . printStackTrace ( ) ; } }
tr	9X	private void setDebug ( final ComponentWrapper parentW , boolean b ) { if ( b && ( debugTimer == null || debugTimer . getDelay ( ) != getDebugMillis ( ) ) ) { if ( debugTimer != null ) debugTimer . stop ( ) ; ContainerWrapper pCW = parentW . getParent ( ) ; final Component parent = pCW != null ? ( Component ) pCW . getComponent ( ) : null ; debugTimer = new Timer ( getDebugMillis ( ) , new MyDebugRepaintListener ( ) ) ; if ( parent != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Container p = parent . getParent ( ) ; if ( p != null ) { if ( p instanceof JComponent ) { ( ( JComponent ) p ) . revalidate ( ) ; } else { parent . invalidate ( ) ; p . validate ( ) ; } } } } ) ; } debugTimer . setInitialDelay ( 100 ) ; debugTimer . start ( ) ; } else if ( ! b && debugTimer != null ) { debugTimer . stop ( ) ; debugTimer = null ; } }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	1	public double timesRestart ( Character c ) { if ( restart . containsKey ( c ) ) { return restart . getValue ( c ) ; } else { return 0 ; } }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
tr	8	public ArrayList < Point > estimateLaunchPoint ( Rectangle slingshot , Point targetPoint ) { double scale = getSceneScale ( slingshot ) ; Point ref = getReferencePoint ( slingshot ) ; double x = ( targetPoint . x - ref . x ) / scale ; double y = - ( targetPoint . y - ref . y ) / scale ; double bestError = 1000 ; double theta1 = 0 ; double theta2 = 0 ; double v = _scaleFactor * _launchVelocity [ 6 ] ; double v2 = v * v ; double v4 = v2 * v2 ; double tangent1 = ( v2 - Math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double tangent2 = ( v2 + Math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double t1 = actualToLaunch ( Math . atan ( tangent1 ) ) ; double t2 = actualToLaunch ( Math . atan ( tangent2 ) ) ; ArrayList < Point > pts = new ArrayList < Point > ( ) ; for ( double theta = t1 - BOUND ; theta <= t1 + BOUND ; theta += 0.001 ) { double velocity = getVelocity ( theta ) ; double u_x = velocity * Math . cos ( theta ) ; double u_y = velocity * Math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = Math . abs ( a * x * x + b * x - y ) ; if ( error < bestError ) { theta1 = theta ; bestError = error ; } } if ( bestError < 1000 ) { theta1 = actualToLaunch ( theta1 ) ; pts . add ( findReleasePoint ( slingshot , theta1 ) ) ; } bestError = 1000 ; for ( double theta = t2 - BOUND ; theta <= t2 + BOUND ; theta += 0.001 ) { double velocity = getVelocity ( theta ) ; double u_x = velocity * Math . cos ( theta ) ; double u_y = velocity * Math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = Math . abs ( a * x * x + b * x - y ) ; if ( error < bestError ) { theta2 = theta ; bestError = error ; } } theta2 = actualToLaunch ( theta2 ) ; if ( theta2 < Math . toRadians ( 75 ) && theta2 != theta1 && bestError < 1000 ) pts . add ( findReleasePoint ( slingshot , theta2 ) ) ; return pts ; }
tr	1	@ Test public void acceptedTestAStar ( ) { Automaton a = new RegExp ( "a*" ) . toAutomaton ( ) ; String [ ] expected = { "" , "a" , "aa" , "aaa" , "aaaa" , "aaaaa" , "aaaaaa" , "aaaaaaa" , "aaaaaaaa" , "aaaaaaaaa" } ; int i = 0 ; for ( String s : AutomatonHelper . accepted ( a , 10 ) ) { assertEquals ( expected [ i ++ ] , s ) ; } }
tr	4	public void minHeapify ( int index ) { for ( int left = leftChild ( index ) ; left < heap . size ( ) ; index = left ) { if ( left + 1 < heap . size ( ) && heap . get ( left + 1 ) . key < heap . get ( left ) . key ) { left ++ ; } if ( heap . get ( left ) . key < heap . get ( index ) . key ) { swap ( left , index ) ; } else { break ; } } }
tr	8	public static void main ( String [ ] args ) { int grade ; grade = Integer . parseInt ( args [ 0 ] ) ; if ( grade <= 100 && grade >= 85 ) System . out . println ( "HD" ) ; else if ( grade <= 84 && grade >= 75 ) System . out . println ( "D" ) ; else if ( grade <= 74 && grade >= 65 ) System . out . println ( "C" ) ; else if ( grade <= 64 && grade >= 50 ) System . out . println ( "P" ) ; else System . out . println ( "F" ) ; }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	4	private List regenerateChildPaths ( Path path , List children , int currentSize , int newSize ) { if ( currentSize == 1 ) { workingPaths . remove ( path ) ; currentSize = 0 ; children = new ArrayList ( newSize ) ; pathsToChildPaths . put ( path , children ) ; } else if ( newSize == 1 ) { workingPaths . removeAll ( children ) ; workingPaths . add ( path ) ; pathsToChildPaths . remove ( path ) ; return Collections . EMPTY_LIST ; } while ( currentSize < newSize ) { Path child = new Path ( ) ; workingPaths . add ( child ) ; children . add ( child ) ; currentSize ++ ; } while ( currentSize > newSize ) { Path child = ( Path ) children . remove ( children . size ( ) - 1 ) ; workingPaths . remove ( child ) ; currentSize -- ; } return children ; }
tr	5	private Entry findEquiv ( Object subtree , Object key ) { if ( subtree == null ) return null ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , key ) ; int found = bin_srch_res & BIN_SEARCH_FOUND_MASK ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( found == BIN_SEARCH_FOUND ) return new Entry ( ary [ idx ] , ary [ idx + ( ary . length >> 1 ) ] ) ; else return null ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int comp_res = compare ( key , nkey ) ; if ( comp_res == 0 ) return node ; else if ( comp_res < 0 ) return findEquiv ( node . left , key ) ; else return findEquiv ( node . right , key ) ; } }
tr	5	public Model method578 ( int i , int j , int k , int l , int i1 , int j1 , int k1 ) { Model model = method581 ( i , k1 , j ) ; if ( model == null ) return null ; if ( aBoolean762 || aBoolean769 ) model = new Model ( aBoolean762 , aBoolean769 , model ) ; if ( aBoolean762 ) { int l1 = ( k + l + i1 + j1 ) / 4 ; for ( int i2 = 0 ; i2 < model . anInt1626 ; i2 ++ ) { int j2 = model . anIntArray1627 [ i2 ] ; int k2 = model . anIntArray1629 [ i2 ] ; int l2 = k + ( ( l - k ) * ( j2 + 64 ) ) / 128 ; int i3 = j1 + ( ( i1 - j1 ) * ( j2 + 64 ) ) / 128 ; int j3 = l2 + ( ( i3 - l2 ) * ( k2 + 64 ) ) / 128 ; model . anIntArray1628 [ i2 ] += j3 - l1 ; } model . method467 ( ) ; } return model ; }
tr	9X	private static void horizLeftRight ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int row = 0 ; row < 6 ; row ++ ) { for ( int col = 0 ; col < 4 ; col ++ ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 2 , row ) . getState ( ) == 0 ) ) { if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 1 ) ; } if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == player2Color ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } } } } }
tr	9X	private boolean checkBackDiagonal ( int j , int i , ConnectFourPiece [ ] [ ] m_Pieces ) { boolean gameWon = false ; int secondPieceDDiagonalColoumn = i - 1 ; int thirdPieceDDiagonalColoumn = i - 2 ; int fourthPieceDDiagonalColoumn = i - 3 ; int secondPieceDDiagonalRow = j + 1 ; int thirdPieceDDiagonalRow = j + 2 ; int fourthPieceDDiagonalRow = j + 3 ; if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == RED_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; } else if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == YELLOW_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; } gameWon = true ; } } } return gameWon ; }
tr	9X	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
tr	7	public void removeKey ( String var ) { boolean changed = false ; if ( this . props . containsKey ( var ) ) { this . props . remove ( var ) ; changed = true ; } Iterator < String > it = this . lines . listIterator ( ) ; while ( it . hasNext ( ) ) { String line = it . next ( ) ; if ( line . trim ( ) . length ( ) == 0 ) { continue ; } if ( line . charAt ( 0 ) == # ) { continue ; } if ( line . contains ( "=" ) ) { int delimPosition = line . indexOf ( = ) ; String key = line . substring ( 0 , delimPosition ) . trim ( ) ; if ( key . equals ( var ) ) { it . remove ( ) ; changed = true ; } } else { continue ; } } if ( changed ) { save ( ) ; } }
tr	0	public static void main ( String [ ] args ) { print ( 4 ) ; }
tr	9X	private static String dump ( Object thing ) { if ( thing == null ) return "null" ; else if ( thing == NO_ELEMENT ) return "NADA" ; else if ( thing instanceof EquivalentSet ) { ArrayList < Object > al = ( ( EquivalentSet ) thing ) . contents ; String res = "[" ; for ( int i = 0 , size = al . size ( ) ; i < size ; ++ i ) { if ( i > 0 ) res = res + "  " ; res = res + al . get ( i ) ; } return res + "]" ; } else if ( thing instanceof Object [ ] ) { StringBuffer str_buf = new StringBuffer ( "{" ) ; Object [ ] ary = ( Object [ ] ) thing ; for ( int i = 0 ; i < ary . length ; ++ i ) { str_buf . append ( dump ( ary [ i ] ) ) ; if ( i < ary . length - 1 ) str_buf . append ( "  " ) ; } str_buf . append ( "}" ) ; return str_buf . toString ( ) ; } else if ( thing instanceof Node ) { Node node = ( Node ) thing ; return "(" + node . size + "  " + dump ( node . element ) + ";\n" + indent ( dump ( node . left ) , "  " ) + " \n" + indent ( dump ( node . right ) , "  " ) + ")" ; } else return thing . toString ( ) ; }
tr	2	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
tr	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
tr	5	static int quadraticRoots ( final float a , final float b , final float c , float [ ] zeroes , final int off ) { int ret = off ; float t ; if ( a != 0f ) { final float dis = b * b - 4 * a * c ; if ( dis > 0f ) { final float sqrtDis = ( float ) Math . sqrt ( dis ) ; if ( b >= 0f ) { zeroes [ ret ++ ] = ( 2f * c ) / ( - b - sqrtDis ) ; zeroes [ ret ++ ] = ( - b - sqrtDis ) / ( 2f * a ) ; } else { zeroes [ ret ++ ] = ( - b + sqrtDis ) / ( 2f * a ) ; zeroes [ ret ++ ] = ( 2f * c ) / ( - b + sqrtDis ) ; } } else if ( dis == 0f ) { t = ( - b ) / ( 2f * a ) ; zeroes [ ret ++ ] = t ; } } else { if ( b != 0f ) { t = ( - c ) / b ; zeroes [ ret ++ ] = t ; } } return ret - off ; }
tr	2	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
tr	4	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
tr	5	public static void load ( Archive archive ) { Buffer stream = new Buffer ( archive . decompressFile ( "varbit.dat" ) ) ; int cacheSize = stream . getUnsignedLEShort ( ) ; if ( cache == null ) cache = new VarBit [ cacheSize ] ; for ( int j = 0 ; j < cacheSize ; j ++ ) { if ( cache [ j ] == null ) cache [ j ] = new VarBit ( ) ; cache [ j ] . loadDefinition ( stream ) ; if ( cache [ j ] . aBoolean651 ) Varp . cache [ cache [ j ] . configId ] . aBoolean713 = true ; } if ( stream . position != stream . buffer . length ) System . out . println ( "varbit load mismatch" ) ; }
tr	3	public int signum ( ) { if ( bigVal != null ) { return bigVal . signum ( ) ; } else { return val > 0 ? 1 : val < 0 ? - 1 : 0 ; } }
tr	8	public List < DimensionWrapper > getDimensionHierarchy ( String indicatorName , String keyFamilyId ) { if ( hierarchicalCodelists == null || hierarchicalCodelists . size ( ) <= 0 ) { return null ; } Dimension indDim = getIndicatorOrDataElementDimension ( keyFamilyId ) ; CodeList codelist = getCodeList ( indDim . getCodelistRef ( ) ) ; Code code = codelist . getCodeByDescription ( indicatorName ) ; if ( code == null ) { return null ; } HierarchicalCodelist hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES ) ; if ( hierarchicalCodelist == null ) { hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES_BACKWARDS_COMPATIBLE ) ; } Hierarchy hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY ) ; if ( hierarchy == null ) { hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY_BACKWARDS_COMPATIBLE ) ; if ( hierarchy == null ) { return null ; } } CodeRef codeRef = hierarchy . findCodeRef ( hierarchicalCodelist . getCodeListAlias ( indDim . getCodelistRef ( ) ) , code . getValue ( ) ) ; if ( codeRef == null ) { return null ; } List < DimensionWrapper > dimensionHierarchy ; if ( codeRef != null ) { dimensionHierarchy = constructDimensionHierarchy ( codeRef ) ; } else { dimensionHierarchy = new ArrayList < DimensionWrapper > ( ) ; } return dimensionHierarchy ; }
tr	8	protected static byte discoverPortal ( IShape shape1 , IShape shape2 ) { getOriginRayDirection ( shape1 , shape2 ) ; MinkowskiDifference . getMinSupport ( e1 , shape1 , shape2 , e0 . v ) ; if ( e1 . v . . ( e0 . v ) >= 0 ) return - 1 ; dir . setCross ( e0 . v , e1 . v ) ; if ( dir . isZero ( ) ) { return 2 ; } MinkowskiDifference . getMaxSupport ( e2 , shape1 , shape2 , dir ) ; if ( e2 . v . . ( dir ) <= 0 ) return - 1 ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; dir . setCross ( v1v0 , v2v0 ) ; if ( dir . . ( e0 . v ) > 0 ) { final Element e = e1 ; e1 = e2 ; e2 = e ; dir . invert ( ) ; Vector3f s = v1v0 ; v1v0 = v2v0 ; v2v0 = s ; } while ( true ) { MinkowskiDifference . getMaxSupport ( e3 , shape1 , shape2 , dir ) ; if ( e3 . v . . ( dir ) <= 0 ) return - 1 ; if ( temp . setCross ( e1 . v , e3 . v ) . . ( e0 . v ) < 0 ) { set ( e2 , e3 ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; } else if ( temp . setCross ( e3 . v , e2 . v ) . . ( e0 . v ) < 0 ) { set ( e1 , e3 ) ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; } else { return 0 ; } dir . setCross ( v1v0 , v2v0 ) ; } }
tr	6	private int processBNEInst ( BNE bne ) { String opCode = bne . getOpcode ( ) . name ( ) ; int instOrder = bne . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( bne . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( bne . getReg1 ( ) , bne ) ; boolean src2 = ! dataHaz . checkRAWHazard ( bne . getReg2 ( ) , bne ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( bne . getReg1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( bne . getReg2 ( ) . getId ( ) ) ; bne . getReg1 ( ) . setValue ( src1v . intValue ( ) ) ; bne . getReg2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + bne . getReg1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + bne . getReg2 ( ) . getId ( ) . name ( ) ) ; bne . clearRawHazard ( ) ; bne . setState ( State . READ ) ; if ( src1v . intValue ( ) != src2v . intValue ( ) ) { bne . setResult ( 5 ) ; } } else { bne . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( bne . getRawInst ( ) ) ; if ( ! src1 ) { src1n = bne . getReg1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = bne . getReg2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
tr	7	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location newLocation = findFood ( ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
tr	7	public String encode ( String plain ) { String key_u = key . toUpperCase ( ) ; String [ ] [ ] code_matrix = new String [ 4 ] [ 25 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { char cur_c = key_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } int pos = cur_c - A ; if ( pos > 8 ) { pos -- ; } for ( int j = 0 ; j < 25 ; j ++ ) { int cur_num = 25 * i + j + 1 ; String cur_str ; if ( cur_num == 100 ) { cur_str = "00" ; } else { cur_str = ( cur_num < 10 ? "0" : "" ) + cur_num ; } code_matrix [ i ] [ pos ] = cur_str ; if ( pos == 24 ) { pos = 0 ; } else { pos ++ ; } } } String cipher_text = get_c_text ( code_matrix , plain ) ; return cipher_text ; }
tr	2	@ Test public void testGet ( ) { for ( int i = 0 ; i < A . length ; ++ i ) { for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) { assertTrue ( matrixA . get ( i , j ) . equals ( A [ i ] [ j ] ) ) ; } } }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
tr	9X	@ Override public float [ ] getFloatData ( float [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { float [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new float [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) Utilities . UNSAFE . getInt ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ ( int ) i ] ; } } } return out ; } }
tr	1	public static String translate ( String fieldname ) { if ( fieldname == null ) fieldname = "" ; String key = String . format ( "Field.%s" , fieldname . toLowerCase ( ) ) ; String name = properties . getProperty ( key , fieldname ) ; return name ; }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	0	public PanelRenderer ( JTable table , TableCellRenderer renderer , TableCellEditor editor ) { this . table = table ; baseRenderer = renderer ; baseEditor = editor ; panel = new JPanel ( ) ; panel . setLayout ( new GridBagLayout ( ) ) ; }
tr	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
tr	9X	@ Override public TIPO_OBJETO get ( TIPO_OBJETO oBean ) throws Exception { class < TIPO_OBJETO > tipo = ( class < TIPO_OBJETO > ) ( ( ParameterizedType ) getClass ( ) . getGenericSuperclass ( ) ) . getActualTypeArguments ( ) [ 0 ] ; Method metodo_getId = tipo . getMethod ( "getId" ) ; Method metodo_setId = tipo . getMethod ( "setId" , Integer . class ) ; if ( ( Integer ) metodo_getId . invoke ( oBean ) > 0 ) { try { oMysql . conexion ( enumTipoConexion ) ; if ( ! oMysql . existsOne ( strTabla , ( Integer ) metodo_getId . invoke ( oBean ) ) ) { metodo_setId . invoke ( oBean , 0 ) ; } else { for ( Method method : tipo . getMethods ( ) ) { if ( ! method . getName ( ) . substring ( 3 ) . equalsIgnoreCase ( "id" ) ) { if ( method . getName ( ) . substring ( 0 , 3 ) . equalsIgnoreCase ( "set" ) ) { final class < ? > strTipoParamMetodoSet = method . getParameterTypes ( ) [ 0 ] ; String strValor = oMysql . getOne ( strTabla , method . getName ( ) . substring ( 3 ) . toLowerCase ( Locale . ENGLISH ) , ( Integer ) metodo_getId . invoke ( oBean ) ) ; if ( strValor != null ) { switch ( strTipoParamMetodoSet . getName ( ) ) { case "java.lang.Double" : method . invoke ( oBean , double . parseDouble ( strValor ) ) ; break ; case "java.lang.Integer" : method . invoke ( oBean , Integer . parseInt ( strValor ) ) ; break ; case "java.util.Date" : SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd" ) ; method . invoke ( oBean , format . parse ( strValor ) ) ; break ; default : method . invoke ( oBean , strValor ) ; break ; } } } } } } } catch ( Exception e ) { throw new Exception ( "GenericDao.get: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } } else { metodo_setId . invoke ( oBean , 0 ) ; } return oBean ; }
tr	2	private Expression expression0 ( ) throws RequiredTokenException { enterRule ( NonTerminal . EXPRESSION0 ) ; Expression lhs = expression1 ( ) ; if ( firstSetSatisfied ( NonTerminal . OP0 ) ) { Token op = null ; try { op = op0 ( ) ; lhs = Command . newExpression ( lhs , op , expression1 ( ) ) ; } catch ( FirstSetUnsatisfiedException e ) { lhs = new Error ( ( ( Command ) lhs ) . lineNumber ( ) , ( ( Command ) lhs ) . charPosition ( ) , String . format ( "First set unsatisfied for nonterminal of type \"%s\"." , e . Unsatisfied ) ) ; } } exitRule ( ) ; return lhs ; }
tr	8	public static boolean isWord ( int c ) { if ( c > 127 ) return true ; if ( c > 47 && c < 58 ) return true ; if ( c > 64 && c < 91 ) return true ; if ( c > 96 && c < 123 ) return true ; if ( c == _ ) return true ; return false ; }
tr	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	6	private ID3v2CommentFrameData extractCommentFrameData ( String id , boolean itunes ) { ID3v2FrameSet frameSet = frameSets . get ( id ) ; if ( frameSet != null ) { Iterator < ID3v2Frame > iterator = frameSet . getFrames ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) iterator . next ( ) ; ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; if ( itunes && ITUNES_COMMENT_DESCRIPTION . equals ( frameData . getDescription ( ) . toString ( ) ) ) { return frameData ; } else if ( ! itunes ) { return frameData ; } } catch ( InvalidDataException e ) { } } } return null ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	1	private boolean matchExact ( String expected , String actual ) { return matchMode == MatchMode . EXACT && actual . equals ( expected ) ; }
tr	0	public void setDateTimeValue ( Date dateTimeValue ) { this . dateTimeValue = dateTimeValue ; }
tr	0	public final boolean isRegistered ( BytesKey key ) { return map . containsKey ( key ) ; }
tr	6	public static void main ( String [ ] args ) { if ( args . length <= 0 ) { System . out . println ( "At least one arg (pebbler project) must be" + "specified" ) ; } String projectFileName = args [ 0 ] ; String nextFlag = args . length > 1 ? args [ 1 ] : "" ; boolean createBook = nextFlag . equals ( "--createBook" ) ? true : false ; File projectFile = new File ( projectFileName ) ; if ( ! projectFile . exists ( ) || ! projectFile . isFile ( ) ) { System . out . println ( "Couldn't find file: " + projectFile . getPath ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( "Getting file from: " + projectFile . getPath ( ) ) ; PebblerProject project = PebblerProject . fromJson ( silentRead ( projectFile ) ) ; File fullFile = new File ( projectFile . getAbsolutePath ( ) ) ; String fullPath = fullFile . getParentFile ( ) . getAbsolutePath ( ) ; project . compile ( fullPath ) ; if ( createBook ) { TypeSetter typeSetter = new TypeSetter ( project ) ; typeSetter . createBook ( fullPath ) ; } }
tr	9X	public OBJModel ( String fileName ) { positions = new ArrayList < Vector3f > ( ) ; texCoords = new ArrayList < Vector2f > ( ) ; normals = new ArrayList < Vector3f > ( ) ; indices = new ArrayList < OBJIndex > ( ) ; hasTexCoords = false ; hasNormals = false ; BufferedReader meshReader = null ; try { meshReader = new BufferedReader ( new FileReader ( fileName ) ) ; String line ; while ( ( line = meshReader . readLine ( ) ) != null ) { String [ ] tokens = line . split ( " " ) ; tokens = Util . removeEmptyStrings ( tokens ) ; if ( tokens . length == 0 || tokens [ 0 ] . equals ( "#" ) ) continue ; else if ( tokens [ 0 ] . equals ( "v" ) ) { positions . add ( new Vector3f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) , float . valueOf ( tokens [ 3 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "vt" ) ) { texCoords . add ( new Vector2f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "vn" ) ) { normals . add ( new Vector3f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) , float . valueOf ( tokens [ 3 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "f" ) ) { for ( int i = 0 ; i < tokens . length - 3 ; i ++ ) { indices . add ( parseOBJIndex ( tokens [ 1 ] ) ) ; indices . add ( parseOBJIndex ( tokens [ 2 + i ] ) ) ; indices . add ( parseOBJIndex ( tokens [ 3 + i ] ) ) ; } } } meshReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	1	public static byte [ ] decompress ( byte [ ] data ) throws IOException , DataFormatException { Inflater inflater = new Inflater ( ) ; inflater . setInput ( data ) ; inflater . finished ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputStream . write ( buffer , 0 , count ) ; } outputStream . close ( ) ; byte [ ] output = outputStream . toByteArray ( ) ; inflater . end ( ) ; return output ; }
tr	6	@ Override public boolean equals ( Object o ) { return o instanceof RectData ? this . x == ( ( RectData ) o ) . x && this . y == ( ( RectData ) o ) . y && this . u == ( ( RectData ) o ) . u && this . v == ( ( RectData ) o ) . v && this . w == ( ( RectData ) o ) . w && this . h == ( ( RectData ) o ) . h : false ; }
tr	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	2	protected void execute ( ) { if ( shooter . left . getD ( ) - accuracy > pos ) { shooter . set ( - holdVel ) ; } else if ( shooter . left . getD ( ) + accuracy < pos ) { shooter . set ( holdVel ) ; } else { shooter . set ( 0.0 ) ; } }
tr	6	public T [ ] quicksort ( T [ ] array , int low , int high ) { int i = low ; int j = high ; T pivot = array [ low + ( high - low ) / 2 ] ; while ( i < j ) { while ( array [ i ] . compareTo ( pivot ) < 0 ) { i ++ ; } while ( array [ j ] . compareTo ( pivot ) > 0 ) { j -- ; } if ( i <= j ) { swap ( array , i , j ) ; i ++ ; j -- ; } } if ( low < j ) { quicksort ( array , low , j ) ; } if ( i < high ) { quicksort ( array , i , high ) ; } return array ; }
tr	4	private ArrayList < String > RemoveStopWords ( ArrayList < String > textSnippets ) { String regex = "" , regexCaps = "" ; ArrayList < String > rem ; String path = System . getProperty ( "user.dir" ) ; File f = new File ( path , Settings . get ( "STOPWORD_LIST_PATH_SEARCH" ) ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String line = "" ; line = br . readLine ( ) ; while ( line != null ) { regexCaps = line . substring ( 0 , 1 ) . toUpperCase ( ) + line . substring ( 1 ) ; regex = " " + line + " | " + regexCaps + " " ; rem = new ArrayList < String > ( ) ; for ( String temp : textSnippets ) { temp = " " + temp + " " ; temp = temp . replaceAll ( regex , " " ) ; rem . add ( temp . trim ( ) ) ; } textSnippets = rem ; line = br . readLine ( ) ; } br . close ( ) ; } catch ( FileNotFoundException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } catch ( IOException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } return textSnippets ; }
tr	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
tr	8	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
tr	3	public static void filledCircle ( double x , double y , double r ) { if ( r < 0 ) throw new IllegalArgumentException ( "circle radius must be nonnegative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * r ) ; double hs = factorY ( 2 * r ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
tr	5	private static int decode ( String rgb , int start , int end ) { try { final int len = rgb . length ( ) ; if ( start >= len ) return 0 ; if ( end >= len ) end = len ; final int v = Integer . parseInt ( rgb . substring ( start , end ) , 16 ) ; return v > 255 ? 255 : v < 0 ? 0 : v ; } catch ( NumberFormatException ex ) { return 0 ; } }
tr	4	public boolean isWalkable ( ) { return ( tileType . equals ( Empty ) || tileType . equals ( OpenedDoor ) || tileType . equals ( StairsUp ) || tileType . equals ( StairsDown ) ) && tileContent . stream ( ) . filter ( p -> p . isOccupiesWholeTile ( ) ) . count ( ) <= 0 ; }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	8	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
tr	8	private boolean isScrambleCore ( String s1 , String s2 ) { boolean result = false ; List < String > key = new ArrayList < String > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String s11 = s1 . substring ( 0 , i + 1 ) ; String s12 = s1 . substring ( i + 1 ) ; String s21 = s2 . substring ( 0 , i + 1 ) ; String s22 = s2 . substring ( i + 1 ) ; if ( isScrambleCore ( s11 , s21 ) && isScrambleCore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isScrambleCore ( s11 , s22 ) && isScrambleCore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	1	public void print ( TreeNode root ) { if ( root == null ) { System . out . print ( " # " ) ; return ; } else { System . out . print ( " " + root . val + " " ) ; } print ( root . left ) ; print ( root . right ) ; }
tr	9X	private void paint ( Display display , GC gc ) { Color white = colors . getWhite ( ) ; Color black = colors . getBlack ( ) ; Color grey30 = colors . getGrey30 ( ) ; Color grey50 = colors . getGrey50 ( ) ; Color grey80 = colors . getGrey80 ( ) ; Color grey120 = colors . getGrey120 ( ) ; int clientWidth = nWhiteKeys * keyWidth + 10 ; int leftMargin = ( getWidget ( ) . getBounds ( ) . width - clientWidth - 20 ) / 2 + 5 ; Pitch pitch ; pitch = new Pitch ( "a0" ) ; gc . setBackground ( grey30 ) ; gc . fillRectangle ( leftMargin - borderWidth , topMargin - borderWidth - 1 , nWhiteKeys * keyWidth + borderWidth * 2 + 1 , keyHeight + borderWidth + 2 ) ; gc . setBackground ( grey30 ) ; gc . setForeground ( grey120 ) ; gc . fillGradientRectangle ( leftMargin - borderWidth + 1 , topMargin - borderWidth , nWhiteKeys * keyWidth + borderWidth * 2 - 1 , topMargin , true ) ; for ( int x = 0 ; x < nWhiteKeys ; x ++ ) { Color selected = getSelectedColor ( pitch ) ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : white ) ; gc . fillRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; gc . drawRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; pitch = pitch . nextSemitone ( ) ; if ( x % 7 != 1 && x % 7 != 4 ) { pitch = pitch . nextSemitone ( ) ; } } pitch = new Pitch ( "a#0" ) ; for ( int x = 0 ; x < nWhiteKeys - 1 ; x ++ ) { if ( x % 7 == 1 || x % 7 == 4 ) { pitch = pitch . nextSemitone ( ) ; continue ; } Color selected = getSelectedColor ( pitch ) ; int left = leftMargin + keyWidth * x + keyWidth / 2 + blackMargin ; int width = keyWidth - blackMargin * 2 + 1 ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : black ) ; gc . fillRectangle ( left , topMargin , width , blackKeyHeight ) ; gc . drawRectangle ( left , topMargin , width , blackKeyHeight ) ; if ( selected == null ) { gc . setBackground ( grey50 ) ; gc . fillRectangle ( left + 1 , topMargin + blackKeyHeight - 5 , width - 1 , 5 ) ; gc . setForeground ( grey80 ) ; gc . drawLine ( left + 1 , topMargin + blackKeyHeight - 5 , left + width - 1 , topMargin + blackKeyHeight - 5 ) ; } pitch = pitch . nextSemitone ( ) ; pitch = pitch . nextSemitone ( ) ; } }
tr	1	@ Override public boolean equals ( Object obj ) { try { GitlabCommitStatus commitObj = ( GitlabCommitStatus ) obj ; return ( this . getId ( ) . compareTo ( commitObj . getId ( ) ) == 0 ) ; } catch ( ClassCastException e ) { return false ; } }
tr	5	public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof long ) { this . put ( key , ( ( long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof double ) { this . put ( key , ( ( double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof float ) { this . put ( key , ( ( float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable to increment [" + quote ( key ) + "]." ) ; } return this ; }
tr	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
tr	5	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	8	public JPanel addNumberButtons ( JTextField DispField ) { final JTextField Field = DispField ; JPanel ButtonPanel = new JPanel ( ) ; ButtonPanel . setLayout ( new GridLayout ( 4 , 3 ) ) ; ButtonPanel . setPreferredSize ( new Dimension ( 500 , 320 ) ) ; ButtonPanel . setMaximumSize ( new Dimension ( 500 , 500 ) ) ; JButton [ ] NumButtons = new JButton [ 10 ] ; JButton StarButtons = new JButton ( "*" ) ; StarButtons . setFont ( NumButtonsFont ) ; StarButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; StarButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "*" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; JButton latticeButtons = new JButton ( "#" ) ; latticeButtons . setFont ( NumButtonsFont ) ; latticeButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; latticeButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "#" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) { final String name = "" + i ; NumButtons [ i ] = new JButton ( "" + i ) ; NumButtons [ i ] . setFont ( NumButtonsFont ) ; NumButtons [ i ] . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; NumButtons [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + name ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; } for ( int i = 1 ; i <= 9 ; i ++ ) { ButtonPanel . add ( NumButtons [ i ] ) ; } ButtonPanel . add ( StarButtons ) ; ButtonPanel . add ( NumButtons [ 0 ] ) ; ButtonPanel . add ( latticeButtons ) ; return ButtonPanel ; }
tr	0	public void setGame ( Game game ) { this . game = game ; }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	5	@ Override public synchronized void onPlayerMove ( final Board b , int playerNr , int move ) { if ( playerNr == getNumber ( ) ) return ; if ( root . children . isEmpty ( ) ) throw new IllegalStateException ( "root has no children" ) ; for ( int i = 0 ; i < root . children . size ( ) ; i ++ ) { Node child = root . children . get ( i ) ; if ( child . move == move ) { child . parent . apply ( rootBoard ) ; child . parent = null ; root = child ; child . apply ( rootBoard ) ; if ( ! rootBoard . equals ( b ) ) { rootBoard . print ( ) ; b . print ( ) ; throw new IllegalStateException ( "boards do not match" ) ; } return ; } } throw new IllegalStateException ( "cannot move to the correct state" ) ; }
tr	5	public void changeSupplier ( String id , String newSupplier ) { String oldSupplier = getSupplierName ( id ) ; if ( oldSupplier == newSupplier ) { return ; } if ( oldSupplier == null ) { addItem ( id , newSupplier ) ; } if ( suppliers . indexOf ( oldSupplier ) > - 1 ) { int oindex = suppliers . indexOf ( oldSupplier ) ; if ( supplierItems . get ( oindex ) . indexOf ( id ) > - 1 ) { int nindex = supplierItems . get ( oindex ) . indexOf ( id ) ; int addIndex = suppliers . indexOf ( newSupplier ) ; supplierItems . get ( oindex ) . remove ( nindex ) ; if ( addIndex > - 1 ) { supplierItems . get ( addIndex ) . add ( id ) ; } } } }
tr	1	@ Override public boolean equals ( Object obj ) { if ( obj instanceof GRGProteinNode ) { GRGProteinNode other = ( GRGProteinNode ) obj ; return this . node . equals ( other . node ) ; } else { return false ; } }
tr	2	public static void onReturn ( final P1 < String > p1 ) { ThreadUtil . runStrong ( new P0 ( ) { public void e ( ) { while ( true ) { try { String readLine = readLine ( ) ; p1 . e ( readLine ) ; } catch ( Exception e1 ) { return ; } } } } ) ; }
tr	2	public static long copy ( InputStream input , OutputStream output , Action1 < long > progressCallback ) throws IOException { byte [ ] buffer = new byte [ BUFFER_SIZE ] ; long count = 0 ; int n ; while ( ( n = input . read ( buffer ) ) != - 1 ) { output . write ( buffer , 0 , n ) ; count += n ; if ( progressCallback != null ) progressCallback . call ( count ) ; } return count ; }
tr	8	@ Override public void computePerformanceMeasures ( ) throws InternalErrorException { totalTimer . start ( ) ; BigRational [ ] X = new BigRational [ qnm . R ] ; BigRational [ ] [ ] Q = new BigRational [ qnm . M ] [ qnm . R ] ; if ( lastG [ 0 ] . isUndefined ( ) ) { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . M ; i ++ ) { for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) + i + 1 ] . isUndefined ( ) ) { Q [ i ] [ r ] = qnm . getDemandAsBigRational ( i , r ) . multiply ( lastG [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ i + 1 ] . isUndefined ( ) ) { Q [ i ] [ qnm . R - 1 ] = qnm . getDemandAsBigRational ( i , qnm . R - 1 ) . multiply ( prevG [ i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) ] . isUndefined ( ) ) { X [ r ] = lastG [ sz * ( r + 1 ) ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ 0 ] . isUndefined ( ) ) { X [ qnm . R - 1 ] = prevG [ 0 ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } totalTimer . pause ( ) ; qnm . setPerformanceMeasures ( Q , X ) ; }
tr	9X	private Description deserialise ( SingleDescriptionTriples buffer , List < Description > additional ) throws DeserialisationException { if ( buffer . hasBeenDeserialised ( ) ) { return buffer . getDeserialisation ( ) ; } URI type = getSpecificType ( buffer ) ; Description description ; if ( type == null ) { type = getImpliedType ( buffer . getSubject ( ) ) ; if ( type == null ) { return null ; } } description = ProvConstructer . create ( type , buffer . getIdentifier ( ) ) ; buffer . setDeserialisation ( description ) ; for ( URI predicate : buffer . getPredicates ( ) ) { if ( ! predicate . equals ( RDF . typeURI ( ) ) ) { if ( Term . isProvTerm ( predicate ) ) { deserialise ( predicate , buffer , description , additional ) ; } else { if ( description instanceof AttributeHolder ) { for ( Literal object : buffer . getLiteralObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object . _value ) ; } for ( URI object : buffer . getURIObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object ) ; } } } } } return description ; }
tr	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : System . out . println ( "Excellent" ) ; break ; case B : System . out . println ( "Good" ) ; break ; case C : System . out . println ( "So so" ) ; break ; case D : System . out . println ( "Fails" ) ; break ; case F : System . out . println ( "Get lost" ) ; break ; default : System . out . println ( "Invalid" ) ; break ; } }
tr	4	public synchronized boolean doCresciDinosauro ( String token , String idDinosauro ) throws InvalidTokenException , GenericDinosauroException { Coord coordToRemove = null ; try { if ( getPlayerByToken ( token ) . getRazza ( ) . existsDinosauroWithId ( idDinosauro ) ) { coordToRemove = getPlayerByToken ( token ) . getRazza ( ) . getDinosauroById ( idDinosauro ) . getCoord ( ) ; getPlayerByToken ( token ) . getRazza ( ) . cresciDinosauro ( idDinosauro ) ; return true ; } return false ; } catch ( InvalidTokenException e ) { throw new InvalidTokenException ( ) ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) { getMappa ( ) . rimuoviIlDinosauroDallaCella ( coordToRemove ) ; } throw new GenericDinosauroException ( e . getMessage ( ) ) ; } }
tr	8	public List < HackResult > grok ( Reader reader ) throws IOException { long t0 = System . currentTimeMillis ( ) ; _HackContainer o = new _HackContainer ( ) ; Type t = new TypeToken < _HackContainer > ( ) { } . getType ( ) ; o = GSON . fromJson ( reader , t ) ; if ( o == null ) throw new IOException ( "GSON returned null!" ) ; L . info ( "Claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new IOException ( "GSON did not find objects!" ) ; List < HackResult > res = new ArrayList < HackResult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int canGetUltraCount = 0 ; for ( _HackRow r : o . rows ) { ++ count ; HackResult h = r . doc ; h . sourceLine = count ; if ( h . resos == null || h . hacker == null ) { L . warn ( "Skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( L . isTraceEnabled ( ) ) L . trace ( String . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hasCanGetUltra ( ) ) canGetUltraCount ++ ; total += h . getItemCount ( ) ; res . add ( h ) ; } long t1 = System . currentTimeMillis ( ) ; L . info ( "*** " + res . size ( ) + " hacks for " + total + " items  canGetUltraCount=" + canGetUltraCount + "  lengthCheck=" + ( res . size ( ) != o . total_rows ? "WARNING" : "OK" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	7	protected void notifyReceivedAck ( MqttAck ack ) throws MqttException { final String methodName = "notifyReceivedAck" ; this . lastInboundActivity = System . currentTimeMillis ( ) ; log . fine ( className , methodName , "627" , new Object [ ] { new Integer ( ack . getMessageId ( ) ) , ack } ) ; MqttToken token = tokenStore . getToken ( ack ) ; MqttException mex = null ; if ( ack instanceof MqttPubRec ) { MqttPubRel rel = new MqttPubRel ( ( MqttPubRec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof MqttPubAck || ack instanceof MqttPubComp ) { notifyResult ( ack , token , mex ) ; } else if ( ack instanceof MqttPingResp ) { pingOutstanding = false ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; } else if ( ack instanceof MqttConnack ) { int rc = ( ( MqttConnack ) ack ) . getReturnCode ( ) ; if ( rc == 0 ) { synchronized ( queueLock ) { if ( cleanSession ) { clearState ( ) ; tokenStore . saveToken ( token , ack ) ; } inFlightPubRels = 0 ; actualInFlight = 0 ; restoreInflightMessages ( ) ; connected ( ) ; } } else { mex = ExceptionHelper . createMqttException ( rc ) ; throw mex ; } clientComms . connectComplete ( ( MqttConnack ) ack , mex ) ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; synchronized ( queueLock ) { queueLock . notifyAll ( ) ; } } else { notifyResult ( ack , token , mex ) ; releaseMessageId ( ack . getMessageId ( ) ) ; tokenStore . removeToken ( ack ) ; } checkQuiesceLock ( ) ; }
tr	2	@ Override public void addStart ( int elem ) { if ( size + 1 >= capacity ) { resize ( ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { array [ i + 1 ] = array [ i ] ; } array [ 0 ] = elem ; ++ size ; }
tr	4	public Type parse ( int i ) { switch ( i ) { case 1 : return HASHTAG ; case 2 : return USER ; case 3 : return EMOTICON ; case 4 : return URL ; } return OTHER ; }
tr	8	public boolean hasAdjacentEmptyTile ( JavaCell cell ) { int x = cell . getX ( ) ; int y = cell . getY ( ) ; if ( x + 1 == 13 ) { if ( map [ 13 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( x - 1 == 0 ) { if ( map [ 0 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y + 1 == 13 ) { if ( map [ x ] [ 13 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y - 1 == 0 ) { if ( map [ x ] [ 0 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } return false ; }
tr	3	public User Authenticate ( String username , String password ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM users WHERE username = \"" + username + "\"" ) ; try { if ( rs . next ( ) ) { password = GenerateHash ( password ) ; if ( rs . getString ( "password" ) . equals ( password ) ) { UserFactory factory = UserFactory . sharedInstance ( ) ; User user = factory . getUserFromID ( rs . getInt ( "id" ) ) ; return user ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return null ; }
tr	4	@ Override public synchronized boolean add ( Plugin plugin ) { Iterator < Plugin > iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( iter . next ( ) . getName ( ) . equals ( plugin . getName ( ) ) ) { return false ; } } plugin . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( "plugin_files_compared" ) ) { int pos = PluginList . this . indexOf ( evt . getNewValue ( ) ) ; propertyChange . firePropertyChange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messageDatabase != null ) { plugin . setMessageDatabase ( messageDatabase ) ; } return super . add ( plugin ) ; }
tr	3	public void update ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	8	@ SuppressWarnings ( { "unchecked" } ) public static < J , K , V > Map < J , Map < K , V >> generateComplexMap ( class < J > jType , class < K > keyType , class < V > valueType ) { Random random = new Random ( 987654321 ) ; Map < J , Map < K , V >> complexMap = new HashMap < J , Map < K , V >> ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { J family = null ; if ( jType == String . class ) { family = ( J ) String . valueOf ( random . nextInt ( ) ) ; } else if ( jType == Integer . class ) { family = ( J ) Integer . valueOf ( random . nextInt ( ) ) ; } else if ( jType == long . class ) { family = ( J ) long . valueOf ( random . nextLong ( ) ) ; } else if ( jType == double . class ) { family = ( J ) double . valueOf ( random . nextDouble ( ) ) ; } else if ( jType == byte [ ] . class ) { byte [ ] bytes = Bytes . toBytes ( random . nextInt ( ) ) ; family = ( J ) bytes ; } else if ( jType == float . class ) { family = ( J ) float . valueOf ( random . nextFloat ( ) ) ; } else if ( jType == boolean . class ) { family = ( J ) boolean . valueOf ( random . nextBoolean ( ) ) ; } Map < K , V > map = generateMapField ( keyType , valueType ) ; complexMap . put ( family , map ) ; } return complexMap ; }
tr	0	public void incrementNodeQuantity ( int increment ) { nodeQuantity += increment ; }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	4	public void print ( GroupedWriter fout ) { super . print ( fout ) ; fout . print ( "alphabet " ) ; fout . printlnGroup ( alphabet ) ; if ( guard != null && guard . length ( ) > 0 ) { fout . print ( "guard " ) ; fout . printlnGroup ( guard ) ; } if ( clocksToReset != null && clocksToReset . length > 0 ) { fout . print ( "clocksToReset " ) ; fout . printlnGroup ( Arrays . toString ( clocksToReset ) ) ; } fout . print ( "offset " ) ; fout . printlnGroup ( double . toString ( offset_theta ) ) ; }
tr	9X	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	6	public static TypedObject parseObject ( String type , String value ) throws ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( type . equals ( "int" ) ) { return new TypedObject ( Integer . class , Integer . parseInt ( value ) ) ; } if ( type . equals ( "float" ) ) { return new TypedObject ( float . class , float . parseFloat ( value ) ) ; } if ( type . equals ( "long" ) ) { return new TypedObject ( long . class , long . parseLong ( value ) ) ; } if ( type . equals ( "double" ) ) { return new TypedObject ( double . class , double . parseDouble ( value ) ) ; } if ( type . equals ( "boolean" ) ) { return new TypedObject ( boolean . class , boolean . valueOf ( value ) ) ; } type = canonicalize ( type ) ; class c = class . forName ( type ) ; Method m = null ; try { m = c . getMethod ( "valueOf" , String . class ) ; } catch ( NoSuchMethodException e ) { return new TypedObject ( String . class , value ) ; } return new TypedObject ( c , m . invoke ( null , value ) ) ; }
tr	8	static int entrance ( List < Point > points , int k ) { int size = points . size ( ) ; Map < String , Integer > indexHash = new HashMap < > ( ) ; Map < String , Point > pointHash = new HashMap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Point p = points . get ( i ) ; indexHash . put ( p . x + " " + p . y , i ) ; pointHash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { Point from = points . get ( i ) ; int max = 0 ; Set < Point > rangePoints = rangePonints ( from , k , pointHash ) ; for ( Point p : rangePoints ) { Integer index = indexHash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxPathValue > max ) { max = p . maxPathValue ; } } from . maxPathValue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxPathValue ; } return - 1 ; }
tr	9X	public ArrayList < ArrayList < Integer >> zigzagLevelOrder ( TreeNode root ) { ArrayList < ArrayList < Integer >> out = new ArrayList < ArrayList < Integer >> ( ) ; if ( root == null ) return out ; ValPack p = new ValPack ( ) ; p . node = root ; p . level = 0 ; LinkedList < ValPack > nodeList = new LinkedList < ValPack > ( ) ; LinkedList < ValPack > list = new LinkedList < ValPack > ( ) ; nodeList . addLast ( p ) ; int curLevel = 0 ; while ( nodeList . size ( ) != 0 ) { p = nodeList . removeFirst ( ) ; if ( p . level != curLevel ) { ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; list = new LinkedList < ValPack > ( ) ; curLevel = p . level ; } list . addLast ( p ) ; if ( p . node . left != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . left ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } if ( p . node . right != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . right ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } } ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; return out ; }
tr	5	public int [ ] getIntArrayFileArgument ( String name , int start , int stop , boolean required ) { if ( M . containsKey ( name ) ) { String [ ] content = readFileContents ( M . get ( name ) ) ; if ( stop > content . length - 1 ) { if ( stop != Integer . MAX_VALUE ) { System . err . println ( "Warning requested array position does not exist" ) ; } stop = content . length - 1 ; } int [ ] res = new int [ ( stop - start ) + 1 ] ; for ( int i = start ; i <= stop ; i ++ ) { res [ i - start ] = Integer . parseInt ( content [ i ] ) ; } return res ; } else { if ( required ) { argumentMissing ( name ) ; } } return null ; }
tr	2	public void fireModelPagesJaukesChanged ( int i_typeChange ) { I_ModelPagesJaukesListener [ ] listenerModelPagesJaukes = ( I_ModelPagesJaukesListener [ ] ) listeners . getListeners ( I_ModelPagesJaukesListener . class ) ; for ( I_ModelPagesJaukesListener listener : listenerModelPagesJaukes ) { switch ( i_typeChange ) { case 0 : listener . criteriaPagesJaukesChange ( ) ; break ; default : System . err . println ( "ModelPagesJaukes.java - Erreur fonction criteriaPagesJaukesChange" ) ; break ; } } }
tr	7	public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( DB_URL , USER , PASS ) ; stmt = conn . createStatement ( ) ; String sql ; sql = "SELECT * FROM Transport" ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; System . out . print ( "ID: " + id ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se2 ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } }
tr	9X	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	4	public static void registerToRmi ( ) { try { NameNodeSlaveImpl slave = new NameNodeSlaveImpl ( ) ; String local_Ipaddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; String slaveName = SystemConstants . getConfig ( SystemConstants . NAMENODE_SLAVE_SERVICE ) ; String name = slaveName + "_" + getIdentifier ( ) ; String bindName = "rmi://" + local_Ipaddress + ":" + portNumber + "/" + name ; System . out . println ( "Registering NameNodeSlave as : " + bindName ) ; Naming . rebind ( bindName , slave ) ; System . out . println ( "NameNodeSlaveImpl: Ready..." ) ; } catch ( RemoteException e ) { System . out . println ( "Error while accessing the remote object check on the RMI." ) ; System . exit ( 0 ) ; } catch ( UnknownHostException e ) { System . out . println ( "Error while accessing the RMI  please retry" ) ; System . exit ( 0 ) ; } catch ( MalformedURLException e ) { System . out . println ( "Error while binding the slave  please retry." ) ; System . exit ( 0 ) ; } catch ( AccessControlException e ) { System . out . println ( "Error with the Access control  check the policy." ) ; System . exit ( 0 ) ; } }
tr	1	@ Override public MDDVariable getVariableForKey ( Object key ) { MDDVariable var = store . getVariableForKey ( key ) ; int idx = store2custom [ var . order ] ; if ( idx < 0 ) { return null ; } return var ; }
tr	6	public Geometry makePath ( double [ ] [ ] Pn , int nP ) { if ( nP == this . nP && same ( Pn , this . Pn ) ) return this ; if ( this . Pn == null || this . Pn . length != Pn . length ) this . Pn = new double [ Pn . length ] [ 3 ] ; for ( int n = 0 ; n < Pn . length ; n ++ ) for ( int k = 0 ; k < Pn [ n ] . length ; k ++ ) this . Pn [ n ] [ k ] = Pn [ n ] [ k ] ; return makePath ( resample ( Pn , nP ) ) ; }
tr	9X	public static ArrayList < ArrayList < Integer >> fourSum ( int [ ] num , int target ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; Arrays . sort ( num ) ; for ( int i = 0 ; i <= num . length - 4 ; i ++ ) { if ( i > 0 && num [ i ] == num [ i - 1 ] ) continue ; for ( int j = i + 1 ; j <= num . length - 3 ; j ++ ) { if ( j > i + 1 && num [ j ] == num [ j - 1 ] ) continue ; int l = j + 1 ; int r = num . length - 1 ; while ( l < r ) { int sum = num [ i ] + num [ j ] + num [ l ] + num [ r ] - target ; if ( sum > 0 ) { r -- ; } else if ( sum < 0 ) { l ++ ; } else { ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; newList . add ( num [ i ] ) ; newList . add ( num [ j ] ) ; newList . add ( num [ l ] ) ; newList . add ( num [ r ] ) ; result . add ( newList ) ; l ++ ; r -- ; while ( l < r && num [ l ] == num [ l - 1 ] ) { l ++ ; } while ( l < r && num [ r ] == num [ r + 1 ] ) { r -- ; } } } } } return result ; }
tr	5	public static void main ( String [ ] args ) { init ( ) ; if ( args . length < 2 ) { System . err . println ( "Expected args: <cmd> <config_file> ....\n" + "\t cmd = create  compare" ) ; System . exit ( 1 ) ; } cmd = args [ 0 ] . toLowerCase ( ) ; String configFile = args [ 1 ] ; try { initVSL ( configFile ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } Integer cmdint = ( Integer ) cmds . get ( cmd ) ; if ( cmdint == null ) { System . err . println ( "Expected args: <cmd> <dbfile> ....\n" + "\t cmd = create  compare  list  read" ) ; System . exit ( 1 ) ; } switch ( cmdint ) { case 1 : create ( args ) ; break ; case 3 : compare ( args ) ; break ; } System . exit ( 0 ) ; }
tr	6	public void run ( ) { String message ; LinkedList < Stockage . Machine > servers = Donnees . getAllServeurs ( ) ; servers . add ( Global . MYSELF ) ; boolean continuer = true ; while ( continuer ) { message = new String ( ) ; while ( message . length ( ) < Global . BUFFER_LENGTH / 4 && ! servers . isEmpty ( ) ) { Machine m = servers . pop ( ) ; message += Message . BEGIN + " " + m . ipAdresse + " " + m . port + " " ; } if ( servers . isEmpty ( ) ) { message += Message . END_ENVOI + " " ; continuer = false ; } try { s . write ( Utilitaires . stringToBuffer ( message ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { s . close ( ) ; } catch ( IOException e ) { } RelationsPubliques . BroadcastAll . broadcastTCP ( Message . NEW_SERVER + " " + s . socket ( ) . getInetAddress ( ) . getHostAddress ( ) + " " + ( s . socket ( ) . getPort ( ) - 3 ) + " #" , Donnees . getAllServeurs ( ) ) ; Donnees . putServer ( new Machine ( s . socket ( ) . getInetAddress ( ) . getHostAddress ( ) , s . socket ( ) . getPort ( ) - 3 ) ) ; Donnees . printServerList ( ) ; }
tr	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
tr	8	@ Override public boolean equals ( Object cidades ) { if ( cidades == null ) { return false ; } if ( getClass ( ) != cidades . getClass ( ) ) { return false ; } final Cidades other = ( Cidades ) cidades ; if ( ( this . nome == null ) ? ( other . nome != null ) : ! this . nome . equals ( other . nome ) ) { return false ; } if ( ( this . uf == null ) ? ( other . uf != null ) : ! this . uf . equals ( other . uf ) ) { return false ; } if ( ( this . ddd == null ) ? ( other . ddd != null ) : ! this . ddd . equals ( other . ddd ) ) { return false ; } return true ; }
tr	9X	public void addStaffInfo ( Vector < StaffInfo > staff , JTextField [ ] staffTF , JList positionList , JList qualificationList , String hospitalList , JTable table ) { DB . db . openConnection ( ) ; try { int posid = - 1 ; int qualid = - 1 ; int hospId = - 1 ; String [ ] tmp = new String [ staffTF . length ] ; for ( int i = 0 ; i < staffTF . length ; i ++ ) { tmp [ i ] = staffTF [ i ] . getText ( ) ; } if ( positionList == null || qualificationList == null ) { throw new Exception ( ) ; } String login = JOptionPane . showInputDialog ( "Enter desired login" ) ; String password = null ; JPasswordField passwordField = new JPasswordField ( ) ; passwordField . setEchoChar ( * ) ; Object [ ] obj = { "Please enter the password:\n\n" , passwordField } ; Object stringArray [ ] = { "OK" , "Cancel" } ; if ( JOptionPane . showOptionDialog ( null , obj , "Desired password" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , stringArray , obj ) == JOptionPane . YES_OPTION ) { password = new String ( passwordField . getPassword ( ) ) ; } ResultSet rs = DB . db . position ( positionList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { posid = rs . getInt ( "id" ) ; } rs = DB . db . qualification ( qualificationList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { qualid = rs . getInt ( "id" ) ; } Auth t = new Auth ( login , password ) ; DB . db . addStaff ( tmp , qualid , posid , t . getLogin ( ) , t . getPasswHash ( ) ) ; DB . db . close ( ) ; staff . removeAllElements ( ) ; this . fillStaff ( ( Vector < T > ) staff ) ; rs = ( ResultSet ) DB . db . hospital ( hospitalList ) ; while ( rs . next ( ) ) { hospId = rs . getInt ( "id" ) ; } for ( int i = 0 ; i < 7 ; i ++ ) { DB . db . editStaffHospitalSchedual ( staff . lastElement ( ) . getId ( ) , hospId , table . getValueAt ( i , 0 ) , table . getValueAt ( i , 1 ) , table . getValueAt ( i , 2 ) ) ; } DB . db . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } }
tr	8	private void bfs ( State s ) { s . id = - 1 ; Loc f = map . finish ; int counter = 0 ; LinkedList < Node > frontier = new LinkedList < Node > ( ) ; Set < State > explored = new HashSet < State > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( s , null , 0 ) ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state , f ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } System . out . println ( "found goal!" ) ; System . out . println ( "moves: " + solution . size ( ) ) ; mSolutions . addAll ( solution ) ; return ; } explored . add ( current . state ) ; if ( counter % 5000 == 0 ) { System . out . print ( "\n" ) ; } ; if ( counter % 50 == 0 ) { System . out . print ( "." ) ; } ; ArrayList < State > possibles = getMovesCorrectlyPlease ( current . state ) ; for ( int i = 0 ; i < possibles . size ( ) ; i ++ ) { State possib = possibles . get ( i ) ; if ( ! explored . contains ( possib ) ) { frontier . addLast ( new Node ( possib , current , current . distance + 1 ) ) ; } } counter ++ ; } if ( solution . isEmpty ( ) ) { System . out . println ( "FAILED TO FIND SOLUTION" ) ; } }
tr	5	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	9X	public static int heading ( double longFrom , double latFrom , double longTo , double latTo ) { double latDiff = latTo - latFrom ; double longDiff = longTo - longFrom ; latDiff *= 110828.28 ; longDiff *= 97862.52 ; double angle ; int quadrant ; if ( longDiff == 0 ) angle = 0 ; else { if ( latDiff < 0 && longDiff < 0 ) quadrant = 3 ; else if ( latDiff < 0 && longDiff > 0 ) quadrant = 2 ; else if ( latDiff >= 0 && longDiff < 0 ) quadrant = 4 ; else quadrant = 1 ; latDiff = Math . abs ( latDiff ) ; longDiff = Math . abs ( longDiff ) ; angle = Math . atan ( latDiff / longDiff ) ; angle *= 180 / ( Math . PI ) ; switch ( quadrant ) { case 1 : angle = 90 - angle ; break ; case 2 : angle = 90 + angle ; break ; case 3 : angle = 270 - angle ; break ; case 4 : angle = 270 + angle ; break ; } } return ( int ) angle ; }
tr	5	public static Integer createOfficeObject ( Integer OFFICE_OBJECT_TYPE_ID ) { Integer id = getUniqueId ( ) ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , id ) ; ps . setString ( 2 , "" ) ; ps . setInt ( 3 , OFFICE_OBJECT_TYPE_ID ) ; ps . setInt ( 4 , OfficeObject . ALL_IS_OK ) ; ps . executeUpdate ( ) ; } catch ( MySQLIntegrityConstraintViolationException e ) { e . printStackTrace ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return id ; }
tr	2	boolean addPropagate ( Constraint c , int mark ) { List < Constraint > todo = new ArrayList < Constraint > ( ) ; todo . add ( c ) ; while ( todo . size ( ) > 0 ) { Constraint d = todo . remove ( todo . size ( ) - 1 ) ; if ( d . output ( ) . mark == mark ) { incrementalRemove ( c ) ; return false ; } d . recalculate ( ) ; addConstraintsConsumingTo ( d . output ( ) , todo ) ; } return true ; }
tr	3	public static final void closeWindow ( ) { if ( clickListener != null ) { clickListener . removeHandler ( ) ; } if ( keyPressListener != null ) { keyPressListener . removeHandler ( ) ; } if ( blurListener != null ) { blurListener . removeHandler ( ) ; } Alerts . closeWindow ( ) ; }
tr	2	public void add ( E e ) { Node u = new Node ( e ) ; if ( tail != null ) tail . setNext ( u ) ; tail = u ; if ( isEmpty ( ) ) { head = tail ; current = head ; } size ++ ; }
tr	1	private static char [ ] reverse ( char [ ] a , int len ) { char [ ] b = new char [ len ] ; for ( int i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { b [ j ] = a [ i ] ; } return b ; }
tr	5	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<StyleMap" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; for ( Iterator iter = this . pair . iterator ( ) ; iter . hasNext ( ) ; ) { StyleMapPair cur = ( StyleMapPair ) iter . next ( ) ; kml += cur . toKML ( ) ; } if ( ! suppressEnclosingTags ) { kml += "</StyleMap>\n" ; } return kml ; }
tr	0	private void gestionePrenotazione ( int uType , int id , Agenzia ag ) { panelVista . removeAll ( ) ; panelVista . add ( new VistaGestionePrenotazioni ( uType , id , ag ) ) ; this . invalidate ( ) ; this . validate ( ) ; this . repaint ( ) ; }
tr	6	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	4	@ Override public void visit ( FSP_OrSplit g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| OR_SPLIT }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
tr	3	public String getPinyinColorized ( ) { StringBuilder ankiPinyin = new StringBuilder ( ) ; String [ ] syllables = PinyinUtil . getSyllables ( pinyin ) ; int curTone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankiPinyin . append ( " " ) ; } curTone = getTone ( syllables [ i ] ) ; if ( curTone == 0 ) { ankiPinyin . append ( syllables [ i ] ) ; } else { ankiPinyin . append ( "<span style = \"color:" ) ; ankiPinyin . append ( toneColor [ curTone ] ) ; ankiPinyin . append ( "\">" ) ; ankiPinyin . append ( PinyinUtil . toUnicode ( syllables [ i ] ) ) ; ankiPinyin . append ( "</span>" ) ; } } return ankiPinyin . toString ( ) ; }
tr	6	@ Override public byte [ ] post ( HttpExchange he ) { if ( ! this . getContext ( ) . getSessionManager ( ) . isAuthorised ( he ) ) { return new byte [ 0 ] ; } WebUser wu = this . getContext ( ) . getSessionManager ( ) . getWebUser ( he . getRemoteAddress ( ) . getAddress ( ) ) ; OfflinePlayer offlinePlayer = this . getContext ( ) . getPlugin ( ) . getServer ( ) . getOfflinePlayer ( wu . getUsername ( ) ) ; if ( offlinePlayer == null || ( ! ( offlinePlayer . isOp ( ) ) ) ) { return new byte [ 0 ] ; } String postParams ; try ( InputStreamReader inStream = new InputStreamReader ( he . getRequestBody ( ) ) ) { try ( BufferedReader bufferedReader = new BufferedReader ( inStream ) ) { postParams = bufferedReader . readLine ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( RequestHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return new byte [ 0 ] ; } Map < String , String > vars = parsePostResponse ( postParams ) ; String add = vars . get ( "addPlayers" ) ; String rem = vars . get ( "removePlayers" ) ; if ( add != null ) { return addToWhitelist ( add ) ; } if ( rem != null ) { return removeFromWhitelist ( rem ) ; } return new byte [ 0 ] ; }
tr	0	@ SuppressWarnings ( "unused" ) private static Polygon getTest3 ( ) { Polygon p = new Polygon ( ) ; p . addPoint ( 0 , new Point ( 10 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 15 ) ) ; p . addPoint ( 0 , new Point ( 20 , 10 ) ) ; p . addPoint ( 0 , new Point ( 25 , 15 ) ) ; p . addPoint ( 0 , new Point ( 30 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 40 ) ) ; return p ; }
tr	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	5	@ Override public String toString ( ) { switch ( this ) { case uneEtoile : return "\u2605" ; case deuxEtoiles : return "\u2605\u2605" ; case troisEtoiles : return "\u2605\u2605\u2605" ; case quatreEtoiles : return "\u2605\u2605\u2605\u2605" ; case cinqEtoiles : return "\u2605\u2605\u2605\u2605\u2605" ; } return null ; }
tr	7	public JMenuBar createMenuBar ( ) { JMenuBar menuBar = new JMenuBar ( ) ; menuBar . putClientProperty ( "jgoodies.headerStyle" , "Both" ) ; JMenu componentsMenu = new JMenu ( "Components" ) ; componentsMenu . setMnemonic ( C ) ; menuBar . add ( componentsMenu ) ; for ( int i = 0 ; i < beans . length ; i ++ ) { Icon icon ; JMenuItem menuItem ; try { URL iconURL = beans [ i ] . getClass ( ) . getResource ( "images/" + beans [ i ] . getName ( ) + "Color16.gif" ) ; icon = new ImageIcon ( iconURL ) ; menuItem = new JMenuItem ( beans [ i ] . getName ( ) , icon ) ; } catch ( Exception e ) { System . out . println ( "JCalendarDemo.createMenuBar(): " + e ) ; menuItem = new JMenuItem ( beans [ i ] . getName ( ) ) ; } componentsMenu . add ( menuItem ) ; final JComponent bean = beans [ i ] ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { installBean ( bean ) ; } } ; menuItem . addActionListener ( actionListener ) ; } UIManager . LookAndFeelInfo [ ] lnfs = UIManager . getInstalledLookAndFeels ( ) ; ButtonGroup lnfGroup = new ButtonGroup ( ) ; JMenu lnfMenu = new JMenu ( "Look&Feel" ) ; lnfMenu . setMnemonic ( L ) ; menuBar . add ( lnfMenu ) ; for ( int i = 0 ; i < lnfs . length ; i ++ ) { if ( ! lnfs [ i ] . getName ( ) . equals ( "CDE/Motif" ) ) { JRadioButtonMenuItem rbmi = new JRadioButtonMenuItem ( lnfs [ i ] . getName ( ) ) ; lnfMenu . add ( rbmi ) ; rbmi . setSelected ( UIManager . getLookAndFeel ( ) . getName ( ) . equals ( lnfs [ i ] . getName ( ) ) ) ; rbmi . putClientProperty ( "lnf name" , lnfs [ i ] ) ; rbmi . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent ie ) { JRadioButtonMenuItem rbmi2 = ( JRadioButtonMenuItem ) ie . getSource ( ) ; if ( rbmi2 . isSelected ( ) ) { UIManager . LookAndFeelInfo info = ( UIManager . LookAndFeelInfo ) rbmi2 . getClientProperty ( "lnf name" ) ; try { UIManager . setLookAndFeel ( info . getClassName ( ) ) ; SwingUtilities . updateComponentTreeUI ( JCalendarDemo . this ) ; BasicSplitPaneDivider divider = ( ( BasicSplitPaneUI ) splitPane . getUI ( ) ) . getDivider ( ) ; if ( divider != null ) { divider . setBorder ( null ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( "Unable to set UI " + e . getMessage ( ) ) ; } } } } ) ; lnfGroup . add ( rbmi ) ; } } JMenu helpMenu = new JMenu ( "Help" ) ; helpMenu . setMnemonic ( H ) ; JMenuItem aboutItem = helpMenu . add ( new AboutAction ( this ) ) ; aboutItem . setMnemonic ( A ) ; aboutItem . setAccelerator ( KeyStroke . getKeyStroke ( A , java . awt . Event . CTRL_MASK ) ) ; menuBar . add ( helpMenu ) ; return menuBar ; }
tr	1	public MerchantDeal getMerchantDeal ( int merchantDealId ) { MerchantDeal merchantDeal = null ; try { session = mySessionFactory . getCurrentSession ( ) ; merchantDeal = ( MerchantDeal ) session . get ( MerchantDeal . class , merchantDealId ) ; } catch ( Exception e ) { } return merchantDeal ; }
tr	3	public static void insertTrainingStatus ( TrainingStatus status , Student student ) { boolean assigned = status . getAssigned ( ) ; String assignedDate = null ; if ( assigned == true ) assignedDate = status . getAssignedDate ( ) ; String supervisor = status . getSupervisor ( ) ; String thesis = status . getThesisTopic ( ) ; boolean plan = status . getIndividualPlan ( ) ; String approvalDate = status . getApprovalDate ( ) ; long studentId = student . getStudentId ( ) ; String insertSQL = "insert into Monitoring " + "(Date) " + "values (?)" ; try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "TrainingStatus not inserted" ) ; dbPrepStmnt = dbConn . prepareStatement ( "use phdStudent;" ) ; dbPrepStmnt . executeUpdate ( ) ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setString ( 1 , status . getMonitoring ( ) . getMonitoringDate ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . getMonitoring ( ) . setMonitoringId ( dbRset . getLong ( 1 ) ) ; insertSQL = "insert into TrainingStatus " + "(studentId  assigned  assignedDate  supervisor  thesis " + "individualPlan  approvalDate  monitoringId) " + "values (?  ?  ?  ?  ?  ?  ?  ?)" ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setLong ( 1 , studentId ) ; dbPrepStmnt . setBoolean ( 2 , assigned ) ; dbPrepStmnt . setString ( 3 , assignedDate ) ; dbPrepStmnt . setString ( 4 , supervisor ) ; dbPrepStmnt . setString ( 5 , thesis ) ; dbPrepStmnt . setBoolean ( 6 , plan ) ; dbPrepStmnt . setString ( 7 , approvalDate ) ; dbPrepStmnt . setLong ( 8 , status . getMonitoring ( ) . getMonitoringId ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . setTrainingStatusId ( dbRset . getLong ( 1 ) ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	3	@ Override public void doAction ( Player player , Grid grid ) throws InvalidActionException { if ( player . getRemainingTurns ( ) <= 0 ) throw new InvalidActionException ( "The player has no turns left!" ) ; Position currentPos = player . getPosition ( ) ; Position newPos = new Position ( currentPos . getxCoordinate ( ) + 1 , currentPos . getyCoordinate ( ) - 1 ) ; if ( ! canMoveToPosition ( player , grid , newPos ) || ! canMoveDiagonal ( grid , newPos ) ) throw new InvalidActionException ( "The player can't move to the desired position!" ) ; player . setPosition ( newPos ) ; player . getLightTrail ( ) . addPosition ( currentPos ) ; player . decrementTurn ( ) ; }
tr	7	@ Override public boolean nextKeyValue ( ) throws IOException , InterruptedException { if ( key == null ) { key = new LongWritable ( ) ; } key . set ( pos ) ; if ( value == null ) { value = new Text ( ) ; } value . clear ( ) ; final Text endline = new Text ( "\n" ) ; int newSize = 0 ; for ( int i = 0 ; i < NLINESTOPROCESS ; i ++ ) { Text v = new Text ( ) ; while ( pos < end ) { newSize = in . readLine ( v , maxLineLength , Math . max ( ( int ) Math . min ( Integer . MAX_VALUE , end - pos ) , maxLineLength ) ) ; value . append ( v . getBytes ( ) , 0 , v . getLength ( ) ) ; value . append ( endline . getBytes ( ) , 0 , endline . getLength ( ) ) ; if ( newSize == 0 ) { break ; } pos += newSize ; if ( newSize < maxLineLength ) { break ; } } } if ( newSize == 0 ) { key = null ; value = null ; return false ; } else { return true ; } }
tr	5	public static void print ( java . lang . String format , int amount , boolean vertical , Object ... objects ) { if ( objects != null ) { java . lang . String [ ] formats = null ; if ( format != null && ! format . isEmpty ( ) ) { formats = format . split ( " " ) ; } if ( formats . length == objects . length ) { for ( int i = 0 ; i < objects . length ; i ++ ) { $ . print ( formats [ i ] , objects [ i ] , 1 , vertical ) ; } } } }
tr	8	@ Override protected void handleInboxItem ( InboxItem inboxItem ) { super . handleInboxItem ( inboxItem ) ; if ( inboxItem . getMessage ( ) instanceof TokenMessage ) { executeTurn ( ) ; } if ( inboxItem . getMessage ( ) instanceof LeaderElectionMessage ) { LeaderElectionMessage message = ( LeaderElectionMessage ) inboxItem . getMessage ( ) ; switch ( message . getLeaderElectionMessageType ( ) ) { case ASK_FOR_ROLL : { doRoll ( inboxItem . getSender ( ) ) ; break ; } case LEADER_ELECTED : { initRound ( ) ; ownPlayer . setActive ( true ) ; if ( message . getValue ( ) == ownEndpoint . getId ( ) ) { isDealer = true ; logger . info ( "New Dealer" ) ; sendToken ( getPreviousPlayer ( ) ) ; } else { logger . info ( "Player " + message . getValue ( ) + " is new dealer." ) ; } break ; } case ROLLED : { gatherRoll ( inboxItem . getSender ( ) , message ) ; break ; } } } if ( inboxItem . getMessage ( ) instanceof StatusMessage ) { handleStatusMessage ( ( StatusMessage ) inboxItem . getMessage ( ) ) ; } if ( inboxItem . getMessage ( ) instanceof DealerMessage ) { handleDealerMessage ( inboxItem . getSender ( ) , ( DealerMessage ) inboxItem . getMessage ( ) ) ; } }
tr	8	private void findCodelOnEdge ( CodelArea area ) { DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; CodelChoser codelChoser = mMachine . getCodelChoser ( ) ; boolean isLeft = codelChoser . isLeft ( ) ; if ( directionPointer . isRight ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxXMinY ( ) ) ; } else { mEdgeCodel . set ( area . maxXMaxY ( ) ) ; } } else if ( directionPointer . isBottom ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxYMaxX ( ) ) ; } else { mEdgeCodel . set ( area . maxYMinX ( ) ) ; } } else if ( directionPointer . isLeft ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minXMaxY ( ) ) ; } else { mEdgeCodel . set ( area . minXMinY ( ) ) ; } } else if ( directionPointer . isTop ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minYMinX ( ) ) ; } else { mEdgeCodel . set ( area . minYMaxX ( ) ) ; } } }
tr	1	private static CC getCC ( ComponentWrapper comp , Map < ComponentWrapper , CC > ccMap ) { CC cc = ccMap . get ( comp ) ; return cc != null ? cc : new CC ( ) ; }
tr	4	private JPanel buildScoreReadingPreferencesPanel ( ) { scoreGameTypeComboBox = new JComboBox ( ) ; scoreGameTypeComboBox . addItemListener ( this ) ; scoreGameSpeedComboBox = new JComboBox ( ) ; scoreGameSpeedComboBox . addItem ( "Largo" ) ; scoreGameSpeedComboBox . addItem ( "Adagio" ) ; scoreGameSpeedComboBox . addItem ( "Moderato" ) ; scoreGameSpeedComboBox . addItem ( "Allegro" ) ; scoreGameSpeedComboBox . addItem ( "Presto" ) ; scoreGameSpeedComboBox . addItemListener ( this ) ; JPanel scoregamePanel = new JPanel ( ) ; scoregamePanel . add ( scoreGameTypeComboBox ) ; scoregamePanel . add ( scoreGameSpeedComboBox ) ; localizables . add ( new Localizable . NamedGroup ( scoregamePanel , "_menuExercises" ) ) ; scoreKeyComboBox = new JComboBox ( ) ; scoreKeyComboBox . addItemListener ( this ) ; scoreNotesComboBox = new JComboBox ( ) ; scoreNotesComboBox . addItemListener ( this ) ; scoreAlterationsComboBox = new JComboBox ( ) ; scoreAlterationsComboBox . addItemListener ( this ) ; JPanel scoreKeyPanel = new JPanel ( ) ; scoreKeyPanel . add ( scoreKeyComboBox ) ; scoreKeyPanel . add ( scoreAlterationsComboBox ) ; scoreKeyPanel . add ( scoreNotesComboBox ) ; localizables . add ( new Localizable . NamedGroup ( scoreKeyPanel , "_menuNotes" ) ) ; scorewholeCheckBox = new JCheckBox ( "" , true ) ; scorewholeCheckBox . addItemListener ( this ) ; scorehalfCheckBox = new JCheckBox ( "" , true ) ; scorehalfCheckBox . addItemListener ( this ) ; scoredottedhalfCheckBox = new JCheckBox ( "" , false ) ; scoredottedhalfCheckBox . addItemListener ( this ) ; scorequarterCheckBox = new JCheckBox ( "" , false ) ; scorequarterCheckBox . addItemListener ( this ) ; scoreeighthCheckBox = new JCheckBox ( "" , false ) ; scoreeighthCheckBox . addItemListener ( this ) ; scorerestCheckBox = new JCheckBox ( "" , true ) ; scorerestCheckBox . addItemListener ( this ) ; scoreTripletCheckBox = new JCheckBox ( "" , false ) ; scoreTripletCheckBox . addItemListener ( this ) ; JPanel scorerhytmsPanel = new JPanel ( ) ; scorerhytmsPanel . add ( scorewholeCheckBox ) ; scorerhytmsPanel . add ( scoredottedhalfCheckBox ) ; scorerhytmsPanel . add ( scorehalfCheckBox ) ; scorerhytmsPanel . add ( scorequarterCheckBox ) ; scorerhytmsPanel . add ( scoreeighthCheckBox ) ; scorerhytmsPanel . add ( scorerestCheckBox ) ; scorerhytmsPanel . add ( scoreTripletCheckBox ) ; scoreTimeSignComboBox = new JComboBox ( ) ; scoreTimeSignComboBox . setPreferredSize ( new Dimension ( 100 , 25 ) ) ; scoreTimeSignComboBox . addItem ( "4/4" ) ; scoreTimeSignComboBox . addItem ( "3/4" ) ; scoreTimeSignComboBox . addItem ( "2/4" ) ; scoreTimeSignComboBox . addItem ( "6/8" ) ; scoreTimeSignComboBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JComboBox cb = ( JComboBox ) e . getSource ( ) ; int sel = cb . getSelectedIndex ( ) ; System . out . println ( "Rhythm time signature changed. Selected: " + sel ) ; if ( sel == 0 ) { scorewholeCheckBox . setEnabled ( true ) ; scorewholeCheckBox . setSelected ( true ) ; scorequarterCheckBox . setSelected ( true ) ; scoredottedhalfCheckBox . setEnabled ( true ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoreLevel . setTimeSignNumerator ( 4 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 1 ) { scorewholeCheckBox . setSelected ( false ) ; scorewholeCheckBox . setEnabled ( false ) ; scoredottedhalfCheckBox . setSelected ( true ) ; scoredottedhalfCheckBox . setEnabled ( true ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 3 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 2 ) { scorewholeCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setEnabled ( false ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 2 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 3 ) { scorewholeCheckBox . setSelected ( false ) ; scorewholeCheckBox . setEnabled ( false ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setEnabled ( false ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 6 ) ; scoreLevel . setTimeSignDenominator ( 8 ) ; scoreLevel . setTimeDivision ( 2 ) ; } } } ) ; JPanel timeSignPanel = new JPanel ( ) ; scoreTimeSignLabel = new JLabel ( ) ; timeSignPanel . add ( scoreTimeSignLabel ) ; timeSignPanel . add ( scoreTimeSignComboBox ) ; JPanel scoreRhythmAndTimePanel = new JPanel ( ) ; scoreRhythmAndTimePanel . setLayout ( new BorderLayout ( ) ) ; scoreRhythmAndTimePanel . add ( timeSignPanel , BorderLayout . NORTH ) ; scoreRhythmAndTimePanel . add ( scorerhytmsPanel , BorderLayout . CENTER ) ; localizables . add ( new Localizable . NamedGroup ( scoreRhythmAndTimePanel , "_menuRythms" ) ) ; scoreMetronomeCheckBox = new JCheckBox ( "" , true ) ; scoreMetronomeShowCheckBox = new JCheckBox ( "" , true ) ; scoreMetronomeShowCheckBox . setSelected ( false ) ; scoreMetronomeCheckBox . addActionListener ( this ) ; scoreMetronomeShowCheckBox . addActionListener ( this ) ; JPanel scoremetronomePanel = new JPanel ( ) ; scoremetronomePanel . add ( scoreMetronomeCheckBox ) ; scoremetronomePanel . add ( scoreMetronomeShowCheckBox ) ; localizables . add ( new Localizable . NamedGroup ( scoremetronomePanel , "_menuMetronom" ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 4 , 1 ) ) ; panel . add ( scoregamePanel ) ; panel . add ( scoreKeyPanel ) ; panel . add ( scoreRhythmAndTimePanel ) ; panel . add ( scoremetronomePanel ) ; return panel ; }
tr	3	public void requestShiftRight ( ) { boolean continueToMakeNew = true ; if ( ! saved ) { continueToMakeNew = promptToSaveState ( ) ; } if ( continueToMakeNew ) { continueToMakeNew = promptShiftRight ( ) ; if ( continueToMakeNew ) { } } }
tr	5	public static void print ( JTextComponent textComponent ) throws TextComponentUtilException { InputStream is = null ; try { PrintService [ ] printServices = PrintServiceLookup . lookupPrintServices ( DocFlavor . INPUT_STREAM . AUTOSENSE , null ) ; if ( printServices . length > 0 ) { PrintRequestAttributeSet printRequestAttributeSet = new HashPrintRequestAttributeSet ( ) ; printRequestAttributeSet . add ( new JobName ( "JAligner" , null ) ) ; PrintService service = ServiceUI . printDialog ( null , 50 , 50 , printServices , PrintServiceLookup . lookupDefaultPrintService ( ) , DocFlavor . INPUT_STREAM . AUTOSENSE , printRequestAttributeSet ) ; if ( service != null ) { DocPrintJob printJob = service . createPrintJob ( ) ; PrintJobMointor printJobMointor = new PrintJobMointor ( printJob ) ; is = new ByteArrayInputStream ( textComponent . getText ( ) . getBytes ( ) ) ; DocumentName documentName = new DocumentName ( "JAligner" , null ) ; HashDocAttributeSet docAttributeSet = new HashDocAttributeSet ( ) ; docAttributeSet . add ( documentName ) ; Doc doc = new SimpleDoc ( is , DocFlavor . INPUT_STREAM . AUTOSENSE , docAttributeSet ) ; printJob . print ( doc , printRequestAttributeSet ) ; printJobMointor . waitForPrintJob ( ) ; } } else { throw new TextComponentUtilException ( "No print service found!" ) ; } } catch ( Exception e ) { throw new TextComponentUtilException ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Failed closing input stream: " + e . getMessage ( ) , e ) ; } } } }
tr	4	private Constant simplifySub ( AbstractBinaryOperator binaryOperator , AbstractMutableFormula left , AbstractMutableFormula right ) { if ( binaryOperator instanceof SubOperator && left instanceof Variable && right instanceof Variable && ( ( Variable ) left ) . getName ( ) . equals ( ( ( Variable ) right ) . getName ( ) ) ) { return new Constant ( 0 ) ; } return null ; }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	7	@ Override public String filterInsertedString ( FilterBypass fb , int offs , String str , AttributeSet a ) { String result = new String ( ) ; if ( negative && offs == 0 && str . charAt ( 0 ) == - ) { result = "-" ; } try { Document doc = fb . getDocument ( ) ; int firstDecimal = str . indexOf ( . ) ; if ( decimal && firstDecimal != - 1 && doc . getText ( 0 , doc . getLength ( ) ) . indexOf ( . ) == - 1 ) { result += str . substring ( 0 , firstDecimal ) . replaceAll ( "\\D" , "" ) ; result += . ; result += str . substring ( firstDecimal + 1 ) . replaceAll ( "\\D" , "" ) ; } else { result += str . replaceAll ( "\\D" , "" ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } return result ; }
tr	9X	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
tr	4	public void run ( ) { for ( int i = 0 ; i < 100 ; i ++ ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException exception ) { } Integer [ ] snapshot = buffer . snapshot ( ) ; assert snapshot . length > 18 : "Larger trim than expected!: " + snapshot . length ; assert snapshot . length <= 20 : "Buffer is too large: " + snapshot . length ; for ( int j = 0 ; j < snapshot . length ; j ++ ) { if ( snapshot [ j ] == null ) { assert false : "Found uninitialized value in snapshot: " + j + ":\n" + Arrays . toString ( snapshot ) ; } } assert snapshot [ 0 ] < snapshot [ snapshot . length - 1 ] : "Values do not appear to be coming out in order" ; Thread . yield ( ) ; } }
tr	3	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	5	public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == # ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ; ) { break ; } else { throw syntaxError ( "Missing ';' in XML entity: &" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	4	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append ( '' ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
tr	9X	public boolean isValid ( String s ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char curChar = s . charAt ( i ) ; switch ( curChar ) { case ) : if ( stack . isEmpty ( ) || stack . pop ( ) != ( ) { return false ; } break ; case ] : if ( stack . isEmpty ( ) || stack . pop ( ) != [ ) { return false ; } break ; case } : if ( stack . isEmpty ( ) || stack . pop ( ) != { ) { return false ; } break ; default : stack . push ( curChar ) ; } } return stack . isEmpty ( ) ; }
tr	4	@ Override public IBSTree < T > delete ( T value ) { BSTree < T > parent = null ; BSTree < T > curr = this ; for ( int cmp = value . compareTo ( curr . data ) ; cmp != 0 ; cmp = value . compareTo ( curr . data ) ) { if ( cmp < 0 ) { if ( curr . left == null ) { return null ; } parent = curr ; curr = curr . getTypedLeft ( ) ; } else { if ( curr . right == null ) { return null ; } parent = curr ; curr = curr . getTypedRight ( ) ; } } return curr . delete ( parent ) ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	9X	@ Override public void stateChanged ( ChangeEvent e ) { JSlider sliderOfInteraction = ( JSlider ) e . getSource ( ) ; switch ( sliderOfInteraction . getName ( ) ) { case "brightness" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; brightness = currentSliderValue * .001f ; if ( brightness < - .9f ) brightness = ( - .9f ) ; if ( brightness > 1f ) brightness = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , hsbvals [ 1 ] , ( hsbvals [ 2 ] + ( brightness ) < 0 ) ? 0 : ( hsbvals [ 2 ] + ( brightness ) > 1.0f ) ? 1.0f : hsbvals [ 2 ] + brightness ) ) ; } } break ; case "saturation" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; saturation = currentSliderValue * .001f ; if ( saturation < - .9f ) saturation = ( - .9f ) ; if ( saturation > 1f ) saturation = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , ( hsbvals [ 1 ] + saturation < 0 ) ? 0 : ( hsbvals [ 1 ] + ( saturation ) > 1.0f ) ? 1.0f : hsbvals [ 1 ] + saturation , hsbvals [ 2 ] ) ) ; } } break ; } oPanel . repaint ( ) ; }
tr	1	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	5	public static void exportPDF ( final File pdfLaTeX , final File workingDir , final String problem , final String solution , final MainFrame mainFrame ) { final java . util . Date date = new java . util . Date ( ) ; final java . sql . Timestamp ts = new java . sql . Timestamp ( date . getTime ( ) ) ; final String timestamp = ts . toString ( ) . replaceAll ( ":" , "-" ) ; final StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( workingDir . getAbsolutePath ( ) ) . append ( File . separator ) ; fileName . append ( "priklad " ) . append ( timestamp ) . append ( ".tex" ) ; final File texFile = new File ( fileName . toString ( ) ) ; writeTeXFile ( texFile , problem , solution ) ; final String errorMsgHeader = "Chyba p\u0159i exportu do PDF" ; final String errorMsg = "P\u0159eklad PDFLaTeXem zlyhal." ; try { final JLRGenerator pdfGenerator = new JLRGenerator ( ) ; pdfGenerator . deleteTempFiles ( false , true , true ) ; if ( pdfLaTeX == null ) { if ( pdfGenerator . generate ( texFile , workingDir , workingDir ) ) JLROpener . open ( pdfGenerator . getPDF ( ) ) ; } else { if ( pdfGenerator . generate ( pdfLaTeX , 1 , texFile , workingDir , workingDir ) ) JLROpener . open ( pdfGenerator . getPDF ( ) ) ; } if ( ! pdfGenerator . getErrorMessage ( ) . equals ( "No errors occurred!" ) ) { UserInputChecker . error ( mainFrame , errorMsgHeader , errorMsg ) ; System . err . println ( pdfGenerator . getErrorMessage ( ) ) ; } } catch ( IOException ex ) { UserInputChecker . error ( mainFrame , errorMsgHeader , errorMsg ) ; System . err . println ( ex . getMessage ( ) ) ; } }
tr	8	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
tr	4	public String getKeterangan ( ) { char idx = getIndex ( ) ; switch ( idx ) { case A : return "Sangat Baik" ; case B : return "Baik" ; case C : return "Cukup" ; case D : return "Kurang" ; default : return "Sangat Kurang" ; } }
tr	8	private Line generateLine ( Scanner inFile ) { Point s = null , e = null ; int thickness = 0 ; Color c = null ; String current = inFile . next ( ) ; while ( inFile . hasNext ( ) && ! ( isCloseTag ( current ) && parseTag ( current ) == LegalTag . Line ) ) { if ( isOpenTag ( current ) ) { switch ( parseTag ( current ) ) { case Start : s = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case End : e = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Color : c = new Color ( inFile . nextInt ( ) , inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Thickness : thickness = inFile . nextInt ( ) ; break ; default : break ; } } current = inFile . next ( ) ; } Line l = new Line ( s , e , thickness , c ) ; return l ; }
tr	0	public boolean isFinished ( ) { return isFinished ; }
tr	6	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { switch ( columnIndex ) { case 0 : return listStock . get ( rowIndex ) . getId ( ) ; case 1 : return listStock . get ( rowIndex ) . getLibelle ( ) ; case 2 : return listStock . get ( rowIndex ) . getType ( ) ; case 3 : return listStock . get ( rowIndex ) . getQtiteStock ( ) ; case 4 : return listStock . get ( rowIndex ) . getPrix ( ) ; case 5 : return listStock . get ( rowIndex ) . getDepot ( ) . getAdresse ( ) ; default : throw new IllegalArgumentException ( ) ; } }
tr	9X	private boolean r_Step_1a ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_1 , 6 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "ss" ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; if ( cursor > limit_backward ) { break lab1 ; } slice_from ( "ie" ) ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; slice_from ( "i" ) ; } while ( false ) ; break ; case 3 : if ( cursor <= limit_backward ) { return false ; } cursor -- ; golab2 : while ( true ) { lab3 : do { if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } slice_del ( ) ; break ; } return true ; }
tr	7	@ Override public YamlPermissionBase get ( PermissionType type , UUID uuid ) throws DataLoadFailedException { switch ( type ) { case USER : return getUser ( uuid ) ; case GROUP : return getGroup ( uuid ) ; case WORLD : return getWorld ( uuid ) ; case ENTITY : return getEntity ( uuid ) ; case OP : return getOP ( ) ; case CONSOLE : return getConsole ( ) ; case RCON : return getRcon ( ) ; default : return null ; } }
tr	7	public void updateLyricsPane ( final Track t ) { if ( ! currentTrack . equals ( t ) ) { currentTrack = t ; new Thread ( ) { @ Override public void run ( ) { String artist = t . get ( "artist" ) ; String title = t . get ( "title" ) ; String lyrics ; if ( artist . equals ( "DOOOOOM" ) && title . equals ( "Please Give Us All An A" ) ) { lyrics = "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; lyrics += "[awesome guitar solo]\n" ; lyrics += "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; } else { if ( artist != null && ! artist . isEmpty ( ) && title != null && ! title . isEmpty ( ) ) { System . out . println ( "." ) ; lyrics = LyricsFetcher . fetchLyrics ( t . get ( "artist" ) , t . get ( "title" ) ) ; } else { lyrics = "[lyrics unavailable]" ; } } Platform . runLater ( new Runnable ( ) { String lyrics ; @ Override public void run ( ) { lyrics_text . setText ( lyrics ) ; } public Runnable init ( String lyrics ) { this . lyrics = lyrics ; return this ; } } . init ( lyrics ) ) ; } } . start ( ) ; } }
tr	1	private final void processItems ( final List < Step > items ) { for ( final Step item : items ) { item . process ( ) ; } }
tr	1	public void destroy ( ) { game . stopLWJGL ( ) ; if ( display_parent != null ) remove ( display_parent ) ; super . destroy ( ) ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; int p1 ; int p2 ; p0 = new String [ ] { "kenta" , "kentaro" , "ken" } ; p1 = 2 ; p2 = 3 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "hideo" , "hideto" , "hideki" , "hide" } ; p1 = 2 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "aya" , "saku" , "emi" , "ayane" , "sakura" , "emika" , "sakurako" } ; p1 = 3 ; p2 = 24 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "taro" , "jiro" , "hanako" } ; p1 = 2 ; p2 = 0 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "alice" , "bob" , "charlie" } ; p1 = 1 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "ryota" , "ryohei" , "ryotaro" , "ryo" , "ryoga" , "ryoma" , "ryoko" , "ryosuke" , "ciel" , "lun" , "ryuta" , "ryuji" , "ryuma" , "ryujiro" , "ryusuke" , "ryutaro" , "ryu" , "ryuhei" , "ryuichi" , "evima" } ; p1 = 3 ; p2 = 276818566 ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	1	public boolean isOpen ( ) { assert ( readystate == READYSTATE . OPEN ? ! flushandclosestate : true ) ; return readystate == READYSTATE . OPEN ; }
tr	8	private void writeHeader ( ) throws IOException { row [ 0 ] = row [ 1 ] = row [ 2 ] = row [ 3 ] = "" ; int columnNumber = 4 ; for ( int i = 0 ; i < columns . get ( "" ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = "" ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( int i = 0 ; i < entry . getValue ( ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = entry . getKey ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; row [ 0 ] = "Point#" ; row [ 1 ] = "Experiment#" ; row [ 2 ] = "Year#" ; row [ 3 ] = "After subiteration" ; columnNumber = 4 ; for ( Column column : columns . get ( "" ) ) row [ columnNumber ++ ] = column . dynamicValueName ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( Column column : entry . getValue ( ) ) row [ columnNumber ++ ] = column . toString ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; }
tr	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
tr	4	private int getLineY ( String text , int lineNumber ) { if ( text . length ( ) == 0 ) return 0 ; int pos = 0 ; try { for ( int i = 1 ; i < lineNumber ; i ++ ) { int eol = text . indexOf ( lineSeparator , pos ) ; if ( eol == - 1 ) { Rectangle bounds = textPane . modelToView ( pos ) ; return bounds . y + bounds . height ; } pos = eol + lineSeparator . length ( ) ; } return textPane . modelToView ( pos ) . y ; } catch ( Exception ex ) { throw new ErrorException ( "Internal error: " + ex ) ; } }
tr	1	public void print ( Node node ) { if ( node != null ) { System . out . print ( node . value + " " ) ; print ( node . next ) ; } else { System . out . println ( ) ; } }
tr	7	private Model method206 ( int i , int j ) { Model model = ( Model ) aMRUNodes_264 . insertFromCache ( ( i << 16 ) + j ) ; if ( model != null ) return model ; if ( i == 1 ) model = Model . method462 ( j ) ; if ( i == 2 ) model = EntityDef . forID ( j ) . method160 ( ) ; if ( i == 3 ) model = client . myPlayer . method453 ( ) ; if ( i == 4 ) model = ItemDef . forID ( j ) . method202 ( 50 ) ; if ( i == 5 ) model = null ; if ( model != null ) aMRUNodes_264 . removeFromCache ( model , ( i << 16 ) + j ) ; return model ; }
tr	5	public void abrir ( ) throws Exception { if ( id . length ( ) > 0 && ! id . equals ( "0" ) ) { long cod = long . parseLong ( id ) ; if ( venda == null || ( venda != null && venda . getId ( ) != cod ) ) setVenda ( ejb . Open ( cod ) ) ; } }
tr	9X	public boolean execute ( CommandSender sender , String [ ] args ) { String groupName = args [ 0 ] ; GroupManager groupManager = Citadel . getGroupManager ( ) ; Faction group = groupManager . getGroup ( groupName ) ; if ( group == null ) { sendMessage ( sender , ChatColor . RED , "Group doesn't exist" ) ; return true ; } String senderName = sender . getName ( ) ; if ( ! group . isFounder ( senderName ) ) { sendMessage ( sender , ChatColor . RED , "Invalid permission to transfer this group" ) ; return true ; } if ( group . isPersonalGroup ( ) ) { sendMessage ( sender , ChatColor . RED , "You cannot transfer your default group" ) ; return true ; } String targetName = args [ 1 ] ; if ( senderName . equalsIgnoreCase ( targetName ) ) { sendMessage ( sender , ChatColor . RED , "You already own this group" ) ; return true ; } int groupsAllowed = Citadel . getConfigManager ( ) . getGroupsAllowed ( ) ; if ( groupManager . getPlayerGroupsAmount ( targetName ) >= groupsAllowed ) { sendMessage ( sender , ChatColor . RED , "This player has already reached the maximum amount of groups allowed" ) ; return true ; } MemberManager memberManager = Citadel . getMemberManager ( ) ; if ( ! memberManager . isOnline ( targetName ) ) { sendMessage ( sender , ChatColor . RED , "User must be online" ) ; return true ; } Member member = memberManager . getMember ( targetName ) ; if ( member == null ) { member = new Member ( targetName ) ; memberManager . addMember ( member ) ; } if ( group . isMember ( targetName ) ) { groupManager . removeMemberFromGroup ( groupName , targetName ) ; } if ( group . isModerator ( targetName ) ) { groupManager . removeModeratorFromGroup ( groupName , targetName ) ; } group . setFounder ( targetName ) ; groupManager . addGroup ( group ) ; sendMessage ( sender , ChatColor . GREEN , "You have transferred %s to %s" , groupName , targetName ) ; if ( memberManager . isOnline ( targetName ) ) { sendMessage ( memberManager . getOnlinePlayer ( targetName ) , ChatColor . YELLOW , "%s has transferred the group %s to you" , senderName , groupName ) ; } return true ; }
tr	3	private void createTable ( ORMHash ht , ORMTable table ) throws SQLException { String createSQL = ht . createSQL ( ) ; String tableName = table . tableName ( ) ; int hashSize = ht . hashSize ( ) ; if ( hashSize < 1 ) { hashSize = 1 ; } List < String > alreadyExistTableList = dao . queryForSimpObjectList ( "show tables like '" + tableName + "%'" , new Object [ ] { } , String . class ) ; MessageFormat mf = new MessageFormat ( createSQL ) ; String hashTableName = null ; for ( int i = 0 ; i < hashSize ; i ++ ) { hashTableName = tableName + "_" + DBUtils . getInstance ( ) . hash ( i , hashSize ) ; if ( alreadyExistTableList . contains ( hashTableName ) ) { logger . trace ( "Hash Table[{}] is already exist!" , hashTableName ) ; } else { logger . info ( "Init hash table:{};" , hashTableName ) ; dao . update ( mf . format ( new Object [ ] { hashTableName } ) ) ; logger . info ( "Init hash table[{}] finish." , hashTableName ) ; } } }
tr	6	protected KeyboardEventListener parseKeyboardListener ( String keyboardListenerString ) { KeyboardEventListener rc = null ; if ( ! "" . equals ( keyboardListenerString ) ) { switch ( keyboardListenerString ) { case ( "SplashScreenKeyboardEventListener" ) : rc = new SplashScreenKeyboardEventListener ( ) ; break ; case ( "MenuKeyboardEventListener" ) : rc = new MenuKeyboardEventListener ( ) ; break ; case ( "OptionsMenuItemKeyboardEventListener" ) : rc = new OptionsMenuItemKeyboardEventListener ( ) ; break ; case ( "ExitMenuItemKeyboardEventListener" ) : rc = new ExitMenuItemKeyboardEventListener ( ) ; break ; case ( "OptionsMenuBackKeyboardEventListener" ) : rc = new OptionsMenuBackKeyboardEventListener ( ) ; break ; default : } } return rc ; }
tr	0	public void showMessageBox ( String sender , String message , boolean option ) { }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	9X	private void scheduleRefreshPackets ( ByteBuffer addEntityBuffer ) { synchronized ( entities ) { for ( Entity one : entities ) { if ( playerListChanged && one . getId ( ) > - 1 ) { protocol . send ( addEntityBuffer , new AddEntity ( one ) ) ; if ( one instanceof Box && one . humanControl ( ) ) { protocol . send ( addEntityBuffer , new Update ( ( Box ) one ) ) ; if ( one instanceof Soldier ) { protocol . send ( addEntityBuffer , new Color ( one ) ) ; protocol . send ( addEntityBuffer , new Ammo ( ( Soldier ) one ) ) ; } } } if ( one instanceof Box ) { Box b = ( Box ) one ; if ( b . needsUpdate ( frame ) ) { prepareUpdateBuffer ( ) ; Packet updatePacket = new Update ( b ) ; protocol . send ( updateBuffer , updatePacket ) ; if ( b . freshMeat ( ) && b instanceof Soldier ) { protocol . send ( updateBuffer , new Color ( b ) ) ; protocol . send ( updateBuffer , new Ammo ( ( Soldier ) b ) ) ; } } } } } }
tr	6	public int [ ] likertJakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	9X	public Geometry patch ( int m , int n , double basisMatrix [ ] [ ] , double data [ ] ) { newRectangularMesh ( m + 2 , n + 2 ) ; faces = new int [ m * n ] [ 4 ] ; for ( int k = 1 ; k < n + 1 ; k ++ ) for ( int j = 1 ; j < m + 1 ; j ++ ) { int f = ( k - 1 ) * m + j - 1 ; int v = k * ( m + 3 ) + j ; faces [ f ] [ 0 ] = v ; faces [ f ] [ 1 ] = v + 1 ; faces [ f ] [ 2 ] = v + m + 3 + 1 ; faces [ f ] [ 3 ] = v + m + 3 ; } double G [ ] [ ] [ ] = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) G [ k ] [ i ] [ j ] = data [ 12 * i + 3 * j + k ] ; Coefs = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int k = 0 ; k < 3 ; k ++ ) constructBicubicCoefficients ( G [ k ] , basisMatrix , Coefs [ k ] ) ; int N = 0 ; for ( int j = - 1 ; j <= n + 1 ; j ++ ) { double v = ( double ) j / n ; for ( int i = - 1 ; i <= m + 1 ; i ++ ) { double u = ( double ) i / m ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = evalBicubic ( Coefs [ k ] , u , v ) ; N ++ ; } } computedMeshNormals = false ; return this ; }
tr	0	public TransformationScaleXY ( Node node ) { NamedNodeMap attr = node . getAttributes ( ) ; scaleX = float . parseFloat ( attr . getNamedItem ( "scaleX" ) . getNodeValue ( ) ) ; scaleY = float . parseFloat ( attr . getNamedItem ( "scaleY" ) . getNodeValue ( ) ) ; transform . setToScale ( scaleX , scaleY ) ; }
tr	3	private boolean checkUserExists ( String user ) { Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "id " + user ) ; p . waitFor ( ) ; int exitValue = p . exitValue ( ) ; if ( exitValue != 0 ) { JOptionPane . showMessageDialog ( sif , "Invalid user - " + user + "\nPlease make sure the user exists in the system." , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null ) NativeCalls . releaseProcess ( p ) ; } return true ; }
tr	5	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	2	public < K , V > ListenableAtomicMap < K , V > removeListenableAtomicMapNamed ( String name ) { return atomic ( ( ) -> { ListenableAtomicMap < ? , ? > map = ListenableAtomicMapsByName . remove ( name ) ; return ( ListenableAtomicMap < K , V > ) map ; } ) ; }
tr	8	private void runButtonActionPerformed ( java . awt . event . ActionEvent evt ) throws IOException { if ( runButton . getText ( ) . equals ( "Run" ) ) { threadSwitch . setEnabled ( false ) ; debugSwitch . setEnabled ( false ) ; simRunSwitch . setEnabled ( false ) ; ignoreSwitch . setEnabled ( false ) ; forceSwitch . setEnabled ( false ) ; writeToDBSwitch . setEnabled ( false ) ; threadComboBox . setEnabled ( false ) ; debugComboBox . setEnabled ( false ) ; runButton . setText ( "Interrupt" ) ; boolean debugEnabled = debugSwitch . isSelected ( ) ; boolean simRunEnabled = simRunSwitch . isSelected ( ) ; boolean ignoreEnabled = ignoreSwitch . isSelected ( ) ; boolean forceEnabled = forceSwitch . isSelected ( ) ; int threadComboVal = threadComboBox . getSelectedIndex ( ) + 1 ; int debugComboVal = debugComboBox . getSelectedIndex ( ) + 1 ; config . setDebug ( debugEnabled ) ; if ( debugEnabled ) { config . setVerbosity ( debugComboVal ) ; } else { config . setVerbosity ( 1 ) ; } config . setRunTerminal ( false ) ; config . setPastOnly ( false ) ; config . setForceRun ( forceEnabled ) ; config . setSimRun ( simRunEnabled ) ; if ( simRunEnabled ) { config . setLOG_NAME ( "log_alt.txt" ) ; } config . setIgnoreLog ( ignoreEnabled ) ; config . setNumThreads ( threadComboVal ) ; try { if ( config . finishedToday ( ) && ! config . isIgnoreLog ( ) ) { mainOutMessage ( "Already finished today" , 1 ) ; } } catch ( IOException e ) { Util . exceptionHandler ( e , 1 , "WT.run> Unknown error  probably a problem reading logfile" , config , this ) ; } config . outputConfig ( this ) ; wr = new WeatherRecorder ( this , config ) ; wr . run ( ) ; } else if ( runButton . getText ( ) . equals ( "Interrupt" ) ) { runButton . setText ( "Press button again to interrupt" ) ; } else if ( runButton . getText ( ) . equals ( "Press button again to interrupt" ) ) { runButton . setText ( "Forcing quit..." ) ; stopProgram ( ) ; } }
tr	7	@ Deprecated static List < Object > graphToRDF ( Map < String , Object > graph , UniqueNamer namer ) { final List < Object > rval = new ArrayList < Object > ( ) ; for ( final String id : graph . keySet ( ) ) { final Map < String , Object > node = ( Map < String , Object > ) graph . get ( id ) ; final List < String > properties = new ArrayList < String > ( node . keySet ( ) ) ; Collections . sort ( properties ) ; for ( String property : properties ) { final Object items = node . get ( property ) ; if ( "@type" . equals ( property ) ) { property = RDF_TYPE ; } else if ( isKeyword ( property ) ) { continue ; } for ( final Object item : ( List < Object > ) items ) { final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; if ( id . indexOf ( "_:" ) == 0 ) { subject . put ( "type" , "blank node" ) ; subject . put ( "value" , namer . getName ( id ) ) ; } else { subject . put ( "type" , "IRI" ) ; subject . put ( "value" , id ) ; } final Map < String , Object > predicate = new LinkedHashMap < String , Object > ( ) ; predicate . put ( "type" , "IRI" ) ; predicate . put ( "value" , property ) ; if ( isList ( item ) ) { listToRDF ( ( List < Object > ) ( ( Map < String , Object > ) item ) . get ( "@list" ) , namer , subject , predicate , rval ) ; } else { final Object object = objectToRDF ( item , namer ) ; final Map < String , Object > tmp = new LinkedHashMap < String , Object > ( ) ; tmp . put ( "subject" , subject ) ; tmp . put ( "predicate" , predicate ) ; tmp . put ( "object" , object ) ; rval . add ( tmp ) ; } } } } return rval ; }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
tr	3	public boolean equals ( Object obj ) { boolean returnMe = true ; if ( ! obj . getClass ( ) . equals ( this . getClass ( ) ) ) { returnMe = false ; } else { if ( docID != ( ( Pair ) obj ) . docID ) { returnMe = false ; } else { if ( score != ( ( Pair ) obj ) . score ) { returnMe = false ; } } } return returnMe ; }
tr	4	public graph ( String C , String type , String interval , String r ) throws SQLException { super ( "Bar Chart" ) ; connnect = new sqlConnection ( ) ; sql = new selectQueries ( ) ; sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; int inte = Integer . parseInt ( interval ) ; ResultSet item = sql . getGraph1 ( conn , type , inte ) ; int i = 0 ; ResultSetMetaData md = item . getMetaData ( ) ; int count = md . getColumnCount ( ) ; String [ ] list = new String [ count ] ; int i1 = 0 ; while ( item . next ( ) ) { list [ i1 ] = item . getString ( "rcm_id" ) ; i1 ++ ; } BarChart chart = new BarChart ( ) ; Object [ ] col = new Object [ ] { Color . red , Color . green , Color . blue , Color . black , Color . pink , Color . yellow , Color . DARK_GRAY } ; for ( int p = 0 ; p < count ; p ++ ) { if ( p == col . length - 1 ) { break ; } try { chart . addBar ( ( Color ) col [ p ] , Integer . parseInt ( list [ p ] ) ) ; } catch ( Exception e ) { System . out . println ( "Exception occured here" ) ; } } getContentPane ( ) . setBackground ( Color . CYAN ) ; getContentPane ( ) . add ( chart ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; pack ( ) ; setVisible ( true ) ; }
tr	1	public List < Frequencia > getFrequenciaFuncionario2 ( Integer mes , Integer ano , Integer dia , Integer ultimodia , Integer idFuncionario ) throws SQLException { List < Frequencia > frequencia = new ArrayList < Frequencia > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM frequencia WHERE idfuncionario = ? and data between ? and ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; Calendar c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , dia ) ; ps . setDate ( 2 , new Date ( c . getTimeInMillis ( ) ) ) ; c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , ultimodia ) ; ps . setDate ( 3 , new Date ( c . getTimeInMillis ( ) ) ) ; Frequencia f ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { f = new Frequencia ( ) ; f . setId ( rs . getInt ( "idfrequencia" ) ) ; f . setData ( rs . getDate ( "data" ) ) ; f . setPresenca ( rs . getBoolean ( "presenca" ) ) ; f . setFuncionario ( new FuncionarioDao ( ) . getfuncionario ( rs . getInt ( "idFuncionario" ) ) ) ; f . setHoraSaida ( rs . getTimestamp ( "hora_saida" ) ) ; f . setTurno ( rs . getString ( "turno" ) ) ; frequencia . add ( f ) ; } return frequencia ; }
tr	9X	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	3	public void addControllerMap ( String name , Map < String , ? extends Object > attribs ) { if ( getControllersMap ( ) != null ) { getControllersMap ( ) . put ( name , attribs ) ; } else { this . setControllersMap ( new HashMap < String , Map < String , ? extends Object >> ( ) ) ; this . getControllersMap ( ) . put ( name , attribs ) ; } }
tr	4	protected boolean isInGrabBar ( int mouseX , int mouseY ) { mouseY = Standards . W_HEIGHT - mouseY - 1 ; if ( ( mouseX > ScreenX ) && ( mouseX < ScreenX + Width ) ) { if ( ( mouseY > ScreenY ) && ( mouseY < ScreenY + GrabBarHeight ) ) { return true ; } } return false ; }
tr	1	public String getName ( ) { if ( name == null ) return "World" ; else return name ; }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	2	public void back ( ) throws JSONException { if ( this . usePrevious || this . index <= 0 ) { throw new JSONException ( "Stepping back two steps is not supported" ) ; } this . index -= 1 ; this . character -= 1 ; this . usePrevious = true ; this . eof = false ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_BitcoinAcct ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	7	public int longestValidParentheses ( String s ) { Stack < Character > sc = new Stack < Character > ( ) ; Stack < Integer > si = new Stack < Integer > ( ) ; int i = 0 , max = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( si . isEmpty ( ) || c == ( ) { si . push ( i ) ; sc . push ( c ) ; } else { if ( sc . peek ( ) == ( ) { sc . pop ( ) ; si . pop ( ) ; if ( si . isEmpty ( ) ) { if ( max < i + 1 ) { max = i + 1 ; } } else { if ( max < i - si . peek ( ) ) { max = i - si . peek ( ) ; } } } } } return max ; }
tr	3	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
tr	1	public void showHideDeleteBtn ( ) { if ( ! btnVisible ) { deletePanel . setVisible ( true ) ; this . repaint ( ) ; btnVisible = true ; } else { deletePanel . setVisible ( false ) ; this . repaint ( ) ; btnVisible = false ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	4	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	0	public int getSize ( ) { return size ; }
tr	9X	final public void edgeRHS ( ) throws ParseException { ASTedgeRHS jjtn000 = new ASTedgeRHS ( JJTEDGERHS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { edgeop ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ID : node_id ( ) ; break ; case SUBGRAPH : case { : subgraph ( ) ; break ; default : jj_la1 [ 11 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EDGE_UNDIRECTED : case EDGE_DIRECTED : edgeRHS ( ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } }
tr	5	@ Test public void buildsGraph ( ) { Point p1 = vc . addPoint ( 0 , 0 ) ; Point p2 = vc . addPoint ( 1 , - 1 ) ; Point p3 = vc . addPoint ( 1 , 1 ) ; Point p4 = vc . addPoint ( 1.5 , 0.0 ) ; Point p5 = vc . addPoint ( 4 , - 1 ) ; Point p6 = vc . addPoint ( 4 , 1 ) ; p1 . setRight ( p2 ) ; p2 . setLeft ( p1 ) ; p3 . setRight ( p1 ) ; p1 . setLeft ( p3 ) ; p2 . setRight ( p3 ) ; p3 . setLeft ( p2 ) ; p4 . setRight ( p5 ) ; p5 . setLeft ( p4 ) ; p6 . setRight ( p4 ) ; p4 . setLeft ( p6 ) ; p5 . setRight ( p6 ) ; p6 . setLeft ( p5 ) ; vc . buildGraph ( ) ; Tree < Vertex > testadj1 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj2 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj3 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj4 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj5 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj6 = new Tree < > ( new VertexComparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; assertTrue ( p1 . getAdjacents ( ) . equals ( testadj1 ) && p2 . getAdjacents ( ) . equals ( testadj2 ) && p3 . getAdjacents ( ) . equals ( testadj3 ) && p4 . getAdjacents ( ) . equals ( testadj4 ) && p5 . getAdjacents ( ) . equals ( testadj5 ) && p6 . getAdjacents ( ) . equals ( testadj6 ) ) ; }
tr	5	public void update ( ) { totalTime ++ ; if ( totalTime > 200 && ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; boolean switchScreen = false ; if ( logoTransparancy < 1.0f ) { logoTransparancy += ( float ) RTSComponent . MS_PER_TICK / 2000 ; } else { logoTransparancy = 1.0f ; switchScreen = true ; } if ( switchScreen ) { if ( ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; } }
tr	9X	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	1	public boolean offerFirst ( E e ) { if ( contains ( e ) ) { return false ; } linkFirst ( e ) ; return true ; }
tr	3	@ Override public void run ( ) { while ( isRunning ) { try { msgProto . newInboundMsg ( activeConnections . getIdByOIS ( ois ) , ( Message ) ois . readObject ( ) ) ; } catch ( ClassNotFoundException | IOException e1 ) { System . out . println ( "Could not retriev ObjectInputStream" ) ; activeConnections . unregisterByOIS ( ois ) ; break ; } try { Thread . sleep ( SPEED ) ; } catch ( InterruptedException e ) { } } }
tr	4	public void onSessionStatusChanged ( O2GSessionStatusCode status ) { System . out . println ( "Status: " + status . toString ( ) ) ; switch ( status ) { case TRADING_SESSION_REQUESTED : if ( mSessionID . isEmpty ( ) ) { System . out . println ( "Argument for trading session ID is missing" ) ; } else { mSession . setTradingSession ( mSessionID , mPin ) ; } break ; case CONNECTED : mConnected = true ; mDisconnected = false ; mSemaphore . release ( ) ; break ; case DISCONNECTED : mConnected = false ; mDisconnected = true ; mSemaphore . release ( ) ; break ; } }
tr	9X	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Polygon" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isExtrudeDirty ) { change += "<extrude>" + this . extrude + "</extrude>\n" ; this . isExtrudeDirty = false ; } if ( this . isTessellateDirty ) { change += "<tessellate>" + this . tessellate + "</tessellate>\n" ; this . isTessellateDirty = false ; } if ( this . altitudeMode != null && this . isAltitudeModeDirty ) { change += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; this . isAltitudeModeDirty = false ; } if ( this . outerBoundaryIs != null && this . outerBoundaryIs . isDirty ( ) ) { change += this . outerBoundaryIs . toUpdateKML ( ) ; } for ( Iterator iter = this . innerBoundaryIs . iterator ( ) ; iter . hasNext ( ) ; ) { boundary cur = ( boundary ) iter . next ( ) ; if ( cur . isDirty ( ) ) { change += cur . toUpdateKML ( ) ; } } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Polygon>\n" ; } setNotDirty ( ) ; return change ; }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Users ) ) { return false ; } Users other = ( Users ) object ; if ( ( this . iduser == null && other . iduser != null ) || ( this . iduser != null && ! this . iduser . equals ( other . iduser ) ) ) { return false ; } return true ; }
tr	8	public static int search3 ( int [ ] A , int target ) { if ( A . length == 0 ) return - 1 ; int l = 0 ; int r = A . length - 1 ; int m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( target == A [ m ] ) { return m ; } else if ( A [ l ] <= A [ m ] ) { if ( target < A [ m ] && target >= A [ l ] ) { r = m - 1 ; } else { l = m + 1 ; } } else { if ( target <= A [ r ] && target > A [ m ] ) { l = m + 1 ; } else { r = m - 1 ; } } } return - 1 ; }
tr	4	private AVLNode < E > verificationRight ( AVLNode < E > pnodo ) { switch ( pnodo . getBalance ( ) ) { case 0 : pnodo . setBalance ( 1 ) ; break ; case - 1 : _increase = false ; pnodo . setBalance ( 0 ) ; case 1 : AVLNode < E > right = pnodo . getRight ( ) ; if ( right . getBalance ( ) == 1 ) { pnodo = rotationRightRight ( pnodo ) ; } else { pnodo = rotationRightLeft ( pnodo ) ; } _increase = false ; break ; } return pnodo ; }
tr	9X	private void handlePacket ( Command command ) throws ProtocolException { if ( command . getCommand ( ) . equals ( ClientProtocol . GAME ) ) { String arg0 = command . getArgument ( 0 ) ; int arg1 = Integer . parseInt ( command . getArgument ( 1 ) ) ; int arg2 = Integer . parseInt ( command . getArgument ( 2 ) ) ; if ( games . containsKey ( arg0 ) ) { games . remove ( arg0 ) ; } System . out . println ( arg0 + arg1 + arg2 ) ; games . put ( arg0 , new int [ ] { arg1 , arg2 } ) ; LobbyGUI . lobbyGUI . paintList ( ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . JOIN_GAME ) ) { if ( command . getArgument ( 0 ) . equals ( currentGame . getCreator ( ) . getUsername ( ) ) ) { currentGame . addPlayer ( user ) ; } } else if ( command . getCommand ( ) . equals ( ClientProtocol . START ) ) { currentGame = new ServerGame ( new HumanPlayer ( command . getArgument ( 0 ) ) ) ; if ( command . getArgumentCount ( ) >= 2 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 1 ) ) ) ; } if ( command . getArgumentCount ( ) >= 3 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 2 ) ) ) ; } if ( command . getArgumentCount ( ) == 4 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 3 ) ) ) ; } currentGame . start ( ) ; LobbyGUI . lobbyGUI . startGame ( ) ; currentGame . online = true ; currentGame . playerType = LobbyGUI . lobbyGUI . playerType ; int timeLimit ; try { timeLimit = Integer . parseInt ( LobbyGUI . lobbyGUI . textField . getText ( ) ) ; } catch ( NumberFormatException e ) { timeLimit = 0 ; } currentGame . timeLimit = timeLimit ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE_DONE ) ) { currentGame . turn = false ; int x = Integer . parseInt ( command . getArgument ( 1 ) ) , y = Integer . parseInt ( command . getArgument ( 2 ) ) ; currentGame . doMove ( x , y ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE ) ) { synchronized ( currentGame ) { if ( currentGame . playerType . equals ( "Human" ) ) { currentGame . turn = true ; currentGame . gameGameGUI . paintComponents ( currentGame . board , true ) ; } else { currentGame . turnOnlineAI ( ) ; } } } }
tr	7	public static BufferedImage getImage ( Card card ) { int rowNumber ; int colNumber ; if ( card . getSuit ( ) . equals ( Suit . CLUBS ) ) { rowNumber = 0 ; } else if ( card . getSuit ( ) . equals ( Suit . DIAMONDS ) ) { rowNumber = 1 ; } else if ( card . getSuit ( ) . equals ( Suit . HEARTS ) ) { rowNumber = 2 ; } else if ( card . getSuit ( ) . equals ( Suit . SPADES ) ) { rowNumber = 3 ; } else { rowNumber = 4 ; } if ( card . getCardValue ( ) . equals ( CardValue . ACE ) ) { colNumber = 0 ; } else if ( card . getCardValue ( ) . equals ( CardValue . JOKER ) ) { if ( card . getSuit ( ) . equals ( Suit . BLACK ) ) { colNumber = 0 ; } else { colNumber = 1 ; } } else { colNumber = card . getCardValue ( ) . getValue ( ) ; } return ImageCard . getInstance ( ) . image . getSubimage ( colNumber * ImageCard . getInstance ( ) . getCardWidth ( ) , rowNumber * ImageCard . getInstance ( ) . getCardHeight ( ) , ImageCard . getInstance ( ) . getCardWidth ( ) , ImageCard . getInstance ( ) . getCardHeight ( ) ) ; }
tr	6	public static void main ( String [ ] args ) { int N = 4 ; int gC [ ] = { 1 , 5 , 3 , 6 } ; int d [ ] = { 2 , 3 , 2 , 7 } ; int rF [ ] = { 0 , 0 , 0 , 0 } ; int l , i ; for ( l = 0 ; l < N ; l ++ ) { for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) rF [ i ] += gC [ ( l + i ) % N ] - d [ ( l + i ) % N ] ; } } for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) break ; } if ( i < N ) { System . out . println ( "The Starting point is:" + i ) ; } else { System . out . println ( "There is no Starting point" ) ; } }
tr	7	public synchronized void tick ( ) { handleEvents ( ) ; updateWorkers ( ) ; for ( Sponsor sponsor : new ArrayList < Sponsor > ( sponsors ) ) { if ( sponsor . getMSLeft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } Random r = new Random ( ) ; if ( sponsors . size ( ) < MAX_SPONSORS && r . nextInt ( ( int ) ( 1500 / Math . log ( getRenown ( ) + 2 ) ) ) == 0 ) { addSponsor ( ) ; } if ( getRenown ( ) <= 0 ) { showWindow ( null , new GameOverWindow ( ) ) ; } if ( r . nextInt ( DIFFICULTY ) == 0 ) { setRenown ( getRenown ( ) - 1 ) ; } if ( firstTick ) showWindow ( null , new HelpWindow ( ) ) ; firstTick = false ; }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	5	public static boolean interactSlot ( int slot , String action ) { if ( ! checkIndex ( slot ) || ! setExpanded ( true ) ) return false ; if ( action == null || action . length ( ) == 0 ) return useSlot ( slot ) ; WidgetChild child = getMainChild ( slot ) ; if ( child . visible ( ) ) { return child . interact ( action ) ; } return false ; }
tr	9X	private int get_next_page ( Page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return OV_FALSE ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return OV_FALSE ; int ret = get_data ( ) ; if ( ret == 0 ) return OV_EOF ; if ( ret < 0 ) return OV_EREAD ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
tr	6	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	4	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	0	public void run ( ) { txtComponent . select ( pos , pos2 ) ; }
tr	5	public void addNodes ( ArrayList < BusLabel > busesLabel , ArrayList < StationLabel > stationsLabel , ArrayList < SemaphoreLabel > semaphoresLabel , int num ) { int iconHeightMid = 0 ; int iconWidthMid = 0 ; int iconHeight = 0 ; int iconWidth = 0 ; if ( num == 1 ) { removeAll ( ) ; } for ( BusLabel busLabel : busesLabel ) { iconHeight = busLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = busLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; busLabel . setBounds ( busLabel . getX ( ) - iconWidthMid , BUSES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( busLabel ) ; } for ( SemaphoreLabel semaphoreLabel : semaphoresLabel ) { iconHeight = semaphoreLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = semaphoreLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; if ( semaphoreLabel . getBounds ( ) . y > 100 ) { System . out . println ( semaphoreLabel . getSemaphore ( ) . getId ( ) ) ; } semaphoreLabel . setBounds ( semaphoreLabel . getX ( ) - iconWidthMid , SEMAPHORES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( semaphoreLabel ) ; } for ( StationLabel stationLabel : stationsLabel ) { iconHeight = stationLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = stationLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; stationLabel . setBounds ( stationLabel . getX ( ) - iconWidthMid , STATIONS_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( stationLabel ) ; } repaint ( ) ; }
tr	7	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
tr	2	public String pedidoPorCliente ( Cliente cliente ) { String retorno = "" ; for ( Pedido p : lista ) { if ( p . getCliente ( ) . getCodigo ( ) == cliente . getCodigo ( ) ) retorno += p . toString ( ) ; } return retorno ; }
tr	5	private String generateRandomId ( ) { StringBuilder sb = new StringBuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idLength ) { char ch = ( char ) rnd . nextInt ( ) ; if ( Utils . isUriLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containsKey ( sb . toString ( ) ) ) { sb . delete ( 0 , idLength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > RETRY_COUNT ) ; return sb . toString ( ) ; }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	0	private void restartGame ( ) { gameChooser . changeGameState ( GameState . INITIALIZING ) ; changedGame = gameChooser ; }
tr	1	public void testService ( ) throws Exception { System . out . println ( "locating service:osgi" ) ; int count = 0 ; for ( ServiceLocationEnumeration services = TestActivator . locator . findServices ( new ServiceType ( "service:osgi" ) , null , null ) ; services . hasMoreElements ( ) ; ) { assertEquals ( services . next ( ) . toString ( ) , "service:osgi://gantenbein:123" ) ; count ++ ; } assertEquals ( count , 1 ) ; }
tr	2	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	5	public synchronized boolean findSDSLInstances ( ) { knownSDSLInstances = new ArrayList < SDSL > ( ) ; boolean found = false ; ListIterator < Line > it = gct . getCodeLines ( ) . listIterator ( ) ; while ( it . hasNext ( ) ) { Line l = it . next ( ) ; if ( l . startsWith ( "28708ceb 000000" ) ) { Line [ ] code = new Line [ 4 ] ; code [ 0 ] = l ; code [ 1 ] = it . next ( ) ; if ( code [ 1 ] . startsWith ( "4A000000 90180F06" ) ) { code [ 2 ] = it . next ( ) ; if ( code [ 2 ] . startsWith ( "14000076 FF00" ) ) { code [ 3 ] = it . next ( ) ; if ( code [ 3 ] . startsWith ( "E0000000 80008000" ) ) { found = true ; SDSL sdsl = new SDSL ( code ) ; knownSDSLInstances . add ( sdsl ) ; gct . recordDynamicCode ( sdsl ) ; } } } } } return found ; }
tr	4	public void render ( Graphics g ) { i ++ ; if ( i >= 8 ) { animationStep ++ ; animationStep %= 9 ; image = sheet . getSprite ( "monster_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 5 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
tr	2	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
tr	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
tr	3	public static boolean isText ( int c ) { if ( isEnd ( c ) || isBreak ( c ) || isSpecial ( c ) ) return false ; return true ; }
tr	5	public final void mSL_COMMENT ( boolean _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { int _ttype ; Token _token = null ; int _begin = text . length ( ) ; _ttype = SL_COMMENT ; int _saveIndex ; match ( "//" ) ; { _loop594 : do { if ( ( _tokenSet_1 . member ( LA ( 1 ) ) ) ) { { match ( _tokenSet_1 ) ; } } else { break _loop594 ; } } while ( true ) ; } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	2	private static List < List < String >> clone ( List < List < String >> original ) { List < List < String >> clone = new ArrayList < List < String >> ( original . size ( ) ) ; for ( List < String > oStrings : original ) { List < String > cStrings = new ArrayList < String > ( oStrings . size ( ) ) ; for ( String oString : oStrings ) { cStrings . add ( oString ) ; } clone . add ( cStrings ) ; } return clone ; }
tr	3	private void compact ( ) { int from = 0 ; int to = 0 ; while ( from < this . capacity ) { Object key = this . list [ from ] ; long usage = age ( this . ticks [ from ] ) ; if ( usage > 0 ) { this . ticks [ to ] = usage ; this . list [ to ] = key ; this . map . put ( key , to ) ; to += 1 ; } else { this . map . remove ( key ) ; } from += 1 ; } if ( to < this . capacity ) { this . length = to ; } else { this . map . clear ( ) ; this . length = 0 ; } this . power = 0 ; }
tr	6	@ Override public void done ( ) { try { try { socket = get ( ) ; parent . updateStatus ( "Connected!" ) ; parent . parentFrame . addTab ( socket , parent . getNickname ( ) ) ; parent . dispose ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } catch ( java . util . concurrent . CancellationException e ) { closeSocket ( ) ; parent . updateStatus ( "Cancelled." ) ; } catch ( java . util . concurrent . ExecutionException e ) { closeSocket ( ) ; String why = null ; Throwable cause = e . getCause ( ) ; if ( cause != null ) { why = cause . getMessage ( ) ; if ( cause instanceof UnknownHostException ) { why = "Unknown host " + why ; } else if ( cause instanceof SocketTimeoutException ) { why = "Connection timed out" ; } } else { why = e . getMessage ( ) ; } parent . updateStatus ( why ) ; } finally { connectButton . setEnabled ( true ) ; } }
tr	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
tr	3	@ Override public void dispell ( ) { for ( Modifier mod : mods ) { if ( mod . isDispellable ( ) ) { if ( mod . isTemporary ( ) ) { modTotal -= mod . getTotal ( ) ; } mods . remove ( mod ) ; } } }
tr	3	public void setRows ( int newRows ) { if ( newRows < 0 ) throw new IllegalArgumentException ( "number of rows cannot be negative" ) ; if ( newRows == 0 && cols == 0 ) throw new IllegalArgumentException ( "number of columns is already 0" ) ; this . rows = newRows ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Consulta_datos ( ) . setVisible ( true ) ; } } ) ; }
tr	6	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
tr	8	protected FileRequestResponseMessage handleResponse ( InputStream in ) throws UnsupportedEncodingException { FileRequestResponseMessage try_again = new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . TRY_AGAIN_LATER , 0 ) ; int probe_len = FileRequestResponseMessage . TYPE_FIELD . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not read response stream: '" + e . getMessage ( ) + "' - assuming 'NEVER TRY AGAIN'" ) ; return try_again ; } String responseHeader = new String ( buffer , Message . ENCODING ) . trim ( ) ; switch ( responseHeader . toUpperCase ( ) ) { case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "OK" : String str_expectedTransferVolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != Message . MESSAGE_SPERATOR ) if ( next == - 1 ) { Thread . sleep ( 500 ) ; } else { str_expectedTransferVolume += new String ( new byte [ ] { ( byte ) next } , Message . ENCODING ) ; } } catch ( IOException | InterruptedException e ) { logger . log ( Level . SEVERE , "Could not understand response header" ) ; transferState = TransferStatus . LostConnection ; closeSocket ( ) ; return null ; } try { long expectedTransferVolume = long . valueOf ( str_expectedTransferVolume ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . OK , expectedTransferVolume ) ; } catch ( NumberFormatException ex ) { logger . log ( Level . SEVERE , "Response contained invalid 'expected transfer volume' - assuming 'TRY AGAIN LATER'" ) ; return try_again ; } case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "TRY" : logger . log ( Level . INFO , "Received 'try again later from host'" ) ; return try_again ; case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "NEV" : logger . log ( Level . INFO , "Received 'never try agiain from host'" ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . NEVER_TRY_AGAIN , 0 ) ; default : logger . log ( Level . INFO , "Received garbage: '" + responseHeader + "'" ) ; return try_again ; } }
tr	8	private static List < Integer > quadraticCongruenceSimpleSolve ( int a , final int m ) { a = normalizeIntModulo ( a , m ) ; int testA = a ; int testM = m ; if ( isPowerOf2 ( m ) ) testM = m / 2 ; final List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < testM ; ++ i ) { if ( isPerfectSquare ( testA ) ) { final int x1 = ( int ) Math . sqrt ( testA ) ; if ( modPow ( x1 , 2 , m ) == a ) quadraticCongruenceSimpleFillSolution ( result , x1 , testM ) ; if ( result . size ( ) == 4 ) break ; } testA += testM ; } if ( ! result . isEmpty ( ) ) { Collections . sort ( result ) ; result . add ( testM ) ; if ( ( result . size ( ) == 5 ) && ( m % 2 == 0 ) ) return binomialCongruenceRuleOut ( result ) ; } return result ; }
tr	5	public boolean isIsAndOrSentenceHelper ( List < String > words , String sentencePtn , String ptn1 , String ptn2 ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.isIsAndOrSentence" ) ; sentencePtn = sentencePtn . toLowerCase ( ) ; sentencePtn = sentencePtn . replaceAll ( "t" , "m" ) ; Pattern p1 = Pattern . compile ( ptn1 ) ; Matcher m1 = p1 . matcher ( sentencePtn ) ; Pattern p2 = Pattern . compile ( ptn2 ) ; Matcher m2 = p2 . matcher ( sentencePtn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { String matchedWords = StringUtils . join ( words . subList ( 0 , end ) , " " ) ; String regex = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( matchedWords , regex ) ) { myLogger . trace ( "Case 1" ) ; return false ; } myLogger . trace ( "Case 2" ) ; return true ; } myLogger . trace ( "Case 3" ) ; return false ; }
tr	2	static public void ReInit ( java . io . InputStream stream , String encoding ) { try { jj_input_stream . ReInit ( stream , encoding , 1 , 1 ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) jj_la1 [ i ] = - 1 ; }
tr	9X	public void setCurrentVar ( int mag_idx ) { assert ( mag_idx >= - 1 && mag_idx < PaneData . magnetList . size ( ) ) ; setVisible ( false ) ; this . removeAll ( ) ; this . mag_idx = mag_idx ; if ( mag_idx == - 1 ) { log . severe ( "Magnet Pane - Magnet unselected." ) ; setVisible ( true ) ; return ; } Magnet mag = ( Magnet ) PaneData . magnetList . get ( mag_idx ) ; String mag_name = mag . getMagnetName ( ) ; for ( int i = 0 ; i < PaneData . var_names . size ( ) ; i ++ ) { String var_name = ( String ) PaneData . var_names . get ( i ) ; if ( var_name . equalsIgnoreCase ( mag_name ) ) { this . var_idx = i ; break ; } } log . severe ( "Magnet Pane - [" + PaneData . var_names . get ( var_idx ) + "] is selected." ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; setLayout ( new GridBagLayout ( ) ) ; constraints . fill = GridBagConstraints . BOTH ; strMeasure = ( String ) PaneData . var_measures . get ( var_idx ) ; strType = ( String ) PaneData . var_types . get ( var_idx ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; assert PaneData . values_min . get ( var_idx ) instanceof Integer ; assert PaneData . values_max . get ( var_idx ) instanceof Integer ; int min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; chkboxList = new JCheckBox [ max - min + 1 ] ; ArrayList repelList = mag . getRepelList ( ) ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( var_idx ) ; chkboxList [ i ] = new JCheckBox ( label . get ( min + i ) + " (" + Integer . toString ( min + i ) + ")" ) ; if ( repelList == null ) chkboxList [ i ] . setSelected ( false ) ; else chkboxList [ i ] . setSelected ( ( ( boolean ) repelList . get ( i ) ) . booleanValue ( ) ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.05 ; constraints . gridx = 0 ; constraints . gridy = 3 + i ; add ( chkboxList [ i ] , constraints ) ; } } else if ( strMeasure . equals ( "Q" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; double threshold = new double ( mag . getThreshold ( ) ) ; if ( strType . equals ( "I" ) ) { int min , max ; min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , min , max , threshold . intValue ( ) ) ; sliderRepel . setMinorTickSpacing ( ( max - min ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( max - min ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; } else if ( strType . equals ( "D" ) ) { double dmin , dmax ; dmin = ( ( double ) PaneData . values_min . get ( var_idx ) ) . doubleValue ( ) ; dmax = ( ( double ) PaneData . values_max . get ( var_idx ) ) . doubleValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , dmin , dmax , threshold . doubleValue ( ) , 1 ) ; sliderRepel . setMinorTickSpacing ( ( dmax - dmin ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( dmax - dmin ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getDoubleValue ( ) + "]" ) ; } } ) ; } else { assert false ; } constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 3 ; add ( sliderRepel , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	9X	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
tr	7	private void clear ( ) { if ( zooKeeper != null ) { if ( leaderOffer != null && zooKeeper . getState ( ) . isAlive ( ) ) { try { zooKeeper . delete ( leaderOffer . getOffer ( ) , - 1 ) ; LOG . debug ( "Removed leader candidate {}" , leaderOffer ) ; } catch ( InterruptedException e ) { failed ( e ) ; } catch ( KeeperException e ) { failed ( e ) ; } if ( leaderElectionAware != null ) { leaderElectionAware . onClosed ( leaderOffer ) ; } leaderOffer = null ; } try { zooKeeper . close ( ) ; } catch ( InterruptedException e ) { failed ( e ) ; } finally { zooKeeper = null ; } } }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . suit . equals ( leadSuit ) && o2 . suit . equals ( leadSuit ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . suit . equals ( leadSuit ) ) { return 1 ; } else if ( o2 . suit . equals ( leadSuit ) ) { return - 1 ; } else { return 0 ; } } }
tr	6	public void paintComponent ( Graphics g2 ) { int w = getWidth ( ) ; int h = getHeight ( ) ; if ( ( img == null ) || ( img . getWidth ( null ) != w ) || ( img . getHeight ( null ) != h ) ) { img = createImage ( w , h ) ; Graphics g = img . getGraphics ( ) ; for ( int x = 0 ; x <= w / 524 ; x ++ ) { for ( int y = 0 ; y <= h / 524 ; y ++ ) g . drawImage ( bgImage , x * 524 , y * 524 , null ) ; } if ( ( g instanceof Graphics2D ) ) { Graphics2D gg = ( Graphics2D ) g ; } g . dispose ( ) ; } g2 . drawImage ( img , 0 , 0 , w , h , null ) ; }
tr	1	public < T > T getInstance ( class < T > c , String [ ] args ) throws Exception { AnnotatedConstructor ctor = ctors . get ( c ) ; AnnotatedCLI . ParsedCLI cli = parse ( args ) ; T obj ; if ( ctor != null ) { obj = ( T ) ctor . newInstance ( cli ) ; } else { obj = ( T ) c . newInstance ( ) ; } cli . inject ( obj ) ; return obj ; }
tr	2	public void select ( ) { switch ( current ) { case 0 : case 1 : } }
tr	7	public String reverseWords ( String s ) { if ( s . length ( ) == 0 ) return s ; String [ ] arr = s . split ( " " ) ; ArrayList < String > aa = new ArrayList < String > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; String ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
tr	1	public void onUnitDestroy ( Unit unit ) { if ( eventListener != null ) { eventListener . onUnitDestroy ( unit ) ; } }
tr	5	public void edit ( Expending expending ) throws NonexistentEntityException { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; expending = em . merge ( expending ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { Integer id = expending . getId ( ) ; if ( findExpending ( id ) == null ) { throw new NonexistentEntityException ( Constant . NON_EXISTS_ERROR_MSG ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
tr	5	public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Card ) ) return false ; Card aCard = ( Card ) o ; if ( ( aCard . suitID == this . suitID ) && ( aCard . nonTrumpCardValue == this . nonTrumpCardValue ) && ( aCard . trumpCardValue == this . trumpCardValue ) ) return true ; return false ; }
tr	7	public void brake ( double delta ) { if ( brakeFriction > 0 ) { if ( xa > 0 ) { xa = xa - ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } else if ( xa < 0 ) { xa = xa + ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } if ( xa <= 1 && xa >= - 1 ) { xa = 0.0 ; } } }
tr	2	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; if ( filterByID ( spg . getSquareNeighbors ( x , y , 1 ) , juggernaut . id ) . isEmpty ( ) ) { Location loc = spg . getFirstSquareNeighborLocation ( x , y , 2 , zombie . id ) ; spg . moveEntity ( x , y , loc == null ? Location . wander ( x , y , 1 ) : Location . away ( x , y , loc , 2 ) ) ; } }
tr	8	public static Application parseApplicationDescription ( JSONObject topJson , boolean store ) throws DBException { try { JSONObject appJson ; appJson = topJson . getJSONObject ( "application" ) ; if ( ! appJson . has ( "USER_id" ) ) { appJson . put ( "USER_id" , ( User . getByName ( appJson . getString ( "USER_name" ) ) ) . getId ( ) ) ; } Application app = new Application ( appJson ) ; if ( store ) app . store ( ) ; LOG . debug ( "loading description for app:" + app . getDescription ( ) ) ; JSONArray modules = appJson . getJSONArray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { JSONObject m = modules . getJSONObject ( i ) ; m . put ( "APPLICATION_id" , app . getId ( ) ) ; Module module = new Module ( m ) ; if ( store ) module . store ( ) ; LOG . debug ( "parsed Module:" + module ) ; JSONArray components = m . getJSONArray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { JSONObject c = components . getJSONObject ( j ) ; c . put ( "MODULE_id" , "" + module . getId ( ) ) ; if ( ! c . has ( "RESOURCE_TYPE_id" ) ) { ResourceType rt = ResourceType . getByName ( c . getString ( "resource_type" ) ) ; c . put ( "RESOURCE_TYPE_id" , rt . getId ( ) ) ; } Component component = new Component ( c ) ; if ( store ) component . store ( ) ; LOG . debug ( "parsed component: " + component ) ; } } return app ; } catch ( JSONException ex ) { System . err . println ( "parsing not successfull" ) ; ex . printStackTrace ( ) ; } return null ; }
tr	5	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	6	@ Override public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Update other = ( Update ) obj ; if ( version == null ) { if ( other . version != null ) { return false ; } } else if ( ! version . equals ( other . version ) ) { return false ; } return true ; }
tr	7	protected void addPointToHull ( Vertex eyeVtx ) { horizon . clear ( ) ; unclaimed . clear ( ) ; if ( debug ) { System . out . println ( "Adding point: " + eyeVtx . pnt . toString ( ) ) ; System . out . println ( " which is " + eyeVtx . face . distanceToPlane ( eyeVtx . pnt ) + " above face " + eyeVtx . face . getVertexString ( ) ) ; } removePointFromFace ( eyeVtx , eyeVtx . face ) ; calculateHorizon ( eyeVtx . pnt , null , eyeVtx . face , horizon ) ; newFaces . clear ( ) ; addNewFaces ( newFaces , eyeVtx , horizon ) ; for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . VISIBLE ) { while ( doAdjacentMerge ( face , NONCONVEX_WRT_LARGER_FACE ) ) ; } } for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . NON_CONVEX ) { face . mark = Face . VISIBLE ; while ( doAdjacentMerge ( face , NONCONVEX ) ) ; } } resolveUnclaimedPoints ( newFaces ) ; }
tr	3	public void updateUser ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	2	public void convert ( Ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . Comment unfuddleComment : ticket . getComments ( ) ) { String username = null ; Person p = provider . getPeopleConverter ( ) . findPersonById ( unfuddleComment . getAuthorId ( ) ) ; if ( null == p ) { System . out . println ( "Warning: the comment-author with id '" + unfuddleComment . getAuthorId ( ) + "' could not be found in the input file. Using 'null'." ) ; } else { username = p . getName ( ) ; } Comment comment = new Comment ( unfuddleComment . getBody ( ) , unfuddleComment . getCreatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , getUniqueCommentId ( ) , ticket . getId ( ) , ticket . getUpdatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , username ) ; comments . add ( comment ) ; } }
tr	4	public synchronized void unbind ( String name ) { if ( registry == null ) throw new IllegalStateException ( "registry not active" ) ; try { registry . unbind ( name ) ; } catch ( NotBoundException e ) { } catch ( Exception e ) { if ( ! ( e instanceof RuntimeException ) ) e = new RuntimeException ( "unexpected exception in " + "SimpleObjectRegistry.unbind: " + e ) ; throw ( RuntimeException ) e ; } }
tr	2	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	8	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	9X	public void helper ( String s , int count ) { if ( count == 3 ) { if ( s . charAt ( 0 ) == 0 && s . length ( ) > 1 ) return ; if ( s . length ( ) > 3 ) { int hh = 0 ; while ( s . length ( ) - hh > 3 ) { if ( s . charAt ( hh ) != 0 ) return ; hh ++ ; } } if ( Integer . parseInt ( s ) > 255 ) return ; else { temp . add ( s ) ; String ss = "" ; for ( int i = 0 ; i < 4 ; i ++ ) { ss = ss + "." + temp . get ( i ) ; } ss = ss . substring ( 1 ) ; ret . add ( ss ) ; temp . remove ( temp . size ( ) - 1 ) ; } } else { for ( int i = 0 ; i < s . length ( ) - 3 + count ; i ++ ) { if ( Integer . parseInt ( s . substring ( 0 , i + 1 ) ) > 255 ) break ; temp . add ( s . substring ( 0 , i + 1 ) ) ; helper ( s . substring ( i + 1 , s . length ( ) ) , count + 1 ) ; temp . remove ( temp . size ( ) - 1 ) ; if ( s . charAt ( 0 ) == 0 ) break ; } } }
tr	9X	private void drawMenu ( ) { int i = menuOffsetX ; int j = menuOffsetY ; int k = menuWidth ; int l = menuHeight + 1 ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 706a5e , menuWidth , menuOffsetX ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 706a5e , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY , menuHeight , 200 , 706a5e , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 2d2822 , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 2d2822 , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 3 , menuHeight - 6 , 250 , 2d2822 , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY + 19 , menuHeight - 22 , 250 , 524a3d , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 20 , menuHeight - 22 , 250 , 524a3d , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 2a291b , menuOffsetY + 2 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a261b , menuOffsetY + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 252116 , menuOffsetY + 4 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 211e15 , menuOffsetY + 5 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1e1b12 , menuOffsetY + 6 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1a170e , menuOffsetY + 7 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 2 , 15120b , menuOffsetY + 8 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 100d08 , menuOffsetY + 10 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 11 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 080703 , menuOffsetY + 12 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 13 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 14 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 15 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 16 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 17 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a291b , menuOffsetY + 18 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 564943 , menuOffsetY + 19 ) ; chatTextDrawingArea . method385 ( c6b895 , "Choose Option" , menuOffsetY + 14 , menuOffsetX + 3 ) ; int j1 = super . mouseX ; int k1 = super . mouseY ; if ( menuScreenArea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuScreenArea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuScreenArea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuScreenArea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuActionRow ; l1 ++ ) { int i2 = j + 31 + ( menuActionRow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { DrawingArea . drawPixels ( 15 , i2 - 11 , i + 3 , 26566C , menuWidth - 6 ) ; j2 = eee5c6 ; } chatTextDrawingArea . method389 ( true , i + 4 , AAA184 , menuActionName [ l1 ] , i2 + 1 ) ; } }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	1	synchronized public String getString ( ) { try { wait ( ) ; } catch ( InterruptedException e ) { } return napis ; }
tr	2	public static int foul ( TeamMatch match ) { int x = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof Points . FoulPoints ) { x += p . getPoints ( ) ; } } return x ; }
tr	8	public static boolean hasAtLeastOneMethodWithName ( class < ? > clazz , String methodName ) { assert . notNull ( clazz , "Class must not be null" ) ; assert . notNull ( methodName , "Method name must not be null" ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; for ( Method method : declaredMethods ) { if ( method . getName ( ) . equals ( methodName ) ) { return true ; } } class < ? > [ ] ifcs = clazz . getInterfaces ( ) ; for ( class < ? > ifc : ifcs ) { if ( hasAtLeastOneMethodWithName ( ifc , methodName ) ) { return true ; } } return ( clazz . getSuperclass ( ) != null && hasAtLeastOneMethodWithName ( clazz . getSuperclass ( ) , methodName ) ) ; }
tr	1	private void checkLevel ( ) { if ( Console . getDebugMode ( ) ) setLevel ( Level . ALL ) ; else setLevel ( Level . INFO ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Window3 ( ) . setVisible ( true ) ; } } ) ; }
tr	6	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { SearchCustomerName form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; Transaction . begin ( ) ; int customer_id = customerDAO . getCustomerId ( form . getUsername ( ) ) ; CustomerBean cb = customerDAO . getCustomerInfo ( customer_id ) ; if ( ! form . isPresent ( ) ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } CustomerBean customer = ( CustomerBean ) request . getAttribute ( "userName" ) ; request . setAttribute ( "customer" , cb ) ; HttpSession session = request . getSession ( ) ; session . setAttribute ( "customer" , cb ) ; Transaction . commit ( ) ; return "e_reset-pfc.do" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_reset-pwd.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	9X	protected void downloadJars ( String path ) throws Exception { File versionFile = new File ( path , "md5s" ) ; Properties md5s = new Properties ( ) ; if ( versionFile . exists ( ) ) { try { FileInputStream fis = new FileInputStream ( versionFile ) ; md5s . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } state = 4 ; int [ ] fileSizes = new int [ urlList . length ] ; boolean [ ] skip = new boolean [ urlList . length ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; urlconnection . setDefaultUseCaches ( false ) ; skip [ i ] = false ; if ( ( urlconnection instanceof HttpURLConnection ) ) { ( ( HttpURLConnection ) urlconnection ) . setRequestMethod ( "HEAD" ) ; int code = ( ( HttpURLConnection ) urlconnection ) . getResponseCode ( ) ; if ( code / 100 == 3 ) { skip [ i ] = true ; } } fileSizes [ i ] = urlconnection . getContentLength ( ) ; totalSizeDownload += fileSizes [ i ] ; } int initialPercentage = this . percentage = 10 ; byte [ ] buffer = new byte [ 65536 ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { if ( skip [ i ] != false ) { percentage = ( initialPercentage + fileSizes [ i ] * 45 / totalSizeDownload ) ; } boolean downloadFile = true ; while ( downloadFile ) { downloadFile = false ; URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; String etag = "" ; if ( ( urlconnection instanceof HttpURLConnection ) ) { urlconnection . setRequestProperty ( "Cache-Control" , "no-cache" ) ; urlconnection . connect ( ) ; etag = urlconnection . getHeaderField ( "ETag" ) ; } String currentFile = getFileName ( urlList [ i ] ) ; InputStream inputstream = getJarInputStream ( currentFile , urlconnection ) ; FileOutputStream fos = new FileOutputStream ( path + currentFile ) ; long downloadStartTime = System . currentTimeMillis ( ) ; int downloadedAmount = 0 ; int fileSize = 0 ; String downloadSpeedMessage = "" ; MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; int bufferSize ; while ( ( bufferSize = inputstream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bufferSize ) ; m . update ( buffer , 0 , bufferSize ) ; currentSizeDownload += bufferSize ; fileSize += bufferSize ; percentage = ( initialPercentage + currentSizeDownload * 45 / totalSizeDownload ) ; subtaskMessage = ( "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%" ) ; downloadedAmount += bufferSize ; long timeLapse = System . currentTimeMillis ( ) - downloadStartTime ; if ( timeLapse >= 1000 ) { float downloadSpeed = downloadedAmount / ( float ) timeLapse ; downloadSpeed = ( int ) ( downloadSpeed * 100.0F ) / 100.0F ; downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec" ; downloadedAmount = 0 ; downloadStartTime += 1000 ; } subtaskMessage += downloadSpeedMessage ; } inputstream . close ( ) ; fos . close ( ) ; } } }
tr	6	private boolean skipComment ( ) throws IOException { char cc = _next ( ) ; if ( cc != * ) { putback ( cc ) ; return false ; } int lineno = getLine ( ) ; while ( ( cc = _next ( ) ) != EOF ) { if ( cc == * ) { cc = _next ( ) ; if ( cc == / ) return true ; if ( cc == * ) putback ( cc ) ; if ( cc == EOF ) break ; } } throw error ( "unclosed comment" , _lineno ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	8	private void writeJSON ( Object value ) throws JSONException { if ( JSONObject . null . equals ( value ) ) { write ( zipNull , 3 ) ; } else if ( boolean . false . equals ( value ) ) { write ( zipFalse , 3 ) ; } else if ( boolean . true . equals ( value ) ) { write ( zipTrue , 3 ) ; } else { if ( value instanceof Map ) { value = new JSONObject ( ( Map ) value ) ; } else if ( value instanceof Collection ) { value = new JSONArray ( ( Collection ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { value = new JSONArray ( value ) ; } if ( value instanceof JSONObject ) { writeObject ( ( JSONObject ) value ) ; } else if ( value instanceof JSONArray ) { writeArray ( ( JSONArray ) value ) ; } else { throw new JSONException ( "Unrecognized object" ) ; } } }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	1	public void clearFeedback ( ) { for ( ValueSource vs : valueSources ) { vs . clearFeedback ( ) ; } }
tr	9X	private boolean applyDistributiveLaw ( IExpressionContext context , ASTNode result ) { final TreeMatcher matcher = new TreeMatcher ( ) . ignoreChildOrder ( true ) . requireNodeToHaveParent ( true ) . unwrapAll ( ) . matchParent ( ) . matchAND ( ) . matchOR ( ) . buildOR ( ) . matchRightChild ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { final ASTNode unwrapped = unwrap ( matcher . parentMatch ( ) ) ; if ( unwrapped . isOR ( ) ) { return n . isAND ( ) ; } if ( unwrapped . isAND ( ) ) { return n . isOR ( ) ; } throw new RuntimeException ( "Unreachable code reached" ) ; } } ) . buildOR ( ) . matchExtra ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { return matcher . leftMatch ( ) . getNodeCount ( ) != matcher . rightMatch ( ) . getNodeCount ( ) ; } } ) . buildOR ( ) ; final MutatingNodeVisitor visitor = new MutatingNodeVisitor ( context ) { @ Override public void visit ( ASTNode node , IExpressionContext context , IIterationContext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final ASTNode matchedParent = matcher . parentMatch ( ) ; final ASTNode leftChild = matcher . leftMatch ( ) ; final ASTNode rightChild = matcher . rightMatch ( ) ; final ASTNode leftTerm ; final ASTNode rightTerm ; final ASTNode replacementTerm ; ASTNode unwrappedRight = unwrap ( rightChild ) ; if ( unwrap ( matchedParent ) . isAND ( ) && unwrappedRight . isOR ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . or ( leftTerm , rightTerm ) ; } else if ( unwrap ( matchedParent ) . isOR ( ) && unwrappedRight . isAND ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . and ( leftTerm , rightTerm ) ; } else { throw new RuntimeException ( "Unreachable code reached => " + matcher ) ; } ASTNode toReplace = matchedParent ; if ( ! toReplace . hasParent ( ) ) { if ( unwrap ( toReplace ) != toReplace ) { toReplace = unwrap ( toReplace ) ; } else { throw new RuntimeException ( "Unreachable code reached" ) ; } } debugPrintln ( "DISTRIBUTIVE LAW: Replacing " + matchedParent . toString ( false ) + " -> " + replacementTerm ) ; toReplace . replaceWith ( replacementTerm ) ; it . astMutated ( ) ; } } ; return applyInOrder ( result , visitor ) ; }
tr	8	private void initContent ( ) { setBounds ( 100 , 100 , 450 , 306 ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; contentPanel . setLayout ( null ) ; lblName = new JLabel ( "Name:" ) ; lblName . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblName . setBounds ( 21 , 22 , 86 , 20 ) ; contentPanel . add ( lblName ) ; lblLevel = new JLabel ( "Level:" ) ; lblLevel . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblLevel . setBounds ( 21 , 51 , 86 , 20 ) ; contentPanel . add ( lblLevel ) ; { lblCapacity = new JLabel ( "Capacity:" ) ; lblCapacity . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblCapacity . setBounds ( 21 , 82 , 86 , 20 ) ; contentPanel . add ( lblCapacity ) ; } { lblStudentAge = new JLabel ( "Student Age:" ) ; lblStudentAge . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblStudentAge . setBounds ( 21 , 113 , 86 , 20 ) ; contentPanel . add ( lblStudentAge ) ; } { lblTeacher = new JLabel ( "Teacher(s):" ) ; lblTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblTeacher . setBounds ( 21 , 144 , 86 , 20 ) ; contentPanel . add ( lblTeacher ) ; } { panel_1 = new JPanel ( ) ; panel_1 . setBorder ( new TitledBorder ( UIManager . getBorder ( "TitledBorder.border" ) , "Schedule" , TitledBorder . LEADING , TitledBorder . TOP , null , new Color ( 0 , 0 , 0 ) ) ) ; panel_1 . setBounds ( 277 , 6 , 155 , 158 ) ; contentPanel . add ( panel_1 ) ; panel_1 . setLayout ( null ) ; JButton btnAdd = new JButton ( "Add" ) ; btnAdd . setFocusTraversalKeysEnabled ( false ) ; btnAdd . setFocusable ( false ) ; btnAdd . setFocusPainted ( false ) ; btnAdd . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnAdd . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnAdd . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnAdd . setBounds ( 10 , 13 , 67 , 23 ) ; btnAdd . setIcon ( StaticRes . ADD16_ICON ) ; btnAdd . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ScheduleSelectDialog ssd ; try { Group_schedule group_schedule = new Group_schedule ( ) ; group_schedule . setGroup ( group . getId ( ) ) ; ssd = new ScheduleSelectDialog ( null , "Schedule for " + group . getName ( ) , ModalityType . DOCUMENT_MODAL , GroupsDialog . this , group_schedule ) ; ssd . setVisible ( true ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } ) ; panel_1 . add ( btnAdd ) ; DefaultListModel listModel = new DefaultListModel ( ) ; for ( Group_schedule obj : this . schedule_list ) { listModel . addElement ( obj ) ; } list = new JList ( listModel ) ; list . setVisibleRowCount ( 5 ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . setCellRenderer ( new ListCellRenderer ( ) { protected DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer ( ) ; @ Override public Component getListCellRendererComponent ( JList list , Object o , int i , boolean selected , boolean cellHasFocus ) { JLabel label = ( JLabel ) defaultRenderer . getListCellRendererComponent ( list , o , i , selected , cellHasFocus ) ; Group_schedule gschedule = ( Group_schedule ) o ; label . setText ( gschedule . getName ( ) ) ; return label ; } } ) ; list . setBounds ( 10 , 40 , 135 , 107 ) ; panel_1 . add ( list ) ; JButton btnRemove = new JButton ( "Remove" ) ; btnRemove . setBounds ( 78 , 13 , 67 , 23 ) ; btnRemove . setFocusTraversalKeysEnabled ( false ) ; btnRemove . setFocusable ( false ) ; btnRemove . setFocusPainted ( false ) ; btnRemove . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnRemove . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnRemove . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnRemove . setIcon ( StaticRes . DELETE16_ICON ) ; btnRemove . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { int index = list . getSelectedIndex ( ) ; Group_schedule gschedule = ( Group_schedule ) list . getSelectedValue ( ) ; if ( index >= 0 ) { ( ( DefaultListModel ) list . getModel ( ) ) . removeElement ( gschedule ) ; lblDispTeacher . setText ( getTeacher ( getTeacherFromList ( ) ) ) ; } } } ) ; panel_1 . add ( btnRemove ) ; } txtName = new JTextField ( ) ; txtName . setBounds ( 117 , 24 , 150 , 20 ) ; txtName . setText ( this . name ) ; contentPanel . add ( txtName ) ; txtName . setColumns ( 10 ) ; { txtCapacity = new JTextField ( ) ; txtCapacity . setColumns ( 10 ) ; txtCapacity . setText ( String . valueOf ( this . capacity ) ) ; txtCapacity . setBounds ( 117 , 84 , 150 , 20 ) ; txtCapacity . addKeyListener ( new KeyAdapter ( ) { public void keyTyped ( KeyEvent ke ) { char c = ke . getKeyChar ( ) ; if ( ! Character . isDigit ( c ) ) ke . consume ( ) ; } } ) ; contentPanel . add ( txtCapacity ) ; } LevelDAO lDAO = new LevelDAO ( db . connection ) ; cbLevel = new JComboBox ( ) ; if ( this . level_id < 1 ) { Level l = new Level ( ) ; l . setName ( "Select level" ) ; l . setId ( 0 ) ; cbLevel . addItem ( l ) ; } List < Level > levelList = lDAO . getLevelList ( ) ; for ( Level level : levelList ) { cbLevel . addItem ( level ) ; if ( level . getId ( ) == this . level_id ) { cbLevel . setSelectedItem ( level ) ; } } cbLevel . setRenderer ( new ComboBoxRenderer ( ) ) ; cbLevel . setBounds ( 117 , 53 , 150 , 20 ) ; contentPanel . add ( cbLevel ) ; cbStudentAge = new JComboBox ( ) ; cbStudentAge . setBounds ( 117 , 115 , 150 , 20 ) ; contentPanel . add ( cbStudentAge ) ; lblDispTeacher = new JLabel ( getTeacher ( getTeacherFromList ( ) ) ) ; lblDispTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblDispTeacher . setBounds ( 117 , 144 , 150 , 20 ) ; contentPanel . add ( lblDispTeacher ) ; { panel = new JPanel ( ) ; panel . setBorder ( UIManager . getBorder ( "MenuBar.border" ) ) ; FlowLayout flowLayout = ( FlowLayout ) panel . getLayout ( ) ; flowLayout . setAlignment ( FlowLayout . LEFT ) ; getContentPane ( ) . add ( panel , BorderLayout . NORTH ) ; { lblGroup = new JLabel ( "Group" ) ; lblGroup . setFont ( new Font ( "Tahoma" , Font . PLAIN , 18 ) ) ; lblGroup . setIcon ( StaticRes . GROUP48_ICON ) ; panel . add ( lblGroup ) ; } } { JPanel buttonPane = new JPanel ( ) ; buttonPane . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; getContentPane ( ) . add ( buttonPane , BorderLayout . SOUTH ) ; { JButton okButton = new JButton ( "OK" ) ; okButton . setIcon ( StaticRes . OK_ICON ) ; okButton . setActionCommand ( "OK" ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "OK Clicked!" ) ; if ( checkAndSaveGroup ( ) ) { dispose ( ) ; result . returnObject ( GroupsDialog . this . group ) ; } else { } } } ) ; buttonPane . add ( okButton ) ; getRootPane ( ) . setDefaultButton ( okButton ) ; } { JButton cancelButton = new JButton ( "Cancel" ) ; cancelButton . setActionCommand ( "Cancel" ) ; cancelButton . setIcon ( StaticRes . CANCEL_ICON ) ; cancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "Cancel Clicked!" ) ; dispose ( ) ; } } ) ; buttonPane . add ( cancelButton ) ; } } }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( JOptionPane . showConfirmDialog ( frame , "Are you sure to close this window?" , "Really Closing?" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { btn . setEnabled ( true ) ; } }
tr	0	public String getName ( ) { return getClass ( ) . getName ( ) ; }
tr	3	private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == a ? "Misplaced endArray." : "Misplaced endObject." ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . , = true ; return this ; }
tr	9X	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	1	public String toString ( ) { StringBuilder out = new StringBuilder ( ) ; for ( ArrayPlace arrayPlace : arrayPlaces ) out . append ( arrayPlace ) . append ( "=" ) ; out . append ( expression ) ; return out . toString ( ) ; }
tr	7	@ Override public void notificarCicloFinalizado ( ) { Tablero tablero = this . vp . obtenerTablero ( ) ; GameLoop gameLoop = this . vp . obtenerGameLoop ( ) ; ArrayList < Barco > listaBarco = tablero . getDestruidos ( ) ; for ( Barco barco : listaBarco ) { for ( Parte parte : barco . getCuerpo ( ) ) { ObjetoDibujable vista = MapaDeVistasDePartes . get ( parte ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( parte ) ; } } } ArrayList < Disparo > listaDisparo = tablero . getDisparosDetonados ( ) ; for ( Disparo disparo : listaDisparo ) { ObjetoDibujable vista = MapaDeVistasDeDisparos . get ( disparo ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( disparo ) ; } } listaDisparo . clear ( ) ; this . vp . obtenerEtiquetaPuntaje ( ) . setText ( "Puntaje: " + tablero . getPuntos ( ) ) ; if ( tablero . estaPerdido ( ) ) { JOptionPane . showMessageDialog ( null , "Lamentablemente Usted Perdio" ) ; this . reiniciarTablero ( ) ; } else if ( tablero . estaGanado ( ) ) { JOptionPane . showMessageDialog ( null , "Gano!!!!" ) ; this . reiniciarTablero ( ) ; } }
tr	4	public boolean boundaryCheck ( Point point ) { if ( ( point . x > 0 ) && point . x < width ) { if ( ( point . y > 0 ) && point . y < height ) { return true ; } } return false ; }
tr	9X	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == Integer . MIN_VALUE && divisor == - 1 ) ) { return Integer . MAX_VALUE ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } while ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	9X	@ Override public void run ( ) { try { while ( Settling . this . running ) { Thread . sleep ( 1 ) ; } } catch ( InterruptedException e ) { } }
tr	1	public static String encripta ( String senha ) { try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( senha . getBytes ( ) ) ; BASE64Encoder encoder = new BASE64Encoder ( ) ; return encoder . encode ( digest . digest ( ) ) ; } catch ( NoSuchAlgorithmException ns ) { return senha ; } }
tr	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	3	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
tr	0	public void unsetName ( ) { this . name = null ; }
tr	2	private int validateProtocol ( ) throws IOException { int resp = this . sendDummyRequest ( ) ; if ( ! this . sc . isSecureConnection ( ) ) { this . sc . setSecureConnection ( true ) ; try { resp = this . sendDummyRequest ( ) ; } catch ( SSLException e ) { this . sc . setSecureConnection ( false ) ; } } return resp ; }
tr	2	public NewSplashScreen ( int maximumValue , Locale locMe ) { maxVal = maximumValue ; Logger log = LoggerFactory . getLogger ( "mars.mars.gui.NewSplashScreen" ) ; MarsResourceBundle mrbSplash = new MarsResourceBundle ( locMe ) ; textVal = mrbSplash . getRBString ( "mars.gui.splash.load" , "Loading..." ) ; log . finest ( "Splash Screen created for JSE 1.6 or higher  attempting to obtain the SplashScreen class." ) ; splash = SplashScreen . getSplashScreen ( ) ; if ( splash == null ) { log . finest ( "SplashScreen couldn't be obtained  must be running on pre 1.6." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.SplashScreenNotCompatible" , "Splash screen is null. May be running on JSE 1.5 or earlier." ) ) ; configured = false ; return ; } g = ( Graphics2D ) splash . createGraphics ( ) ; if ( g == null ) { log . finest ( "Graphics2D class could not be obtained  currently null." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.Graphics2DNotFound" , "Cannot obtain the Splash screen graphics2D class. It is currently null." ) ) ; configured = false ; return ; } }
tr	5	public void wc ( MainClass mc , Encounter e ) { int x = mc . getXPos ( ) ; int y = mc . getYPos ( ) ; int k = e . getKeyPress ( ) ; if ( x >= 300 && x <= 450 ) { if ( y >= 40 && y <= 140 ) { e . win = false ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } } else if ( k == 10 ) { e . win = false ; e . setKeyPress ( 0 ) ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	2	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
tr	6	public void advance ( ) { timeUntilNext -- ; if ( timeUntilNext <= 0 ) { stoppingAt ( ) ; if ( ! reverse && nextStation . getNext ( ) == null ) { reverse = true ; timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; return ; } if ( reverse && nextStation . getPrev ( ) == null ) { reverse = false ; timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; return ; } if ( reverse ) { timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; } else { timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; } } }
tr	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
tr	3	protected void fireTreeNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( e ) ; } } }
tr	0	public IntAdder ( JBlockingQueue < Integer > q ) { this . q = q ; }
tr	6	public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( m == n ) return head ; ListNode dumy = new ListNode ( 0 ) ; dumy . next = head ; ListNode pre = dumy ; ListNode cur = head ; ListNode tail = null ; ListNode start = null ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) { tail = cur ; start = pre ; start . next = cur . next ; pre = cur ; cur = cur . next ; } else if ( i > m && i < n ) { start . next = cur . next ; cur . next = pre ; pre = cur ; cur = start . next ; } else if ( i == n ) { tail . next = cur . next ; cur . next = pre ; } else { pre = cur ; cur = cur . next ; } } return dumy . next ; }
tr	3	private String getDifficultyName ( ) { if ( numHints < ( boardSegs * boardSegs ) + boardSegs ) return "diablolical" ; if ( numHints < boardWidth * 2 ) return "tough" ; if ( numHints < boardWidth * boardSegs ) return "moderate" ; return "gentle" ; }
tr	3	@ SuppressWarnings ( "unchecked" ) public T nextConcrete ( ) { T genObj = null ; try { initFieldGenerators ( ) ; genObj = ( T ) Utils . getDummyObject ( this . type ) ; Reflector r1 = new Reflector ( genObj ) ; Field [ ] fields = r1 . getFields ( genObj ) ; for ( Field f : fields ) { f . set ( genObj , fieldGenerators . get ( f ) . next ( ) ) ; } } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return genObj ; }
tr	8	public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > datos = new ArrayList < Integer > ( 100 ) ; int mayor = 0 ; System . out . println ( "Introduzca hasta 100 n\u00FAmeros ('q' para salir):" ) ; boolean fin = false ; while ( datos . size ( ) < 100 && ! fin ) { System . out . print ( ( datos . size ( ) + 1 ) + ": " ) ; String entrada = null ; try { entrada = reader . readLine ( ) ; } catch ( IOException ex ) { entrada = "q" ; } if ( entrada . equals ( "q" ) ) { fin = true ; } else { try { int num = Integer . parseInt ( entrada ) ; datos . add ( num ) ; if ( datos . size ( ) == 1 || num > mayor ) mayor = num ; } catch ( NumberFormatException ex ) { } } } System . out . println ( ) ; if ( datos . size ( ) == 0 ) System . out . println ( "\u00A1No ha introducido ning\u00FAn n\u00FAmero!" ) ; else System . out . println ( "El n\u00FAmero mayor es: " + mayor ) ; }
tr	6	public static Integer valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof byte ) { return ( int ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( Integer ) o ; } else if ( o instanceof double ) { return ( int ) ( double ) ( double ) o ; } else if ( o instanceof float ) { return ( int ) ( float ) ( float ) o ; } else if ( o instanceof long ) { return ( int ) ( long ) ( long ) o ; } else { return null ; } }
tr	9X	private void planForAgent ( Agent agent ) { TaskDispenser td = agent . td ; Node node = agent . node ; if ( agent . request != null ) { if ( agent . request . requestBox . atField == agent . request . requestGoal ) { agent . request = null ; } } if ( agent . taskQueue != null && agent . taskQueue . size ( ) > 0 && ( agent . taskQueue . peek ( ) . commandQueue == null || agent . taskQueue . peek ( ) . commandQueue . size ( ) == 0 ) ) { if ( agent . taskQueue . peek ( ) instanceof DockTask ) { DockTask t = ( DockTask ) agent . taskQueue . peek ( ) ; t . box . reserved = false ; t . moveBoxTo . reserved = false ; } agent . taskQueue . poll ( ) ; } if ( agent . taskQueue . size ( ) == 0 ) { agent . taskQueue . clear ( ) ; if ( agent . td . agents . size ( ) == 1 ) { agent . taskQueue . addAll ( td . newDispenseTaskForAgent ( agent ) ) ; } else { agent . taskQueue . addAll ( td . simpleDispenseTaskForAgent ( agent ) ) ; } } }
tr	4	private static int [ ] leeVector ( String mensaje , int longitud ) { int [ ] vector = new int [ longitud ] ; boolean valido = false ; while ( ! valido ) { System . out . print ( mensaje ) ; try { for ( int i = 0 ; i < longitud ; i ++ ) vector [ i ] = Coin . nextInt ( ) ; if ( Coin . hasNextLine ( ) ) Coin . nextLine ( ) ; valido = true ; } catch ( Exception ex ) { Coin . nextLine ( ) ; } } return vector ; }
tr	3	private void createNewKeyWithLoad ( BigInteger value , int load ) { if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( ! this . allKeys . add ( new Key ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	4	public static boolean intersects ( final IShape shape1 , final Vector3f vertex ) { simplex . clear ( ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , vertex , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS ) { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , vertex , v ) ; if ( v . . ( e . v ) > 0 ) { return false ; } if ( simplex . contains ( e . v ) ) break ; simplex . addElement ( ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } return true ; }
tr	3	@ Override public Connection getConnection ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { return connection ; } else { connection = DriverManager . getConnection ( "jdbc:hsqldb:file:" + db + ";shutdown=true" , user , pass ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return connection ; }
tr	9X	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { StringTokenizer st = new StringTokenizer ( sc . nextLine ( ) ) ; int nbrInts = Integer . parseInt ( st . nextToken ( ) ) ; if ( nbrInts <= 0 ) { System . out . println ( "Not jolly" ) ; continue ; } else if ( nbrInts == 1 ) { System . out . println ( "Jolly" ) ; continue ; } boolean [ ] data = new boolean [ nbrInts - 1 ] ; int prev = Integer . parseInt ( st . nextToken ( ) ) ; while ( st . hasMoreTokens ( ) ) { int curr = Integer . parseInt ( st . nextToken ( ) ) ; int absDiff = Math . abs ( prev - curr ) ; if ( absDiff > 0 && absDiff <= nbrInts - 1 ) { data [ absDiff - 1 ] = true ; } prev = curr ; } boolean isJolly = true ; for ( boolean b : data ) { if ( ! b ) { isJolly = false ; break ; } } if ( isJolly ) { System . out . println ( "Jolly" ) ; } else { System . out . println ( "Not jolly" ) ; } } }
tr	5	public void paintTriangle ( Graphics g , int x , int y , int size ) { for ( int i = 0 ; i < size ; i ++ ) { switch ( facing ) { case UP : g . drawLine ( x - i , y - size / 2 + i , x + i , y - size / 2 + i ) ; break ; case DOWN : g . drawLine ( x - i , y + size / 2 - i , x + i , y + size / 2 - i ) ; break ; case LEFT : g . drawLine ( x - size / 2 + i , y - i , x - size / 2 + i , y + i ) ; break ; case RIGHT : g . drawLine ( x + size / 2 - i , y - i , x + size / 2 - i , y + i ) ; break ; } } }
tr	5	public int getPerceptIndex ( String percept ) { if ( percept . equals ( SOLVED ) ) { return ( getPerceptsNumber ( ) - 1 ) ; } else { int [ ] values = new int [ 2 ] ; int k = 0 ; try { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( percept ) ) ; while ( k < 2 && tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . ttype == StreamTokenizer . TT_NUMBER ) { values [ k ] = ( int ) ( tokenizer . nval ) ; k ++ ; } } return values [ 0 ] * DIGITS + values [ 1 ] ; } catch ( Exception e ) { return - 1 ; } } }
tr	9X	String formatOption ( OptionMetadata metadata , CommandLineConfiguration config ) { String formattedOption = null ; if ( metadata . isParameterAccepted ( ) ) { boolean isParamRequired = ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . isRequired ( ) ) ; String paramDelim = StringUtil . formatDelimValue ( config . getCommandLineProperties ( ) . getOptionParameterDelim ( ) ) ; String paramUsageStr = "" ; if ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . getParameterType ( ) != ParameterType . NONE ) { String paramName = "" ; if ( metadata . getParameterMetadata ( ) . getParameterType ( ) == ParameterType . CUSTOM ) { paramName = metadata . getParameterMetadata ( ) . getIdentifier ( ) ; } else { paramName = metadata . getParameterMetadata ( ) . getParameterType ( ) . name ( ) ; } paramUsageStr = String . format ( ( isParamRequired ) ? "%s<%s>" : "[%s<%s>]" , paramDelim , paramName ) ; if ( metadata . isMultiValued ( ) ) { paramUsageStr += "..." ; } } String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) , paramUsageStr ) ; } else { formattedOption = String . format ( "%s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , paramUsageStr ) ; } } else { String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) ) ; } else { formattedOption = String . format ( "%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) ) ; } } return formattedOption ; }
tr	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	4	public static boolean checkBSTInOrderTraversal ( Node root ) { if ( root == null ) { return true ; } if ( ! checkBSTInOrderTraversal ( root . left ) ) { return false ; } if ( root . value < min ) { return false ; } min = root . value ; if ( ! checkBSTInOrderTraversal ( root . right ) ) { return false ; } return true ; }
tr	3	@ Override public void update ( Observable o , Object o1 ) { if ( o . getClass ( ) == FachadaInterfaz . class && o1 . equals ( "Convenio" ) ) { try { setTableConvenios ( ) ; } catch ( ParseException ex ) { Logger . getLogger ( MantenimientoConvenio . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	5	public void setup ( ) { setup = true ; if ( recordReplay ) replay = new GameReplay ( players , board ) ; playersAliveCount = players . length ; Player [ ] starters = players . clone ( ) ; int [ ] startPositions = board . getStartPositions ( starters . length ) ; if ( scrambleStartPositions ) { for ( int i = 0 ; i < startPositions . length ; i ++ ) { int randomIndex = random . nextInt ( startPositions . length ) ; int tmp = startPositions [ i ] ; startPositions [ i ] = startPositions [ randomIndex ] ; startPositions [ randomIndex ] = tmp ; } } for ( int i = 0 ; i < players . length ; i ++ ) { players [ i ] . setAlive ( true ) ; players [ i ] . setNumber ( i ) ; players [ i ] . reset ( ) ; int start = startPositions [ i ] ; board . placePlayerWall ( Board . posToX ( start ) , Board . posToY ( start ) , players [ i ] ) ; } if ( recordReplay ) replay . setStartPositions ( startPositions ) ; thread = new Thread ( ) { @ Override public void run ( ) { runGame ( ) ; } } ; }
tr	2	public String toString ( ) { return "CREATE " + ( temporary ? "TEMPORARY " : "" ) + "TABLE " + ( exists ? "IF NOT EXISTS " : "" ) + name ; }
tr	1	public void renderLow ( Parameters params ) { if ( renderer == null ) { throw new IllegalStateException ( "renderer not set" ) ; } image = newImage ( ) ; showImage ( image ) ; int width = image . getWidth ( null ) ; int height = image . getHeight ( null ) ; params . adjustAspect ( width , height ) ; setParameters ( params ) ; imageComponent . setCursor ( waitCursor ) ; renderThread = new Thread ( new RenderRunner ( image , params , renderer ) ) ; renderThread . start ( ) ; }
tr	0	public void setNeedsPass ( boolean needsPass ) { this . needsPass = needsPass ; }
tr	4	public static Remote findObject ( String name , String host , int lowPort , int highPort ) throws NotBoundException { boolean aRegistryFound = false ; for ( int rport = lowPort ; rport <= highPort ; rport += 1 ) try { return LocateRegistry . getRegistry ( host , rport ) . lookup ( name ) ; } catch ( NotBoundException e ) { aRegistryFound = true ; } catch ( RemoteException e ) { } if ( aRegistryFound ) throw new NotBoundException ( "name not bound in any registry on " + host + ": " + name ) ; else throw new NotBoundException ( "no registries found on " + host + "  ports " + lowPort + ".." + highPort ) ; }
tr	6	public static ConsumptionModel getConsumptionModelForWashingMachine ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
tr	3	private static boolean hasAccess ( IGraph g , IGraph access ) { for ( int i = 0 ; i < g . size ( ) ; i ++ ) { for ( int j = 0 ; j < access . size ( ) ; j ++ ) { String a = g . get ( i ) . getName ( ) ; String b = access . get ( j ) . getName ( ) ; if ( a . equals ( b ) ) return true ; } } return false ; }
tr	9X	public Matrix solve ( Matrix B ) { if ( B . getRowDimension ( ) != m ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if ( ! this . isNonsingular ( ) ) { throw new RuntimeException ( "Matrix is singular." ) ; } int nx = B . getColumnDimension ( ) ; Matrix Xmat = B . getMatrix ( piv , 0 , nx - 1 ) ; double [ ] [ ] X = Xmat . getArray ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ k ] [ j ] /= LU [ k ] [ k ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } return Xmat ; }
tr	7	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
tr	8	private void parseConfLine ( SBConfig conf , String str ) { String delim = "[ ]" ; String [ ] tokens = str . split ( delim ) ; List < String > list = new ArrayList < String > ( ) ; for ( String s : tokens ) { if ( s != null && s . length ( ) > 0 ) { list . add ( s ) ; } } tokens = list . toArray ( new String [ list . size ( ) ] ) ; try { if ( tokens [ 0 ] . equals ( "FPAdder" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPAdder ( i ) ; } else if ( tokens [ 0 ] . equals ( "FPMultiplier" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPMultiplier ( i ) ; } else if ( tokens [ 0 ] . equals ( "FPDivider" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPDivider ( i ) ; } else if ( tokens [ 0 ] . equals ( "IntegerUnit" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfIntegerUnit ( i ) ; } else { log . error ( "Invalid config option provided" ) ; } } catch ( NumberFormatException e ) { log . error ( "Invalid config value provided" ) ; } }
tr	2	private JPanel pnlCrear ( ) { lblNuevoId = new JLabel ( "Identificaci\u00F3n" ) ; lblNuevoNombre = new JLabel ( "Nombre" ) ; lblNuevoApellido = new JLabel ( "Apellido" ) ; lblNuevoTelefono = new JLabel ( "Tel\u00E9fono" ) ; lblNuevoParentesco = new JLabel ( "Parentesco" ) ; txtNuevoId = new JTextField ( ) ; txtNuevoNombre = new JTextField ( ) ; txtNuevoApellido = new JTextField ( ) ; txtNuevoTelefono = new JTextField ( ) ; txtNuevoParentesco = new JTextField ( ) ; btnNuevoElegir = new JButton ( "Elegir" ) ; btnNuevoElegir . addActionListener ( this ) ; switch ( tipo ) { case SELECCIONAR_DUENIO : btnNuevoElegir . setActionCommand ( ELEGIR_DUENIO_NUEVO ) ; break ; case SELECCIONAR_RESPONSABLE : btnNuevoElegir . setActionCommand ( ELEGIR_RESPONSABLE_NUEVO ) ; break ; } ImageIcon iconElegir = new ImageIcon ( getClass ( ) . getResource ( "/conjunto/views/icons/check.png" ) ) ; Image imgElegir = iconElegir . getImage ( ) . getScaledInstance ( - 1 , 22 , Image . SCALE_SMOOTH ) ; iconElegir . setImage ( imgElegir ) ; btnNuevoElegir . setIcon ( iconElegir ) ; Dimension cmps = new Dimension ( 180 , 27 ) ; lblNuevoId . setPreferredSize ( cmps ) ; lblNuevoNombre . setPreferredSize ( cmps ) ; lblNuevoApellido . setPreferredSize ( cmps ) ; lblNuevoTelefono . setPreferredSize ( cmps ) ; lblNuevoParentesco . setPreferredSize ( cmps ) ; txtNuevoId . setPreferredSize ( cmps ) ; txtNuevoNombre . setPreferredSize ( cmps ) ; txtNuevoApellido . setPreferredSize ( cmps ) ; txtNuevoTelefono . setPreferredSize ( cmps ) ; txtNuevoParentesco . setPreferredSize ( cmps ) ; btnNuevoElegir . setPreferredSize ( new Dimension ( 150 , 30 ) ) ; JPanel pnl = new JPanel ( new FlowLayout ( ) ) ; pnl . setBorder ( BorderFactory . createTitledBorder ( "Crear uno nuevo" ) ) ; pnl . setPreferredSize ( new Dimension ( 200 , - 1 ) ) ; pnl . add ( lblNuevoId ) ; pnl . add ( txtNuevoId ) ; pnl . add ( lblNuevoNombre ) ; pnl . add ( txtNuevoNombre ) ; pnl . add ( lblNuevoApellido ) ; pnl . add ( txtNuevoApellido ) ; pnl . add ( lblNuevoTelefono ) ; pnl . add ( txtNuevoTelefono ) ; pnl . add ( lblNuevoParentesco ) ; pnl . add ( txtNuevoParentesco ) ; pnl . add ( btnNuevoElegir ) ; return pnl ; }
tr	8	public ByteBuffer getBuffer ( String filePath ) { ByteBuffer buffer = fileMaps . get ( filePath ) ; if ( buffer == null ) { File requestedFile = new File ( filePath ) ; if ( requestedFile != null && requestedFile . exists ( ) ) { FileInputStream fileInput = null ; FileChannel fileChannel = null ; try { fileInput = new FileInputStream ( requestedFile ) ; fileChannel = fileInput . getChannel ( ) ; if ( fileChannel . size ( ) < ( 1024 * 1024 * 10 ) ) { MappedByteBuffer fileBuffer = fileChannel . map ( MapMode . READ_ONLY , 0 , fileChannel . size ( ) ) ; fileBuffer . load ( ) ; this . fileMaps . put ( filePath , fileBuffer ) ; buffer = fileBuffer . asReadOnlyBuffer ( ) ; } else { buffer = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fileInput != null ) { fileInput . close ( ) ; fileInput = null ; } if ( fileChannel != null ) { fileChannel . close ( ) ; fileChannel = null ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return buffer ; }
tr	4	public static double sigLevelByApproxRand ( int [ ] A , int [ ] B , int iterations ) { if ( A . length == 0 ) throw new IllegalArgumentException ( "Input arrays must not be empty!" ) ; if ( A . length != B . length ) throw new IllegalArgumentException ( "Input arrays must have equal length!" ) ; if ( iterations <= 0 ) throw new IllegalArgumentException ( "Number of iterations must be positive!" ) ; double [ ] X = new double [ A . length ] ; double [ ] Y = new double [ B . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { X [ i ] = A [ i ] ; Y [ i ] = B [ i ] ; } return sigLevelByApproxRand ( X , Y , iterations ) ; }
tr	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Location" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</Location>\n" ; } return kml ; }
tr	6	@ Override public void loadListOfPlugins ( PluginList plugins , String folderPath , String language , boolean isIntern ) { File downloadDir = new File ( getRepositoryFolderName ( ) + "/" + folderPath ) ; if ( downloadDir . exists ( ) ) { for ( File f : downloadDir . listFiles ( ) ) { if ( f . isDirectory ( ) ) { Plugin p = new Plugin ( f . getName ( ) , language ) ; if ( folderPath . contains ( "plugins" ) ) { if ( p . getType ( ) . equals ( PluginType . template ) ) { p . setType ( PluginType . event ) ; } } p . setRepository ( this ) ; if ( folderPath . length ( ) > 0 ) { p . setFolderInRepository ( folderPath + "/" + f . getName ( ) ) ; } else { p . setFolderInRepository ( f . getName ( ) ) ; } plugins . add ( p ) ; } } } }
tr	7	@ Override public boolean combine ( AExecutionItem itemToAdd ) { if ( itemToAdd != null && itemToAdd . getClass ( ) == PreparedStatementExecutionItem . class ) { if ( this . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! this . query . toUpperCase ( ) . contains ( ";SELECT" ) ) { PreparedStatementExecutionItem otherItem = ( PreparedStatementExecutionItem ) itemToAdd ; if ( otherItem . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! otherItem . query . toUpperCase ( ) . contains ( ";SELECT" ) && otherItem . query . toLowerCase ( ) . equals ( query . toLowerCase ( ) ) ) { this . executionItems . add ( otherItem ) ; return true ; } } } return false ; }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	9X	@ SuppressWarnings ( "element-type-mismatch" ) public void removePart ( int i ) { if ( mouths . contains ( parts . get ( i ) ) ) { mouths . remove ( parts . get ( i ) ) ; } if ( eyes . contains ( parts . get ( i ) ) ) { eyes . remove ( parts . get ( i ) ) ; } if ( genitals . contains ( parts . get ( i ) ) ) { genitals . remove ( parts . get ( i ) ) ; } if ( legs . contains ( parts . get ( i ) ) ) { legs . remove ( parts . get ( i ) ) ; } if ( fats . contains ( parts . get ( i ) ) ) { fats . remove ( parts . get ( i ) ) ; } if ( brains . contains ( parts . get ( i ) ) ) { brains . remove ( parts . get ( i ) ) ; } if ( stomachs . contains ( parts . get ( i ) ) ) { stomachs . remove ( parts . get ( i ) ) ; } if ( stems . contains ( parts . get ( i ) ) ) { stems . remove ( parts . get ( i ) ) ; } if ( seeds . contains ( parts . get ( i ) ) ) { seeds . remove ( parts . get ( i ) ) ; } if ( leafs . contains ( parts . get ( i ) ) ) { leafs . remove ( parts . get ( i ) ) ; } parts . remove ( i ) ; }
tr	1	public Dimension minimumLayoutSize ( Container target ) { if ( target . getComponentCount ( ) == 0 ) return new Dimension ( 0 , 0 ) ; return processLayout ( target , MINIMUM_LAYOUT_SIZE_MODE ) ; }
tr	9X	public void booking ( ) { int movieCode ; int showTime_index ; String seats ; Movie movie ; ShowTime showTime = null ; MovieGoer movieGoer ; boolean tryAgain ; do { tryAgain = false ; System . out . println ( ) ; System . out . print ( "Please enter movie code (-1 to go back) : " ) ; movieCode = ConsoleReader . readIntInput ( ) ; if ( movieCode == - 1 ) { return ; } movie = movieBL . getMovie ( movieCode ) ; if ( movie == null ) { tryAgain = true ; System . out . println ( "Invalid Movie Code. Try again." ) ; System . out . println ( ) ; } } while ( tryAgain ) ; printMovieInfo ( movie ) ; do { tryAgain = false ; System . out . print ( "Please select showtime (the number between '[ ]') (-1 to go back) : " ) ; showTime_index = ConsoleReader . readIntInput ( ) ; if ( showTime_index == - 1 ) { return ; } if ( showTime_index < 1 || showTime_index > _showTimes . size ( ) ) { tryAgain = true ; System . out . println ( "Invalid number. Try again." ) ; } else { showTime = _showTimes . get ( showTime_index - 1 ) ; if ( showTimeBL . isFullyBooked ( showTime ) ) { System . out . println ( ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( "| We're sorry  the selected session is sold out. Please pick another one! |" ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( ) ; tryAgain = true ; continue ; } printSeats ( showTime ) ; } } while ( tryAgain ) ; boolean isValidSeatNos ; do { System . out . print ( "Please enter seat no. (e.g. G1 G2 ...) : " ) ; seats = ConsoleReader . readSeatNumbers ( ) ; String [ ] _seats = seats . split ( " " ) ; isValidSeatNos = seatBL . validateSeatNumbers ( showTime , _seats ) ; if ( ! isValidSeatNos ) { System . out . println ( "Invalid seat numbers. Please choose again." ) ; } else if ( _seats . length > 10 ) { System . out . println ( "You cannot book more than 10 tickets per transaction. Please select seats again." ) ; isValidSeatNos = false ; } System . out . println ( ) ; } while ( ! isValidSeatNos ) ; String movieGoerName ; String movieGoerMobileNo ; String movieGoerEmail ; Date dateOfBirth = null ; System . out . println ( ) ; System . out . println ( "Please Enter Your Details" ) ; System . out . println ( "=========================" ) ; System . out . print ( "Name : " ) ; movieGoerName = ConsoleReader . readString ( ) ; System . out . print ( "Date of Birth (DD/MM/YYYY) : " ) ; dateOfBirth = ConsoleReader . readDateInput ( ) ; System . out . print ( "Email : " ) ; movieGoerEmail = ConsoleReader . readString ( ) ; System . out . print ( "Mobile No : " ) ; movieGoerMobileNo = ConsoleReader . readString ( ) ; movieGoer = movieGoerBL . createMovieGoer ( movieGoerName , movieGoerEmail , movieGoerMobileNo , dateOfBirth ) ; printBookingSummary ( showTime , movieGoer , seats ) ; }
tr	0	public boolean isInterested ( ) { return this . interested ; }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	9X	@ Override public void run ( ) { String line = null ; while ( true ) { try { line = readLine ( ) ; if ( line . startsWith ( EGame . START . toString ( ) ) ) controller . setPlayer ( Integer . parseInt ( line . substring ( EGame . START . toString ( ) . length ( ) ) ) == 1 ? EPlayer . P1 : EPlayer . P2 ) ; else if ( line . startsWith ( EGame . REQUEST_TURN . toString ( ) ) ) { new RequestTurn ( ) . start ( ) ; } else if ( line . startsWith ( EGame . REQUEST_CHOICE . toString ( ) ) ) { new RequestChoice ( ) . start ( ) ; } else if ( line . startsWith ( EGame . OTHER_TURN . toString ( ) ) ) controller . addTurn ( new Turn ( ) . fromString ( line . substring ( EGame . OTHER_TURN . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . OTHER_CHOICE . toString ( ) ) ) controller . addChoice ( Integer . parseInt ( line . substring ( EGame . OTHER_CHOICE . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . FINISHED . toString ( ) ) ) { break ; } else if ( line . startsWith ( EGame . INTERRUPTED . toString ( ) ) ) { break ; } } catch ( InterruptedException e ) { break ; } } controller . toLobby ( ) ; }
tr	2	public void requestOpenPose ( int id ) { boolean continueToOpen = true ; if ( ! saved ) { continueToOpen = promptToSave ( ) ; } if ( continueToOpen ) { promptToOpen ( id ) ; } }
tr	0	@ BeforeMethod public void setUpMethod ( ) throws Exception { }
tr	4	public Questionnaire getQuestionnaireById ( long id ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; Questionnaire questionnaire = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Retrieving questionnaire " + id + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUESTIONNAIRE ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUESTIONNAIRE ) ; statement . setLong ( 1 , id ) ; rs = statement . executeQuery ( ) ; if ( rs . next ( ) ) { questionnaire = fillQuestionnaire ( rs ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questionnaire ; }
tr	7	private int packSpecifiedFrames ( byte [ ] bytes , int offset , String onlyId , String notId ) throws NotSupportedException { Iterator < ID3v2FrameSet > setIterator = frameSets . values ( ) . iterator ( ) ; while ( setIterator . hasNext ( ) ) { ID3v2FrameSet frameSet = setIterator . next ( ) ; if ( ( onlyId == null || onlyId . equals ( frameSet . getId ( ) ) ) && ( notId == null || ! notId . equals ( frameSet . getId ( ) ) ) ) { Iterator < ID3v2Frame > frameIterator = frameSet . getFrames ( ) . iterator ( ) ; while ( frameIterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) frameIterator . next ( ) ; if ( frame . getDataLength ( ) > 0 ) { byte [ ] frameData = frame . toBytes ( ) ; BufferTools . copyIntoByteBuffer ( frameData , 0 , frameData . length , bytes , offset ) ; offset += frameData . length ; } } } } return offset ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	2	public void insert ( Object value , int index ) { int space = index ; while ( rawget ( space ) != null ) space ++ ; while ( space != index ) rawset ( space , rawget ( -- space ) ) ; rawset ( space , value ) ; }
tr	7	public void paint ( Graphics g ) { if ( fm == null ) { fm = g . getFontMetrics ( font ) ; titleFm = g . getFontMetrics ( titleFont ) ; minSize . width = titleFm . stringWidth ( title ) ; minSize . height = 1 + TITLE_ABOVE_SPACE + titleFm . getHeight ( ) + TITLE_BELOW_SPACE ; for ( int i = 0 ; i < items . length ; i ++ ) { minSize . height += ITEM_ABOVE_SPACE ; if ( items [ i ] . equals ( "-" ) ) { minSize . height += DIVIDER_HEIGHT ; } else { minSize . height += fm . getHeight ( ) ; if ( fm . stringWidth ( items [ i ] ) > minSize . width ) minSize . width = fm . stringWidth ( items [ i ] ) ; } minSize . height += ITEM_BELOW_SPACE ; } minSize . width += ( MATTE_SIZE + 1 ) * 2 ; minSize . height ++ ; resize ( minSize ) ; repaint ( ) ; } else { g . setColor ( borderColor ) ; g . drawLine ( 0 , 0 , 0 , size ( ) . height - 1 ) ; g . drawLine ( 0 , 0 , size ( ) . width - 1 , 0 ) ; g . drawLine ( size ( ) . width - 1 , 0 , size ( ) . width - 1 , size ( ) . height - 1 ) ; g . drawLine ( 0 , size ( ) . height - 1 , size ( ) . width - 1 , size ( ) . height - 1 ) ; int y = 1 + TITLE_ABOVE_SPACE ; g . setFont ( titleFont ) ; g . setColor ( titleColor ) ; g . drawString ( title , size ( ) . width / 2 - titleFm . stringWidth ( title ) / 2 , y + titleFm . getAscent ( ) ) ; y += titleFm . getHeight ( ) + TITLE_BELOW_SPACE ; g . setFont ( font ) ; for ( int i = 0 ; i < items . length ; i ++ ) { if ( items [ i ] . equals ( "-" ) ) { g . setColor ( dividerColor ) ; g . drawLine ( 1 , y + ITEM_ABOVE_SPACE , size ( ) . width - 2 , y + ITEM_ABOVE_SPACE ) ; y += DIVIDER_HEIGHT ; } else { if ( selected == i ) { g . setColor ( selectedBgColor ) ; g . fillRect ( 1 , y , size ( ) . width - 2 , fm . getHeight ( ) + ITEM_ABOVE_SPACE + ITEM_BELOW_SPACE ) ; g . setColor ( selectedFgColor ) ; } else g . setColor ( fgColor ) ; g . drawString ( items [ i ] , 1 + MATTE_SIZE , y + ITEM_ABOVE_SPACE + fm . getAscent ( ) ) ; y += fm . getHeight ( ) ; } y += ITEM_ABOVE_SPACE + ITEM_BELOW_SPACE ; } } }
tr	1	@ Override public void visit ( VariableDeclaration node ) { Type symbolType = node . symbol ( ) . getType ( ) ; if ( ! symbolType . isPrimitive ( ) ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Variable " + node . symbol ( ) . getName ( ) + " has invalid type " + symbolType + "." ) ; }
tr	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	6	public T getEdge ( int i , int j ) throws IllegalArgumentException { if ( i < 0 || i >= numberOfVertices || j < 0 || j >= numberOfVertices ) { String errorMessage = "Allows vertex indizes are 0.." + ( numberOfVertices - 1 ) + "." ; throw new IllegalArgumentException ( errorMessage ) ; } for ( T e : adjacencyList [ i ] ) { if ( e . getTarget ( ) == j ) { return e ; } } return null ; }
tr	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	9X	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	8	@ Override public void run ( ) { try { startServer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } while ( ! this . isInterrupted ( ) ) { try { selector . select ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Iterator keys = selector . selectedKeys ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) keys . next ( ) ; keys . remove ( ) ; if ( ! key . isValid ( ) ) { continue ; } if ( key . isAcceptable ( ) ) { acceptOP ( key , selector ) ; } else if ( key . isReadable ( ) ) { this . readOP ( key ) ; } else if ( key . isWritable ( ) ) { this . writeOP ( key ) ; } } } }
tr	5	public static Object evaluate ( String expression , Object root , boolean trimRootToken ) throws Exception { if ( trimRootToken ) { expression = expression . substring ( expression . indexOf ( . ) + 1 ) ; } Object value = root ; StringTokenizer parser = new StringTokenizer ( expression , "." ) ; while ( parser . hasMoreTokens ( ) ) { String token = parser . nextToken ( ) ; if ( value == null ) { return null ; } ClassMap classMap = getClassMap ( value . getClass ( ) ) ; String methodBase = StringUtils . capitalizeFirstLetter ( token ) ; String methodName = "get" + methodBase ; Method method = classMap . findMethod ( methodName , CLASS_ARGS ) ; if ( method == null ) { methodName = "is" + methodBase ; method = classMap . findMethod ( methodName , CLASS_ARGS ) ; } if ( method == null ) { return null ; } value = method . invoke ( value , OBJECT_ARGS ) ; } return value ; }
tr	2	public void initRandom ( Random random , int maxValue ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { int v = random . nextInt ( maxValue + 1 ) ; setValue ( x , y , v ) ; } } }
tr	7	private boolean fulfills ( Car car , Step3UserRequest userRequest3 ) { if ( userRequest3 . getMinyearOfProduction ( ) != null && car . getYearOfProduction ( ) < userRequest3 . getMinyearOfProduction ( ) ) return false ; if ( userRequest3 . getMaxyearOfProduction ( ) != null && car . getYearOfProduction ( ) > userRequest3 . getMaxyearOfProduction ( ) ) return false ; if ( userRequest3 . getFeatures ( ) != null ) { for ( CarFeature feature : userRequest3 . getFeatures ( ) ) { if ( ! car . getFeatures ( ) . contains ( feature ) ) return false ; } } return true ; }
tr	6	private List < Student > parse ( final Document doc ) { final List < Student > students = new Vector < Student > ( ) ; if ( doc == null ) { return students ; } final Element root = doc . getDocumentElement ( ) ; final NodeList nodeStudents = root . getChildNodes ( ) ; if ( nodeStudents != null ) { if ( nodeStudents . getLength ( ) != 0 ) { for ( int i = 0 ; i < nodeStudents . getLength ( ) ; ++ i ) { final Node nodeStudent = nodeStudents . item ( i ) ; if ( nodeStudent != null ) { if ( nodeStudent . getNodeType ( ) == Node . ELEMENT_NODE ) { final Student student = parseStudent ( nodeStudent ) ; students . add ( student ) ; } } } } } return students ; }
tr	1	public Game ( Dimension boardDimension ) { board = new Board ( boardDimension , this ) ; windowFavoriteSize = new Dimension ( 800 , 600 ) ; playerList = new ArrayList < Player > ( ) ; bufferPlayers = new ArrayList < Player > ( ) ; try { bufferBoard = board . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } }
tr	4	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] >= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
tr	5	void setViewOffset ( int xofs , int yofs ) { if ( bg_defined == null ) return ; this . xofs = xofs ; this . yofs = yofs ; int oldtilexofs = tilexofs ; int oldtileyofs = tileyofs ; tilexofs = divFloor ( xofs , tilex ) - 1 ; tileyofs = divFloor ( yofs , tiley ) - 1 ; xofs_scaled = scaleXPos ( xofs , false ) ; yofs_scaled = scaleYPos ( yofs , false ) ; calcPFWrapCenter ( ) ; int maxtilexofs = Math . max ( tilexofs , oldtilexofs ) ; int maxtileyofs = Math . max ( tileyofs , oldtileyofs ) ; int mintilexofs = Math . min ( tilexofs , oldtilexofs ) ; int mintileyofs = Math . min ( tileyofs , oldtileyofs ) ; for ( int yi = mintileyofs ; yi < maxtileyofs ; yi ++ ) { for ( int xi = 0 ; xi < viewnrtilesx + 3 ; xi ++ ) { bg_defined [ xi ] [ moduloFloor ( yi , viewnrtilesy + 3 ) ] = false ; } } for ( int xi = mintilexofs ; xi < maxtilexofs ; xi ++ ) { for ( int yi = 0 ; yi < viewnrtilesy + 3 ; yi ++ ) { bg_defined [ moduloFloor ( xi , viewnrtilesx + 3 ) ] [ yi ] = false ; } } }
tr	6	public boolean HasClearPath ( ChessTile Start , ChessTile End ) { int ForwardDistance ; int SideDistance ; if ( Start == null || End == null ) { return false ; } ForwardDistance = Math . abs ( End . GetPosition ( ) [ 1 ] - Start . GetPosition ( ) [ 1 ] ) ; SideDistance = Math . abs ( End . GetPosition ( ) [ 0 ] - Start . GetPosition ( ) [ 0 ] ) ; for ( int i = 1 ; i < Math . max ( ForwardDistance , SideDistance ) - 1 ; i ++ ) { int ForwardMin = Math . min ( ForwardDistance , i ) ; int SideMin = Math . min ( SideDistance , i ) ; if ( Start . GetPosition ( ) [ 0 ] > End . GetPosition ( ) [ 0 ] ) { SideMin = - SideMin ; } if ( Start . GetPosition ( ) [ 1 ] > End . GetPosition ( ) [ 1 ] ) { ForwardMin = - ForwardMin ; } if ( Board [ Start . GetPosition ( ) [ 0 ] + SideMin ] [ Start . GetPosition ( ) [ 1 ] + ForwardMin ] . GetHeldPiece ( ) != null ) { return false ; } } return true ; }
tr	6	public int longestConsecutive ( int [ ] num ) { int max = 0 ; if ( num == null ) return max ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : num ) { set . add ( i ) ; } for ( int i : num ) { if ( set . contains ( i ) ) { set . remove ( i ) ; int start = i - 1 ; while ( set . contains ( start ) ) { set . remove ( start ) ; start -- ; } int end = i + 1 ; while ( set . contains ( end ) ) { set . remove ( end ) ; end ++ ; } max = Math . max ( max , end - start - 1 ) ; } } return max ; }
tr	3	private boolean bit ( ) throws JSONException { boolean value ; try { value = this . bitreader . bit ( ) ; if ( probe ) { log ( value ? 1 : 0 ) ; } return value ; } catch ( Throwable e ) { throw new JSONException ( e ) ; } }
tr	8	private String subscribe ( String msg , iKPIC_subscribeHandler2 handler ) { deb_print ( "KpCore:subscribe method" ) ; int ret = 0 ; System . out . println ( "HERE!" ) ; if ( handler == null ) { this . KP_ERROR_ID = this . ERR_EVENT_HANDLER_NULL ; err_print ( "EVENT HANDLER IS NULL!!!" ) ; return null ; } deb_print ( "KpCore:SSAP:XML MESSAGE:\n" + msg ) ; deb_print ( "KpCore:SSAP:Open connection..." ) ; ret = openConnect ( ) ; if ( ret != this . ERR_Conected ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:connection error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Send message..." ) ; ret = send ( msg ) ; if ( ret != this . ERR_MsgSent ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:send error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Message Sent..." ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; msg = "" ; int charRead = 0 ; try { while ( ( charRead = in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { builder . append ( buffer , 0 , charRead ) ; msg = builder . toString ( ) ; if ( msg . contains ( "<SSAP_message>" ) && msg . contains ( "</SSAP_message>" ) ) { if ( this . xmlTools . isSubscriptionConfirmed ( msg ) ) { this . KP_ERROR_ID = this . ERR_Subscription_DONE ; System . out . println ( "1" ) ; kpSocket . setKeepAlive ( true ) ; Subscription s = new Subscription ( kpSocket , handler ) ; return msg ; } else { System . out . println ( "[90] UNKNOW MESSAGE:" + msg ) ; break ; } } } deb_print ( "KpCore:readByteXByteSIBmsg:READ LOOP TERMINATED" ) ; closeConnection ( ) ; } catch ( Exception e ) { err_print ( "KPICore:readByteXByteSIBmsg:Exception on EVENT HANDLER:RECEIVE:\n" + e ) ; this . KP_ERROR_ID = this . ERR_SOCKET_TIMEOUT ; } this . KP_ERROR_ID = this . ERR_Subscription_NOT_DONE ; deb_print ( "KpCore:SSAP:Message received:(" + msg + ")" ) ; return msg ; }
tr	5	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	5	public static < C > String getStateDecoration ( State < C > state , boolean requireAdditionDecoration , String additionalDecoration ) { StringBuilder b = new StringBuilder ( ) ; b . append ( "shape=\"record\"  label=\"{" ) . append ( state . getName ( ) ) . append ( ( requireAdditionDecoration ) ? String . format ( "|%s|{" , additionalDecoration ) : "|{" ) ; String sep = "" ; for ( Action < C > a : state . getActions ( ) ) { b . append ( sep ) . append ( a . getType ( ) ) ; sep = "|" ; } b . append ( "}}\"" ) ; int mod = state . getModifier ( ) ; b . append ( "  style=\"filled" ) ; if ( ( mod & ITimedAutomata . INITIAL ) > 0 ) b . append ( " diagonals" ) ; if ( ( mod & ITimedAutomata . URGENT ) > 0 ) b . append ( " bold" ) ; b . append ( "\"" ) ; if ( ( mod & ITimedAutomata . TERMINATE ) > 0 ) b . append ( "  color=\"red\"" ) ; b . append ( "  fillcolor=\"white\"" ) ; return b . toString ( ) ; }
tr	0	public static String Message_GetUsageCredits ( String THE_MESSAGE ) { return otapiJNI . OTAPI_Basic_Message_GetUsageCredits ( THE_MESSAGE ) ; }
tr	3	public void addFAB ( NodeFAB f , boolean clear ) { if ( clear ) fabs . clear ( ) ; int numB = 5 ; fabs . add ( f . make ( ) ) ; for ( Node N : network ) { if ( clear ) { N . clearFABS ( ) ; } N . addFAB ( f . make ( ) ) ; N . initFAB ( N . getNumFab ( ) - 1 , 0 ) ; } }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	2	public static void initPreferences ( Preferences preferences ) { if ( pdfLaTeXFile == null ) preferences . put ( "pathToPDFLaTeXFile" , default ) ; else preferences . put ( "pathToPDFLaTeXFile" , pdfLaTeXFile . getAbsolutePath ( ) ) ; if ( pdfExportFolder == null ) preferences . put ( "pathToPDFExportFolder" , default ) ; else preferences . put ( "pathToPDFExportFolder" , pdfExportFolder . getAbsolutePath ( ) ) ; }
tr	1	public void paintComponent ( Graphics comp ) { super . paintComponent ( comp ) ; Graphics2D comp2D = ( Graphics2D ) comp ; int h = getHeight ( ) - 5 ; int w = getWidth ( ) - 5 ; if ( ! hasValidDrafter ( map , comp2D , hexSideInPixels ) ) { int leftMarginInPixels = 0 ; int topMarginInPixels = 0 ; Rectangle margins = new Rectangle ( leftMarginInPixels , topMarginInPixels , w , h ) ; drafter = new CanvasDrafter ( map , comp2D , hexSideInPixels , textDisplayer , margins ) ; loupe . setMargins ( margins ) ; } drafter . drawMap ( w , h , centerCellId ) ; }
tr	9X	public void checkCollisionsWithEnemies ( ArrayList < Enemy > list , Level1State state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getKilledByTop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getPlayerState ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
tr	1	public T createResponse ( int source , long timestamp ) { try { class < T > cl = getResponseType ( ) ; return cl . getConstructor ( Integer . TYPE , long . TYPE ) . newInstance ( source , timestamp ) ; } catch ( Exception e ) { return null ; } }
tr	2	public void initNew ( ) { if ( aDataMap == null ) aDataMap = new HashMap < ASection , AData > ( ) ; else aDataMap . clear ( ) ; try { this . replace ( 0 , getLength ( ) , "" , defaultStyle ) ; } catch ( BadLocationException e ) { System . out . println ( "Error in ADocument.initNew() :\n" ) ; e . printStackTrace ( ) ; } putProperty ( ( Object ) TitleProperty , ( Object ) DEFAULT_TITLE ) ; putProperty ( ( Object ) ExpertProperty , ( Object ) "" ) ; putProperty ( ( Object ) ClientProperty , ( Object ) "" ) ; Date date = new Date ( ) ; putProperty ( ( Object ) DateProperty , ( Object ) date . toLocaleString ( ) ) ; putProperty ( ( Object ) CommentProperty , "" ) ; setCharacterAttributes ( 0 , 1 , defaultStyle , true ) ; fireADocumentChanged ( ) ; Analyst . initUndoManager ( ) ; }
tr	6	boolean isaContact ( Game game , Tile tile , double x , double y ) { Point2D pt = new Point2D . double ( x , y ) ; boolean touched = false ; for ( Tile tl : game . getMap ( ) . getTiles ( ) ) { if ( ! tl . equals ( tile ) ) { if ( tl . getArea ( ) . getMinX ( ) <= x && x <= tl . getArea ( ) . getMaxX ( ) && tl . getArea ( ) . getMinY ( ) <= y && y <= tl . getArea ( ) . getMaxY ( ) ) { touched = true ; break ; } } } return touched ; }
tr	1	public void awaitTermination ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { String message = "awaitTermination() method was interrupted!" ; throw new UnsupportedOperationException ( message , e ) ; } }
tr	6	public static String unescape ( String s ) { int len = s . length ( ) ; StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = s . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < len ) { int d = JSONTokener . dehexchar ( s . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( s . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } b . append ( c ) ; } return b . toString ( ) ; }
tr	9X	private void getScaleFactors_2 ( int gr , int ch ) { byte [ ] nr ; int i , band , slen , num , n = 0 , scf = 0 ; final boolean i_stereo = header . isIntensityStereo ( ) ; final ChannelInformation ci = channelInfo [ gr ] [ ch ] ; final int [ ] l = scalefacLong [ ch ] ; final int [ ] s = scalefacShort [ ch ] ; rzeroBandLong = 0 ; if ( ( ch > 0 ) && i_stereo ) slen = i_slen2 [ ci . scalefac_compress >> 1 ] ; else slen = n_slen2 [ ci . scalefac_compress ] ; ci . preflag = ( slen >> 15 ) & 1 ; ci . part2_length = 0 ; if ( ci . block_type == 2 ) { n ++ ; if ( ( ci . mixed_block_flag ) != 0 ) n ++ ; nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) s [ scf ++ ] = 0 ; } else { nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) l [ scf ++ ] = 0 ; } }
tr	0	public void updateMenu ( ) { setPanel ( _menuSelect . selectMenu ( ) ) ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	9X	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
tr	3	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	4	public static void create ( String [ ] args ) { Vector < vslFileDataChunk > chunks = null ; if ( args . length < 3 ) { System . err . println ( "Missings args: create <dbfile> <source>" ) ; System . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkFile ( source ) ; vslDataType < vslFileDataChunk > fileData = new vslDataType < vslFileDataChunk > ( ) ; StringTokenizer st = new StringTokenizer ( source , "/" ) ; String fname = "UNSET" ; while ( st . hasMoreTokens ( ) ) { fname = st . nextToken ( ) ; } fileData . setName ( fname ) ; for ( vslFileDataChunk chunk : chunks ) { fileData . addNewChunk ( chunk ) ; } core . addEntry ( fileData ) ; core . debugShow ( ) ; core . save ( ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	8	@ Override public void widgetSelected ( SelectionEvent e ) { if ( e . getSource ( ) == add_button ) { String username = ua_uname_text . getText ( ) ; String name = ua_name_text . getText ( ) ; String pass = ua_pass_text . getText ( ) ; String confirm = ua_cpass_text . getText ( ) ; if ( pass . equals ( confirm ) ) { if ( Sanitizer . isCleanInput ( username ) && Sanitizer . isCleanInput ( name ) && Sanitizer . isCleanInput ( pass ) ) { ADD newuser = null ; try { newuser = new ADD ( username , name , Hash . getSHA256 ( pass . getBytes ( "UTF-8" ) ) , session . getName ( ) , session . getPassHash ( ) ) ; } catch ( UnsupportedEncodingException e2 ) { System . out . println ( "nope" ) ; e2 . printStackTrace ( ) ; } try { System . out . println ( portclient . exchange ( newuser ) ) ; } catch ( UserNotFoundException e1 ) { System . out . println ( "did not go through  sorry" ) ; e1 . printStackTrace ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Invalid Input(s)." ) ; messageBox . open ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Passwords do not match." ) ; messageBox . open ( ) ; } } else if ( e . getSource ( ) == clear_button ) { ua_uname_text . setText ( "" ) ; ua_name_text . setText ( "" ) ; ua_pass_text . setText ( "" ) ; ua_cpass_text . setText ( "" ) ; } }
tr	0	@ Test public void revers_on_empty_list_should_be_equals_to_itself ( ) { DoubleLinkedList list = new DoubleLinkedList ( ) ; assertEquals ( utils . reverse ( list ) , list ) ; }
tr	0	public int numberOfPhotosBelongingTo ( ) { return this . photosInAlbum . size ( ) ; }
tr	0	public void setId ( Integer id ) { this . id = id ; }
tr	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	2	public OptionSet getMatchingSet ( boolean ignoreUnmatched , boolean requireDataLast ) { for ( String setName : optionSets . keySet ( ) ) if ( check ( setName , ignoreUnmatched , requireDataLast ) ) return optionSets . get ( setName ) ; return null ; }
tr	5	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
tr	9X	public PiecePanel ( tutFrame frame , int x ) { this . setLayout ( new BorderLayout ( ) ) ; this . setPreferredSize ( new Dimension ( PLAYERWIDTH , GRIDSIZE ) ) ; this . setBackground ( Color . DARK_GRAY . darker ( ) ) ; boardPanel = frame . boardPanel ; this . board = frame . board ; this . player = frame . players [ x ] ; this . frame = frame ; currentPiece = null ; Border bord1 , bord2 , finalborder ; bord1 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 5 , 0 , 0 , Color . BLUE ) , BorderFactory . createMatteBorder ( 5 , 0 , 0 , 0 , Color . RED ) ) ; bord2 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 0 , 5 , Color . YELLOW ) , BorderFactory . createMatteBorder ( 0 , 0 , 5 , 0 , Color . GREEN ) ) ; finalborder = new CompoundBorder ( bord1 , bord2 ) ; this . setBorder ( finalborder ) ; switch ( player . getColor ( ) ) { case b : color = "Blue" ; break ; case r : color = "Red" ; break ; case y : color = "Yellow" ; break ; case g : color = "Green" ; break ; } im = new Image [ 21 ] ; ImageIcon temp ; for ( int i = 0 ; i < 21 ; ++ i ) { try { temp = new ImageIcon ( getClass ( ) . getResource ( "/images/" + color + "/" + String . valueOf ( i ) + "S.png" ) ) ; im [ i ] = temp . getImage ( ) ; } catch ( Exception e ) { System . out . println ( "Stuff" ) ; System . exit ( 10 ) ; } } piecesPanel = new JPanel ( new FlowLayout ( ) ) ; piecesPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; pieces = new Piece [ 21 ] ; clickables = new JRadioButton [ 21 ] ; int w , h ; ImageIcon icon = null ; ButtonListener clicked = new ButtonListener ( ) ; for ( int i = 0 ; i < 21 ; ++ i ) { pieces [ i ] = player . getPiece ( i ) ; w = ( int ) ( 0.7 * ( pieces [ i ] . getWidth ( ) * SPACESIZE ) ) ; h = ( int ) ( 0.7 * ( pieces [ i ] . getHeight ( ) * SPACESIZE + 1 ) ) ; im [ i ] = im [ i ] . getScaledInstance ( w , h , BufferedImage . SCALE_DEFAULT ) ; icon = new ImageIcon ( im [ i ] ) ; clickables [ i ] = new JRadioButton ( icon ) ; clickables [ i ] . setOpaque ( false ) ; clickables [ i ] . addActionListener ( clicked ) ; piecesPanel . add ( clickables [ i ] ) ; } this . add ( piecesPanel ) ; rcButton = new JButton ( "<html><center>Rotate<p>Right(&gt)</center></html>" ) ; rccButton = new JButton ( "<html><center>Rotate<p>Left(&lt)</center></html>" ) ; flipButton = new JButton ( "Flip(^)" ) ; buttonPanel = new JPanel ( new GridLayout ( 1 , 3 ) ) ; buttonPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; buttonPanel . add ( rccButton , BorderLayout . SOUTH ) ; buttonPanel . add ( flipButton , BorderLayout . SOUTH ) ; buttonPanel . add ( rcButton , BorderLayout . SOUTH ) ; rcButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRC ( ) ; } } } ) ; rccButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRCC ( ) ; } } } ) ; flipButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragFlip ( ) ; } } } ) ; submitButton = new JButton ( "Submit Move!(ENTER)" ) ; submitButton . addActionListener ( new SubmitListener ( ) ) ; submitButton . setEnabled ( false ) ; JPanel two = new JPanel ( new GridLayout ( 2 , 1 ) ) ; two . setBackground ( Color . DARK_GRAY . darker ( ) ) ; two . add ( buttonPanel ) ; two . add ( submitButton ) ; this . add ( two , BorderLayout . SOUTH ) ; }
tr	3	private void initCustomTag ( RandomAccessFile file ) throws IOException { int bufferLength = ( int ) ( getLength ( ) - ( endOffset + 1 ) ) ; if ( hasId3v1Tag ( ) ) bufferLength -= ID3v1Tag . TAG_LENGTH ; if ( bufferLength <= 0 ) { customTag = null ; } else { customTag = new byte [ bufferLength ] ; file . seek ( endOffset + 1 ) ; int bytesRead = file . read ( customTag , 0 , bufferLength ) ; if ( bytesRead < bufferLength ) throw new IOException ( "Not enough bytes read" ) ; } }
tr	7	private static void argsCommand ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . toLowerCase ( ) ) { case "-ip" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { networkIP = args [ i + 1 ] . split ( ":" , 2 ) [ 0 ] . trim ( ) ; rmiPort = Integer . parseInt ( args [ i + 1 ] . split ( ":" , 2 ) [ 1 ] . trim ( ) ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -ip" ) ; } break ; case "-tcp" : tcpPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) ) ; i ++ ; break ; case "-multicast" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { multicastIP = args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 0 ] ; multicastPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 1 ] ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -multicast" ) ; } break ; case "-help" : System . out . println ( "SystemY Server application - 2014" ) ; System . out . println ( "Starts the server for connecting to SystemY. SystemY is a distributed file system for local networks." ) ; System . out . println ( "\nOptions: " ) ; System . out . println ( "\t-ip {ip}:{port}\t\tThe given ip will be used for all communication from the server to the network.\n\t\t\t\tThe ip must be the ip of the physical interface connected to the local network with SystemY." ) ; System . out . println ( "\t-tcpPort {port}\tThis feature is for future purposes." ) ; System . out . println ( "\t-multicast {ip}:{port}\tThis feature is for future purposes." ) ; System . exit ( 0 ) ; default : System . out . println ( "Unkown option '" + args [ i ] + "'" ) ; break ; } } }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	8	private static int getPrecedence ( String s ) { switch ( s . charAt ( 0 ) ) { case ( : case ) : return 1 ; case _ : return 4 ; case * : case / : return 3 ; case + : case - : return 2 ; case ^ : return 5 ; default : return 0 ; } }
tr	5	@ Override public Object visit ( ASTattr_stmt node , Object data ) { commonProcessing ( node , this ) ; if ( node . jjtGetValue ( ) . equals ( "node" ) ) { for ( int i = 0 ; i < node . jjtGetNumChildren ( ) ; i ++ ) { Node child = node . jjtGetChild ( i ) ; if ( child instanceof ASTattr_list ) { String childNodeShape = ( String ) child . jjtAccept ( this , data ) ; if ( childNodeShape . equals ( "doublecircle" ) || childNodeShape . equals ( "box" ) ) this . accept = true ; else this . accept = false ; } else { child . jjtAccept ( this , data ) ; } } } else node . childrenAccept ( this , data ) ; return null ; }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	4	public void triangulate ( FaceList newFaces , double minArea ) { HalfEdge hedge ; if ( numVertices ( ) < 4 ) { return ; } Vertex v0 = he0 . head ( ) ; Face prevFace = null ; hedge = he0 . next ; HalfEdge oppPrev = hedge . opposite ; Face face0 = null ; for ( hedge = hedge . next ; hedge != he0 . prev ; hedge = hedge . next ) { Face face = createTriangle ( v0 , hedge . prev . head ( ) , hedge . head ( ) , minArea ) ; face . he0 . next . setOpposite ( oppPrev ) ; face . he0 . prev . setOpposite ( hedge . opposite ) ; oppPrev = face . he0 ; newFaces . add ( face ) ; if ( face0 == null ) { face0 = face ; } } hedge = new HalfEdge ( he0 . prev . prev . head ( ) , this ) ; hedge . setOpposite ( oppPrev ) ; hedge . prev = he0 ; hedge . prev . next = hedge ; hedge . next = he0 . prev ; hedge . next . prev = hedge ; computeNormalAndCentroid ( minArea ) ; checkConsistency ( ) ; for ( Face face = face0 ; face != null ; face = face . next ) { face . checkConsistency ( ) ; } }
tr	5	@ Override public Point getTarget ( GameState state ) { float [ ] [ ] candidates = new float [ 3 ] [ 5 ] ; Point target = null ; int i = 0 ; for ( TargetingStrategy strategy : strategies ) { target = strategy . getTarget ( state ) ; if ( target != null ) { candidates [ target . x ] [ target . y ] += weights [ i ] ; } ++ i ; } float greatest = 0f ; target = null ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( candidates [ x ] [ y ] > greatest ) { target = new Point ( x , y ) ; greatest = candidates [ x ] [ y ] ; } } } return target ; }
tr	3	@ Override protected byte [ ] encryptConcrete ( EncFSVolume volume , byte [ ] paddedDecFileName , byte [ ] fileIv ) throws EncFSCorruptDataException { try { return BlockCrypto . blockEncrypt ( volume , fileIv , paddedDecFileName ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( BadPaddingException e ) { throw new EncFSCorruptDataException ( e ) ; } }
tr	4	public CombIterator ( final Map < ? extends K , ? extends Iterable < ? extends V >> origin ) throws NullPointerException , IllegalArgumentException { this . iterators = new HashMap < > ( origin . size ( ) ) ; this . template = new LinkedHashMap < > ( origin . size ( ) ) ; for ( final K key : origin . keySet ( ) ) { resume ( key , origin . get ( key ) . iterator ( ) ) ; } this . origin = origin ; }
tr	1	public Labels getLabels ( ) { if ( labels == null ) { labels = new Labels ( ) ; } return labels ; }
tr	4	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } int [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
tr	8	public int checkCollision ( int cidmask , JGObject obj ) { JGRectangle bbox = obj . getBBox ( ) ; if ( bbox == null ) return 0 ; int retcid = 0 ; JGRectangle obj_bbox = tmprect1 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o == obj ) continue ; if ( ! o . is_suspended ) { if ( cidmask == 0 || ( o . colid & cidmask ) != 0 ) { if ( ! o . getBBox ( obj_bbox ) ) continue ; if ( bbox . intersects ( obj_bbox ) ) { retcid |= o . colid ; } } } } return retcid ; }
tr	6	public int [ ] getActions ( Game game , long timeDue ) { int pacmanLoc = game . getCurPacManLoc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostRequiresAction ( i ) ) { if ( isCrowded ( game ) && ! closeToMsPacMan ( game , game . getCurGhostLoc ( i ) ) ) dirs [ i ] = getRetreatActions ( game , i ) ; else if ( game . getEdibleTime ( i ) > 0 || closeToPower ( game ) ) dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , false , Game . DM . PATH ) ; else dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , true , Game . DM . PATH ) ; } } return dirs ; }
tr	8	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
tr	8	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	0	public AddOrigen ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; }
tr	6	public int getAnswerIndex ( ) { if ( answer == null || options == null || isSurvey || style != CHOICE_QUESTION ) { return - 1 ; } for ( int i = 0 ; i < options . length ; i ++ ) { if ( answer . equals ( options [ i ] ) ) { return i ; } } return - 1 ; }
tr	8	@ Override public List < ChessPosition > getTargetPos ( ChessPosition current ) { List < ChessPosition > pos = new ArrayList < ChessPosition > ( ) ; int x , y , upBound , lowBound , leftBound , rightBound , value , cy , cx ; int Tdx [ ] = { 0 , - 1 , 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 } ; int Tdy [ ] = { 0 , - 2 , - 2 , - 1 , 1 , 2 , 2 , 1 , - 1 } ; int dx [ ] = { 0 , 0 , 1 , 0 , - 1 } ; int dy [ ] = { 0 , - 1 , 0 , 1 , 0 } ; ChessPosition CpTemp ; x = current . getCol ( ) ; y = current . getRow ( ) ; value = board . getTable ( ) [ y ] [ x ] ; x = current . getCol ( ) ; y = current . getRow ( ) ; value = board . getTable ( ) [ y ] [ x ] ; upBound = 0 ; lowBound = 9 ; leftBound = 0 ; rightBound = 8 ; for ( int i = 1 ; i <= 8 ; i ++ ) { x = current . getCol ( ) + Tdx [ i ] ; y = current . getRow ( ) + Tdy [ i ] ; cx = current . getCol ( ) + dx [ ( i + 1 ) / 2 ] ; cy = current . getRow ( ) + dy [ ( i + 1 ) / 2 ] ; if ( ( ( x >= leftBound ) && ( x <= rightBound ) ) && ( ( y >= upBound ) && ( y <= lowBound ) ) ) { if ( ( board . getTable ( ) [ y ] [ x ] != 0 ) && ( board . getTable ( ) [ cy ] [ cx ] == 0 ) ) { if ( board . getTable ( ) [ y ] [ x ] * value < 0 ) { CpTemp = new ChessPosition ( x , y , true ) ; } else { CpTemp = new ChessPosition ( x , y , false ) ; } pos . add ( CpTemp ) ; } } } return pos ; }
tr	9X	public String getString ( int id , int language ) throws IOException { if ( id == 0 ) return null ; if ( id < 0 || id > ff ) throw new IllegalArgumentException ( ) ; if ( ! checkedStrings ) getLanguages ( ) ; if ( languages == null || languages . length == 0 ) return null ; byte key = new byte ( ( byte ) id ) ; String retval = null ; if ( stringCache == null ) { synchronized ( lock ) { if ( stringCache == null ) { cachedLanguage = language ; stringCache = new Hashtable ( 7 ) ; } } } else if ( stringCache . containsKey ( key ) ) { Object value = stringCache . get ( key ) ; if ( value instanceof String ) return ( String ) value ; else return null ; } retval = ControlMessage . getString ( this , ( byte ) id , language ) ; if ( retval == null ) stringCache . put ( key , boolean . false ) ; else stringCache . put ( key , retval ) ; return retval ; }
tr	2	public static Connection getSimpleConnection ( ) { String DB_CONN_STRING = "jdbc:mysql://ichhd.dyndns.org:3309/tikTakToe" ; String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver" ; String USER_NAME = "subhash" ; String PASSWORD = "subhash" ; Connection result = null ; try { class . forName ( DRIVER_CLASS_NAME ) . newInstance ( ) ; } catch ( Exception ex ) { log ( "Check classpath. Cannot load db driver: " + DRIVER_CLASS_NAME ) ; } try { result = DriverManager . getConnection ( DB_CONN_STRING , USER_NAME , PASSWORD ) ; } catch ( SQLException e ) { log ( "Driver loaded  but cannot connect to db: " + DB_CONN_STRING ) ; } return result ; }
tr	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(0|101|11(01)*(1|00)1|(100|11(01)*(1|00)0)(1|0(01)*(1|00)0)*0(01)*(1|00)1)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 10 ; problemCount [ 1 ] = 20 ; problemCount [ 2 ] = 30 ; problemCount [ 3 ] = 40 ; problemCount [ 4 ] = 50 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { GraphvizRenderer . renderGraph ( starter . getWinner ( ) . getObj ( ) , "winner.svg" ) ; solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	8	@ Override public void run ( ) { isRunning = true ; while ( isRunning ) { if ( mediaPlayer != null ) { if ( ! warningPassed && passedTime > TIME_GREEN ) { warningPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "dong03.wav" ) ; } if ( ! finishPassed && passedTime > TIME_YELLOW ) { finishPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "end.wav" ) ; } } try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { repaint ( ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } Thread . yield ( ) ; } }
tr	6	public void scores ( Player player ) { switch ( player . getScore ( ) ) { case LOVE : player . setScore ( FIFTEEN ) ; break ; case FIFTEEN : player . setScore ( THIRTY ) ; break ; case THIRTY : determineFortyOrDeuce ( player ) ; break ; case DEUCE : determineAdvantageOrDeuce ( player ) ; break ; case FORTY : case ADVANTAGE : player . setScore ( WIN ) ; } }
tr	4	private void addSegmentsFor ( Obstacle source , Obstacle target ) { if ( source . intersects ( target ) ) addAllSegmentsBetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addSegmentsTargetAboveSource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addSegmentsTargetAboveSource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addSegmentsTargetBesideSource ( source , target ) ; else addSegmentsTargetBesideSource ( target , source ) ; }
tr	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	6	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede dividir un Tipo Int con un Tipo " + der . toString ( ) ) ; } } else if ( izq instanceof TipoFloat ) { if ( der instanceof TipoFloat || der instanceof TipoInt ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede dividir un Tipo Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede dividir Tipo " + izq . toString ( ) + " con Tipo " + der . toString ( ) ) ; } }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	2	public boolean isLeap ( ) { return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) || ( year % 400 == 0 ) ) ; }
tr	0	@ Override public List < Apontamento > obterPorOrdemServico ( int ordemServicoId ) { return session . createQuery ( "from Apontamento where OrdemServicoId = :ordemServicoId" ) . setString ( "ordemServicoId" , String . valueOf ( ordemServicoId ) ) . list ( ) ; }
tr	1	private void buttonGetResultActionPerformed ( java . awt . event . ActionEvent evt ) { System . out . println ( "inside Result Action Performed" ) ; try { new ResultWindow ( textUName . getText ( ) ) . setVisible ( true ) ; } catch ( Exception e ) { } }
tr	0	public void setProjectId ( int projectId ) { this . projectId = projectId ; }
tr	8	public boolean initHeaderComponents ( ) { locationLabel = new JLabel ( "Project Location" ) ; locationLabel . setBounds ( 5 , 5 , 100 , 25 ) ; locationField = new JTextField ( ) ; locationField . setBounds ( 105 , 5 , 400 , 25 ) ; includeLabel = new JLabel ( "Include File type" ) ; includeLabel . setBounds ( 5 , 35 , 100 , 25 ) ; includeTextField = new JTextField ( ) ; includeTextField . setBounds ( 105 , 35 , 400 , 25 ) ; nonIncludeLabel = new JLabel ( "Non include" ) ; nonIncludeLabel . setBounds ( 5 , 65 , 100 , 25 ) ; nonIncludeTextField = new JTextField ( ) ; nonIncludeTextField . setBounds ( 105 , 65 , 400 , 25 ) ; configIncludeAndNonInclude ( ) ; openFileButton = new JButton ( "File.." ) ; openFileButton . setBounds ( 515 , 5 , 80 , 25 ) ; openFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileChooser = new JFileChooser ( new File ( "c:" ) ) ; int i = fileChooser . showOpenDialog ( header ) ; if ( i == JFileChooser . APPROVE_OPTION ) { locationField . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; configButton = new JButton ( "Config.." ) ; configButton . setBounds ( 515 , 45 , 80 , 25 ) ; configButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { configIncludeAndNonInclude ( ) ; } } ) ; loadButton = new JButton ( "Load" ) ; loadButton . setBounds ( 605 , 5 , 80 , 80 ) ; loadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( locationField . getText ( ) == null || locationField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "File cannot be null!" ) ; return ; } if ( includeTextField . getText ( ) == null || includeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Include cannot be null!" ) ; return ; } if ( nonIncludeTextField . getText ( ) == null || nonIncludeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Non-Include cannot be null!" ) ; return ; } if ( sourceCounter == null ) { sourceCounter = new SourceCounter ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) , includeTextField . getText ( ) , nonIncludeTextField . getText ( ) ) ; } else { sourceCounter . setFiles ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) ) ; sourceCounter . repaint ( ) ; } } } ) ; header . add ( locationLabel ) ; header . add ( locationField ) ; header . add ( includeLabel ) ; header . add ( includeTextField ) ; header . add ( nonIncludeLabel ) ; header . add ( nonIncludeTextField ) ; header . add ( openFileButton ) ; header . add ( configButton ) ; header . add ( loadButton ) ; return false ; }
tr	0	public Position ( ) { }
tr	6	@ Override public String getMessage ( ) { if ( this . server != null && this . server2 != null ) { return String . format ( "%s %s %s" , this . getCommandName ( ) , this . server , this . server2 ) ; } if ( this . server != null && this . server2 == null ) { return String . format ( "%s %s" , this . getCommandName ( ) , this . server ) ; } if ( this . server == null && this . server2 != null ) { return String . format ( "%s :%s" , this . getCommandName ( ) , this . server2 ) ; } throw new RuntimeException ( "This state should not happen. There is probably a bug in a constructor." ) ; }
tr	8	public String ValidarCampo ( ComprobanteVenta BEEntidades ) { Result rs = new Result ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getNumero ( ) ) ? "Numero inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEmpresa ( ) ) ? "Empresa inv\u00E1lido " : "" ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getMoneda ( ) ) ? "Moneda inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_emision ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_vencimiento ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_pago ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getObservaciones ( ) ) ? "Observacion inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEstado ( ) ) ? "Esado inv\u00E1lido " : "" ) ; rs . SetResult ( ResultType . Advertencia , "Error de campo" , sb . toString ( ) ) ; return rs . toString ( ) ; }
tr	7	@ SuppressWarnings ( "unchecked" ) private static int countRunAndMakeAscending ( Object [ ] a , int lo , int hi ) { if ( DEBUG ) { assert lo < hi ; } int runHi = lo + 1 ; if ( runHi == hi ) { return 1 ; } if ( ( ( Comparable ) a [ runHi ++ ] ) . compareTo ( a [ lo ] ) < 0 ) { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) < 0 ) { runHi ++ ; } reverseRange ( a , lo , runHi ) ; } else { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) >= 0 ) { runHi ++ ; } } return runHi - lo ; }
tr	7	public ArrayList < Title > loadTitles ( String ... constrains ) { ArrayList < Title > list = new ArrayList < Title > ( ) ; Statement statement = null ; ResultSet resultSet = null ; String where = whereCreator ( constrains ) ; try { statement = db . createStatement ( ) ; System . out . println ( "SELECT * FROM title " + where + ";" ) ; resultSet = statement . executeQuery ( "SELECT * FROM title " + where + ";" ) ; while ( resultSet . next ( ) ) { Title item = new Title ( Integer . parseInt ( resultSet . getString ( "title_number" ) ) , resultSet . getString ( "market_code" ) , resultSet . getString ( "iban" ) , resultSet . getString ( "bic" ) , Integer . parseInt ( ( resultSet . getString ( "broker_number" ) != null ? resultSet . getString ( "broker_number" ) : "-1" ) ) , resultSet . getString ( "created_day" ) , double . parseDouble ( resultSet . getString ( "initial_value" ) ) , resultSet . getString ( "initial_value_currency" ) ) ; list . add ( item ) ; } resultSet . close ( ) ; statement . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { if ( statement != null ) { try { statement . close ( ) ; } catch ( SQLException e ) { } } if ( resultSet != null ) { try { resultSet . close ( ) ; } catch ( SQLException e ) { } } } return list ; }
tr	7	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	7	public static ProbabilityDistribution respond ( ProbabilityDistribution pd , PricingPolicy policy , PricingPolicy baseline , double awareness , double sensitivity , String responseType ) { double w = 2 ; double [ ] previousHist = pd . getHistogram ( ) ; double [ ] newHist = new double [ Constants . MIN_IN_DAY ] ; double [ ] policyArr = policy . getTOUArray ( ) ; double [ ] baseArr = baseline . getTOUArray ( ) ; switch ( responseType ) { case "None" : return pd ; case "Optimal" : newHist = shiftingOptimal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Normal" : newHist = shiftingNormal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Discrete" : newHist = shiftingDiscrete ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Daily" : newHist = shiftingDaily ( previousHist , baseArr , policyArr , awareness , sensitivity ) ; for ( int i = 0 ; i < newHist . length ; i ++ ) { if ( double . isNaN ( newHist [ i ] ) ) { newHist [ i ] = 0.0 ; } } break ; default : return pd ; } ProbabilityDistribution retPd = new Histogram ( newHist ) ; return retPd ; }
tr	0	@ Override public double calculateDiscount ( double price , int qty ) { return ( qty * dollarAmt ) ; }
tr	6	public Menu ( ) { for ( int i = 0 ; i < strmenus . length ; i ++ ) { menus [ i ] = new JMenu ( strmenus [ i ] ) ; menus [ i ] . setMnemonic ( strmenus [ i ] . charAt ( 0 ) ) ; this . add ( menus [ i ] ) ; } for ( int i = 0 ; i < strmenuitems . length ; i ++ ) { menuitems [ i ] = new JMenuItem ( strmenuitems [ i ] ) ; menuitems [ i ] . setMnemonic ( strmenuitems [ i ] . charAt ( 0 ) ) ; menuitems [ i ] . addActionListener ( new MenuListener ( ) ) ; if ( i == 0 ) menus [ 0 ] . add ( menuitems [ i ] ) ; else if ( i == 1 || i == 2 ) menus [ 1 ] . add ( menuitems [ i ] ) ; else if ( i == 3 ) menus [ 2 ] . add ( menuitems [ i ] ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PairImpl < ? > other = ( PairImpl < ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	9X	final public CreateTableCommand CreateTable_suffix ( ) throws ParseException { String tableName ; List < CreateTableCommand . AttributeDescriptor > attributeDescriptors = new ArrayList < CreateTableCommand . AttributeDescriptor > ( ) ; List < String > primaryKeyAttrNames = new ArrayList < String > ( ) ; List < CreateTableCommand . ForeignKeyDescriptor > foreignKeyDescriptors = new ArrayList < CreateTableCommand . ForeignKeyDescriptor > ( ) ; CreateTableCommand . AttributeDescriptor attributeDescriptor ; CreateTableCommand . ForeignKeyDescriptor foreignKeyDescriptor ; String name ; jj_consume_token ( KW_TABLE ) ; tableName = Identifier ( ) ; jj_consume_token ( 52 ) ; label_2 : while ( true ) { attributeDescriptor = AttrDecl ( ) ; jj_consume_token ( 51 ) ; attributeDescriptors . add ( attributeDescriptor ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : ; break ; default : jj_la1 [ 6 ] = jj_gen ; break label_2 ; } } jj_consume_token ( KW_PRIMARY ) ; jj_consume_token ( KW_KEY ) ; jj_consume_token ( 52 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; label_3 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 7 ] = jj_gen ; break label_3 ; } jj_consume_token ( 51 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; } jj_consume_token ( 53 ) ; label_4 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 8 ] = jj_gen ; break label_4 ; } jj_consume_token ( 51 ) ; foreignKeyDescriptor = ForeignKeyDecl ( ) ; foreignKeyDescriptors . add ( foreignKeyDescriptor ) ; } jj_consume_token ( 53 ) ; { if ( true ) return new CreateTableCommand ( token , tableName , attributeDescriptors , primaryKeyAttrNames , foreignKeyDescriptors ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	7	private void reflectClassWrapper ( Map < Type , Set < GeneTrait >> genePool , String className , int parameterCount , List < String > parameterTypes , int parametersSet ) throws ClassNotFoundException { if ( parametersSet < parameterCount ) { for ( BreedingClassSetup classSetup : Settings . getSettings ( ) . getClasses ( ) ) { if ( ! rawTypesClassMap . containsKey ( classSetup . className ) ) { if ( parameterTypes . size ( ) >= parametersSet + 1 ) { parameterTypes . remove ( parametersSet ) ; } parameterTypes . add ( parametersSet , classSetup . className ) ; reflectClassWrapper ( genePool , className , parameterCount , parameterTypes , parametersSet + 1 ) ; } } } else { class < ? > clazz = rawTypesClassMap . get ( className ) ; if ( clazz == null ) { clazz = class . forName ( className ) ; } Type classType = Type . getType ( className + ( ( parameterCount == 0 ) ? "" : ( "<" + Tools . implode ( parameterTypes , " " ) + ">" ) ) ) ; reflectClass ( genePool , clazz , className , classType , parameterTypes ) ; } }
tr	1	public void setPanelEnabled ( boolean enabled ) { if ( ! enabled ) { dimensionGroup . clearSelection ( ) ; clearDimensionSelection . setEnabled ( false ) ; } d1 . setEnabled ( enabled ) ; d2 . setEnabled ( enabled ) ; d3 . setEnabled ( enabled ) ; d4 . setEnabled ( enabled ) ; odno . setEnabled ( enabled ) ; mnogo . setEnabled ( enabled ) ; malo . setEnabled ( enabled ) ; indi . setEnabled ( enabled ) ; }
tr	7	@ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { if ( event . isCancelled ( ) ) { return ; } Player player = event . getPlayer ( ) ; if ( preChecks ( player , event . getTo ( ) ) ) { JumpPort port = JumpPorts . getPort ( event . getTo ( ) ) ; if ( checkInstant ( event ) ) { return ; } if ( checkJump ( event ) ) { return ; } if ( checkFall ( event ) ) { return ; } if ( ! ignoredPlayers . contains ( player . getName ( ) ) ) { player . sendMessage ( Lang . get ( "port.triggered" ) . replaceAll ( "%N" , port . getName ( ) ) . replaceAll ( "%D" , port . getDescription ( ) ) ) ; if ( port . getPrice ( ) > 0 ) { player . sendMessage ( Lang . get ( "port.price" ) . replaceAll ( "%P" , "" + port . getPrice ( ) ) ) ; } player . sendMessage ( Lang . get ( "port.triggers" ) ) ; ignoredPlayers . add ( player . getName ( ) ) ; } } }
tr	0	@ AfterClass public static void tearDownClass ( ) { }
tr	6	protected Shape createTriangle ( float fx , float fy , float tx , float ty , boolean rot ) { int size = 15 ; float dx = tx - fx ; float dy = ty - fy ; float D = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float z = ( dx <= 0 ) ? fx - D : fx + D ; float mid = ( dx <= 0 ) ? fx - D / 2 : fx + D / 2 ; float dec = ( dx <= 0 ) ? size : - size ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy + size / 2 ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; if ( rot ) { gp . moveTo ( mid + dec , fy - size / 2 ) ; gp . curveTo ( mid , fy - size , mid , fy + size , mid + dec , fy + size / 2 ) ; } double alpha = ( dx > 0 ) ? Math . asin ( dy / D ) : - Math . asin ( dy / D ) ; return alpha != 0 ? gp . createTransformedShape ( AffineTransform . getRotateInstance ( alpha , fx , fy ) ) : gp ; }
tr	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
tr	8	private LogItemParser parseComplexParser ( ) throws XMLStreamException { int event = reader . next ( ) ; LogItemParser parser = null ; LogParserBuilder builder = new LogParserBuilder ( ) ; while ( ! foundItemEnd ( event , "complex" ) ) { if ( event == XMLStreamConstants . START_ELEMENT ) { String elemName = reader . getLocalName ( ) ; if ( "simplesplittokenizer" . equals ( elemName ) ) { String splitStr = reader . getAttributeValue ( null , "splitStr" ) ; String start = reader . getAttributeValue ( null , "start" ) ; String stop = reader . getAttributeValue ( null , "stop" ) ; if ( splitStr != null ) { builder . withSimpleSplitTokenizer ( splitStr ) ; } else { builder . withSimpleSplitTokenizer ( start , stop ) ; } } else if ( "dateindexfinder" . equals ( elemName ) ) { String pattern = reader . getAttributeValue ( null , "pattern" ) ; String pos = reader . getAttributeValue ( null , "position" ) ; if ( pos != null ) { builder . withDateFinder ( pattern , Integer . parseInt ( pos ) ) ; } else { builder . withDateFinder ( pattern ) ; } } else if ( "maplinebuilder" . equals ( elemName ) ) { List < String > keys = parseKeys ( ) ; builder . withDateMapBuilder ( keys ) ; } } event = reader . next ( ) ; } parser = builder . build ( ) ; logItemClass = MapLogLine . class ; if ( parser == null ) { throw new XMLStreamException ( "Did not find a complete complex parser element" ) ; } return parser ; }
tr	1	public static String [ ] getMonths ( final boolean shortened ) { if ( shortened ) { return DATE_FORMAT_SYMBOLS . getShortMonths ( ) ; } else { return DATE_FORMAT_SYMBOLS . getMonths ( ) ; } }
tr	1	public SimulatorView ( Simulator sim ) { super ( sim ) ; colors = new LinkedHashMap < class < ? > , Color > ( ) ; fieldView = new FieldView ( 100 , 100 ) ; }
tr	2	public boolean removePrefFile ( CommonPrefEPFResource pfRem ) { if ( pfRem == null || pfRem . isConfig ( ) ) return false ; return prefFiles . remove ( pfRem ) ; }
tr	3	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
tr	7	private final boolean cons ( int i ) { switch ( b [ i ] ) { case a : case e : case i : case o : case u : return false ; case y : return ( i == 0 ) ? true : ! cons ( i - 1 ) ; default : return true ; } }
tr	9X	public boolean isModifier ( DataHolder dataholderHandler , String word , String modifier , String tag ) { if ( this . checkedModifiers . containsKey ( word ) ) { if ( this . checkedModifiers . get ( word ) ) { return true ; } else { return false ; } } Set < String > nouns = new HashSet < String > ( Arrays . asList ( "s p n" . split ( " " ) ) ) ; List < Entry < WordPOSKey , WordPOSValue >> entries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , nouns ) ; if ( entries . size ( ) > 0 ) { this . checkedModifiers . put ( word , true ) ; return true ; } Set < String > bPOS = new HashSet < String > ( ) ; bPOS . add ( "b" ) ; List < Entry < WordPOSKey , WordPOSValue >> boundaries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , bPOS ) ; boolean c1 = ( boundaries . size ( ) > 0 ) ; boolean c2 = dataholderHandler . getModifierHolder ( ) . containsKey ( word ) ; if ( c1 && ! c2 ) { this . checkedModifiers . put ( word , false ) ; return false ; } if ( ! c1 && c2 ) { this . checkedModifiers . put ( word , true ) ; return true ; } int mCount = this . getMCount ( dataholderHandler , word ) ; String wCopy = "" + word ; if ( StringUtility . isMatchedNullSafe ( word , "_" ) ) { wCopy = wCopy . replaceAll ( "_" , " - " ) ; } int tCount = 0 ; String pattern = "(^| )" + wCopy + " " ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String oSentence = sentenceItem . getOriginalSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( oSentence , pattern ) ) { tCount ++ ; } } if ( tCount == 0 || tCount > 0.25 * mCount ) { this . checkedModifiers . put ( word , false ) ; return false ; } else { this . checkedModifiers . put ( word , true ) ; return true ; } }
tr	9X	public static String nullSafeToString ( Object obj ) { if ( obj == null ) { return NULL_STRING ; } if ( obj instanceof String ) { return ( String ) obj ; } if ( obj instanceof Object [ ] ) { return nullSafeToString ( ( Object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return nullSafeToString ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return nullSafeToString ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return nullSafeToString ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return nullSafeToString ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return nullSafeToString ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return nullSafeToString ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return nullSafeToString ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return nullSafeToString ( ( short [ ] ) obj ) ; } String str = obj . toString ( ) ; return ( str != null ? str : EMPTY_STRING ) ; }
tr	5	private void addFileDropTarget ( Composite parent ) { final FileTransfer fileTransfer = FileTransfer . getInstance ( ) ; DropTarget target = new DropTarget ( parent , DND . DROP_COPY | DND . DROP_DEFAULT ) ; target . setTransfer ( new Transfer [ ] { fileTransfer } ) ; target . addDropListener ( new DropTargetListener ( ) { public void dragEnter ( DropTargetEvent event ) { if ( event . detail == DND . DROP_DEFAULT ) { if ( ( event . operations & DND . DROP_COPY ) > 0 ) { event . detail = DND . DROP_COPY ; } else { event . detail = DND . DROP_NONE ; } } } public void drop ( DropTargetEvent event ) { if ( fileTransfer . isSupportedType ( event . currentDataType ) ) { String [ ] files = ( String [ ] ) event . data ; for ( String file : files ) { try { controller . openFile ( file ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; displayErrorMessage ( "Error loading file: " + e . getMessage ( ) ) ; } } } } public void dropAccept ( DropTargetEvent event ) { } public void dragOver ( DropTargetEvent event ) { } public void dragOperationChanged ( DropTargetEvent event ) { } public void dragLeave ( DropTargetEvent event ) { } } ) ; }
tr	5	public int numDistinct ( String S , String T ) { int sum = 0 ; if ( T . length ( ) == 0 ) return 1 ; if ( T . length ( ) > S . length ( ) ) return 0 ; if ( T . length ( ) == S . length ( ) ) { if ( T . equals ( S ) ) return 1 ; else return 0 ; } int ind = S . indexOf ( T . charAt ( 0 ) ) ; if ( ind >= 0 ) { sum += numDistinct ( S . substring ( ind + 1 , S . length ( ) ) , T ) ; sum += numDistinct ( S . substring ( ind + 1 , S . length ( ) ) , T . substring ( 1 , T . length ( ) ) ) ; } return sum ; }
tr	5	private void handleFailed ( ) { uncompletedCount = 0 ; completedCount = 0 ; for ( OnDemandData onDemandData = ( OnDemandData ) requested . peekLast ( ) ; onDemandData != null ; onDemandData = ( OnDemandData ) requested . reverseGetNext ( ) ) if ( onDemandData . incomplete ) uncompletedCount ++ ; else completedCount ++ ; while ( uncompletedCount < 10 ) { OnDemandData onDemandData_1 = ( OnDemandData ) aClass19_1368 . popHead ( ) ; if ( onDemandData_1 == null ) break ; if ( filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] != 0 ) filesLoaded ++ ; filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] = 0 ; requested . insertHead ( onDemandData_1 ) ; uncompletedCount ++ ; closeRequest ( onDemandData_1 ) ; waiting = true ; } }
tr	3	public void backPropagate ( double [ ] target , double learningSpeed ) { double [ ] oError = calculateError ( getOutput ( ) , target , learningSpeed ) ; for ( double n : oError ) if ( double . isNaN ( n ) ) throw new RuntimeException ( "calculateError resulted in NaN" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] iError = backPropagateLayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oError , learningSpeed ) ; updateBias ( weights . get ( l ) , oError ) ; oError = iError ; } }
tr	5	@ Override public int hashCode ( ) { int result = iduser ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( lastName != null ? lastName . hashCode ( ) : 0 ) ; result = 31 * result + ( email != null ? email . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( activateKey != null ? activateKey . hashCode ( ) : 0 ) ; return result ; }
tr	9X	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	7	@ Override public LinkedList < Individual > crossover ( int [ ] parents , Population pop ) { LinkedList < Individual > children = new LinkedList < Individual > ( ) ; Random r = new Random ( ) ; int r1 = r . nextInt ( parents . length ) ; int r2 = r . nextInt ( parents . length ) ; Individual p1 = pop . people [ parents [ r1 ] ] ; Individual p2 = pop . people [ parents [ r2 ] ] ; int dna1 [ ] [ ] = new int [ 9 ] [ 9 ] ; int dna2 [ ] [ ] = new int [ 9 ] [ 9 ] ; Sudoku parent1 = ( ( Sudoku ) p1 ) ; Sudoku parent2 = ( ( Sudoku ) p2 ) ; for ( int row = 0 ; row < 9 ; row ++ ) { int cut1 = r . nextInt ( 9 ) ; int cut2 = r . nextInt ( 9 ) ; if ( cut2 < cut1 ) { int temp = cut1 ; cut1 = cut2 ; cut2 = temp ; } for ( int col = 0 ; col < 9 ; col ++ ) { if ( col <= cut1 || col >= cut2 ) { dna1 [ row ] [ col ] = parent2 . rows [ row ] [ col ] ; dna2 [ row ] [ col ] = parent1 . rows [ row ] [ col ] ; } else { int a = parent1 . rows [ row ] [ col ] ; if ( ! contains ( a , dna2 [ row ] ) ) dna2 [ row ] [ col ] = a ; int b = parent2 . rows [ row ] [ col ] ; if ( ! contains ( b , dna1 [ row ] ) ) dna1 [ row ] [ col ] = b ; } } } children . add ( new Sudoku ( dna1 ) ) ; children . add ( new Sudoku ( dna2 ) ) ; return children ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PosListaPrecioEntityPK that = ( PosListaPrecioEntityPK ) o ; if ( pcaIdElemento != that . pcaIdElemento ) return false ; if ( pcaPosId != null ? ! pcaPosId . equals ( that . pcaPosId ) : that . pcaPosId != null ) return false ; return true ; }
tr	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back != null ) != ( that . back != null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
tr	3	public static Shell Create ( ByteList messageBytes ) throws Exception { Shell result ; if ( messageBytes == null || messageBytes . getLength ( ) < 6 ) { throw new Exception ( "Invalid message byte array" ) ; } if ( messageBytes . peekInt ( ) != Shell . getClassID ( ) ) { throw new Exception ( "Invalid message type" ) ; } else { result = new Shell ( ) ; result . decode ( messageBytes ) ; } return result ; }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	7	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Radical > radicals = new ArrayList < Radical > ( ) ; for ( int i = 0 ; i <= SIZE ; i ++ ) radicals . add ( new Radical ( i , primeList ) ) ; radicals = sort ( radicals ) ; System . out . print ( radicals . get ( SIZE / 10 ) . num ) ; }
tr	8	public int minimumTotal ( ArrayList < ArrayList < Integer >> triangle ) { int out = 0 ; int min ; if ( triangle == null || triangle . size ( ) == 0 ) return out ; int tLevel = triangle . size ( ) ; out = triangle . get ( 0 ) . get ( 0 ) ; ArrayList < Integer > candidate = new ArrayList < Integer > ( ) ; candidate . add ( out ) ; ArrayList < Integer > next ; for ( int level = 1 ; level < tLevel ; level ++ ) { next = new ArrayList < Integer > ( ) ; int k ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) k = triangle . get ( level ) . get ( 0 ) + candidate . get ( 0 ) ; else if ( i == level ) k = triangle . get ( level ) . get ( i ) + candidate . get ( i - 1 ) ; else { k = triangle . get ( level ) . get ( i ) ; k += Math . min ( candidate . get ( i - 1 ) , candidate . get ( i ) ) ; } next . add ( k ) ; } candidate . clear ( ) ; candidate = next ; } if ( candidate . size ( ) != 0 ) { min = candidate . get ( 0 ) ; for ( int c : candidate ) { min = Math . min ( min , c ) ; } out = min ; } return out ; }
tr	5	@ Override public void run ( ) { while ( beatWork ) { heartRate = messageResource . getHR ( ) ; if ( heartRate != 0 ) { int sleep = 1000 / heartRate ; try { Thread . sleep ( 40 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 1 ) ; try { Thread . sleep ( 20 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 0 ) ; } else { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	8	Vector < Integer > getNeighboringIndexes ( int index ) { Vector < Integer > result = new Vector < Integer > ( 6 ) ; int row = getRow ( index ) ; int col = getColumn ( index ) ; int offset = getOffset ( row ) ; if ( row < numRows - 1 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row + 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row + 1 , col + offset ) ) ; } } if ( col > 0 ) { result . add ( getIndex ( row , col - 1 ) ) ; } if ( col < numColumns - 1 ) { result . add ( getIndex ( row , col + 1 ) ) ; } if ( row > 0 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row - 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row - 1 , col + offset ) ) ; } } result . trimToSize ( ) ; return result ; }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int p1 ; p0 = new int [ ] { 5 , 1 , 2 } ; p1 = 4 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 4 } ; p1 = 8 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 2 , 7 } ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 94512 , 2 , 87654 , 81316 , 6 , 5 , 6 , 37151 , 6 , 139 , 1 , 36 , 307 , 1 , 377 , 101 , 8 , 37 , 58 , 1 } ; p1 = 1092 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 883 , 66392 , 3531 , 28257 , 1 , 14131 , 57 , 1 , 25 , 88474 , 4 , 1 , 110 , 6 , 1769 , 220 , 442 , 7064 , 7 , 13 } ; p1 = 56523 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 3 } ; p1 = 1 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	4	private void txtEdgeCostKeyPressed ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyCode ( ) == 10 ) { if ( ! txtVertexName . getText ( ) . isEmpty ( ) && txtVertexName . getText ( ) . length ( ) != 0 ) { drawing . addVertex ( txtVertexName . getText ( ) ) ; txtVertexName . setText ( "" ) ; } int cost = 1 ; if ( ! txtEdgeCost . getText ( ) . isEmpty ( ) ) { cost = Integer . parseInt ( txtEdgeCost . getText ( ) ) ; } drawing . addEdge ( cost ) ; txtEdgeCost . setText ( "" ) ; txtVertexName . requestFocus ( ) ; } }
tr	5	private static String normalized ( String s ) { if ( s == null ) return null ; StringBuffer buf = new StringBuffer ( ) ; boolean seenCR = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; if ( ch == '' ) { buf . append ( '' ) ; seenCR = true ; } else if ( ch == '' ) { if ( ! seenCR ) { buf . append ( ch ) ; } seenCR = false ; } else { buf . append ( ch ) ; seenCR = false ; } } s = buf . toString ( ) ; return s ; }
tr	3	public void setType ( int type ) { if ( getType ( ) == type ) { return ; } switch ( type ) { case DOUBLE_TYPE : imp = new DoubleBenoitNumber ( doubleValue ( ) ) ; break ; case BIG_TYPE : imp = new BigDecimalBenoitNumber ( bigValue ( ) ) ; break ; default : throw new IllegalArgumentException ( "Invalid type" ) ; } }
tr	7	public static void main ( String [ ] args ) throws NumberAlreadyEnteredException , FileNotFoundException { Network aNetwork = new Network ( ) ; PhoneNumber aPhone = new PhoneNumber ( LineType . MOBILE1 , "3016513831" ) ; PhoneNumber anotherPhone = new PhoneNumber ( LineType . MOBILE1 , "9176823411" ) ; Contact rena = new PhoneOwner ( "Rena Friedman" , aPhone ) ; Contact Professor = new PhoneOwner ( "Professor Plonczack" , anotherPhone ) ; RunCellPhone a = null , b = null ; try { a = new RunCellPhone ( rena . getName ( ) , "./renaCellPhone.ser" , aNetwork , rena . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up phone" ) ; e . printStackTrace ( ) ; System . exit ( 0 ) ; } try { b = new RunCellPhone ( Professor . getName ( ) , "./professorCellPhone.ser" , aNetwork , Professor . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up bank" ) ; System . exit ( 0 ) ; } try { System . out . println ( "Adding Contacts..." ) ; a . aCell . addContact ( Professor . getName ( ) , Professor . getPhoneNumber ( ) ) ; a . aFrame . refresh ( ) ; b . aCell . addContact ( rena . getName ( ) , rena . getPhoneNumber ( ) ) ; b . aFrame . refresh ( ) ; System . out . println ( "Added" ) ; } catch ( NumberAlreadyEnteredException e ) { System . out . println ( "Numbers already added" ) ; } }
tr	7	public void connect2 ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) return ; TreeLinkNode cur = root ; TreeLinkNode sibling ; TreeLinkNode next = null ; while ( cur != null && cur . left != null ) { next = cur . left ; while ( cur != null ) { if ( cur . next != null ) sibling = cur . next . left ; else sibling = null ; cur . left . next = cur . right ; cur . right . next = sibling ; cur = cur . next ; } cur = next ; } }
tr	3	public static String getPalindrome ( String s , int l , int r ) { char [ ] arr = s . toCharArray ( ) ; while ( l >= 0 && r < arr . length ) { if ( arr [ l ] != arr [ r ] ) break ; l -- ; r ++ ; } return s . substring ( l + 1 , r ) ; }
tr	1	public static float distanceBetween ( Creature t , Creature o2 ) { float x1 , x2 , y1 , y2 ; x1 = t . getX ( ) ; y1 = t . getY ( ) ; if ( o2 instanceof Ship ) { Ship s = ( Ship ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } else { Sprite s = ( Sprite ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } return distanceBetween ( x1 , y1 , x2 , y2 ) ; }
tr	2	@ Override public boolean login ( ) throws LoginException { NameCallback nameCallback = new NameCallback ( "Name : " ) ; PasswordCallback passwordCallback = new PasswordCallback ( "Password : " , false ) ; try { callbackHandler . handle ( new Callback [ ] { nameCallback , passwordCallback } ) ; String username = nameCallback . getName ( ) ; String password = new String ( passwordCallback . getPassword ( ) ) ; nameCallback . setName ( "" ) ; passwordCallback . clearPassword ( ) ; Customer customer = null ; if ( customer == null ) { throw new LoginException ( "Authentication failed" ) ; } return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new LoginException ( e . getMessage ( ) ) ; } }
tr	1	private void beforeShade ( Light light , ColorRGB color ) { for ( TracerInterceptor interceptor : interceptors ) { interceptor . beforeShade ( light , color ) ; } }
tr	4	@ Override public void notifySample ( Sample s ) { switch ( mode ) { case CLASSIFYING : System . out . println ( "add sample to classify" ) ; Gesture g = classifier . classifySample ( s ) ; gui . showClassifiedGesture ( g ) ; break ; case IDLE : System . out . println ( "Idle Sample" ) ; break ; case RECORDING : break ; case TRAINING : System . out . println ( "add Training Sample" ) ; Gesture currentGesture = gui . getCurrentGesture ( ) ; trainer . addSample ( s , currentGesture ) ; break ; default : break ; } }
tr	8	public String longestPrefixOf ( String string ) { if ( string == null ) { throw new IllegalArgumentException ( ) ; } if ( root == null ) { return null ; } int longest = - 1 ; if ( root . value != null ) { longest = 0 ; } Node < V > node = root ; int length = string . length ( ) ; for ( int i = 0 ; i < length && node != null ; ++ i ) { char c = string . charAt ( i ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } node = node . next [ c ] ; if ( node . value != null ) { longest = i + 1 ; } } if ( longest == - 1 ) { return null ; } return string . substring ( 0 , longest ) ; }
tr	0	@ Override public boolean setPacketFields ( Map < String , Object > in ) { return true ; }
tr	5	private static interface getHID ( Device dev ) throws IOException { Configuration config ; interface retval = null ; DeviceDescriptor info = dev . getDeviceDescriptor ( ) ; if ( info . getDeviceClass ( ) != 0 ) throw new IllegalArgumentException ( "dev class" ) ; config = dev . getConfiguration ( ) ; for ( int i = config . getNumInterfaces ( ) ; i -- != 0 ; ) { interface intf = config . getInterface ( i , 0 ) ; if ( intf . getInterfaceClass ( ) == intf . CLASS_HID ) { if ( retval != null ) throw new IllegalArgumentException ( "multi-hid" ) ; retval = intf ; } } if ( retval == null ) throw new IllegalArgumentException ( "not hid" ) ; return retval ; }
tr	0	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
tr	8	public void menuAction ( JMenu selectMenu ) { MainFrame mainFrame = MainFrame . getInstance ( ) ; AttdFrame workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . setVisible ( false ) ; for ( int i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . equals ( selectMenu ) ) { switch ( i ) { case 0 : mainFrame . setCurrentFrameEditCourse ( ) ; break ; case 1 : mainFrame . setCurrentFrameEditStudent ( ) ; break ; case 2 : mainFrame . setCurrentFrameCourseEnroll ( ) ; break ; case 3 : mainFrame . setCurrentFrameAttendance ( ) ; break ; case 4 : mainFrame . setCurrentFrameShowClassAR ( ) ; break ; case 5 : mainFrame . setCurrentFrameShowClassRP ( ) ; break ; default : break ; } break ; } } workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . display ( ) ; }
tr	2	@ Override public void setArtistUrl ( String url ) { if ( url != null && url . length ( ) > 0 ) { invalidateDataLength ( ) ; ID3v2WWWFrameData frameData = new ID3v2WWWFrameData ( useFrameUnsynchronisation ( ) , url ) ; addFrame ( createFrame ( ID_ARTIST_URL , frameData . toBytes ( ) ) , true ) ; } }
tr	7	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
tr	0	public String getReturn ( ) { return _return ; }
tr	6	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	1	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new Application ( ) ) ; app . setDisplayMode ( SCREEN_WIDTH , SCREEN_HEIGHT , false ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	7	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	6	public boolean equals ( Grade g ) { if ( ! this . assignmentId . equals ( g . getAssignmentId ( ) ) ) { return false ; } else if ( ! this . comments . equals ( g . getComments ( ) ) ) { return false ; } else if ( this . courseId != g . getCourseId ( ) ) { return false ; } else if ( this . ptsEarn != g . getPointsEarned ( ) ) { return false ; } else if ( this . ptsPoss != g . getPointsPossible ( ) ) { return false ; } else if ( ! this . title . equals ( g . getTitle ( ) ) ) { return false ; } else { return true ; } }
tr	0	private static void writeFile ( File destFile , String content ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( destFile ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; writer = null ; }
tr	5	@ SuppressWarnings ( "unchecked" ) public static void main ( String args [ ] ) { Repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new Repl < > ( FractalEvaluator . class ) ; repl . loop ( ) ; } else { try { repl = new Repl ( class . forName ( args [ 0 ] ) ) ; ArrayList < String > fileList = new ArrayList < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { fileList . add ( args [ i ] ) ; } repl . visitFiles ( fileList ) ; repl . loop ( ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( cnfe . getMessage ( ) ) ; System . exit ( 1 ) ; } } }
tr	1	@ Override public Object visitBooleanLiteral ( BooleanLiteral bool , Integer arg ) { if ( bool . spelling . equals ( "true" ) ) { Machine . emit ( Op . LOADL , Machine . trueRep ) ; } else { Machine . emit ( Op . LOADL , Machine . falseRep ) ; } return null ; }
tr	2	public static int getSeqVal ( String sql ) { try { PreparedStatement stat = connection . prepareStatement ( sql ) ; ResultSet re = stat . executeQuery ( ) ; if ( re . next ( ) ) { return re . getInt ( 1 ) ; } else { return - 1 ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return - 1 ; }
tr	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
tr	6	private boolean isPredictableResult ( ) { boolean commSet = true ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( this . communityCards [ i ] == null ) { commSet = false ; break ; } } if ( commSet ) { boolean correctPlayerTypes = false ; for ( PlayerProfile profile : this . profiles ) { if ( profile . getHandType ( ) != HandType . EXACTCARDS ) { correctPlayerTypes = true ; break ; } } if ( ! correctPlayerTypes ) { return true ; } } return false ; }
tr	5	public static void execute ( ICommand command ) throws FogBugzException { if ( getPage ( ) == null && ! checkingApi ) { checkApi ( ) ; } if ( ! checkingApi && ! loggedIn ) { logger . info ( "Token was not set. Trying to login." ) ; login ( ) ; if ( getToken ( ) . getToken ( ) != null ) { logger . info ( "Login was successful: " + getToken ( ) . getToken ( ) ) ; } else { logger . warn ( "Login failed." ) ; } } URLFetcher . setCommand ( command ) ; URLFetcher . setConnection ( getConnection ( ) ) ; URLFetcher . setToken ( getToken ( ) ) ; URLFetcher . setRequestPage ( getPage ( ) ) ; String uri = URLFetcher . generateRequest ( ) ; logger . info ( "Using URL for request: " + uri ) ; command . addListener ( Processor . getInstance ( ) ) ; command . execute ( uri ) ; }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	2	private synchronized void sendPlain ( String text ) { if ( getState ( ) == STATE_READY ) try { transport . send ( text ) ; } catch ( Exception e ) { outputBuffer . add ( text ) ; } else { outputBuffer . add ( text ) ; } }
tr	4	public boolean put ( int key , int value ) { LinkedNode root = this ; if ( root == null ) { return false ; } while ( root . getNext ( ) != null ) { if ( root . getKey ( ) == key ) return false ; root = root . getNext ( ) ; } if ( root . getKey ( ) == key ) return false ; root . setNext ( new LinkedNode ( key , value ) ) ; return true ; }
tr	4	public void equipWeapon ( Survivor survivor , Weapon weapon ) throws CantEquipWeaponException { if ( ! this . survivors . contains ( survivor ) ) { throw new CantEquipWeaponException ( CantEquipWeaponException . notInTheTeam ( survivor ) ) ; } else if ( ! this . mainBase . getAvailableWeapons ( ) . contains ( weapon ) ) { throw new CantEquipWeaponException ( "Weapon must be one of those stored in base to equip" ) ; } else { Survivor owner = this . alreadyEquipped ( weapon ) ; if ( owner != null ) { throw new CantEquipWeaponException ( "Weapon is already equipped by " + owner . getName ( ) ) ; } else { Weapon oldWeapon = survivor . getWeapon ( ) ; this . mainBase . getAvailableWeapons ( ) . remove ( weapon ) ; survivor . setWeapon ( weapon ) ; if ( oldWeapon != null ) { this . mainBase . getAvailableWeapons ( ) . add ( oldWeapon ) ; } } } }
tr	6	public boolean act ( Agent agent , Action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateViews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { SimulatedAgent a = ( SimulatedAgent ) agent ; int x = ( ( Integer ) a . getAttribute ( X ) ) . intValue ( ) ; int y = ( ( Integer ) a . getAttribute ( Y ) ) . intValue ( ) ; Percept p = sense ( a ) ; String msg = null ; String act = action . getCode ( ) ; int actionID = language . getActionIndex ( act ) ; switch ( actionID ) { case 4 : if ( ( ( boolean ) p . getAttribute ( language . getPercept ( 5 ) ) ) . booleanValue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { System . out . println ( "Eating good food..." ) ; energy_level = Math . min ( energy_level + INC_ENERGY_LEVEL , MAX_ENERGY_LEVEL ) ; } else { System . out . println ( "Eating bad food..." ) ; energy_level = Math . max ( energy_level - DEC_ENERGY_LEVEL , 0 ) ; } } else { msg = SimpleView . ERROR + "[There is not food. Eat action not executed]" ; } updateViews ( msg ) ; break ; default : if ( actionID == 2 ) { energy_level -- ; System . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
tr	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
tr	6	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	0	public void setC ( float C ) { this . C = C ; }
tr	2	public static void createTableCourseProtocols ( ) { try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "table CourseProtocols not created" ) ; dbConn . setAutoCommit ( false ) ; dbStmnt = dbConn . createStatement ( ) ; dbStmnt . executeUpdate ( "use phdStudent;" ) ; dbStmnt . executeUpdate ( "create table if not exists CourseProtocols" + "( id int auto_increment primary key " + "protoName varchar(255) not null);" ) ; dbConn . commit ( ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	5	public void handle ( Connection connection , Request request ) { logger . debug ( "NickCommand handler : " + request ) ; if ( StringUtils . isEmpty ( request . getArgs ( ) ) ) { connection . serverSendCommandToMe ( "431 ERR_NONICKNAMEGIVEN :No nickname given" ) ; return ; } String newNickname = request . getArgs ( ) . trim ( ) ; String oldNickName = connection . getNickname ( ) ; if ( newNickname . startsWith ( ":" ) ) { newNickname = newNickname . substring ( 1 ) ; } if ( ! isNickCorrectlyFormat ( newNickname ) ) { connection . serverSendCommandToMe ( "432 ERR_ERRONEUSNICKNAME " + newNickname + " :Erroneus nickname" ) ; return ; } if ( connection . isNickExist ( newNickname ) ) { connection . serverSendCommandToMe ( "433 ERR_NICKNAMEINUSE " + newNickname + " :Nickname is already in use" ) ; return ; } if ( StringUtils . isNotEmpty ( oldNickName ) ) { connection . meSendCommandToAll ( "NICK " + newNickname ) ; } connection . setNickname ( newNickname ) ; }
tr	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	1	@ Override protected void validateTree ( ) { if ( ! view . isProcessing ( name ) ) super . validateTree ( ) ; }
tr	1	private Meter getSelectedMeter ( ) { Account temp = getSelectedAccount ( ) ; if ( temp != null ) { Meter m = temp . getMeter ( getSelectedMeterID ( ) ) ; return m ; } else return null ; }
tr	8	private void createGame ( ) { gameName = fieldGameName . getText ( ) ; playerNameHost = fieldPlayerName . getText ( ) ; Enumeration < NetworkInterface > nets = null ; try { nets = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e1 ) { } Vector < String > l = new Vector < String > ( ) ; for ( NetworkInterface netint : Collections . list ( nets ) ) { Enumeration < InetAddress > inetAddresses = netint . getInetAddresses ( ) ; for ( InetAddress inetAddress : Collections . list ( inetAddresses ) ) { l . add ( netint . getDisplayName ( ) + " (" + inetAddress . toString ( ) . substring ( 1 ) + ")" ) ; } } Object selVal = JOptionPane . showInputDialog ( this , "Choose interface to bind" , "Input" , JOptionPane . INFORMATION_MESSAGE , null , l . toArray ( ) , l . elementAt ( 0 ) ) ; String ip = selVal . toString ( ) ; int beg = ip . lastIndexOf ( ( ) ; int end = ip . lastIndexOf ( ) ) ; String ipAddr = selVal . toString ( ) . substring ( beg + 1 , end ) ; try { addr = InetAddress . getByName ( ipAddr ) ; } catch ( UnknownHostException e1 ) { } if ( gameName == null || gameName . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each game needs a name" , "Game Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( playerNameHost == null || playerNameHost . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each player needs a name" , "Player Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } dispose ( ) ; s = new Server ( ipAddr ) ; adapter . connectToServer ( addr , playerNameHost ) ; hostFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; hostFrame . setTitle ( "Snake on Lan - Host Game" ) ; hostFrame . setVisible ( true ) ; hostFrame . setResizable ( false ) ; hostFrame . setLocationRelativeTo ( null ) ; StartSnakeGame . frame . dispose ( ) ; }
tr	9X	private static boolean isUnreserved ( char c ) { return ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || c == . || c == - || c == _ || c == ~ ; }
tr	5	private static void loadVersionProperties ( ) { ClassLoader loader = ReleaseInfo . class . getClassLoader ( ) ; Properties info = new Properties ( ) ; InputStream stream = loader . getResourceAsStream ( PROPERTY_FILE ) ; if ( stream == null ) stream = loader . getResourceAsStream ( "/" + PROPERTY_FILE ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildVersion = info . getProperty ( "version" ) ; buildDate = info . getProperty ( "build.date" ) ; } catch ( IOException e ) { } } if ( buildVersion == null ) buildVersion = "unknown" ; if ( buildDate == null ) buildDate = "unknown" ; }
tr	2	public static ProcessorLayer createProcessorLayerWithProcessorNeuron ( int neuronsNum , boolean bias ) { ProcessorLayer layer = new ProcessorLayer ( ) ; if ( bias ) { layer . addNeuron ( new BiasNeuron ( ) ) ; } for ( int i = 0 ; i < neuronsNum ; i ++ ) layer . addNeuron ( new ProcessorNeuron ( ) ) ; return layer ; }
tr	7	public class < ? > [ ] genericsTypes ( class < ? > superClazz ) { Type type = getGenericSupertype ( clazz , superClazz ) ; List < class < ? >> types = new LinkedList < class < ? >> ( ) ; if ( type instanceof ParameterizedType ) { Type [ ] paramTypes = ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) ; types . addAll ( evalTypesAsClasses ( paramTypes ) ) ; } else if ( type instanceof GenericArrayType ) { Type paramType = ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ; types . add ( evalTypesAsClasses ( paramType ) . get ( 0 ) ) ; } return types . toArray ( new class < ? > [ types . size ( ) ] ) ; }
tr	1	public ActionDialog ( SkyQuestUtility util , JComponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new JButton ( "Save" ) ; cancel = new JButton ( "Cancel" ) ; amodel = new DefaultListModel < ActionType > ( ) ; atypes = new JList < ActionType > ( amodel ) ; for ( ActionType a : QuestManager . getInstance ( ) . getRegisteredActionTypes ( ) ) amodel . addElement ( a ) ; setLayout ( new BorderLayout ( ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; JPanel ap = new JPanel ( ) ; ap . setLayout ( new BorderLayout ( ) ) ; ap . add ( "Center" , atypes ) ; ap . add ( "North" , new JLabel ( "Type" ) ) ; add ( "South" , buttons ) ; cancel . addActionListener ( this ) ; save . addActionListener ( this ) ; }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	8	public static int searchInt ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchInt ( arr , low , mid - 1 , x ) ; else return searchInt ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchInt ( arr , mid + 1 , high , x ) ; else return searchInt ( arr , low , mid , x ) ; } }
tr	9X	private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; }
tr	3	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	5	public String getDescription ( ) { if ( kinds . size ( ) == 0 ) return "Gathering resources" ; String result = "Gathering " ; int i = 0 ; for ( Resource res : kinds ) { if ( i == kinds . size ( ) - 1 && i != 0 ) { result += " and " ; } else if ( i != 0 ) { result += "  " ; } result += res . name ; ++ i ; } return result ; }
tr	2	@ Test public void testTwoDimensionalArrays ( ) { final int rows = 3 ; final int cols = 4 ; int count = 0 ; int [ ] [ ] matrix = new int [ rows ] [ cols ] ; for ( int row = 0 ; row < rows ; row ++ ) { for ( int col = 0 ; col < cols ; col ++ ) { matrix [ row ] [ col ] = count ++ ; } } assertEquals ( 11 , matrix [ 2 ] [ 3 ] ) ; assertEquals ( 6 , matrix [ 1 ] [ 2 ] ) ; }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	3	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	2	private ArrayList < AtomExecutableCommand > populateExecutableCommandList ( String serverId , ArrayList < AtomExecutableCommand > commandList ) { AtomExecutableCommand _commandDet ; ArrayList < AtomExecutableCommand > _commandList ; int index = 0 ; int _countExecutables ; _commandList = new ArrayList < AtomExecutableCommand > ( ) ; _countExecutables = commandList . size ( ) ; while ( _countExecutables > index ) { _commandDet = commandList . get ( index ) ; if ( serverId . equals ( _commandDet . getServerID ( ) ) ) { _commandList . add ( _commandDet ) ; } index ++ ; } return _commandList ; }
tr	3	@ Override public void process ( ) { String [ ] s = curDir . list ( stringS . getStringFilter ( ) . getFilenameFilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { String x = stringS . substitute ( s [ i ] ) ; String t = s [ i ] + " => " + x ; if ( ! isPreview ) t += new File ( curDir , s [ i ] ) . renameTo ( new File ( curDir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; Print . ln ( t ) ; } Print . ln ( "Total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
tr	5	BufferedImage getRetroChar ( final char c , final Color color ) { int code = ( int ) c ; if ( code < 0 || c > 255 ) { code = ( int ) ? ; } final int row = code >> 4 ; final int col = code % 16 ; final BufferedImage subimg = font . getSubimage ( col << 3 , row << 3 , 8 , 8 ) ; final BufferedImage result = new BufferedImage ( subimg . getWidth ( ) , subimg . getHeight ( ) , subimg . getType ( ) ) ; subimg . copyData ( result . getRaster ( ) ) ; for ( int x = 0 ; x < result . getWidth ( ) ; ++ x ) { for ( int y = 0 ; y < result . getHeight ( ) ; ++ y ) { if ( result . getRGB ( x , y ) == FFFFFFFF ) { result . setRGB ( x , y , color . getRGB ( ) ) ; } } } return result ; }
tr	4	private int calcNumPattern ( int n , int r ) { if ( n == r ) return 1 ; else if ( n == 1 ) return 1 ; else if ( r == 1 ) return n ; if ( dp [ n ] [ r ] == 0 ) dp [ n ] [ r ] = ( calcNumPattern ( n - 1 , r - 1 ) + calcNumPattern ( n - 1 , r ) ) % NUM_MOD ; return dp [ n ] [ r ] ; }
tr	1	public RBTree ( LinkSetNode _template ) { template = _template ; if ( template instanceof TimedLinkSetNode ) { dummy = ( ( TimedLinkSetNode ) template ) . newNode ( 0 , 0 , NodeColor . RED , null , null , 0 ) ; } else { dummy = template . newNode ( 0 , 0 , NodeColor . RED , null , null ) ; } root = null ; }
tr	5	protected static void validateCertificateChain ( Certificate [ ] ownCerts , Certificate [ ] native_certs ) throws Exception { if ( ownCerts == null ) return ; if ( native_certs == null ) throw new Exception ( "Unable to validate certificate chain. Native entry did not have a certificate chain at all" ) ; if ( ownCerts . length != native_certs . length ) throw new Exception ( "Unable to validate certificate chain. Chain differs in length [" + ownCerts . length + " vs " + native_certs . length + "]" ) ; for ( int i = 0 ; i < ownCerts . length ; i ++ ) if ( ! ownCerts [ i ] . equals ( native_certs [ i ] ) ) throw new Exception ( "Certificate mismatch: " + ownCerts [ i ] + " != " + native_certs [ i ] ) ; }
tr	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
tr	7	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	4	RendererContext ( final String name ) { if ( LOG_CREATE_CONTEXT ) { MarlinUtils . logInfo ( "new RendererContext = " + name ) ; } this . name = name ; nPCPathIterator = new NormalizingPathIterator . NearestPixelCenter ( float6 ) ; nPQPathIterator = new NormalizingPathIterator . NearestPixelQuarter ( float6 ) ; transformerPC2D = new TransformingPathConsumer2D ( ) ; cache = new MarlinCache ( this ) ; renderer = new Renderer ( this ) ; ptg = new MarlinTileGenerator ( renderer ) ; stroker = new Stroker ( this ) ; dasher = new Dasher ( this ) ; switch ( MarlinRenderingEngine . REF_TYPE ) { default : case MarlinRenderingEngine . REF_HARD : reference = this ; break ; case MarlinRenderingEngine . REF_SOFT : reference = new SoftReference < RendererContext > ( this ) ; break ; case MarlinRenderingEngine . REF_WEAK : reference = new WeakReference < RendererContext > ( this ) ; break ; } }
tr	5	private static String decimalToBinary ( double d ) { if ( d >= 1 || d <= 0 ) { return "ERROR" ; } StringBuilder result = new StringBuilder ( "0." ) ; while ( d > 0 ) { if ( result . length ( ) > 32 ) { return "ERROR" ; } double multiplied = d * 2 ; if ( multiplied >= 1 ) { result . append ( "1" ) ; d = multiplied - 1 ; } else { result . append ( "0" ) ; d = multiplied ; } } return result . toString ( ) ; }
tr	8	public void run ( ) { HttpRequest hq = null ; try { boolean successfull = false ; if ( inbound == null || inbound . isClosed ( ) ) { isDead = true ; return ; } hq = HttpRequest . createRequest ( ) ; successfull = hq . readRequest ( inbound ) ; if ( hq . passthroughssl ( ) ) { new Thread ( new ShortCircuitSSLProxy ( hq ) ) . start ( ) ; } if ( ! GizmoView . getView ( ) . intercepting ( ) || ! GizmoView . getView ( ) . matchRequest ( hq . contents ( ) ) ) { hq . fetchResponse ( false ) ; if ( hq . passthroughssl ( ) ) { new Thread ( new ShortCircuitSSLProxy ( hq ) ) . start ( ) ; } GizmoView . getView ( ) . setStatus ( "" ) ; hq . sendDataToClient ( ) ; hq . closeClientConnection ( ) ; } else { } if ( successfull ) { handlerhandler . addMessage ( hq ) ; synchronized ( lock ) { lock . notifyAll ( ) ; } } else { inbound . close ( ) ; } return ; } catch ( IOException e ) { System . out . println ( e ) ; } }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	9X	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	3	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) != null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
tr	7	public String dTDetailSearch ( String id ) { String docName = "" ; String docTellContent = "" ; String excuteDate = "" ; String stopDate = "" ; String docTellStatus = "" ; String docTellType = "" ; String sd = "" ; String pn = "" ; String str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; System . out . println ( "docTellDetailSearch_______________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { excuteDate = num . getString ( "excute_date" ) ; stopDate = num . getString ( "stop_date" ) ; docName = num . getString ( "user_name" ) ; docTellStatus = num . getString ( "doc_tell_status" ) ; docTellType = num . getString ( "doc_tell_type" ) ; docTellContent = num . getString ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getAttribute('userId') %>\" style=\"display:none\" id=\"excuteId\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4E3B\u6CBB\u533B\u751F:" + docName + "</td>  <td>\u4F5C\u7528\u65F6\u95F4:" + excuteDate + "~" + stopDate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533B\u5631\u5185\u5BB9\uFF1A <textarea readonly rows=\"6\" cols=\"80\" name=\"docTellContent\" id=\"docTellContent\" onpropertychange=\"if(this.scrollHeight>80) this.style.posHeight=this.scrollHeight+5\">" + docTellContent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( docTellType . equals ( "1" ) ) { switch ( Integer . parseInt ( docTellStatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nurseCheck\" onclick=\"save(2)\" value=\"\u62A4\u58EB\u6821\u5BF9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docStop\"  onclick=\"save(3)\" value=\"\u505C\u6B62\u533B\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseConfirm\" onclick=\"save(4)\"  value=\"\u62A4\u58EB\u786E\u8BA4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( docTellType . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseConfirm\"  value=\"\u62A4\u58EB\u786E\u8BA4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	6	public void changePanel ( ) { this . removeAll ( ) ; switch ( this . status ) { case 0 : break ; case 1 : this . add ( label [ 0 ] ) ; this . add ( label [ 1 ] ) ; this . add ( label [ 2 ] ) ; this . add ( label [ 3 ] ) ; this . add ( label [ 4 ] ) ; break ; case 2 : textField [ 0 ] . setText ( "" ) ; this . add ( textField [ 0 ] ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 3 : textField [ 1 ] . setText ( "" ) ; files . removeAllElements ( ) ; this . add ( textField [ 1 ] ) ; this . add ( btn [ 0 ] ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 4 : textField [ 2 ] . setText ( ClientLauncher . getFileMgr ( ) . getDownloadPath ( ) ) ; selectedFiles1 . setText ( ClientLauncher . getFrame ( ) . getFileListPanel ( ) . getSelectedNodes ( ) . length + "" ) ; this . add ( textField [ 2 ] ) ; this . add ( selectedFiles1 ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 5 : selectedFiles2 . setText ( ClientLauncher . getFrame ( ) . getFileListPanel ( ) . getSelectedNodes ( ) . length + "" ) ; this . add ( selectedFiles2 ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; default : break ; } this . add ( bgImg [ status ] ) ; this . repaint ( ) ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	1	private static TermURIs getURISet ( ) { if ( _singleton == null ) { _singleton = new TermURIs ( ) ; } return _singleton ; }
tr	9X	public String checkDataEntry ( ) { if ( lhc_analysis_panel3 . lhcParamFileChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( lhc_analysis_panel3 . measures . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . measureScale . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . mediansFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcSummaryFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcCoEffsFileName . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "csv" ) && ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "xml" ) ) { return "Result file format must be xml or csv" ; } else { try { int numRuns = Integer . parseInt ( lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) ) ; if ( numRuns < 0 ) { return "Number of runs must be positive" ; } else { return null ; } } catch ( NumberFormatException e ) { return "Make sure the number of runs is an integer" ; } } }
tr	2	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; return ; } else if ( e . getSource ( ) == sparastangB ) { transaction ( true ) ; return ; } }
tr	1	public Hora ( String cadena ) { String literal1 = cadena . substring ( 0 , cadena . indexOf ( ":" ) ) ; String literal2 = cadena . substring ( cadena . indexOf ( ":" ) + 1 , cadena . length ( ) ) ; if ( cadena . contains ( ":" ) ) { this . cadena = cadena ; this . hora = Integer . parseInt ( literal1 ) ; this . minutos = Integer . parseInt ( literal2 ) ; } }
tr	6	public MainFrame ( ) { initComponents ( ) ; preferences = Preferences . userRoot ( ) . node ( this . getClass ( ) . getName ( ) ) ; final String pathToPDFLaTeXFile = preferences . get ( "pathToPDFLaTeXFile" , null ) ; final String pathToPDFExportFolder = preferences . get ( "pathToPDFExportFolder" , null ) ; if ( ( pathToPDFLaTeXFile == null ) || ( pathToPDFExportFolder == null ) ) Config . initPreferences ( preferences ) ; if ( ( pathToPDFLaTeXFile != null ) && ( ! pathToPDFLaTeXFile . equals ( Config . default ) ) ) Config . setPDFLaTeXFile ( new File ( pathToPDFLaTeXFile ) ) ; if ( ( pathToPDFExportFolder != null ) && ( ! pathToPDFExportFolder . equals ( Config . default ) ) ) Config . setPDFExportFolder ( new File ( pathToPDFExportFolder ) ) ; parameterLabelArray = new javax . swing . JLabel [ ] { parameter1Label , parameter2Label , parameter3Label , parameter4Label } ; parameterArray = new javax . swing . JTextField [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problemPartComponentsArray = new JComponent [ ] { userAnswerField , checkButton , showSolutionLaTeXButton , showSolutionPlaintextButton , copyToClipboardButton , exportToPDFButton , resetButton } ; }
tr	8	private final boolean isNumeric ( class < ? > clazz ) { if ( Number . class . isAssignableFrom ( clazz ) ) { return true ; } if ( clazz . isPrimitive ( ) ) { return clazz == long . TYPE || clazz == Integer . TYPE || clazz == double . TYPE || clazz == float . TYPE || clazz == short . TYPE || clazz == byte . TYPE ; } return false ; }
tr	0	public static ByteBuffer stringToBuffer ( int id ) { String s = Integer . valueOf ( id ) . toString ( ) ; return stringToBuffer ( s ) ; }
tr	1	@ Override public BigDecimal evaluate ( String mathExpression ) throws EvaluationException { EvaluationContext context = new EvaluationContext ( mathExpression ) ; try { return run ( context ) ; } catch ( Exception ex ) { throw new EvaluationException ( ex . getMessage ( ) , context . getCurrentPosition ( ) ) ; } }
tr	2	@ Override public BSTNode < T > search ( T element ) { BSTNode < T > node = search ( element , root ) ; if ( ! node . isEmpty ( ) ) { splay ( node ) ; } else { if ( ! node . equals ( root ) ) { splay ( ( BSTNode < T > ) node . getParent ( ) ) ; } } return node ; }
tr	7	public static Document deepCloneDocument ( Document doc , DOMImplementation impl ) { Element root = doc . getDocumentElement ( ) ; Document result = impl . createDocument ( root . getNamespaceURI ( ) , root . getNodeName ( ) , null ) ; Element rroot = result . getDocumentElement ( ) ; boolean before = true ; for ( Node n = doc . getFirstChild ( ) ; n != null ; n = n . getNextSibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasAttributes ( ) ) { NamedNodeMap attr = root . getAttributes ( ) ; int len = attr . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setAttributeNode ( ( Attr ) result . importNode ( attr . item ( i ) , true ) ) ; } } for ( Node c = root . getFirstChild ( ) ; c != null ; c = c . getNextSibling ( ) ) { rroot . appendChild ( result . importNode ( c , true ) ) ; } } else { if ( n . getNodeType ( ) != Node . DOCUMENT_TYPE_NODE ) { if ( before ) { result . insertBefore ( result . importNode ( n , true ) , rroot ) ; } else { result . appendChild ( result . importNode ( n , true ) ) ; } } } } return result ; }
tr	4	@ Override public final Element get ( int index ) { final int size = elements . size ( ) ; if ( index >= 0 ) { if ( index < size ) { return elements . get ( index ) ; } else { return null ; } } else { final int calculated = size + index ; if ( calculated >= 0 && calculated < size ) { return elements . get ( calculated ) ; } else { return null ; } } }
tr	4	private void updateItemsBorrowed ( ) { String attribute = null ; if ( studentJRadioButton . isSelected ( ) ) { attribute = studentJTextField . getText ( ) ; memberId = studentJTextField . getText ( ) ; } else if ( facultyJRadioButton . isSelected ( ) ) { attribute = facultyJTextField . getText ( ) ; memberId = facultyJTextField . getText ( ) ; } String query = "UPDATE members SET ItemsBorrowed=(ItemsBorrowed+1) WHERE MemberId='" + attribute + "' " ; String query2 = "UPDATE books SET IsBorrowed=1 WHERE ((Name='" + title . getTitleName ( ) + "') AND (ItemNo='" + title . getItemNo ( ) + "')) " ; try { pst = connection . prepareStatement ( query ) ; pst = connection . prepareStatement ( query2 ) ; pst . addBatch ( query ) ; pst . addBatch ( query2 ) ; pst . executeBatch ( ) ; JOptionPane . showMessageDialog ( null , "All tables are up-to-date.\nYou can now lend the Item to Member" , "Successful lending" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } }
tr	9X	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<LookAt" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } kml += "<range>" + this . range + "</range>\n" ; if ( this . tilt != DEFAULT_TILT ) { kml += "<tilt>" + this . tilt + "</tilt>\n" ; } if ( this . heading != DEFAULT_HEADING ) { kml += "<heading>" + this . heading + "</heading>\n" ; } if ( this . altitudeMode != null ) { kml += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</LookAt>\n" ; } return kml ; }
tr	7	private void updateDataTableTimeKeeping ( int n , int month , int year ) { Object [ ] [ ] objData = new Object [ n ] [ ] ; Object [ ] objColumn = new Object [ ] { "Working" , "Date" } ; int day ; String date ; if ( currentEmployee != null ) { Contract correctContract = currentEmployee . searchCorrespondingContract ( year , month ) ; if ( correctContract != null ) { TimeKeepingBook keepBook = correctContract . getTimeKeeping ( ) ; if ( keepBook != null ) { TimeKeepingSheet keepSheet = keepBook . get ( month , year ) ; if ( keepSheet == null ) { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } else { for ( int i = 0 ; i < keepSheet . size ( ) ; i ++ ) { TimeKeepingDetailInfo infor = keepSheet . get ( i ) ; day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( infor . getIsWorking ( ) ) , date } ; objData [ i ] = objValue ; } } } } } else { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } timeKeepingBookFrame . getTableModelTimeKeeping ( ) . setDataVector ( objData , objColumn ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellRenderer ( new MyTableCellRenderer ( ) ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellEditor ( new MyTableCellEditor ( ) ) ; }
tr	1	public void mouseReleased ( MouseEvent e ) { GameAction gameAction = getMouseButtonAction ( e ) ; if ( gameAction != null ) { gameAction . release ( ) ; } }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	8	public ArrayList < SearchBean < FreeBedSummaryBean >> getFreeBedSummary ( Hostel info , Date start , Date end ) { ArrayList < SearchBean < FreeBedSummaryBean >> result = new ArrayList < SearchBean < FreeBedSummaryBean >> ( ) ; if ( info == null ) { return null ; } try { ArrayList < Identifier > hostelIds = Hostels . getInstance ( ) . search ( info ) ; if ( hostelIds . size ( ) == 0 ) { return null ; } for ( Identifier hostelId : hostelIds ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( start ) ; for ( int days = 1 ; days <= GenericUtility . getDiffDays ( end , start ) ; days ++ ) { Date checkIn = cal . getTime ( ) ; cal . add ( Calendar . DATE , 1 ) ; Date checkOut = cal . getTime ( ) ; ArrayList < Identifier > bedIds = Hostels . getInstance ( ) . getFreeBeds ( hostelId , checkIn , checkOut ) ; int maxPrice = 0 ; int minPrice = Integer . MAX_VALUE ; for ( Identifier bedId : bedIds ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedId ) ; Tariff tariff = bedInfo . getTariffForDate ( checkIn , checkOut ) ; if ( tariff . getPrice ( ) > maxPrice ) maxPrice = tariff . getPrice ( ) ; if ( tariff . getPrice ( ) < minPrice ) minPrice = tariff . getPrice ( ) ; } FreeBedSummaryBean fbsBean = new FreeBedSummaryBean ( ) ; fbsBean . setMaxPrice ( maxPrice ) ; fbsBean . setMinPrice ( minPrice ) ; fbsBean . setNoOfBeds ( bedIds . size ( ) ) ; fbsBean . setStartDate ( checkIn ) ; fbsBean . setEndDate ( checkOut ) ; SearchBean < FreeBedSummaryBean > bean = new SearchBean < FreeBedSummaryBean > ( getNextSearchId ( ) , hostelId , fbsBean ) ; result . add ( bean ) ; } } } catch ( DataBaseReadWriteException | IdentifierNotFoundException | InvalidIdentifierException | InvalidParameterException e ) { e . printStackTrace ( ) ; } write ( result ) ; return result ; }
tr	5	public void move ( ) { super . move ( ) ; if ( this . clock % 10 == 0 ) { if ( this . clock % 50 == 0 ) { this . angle = Math . PI * 3 / 2 ; } PlayerShip p = game . getPlayer ( ) ; double dFromPlayer = Math . sqrt ( Math . pow ( p . x - x , 2 ) + Math . pow ( p . y - y , 2 ) ) ; if ( dFromPlayer < 128 ) { this . angle = Math . PI * 3 / 2 ; this . velocity += 1.2 ; } } if ( game . t % 10 == 0 && game . random ( 0 , 1 , 1 ) == 1 ) { shoot ( Math . PI * 3 / 2 ) ; } }
tr	2	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unset_success ( ) ; } else { set_success ( ( QueueInfo ) value ) ; } break ; } }
tr	4	public void fill ( final Color [ ] [ ] frameBuffer ) { if ( frameBuffer == null ) { throw new NullPointerException ( "'frameBuffer' must not be 'null'" ) ; } Color c = ( getAttributes ( ) . containsKey ( "color" ) ) ? ( Color ) getAttributes ( ) . get ( "color" ) : Color . white ; for ( int i = getP ( ) . get ( 0 , 0 ) . intValue ( ) ; i < getP ( ) . get ( 0 , 0 ) . intValue ( ) + getD ( ) . get ( 0 , 0 ) . intValue ( ) ; ++ i ) { for ( int j = getP ( ) . get ( 1 , 0 ) . intValue ( ) ; j < getP ( ) . get ( 1 , 0 ) + getD ( ) . get ( 1 , 0 ) ; ++ j ) { frameBuffer [ i ] [ j ] = c ; } } }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	7	void modElement ( String [ ] args ) throws Exception { if ( args . length < 3 ) { System . err . println ( "Usage: mod <config_file> <indexID>" ) ; System . exit ( 1 ) ; } myVsl = new vsl ( args [ 1 ] ) ; vslRecKey prev = new vslRecKey ( ) ; vslID id = new vslID ( ) ; id . setID ( args [ 2 ] ) ; vslIndex index = myVsl . getIndex ( id , true ) ; Vector < vslElKey > allKeys = showAllElements ( index ) ; vslElKey elKey = null ; while ( ( elKey = promptForChoice ( "element to update" , allKeys ) ) != null ) { vslIndexElement el = index . getElement ( elKey ) ; Vector < vslRecKey > allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; while ( ( prev = promptForChoice ( "previous record to update" , allRec ) ) != null ) { Vector prevVec = new Vector ( ) ; prevVec . add ( prev ) ; vslIndexDataType < String > elData = null ; String input = null ; do { System . out . print ( "Update/Detele [u/d]:" ) ; input = FileChunkingTest . getLine ( ) ; } while ( input != null && ! ( input . equals ( "u" ) || input . equals ( "d" ) ) ) ; if ( input . equals ( "u" ) ) { System . out . print ( "Update data:" ) ; input = FileChunkingTest . getLine ( ) ; elData = new vslIndexDataType < String > ( input ) ; index . updateElement ( elKey , elData , prevVec ) ; } else { index . deleteElement ( elKey , prevVec ) ; } myVsl . updateIndex ( index ) ; allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; } allKeys = showAllElements ( index ) ; } myVsl . save ( ) ; }
tr	2	@ Override public String toString ( ) { String s = "Vertices: " + V + " Edges: " + E + "\n" ; for ( int i = 0 ; i < V ; i ++ ) { s += i + ": " ; for ( int w : adj ( i ) ) s += w + " " ; s += "\n" ; } return s ; }
tr	6	public < T extends DBObject > T createObject ( class < ? extends DBObject > c , String identifier ) throws RemoteException { checkStarted ( ) ; try { Logger . debug ( "try to create new DBObject. request from host: " + getClientHost ( ) ) ; } catch ( ServerNotActiveException soe ) { } try { T o = create ( c ) ; o . load ( identifier ) ; return o ; } catch ( RemoteException re ) { throw re ; } catch ( Exception e ) { Logger . error ( "unable to create object " + ( c == null ? "unknown" : c . getName ( ) ) , e ) ; throw new RemoteException ( "unable to create object " + ( c == null ? "unknown" : c . getName ( ) ) , e ) ; } }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ComplexNumber that = ( ComplexNumber ) o ; if ( double . compare ( that . im , im ) != 0 ) return false ; if ( double . compare ( that . re , re ) != 0 ) return false ; return true ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	5	private boolean r_i_verb_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_pV ) { return false ; } cursor = I_pV ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_5 , 35 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; switch ( among_var ) { case 0 : limit_backward = v_2 ; return false ; case 1 : if ( ! ( out_grouping_b ( g_v , 97 , 251 ) ) ) { limit_backward = v_2 ; return false ; } slice_del ( ) ; break ; } limit_backward = v_2 ; return true ; }
tr	9X	public boolean setRobot ( final int robot , final int position , final boolean allowSwapRobots ) { if ( ( robot < 0 ) || ( robot >= this . robots . length ) || ( position < 0 ) || ( position >= this . size ) || this . isObstacle ( position ) || ( ( false == allowSwapRobots ) && ( this . getRobotNum ( position ) >= 0 ) && ( this . getRobotNum ( position ) != robot ) ) ) { return false ; } else { final int otherRobot = this . getRobotNum ( position ) ; final int oldPosition = this . robots [ robot ] ; if ( ( otherRobot >= 0 ) && ( otherRobot != robot ) && ( oldPosition >= 0 ) ) { this . robots [ otherRobot ] = oldPosition ; } this . robots [ robot ] = position ; return true ; } }
tr	0	public void setUpvote ( boolean upvote ) { this . upvote = upvote ; }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	2	@ Override public void nextFrame ( ) { if ( images . size ( ) <= 1 || ! playing ) { return ; } frame ++ ; frame %= images . size ( ) ; }
tr	3	private static void splitReciprocal ( final double in [ ] , final double result [ ] ) { final double b = 1.0 / 4194304.0 ; final double a = 1.0 - b ; if ( in [ 0 ] == 0.0 ) { in [ 0 ] = in [ 1 ] ; in [ 1 ] = 0.0 ; } result [ 0 ] = a / in [ 0 ] ; result [ 1 ] = ( b * in [ 0 ] - a * in [ 1 ] ) / ( in [ 0 ] * in [ 0 ] + in [ 0 ] * in [ 1 ] ) ; if ( result [ 1 ] != result [ 1 ] ) { result [ 1 ] = 0.0 ; } resplit ( result ) ; for ( int i = 0 ; i < 2 ; i ++ ) { double err = 1.0 - result [ 0 ] * in [ 0 ] - result [ 0 ] * in [ 1 ] - result [ 1 ] * in [ 0 ] - result [ 1 ] * in [ 1 ] ; err = err * ( result [ 0 ] + result [ 1 ] ) ; result [ 1 ] += err ; } }
tr	4	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	5	public boolean fireballCollideCheck ( Fireball fireball ) { if ( deadTime != 0 ) return false ; float xD = fireball . x - x ; float yD = fireball . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < fireball . height ) { return true ; } } return false ; }
tr	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Token:" ) ; sb . append ( "\n  type: " ) ; sb . append ( type . toString ( ) ) ; if ( accessToken != null ) { sb . append ( "\n  access token: " ) ; sb . append ( accessToken ) ; } if ( refreshToken != null ) { sb . append ( "\n  refresh token: " ) ; sb . append ( refreshToken ) ; } if ( keyId != null ) { sb . append ( "\n  kid: " ) ; sb . append ( keyId ) ; } if ( macKey != null ) { sb . append ( "\n  mac key: " ) ; sb . append ( macKey ) ; } if ( macAlgorithm != null ) { sb . append ( "\n  mac algorithm: " ) ; sb . append ( macAlgorithm ) ; } if ( expiresIn != - 1 ) { sb . append ( "\n  expires in: " ) ; sb . append ( expiresIn ) ; } return sb . toString ( ) ; }
tr	4	private static String longestWordFromOtherWords1 ( String [ ] words ) { int rl = - 1 ; String lwfow = null ; Arrays . sort ( words , new stringComparator ( ) ) ; HashMap < String , boolean > wordMap = new HashMap < String , boolean > ( ) ; for ( String w : words ) { if ( ! wordMap . containsKey ( w ) ) { wordMap . put ( w , true ) ; } } for ( String w : words ) { wordMap . remove ( w ) ; rl = longestWordFromOtherWords ( wordMap , w ) ; wordMap . put ( w , true ) ; if ( rl > 0 ) { lwfow = w ; break ; } } return lwfow ; }
tr	8	public void exit ( SimpleFrame frame ) { File tempFile = new File ( frame . fileName ) ; if ( tempFile . exists ( ) ) tempFile . delete ( ) ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new File ( "." ) ) ; if ( frame . getIsChanged ( ) ) { int selection = JOptionPane . showConfirmDialog ( null , "Do you want save document?" , "Warrning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( selection == JOptionPane . NO_OPTION ) { try { frame . getClient ( ) . close ( ) ; frame . getPtr ( ) . Disconnect ( frame . getProjName ( ) , frame . getLogin ( ) ) ; } catch ( RemoteException e1 ) { JOptionPane . showMessageDialog ( frame , "Disconect from Server" ) ; return ; } System . exit ( 0 ) ; } if ( selection == JOptionPane . YES_OPTION ) { chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } else { return ; } } } else { try { frame . getClient ( ) . close ( ) ; frame . getPtr ( ) . Disconnect ( frame . getProjName ( ) , frame . getLogin ( ) ) ; } catch ( RemoteException e1 ) { JOptionPane . showMessageDialog ( frame , "Disconect from Server" ) ; return ; } System . exit ( 0 ) ; } }
tr	8	public HashMap < String , Object > convertToMapDefaultFill ( final ArrayList < BeanFieldSet > list ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; for ( BeanFieldSet bean : list ) { if ( bean . fieldName == null || bean . fieldName . isEmpty ( ) ) { return map ; } bean . fieldIni = bean . fieldIni == null ? "" : bean . fieldIni ; if ( bean . fieldIni . startsWith ( "$" ) ) { if ( Actuacio . resourceMap != null && Actuacio . resourceMap . containsKey ( bean . fieldIni ) ) { Object obj = Actuacio . resourceMap . get ( bean . fieldIni ) ; if ( obj . getClass ( ) . equals ( String . class ) ) { bean . fieldIni = ( String ) obj ; } } else { bean . fieldIni = "" ; } } map . put ( bean . fieldName , bean . fieldIni ) ; } return map ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Station station = ( Station ) o ; if ( id != station . id ) return false ; if ( name != null ? ! name . equals ( station . name ) : station . name != null ) return false ; return true ; }
tr	4	public int numTrees2 ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int [ ] num = new int [ n + 1 ] ; num [ 0 ] = 1 ; num [ 1 ] = 1 ; num [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { int left = j - 1 ; int right = i - j ; cnt += num [ left ] * num [ right ] ; } num [ i ] = cnt ; } return num [ n ] ; }
tr	3	private void initWindow ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . PAGE_AXIS ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; tabbedPanel = new JTabbedPane ( ) ; tabbedPanel . setPreferredSize ( new Dimension ( 500 , 800 ) ) ; connectionTabPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel . setLayout ( new BoxLayout ( userSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; userSettingsPanel . setBorder ( new TitledBorder ( "User Settings" ) ) ; userSettingsV1Panel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; usernameLabel = new JLabel ( "Username:" ) ; usernameText = new JTextField ( UserPreferences . PREF_USERNAME , 6 ) ; apiSecretLabel = new JLabel ( "API Secret:" ) ; apiSecretText = new JPasswordField ( UserPreferences . PREF_API_SECRET , 6 ) ; passwordLabel = new JLabel ( "Password:" ) ; passwordText = new JPasswordField ( UserPreferences . PREF_PASSWORD , 6 ) ; userSettingsV1Panel . add ( usernameLabel ) ; userSettingsV1Panel . add ( usernameText ) ; userSettingsV1Panel . add ( apiSecretLabel ) ; userSettingsV1Panel . add ( apiSecretText ) ; userSettingsV1Panel . add ( passwordLabel ) ; userSettingsV1Panel . add ( passwordText ) ; userTokenPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userTokenPanel . setPreferredSize ( new Dimension ( 443 , 40 ) ) ; userTokenLabel = new JLabel ( "Token:" ) ; userTokenText = new JTextField ( UserPreferences . PREF_USERTOKEN , 10 ) ; userTokenButton = new JButton ( "Get your token" ) ; userTokenButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { GetToken . browse ( ) ; } } ) ; userTokenPanel . add ( userTokenLabel ) ; userTokenPanel . add ( userTokenText ) ; userTokenPanel . add ( userTokenButton ) ; userSettingsPanel . add ( userTokenPanel ) ; proxySettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; proxyUseCheck = new JCheckBox ( "Use Proxy" , UserPreferences . PREF_USE_PROXY ) ; proxyUseCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( proxyUseCheck . isSelected ( ) ) { proxyAddressText . setEnabled ( true ) ; proxyPortText . setEnabled ( true ) ; } else { proxyAddressText . setEnabled ( false ) ; proxyPortText . setEnabled ( false ) ; } } } ) ; proxySettingsPanel . setBorder ( new TitledBorder ( "Proxy Settings" ) ) ; proxyAddressLabel = new JLabel ( "Proxy:" ) ; proxyAddressText = new JTextField ( UserPreferences . PREF_PROXY_ADDRESS , 15 ) ; proxyPortLabel = new JLabel ( "Port:" ) ; proxyPortText = new JTextField ( UserPreferences . PREF_PROXY_PORT , 3 ) ; proxySettingsPanel . add ( proxyUseCheck ) ; proxySettingsPanel . add ( proxyAddressLabel ) ; proxySettingsPanel . add ( proxyAddressText ) ; proxySettingsPanel . add ( proxyPortLabel ) ; proxySettingsPanel . add ( proxyPortText ) ; proxySettingsPanel . setPreferredSize ( new Dimension ( 455 , 60 ) ) ; serverSettingsPanel = new JPanel ( ) ; serverSettingsPanel . setLayout ( new BoxLayout ( serverSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; serverSettingsPanel . setBorder ( new TitledBorder ( "Server Settings" ) ) ; serverCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverCheckIntervalLabel = new JLabel ( "Server check interval (sec):" ) ; serverCheckIntervalText = new JTextField ( String . valueOf ( UserPreferences . PREF_SERVER_CHECK_INTERVAL ) , 3 ) ; autoCleanCheck = new JCheckBox ( "Delete empty folders (keeps account clean)" , UserPreferences . PREF_AUTO_CLEAN ) ; serverCheckPanel . add ( serverCheckIntervalLabel ) ; serverCheckPanel . add ( serverCheckIntervalText ) ; serverCheckPanel . add ( autoCleanCheck ) ; serverSortByPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverSortByLabel = new JLabel ( "Sort by default:" ) ; serverSortByCombo = new JComboBox < String > ( new String [ ] { "Name" , "Date" } ) ; serverSortByCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_SORT_BY ) ; serverSortByPanel . add ( serverSortByLabel ) ; serverSortByPanel . add ( serverSortByCombo ) ; serverFriendPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; loadSharedCheck = new JCheckBox ( "Load friends' files (this could take some time to load)" , UserPreferences . PREF_LOAD_SHARED ) ; serverFriendPanel . add ( loadSharedCheck ) ; serverSettingsPanel . add ( serverCheckPanel ) ; serverSettingsPanel . add ( serverSortByPanel ) ; serverSettingsPanel . add ( serverFriendPanel ) ; serverSettingsPanel . setPreferredSize ( new Dimension ( 455 , 120 ) ) ; connectionTabPanel . add ( userSettingsPanel ) ; connectionTabPanel . add ( proxySettingsPanel ) ; connectionTabPanel . add ( serverSettingsPanel ) ; tabbedPanel . addTab ( "Connection" , null , connectionTabPanel ) ; startupSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoConnectCheck = new JCheckBox ( "Connect on start automatically" , UserPreferences . PREF_AUTO_CONNECT ) ; startInTrayCheck = new JCheckBox ( "Start in system tray" , UserPreferences . PREF_START_IN_TRAY ) ; startupSettingsPanel . setBorder ( new TitledBorder ( "Startup Settings" ) ) ; startupSettingsPanel . add ( autoConnectCheck ) ; startupSettingsPanel . add ( startInTrayCheck ) ; tabbedPanel . addTab ( "Startup" , null , startupSettingsPanel ) ; downloadSettingsPanel = new JPanel ( ) ; downloadSettingsPanel . setLayout ( new BoxLayout ( downloadSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; downloadSettingsPanel . setBorder ( new TitledBorder ( "Download Settings" ) ) ; autoDownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoDownloadCheck = new JCheckBox ( "Download on connect" , UserPreferences . PREF_AUTO_DOWNLOAD ) ; autoDownloadPanel . add ( autoDownloadCheck ) ; downloadTargetPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadTargetLabel = new JLabel ( "Target:" ) ; downloadTargetText = new JTextField ( UserPreferences . PREF_DOWNLOAD_TARGET , 20 ) ; downloadTargetText . setEditable ( false ) ; fileChooserButton = new JButton ( "Browse" ) ; fileChooserButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( fileChooser . showOpenDialog ( preferencesScreen ) == JFileChooser . APPROVE_OPTION ) { downloadTargetText . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; fileChooser = new JFileChooser ( downloadTargetText . getText ( ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileChooser . setDialogTitle ( "Select download directory" ) ; fileChooser . setAcceptAllFileFilterUsed ( false ) ; downloadTargetPanel . add ( downloadTargetLabel ) ; downloadTargetPanel . add ( downloadTargetText ) ; downloadTargetPanel . add ( fileChooserButton ) ; downloadWhatPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadWhatLabel = new JLabel ( "Download:" ) ; everythingRadio = new JRadioButton ( "everything" ) ; selFoldersRadio = new JRadioButton ( "selected folders" ) ; selFoldersRadio . setToolTipText ( "Right clic folder -> Add to automatic download" ) ; downloadWhatGroup = new ButtonGroup ( ) ; downloadWhatGroup . add ( everythingRadio ) ; downloadWhatGroup . add ( selFoldersRadio ) ; downloadWhatPanel . add ( downloadWhatLabel ) ; downloadWhatPanel . add ( everythingRadio ) ; downloadWhatPanel . add ( selFoldersRadio ) ; downloadPartsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; maxParallelDownloadsLabel = new JLabel ( "Max parallel downloads:" ) ; maxParallelDownloadsText = new JTextField ( String . valueOf ( UserPreferences . PREF_MAX_DOWNLOADS ) , 2 ) ; downloadPartsLabel = new JLabel ( "Parts for each download:" ) ; downloadPartsText = new JTextField ( String . valueOf ( UserPreferences . PREF_DOWNLOAD_PART_COUNT ) , 2 ) ; downloadPartsPanel . add ( maxParallelDownloadsLabel ) ; downloadPartsPanel . add ( maxParallelDownloadsText ) ; downloadPartsPanel . add ( downloadPartsLabel ) ; downloadPartsPanel . add ( downloadPartsText ) ; fileSizeCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; fileSizeCheckCheck = new JCheckBox ( "Skip download if size of the file is smaller than (MB):" , UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeCheckCheck . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeDeleteCheck . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; } } ) ; fileSizeCheckText = new JTextField ( String . valueOf ( UserPreferences . PREF_FILE_SIZE_FOR_CHECK ) , 4 ) ; fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeCheckPanel . add ( fileSizeCheckCheck ) ; fileSizeCheckPanel . add ( fileSizeCheckText ) ; fileSizeDeletePanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; fileSizeDeleteCheck = new JCheckBox ( "Also delete it from server automatically" , UserPreferences . PREF_FILE_SIZE_DELETE ) ; fileSizeDeleteCheck . setEnabled ( UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeDeletePanel . add ( fileSizeDeleteCheck ) ; downloadSettingsPanel . add ( autoDownloadPanel ) ; downloadSettingsPanel . add ( downloadTargetPanel ) ; downloadSettingsPanel . add ( downloadWhatPanel ) ; downloadSettingsPanel . add ( downloadPartsPanel ) ; downloadSettingsPanel . add ( fileSizeCheckPanel ) ; downloadSettingsPanel . add ( fileSizeDeletePanel ) ; tabbedPanel . addTab ( "Download" , null , downloadSettingsPanel ) ; conflictSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; conflictSettingsPanel . setBorder ( new TitledBorder ( "Conflict Settings" ) ) ; redownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; redownloadCheck = new JCheckBox ( "Do not ask if file already downloaded. Apply following: " , UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { redownloadCombo . setEnabled ( redownloadCheck . isSelected ( ) ) ; } } ) ; redownloadCombo = new JComboBox < String > ( new String [ ] { "Download again" , "Skip" , "Skip and delete" } ) ; redownloadCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_DOWNLOAD_AGAIN ) ; redownloadCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadPanel . add ( redownloadCheck ) ; redownloadPanel . add ( redownloadCombo ) ; overwritePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCheck = new JCheckBox ( "Do not ask if file already exits on disc. Apply following: " , UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwriteCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { overwriteCombo . setEnabled ( overwriteCheck . isSelected ( ) ) ; } } ) ; overwriteComboPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCombo = new JComboBox < String > ( new String [ ] { "Overwrite" , "Skip" , "Skip and delete from server" , "Skip in case of same size" , "Skip in case of same size and delete from server" } ) ; overwriteCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_OVERWRITE ) ; overwriteCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwritePanel . add ( overwriteCheck ) ; overwriteComboPanel . add ( overwriteCombo ) ; conflictSettingsPanel . add ( redownloadPanel ) ; conflictSettingsPanel . add ( overwritePanel ) ; conflictSettingsPanel . add ( overwriteComboPanel ) ; tabbedPanel . addTab ( "Conflict" , null , conflictSettingsPanel ) ; buttonsPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; saveAndCloseButton = new JButton ( "Save & Close" ) ; saveAndCloseButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( saveSettings ( ) ) { preferencesScreen . setVisible ( false ) ; } } } ) ; closeButton = new JButton ( "Close" ) ; closeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { preferencesScreen . setVisible ( false ) ; } } ) ; buttonsPanel . add ( saveAndCloseButton ) ; buttonsPanel . add ( closeButton ) ; contentPanel . add ( tabbedPanel ) ; contentPanel . add ( buttonsPanel ) ; this . getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; this . setTitle ( "Preferences" ) ; this . setSize ( new Dimension ( 490 , 370 ) ) ; this . setResizable ( false ) ; }
tr	8	public static Mineral find ( int remoteId ) { switch ( remoteId ) { case 34 : return Tritanium ; case 35 : return Pyerite ; case 36 : return Mexallon ; case 37 : return Isogen ; case 38 : return Nocxium ; case 39 : return Zydrine ; case 40 : return Megacyte ; case 11399 : return Morphite ; default : { throw new RuntimeException ( "Id does not represent mineral" ) ; } } }
tr	2	public static void writeAttack ( Pokemon poke , int moveChoice , int damage , int teamId ) { if ( ! isSearchMode ) { String statement = "%s" ; if ( teamId == Game . OMNIDEXTER ) { statement = String . format ( statement , "OmniDexter's" ) ; } else { statement = String . format ( statement , "Opponent" ) ; } statement = statement . concat ( " %s uses %s  dealing %d damage!" ) ; String moveName = poke . getMove ( moveChoice ) . getMove ( ) . getName ( ) ; statement = String . format ( statement , poke , moveName , damage ) ; System . out . println ( statement ) ; } }
tr	3	public List < Hostel > getAvailableBedsInAllHostels ( Date startDate , Date endDate ) { List < Hostel > hostels = null ; if ( startDate . after ( endDate ) ) { return null ; } Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new java . util . Date ( ) ) ; if ( startDate . before ( cal . getTime ( ) ) ) { return null ; } try { hostels = hostelDAOImpl . getAvailableBedsInAllHostels ( startDate , endDate ) ; } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } return hostels ; }
tr	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; User user = ( User ) session . get ( "User" ) ; Campaign camp ; lc = ( long ) long . parseLong ( campaid ) ; System . out . println ( "campaignlong id is" + getLc ( ) ) ; camp = ( Campaign ) myDao . getDbsession ( ) . get ( Campaign . class , lc ) ; camp . setCampaignId ( long . parseLong ( campaid ) ) ; camp . setCampaignName ( campaignname ) ; camp . setStartDate ( startdate ) ; camp . setEndDate ( enddate ) ; camp . setDialyBudget ( dailybdgt ) ; camp . setDeliveryMethod ( deliverytype ) ; camp . setNote ( note ) ; getMyDao ( ) . getDbsession ( ) . update ( camp ) ; setCamplist ( ( List < Campaign > ) myDao . getDbsession ( ) . createQuery ( "from Campaign" ) . list ( ) ) ; Criteria crit = myDao . getDbsession ( ) . createCriteria ( Campaign . class ) ; crit . add ( Restrictions . like ( "user" , user ) ) ; crit . setMaxResults ( 20 ) ; setCamplist ( ( List < Campaign > ) crit . list ( ) ) ; addActionMessage ( "Campaign " + camp . getCampaignName ( ) + " Successfully Updated" ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } }
tr	1	protected void check ( String method ) { if ( mAmShutdown ) throw new RuntimeException ( "NetBase." + method + " called when NetBase isn't in initialized state" ) ; }
tr	5	@ Override public void draw ( SpriteBatch batch ) { if ( object . isVisible ( ) ) { graphics . draw ( batch ) ; } if ( animate ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = explosionAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - 1f ) , ( animPos . y - 1f ) , 2 , 2 ) ; if ( explosionAnimation . isAnimationFinished ( stateTime ) ) { animate = false ; WorldObject . removelist . add ( object ) ; } } else if ( animateMiss ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = splashAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - .5f ) , ( animPos . y - .5f ) , 1 , 1 ) ; if ( splashAnimation . isAnimationFinished ( stateTime ) ) { animateMiss = false ; WorldObject . removelist . add ( object ) ; } } }
tr	2	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	9X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	5	public static void benchmark ( ) throws Exception { int N = 10000 ; String [ ] methodsToCompare = { "approxSort1" , "approxSort2" } ; int k = 10 ; int [ ] arr = new int [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { arr [ i ] = ( int ) ( i * 1000 + Math . floor ( Math . random ( ) * 100 ) ) ; int offset = ( int ) ( Math . floor ( Math . random ( ) * 2 * k ) - k ) ; if ( i + offset > 0 && i + offset < arr . length ) { swap ( arr , i , i + offset ) ; } } for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.ten.Problem10_06" ) ; Method method = clazz . getDeclaredMethod ( methodName , int [ ] . class , int . class ) ; double totalTime = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrClone = arr . clone ( ) ; long startTime = System . nanoTime ( ) ; method . invoke ( null , arrClone , k ) ; long endTime = System . nanoTime ( ) ; totalTime += ( endTime - startTime ) / 1000000000.0 ; } System . out . println ( "Elapsed time for " + methodName + ": " + totalTime + " seconds" ) ; } }
tr	1	public void stopSliding ( ) { if ( slider != null ) { slider . restart ( ) ; slider . stop ( ) ; } count = 0 ; }
tr	8	public HashMap < Integer , Integer > getSgd2iesdhcmap ( ) { if ( sgd2iesdhcmap != null ) { return sgd2iesdhcmap ; } sgd2iesdhcmap = new HashMap < Integer , Integer > ( ) ; String SQL1 = "SELECT id  TIME_FORMAT(inicio '%H:%i') AS inicio  TIME_FORMAT(fin '%H:%i') AS fin FROM horascentro" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getInt ( "id" ) ; String inicio = rs1 . getString ( "inicio" ) ; String fin = rs1 . getString ( "fin" ) ; String SQL2 = "SELECT codigo from sig_hores_classe WHERE inicio='" + inicio + "' AND fin='" + fin + "'" ; Statement st2 = getMysql ( ) . createStatement ( ) ; ResultSet rs2 = getMysql ( ) . getResultSet ( SQL2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { sgd2iesdhcmap . put ( id , rs2 . getInt ( 1 ) ) ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( HoraCentro . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return sgd2iesdhcmap ; }
tr	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final FormadePagamento other = ( FormadePagamento ) obj ; if ( ! Objects . equals ( this . nome , other . nome ) ) { return false ; } return true ; }
tr	4	protected final void measure ( int width , int height ) { Debug . log ( "MEASURING %s" , this ) ; if ( width == LayoutParameters . MATCH_PARENT ) { width = getParentWidth ( ) ; } if ( height == LayoutParameters . MATCH_PARENT ) { height = getParentHeight ( ) ; } onMeasure ( width , height ) ; if ( measuredWidth == NOT_SET || measuredHeight == NOT_SET ) { throw new IllegalStateException ( "View subclass (" + this + ") does not properly set the measured width or height." ) ; } Debug . log ( "MEASURED DIMENSIONS FOR (%s): width=%s  height=%s" , this , measuredWidth , measuredHeight ) ; }
tr	4	@ Override public void run ( ) { try { while ( active ) { synchronized ( messages ) { if ( messages . isEmpty ( ) ) { messages . wait ( 200 ) ; } else { NetworkMessage nm = messages . remove ( 0 ) ; out . write ( nm . getData ( ) ) ; } } } } catch ( InterruptedException ex ) { System . err . println ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
tr	0	public Builder buying ( double price ) { this . price = price ; return this ; }
tr	4	private void initializeTokens ( ) { tokens = new Token [ 21 ] [ 10 ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] = new Token ( ) ; } } nextTokens1 = new TokenNext [ 2 ] [ 4 ] ; nextTokens2 = new TokenNext [ 2 ] [ 4 ] ; nextTokens3 = new TokenNext [ 2 ] [ 4 ] ; holdTokens = new TokenNext [ 2 ] [ 4 ] ; for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] = new TokenNext ( ) ; nextTokens2 [ i ] [ j ] = new TokenNext ( ) ; nextTokens3 [ i ] [ j ] = new TokenNext ( ) ; holdTokens [ i ] [ j ] = new TokenNext ( ) ; } } currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; }
tr	4	public FrizzleFeatherGene ( String genotype ) { this . genotype = genotype ; switch ( genotype ) { case "FF" : phenotype = "Normal" ; break ; case "Ff" : case "fF" : phenotype = "Frizzle" ; break ; case "ff" : phenotype = "Curly" ; break ; default : } }
tr	4	private int findPlaceholderEndIndex ( CharSequence buf , int startIndex ) { int index = startIndex + this . placeholderPrefix . length ( ) ; int withinNestedPlaceholder = 0 ; while ( index < buf . length ( ) ) { if ( StringUtils . substringMatch ( buf , index , this . placeholderSuffix ) ) { if ( withinNestedPlaceholder > 0 ) { withinNestedPlaceholder -- ; index = index + this . placeholderSuffix . length ( ) ; } else { return index ; } } else if ( StringUtils . substringMatch ( buf , index , this . simplePrefix ) ) { withinNestedPlaceholder ++ ; index = index + this . simplePrefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
tr	6	static private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 7 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 ) ; return 9 ; } switch ( curChar ) { case 73 : return jjMoveStringLiteralDfa10_0 ( active0 , 20 ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 1000 ) ; case 108 : return jjMoveStringLiteralDfa10_0 ( active0 , 2000 ) ; case 114 : return jjMoveStringLiteralDfa10_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 ) ; }
tr	4	@ Override public boolean getPoint ( int mouseX , int mouseY ) { int newX = - 1 ; int newY = - 1 ; if ( mouseX < 800 ) { int cx = Boot . getPlayer ( ) . getX ( ) ; int cy = Boot . getPlayer ( ) . getY ( ) ; newX = cx + ( mouseX / Standards . TILE_SIZE ) - 12 ; newY = cy + ( ( Standards . W_HEIGHT - mouseY ) / Standards . TILE_SIZE ) - 12 ; } if ( newX != - 1 && newY != - 1 ) { if ( picks == 0 ) { this . posX = newX ; this . posY = newY ; picks = 1 ; } else { this . posX2 = newX ; this . posY2 = newY ; picks = 0 ; } } return true ; }
tr	0	private void visitEdge ( Edge e ) { System . out . println ( "Visiting edge " + e ) ; }
tr	0	public boolean isBlsSpecialBonusAvailable ( ) { return blsSpecialBonusAvailable ; }
tr	7	@ Override public User getUser ( String login , String password ) throws DAOException { final String filename = Constants . ResourcePath + ConstantsXML . USERS_FILE_NAME ; final String CSV_SPLITTER = ";" ; Scanner sc = null ; synchronized ( CSVUserDAO . class ) { try { boolean found = false ; sc = new Scanner ( new FileReader ( filename ) ) ; Role role = null ; String [ ] str = null ; while ( sc . hasNext ( ) ) { str = sc . nextLine ( ) . split ( CSV_SPLITTER ) ; if ( str [ LOGIN_NUM ] . equals ( login ) && str [ PASSWORD_NUM ] . equals ( password ) ) { role = Role . valueOf ( str [ ROLE_NUM ] . toUpperCase ( ) ) ; found = true ; break ; } } if ( ! found ) { throw new DAOException ( Constants . INVALID_NAME_OR_PASSWORD ) ; } return new User ( login , password , str [ EMAIL_NUM ] , str [ PHONE_NUM ] , role , Integer . parseInt ( str [ ID_NUM ] ) ) ; } catch ( DAOException e ) { throw new DAOException ( e ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new DAOException ( Constants . INTERNAL_ERROR ) ; } finally { if ( sc != null ) { sc . close ( ) ; } } } }
tr	9X	private void huffman_decode ( int ch , int gr ) { x [ 0 ] = 0 ; y [ 0 ] = 0 ; v [ 0 ] = 0 ; w [ 0 ] = 0 ; int part2_3_end = part2_start + si . ch [ ch ] . gr [ gr ] . part2_3_length ; int num_bits ; int region1Start ; int region2Start ; int index ; int buf , buf1 ; huffcodetab h ; if ( ( ( si . ch [ ch ] . gr [ gr ] . window_switching_flag ) != 0 ) && ( si . ch [ ch ] . gr [ gr ] . block_type == 2 ) ) { region1Start = ( sfreq == 8 ) ? 72 : 36 ; region2Start = 576 ; } else { buf = si . ch [ ch ] . gr [ gr ] . region0_count + 1 ; buf1 = buf + si . ch [ ch ] . gr [ gr ] . region1_count + 1 ; if ( buf1 > sfBandIndex [ sfreq ] . l . length - 1 ) buf1 = sfBandIndex [ sfreq ] . l . length - 1 ; region1Start = sfBandIndex [ sfreq ] . l [ buf ] ; region2Start = sfBandIndex [ sfreq ] . l [ buf1 ] ; } index = 0 ; for ( int i = 0 ; i < ( si . ch [ ch ] . gr [ gr ] . big_values << 1 ) ; i += 2 ) { if ( i < region1Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 0 ] ] ; else if ( i < region2Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 1 ] ] ; else h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 2 ] ] ; huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + x [ 0 ] + y [ 0 ] ; } h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . count1table_select + 32 ] ; num_bits = br . hsstell ( ) ; while ( ( num_bits < part2_3_end ) && ( index < 576 ) ) { huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = v [ 0 ] ; is_1d [ index ++ ] = w [ 0 ] ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + v [ 0 ] + w [ 0 ] + x [ 0 ] + y [ 0 ] ; num_bits = br . hsstell ( ) ; } if ( num_bits > part2_3_end ) { br . rewindNbits ( num_bits - part2_3_end ) ; index -= 4 ; } num_bits = br . hsstell ( ) ; if ( num_bits < part2_3_end ) br . hgetbits ( part2_3_end - num_bits ) ; if ( index < 576 ) nonzero [ ch ] = index ; else nonzero [ ch ] = 576 ; if ( index < 0 ) index = 0 ; for ( ; index < 576 ; index ++ ) is_1d [ index ] = 0 ; }
tr	6	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	3	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
tr	1	public int length ( ) { LinkedListNode iter = this ; int acc = 0 ; while ( iter != null ) { acc ++ ; iter = iter . next ; } return acc ; }
tr	4	@ Override public void read ( ReceiveBuffer rbuf , int timeout ) { try { long time = System . currentTimeMillis ( ) ; while ( ( System . currentTimeMillis ( ) - time ) < timeout && ! sio . state . reset ) { sio . state . readcalls ++ ; int len = inputStream . read ( mReadBuffer . array ( ) , 0 , READ_SIZE ) ; if ( len > 0 ) { mReadBuffer . position ( len ) ; rbuf . append ( mReadBuffer ) ; mReadBuffer . clear ( ) ; return ; } } } catch ( Exception e ) { sio . onRunError ( e , "OTG read" ) ; } }
tr	3	public void setNumberType ( int type ) { if ( renderer != null ) { renderer . removeListener ( this ) ; } if ( type == BenoitNumber . DOUBLE_TYPE ) { renderer = new FastDoublesRenderer ( ) ; } else if ( type == BenoitNumber . BIG_TYPE ) { renderer = new BigDecimalRenderer ( ) ; } else { throw new IllegalArgumentException ( "invalid number type" ) ; } numericType = type ; getParameters ( ) . setType ( type ) ; renderer . addListener ( this ) ; fireChange ( RENDERER_CHANGED ) ; }
tr	6	public static void main ( String argv [ ] ) { Bus busses [ ] = null ; Host host ; try { host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USB is unavailable  can't run." ) ; return ; } System . out . println ( "<!-- " + host + " -->" ) ; busses = host . getBusses ( ) ; indentLine ( 0 , "<host busses='" + busses . length + "'>" ) ; for ( int busno = 0 ; busno < busses . length ; busno ++ ) { indentLine ( 2 , "<!-- Bus #" + ( busno + 1 ) + " -->" ) ; if ( busses [ busno ] != null ) { try { printDevice ( 2 , busses [ busno ] . getRootHub ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } indentLine ( 0 , "</host>" ) ; } catch ( SecurityException e ) { System . err . println ( "USB permissions problem:" ) ; System . err . println ( e . getMessage ( ) ) ; System . exit ( 1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	7	private String getOrientationString ( Orientations o ) { String os = "unknown" ; if ( o == Orientations . horizontal ) os = "horizontal" ; if ( o == Orientations . left ) os = "90\u00B0 left" ; if ( o == Orientations . right ) os = "90\u00B0 right" ; if ( o == Orientations . upside ) os = "180\u00B0" ; if ( myTFTType == TFTTypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( myTFTType == TFTTypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( myTFTType == TFTTypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	2	public boolean inGameState ( String state ) { for ( int i = gamestate . size ( ) - 1 ; i >= 0 ; i -- ) { if ( ( ( String ) gamestate . elementAt ( i ) ) . equals ( state ) ) return true ; } return false ; }
tr	3	@ SuppressWarnings ( "unchecked" ) private void initprocedureArray ( ) { procedureArray = ( Action < TerminalEnum , ProductionEnum , VersionEnum > [ ] ) new Action < ? , ? , ? > [ ] { reduceitem_star_0_empty , branch0 , branch0 , shift4 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reduceblock , reduceinstr_end , reduceinstr_break , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reducefuncall , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_if , branch0 , reduceinstr_if_else , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat_while , branch0 , reduceinstr_funcall , branch0 , reduceproc , reduceitem_proc , reduceitem_instr , reduceitem_star_0_rec } ; }
tr	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	7	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	4	@ Override public < T extends AggregateRoot < ? >> T loadOneBy ( final class < T > aggregateRoot , final Specification < T > specification ) { @ SuppressWarnings ( "unchecked" ) final DomainRepositoryDriver < T , ? > driver = ( DomainRepositoryDriver < T , ? > ) drivers . get ( aggregateRoot ) ; if ( driver == null ) { throw new RuntimeException ( "Can't find any driver for the given aggregate: " + aggregateRoot ) ; } return driver . loadOneBySpecification ( specification ) ; }
tr	0	public void obtainReservations ( ) { BigDecimal [ ] reservations = { BigDecimal . valueOf ( long . valueOf ( "1" ) ) , BigDecimal . valueOf ( long . valueOf ( "2" ) ) } ; System . out . println ( "Invoking Managed Tasks" ) ; ejbFacade . getReservations ( reservations ) ; setReservationListMessage ( "The reservation report has been initated" ) ; }
tr	9X	public void setAttributes ( NamedNodeMap attributes ) { if ( attributes == null ) { return ; } String target = attributes . getNamedItem ( "target" ) . getNodeValue ( ) ; if ( target == null || target . isEmpty ( ) ) { return ; } if ( target . equalsIgnoreCase ( "iesdigital" ) ) { this . registerIesDigital = true ; } if ( target . equalsIgnoreCase ( "sgd" ) ) { this . registerSGD = true ; } for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { Node item = attributes . item ( i ) ; if ( item . getNodeName ( ) . equals ( "dates" ) ) { this . dates = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "dates" ) ) { this . dates = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "type" ) ) { this . tipus = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "simbol" ) ) { this . simboloIncidencia = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "description" ) ) { this . observaciones = item . getNodeValue ( ) . replaceAll ( "<" , "(" ) . replaceAll ( ">" , ")" ) ; } else if ( item . getNodeName ( ) . equals ( "incpersession" ) ) { this . incidenciasSesion = Integer . parseInt ( item . getNodeValue ( ) ) ; } else if ( item . getNodeName ( ) . equals ( "allDay" ) ) { this . todoElDia = item . getNodeValue ( ) . equals ( "yes" ) ; } } }
tr	2	private boolean isValidUserInput ( final String hostname , final String port ) { final String methodName = "isValidUserInput" ; ControllerLogger . entering ( CLASS_NAME , methodName , hostname , port ) ; try { if ( GUIUtils . isEmptyValue ( hostname ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_HOSTNAME_MESSAGE ) ; return false ; } if ( ! GUIUtils . isPortNumberValid ( port ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_PORT_NUMBER_MESSAGE ) ; return false ; } return true ; } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	7	protected static void addObject ( IUnknown o ) { if ( apartmentInitialized . get ( ) == false ) { ComThread . InitSTA ( false ) ; apartmentInitialized . set ( true ) ; } if ( ! AUTO_GC ) return ; ReferenceQueue < IUnknown > deadObjects = deadPool . get ( ) ; objects . put ( new PointerWeakReference ( o , deadObjects ) , false ) ; if ( GC_COUNT != - 1 && ( count % GC_COUNT ) == 0 ) { System . gc ( ) ; } if ( ( count ++ % CULL_COUNT ) == 0 ) { int numberCulled = cullDeadPool ( deadObjects , objects ) ; if ( IUnknown . isDebugEnabled ( ) ) { if ( numberCulled > 0 ) { IUnknown . debug ( "ROT: added instance of " + o . getClass ( ) . getSimpleName ( ) + "->[+1  -" + numberCulled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	5	private void drawGhosts ( ) { for ( int index = 0 ; index < G . NUM_GHOSTS ; index ++ ) { int loc = game . getCurGhostLoc ( index ) ; int x = game . getX ( loc ) ; int y = game . getY ( loc ) ; if ( game . getEdibleTime ( index ) > 0 ) { if ( game . getEdibleTime ( index ) < _G_ . EDIBLE_ALERT && ( ( game . getTotalTime ( ) % 6 ) / 3 ) == 0 ) bufferGraphics . drawImage ( ghostsImgs [ 5 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ 4 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } else { if ( game . getLairTime ( index ) > 0 ) bufferGraphics . drawImage ( ghostsImgs [ index ] [ G . UP ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 + ( index * 5 ) , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ index ] [ game . getCurGhostDir ( index ) ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } } }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
tr	6	public ScenarioTreeStepTwoOptions ( String name , ScenarioTreeStep first , String firstText , ScenarioTreeStep second , String secondText , String help ) { super ( name , help ) ; if ( first == null || second == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Schritte m\u00FCssen gesetzt sein!" ) ; } if ( firstText == null || firstText . trim ( ) . isEmpty ( ) || secondText == null || secondText == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Texte m\u00FCssen gesetzt und nicht leer sein!" ) ; } this . addFollowUpStep ( first , firstText ) ; this . addFollowUpStep ( second , secondText ) ; }
tr	5	public Identifier AddUser ( User info ) { try { if ( info . getContact ( ) == null || info . getContact ( ) . getEmail ( ) == null || info . getFirstName ( ) == null || info . getLastName ( ) == null ) { return null ; } return Users . getInstance ( ) . create ( info ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { System . err . println ( "Failed to Add user. " + e . getMessage ( ) ) ; return null ; } }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	5	protected void scrollUp ( final int firstScrollLine , final int lastScrollLine , final int lines ) { if ( firstScrollLine < 0 ) { throw new IllegalArgumentException ( "First scroll line cannot be less than zero!" ) ; } if ( lastScrollLine >= getHeight ( ) ) { throw new IllegalArgumentException ( "Last scroll line cannot be greater than terminal height!" ) ; } if ( lastScrollLine < firstScrollLine ) { throw new IllegalArgumentException ( "Scroll region cannot be negative!" ) ; } if ( lines < 1 ) { throw new IllegalArgumentException ( "Invalid number of lines!" ) ; } int region = ( lastScrollLine - firstScrollLine + 1 ) ; int n = Math . min ( lines , region ) ; int width = getWidth ( ) ; int srcPos = ( n + firstScrollLine ) * width ; int destPos = firstScrollLine * width ; int lastPos = ( lastScrollLine + 1 ) * width ; int length = lastPos - srcPos ; if ( length > 0 ) { System . arraycopy ( m_buffer , srcPos , m_buffer , destPos , length ) ; } Arrays . fill ( m_buffer , destPos + length , srcPos + length , new TextCell (   , getAttributes ( ) ) ) ; m_heatMap . set ( destPos , lastPos ) ; }
tr	3	private void drawQuitButton ( ) { Box tempBox = new Box ( BoxLayout . X_AXIS ) ; statBox . add ( tempBox ) ; quit = new KulButton ( s ( "quit" ) ) ; quit . setPreferredSize ( new Dimension ( 140 , 50 ) ) ; quit . setMaximumSize ( new Dimension ( 140 , 50 ) ) ; quit . setForeground ( Color . WHITE ) ; quit . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) && ! bestScorePanel . isActive ( ) ) { String [ ] options = { s ( "yes" ) , s ( "no" ) } ; int choice = JOptionPane . showOptionDialog ( MainPanel . this , s ( "quitConfirm" ) , s ( "quit" ) , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE , null , options , 0 ) ; if ( choice == JOptionPane . OK_OPTION ) { main . Main . closeWindow ( ) ; } } } } ) ; tempBox . add ( quit ) ; }
tr	9X	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	9X	public IPv4 ( String symbolicIP , String netmask ) throws NumberFormatException { String [ ] st = symbolicIP . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; int i = 24 ; baseIPnumeric = 0 ; for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; } baseIPnumeric += value << i ; i -= 8 ; } st = netmask . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; i = 24 ; netmaskNumeric = 0 ; if ( Integer . parseInt ( st [ 0 ] ) < 255 ) { throw new NumberFormatException ( "The first byte of netmask can not be less than 255" ) ; } for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; } netmaskNumeric += value << i ; i -= 8 ; } boolean encounteredOne = false ; int ourMaskBitPattern = 1 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( netmaskNumeric & ourMaskBitPattern ) != 0 ) { encounteredOne = true ; } else { if ( encounteredOne == true ) throw new NumberFormatException ( "Invalid netmask: " + netmask + " (bit " + ( i + 1 ) + ")" ) ; } ourMaskBitPattern = ourMaskBitPattern << 1 ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { ListaObjetos dialog = new ListaObjetos ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	7	public Hashtable < String , Neo4jCluster > perform ( DatasetLoader datasetHandler , Neo4jHandler neo4jHandler , double similairtyThreshold , int softClusteringThreshold ) throws Exception { Hashtable < String , Neo4jCluster > clustersList = new Hashtable < String , Neo4jCluster > ( ) ; Hashtable < String , Document > docsHash = datasetHandler . loadDocuments ( ) ; DDSimIF similarityCalculator = new DDSimilairty ( ) ; Enumeration e = docsHash . keys ( ) ; int numberOfClusters = 0 ; while ( e . hasMoreElements ( ) ) { Hashtable < String , double > candidateClustersHash = new Hashtable < String , double > ( ) ; String documentID = ( String ) e . nextElement ( ) ; System . out . println ( "Processing document " + documentID ) ; Document document = docsHash . get ( documentID ) ; Neo4jDocument neo4jDocument = neo4jHandler . loadDocument ( document ) ; boolean clusteredYet = false ; ArrayList < Neo4jDocument > similarDocuments = getSimilarDocuments ( neo4jDocument , neo4jHandler , datasetHandler ) ; for ( Iterator iterator = similarDocuments . iterator ( ) ; iterator . hasNext ( ) ; ) { Neo4jDocument neo4jSimilarDocument = ( Neo4jDocument ) iterator . next ( ) ; if ( neo4jSimilarDocument . getClustersHash ( ) . isEmpty ( ) ) continue ; if ( similarityCalculator . calculateSimilarity ( neo4jDocument , neo4jSimilarDocument , datasetHandler . numberOfDocuments ( ) ) > similairtyThreshold ) { ArrayList < String > candidateDocumentClustersIDs = neo4jSimilarDocument . getClusterIDsList ( ) ; for ( Iterator iterator2 = candidateDocumentClustersIDs . iterator ( ) ; iterator2 . hasNext ( ) ; ) { String candidateClusterID = ( String ) iterator2 . next ( ) ; Neo4jCluster candidateNeo4jCluster = clustersList . get ( candidateClusterID ) ; double averageSimilairtyToCluster = calculateAvgSimilairtyToCluster ( neo4jDocument , candidateNeo4jCluster , datasetHandler , neo4jHandler ) ; if ( averageSimilairtyToCluster > similairtyThreshold ) { clusteredYet = true ; candidateClustersHash . put ( candidateClusterID , averageSimilairtyToCluster ) ; } } } } if ( ! clusteredYet ) { numberOfClusters ++ ; Neo4jCluster newCluster = new Neo4jCluster ( String . valueOf ( numberOfClusters ) ) ; newCluster . addDcoument ( documentID ) ; neo4jDocument . addCluster ( newCluster . getId ( ) , 1 ) ; clustersList . put ( newCluster . getId ( ) , newCluster ) ; } else { String nearestClusterID = getNearestCluster ( candidateClustersHash ) ; Neo4jCluster cluster = clustersList . get ( nearestClusterID ) ; cluster . addDcoument ( neo4jDocument . getDocumentID ( ) ) ; neo4jDocument . addCluster ( nearestClusterID , 1 ) ; } } return clustersList ; }
tr	9X	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	8	public static void main ( String args [ ] ) throws Exception { if ( ( args . length < 2 ) || ( args . length > 3 ) ) throw new IllegalArgumentException ( "\u53C2\u6570\u4E0D\u6B63\u786E" ) ; String server = args [ 0 ] ; byte [ ] argument = args [ 1 ] . getBytes ( ) ; int servPort = ( args . length == 3 ) ? Integer . parseInt ( args [ 2 ] ) : 7 ; SocketChannel clntChan = SocketChannel . open ( ) ; clntChan . configureBlocking ( false ) ; if ( ! clntChan . connect ( new InetSocketAddress ( server , servPort ) ) ) { while ( ! clntChan . finishConnect ( ) ) { System . out . print ( "." ) ; } } System . out . print ( "\n" ) ; ByteBuffer writeBuf = ByteBuffer . wrap ( argument ) ; ByteBuffer readBuf = ByteBuffer . allocate ( argument . length ) ; int totalBytesRcvd = 0 ; int bytesRcvd ; while ( totalBytesRcvd < argument . length ) { if ( writeBuf . hasRemaining ( ) ) { clntChan . write ( writeBuf ) ; } if ( ( bytesRcvd = clntChan . read ( readBuf ) ) == - 1 ) { throw new SocketException ( "Connection closed prematurely" ) ; } totalBytesRcvd += bytesRcvd ; System . out . print ( "." ) ; } System . out . println ( "Received: " + new String ( readBuf . array ( ) , 0 , totalBytesRcvd ) ) ; clntChan . close ( ) ; }
tr	6	public Object tostring ( Object value ) { if ( value == null ) return "nil" ; if ( value instanceof String ) return ( String ) value ; if ( value instanceof boolean || value instanceof double ) return value . toString ( ) ; if ( isCallable ( value ) ) return "function: " + System . identityHashCode ( value ) ; Object meta = getMetaValue ( value , "__tostring" ) ; if ( meta != null ) return call ( meta , value ) ; return value . toString ( ) ; }
tr	8	private static boolean longestWordFromOtherWords2 ( HashMap < String , boolean > wordMap , boolean isOriginal , String word ) { String substring1 ; String substring2 ; if ( word == null || word . length ( ) == 0 ) { return false ; } else if ( wordMap . containsKey ( word ) && ! isOriginal ) { return wordMap . get ( word ) ; } else { int i ; for ( i = 1 ; i < word . length ( ) ; i ++ ) { substring1 = word . substring ( 0 , i ) ; substring2 = word . substring ( i ) ; if ( wordMap . containsKey ( substring1 ) && wordMap . get ( substring1 ) == true && longestWordFromOtherWords2 ( wordMap , false , substring2 ) ) { return true ; } } wordMap . put ( word , false ) ; return false ; } }
tr	3	public static List < FavoritesTag > constructTag ( Response res ) throws WeiboException { try { JSONArray list = res . asJSONObject ( ) . getJSONArray ( "tags" ) ; int size = list . length ( ) ; List < FavoritesTag > tags = new ArrayList < FavoritesTag > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { tags . add ( new FavoritesTag ( list . getJSONObject ( i ) ) ) ; } return tags ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone ) ; } catch ( WeiboException te ) { throw te ; } }
tr	0	public void clear ( ) { listModel . clear ( ) ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent ae ) { if ( ae . getActionCommand ( ) . compareTo ( "comboBoxChanged" ) == 0 ) { if ( ae . getSource ( ) == combo_url ) { loadUrlData ( ) ; } else if ( ae . getSource ( ) == combo_grantType ) { if ( combo_grantType . getSelectedIndex ( ) == AUTHORIZATION_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . AUTHORIZATION_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == PASSWORD_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . PASWORD_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == CLIENT_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) ; setupPanels ( ) ; } } } else if ( ae . getActionCommand ( ) . compareTo ( ABOUT_MENUITEM ) == 0 ) { JOptionPane . showMessageDialog ( applicationFrame , "OAuthTestClient\nAn OAuth 2.0 Test Application\nWritten by Ronnie Mitra.\n\nhttps://github.com/mitraman/OAuthTestClient    \n\n" , "About OAuthTestClient" , JOptionPane . QUESTION_MESSAGE ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SETTINGS_MENUITEM ) == 0 ) { SettingsDialog settingsDialog = new SettingsDialog ( applicationFrame ) ; settingsDialog . setVisible ( true ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SAVE_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( "./OAuthTestClient.cfg" ) ; if ( fileChooser . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . saveProperties ( file ) ; } } else if ( ae . getActionCommand ( ) . compareTo ( LOAD_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( ) ; if ( fileChooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . loadProperties ( file ) ; } } else { System . out . println ( ae . getActionCommand ( ) + " " + ae . getID ( ) ) ; } }
tr	1	public int getComponetType ( boolean disregardScrollPane ) { if ( compType == TYPE_UNSET ) compType = checkType ( disregardScrollPane ) ; return compType ; }
tr	0	@ Before public void setUp ( ) { DB . setDataSource ( new SQLite ( ) ) ; }
tr	8	@ Override public void actionPerformed ( ActionEvent event ) { String userId = textField . getText ( ) ; String userList = textArea . getText ( ) ; if ( event . getSource ( ) == btn [ 0 ] ) { if ( userList . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Add User" ) ; } else { StringTokenizer tokenizer = new StringTokenizer ( userList , "\n" ) ; String targetId [ ] = new String [ userList . length ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { targetId [ i ] = tokenizer . nextToken ( ) ; i ++ ; } String data = ClientLauncher . getUser ( ) . getId ( ) + "\t" + ClientLauncher . getFrame ( ) . getDirectoryListPanel ( ) . getDirectoryID ( ) + "\t" + i ; int type = Constants . PacketType . ShareRequest . getType ( ) ; for ( int j = 0 ; j < i ; j ++ ) { data += "\t" + targetId [ j ] ; } int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } textField . setText ( "" ) ; } if ( event . getSource ( ) == btn [ 1 ] ) { dispose ( ) ; initialize ( ) ; } if ( event . getSource ( ) == btn [ 2 ] ) { if ( userId . equals ( "" ) ) JOptionPane . showMessageDialog ( null , "Input user ID" ) ; else if ( userId . equals ( ClientLauncher . getUser ( ) . getId ( ) ) ) JOptionPane . showMessageDialog ( null , "Can't add your ID" ) ; else { String data = userId ; int type = Constants . PacketType . IdCheckRequest . getType ( ) ; int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } } }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	5	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	4	public void testLineSeriesChart ( ) { LineSeriesChart < Number , Number > chart = new LineSeriesChart < Number , Number > ( "Curves" , "X" , "Y" ) ; Collection < LineSeriesItem < Number , Number >> linhaSin = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaSin . add ( new LineSeriesItem < Number , Number > ( i , Math . sin ( i ) + 4 ) ) ; } chart . addValue ( linhaSin ) ; Collection < LineSeriesItem < Number , Number >> linhaCos = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaCos . add ( new LineSeriesItem < Number , Number > ( i , Math . cos ( i ) ) ) ; } chart . addValue ( linhaCos ) ; Collection < LineSeriesItem < Number , Number >> linhaExp = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaExp . add ( new LineSeriesItem < Number , Number > ( i , Math . exp ( i ) + 1 ) ) ; } chart . addValue ( linhaExp ) ; Collection < LineSeriesItem < Number , Number >> linhaReta = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaReta . add ( new LineSeriesItem < Number , Number > ( i , i ) ) ; } chart . addValue ( linhaReta ) ; Highlighter highlighter = criarHighlighter ( ) ; chart . getChartConfiguration ( ) . setHighlighter ( highlighter ) ; chart . addSerie ( criarSerie ( "Seno" , "#489104" ) ) ; chart . addSerie ( criarSerie ( "Coseno" , "#c91212" ) ) ; chart . addSerie ( criarSerie ( "Exponensial" , "#7D02B2" ) ) ; chart . addSerie ( criarSerie ( "Reta" , "#066FA7" ) ) ; Legend legend = new Legend ( true , Location . ne ) ; legend . setPlacement ( "outsideGrid" ) ; chart . setLegend ( legend ) ; Axis < String > axis = new AxisString ( ) ; axis . setLabelRenderer ( JqPlotResources . CanvasAxisLabelRenderer ) ; chart . setAxesDefaults ( axis ) ; Axes axes = chart . getAxes ( ) ; XAxis xaxis = axes . getXaxis ( ) ; TickOptions tickOptions = new TickOptions ( ) ; tickOptions . setAngle ( 270 ) ; tickOptions . setLabelPosition ( "end" ) ; xaxis . setTickOptions ( tickOptions ) ; xaxis . setTickRenderer ( JqPlotResources . CanvasAxisTickRenderer ) ; xaxis . setTickInterval ( 1 ) ; axes . getYaxis ( ) . setTickInterval ( 0.50 ) ; axes . getYaxis ( ) . setMax ( 8.50 ) ; axes . getYaxis ( ) . setMin ( - 1.50 ) ; TickOptions tickOptionsY = new TickOptions ( ) ; tickOptionsY . setFormatString ( "%.2f" ) ; axes . getYaxis ( ) . setTickOptions ( tickOptionsY ) ; Grid grid = new Grid ( ) ; grid . setBackground ( "#ffffff" ) ; grid . setGridLineColer ( "#a0a0a0" ) ; chart . getChartConfiguration ( ) . setGrid ( grid ) ; Cursor cursor = new Cursor ( ) ; cursor . setZoom ( true ) ; cursor . setClickReset ( true ) ; chart . getChartConfiguration ( ) . setCursor ( cursor ) ; String json = JqPlotUtils . createJquery ( chart , "div3" ) ; json = json . replaceAll ( "\\$" , "jQuery" ) ; System . out . println ( json ) ; }
tr	4	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
tr	1	@ Override public List < Score > getHighscore ( ) { List < Score > ret ; try { ret = fetchScores ( 10 ) ; } catch ( IOException e ) { ret = new ArrayList < Score > ( 0 ) ; e . printStackTrace ( ) ; } return ret ; }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	8	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) { return true ; } if ( p == null && q != null ) { return false ; } if ( p != null && q == null ) { return false ; } return ( p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ) ; }
tr	4	public static int [ ] swap ( int [ ] a , int i , int j ) { if ( i < 0 || j < 0 || i > a . length || j > a . length ) { throw new IllegalArgumentException ( "Illegal argument!" ) ; } else { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } System . out . println ( "swap : " + QuickSort . toString ( a ) ) ; return a ; }
tr	8	public Sprite ( StreamLoader streamLoader , String s , int i ) { Stream stream = new Stream ( streamLoader . getDataForName ( s + ".dat" ) ) ; Stream stream_1 = new Stream ( streamLoader . getDataForName ( "index.dat" ) ) ; stream_1 . currentOffset = stream . readUnsignedWord ( ) ; anInt1444 = stream_1 . readUnsignedWord ( ) ; anInt1445 = stream_1 . readUnsignedWord ( ) ; int j = stream_1 . readUnsignedByte ( ) ; int ai [ ] = new int [ j ] ; for ( int k = 0 ; k < j - 1 ; k ++ ) { ai [ k + 1 ] = stream_1 . read3Bytes ( ) ; if ( ai [ k + 1 ] == 0 ) ai [ k + 1 ] = 1 ; } for ( int l = 0 ; l < i ; l ++ ) { stream_1 . currentOffset += 2 ; stream . currentOffset += stream_1 . readUnsignedWord ( ) * stream_1 . readUnsignedWord ( ) ; stream_1 . currentOffset ++ ; } anInt1442 = stream_1 . readUnsignedByte ( ) ; anInt1443 = stream_1 . readUnsignedByte ( ) ; myWidth = stream_1 . readUnsignedWord ( ) ; myHeight = stream_1 . readUnsignedWord ( ) ; int i1 = stream_1 . readUnsignedByte ( ) ; int j1 = myWidth * myHeight ; myPixels = new int [ j1 ] ; if ( i1 == 0 ) { for ( int k1 = 0 ; k1 < j1 ; k1 ++ ) myPixels [ k1 ] = ai [ stream . readUnsignedByte ( ) ] ; setTransparency ( 255 , 0 , 255 ) ; return ; } if ( i1 == 1 ) { for ( int l1 = 0 ; l1 < myWidth ; l1 ++ ) { for ( int i2 = 0 ; i2 < myHeight ; i2 ++ ) myPixels [ l1 + i2 * myWidth ] = ai [ stream . readUnsignedByte ( ) ] ; } } setTransparency ( 255 , 0 , 255 ) ; }
tr	3	public static final Course readCourse ( File definitionFile ) { LOGGER . log ( Level . INFO , "Reading course from file '" + definitionFile + "'" ) ; JSONParser parser = new JSONParser ( ) ; JSONObject jsonObject = null ; try { jsonObject = ( JSONObject ) parser . parse ( new FileReader ( definitionFile ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( org . json . simple . parser . ParseException e ) { e . printStackTrace ( ) ; } Course course = new Course ( ( String ) jsonObject . get ( "name" ) , ( String ) jsonObject . get ( "address" ) , ( int ) ( ( long ) jsonObject . get ( "bestScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "averageScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "worstScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "timesPlayed" ) ) , new ArrayList < Hole > ( ) , ( String ) jsonObject . get ( "userWithBestScore" ) , ( String ) jsonObject . get ( "description" ) ) ; LOGGER . log ( Level . INFO , "Created course '" + course . getName ( ) + "'" ) ; return course ; }
tr	7	public static boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix == null || matrix . length == 0 || matrix [ 0 ] . length == 0 ) return false ; if ( target < matrix [ 0 ] [ 0 ] ) return false ; int row = search ( matrix , target ) ; int i = 0 ; int j = matrix [ row ] . length - 1 ; while ( i <= j ) { int mid = ( i + j ) / 2 ; if ( matrix [ row ] [ mid ] == target ) { return true ; } else if ( matrix [ row ] [ mid ] < target ) { i = mid + 1 ; } else { j = mid - 1 ; } } return false ; }
tr	8	public static void main ( String args [ ] ) throws IOException { Scanner obj = new Scanner ( System . in ) ; System . out . print ( " " ) ; int n = obj . nextInt ( ) ; int m = obj . nextInt ( ) ; int p = obj . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i ] [ j ] = j ; } } while ( p -- > 0 ) { int i = obj . nextInt ( ) ; int j = obj . nextInt ( ) ; arr [ i - 1 ] [ j - 1 ] += 1 ; } for ( int i = 0 ; i < m ; ++ i ) { int j ; for ( j = m - 1 ; j > 0 ; -- j ) { if ( arr [ i ] [ j ] >= arr [ i ] [ j - 1 ] ) { brr [ i ] += arr [ i ] [ j ] - arr [ i ] [ j - 1 ] ; } else { break ; } } if ( j != 0 ) { brr [ i ] = - 1 ; } } for ( int i = 0 ; i < n ; ++ i ) { System . out . println ( brr [ i ] ) ; } }
tr	8	@ Override public void beginContact ( Contact c ) { Fixture a = c . m_fixtureA ; Fixture b = c . m_fixtureB ; if ( a . getUserData ( ) != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { } if ( a . m_isSensor && a . m_userData != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) a . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } if ( b . m_isSensor && b . m_userData != null && b . m_userData . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) b . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } }
tr	5	public void writeRow ( RowDetails rowDetails ) { Util . checkForNotNull ( rowDetails , "rowDetails" ) ; generateRowData ( rowDetails ) ; DataExporterCallback callback = rowDetails . getTable ( ) . getCallback ( ) ; if ( callback != null ) { callback . beforeRow ( rowDetails ) ; } beforeRow ( rowDetails ) ; for ( int columnIndex = 0 ; columnIndex < rowDetails . getTable ( ) . getColumns ( ) . size ( ) ; columnIndex ++ ) { CellDetails cellDetails = new CellDetails ( rowDetails , columnIndex ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; if ( callback != null ) { callback . beforeCell ( cellDetails ) ; } beforeRowCell ( cellDetails ) ; writeRowCell ( cellDetails ) ; afterRowCell ( cellDetails ) ; if ( callback != null ) { callback . afterCell ( cellDetails ) ; } } afterRow ( rowDetails ) ; if ( callback != null ) { callback . afterRow ( rowDetails ) ; } }
tr	9X	@ SuppressWarnings ( "unchecked" ) protected Object get ( String [ ] parts ) { if ( parts . length == 0 ) { return root ; } if ( ! ( root instanceof Map < ? , ? > ) ) { return null ; } Map < Object , Object > node = ( Map < Object , Object > ) root ; for ( int i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; Matcher m = indexPattern . matcher ( part ) ; int index = - 1 ; if ( m . matches ( ) ) { part = part . substring ( 0 , part . length ( ) - m . group ( 1 ) . length ( ) ) ; index = Integer . parseInt ( m . group ( 1 ) ) ; } Object o = node . get ( part ) ; if ( o == null ) { return null ; } else if ( i == parts . length - 1 ) { return getIndexOf ( o , index ) ; } try { node = ( Map < Object , Object > ) getIndexOf ( o , index ) ; } catch ( ClassCastException e ) { return null ; } } return null ; }
tr	0	public String getMateria ( ) { return materia ; }
tr	3	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	6	public ListNode rotateRight ( ListNode head , int n ) { if ( head == null || head . next == null || n == 0 ) { return head ; } ListNode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } ListNode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; IdentNode other = ( IdentNode ) obj ; if ( identName == null ) { if ( other . identName != null ) return false ; } else if ( ! identName . equals ( other . identName ) ) return false ; return true ; }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PersistentEntry < ? , ? > other = ( PersistentEntry < ? , ? > ) obj ; if ( entry == null ) { if ( other . entry != null ) return false ; } else if ( ! entry . equals ( other . entry ) ) return false ; return true ; }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	4	@ Override public boolean hasNext ( ) { if ( end ) { return false ; } if ( next != null ) { return true ; } peeked = true ; while ( iterator . hasNext ( ) ) { final T n = iterator . next ( ) ; if ( predicate . evaluate ( n ) ) { next = n ; return true ; } } end = true ; return false ; }
tr	3	public static void initConfig ( String path ) { FileInputStream fis = null ; try { fis = new FileInputStream ( path ) ; SYSTEM_CONFIG . load ( fis ) ; } catch ( Exception e ) { logger . error ( "System config file init fail !" , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	1	public void run ( ) { boolean autoFlushStream = true ; try { in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; out = new PrintWriter ( clientSocket . getOutputStream ( ) , autoFlushStream ) ; out . println ( "sWait" ) ; processPlayer ( ) ; } catch ( IOException ioe ) { System . out . println ( "Some I/O error occured..." + ioe . getMessage ( ) ) ; } }
tr	4	protected Tile getTile ( Tile t , Direction step ) { Point location = t . getLocation ( ) ; switch ( step ) { case EAST : return getTile ( new Point ( location . x + 1 , location . y ) ) ; case NORTH : return getTile ( new Point ( location . x , location . y - 1 ) ) ; case SOUTH : return getTile ( new Point ( location . x , location . y + 1 ) ) ; case WEST : return getTile ( new Point ( location . x - 1 , location . y ) ) ; default : return null ; } }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	6	public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FileImageSource other = ( FileImageSource ) obj ; if ( file == null ) { if ( other . file != null ) return false ; } else if ( ! file . equals ( other . file ) ) return false ; return true ; }
tr	4	@ Override public void mouseClicked ( MouseEvent arg0 ) { if ( albumsScreen . editing ) { albumsScreen . editing = false ; albumsScreen . edit . setIcon ( new ImageIcon ( "resources/editUP.jpg" ) ) ; albumsScreen . edit . setPressedIcon ( new ImageIcon ( "resources/editDN.jpg" ) ) ; for ( AlbumInfo panel : albumsScreen . albumpanels ) { panel . changeName ( ) ; panel . showHideDeleteBtn ( ) ; panel . allowNameEditing ( ) ; } } try { photoScreen = new PhotosScreen ( this . album , this . albumsScreen . control , this . albumsScreen . backend , this , this . albumsScreen ) ; photoScreen . setVisible ( true ) ; photoScreen . setLocationRelativeTo ( null ) ; photoScreen . setResizable ( false ) ; this . albumsScreen . setVisible ( false ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	0	public void mouseExited ( MouseEvent e ) { }
tr	6	public void convertItemToHtml ( XmlPullParser parser , XmlSerializer writer ) throws IOException , XmlPullParserException { writer . startTag ( null , "p" ) ; String title = null , link = null , description = null ; while ( parser . nextTag ( ) != XmlPullParser . END_TAG ) { if ( parser . getName ( ) . equals ( "title" ) ) { title = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "link" ) ) { link = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "description" ) ) { description = parser . nextText ( ) ; } } writer . startTag ( null , "a" ) ; writer . attribute ( null , "href" , link ) ; if ( title != null ) { writer . text ( title ) ; } else { writer . text ( link ) ; } writer . endTag ( null , "a" ) ; writer . startTag ( null , "br" ) . endTag ( null , "br" ) ; if ( description != null ) writer . text ( description ) ; writer . endTag ( null , "p" ) ; }
tr	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	4	@ Override public void printRow2 ( int row ) { int row_to_print = row - position . row ; if ( row_to_print >= 0 && row_to_print < size . row ) { for ( int i = cols_printed ; i < position . col ; i ++ ) { System . out . format ( "%2s " , " " ) ; cols_printed ++ ; } for ( int col = 0 ; col < size . col ; col ++ ) { System . out . format ( "%2s " , array [ row_to_print ] [ col ] . toString ( ) ) ; cols_printed ++ ; } } }
tr	6	@ Override public Object eval ( OclContext context ) throws OclEvaluationException { if ( "String" . equals ( this . referredType ) ) { return String . class ; } else if ( "Boolean" . equals ( this . referredType ) ) { return boolean . class ; } else if ( "Integer" . equals ( this . referredType ) ) { return Integer . class ; } else if ( "Real" . equals ( this . referredType ) ) { return double . class ; } else if ( "OclVoid" . equals ( this . referredType ) ) { return void . class ; } else if ( "OclAny" . equals ( this . referredType ) ) { return Object . class ; } else { return context . getType ( this . referredType ) ; } }
tr	5	private LinkedList < String > extractKeywords ( String filename ) { LinkedList < String > keywords = new LinkedList < String > ( ) ; int posOfDot = filename . lastIndexOf ( . ) ; if ( posOfDot != - 1 ) { keywords . add ( filename . substring ( posOfDot ) ) ; filename = filename . substring ( 0 , posOfDot ) ; } filename = filename . replaceAll ( "[0-9]+" , " " ) . trim ( ) ; String [ ] splitCamelAndDelim = filename . split ( "((?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addAll ( Arrays . asList ( splitCamelAndDelim ) ) ; for ( Iterator < String > iter = keywords . iterator ( ) ; iter . hasNext ( ) ; ) { String item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . toUpperCase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
tr	4	public void actionPerformed ( ActionEvent e ) { String login = principal . getLogin ( ) ; String senha = principal . getSenha ( ) ; LoginInterface loginInterface = new LoginInterface ( ) ; Funcionario funcionario = null ; try { funcionario = loginInterface . logarUsuario ( login , senha ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } String respostaUsuario = "" ; if ( funcionario != null ) { if ( funcionario . getNivelAcesso ( ) ) { try { UsuarioLogado usuarioLogado = UsuarioLogado . getInstancia ( ) ; usuarioLogado . setUsuarioLogado ( funcionario ) ; OperacaoLog log = new OperacaoLog ( ) ; log . setData ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; log . setDescricao ( "Logon de Administrador: " + funcionario . getNome ( ) ) ; log . setFuncionario ( UsuarioLogado . getInstancia ( ) . getUsuarioLogado ( ) ) ; log . setOperacao ( "Logon de Administrador" ) ; OperacaoLogDao operacaoLogDao = new OperacaoLogDao ( ) ; operacaoLogDao . persiste ( log ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } principal . dispose ( ) ; Administrador . main ( null ) ; } else { respostaUsuario = "Erro  acesso n\u00E3o permitido!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } } else { respostaUsuario = "Erro  Credenciais inv\u00E1lidas!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } e . getActionCommand ( ) ; }
tr	9X	public void mouseDragged ( MouseEvent e ) { if ( isCtrlDown ( e ) || ( ! editMode && ! ctx . dragging ) ) { if ( panCurr != null ) { Point pt = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( e . getComponent ( ) != null ) { SwingUtilities . convertPointToScreen ( pt , e . getComponent ( ) ) ; } int deltaX = pt . x - panCurr . x ; int deltaY = pt . y - panCurr . y ; prevPanCurr = panCurr ; panCurr = new PointAtTime ( pt . x , pt . y ) ; ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . setValue ( - deltaX + ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . getValue ( ) ) ; ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . setValue ( - deltaY + ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . getValue ( ) ) ; } } else { if ( ctx . dragging || ctx . rubberBanding ) { ctx . dragCurr = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( ctx . rubberBanding ) { Point startP = ctx . getXY ( ctx . dragStart . x , ctx . dragStart . y ) ; Point endP = ctx . getXY ( ctx . dragCurr . x , ctx . dragCurr . y ) ; int temp ; if ( startP . x > endP . x ) { temp = startP . x ; startP . x = endP . x ; endP . x = temp ; } if ( startP . y > endP . y ) { temp = startP . y ; startP . y = endP . y ; endP . y = temp ; } ctx . clearSelection ( ) ; for ( CoverDetails cd : ctx . covers ) { if ( cd . getX ( ) >= startP . x && cd . getX ( ) <= endP . x && cd . getY ( ) >= startP . y && cd . getY ( ) <= endP . y ) { ctx . addSelection ( cd ) ; } } } ctx . mainRepaint ( ) ; } } }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	4	private Tag readTag ( ) { Tag retval = null ; String token = null ; try { readTo ( OPEN ) ; } catch ( final Exception e ) { return null ; } try { token = readTo ( CLOSE ) ; if ( token != null ) { token = token . trim ( ) ; if ( token . length ( ) > 0 ) { retval = new Tag ( token ) ; } } } catch ( final IOException e ) { throw error ( "Could not read a complete tag: IO error" ) ; } return retval ; }
tr	5	public static void merge ( int [ ] a , int [ ] aux , int lo , int mid , int hi ) { assert isSorted ( a , lo , mid ) ; assert isSorted ( a , mid + 1 , hi ) ; for ( int k = lo ; k <= hi ; k ++ ) aux [ k ] = a [ k ] ; int i = lo , j = mid + 1 ; for ( int k = lo ; k <= hi ; k ++ ) { if ( i > mid ) { a [ k ] = aux [ j ++ ] ; } else if ( j > hi ) { a [ k ] = aux [ i ++ ] ; } else if ( less ( aux [ j ] , aux [ i ] ) ) { a [ k ] = aux [ j ++ ] ; } else { a [ k ] = aux [ i ++ ] ; } } assert isSorted ( a , lo , hi ) ; }
tr	2	public static void runReports ( boolean full , boolean printall , Object ... objs ) { Tester t = new Tester ( ) ; if ( objs != null ) { for ( Object obj : objs ) { t . runAnyTests ( obj , full , printall ) ; } } }
tr	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
tr	4	public Builder touPricing ( String [ ] froms , String [ ] tos , double [ ] prices ) { if ( ! type . equals ( "TOUPricing" ) ) { System . err . println ( "PricingPolicy type mismatch: method only applicable to the TOUPricing scheme" ) ; return this ; } if ( ! ( froms . length == tos . length && tos . length == prices . length ) ) { System . err . println ( "PricingPolicy initialization error: all input tables must have the same length" ) ; return this ; } for ( int i = 0 ; i < froms . length ; i ++ ) { String from = froms [ i ] ; String to = tos [ i ] ; double price = prices [ i ] ; Period p = new Period ( from , to , price ) ; periods . add ( p ) ; } return this ; }
tr	1	private static void createProduct ( ) { ProductUI productMenu = new ProductUI ( ) ; ProductService productService = new ProductService ( new ProductDAO ( ) ) ; try { ProductModel newProduct = productMenu . createProduct ( ) ; newProduct = productService . createProduct ( newProduct ) ; productMenu . showCreateSuccess ( newProduct ) ; } catch ( WebshopAppException e ) { ExceptionUI . printException ( e ) ; } }
tr	5	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	2	public void exit ( ) { for ( List < GameSystem > s : systems . values ( ) ) { for ( GameSystem system : s ) { system . exit ( ) ; } } systems . clear ( ) ; }
tr	3	public Code getCodeByDescription ( String description ) { for ( Code code : codes ) { Map < String , String > localizedStrings = code . getDescription ( ) . getLocalizedStrings ( ) ; for ( String key : localizedStrings . keySet ( ) ) { if ( localizedStrings . get ( key ) . equalsIgnoreCase ( description ) ) { return code ; } } } return null ; }
tr	5	private static int mixLightness ( int colour , int lightness , int drawType ) { if ( ( drawType & 2 ) == 2 ) { if ( lightness < 0 ) lightness = 0 ; else if ( lightness > 127 ) lightness = 127 ; lightness = 127 - lightness ; return lightness ; } lightness = lightness * ( colour & 7f ) >> 7 ; if ( lightness < 2 ) lightness = 2 ; else if ( lightness > 126 ) lightness = 126 ; return ( colour & ff80 ) + lightness ; }
tr	5	public static void main ( String [ ] args ) { r1 = new Thread ( ) { public void run ( ) { while ( i < 100 ) { if ( i % 10 == 0 ) { if ( r2 . isAlive ( ) ) r2 . notify ( ) ; else r2 . run ( ) ; } i ++ ; } r1 . interrupt ( ) ; r2 . interrupt ( ) ; } } ; r2 = new Thread ( ) { public void run ( ) { System . out . println ( i ) ; try { if ( r2 . isAlive ( ) ) { r2 . wait ( ) ; r1 . notify ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; r1 . run ( ) ; }
tr	9X	public String checkDataEntry ( ) { if ( panel6 . large . getText ( ) . equals ( "" ) || panel6 . small . getText ( ) . equals ( "" ) || panel6 . medium . getText ( ) . equals ( "" ) || panel6 . largeDiffIndicator . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else { try { double large = double . parseDouble ( panel6 . large . getText ( ) ) ; double small = double . parseDouble ( panel6 . small . getText ( ) ) ; double medium = double . parseDouble ( panel6 . medium . getText ( ) ) ; double largeDiff = double . parseDouble ( panel6 . largeDiffIndicator . getText ( ) ) ; if ( large > 1 || small > 1 || medium > 1 || largeDiff > 1 || large < 0 || small < 0 || medium < 0 || largeDiff < 0 ) { return "A-Test significance levels must be doubles between zero and one" ; } else { return null ; } } catch ( NumberFormatException e ) { return "A-Test significance levels must be doubles less than one" ; } } }
tr	9X	private QuerySet < T > range ( String query ) { QuerySet < T > querySet = null ; try { if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { query = query . replace ( "__range" , "" ) ; query = query . replace ( "  " , " " ) ; query = query . replaceAll ( "['\\[\\]]" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; if ( queryComponents != null && queryComponents . length > 0 ) { querySet = new QuerySet < T > ( ) ; querySet . entity ( this . entity ) ; String fieldName = queryComponents [ 0 ] ; String [ ] fieldValues = queryComponents [ 1 ] . split ( " " ) ; Field field = null ; if ( fieldName . trim ( ) . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { for ( int fieldValue = Integer . parseInt ( fieldValues [ 0 ] ) ; fieldValue <= Integer . parseInt ( fieldValues [ 1 ] ) ; fieldValue ++ ) { if ( field . get ( model ) . equals ( fieldValue ) ) { querySet . add ( model ) ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return querySet ; }
tr	7	static boolean authenticate ( String username , String hashString , PassthroughConnection ptc ) { try { String encodedUsername = URLEncoder . encode ( username , "UTF-8" ) ; String encodedHashString = URLEncoder . encode ( hashString , "UTF-8" ) ; String authURLString = new String ( "http://www.minecraft.net/game/checkserver.jsp?user=" + encodedUsername + "&serverId=" + encodedHashString ) ; if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Authing with " + authURLString ) ; } URL minecraft = new URL ( authURLString ) ; URLConnection minecraftConnection = minecraft . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( minecraftConnection . getInputStream ( ) ) ) ; String reply = in . readLine ( ) ; if ( Globals . isInfo ( ) ) { ptc . printLogMessage ( "Server Response: " + reply ) ; } in . close ( ) ; if ( reply != null && reply . equals ( "YES" ) ) { if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Auth successful" ) ; } return true ; } } catch ( MalformedURLException mue ) { ptc . printLogMessage ( "Auth URL error" ) ; } catch ( IOException ioe ) { ptc . printLogMessage ( "Problem connecting to auth server" ) ; } return false ; }
tr	4	public static void execute_crop_stmt ( PreparedStatement pstmt , int [ ] indexes , HashSet < Integer > set ) throws SQLException { int cnt = 0 ; for ( int i = 0 ; i < indexes . length ; i ++ ) { if ( ! set . contains ( indexes [ i ] ) ) { pstmt . setInt ( 1 , indexes [ i ] ) ; pstmt . addBatch ( ) ; cnt ++ ; if ( cnt > 5000 ) { pstmt . executeBatch ( ) ; cnt = 0 ; } } } if ( cnt > 0 ) pstmt . executeBatch ( ) ; }
tr	4	@ Test public void testLinearAssociator ( ) throws Exception { EvaluationManager evaluationManager = new EvaluationManager ( ) ; evaluationManager . setDataSet ( dataSet ) ; evaluationManager . setAlgorithm ( new LinearAssociator ( ) ) ; evaluationManager . setValidationMethod ( new LeaveOneOutValidation ( ) ) ; evaluationManager . evaluate ( ) ; for ( EvaluationMetric metric : evaluationManager . getMetrics ( ) ) { if ( metric instanceof BasicsMetric ) { System . out . println ( "\nTPR" ) ; double [ ] tpr = ( ( BasicsMetric ) metric ) . getTpr ( ) ; for ( double s : tpr ) { System . out . printf ( "%.3f\n" , s ) ; } System . out . println ( "\nFPR" ) ; double [ ] fpr = ( ( BasicsMetric ) metric ) . getFpr ( ) ; for ( double s : fpr ) { System . out . printf ( "%.3f\n" , s ) ; } } } }
tr	6	public Editor ( DefaultMutableTreeNode node , DefaultTreeModel model ) throws InvalidNodeRepresentationException { _node = node ; _model = model ; _children = new ArrayList < > ( ) ; if ( _node . getUserObject ( ) instanceof Song ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = ( Song ) node . getUserObject ( ) ; _playlist = null ; _artist = new JTextField ( _song . getArtist ( ) ) ; _title = new JTextField ( _song . getTitle ( ) ) ; _album = new JTextField ( _song . getAlbum ( ) ) ; _genre = new JTextField ( _song . getGenre ( ) ) ; _year = new JTextField ( _song . getYear ( ) ) ; _name = null ; JLabel artist = new JLabel ( "Artist:" ) ; JLabel title = new JLabel ( "Title:" ) ; JLabel album = new JLabel ( "Album:" ) ; JLabel genre = new JLabel ( "Genre:" ) ; JLabel year = new JLabel ( "Year:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( artist ) ; add ( _artist ) ; add ( title ) ; add ( _title ) ; add ( album ) ; add ( _album ) ; add ( genre ) ; add ( _genre ) ; add ( year ) ; add ( _year ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , artist , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _artist , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _artist , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . WEST , title , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . EAST , _title , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _title , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . WEST , album , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . EAST , _album , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _album , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . WEST , genre , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . EAST , _genre , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _genre , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . WEST , year , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . EAST , _year , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _year , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _year ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _year ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else if ( _node . getUserObject ( ) instanceof Playlist ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = null ; _playlist = ( Playlist ) node . getUserObject ( ) ; _artist = null ; _title = null ; _album = null ; _genre = null ; _year = null ; _name = new JTextField ( _playlist . getName ( ) ) ; JLabel name = new JLabel ( "Title:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( name ) ; add ( _name ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , name , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _name , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _name , 5 , SpringLayout . EAST , name ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _name ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _name ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else { throw new InvalidNodeRepresentationException ( "Node must represent a Song or Playlist" ) ; } }
tr	7	public Level ( ) { Bitmap bmp = Art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new Blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redPlayer = new Player ( this , Team . allied ) ; bluPlayer = new Player ( this , Team . soviet ) ; }
tr	2	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	8	public DescribeServiceCertificatesResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DescribeServiceCertificatesResult describeServiceCertificatesResult = new DescribeServiceCertificatesResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return describeServiceCertificatesResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "serviceCertificates/item" , targetDepth ) ) { describeServiceCertificatesResult . getServiceCertificates ( ) . add ( ServiceCertificateStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return describeServiceCertificatesResult ; } } } }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
tr	6	public Integer checkFields ( ) { if ( buttonGroup . getSelection ( ) == null ) { return null ; } else { final Enumeration < AbstractButton > elements = buttonGroup . getElements ( ) ; Integer num = null ; while ( elements . hasMoreElements ( ) ) { final JRadioButton button = ( JRadioButton ) elements . nextElement ( ) ; if ( button != null ) { if ( button . isSelected ( ) ) { num = Integer . parseInt ( button . getText ( ) . substring ( button . getText ( ) . lastIndexOf ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkFields ( num ) ) { return num ; } else { JOptionPane . showMessageDialog ( null , "***ERROR***: Incorrect search options" ) ; } } } return null ; }
tr	1	public void update ( M m , Connection conn ) { int result = update ( m , allFields ( ) , conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , getId ( m ) ) ; if ( result != 1 ) { throw new RuntimeException ( "Failed to update record into " + tableName + " table" ) ; } }
tr	7	public static int numPaths ( int x , int y ) { if ( x == 1 && y == 1 ) { return 0 ; } if ( x == 2 && y == 1 ) { return 1 ; } if ( x == 1 && y == 2 ) { return 1 ; } if ( ! isLegal ( x , y ) ) { return 0 ; } return numPaths ( x - 1 , y ) + numPaths ( x , y - 1 ) ; }
tr	9X	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	4	protected EncodedString decodeEncodedCharacterStringOnThirdbit ( ) throws IOException , FastInfosetException { switch ( current_octet & FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_MASK_DISCRIMINANT ) { case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF8_DISCRIMINANT : encodedStringBuffer . setUTF8 ( decodeUTF8inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF16_DISCRIMINANT : encodedStringBuffer . setUTF16 ( decodeUTF16inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALGORITHM_DISCRIMINANT : int index = decodeOctetInteger ( 5 ) ; Algorithm algo = vocabulary . algorithms . get ( index ) ; encodedStringBuffer . setAlgorithm ( index , algo , decodeNonEmptyOctetStringOnFifthBit ( ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALPHABET_DISCRIMINANT : int index2 = decodeOctetInteger ( 5 ) ; Algorithm algo2 = vocabulary . alphabets . get ( index2 ) ; encodedStringBuffer . setAlphabet ( index2 , algo2 , algo2 . fromByteArray ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; } throw new FastInfosetException ( ) ; }
tr	3	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
tr	3	private void notifyClientsDeviceRemoved ( String [ ] deviceNames ) { for ( int h = 0 ; h < deviceNames . length ; h ++ ) { String deviceName = deviceNames [ h ] ; String message = "<delProperty device=\"" + deviceName + "\" />" ; ArrayList < INDIDeviceListener > list = this . getClientsListeningToDevice ( deviceName ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { INDIDeviceListener c = list . get ( i ) ; c . sendXMLMessage ( message ) ; } ArrayList < INDIDeviceListener > list2 = this . getClientsListeningToSingleProperties ( deviceName ) ; for ( int i = 0 ; i < list2 . size ( ) ; i ++ ) { INDIDeviceListener c = list2 . get ( i ) ; c . sendXMLMessage ( message ) ; } } }
tr	0	public void setAgility ( int agi ) { this . agility = agi ; }
tr	5	public static < E , C extends Collection < E >> C removeAll ( final C subject , final Collection < ? > elements ) { Iterator < ? > it = subject . iterator ( ) ; while ( it . hasNext ( ) ) { if ( elements . contains ( it . next ( ) ) ) { it . remove ( ) ; } } try { subject . removeAll ( elements ) ; } catch ( final ClassCastException | NullPointerException ignored ) { } return subject ; }
tr	1	public void loadData ( DadesHotel hotel ) { TitledBorder leftBorder = BorderFactory . createTitledBorder ( hotel . nom ) ; leftBorder . setTitleJustification ( TitledBorder . LEFT ) ; this . setBorder ( leftBorder ) ; nomHotel = hotel . nom ; hotelDescriptionLabel . setText ( hotel . desc ) ; DefaultListModel model = new DefaultListModel ( ) ; for ( DadesHabitacio hab : hotel . habs ) { String dada = hab . tipusHab + " (" + hab . preu + "\u20AC) - " + hab . numeroDisp + " disponibles" ; model . addElement ( dada ) ; nomsTipus . add ( hab . tipusHab ) ; } tipusHabitacionsList . setModel ( model ) ; }
tr	5	public static void main ( String [ ] args ) { Suitors mySuitors = new Suitors ( ) ; for ( int i = 0 ; i < 22 ; i ++ ) mySuitors . add ( ) ; Suitor theSuitor = mySuitors . head ; boolean done = false ; int count = 0 ; while ( ! done ) { if ( theSuitor . next . number == theSuitor . number ) done = true ; else { theSuitor = theSuitor . next . next . next ; mySuitors . remove ( theSuitor ) ; count ++ ; if ( count > 0 && count % 5 == 0 ) { mySuitors . display ( ) ; System . out . println ( ) ; } } } System . out . println ( "And the winner is..." ) ; mySuitors . display ( ) ; }
tr	7	private JPanel createFillInTheBlanksQuestion ( ) { _questionLabel . setText ( _fillInTheBlanks . getAnswer ( ) ) ; final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _optionsStrings = _fillInTheBlanks . getBlanks ( ) ; final int [ ] randomList = MathUtilities . generateRandomArray ( _optionsStrings . size ( ) ) ; _answers = new ArrayList < String > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final String value = _optionsStrings . get ( randomList [ x ] ) ; _answers . add ( _optionsStrings . get ( _optionsStrings . indexOf ( value ) ) ) ; } _optionComboBoxes = new ArrayList < JComboBox > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final JLabel label = new JLabel ( "Choose #" ) ; final String choice = _optionsStrings . get ( randomList [ x ] ) . toLowerCase ( ) ; springLayout . putConstraint ( SpringLayout . WEST , label , 15 , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , label , 45 + x * 35 , SpringLayout . NORTH , jPanel ) ; jPanel . add ( label ) ; Object [ ] choices = new Object [ _optionsStrings . size ( ) + 1 ] ; choices [ 0 ] = "--" ; for ( int y = 0 ; y < choices . length - 1 ; y ++ ) { choices [ y + 1 ] = "[" + y + "]" ; } final JComboBox combobox = new JComboBox ( choices ) ; springLayout . putConstraint ( SpringLayout . WEST , combobox , 10 , SpringLayout . EAST , label ) ; springLayout . putConstraint ( SpringLayout . NORTH , combobox , - 20 , SpringLayout . SOUTH , label ) ; _optionComboBoxes . add ( combobox ) ; combobox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent arg0 ) { String question = "" ; if ( _choicesMade . containsKey ( choice ) ) { _choicesMade . remove ( choice ) ; } String begin = "Question #" + new Integer ( _questionData . getQuestionNumber ( ) ) . toString ( ) + ": " ; question = begin + _questionData . getQuestionString ( ) ; final Set < String > keys = _choicesMade . keySet ( ) ; for ( final String key : keys ) { question = replace ( _choicesMade . get ( key ) , question , key ) ; } final int indexToLookFor = combobox . getSelectedIndex ( ) - 1 ; if ( indexToLookFor >= 0 ) { _choicesMade . put ( choice , "[" + indexToLookFor + "]" ) ; question = replace ( "[" + indexToLookFor + "]" , question , choice ) ; } _beginLabel . setText ( question ) ; } private String replace ( final String needle , final String haystack , final String newNeedle ) { String result = haystack ; while ( result . indexOf ( needle ) != - 1 ) { result = result . replace ( needle , newNeedle ) ; } return result ; } } ) ; jPanel . add ( combobox ) ; final JLabel option = new JLabel ( choice ) ; springLayout . putConstraint ( SpringLayout . WEST , option , 10 , SpringLayout . EAST , combobox ) ; springLayout . putConstraint ( SpringLayout . NORTH , option , 1 , SpringLayout . NORTH , combobox ) ; jPanel . add ( option ) ; } final JLabel temp = new JLabel ( ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , 600 , SpringLayout . WEST , temp ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , 250 , SpringLayout . SOUTH , temp ) ; jPanel . setOpaque ( true ) ; return jPanel ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof TIPPTool ) ) return false ; TIPPTool t = ( TIPPTool ) o ; return Objects . equals ( name , t . name ) && Objects . equals ( id , t . id ) && Objects . equals ( version , t . version ) ; }
tr	4	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
tr	2	@ Override public boolean hasNext ( ) { while ( index < menu . size ( ) ) { if ( menu . get ( index ) . getCalories ( ) <= maxCalories ) { return true ; } else { index ++ ; } } return false ; }
tr	1	private void fixUpCase1 ( RBNode < T > node ) { if ( node . equals ( root ) ) { node . setColour ( Colour . BLACK ) ; } else { fixUpCase2 ( node ) ; } }
tr	2	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( left == null ) ? 0 : left . hashCode ( ) ) ; result = prime * result + ( ( right == null ) ? 0 : right . hashCode ( ) ) ; return result ; }
tr	1	public int anotaClase ( String idProf , String idProfReal , int idHoras , ArrayList < Integer > grupAsigInClass ) { int nup = 0 ; Iterator it = grupAsigInClass . iterator ( ) ; while ( it . hasNext ( ) ) { int idgrupasig = ( ( Number ) it . next ( ) ) . intValue ( ) ; nup += new ClasesAnotadas ( idProf , idProfReal , idHoras , idgrupasig , client ) . save ( ) ; } return nup ; }
tr	0	public Client ( String dni , String nom , String cognoms , String email ) { this . dni = dni ; this . nom = nom ; this . cognoms = cognoms ; this . email = email ; }
tr	6	@ Override public void run ( ) { if ( getLocation ( ) . distance ( bankerTile ) <= 10 ) { goHome ( ) ; } Time . sleep ( rand . nextInt ( 2000 ) ) ; if ( getLocation ( ) . equals ( new Tile ( 3262 , 3322 , 0 ) ) || getLocation ( ) . equals ( new Tile ( 3262 , 3323 , 0 ) ) ) { Walking . walk ( Field ) ; Time . sleep ( 5000 ) ; } SceneObject Gate = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 45206 ; } } ) ; if ( getLocation ( ) . distance ( Gate ) <= 5 ) { Gate . interact ( "Open" ) ; Time . sleep ( 3000 ) ; } if ( getLocation ( ) . distance ( Gate ) <= 5 && ! Gate . isOnScreen ( ) ) { Camera . turnTo ( Gate ) ; Time . sleep ( 3000 ) ; } }
tr	8	public int [ ] [ ] makeTileMap ( ArrayList < GameEntity > entities ) { int width = 1 ; int height = 1 ; startX = entities . get ( 0 ) . getStartX ( ) ; startY = entities . get ( 0 ) . getStartY ( ) ; int tileSize = GlobalSettings . tileSize ; for ( int i = 1 ; i < entities . size ( ) ; i ++ ) { int entX = entities . get ( i ) . getStartX ( ) ; int entY = entities . get ( i ) . getStartY ( ) ; if ( entX < startX ) { if ( ( startX - entX ) / tileSize == 0 ) System . out . println ( "Zero added" ) ; width += ( ( startX - entX ) / tileSize ) ; startX = entX ; } if ( entY < startY ) { height += ( ( startY - entY ) / tileSize ) ; startY = entY ; } if ( entX > startX + width * tileSize ) { width += ( ( entX - ( startX + width * tileSize ) ) / tileSize ) ; } if ( entY > startY + height * tileSize ) { height += ( ( entY - ( startY + height * tileSize ) ) / tileSize ) ; } } height ++ ; width ++ ; int [ ] [ ] tileMap = new int [ height ] [ width ] ; System . out . println ( "Width :: " + width + " Height :: " + height ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { boolean block = entities . get ( i ) . isBlock ( ) ; if ( block ) { int xpos = ( entities . get ( i ) . getStartX ( ) - startX ) / tileSize ; int ypos = ( entities . get ( i ) . getStartY ( ) - startY ) / tileSize ; tileMap [ ypos ] [ xpos ] = 1 ; } } return tileMap ; }
tr	9X	private void parseSpriteSheets ( ) throws IOException , ExpectedTokenException , InvalidTokenException { String line ; line = reader . readLine ( ) ; if ( ! line . equals ( "SPRITESHEETS" ) ) { throw new ExpectedTokenException ( "SPRITESHEETS" , line ) ; } line = reader . readLine ( ) ; while ( line != null && ! line . equals ( "END SPRITESHEETS" ) ) { scanner = new Scanner ( line ) ; if ( ! scanner . hasNext ( ) ) { throw new ExpectedTokenException ( "<file>" , line ) ; } String file = scanner . next ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame width>" , line ) ; } int frameWidth = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame height>" , line ) ; } int frameHeight = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding x>" , line ) ; } int paddingX = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding y>" , line ) ; } int paddingY = scanner . nextInt ( ) ; SpriteSheet sheet = new SpriteSheet ( file , new Vec2i ( frameWidth , frameHeight ) , new Vec2i ( paddingX , paddingY ) ) ; sheets . put ( file , sheet ) ; line = reader . readLine ( ) ; } if ( line == null ) { throw new ExpectedTokenException ( "END SPRITESHEET" , line ) ; } }
tr	4	protected String getPresentationName ( ) { if ( countDifferences ( oldValue , newValue ) == 1 ) { for ( Features feature : Features . values ( ) ) { if ( feature . isChosen ( oldValue ) != feature . isChosen ( newValue ) ) { if ( feature . isChosen ( newValue ) ) { return "set cell " + feature . toString ( ) ; } else { return "unset cell " + feature . toString ( ) ; } } } } return "change cell features" ; }
tr	6	public synchronized void doRanking ( ) { calculate_tf_idf_q ( ) ; Query q ; for ( String term : queryTerms . keySet ( ) ) { term = term . trim ( ) ; q = queryTerms . get ( term ) ; q . setPostings ( getPostingsFor ( term ) ) ; if ( q . getPostings ( ) == null ) { System . out . println ( "sry. no postings found" ) ; continue ; } for ( Posting p : q . getPostings ( ) . getPostings ( ) ) { float value = ( float ) ( q . getTf_idf ( ) * calculate_tf_idf_d ( p , q . getPostings ( ) . getOverallFrequency ( ) ) ) ; Score s = new Score ( ) ; s . setScore ( value ) ; s . setId ( p . getDocID ( ) ) ; if ( ! scores . containsKey ( p . getDocID ( ) ) ) { scores . put ( p . getDocID ( ) , s ) ; } else { Score sc = scores . get ( p . getDocID ( ) ) ; float score = sc . getScore ( ) ; score += value ; sc . setScore ( score ) ; scores . put ( p . getDocID ( ) , sc ) ; } } } float newScore , lengthV ; Score s ; for ( String id : scores . keySet ( ) ) { s = scores . get ( id ) ; try { newScore = s . getScore ( ) / length . get ( id ) . floatValue ( ) ; s . setScore ( newScore ) ; scores . put ( id , s ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	9X	public void run ( ) { while ( isWriter ) { int i ; int j ; synchronized ( this ) { if ( buffIndex == writeIndex ) try { wait ( ) ; } catch ( InterruptedException _ex ) { } if ( ! isWriter ) return ; j = writeIndex ; if ( buffIndex >= writeIndex ) i = buffIndex - writeIndex ; else i = 5000 - writeIndex ; } if ( i > 0 ) { try { outputStream . write ( buffer , j , i ) ; } catch ( IOException _ex ) { hasIOError = true ; } writeIndex = ( writeIndex + i ) % 5000 ; try { if ( buffIndex == writeIndex ) outputStream . flush ( ) ; } catch ( IOException _ex ) { hasIOError = true ; } } } }
tr	3	private static void player1DoSwapPieces ( OthelloPiece piecesToSwap [ ] [ ] ) { for ( int i = 0 ; i < TOTALWIDTH ; i ++ ) { for ( int j = 0 ; j < TOTALHEIGHT ; j ++ ) { if ( piecesToSwap [ i ] [ j ] == null ) { } else { player1SwapPieces ( i , j ) ; } } } }
tr	7	private String getMPatternCode ( ) { int posIni = _position ; for ( ; ; ) { if ( _mumpsPattern . length ( ) <= _position ) { break ; } if ( isQuantifier ( _mumpsPattern . charAt ( _position ) ) || ( _mumpsPattern . charAt ( _position ) == ( ) || ( _mumpsPattern . charAt ( _position ) ==   ) || ( _mumpsPattern . charAt ( _position ) == ) ) ) { break ; } if ( ! patternAtomTranslateTable . containsKey ( _mumpsPattern . charAt ( _position ) ) ) { throw new IllegalArgumentException ( "Code Pattern inv\u00E1lido encontrado: " . concat ( _mumpsPattern . substring ( _position , _position + 1 ) ) . concat ( ". Na posi\u00E7\u00E3o: " . concat ( String . valueOf ( _position ) ) ) ) ; } _position ++ ; } return _mumpsPattern . substring ( posIni , _position ) ; }
tr	1	public boolean isWrapperFor ( class < ? > iface ) throws SQLException { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
tr	2	@ Override public void removeUser ( Identifier id ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException { if ( id == null ) { throw new InvalidIdentifierException ( "Id is invalid" ) ; } if ( Users . remove ( id ) == null ) { throw new IdentifierNotFoundException ( "Id not found" ) ; } Users . remove ( id ) ; write ( USERS ) ; }
tr	3	private boolean isConvex ( Point p1 , Point p2 , Point p3 ) { Point v = new Point ( p2 . x - p1 . x , p2 . y - p1 . y ) ; int res = p3 . x * v . y - p3 . y * v . x + v . x * p1 . y - v . y * p1 . x ; return ! ( ( res > 0 && isCw ) || ( res <= 0 && ! isCw ) ) ; }
tr	3	public static void benchmark ( ) throws Exception { int N = 100000 ; String [ ] methodsToCompare = { "canWriteLetterFromMagazine1" , "canWriteLetterFromMagazine2" , "canWriteLetterFromMagazine3" , "canWriteLetterFromMagazine4" , "canWriteLetterFromMagazine5" , "canWriteLetterFromMagazine6" , "canWriteLetterFromMagazine7" } ; String magazine = cleanInput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; String letter = cleanInput ( "hogs are swine" ) ; for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.twelve.Problem12_09" ) ; Method method = clazz . getDeclaredMethod ( methodName , String . class , String . class ) ; long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean retVal = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retVal == false ) throw new Exception ( "wrong result!" ) ; } long endTime = System . nanoTime ( ) ; System . out . println ( "Elapsed time for " + methodName + ": " + ( endTime - startTime ) / 1000000000.0 + " seconds" ) ; } }
tr	1	public void addMouseListener ( MouseListener mouseListener ) { super . addMouseListener ( mouseListener ) ; for ( Component component : getComponents ( ) ) { component . addMouseListener ( mouseListener ) ; } }
tr	8	protected void encodeDocumentType ( DocumentType documentType ) throws IOException { alignToOctet ( ) ; current_octet |= FastInfosetConstants . DOCUMENT_TYPE_IDENTIFICATION ; boolean encodesystemid = ( documentType . systemIdentifier != null ) && ! documentType . systemIdentifier . isEmpty ( ) ; boolean encodepublicid = ( documentType . publicIdentifier != null ) && ! documentType . publicIdentifier . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( documentType . systemIdentifier , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( documentType . publicIdentifier , vocabulary . other_uris ) ; } if ( documentType . instructions != null ) { for ( fastinfoset . Document . ProcessingInstruction instruction : documentType . instructions ) { encodeProcessingInstruction ( instruction . target , instruction . content ) ; } } current_octet |= FastInfosetConstants . TERMINATION_PATTERN << 4 ; }
tr	5	public User validateUser ( String username , String password ) { try { if ( username . length ( ) > 40 ) return null ; if ( password . length ( ) > 40 ) return null ; select1 . setString ( 1 , username ) ; ResultSet rs = select1 . executeQuery ( ) ; while ( rs . next ( ) ) { if ( rs . getString ( "password" ) . equals ( password ) ) { return new User ( rs . getString ( "username" ) , rs . getString ( "password" ) , rs . getString ( "displayname" ) , PermissionsList . fromByteArray ( rs . getBytes ( "permissions" ) ) ) ; } } rs = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	2	private void traversal ( final TreeNode t , final List < long > list ) { if ( t . left != null ) { traversal ( t . left , list ) ; list . add ( t . value ) ; if ( t . right != null ) { traversal ( t . right , list ) ; } } }
tr	2	@ Override public final void setGeometry ( final Object geometry ) { if ( geometry instanceof String [ ] ) { final String [ ] geometryArray = ( String [ ] ) geometry ; if ( geometryArray . length != 4 ) { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } else { this . raCol = geometryArray [ 0 ] ; this . decCol = geometryArray [ 1 ] ; this . timeCol = geometryArray [ 2 ] ; this . bandCol = geometryArray [ 3 ] ; } } else { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } }
tr	1	private static void assertNotNull ( Object o ) { if ( o == null ) { throw new RuntimeException ( "expected no null value" ) ; } }
tr	8	private void readValues ( Stream stream ) { do { int i = stream . readUnsignedByte ( ) ; boolean dummy ; if ( i == 0 ) return ; else if ( i == 1 ) { anInt390 = stream . read3Bytes ( ) ; rgbToHsl ( anInt390 ) ; } else if ( i == 2 ) anInt391 = stream . readUnsignedByte ( ) ; else if ( i == 3 ) dummy = true ; else if ( i == 5 ) aBoolean393 = false ; else if ( i == 6 ) stream . readString ( ) ; else if ( i == 7 ) { int j = hue ; int k = saturation ; int l = lightness ; int i1 = anInt397 ; int j1 = stream . read3Bytes ( ) ; rgbToHsl ( j1 ) ; hue = j ; saturation = k ; lightness = l ; anInt397 = i1 ; anInt398 = i1 ; } else { System . out . println ( "Error unrecognised config code: " + i ) ; } } while ( true ) ; }
tr	3	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
tr	7	public Contact [ ] resize ( int currentSize , Integer capacity , Contact [ ] c ) { Contact [ ] copy ; if ( capacity == null ) { int j = 0 ; while ( j < c . length ) { if ( c [ j ] == null ) break ; j ++ ; } copy = new Contact [ j ] ; for ( int i = 0 ; i < copy . length ; i ++ ) { copy [ i ] = c [ i ] ; } return copy ; } copy = new Contact [ capacity ] ; if ( capacity > currentSize ) { for ( int i = 0 ; i < currentSize ; i ++ ) { copy [ i ] = c [ i ] ; } } else { for ( int i = 0 ; i < capacity ; i ++ ) { copy [ i ] = c [ i ] ; } } return copy ; }
tr	1	@ Override public void setIsMondayFirstDayOfWeek ( boolean isMondayFirstDayOfWeek ) { if ( isMondayFirstDayOfWeek == true ) { weekDaysMap . put ( 0 , MONDAY ) ; weekDaysMap . put ( 1 , TUESDAY ) ; weekDaysMap . put ( 2 , WEDNESDAY ) ; weekDaysMap . put ( 3 , THURSDAY ) ; weekDaysMap . put ( 4 , FRIDAY ) ; weekDaysMap . put ( 5 , SATURDAY ) ; weekDaysMap . put ( 6 , SUNDAY ) ; } else { weekDaysMap . put ( 0 , SUNDAY ) ; weekDaysMap . put ( 1 , MONDAY ) ; weekDaysMap . put ( 2 , TUESDAY ) ; weekDaysMap . put ( 3 , WEDNESDAY ) ; weekDaysMap . put ( 4 , THURSDAY ) ; weekDaysMap . put ( 5 , FRIDAY ) ; weekDaysMap . put ( 6 , SATURDAY ) ; } super . setIsMondayFirstDayOfWeek ( isMondayFirstDayOfWeek ) ; }
tr	3	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { golab2 : while ( true ) { v_2 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } bra = cursor ; lab4 : do { v_3 = cursor ; lab5 : do { if ( ! ( eq_s ( 1 , "u" ) ) ) { break lab5 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab5 ; } slice_from ( "U" ) ; break lab4 ; } while ( false ) ; cursor = v_3 ; if ( ! ( eq_s ( 1 , "i" ) ) ) { break lab3 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } slice_from ( "I" ) ; } while ( false ) ; cursor = v_2 ; break golab2 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { break lab1 ; } cursor ++ ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	4	public void read ( org . apache . thrift . protocol . TProtocol iprot , inserir_result struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new Registro ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	7	@ Override public boolean shadow_hit ( Ray ray , FloatRef tmin ) { float ox = ray . getOrigin ( ) . getX ( ) ; float oy = ray . getOrigin ( ) . getY ( ) ; float oz = ray . getOrigin ( ) . getZ ( ) ; float dx = ray . getDirection ( ) . getX ( ) ; float dy = ray . getDirection ( ) . getY ( ) ; float dz = ray . getDirection ( ) . getZ ( ) ; float a = dx * dx + dz * dz ; float b = 2.0f * ( ox * dx + oz * dz ) ; float c = ox * ox + oz * oz - radius * radius ; float disc = b * b - 4.0f * a * c ; if ( disc < 0.0 ) return false ; float e = ( float ) sqrt ( disc ) ; float denom = 2.0f * a ; float t = ( - b - e ) / denom ; if ( t > K_EPSILON ) { double yhit = oy + t * dy ; if ( yhit > y0 && yhit < y1 ) { tmin . value = t ; return true ; } } t = ( - b + e ) / denom ; if ( t > K_EPSILON ) { double yhit = oy + t * dy ; if ( yhit > y0 && yhit < y1 ) { tmin . value = t ; return true ; } } return false ; }
tr	0	public ValueListener ( Event1 returnValue ) { this . returnValue = returnValue ; }
tr	7	public static boolean searchAndAdd ( TrieNode root , TrieNode prev , char [ ] str , int index ) { if ( root == null ) { return false ; } if ( root . childLinks == null ) { insertNode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( TrieNode child : root . childLinks ) { if ( child . alphabet == str [ index ] ) { return searchAndAdd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endOfWord ) { return true ; } else { insertNode ( prev , str , index ) ; return false ; } }
tr	7	public synchronized void nextGeneration ( ) { generation ++ ; Arrays . fill ( tmp , 0 ) ; for ( int x = 0 ; x < maxx ; ++ x ) { int xminor = ( x + maxx - 1 ) % maxx ; int xmajor = ( x + 1 ) % maxx ; for ( int y = 0 ; y < maxy ; ++ y ) { int yminor = ( y + maxy - 1 ) % maxy ; int ymajor = ( y + 1 ) % maxy ; int here = maxx * y + x ; int neighbors = f ( grid [ maxx * yminor + xminor ] ) + f ( grid [ maxx * yminor + x ] ) + f ( grid [ maxx * yminor + xmajor ] ) + f ( grid [ maxx * y + xminor ] ) + f ( grid [ maxx * y + xmajor ] ) + f ( grid [ maxx * ymajor + xminor ] ) + f ( grid [ maxx * ymajor + x ] ) + f ( grid [ maxx * ymajor + xmajor ] ) ; if ( grid [ here ] > 0 ) { if ( neighbors < 2 ) { tmp [ here ] = 0 ; } else if ( neighbors == 2 || neighbors == 3 ) { tmp [ here ] = grid [ here ] + 1 ; } else { tmp [ here ] = 0 ; } } else { if ( neighbors == 3 ) { tmp [ here ] = 1 ; } } } } int [ ] t = grid ; grid = tmp ; tmp = t ; }
tr	7	private void updatePlayerList ( Buffer stream , int count ) { while ( stream . bitPosition + 10 < count * 8 ) { int pId = stream . readBits ( 11 ) ; if ( pId == 2047 ) break ; if ( players [ pId ] == null ) { players [ pId ] = new Player ( ) ; if ( playerAppearanceData [ pId ] != null ) players [ pId ] . updatePlayerAppearance ( playerAppearanceData [ pId ] ) ; } localPlayers [ localPlayerCount ++ ] = pId ; Player player = players [ pId ] ; player . lastUpdateTick = tick ; int observed = stream . readBits ( 1 ) ; if ( observed == 1 ) playersObserved [ playersObservedCount ++ ] = pId ; int teleported = stream . readBits ( 1 ) ; int x = stream . readBits ( 5 ) ; if ( x > 15 ) x -= 32 ; int y = stream . readBits ( 5 ) ; if ( y > 15 ) y -= 32 ; player . setPos ( localPlayer . waypointX [ 0 ] + y , localPlayer . waypointY [ 0 ] + x , teleported == 1 ) ; } stream . finishBitAccess ( ) ; }
tr	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
tr	2	public void insertAtEnd ( int element ) { SNode newNode = new SNode ( ) ; newNode . data = element ; if ( HEADER == null ) { HEADER = newNode ; newNode . next = HEADER ; } else { SNode current = HEADER ; while ( current . next != HEADER ) current = current . next ; current . next = newNode ; newNode . next = HEADER ; } }
tr	1	public void displayPlayer ( ) { Iterator < PlayerID > iter = activePlayers . iterator ( ) ; PlayerID p ; System . out . println ( "--- PlayerIDs ---" ) ; while ( iter . hasNext ( ) ) { p = iter . next ( ) ; System . out . println ( "PlayerID: " + p . getPID ( ) + "  ConnectionID: " + p . getCID ( ) ) ; } }
tr	9X	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	3	private void timeButtonMouseClicked ( java . awt . event . MouseEvent evt ) { JOptionPane infoPopup = new JOptionPane ( ) ; int n = JOptionPane . showConfirmDialog ( null , "Are you sure you want to quit?" , "End game" , JOptionPane . YES_NO_OPTION ) ; Result r = new Result ( ) ; ResultContainer cont = new ResultContainer ( ) ; String s = new String ( ) ; if ( n == JOptionPane . YES_OPTION ) { s = JOptionPane . showInputDialog ( null , "Please type your name below: " , "Type your name" , JOptionPane . PLAIN_MESSAGE ) ; System . out . println ( s ) ; if ( s != null ) r . setName ( s ) ; if ( this . empire . getTotalSeconds ( ) > 0 ) r . setSeconds ( this . empire . getTotalSeconds ( ) ) ; infoPopup . setVisible ( false ) ; cont . addAndSerialize ( r ) ; System . exit ( 0 ) ; } }
tr	8	@ Transactional public void allocateSeats ( Event event ) { if ( event . isSeatAllocated ( ) ) { return ; } List < EventRegistration > allUnallocatedForeignRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , false ) ; List < EventRegistration > allUnallocatedIndianRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , true ) ; List < EventRegistration > allUnallocatedRegistrations = new ArrayList < EventRegistration > ( ) ; allUnallocatedRegistrations . addAll ( allUnallocatedForeignRegistrations ) ; allUnallocatedRegistrations . addAll ( allUnallocatedIndianRegistrations ) ; List < RowMeta > rowMetas = eventDAO . getAllEmptyRowMetas ( event ) ; int regsCount = 0 ; int regsSize = allUnallocatedRegistrations . size ( ) ; for ( RowMeta rowMeta : rowMetas ) { if ( regsCount >= regsSize ) { break ; } int seatCounter = 0 ; boolean [ ] seatFlags = markAllocatedSeats ( event , rowMeta ) ; boolean isRowFull = false ; for ( int i = 0 ; i < seatFlags . length ; i ++ ) { if ( regsCount >= regsSize ) { break ; } seatCounter = seatCounter + 1 ; if ( ! seatFlags [ i ] ) { EventRegistration registration = allUnallocatedRegistrations . get ( regsCount ) ; ParticipantSeat seat = createSeat ( registration , rowMeta . getRowName ( ) , seatCounter ) ; participantDAO . saveOrUpdate ( seat ) ; seatFlags [ i ] = true ; regsCount ++ ; } if ( seatFlags . length == seatCounter ) { isRowFull = true ; } } if ( isRowFull ) { rowMeta . setRowFull ( true ) ; eventDAO . saveOrUpdate ( rowMeta ) ; } } event . setSeatAllocated ( true ) ; eventDAO . saveOrUpdate ( event ) ; }
tr	2	private List < Integer > getSelection ( ) { final List < Integer > sel = new LinkedList < > ( ) ; for ( int i = 0 ; i < cardList . size ( ) ; i ++ ) { if ( cardList . get ( i ) . selected ) { sel . add ( i ) ; } } return sel ; }
tr	7	private void populate ( ) { Random rand = Randomizer . getRandom ( ) ; field . clear ( ) ; int Number_of_foxes = 0 ; int Number_of_rabbits = 0 ; int Number_of_korenwolfs = 0 ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { if ( rand . nextDouble ( ) <= KORENWOLF_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Korenwolf korenwolf = new Korenwolf ( true , field , location ) ; actors . add ( korenwolf ) ; Number_of_korenwolfs ++ ; } else if ( rand . nextDouble ( ) <= FOX_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Fox fox = new Fox ( true , field , location ) ; actors . add ( fox ) ; Number_of_foxes ++ ; } else if ( rand . nextDouble ( ) <= RABBIT_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Rabbit rabbit = new Rabbit ( true , field , location ) ; actors . add ( rabbit ) ; Number_of_rabbits ++ ; } else if ( rand . nextDouble ( ) <= HUNTER_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Hunter hunter = new Hunter ( field , location ) ; actors . add ( hunter ) ; } else if ( rand . nextDouble ( ) <= 0.03 ) { Location location = new Location ( row , col ) ; Grass grass = new Grass ( field , location ) ; actors . add ( grass ) ; } } } Rabbit . PERFECT_NUMBER_OF_RABBITS = Number_of_rabbits ; Fox . PERFECT_NUMBER_OF_FOXES = Number_of_foxes ; Korenwolf . PERFECT_NUMBER_OF_KORENWOLFS = Number_of_korenwolfs ; }
tr	3	private void processNumber ( Object value ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; if ( double . isNaN ( average ) ) { average = doubleValue ; min = doubleValue ; max = doubleValue ; sum = doubleValue ; } else { if ( doubleValue < min ) { min = doubleValue ; } if ( doubleValue > max ) { max = doubleValue ; } sum += doubleValue ; average = average + ( doubleValue - average ) / count ; } }
tr	6	void trace ( PgPolygonSet output , PdVector seed , int steps , double stepSize ) { output . addVertex ( seed ) ; PdVector cur = seed ; for ( int s = 1 ; s <= steps ; ++ s ) { PdVector last = cur ; cur = next ( cur , stepSize ) ; if ( cur == null ) { break ; } int vertex = output . addVertex ( cur ) ; output . addPolygon ( new PiVector ( vertex - 1 , vertex ) ) ; if ( PdVector . dist ( last , cur ) < ( stepSize / 10d ) ) { break ; } boolean stop = false ; for ( PdVector v : m_stops ) { if ( PdVector . dist ( v , cur ) < ( stepSize / 10d ) ) { stop = true ; break ; } } if ( stop ) { break ; } } }
tr	3	public NodeUnion ( Link [ ] links ) { if ( links == null || links . length < 2 || links . length > 4 ) { throw new IllegalArgumentException ( "Links size must be >=2 and <=4" ) ; } this . links = links ; }
tr	9X	@ Override public void paintComponent ( Graphics g ) { this . g = ( Graphics2D ) g ; super . paintComponent ( g ) ; for ( int i = 0 ; i < ( this . size * this . size ) ; i ++ ) { this . g . drawLine ( getNodeX ( i ) , getNodeY ( i ) , getNodeX ( i ) , getNodeY ( i ) ) ; } Fire fire = this . loadedEnv . getLevel ( this . level ) . getFire ( ) ; int [ ] [ ] fireArray = fire . getArray ( ) ; for ( int i = 0 ; i < this . size ; i ++ ) { for ( int j = 0 ; j < this . size ; j ++ ) { if ( fireArray [ i ] [ j ] != 0 ) this . drawFire ( i * this . size + j , fireArray [ i ] [ j ] ) ; } } UndirectedGraph walls = this . loadedEnv . getLevel ( this . level ) . getWalls ( ) ; Iterator it = walls . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) walls . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawWall ( tempNode , tempNode2 ) ; } } UndirectedGraph doors = this . loadedEnv . getLevel ( this . level ) . getDoors ( ) ; it = doors . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) doors . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawDoor ( tempNode , tempNode2 ) ; } } UndirectedGraph exits = this . loadedEnv . getLevel ( this . level ) . getExits ( ) ; it = exits . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) exits . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawExit ( tempNode , tempNode2 ) ; } } ArrayList agents = this . loadedEnv . getAgents ( ) ; it = agents . iterator ( ) ; while ( it . hasNext ( ) ) { Agent a = ( Agent ) it . next ( ) ; if ( a . getLevel ( ) == this . level ) this . drawAgent ( a ) ; } ArrayList labels = this . loadedEnv . getLevel ( this . level ) . getLabels ( ) ; it = labels . iterator ( ) ; while ( it . hasNext ( ) ) { Label l = ( Label ) it . next ( ) ; this . drawLabel ( l ) ; } if ( this . hNode1 != 0 && this . hNode2 != 0 ) this . drawHighlight ( ) ; }
tr	6	private void createUnits ( ) { ArrayList < Building > buildings = g . map . getPlayersBuildings ( this ) ; boolean hasMoney = true ; while ( hasMoney ) { for ( Building building : buildings ) { if ( building instanceof Factory ) { ( ( Factory ) building ) . recruitTank ( g . map , building . getCell ( ) , true ) ; } if ( building instanceof Barracks ) { ( ( Barracks ) building ) . recruitMarine ( g . map , building . getCell ( ) , true ) ; } } if ( buildings . contains ( Barracks . class ) ) { hasMoney = this . getMoney ( ) >= Marine . cost ; } else if ( buildings . contains ( Factory . class ) ) { hasMoney = this . getMoney ( ) >= Tank . cost ; } else { hasMoney = false ; } } }
tr	4	private static Expr resolveNoneParamExpr ( SyntaxTreeNode node ) { LexToken token = node . getToken ( ) ; String text = token . getText ( ) ; switch ( ( NagisaLexTokenType ) token . getType ( ) ) { case LITERAL_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerLiteral , text ) ; case IDENTIFIER_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerVariableRef , text ) ; case LITERAL_STRING : return new Expr ( ExprType . String , ExprOperator . StringLiteral , text ) ; case IDENTIFIER_STRING : return new Expr ( ExprType . String , ExprOperator . StringVariableRef , text ) ; default : throw new UnsupportedOperationException ( token . toString ( ) ) ; } }
tr	2	private void program ( BlockNode root ) { Token t = in . next ( ) ; while ( t != null ) { if ( t . type == TokenType . END ) throw new ParserException ( "extra ']' without matching '['" ) ; else operation ( root , t ) ; t = in . next ( ) ; } }
tr	4	protected String getJarName ( URL url ) { String fileName = url . getFile ( ) ; if ( fileName . contains ( "?" ) ) { fileName = fileName . substring ( 0 , fileName . indexOf ( "?" ) ) ; } if ( fileName . endsWith ( ".pack.lzma" ) ) fileName = fileName . replaceAll ( ".pack.lzma" , "" ) ; else if ( fileName . endsWith ( ".pack" ) ) fileName = fileName . replaceAll ( ".pack" , "" ) ; else if ( fileName . endsWith ( ".lzma" ) ) { fileName = fileName . replaceAll ( ".lzma" , "" ) ; } return fileName . substring ( fileName . lastIndexOf ( / ) + 1 ) ; }
tr	0	@ FuncInfo ( name = "LOG10" , group = "Math Transform" , flags = 0 , nbInput = 1 , nbOptInput = 0 , nbOutput = 1 ) public RetCode log10 ( int startIdx , int endIdx , @ InputParameterInfo ( paramName = "inReal" , flags = 0 , type = InputParameterType . TA_Input_Real ) double inReal [ ] , MInteger outBegIdx , MInteger outNBElement , @ OutputParameterInfo ( paramName = "outReal" , flags = 1 , type = OutputParameterType . TA_Output_Real ) double outReal [ ] ) { return super . log10 ( startIdx , endIdx , inReal , outBegIdx , outNBElement , outReal ) ; }
tr	9X	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitClone gitClone = ( GitClone ) o ; if ( localPath != null ? ! localPath . equals ( gitClone . localPath ) : gitClone . localPath != null ) return false ; if ( pathToGit != null ? ! pathToGit . equals ( gitClone . pathToGit ) : gitClone . pathToGit != null ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( gitClone . repositoryUrl ) : gitClone . repositoryUrl != null ) return false ; return true ; }
tr	5	@ Test public void testlimitNunberOfItems ( ) throws IOException { block = new StorageBlock ( testDir , 2 , StorageManager . DEFAULT_CAPACITY_PER_BLOCK , storageMode ) ; int limit = 1000 ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = block . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; assertTrue ( testBytes . length * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; } String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == block . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit - ( testBytes . length - smallTestBytes . length ) * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == block . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == block . getUsed ( ) ) ; block . free ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; }
tr	2	private Set < String > getExcludes ( ) { Set < String > result = new HashSet < String > ( ) ; for ( String exclude : kp . getExcludes ( ) ) { String name = exclude + ".class" ; String renamed = renames . get ( name ) ; result . add ( ( renamed != null ) ? renamed : name ) ; } return result ; }
tr	7	public static int [ ] getAlleleCounts ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; int alleleTotals [ ] = new int [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; if ( v > 0 ) { alleleTotals [ i ] += 1 ; } } i ++ ; } } } return alleleTotals ; }
tr	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
tr	0	public Game ( TurnManager tm ) { this . tm = tm ; seed = ( int ) ( Math . random ( ) * 100 ) ; init ( ) ; }
tr	2	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unset_success ( ) ; } else { set_success ( ( Integer ) value ) ; } break ; } }
tr	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	6	public void run ( ) { isRunning = true ; int frames = 0 ; double frameCounter = 0 ; game . init ( ) ; double lastTime = Time . getTime ( ) ; double unprocessedTime = 0 ; while ( isRunning ) { boolean render = false ; double startTime = Time . getTime ( ) ; double passedTime = startTime - lastTime ; lastTime = startTime ; unprocessedTime += passedTime ; frameCounter += passedTime ; while ( unprocessedTime > frameTime ) { render = true ; unprocessedTime -= frameTime ; if ( Window . isCloseRequested ( ) ) stop ( ) ; game . input ( ( float ) frameTime ) ; Input . update ( ) ; game . update ( ( float ) frameTime ) ; if ( frameCounter >= 1 ) { frames = 0 ; frameCounter = 0 ; } } if ( render ) { game . render ( renderingEngine ) ; Window . render ( ) ; frames ++ ; } else { try { Thread . sleep ( 1 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } cleanup ( ) ; }
tr	6	private void handleIOException ( SelectionKey key , WebSocket conn , IOException ex ) { if ( conn != null ) { conn . closeConnection ( CloseFrame . ABNORMAL_CLOSE , ex . getMessage ( ) ) ; } else if ( key != null ) { SelectableChannel channel = key . channel ( ) ; if ( channel != null && channel . isOpen ( ) ) { try { channel . close ( ) ; } catch ( IOException e ) { } if ( WebSocketImpl . DEBUG ) System . out . println ( "Connection closed because of" + ex ) ; } } }
tr	0	public JButton getButtonClose ( ) { return btnClose ; }
tr	0	@ Parameters ( { "url" , "Jenkins_job" , "sale" } ) @ Test public void Test_case_verification_of_Latin_America_locales ( String url , String Jenkins_job , String sale ) throws InterruptedException { page_locales = new Page_Locales ( ) ; page_css = new Pages_Css ( ) ; test_case_starter ( "verification_of_Latin_America_locales" , "" ) ; Locales_smoke ( url , page_locales . icon_argentina , page_locales . title_page_locales_argentina , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_brazil , page_locales . title_page_locales_brasil , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_chili , page_locales . title_page_locales_chile , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_mexico , page_locales . title_page_locales_mexico , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_other_latin , page_locales . title_page_locales_other_latin , Jenkins_job , sale ) ; test_case_ends ( ) ; }
tr	2	private void tarkistaKirjautuminen ( ) { kayttajatunnus = kayttajatunnusField . getText ( ) ; salasana = ripoffPassword ( salasanaField . getPassword ( ) ) ; Kayttajatunnus kayttaja = Database . tarkastaKirjautuminen ( kayttajatunnus , salasana ) ; if ( kayttaja == null ) { fail ( ) ; } else { if ( kayttaja . getSalasana ( ) . equals ( salasana ) ) { kirjaudu ( kayttaja ) ; } else { fail ( ) ; } } }
tr	5	private boolean verificarMovimiento ( JPanelJuego jPanelJuego ) { if ( entroALaPuerta ) return false ; boolean movimiento = true ; if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ARRIBA ) ) ) { setEstadoActual ( Estado . ARRIBA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . play ( ) ; movimientoArriba ( ) ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ABAJO ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . stop ( ) ; setEstadoActual ( Estado . ABAJO ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . DOWN ) . play ( ) ; movimientoAbajo ( ) ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . UP , Sonidos . DOWN ) ; movimiento = false ; } if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . DERECHA ) ) ) { setEstadoActual ( Estado . DERECHA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . play ( ) ; movimientoDerecha ( ) ; movimiento = true ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . IZQUIERDA ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . stop ( ) ; setEstadoActual ( Estado . IZQUIERDA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . RIGHT ) . play ( ) ; movimientoIzquierda ( ) ; movimiento = true ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . LEFT , Sonidos . RIGHT ) ; } return movimiento ; }
tr	7	public void check_reductions ( ) throws internal_error { parse_action act ; production prod ; for ( int row = 0 ; row < num_states ( ) ; row ++ ) { for ( int col = 0 ; col < under_state [ row ] . size ( ) ; col ++ ) { act = under_state [ row ] . under_term [ col ] ; if ( act != null && act . kind ( ) == parse_action . REDUCE ) { ( ( reduce_action ) act ) . reduce_with ( ) . note_reduction_use ( ) ; } } } for ( Enumeration p = production . all ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; if ( prod . num_reductions ( ) == 0 ) { if ( ! emit . nowarn ) { System . err . println ( "*** Production \"" + prod . to_simple_string ( ) + "\" never reduced" ) ; lexer . warning_count ++ ; } } } }
tr	2	@ Override public int getBucketId ( String dbFilename ) { for ( int i = 0 ; i < filenames . length ; i ++ ) { if ( filenames [ i ] . equals ( dbFilename ) ) { return i ; } } return - 1 ; }
tr	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	0	private int valueRanges ( Situation s ) { return valueSolution ( s , 0 ) ; }
tr	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	1	public static List < Appointment > findByVenue ( long venueId ) throws SQLException { List < Appointment > aAppt = new ArrayList < Appointment > ( ) ; ResultSet resultSet = Data . _find ( Appointment . class . getSimpleName ( ) , "venueId" , String . valueOf ( venueId ) ) ; while ( resultSet . next ( ) ) { aAppt . add ( Appointment . createOneFromResultSet ( resultSet ) ) ; } return aAppt ; }
tr	8	@ Override public boolean isNonRotatableComponentOnBoard ( int x , int y ) { if ( ( y > 1 && y < 12 ) && ( x > 1 && x < 12 ) ) { System . out . println ( "if false. (x y): " + x + " " + y ) ; return false ; } else if ( x < 0 || x > 13 ) { return false ; } else if ( y < 0 || y > 13 ) { return false ; } else { System . out . println ( "(In SelPlaDev) component on board valid" ) ; return true ; } }
tr	8	public void enterElement ( String name , Attributes attrs ) throws Exception { if ( customParser != null ) { customParser . enterElement ( name , attrs ) ; return ; } if ( name . equals ( "Keyring" ) ) { done = false ; return ; } if ( name . equals ( "Protocols" ) ) { return ; } if ( name . equals ( "Protocol" ) ) { String type = attrs . getValue ( "type" ) ; String clName = attrs . getValue ( "class" ) ; try { class < ? > cl = class . forName ( clName ) ; AP_Generic . registerHandler ( type , cl . asSubclass ( AP_Generic . class ) ) ; } catch ( Exception e ) { throw new SAXException ( "Unknown authentication protocol class: " + clName ) ; } return ; } if ( name . equals ( "Identity" ) ) { proto = attrs . getValue ( "proto" ) ; domain = attrs . getValue ( "domain" ) ; AP_Generic parser = AP_Generic . getInstance ( proto ) ; if ( parser == null ) throw new SAXException ( "Unknown authentication protocol: " + proto ) ; parser . initParse ( attrs ) ; customParser = parser ; return ; } }
tr	5	protected void doNext ( ) { doStop ( ) ; runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { selectedIndex ++ ; setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	9X	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece == DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
tr	5	public void PrOkObteHabitacions ( String pob , Date dIni , Date dFi , int numOcup ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( dIni ) ; long dataIni = c . getTimeInMillis ( ) ; c . setTime ( dFi ) ; long dataFi = c . getTimeInMillis ( ) ; if ( ( dataFi < dataIni ) || dataFi - dataIni < 1000 ) { vista . mostraMissatge ( "Dates incorrectes" , 1 ) ; return ; } try { Set < DadesHotel > resultat = domini . buscarHabitacio ( pob , dIni , dFi , numOcup ) ; DadesReserva basicData = new DadesReserva ( ) ; basicData . pob = pob ; basicData . dIni = dIni ; basicData . dFi = dFi ; basicData . numOc = numOcup ; vista . mostraHabitacions ( basicData , resultat ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null && e . getMessage ( ) . equals ( "hotelsNoDisp" ) ) { vista . mostraMissatge ( "No hi ha hotels disponibles en aquesta poblaci\u00F3" , 1 ) ; } else e . printStackTrace ( ) ; } }
tr	7	private void computerNextTurn ( ) { if ( ! getGame ( ) . gameWon ( ) ) { new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( ANIMATION_TIME ) ; } catch ( Exception e ) { } if ( ! getGame ( ) . getPlayer ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS ) . getPlayerType ( ) . equals ( "Human" ) ) { int playerTurn = getGame ( ) . getPlayerTurn ( ) ; int x ; if ( ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_ONE && m_playerOneType == "Computer: Easy" ) || ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_TWO && m_playerTwoType == "Computer: Easy" ) ) { ConnectFourEasyComputerPlayer player = ( ConnectFourEasyComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } else { ConnectFourHardComputerPlayer player = ( ConnectFourHardComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } performMove ( x ) ; getGame ( ) . incrementTurn ( ) ; } } } ) . start ( ) ; } }
tr	8	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	9X	public static void main ( String [ ] args ) { boolean a , b ; System . out . println ( "a\tb\ta and b\ta or b\tnot a\tnot b \n" ) ; a = 3 > 5 ; b = 12 != 8 ; System . out . print ( "(3>5)\t(12!=8)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 5 >= 6 ; b = 3 != 3 ; System . out . print ( "(5>=6)\t(3!=3)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = - 7 == 8 ; System . out . print ( "(-7=8)\t(22)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + " NO SE PUEDE USAR EL 22\n" ) ; a = 21 != 12 ; b = true ; System . out . print ( "21!=12\t(true)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 4 == 2 ; b = 7 >= - 9 ; System . out . print ( "(4==2)\t(7>=-9)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; }
tr	1	public static String SQLdecrypted ( String decrypt ) { String decrypted = "" ; try { SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "DES" ) ; DESKeySpec keySpec = new DESKeySpec ( secretSalt . getBytes ( ) ) ; SecretKey key = keyFactory . generateSecret ( keySpec ) ; DesEncrypter encrypter = new DesEncrypter ( key ) ; decrypted = encrypter . decrypt ( decrypt ) ; } catch ( Exception e ) { Error_Frame . Error ( e . toString ( ) ) ; } return decrypted ; }
tr	0	public byte [ ] getZippedFileBytes ( String path ) throws IOException { byte [ ] uncompressedBytes = getFileBytes ( path ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; GZIPOutputStream zippedStream = new GZIPOutputStream ( output ) ; zippedStream . write ( uncompressedBytes ) ; byte [ ] compressedBytes = new byte [ output . size ( ) ] ; zippedStream . write ( compressedBytes ) ; return compressedBytes ; }
tr	2	public Signals ( int x , int y , int h , String data [ ] ) { this . x = x ; this . y = y ; fontHeight = ( h - 2 ) * 2 / 3 ; newFontHeight = fontHeight ; if ( data != null ) for ( int n = 0 ; n < data . length ; n ++ ) addSignal ( data [ n ] ) ; }
tr	1	void dispatch ( SelectionKey key ) { Runnable r = ( Runnable ) key . attachment ( ) ; if ( r != null ) { r . run ( ) ; } }
tr	6	private int method185 ( int i , int j ) { if ( i == - 2 ) return bc614e ; if ( i == - 1 ) { if ( j < 0 ) j = 0 ; else if ( j > 127 ) j = 127 ; j = 127 - j ; return j ; } j = ( j * ( i & 7f ) ) / 128 ; if ( j < 2 ) j = 2 ; else if ( j > 126 ) j = 126 ; return ( i & ff80 ) + j ; }
tr	6	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
tr	9X	public SourceBlock [ ] partition ( ) { Partition KZ = new Partition ( Kt , Z ) ; int KL = KZ . get ( 1 ) ; int KS = KZ . get ( 2 ) ; int ZL = KZ . get ( 3 ) ; Partition TN = new Partition ( T / ALIGN_PARAM , N ) ; int TL = TN . get ( 1 ) ; int TS = TN . get ( 2 ) ; int NL = TN . get ( 3 ) ; SourceBlock [ ] object = new SourceBlock [ Z ] ; int i ; int index_master = 0 ; for ( i = 0 ; i < ZL ; i ++ ) { byte [ ] symbols = new byte [ KL * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KL ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KL * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KL * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KL ) ; index_master += ( KL * T ) ; } for ( ; i < Z ; i ++ ) { byte [ ] symbols = new byte [ KS * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KS ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KS * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KS * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KS ) ; index_master += ( KS * T ) ; } return object ; }
tr	8	public String execute ( DeleteCalendarObject deleteCalendarObject ) throws SQLException { String answer = "" ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "CalendarName" , "=" , deleteCalendarObject . getCalendarToDelete ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; String calendarID = resultSet . getString ( "calendarID" ) ; resultSet = queryBuilder . selectFrom ( "Users" ) . where ( "UserName" , "=" , deleteCalendarObject . getuserID ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; int userID = resultSet . getInt ( "userID" ) ; boolean author = false ; boolean imported = true ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "calendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; if ( resultSet . next ( ) ) { if ( resultSet . getInt ( "imported" ) == 0 ) { imported = false ; } } if ( imported == false ) { resultSet = queryBuilder . selectFrom ( "AutherRights" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { if ( resultSet . getInt ( "userID" ) == userID ) { author = true ; } } if ( author ) { resultSet = queryBuilder . selectFrom ( "Events" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { String eventID = resultSet . getString ( "eventID" ) ; try { queryBuilder . deleteFrom ( "Notes" ) . where ( "eventID" , "=" , eventID ) ; } catch ( Exception e ) { System . err . print ( e . getStackTrace ( ) ) ; } } queryBuilder . deleteFrom ( dbConfig . getEvents ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "subscription" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "autherrights" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( dbConfig . getCalendar ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; answer = String . format ( "Calendar " + deleteCalendarObject . getCalendarToDelete ( ) + " has been deleted  along with all associated events and notes." ) ; } else { answer = "You do not have the rights to delete this calendar." ; } } else { answer = "This is an imported calendar and cannot be deleted." ; } return answer ; }
tr	3	public void method386 ( int i , String s , int j , int k , int l ) { if ( s == null ) return ; j -= getStringWidth ( s ) / 2 ; l -= charHeight ; for ( int i1 = 0 ; i1 < s . length ( ) ; i1 ++ ) { char c = s . charAt ( i1 ) ; if ( c !=   ) method392 ( aByteArrayArray1491 [ c ] , j + anIntArray1494 [ c ] , l + anIntArray1495 [ c ] + ( int ) ( Math . sin ( ( double ) i1 / 2D + ( double ) k / 5D ) * 5D ) , anIntArray1492 [ c ] , anIntArray1493 [ c ] , i ) ; j += anIntArray1496 [ c ] ; } }
tr	5	static public void LU_ver ( double a [ ] [ ] ) { int n = a . length ; int i , j , k ; double suma ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i - 1 ; j ++ ) { ver ( i , j , 0 ) ; System . out . print ( "(" ) ; ver ( i , j , 1 ) ; suma = 0 ; for ( k = 0 ; k <= j - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = ( a [ i ] [ j ] - suma ) / a [ j ] [ j ] ; ver ( j , j , 4 ) ; System . out . println ( ) ; } for ( j = i ; j < n ; j ++ ) { suma = 0 ; ver ( i , j , 0 ) ; ver ( i , j , 1 ) ; for ( k = 0 ; k <= i - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = a [ i ] [ j ] - suma ; System . out . println ( ) ; } } }
tr	8	@ Override public Object cresciDinosauro ( String token , String idDinosauro ) { try { if ( myLogica . isMioTurno ( token ) ) { if ( myLogica . doCresciDinosauro ( token , idDinosauro ) ) { return "@ok" ; } return "@no @idNonValido" ; } else return "@no @nonIlTuoTurno" ; } catch ( InvalidTokenException e ) { return returnInvalidToken ( ) ; } catch ( NonInPartitaException e ) { return "@no @nonInPartita" ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) return "@no @mortePerInedia" ; if ( e . getMessage ( ) . equals ( "raggiuntaDimensioneMax" ) ) return "@no @raggiuntaDimensioneMax" ; if ( e . getMessage ( ) . equals ( "raggiuntoLimiteMosseDinosauro" ) ) return "@no @raggiuntoLimiteMosseDinosauro" ; } return "@no" ; }
tr	1	private int getNextIndicator ( ) throws IOException { if ( this . indicator == 0 ) { this . indicator = in . read ( ) ; } return this . indicator ; }
tr	5	Message writeFailureResponse ( String reason ) { String xmlString ; if ( myDLE == null ) { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myEventId + "' type='closed' behavior='roundRobin' question='question' " + "numChoices='0' numRounds='1' position='0'/></response>" ; } else { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myDLE . getUniqueId ( ) + "' " ; if ( myDLE . getEventType ( ) == EventType . CLOSED || myDLE . getEventType ( ) == EventType . FINISHED ) xmlString = xmlString + "type='closed' " ; else xmlString = xmlString + "type='open' " ; if ( myDLE . getBehavior ( ) == Behavior . ROUNDROBIN ) xmlString = xmlString + "behavior='roundRobin' " ; else xmlString = xmlString + "behavior='asynchronous' " ; xmlString = xmlString + "question='" + myDLE . getQuestion ( ) + "' " + " numChoices='" + myDLE . getNumberOfChoices ( ) + "' numRounds='" + myDLE . getNumberOfEdges ( ) + "' " + "position='" + newUser . getPosition ( ) + "'>" ; for ( int i = 0 ; i < myDLE . getChoices ( ) . size ( ) ; i ++ ) { Choice tmpChoice = myDLE . getChoices ( ) . get ( i ) ; xmlString = xmlString + "<choice value='" + tmpChoice . getName ( ) + "' index='" + tmpChoice . getOrder ( ) + "'/>" ; } xmlString = xmlString + "</signInResponse></response>" ; } System . out . println ( "Error Response: " + xmlString ) ; return new Message ( xmlString ) ; }
tr	7	public void run ( ) { parser = new CommandParser ( true ) ; parser . setCommandList ( new ApplicationCommandList ( ) ) ; System . out . println ( "WELCOME" ) ; System . out . println ( "READY for Input!" ) ; reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String input ; try { while ( ( input = reader . readLine ( ) ) != null ) { if ( input . equals ( "!end" ) ) { break ; } else { if ( input . length ( ) > 0 ) { String query = parser . parse ( input . trim ( ) ) ; if ( query . length ( ) > 1 ) { parser . parse ( query ) ; } } else System . out . println ( "" ) ; } } } catch ( IOException e ) { logger . error ( "reading input lines failed" ) ; } finally { System . out . println ( "BYE" ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { logger . error ( "could not close reader" ) ; } } } }
tr	2	public int min_number_of_frames ( int streamsize ) { if ( h_vbr == true ) return h_vbr_frames ; else { if ( ( framesize + 5 - h_padding_bit ) == 0 ) return 0 ; else return ( streamsize / ( framesize + 5 - h_padding_bit ) ) ; } }
tr	4	private boolean r_e_ending ( ) { int v_1 ; B_e_found = false ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "e" ) ) ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } v_1 = limit - cursor ; if ( ! ( out_grouping_b ( g_v , 97 , 232 ) ) ) { return false ; } cursor = limit - v_1 ; slice_del ( ) ; B_e_found = true ; if ( ! r_undouble ( ) ) { return false ; } return true ; }
tr	3	public void removeConnectionFromChans ( Connection connection ) { List < Chan > emptyChans = new ArrayList < Chan > ( ) ; for ( Chan chan : chans . values ( ) ) { chan . getConnections ( ) . remove ( connection ) ; if ( chan . getConnections ( ) . size ( ) == 0 ) { emptyChans . add ( chan ) ; } } for ( Chan rmChan : emptyChans ) { chans . remove ( rmChan ) ; } }
tr	7	private Object difference ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == null || subtree1 == subtree2 ) return null ; else if ( subtree2 == null ) return split ( subtree1 , lo , hi ) ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) return difference ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else { Node n2 = ( Node ) subtree2 ; Object elt2 = n2 . element ; Object elt1 = findEquiv ( subtree1 , elt2 ) ; Object new_left = difference ( trim ( subtree1 , lo , elt2 ) , trim ( n2 . left , lo , elt2 ) , lo , elt2 ) ; Object new_right = difference ( trim ( subtree1 , elt2 , hi ) , trim ( n2 . right , elt2 , hi ) , elt2 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } } else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; Object elt2 = findEquiv ( subtree2 , elt1 ) ; Object new_left = difference ( n1 . left , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) ; Object new_right = difference ( n1 . right , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } }
tr	5	private void initiateMalesAndFemales ( Habitat habitat ) { numberOfLonelyFemales = 0 ; males . clear ( ) ; lonelyFemales . clear ( ) ; for ( IndividualsGroupState group : habitat . getGroupsStates ( ) . values ( ) ) { if ( group . isMatureMale ( ) && group . strength > 0 ) males . add ( group ) ; else if ( group . isMatureFemale ( ) && group . getNotMultipliedst ( ) > 0 ) { lonelyFemales . add ( group ) ; numberOfLonelyFemales += group . getNotMultipliedst ( ) ; } } }
tr	0	public void setI ( float i ) { this . i = i ; }
tr	1	public void printRes ( ) { for ( int i = 0 ; i < n ; i ++ ) { Vertex v = res . get ( i ) ; System . out . println ( v . vertex + " : " + v . timestamp1 + " / " + v . timestamp2 ) ; } }
tr	6	private void initButtons ( ) { buttons = new JPanel ( ) ; buttons . setMinimumSize ( new Dimension ( 70 , 75 + design . getHeight ( ) ) ) ; buttons . setBackground ( Color . black ) ; noTerrain = new JButton ( ) ; noTerrain . setText ( "Canyon" ) ; noTerrain . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; noTerrain . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; noTerrain . setForeground ( Color . LIGHT_GRAY ) ; noTerrain . setBackground ( Color . black ) ; noTerrain . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; noTerrain . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = - 1 ; } } ) ; terrain0 = new JButton ( ) ; terrain0 . setText ( "Road" ) ; terrain0 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain0 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain0 . setForeground ( Color . BLACK ) ; terrain0 . setBackground ( Color . LIGHT_GRAY ) ; terrain0 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain0 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 0 ; unitButtons . deselect ( ) ; } } ) ; terrain1 = new JButton ( ) ; terrain1 . setText ( "Grass" ) ; terrain1 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain1 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain1 . setForeground ( Color . BLACK ) ; terrain1 . setBackground ( new Color ( 100 , 150 , 0 ) ) ; terrain1 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 1 ; unitButtons . deselect ( ) ; } } ) ; terrain2 = new JButton ( ) ; terrain2 . setText ( "Hills" ) ; terrain2 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain2 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain2 . setForeground ( Color . BLACK ) ; terrain2 . setBackground ( new Color ( 100 , 100 , 0 ) ) ; terrain2 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 2 ; unitButtons . deselect ( ) ; } } ) ; terrain3 = new JButton ( ) ; terrain3 . setText ( "Forest" ) ; terrain3 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain3 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain3 . setForeground ( Color . BLACK ) ; terrain3 . setBackground ( new Color ( 0 , 125 , 0 ) ) ; terrain3 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain3 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 3 ; unitButtons . deselect ( ) ; } } ) ; terrain4 = new JButton ( ) ; terrain4 . setText ( "Mountain" ) ; terrain4 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain4 . setFont ( new Font ( "Consolas" , 0 , 8 ) ) ; terrain4 . setForeground ( Color . lightGray ) ; terrain4 . setBackground ( new Color ( 0 , 65 , 0 ) ) ; terrain4 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain4 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 4 ; unitButtons . deselect ( ) ; } } ) ; blueBase = new JButton ( ) ; blueBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "BlueBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; blueBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; blueBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; blueBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 5 ; unitButtons . deselect ( ) ; } } ) ; redBase = new JButton ( ) ; redBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "RedBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; redBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; redBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; redBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 6 ; unitButtons . deselect ( ) ; } } ) ; factory = new JButton ( ) ; factory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; factory . setBackground ( Color . LIGHT_GRAY ) ; factory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; factory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; factory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 7 ; unitButtons . deselect ( ) ; } } ) ; teamFactory = new JButton ( ) ; teamFactory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; teamFactory . setBackground ( Color . BLUE ) ; teamFactory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; teamFactory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; teamFactory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = team ? 8 : 9 ; unitButtons . deselect ( ) ; } } ) ; blueTeam = new JRadioButton ( ) ; blueTeam . setText ( "Blue" ) ; blueTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; blueTeam . setBackground ( Color . BLACK ) ; blueTeam . setForeground ( Color . LIGHT_GRAY ) ; blueTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = true ; unitButtons . changeTeam ( true ) ; teamFactory . setBackground ( Color . BLUE ) ; redTeam . setSelected ( false ) ; } } ) ; redTeam = new JRadioButton ( ) ; redTeam . setText ( "Red" ) ; redTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; redTeam . setBackground ( Color . BLACK ) ; redTeam . setForeground ( Color . LIGHT_GRAY ) ; redTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = false ; unitButtons . changeTeam ( false ) ; teamFactory . setBackground ( Color . red ) ; blueTeam . setSelected ( false ) ; } } ) ; unitButtons = new UnitButtonsPanel ( ) ; unitButtons . setMaximumSize ( new Dimension ( 100 , 0 ) ) ; save = new JButton ( ) ; save . setText ( "Save" ) ; save . setBackground ( Color . BLACK ) ; save . setForeground ( Color . LIGHT_GRAY ) ; save . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { if ( LocationManager . getBase ( true ) == null || LocationManager . getBase ( false ) == null ) { JOptionPane . showMessageDialog ( design , "Base Missing" ) ; return ; } String mapName = JOptionPane . showInputDialog ( "Map Name?" ) ; if ( mapName == null || mapName . equals ( "" ) ) { JOptionPane . showMessageDialog ( design , "Invalid Name" ) ; return ; } try { LocationManager . saveMap ( mapName ) ; JOptionPane . showMessageDialog ( design , "Map " + mapName + " saved." ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( design , "Error occurred: " + e . toString ( ) ) ; } } } ) ; random = new JButton ( ) ; random = new JButton ( ) ; random . setText ( "Random" ) ; random . setBackground ( Color . BLACK ) ; random . setForeground ( Color . LIGHT_GRAY ) ; random . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; random . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { LocationManager . generateMap ( LocationManager . getSize ( ) . x , LocationManager . getSize ( ) . y ) ; render ( ) ; } } ) ; }
tr	2	public void printInfo ( ) { System . out . println ( "Arithmos Xeirourgiwn :" + NumberOrSyrgeries ) ; for ( int i = 0 ; i <= tepRooms . size ( ) ; i ++ ) System . out . println ( "Dwmatio :" + tepRooms . get ( i ) ) ; for ( int i = 0 ; i <= tepSurgeries . size ( ) ; i ++ ) System . out . println ( "Xeirourgio :" + tepSurgeries . get ( i ) ) ; }
tr	5	public boolean commit ( Connection conn ) throws SQLException { boolean status = true ; try { conn . setAutoCommit ( false ) ; BookingMapper bm = new BookingMapper ( ) ; status = status && bm . addNewBooking ( newBooking , conn ) ; status = status && bm . updateBooking ( modifiedBooking , conn ) ; status = status && bm . deleteBooking ( deleteBooking , conn ) ; if ( ! status ) { throw new Exception ( "Business Transaction aborted" ) ; } conn . commit ( ) ; } catch ( Exception e ) { System . out . println ( "fail in UnitOfWork - commit()" ) ; System . err . println ( e ) ; conn . rollback ( ) ; status = false ; } return status ; }
tr	9X	public void saveTraining ( String fileDict , String fileNgrams , String fileDMC , String fileHMM , String fileVLMC , boolean clear ) { if ( fileDict != null ) { trainDict ( ) ; dict . save ( fileDict ) ; if ( clear ) { dict = null ; dictTrained = false ; } } if ( fileNgrams != null ) { trainNgram ( ) ; ngrams . save ( fileNgrams ) ; if ( clear ) { ngrams = null ; ngramTrained = false ; } } if ( fileDMC != null ) { trainDMC ( ) ; dmc . save ( fileDMC ) ; if ( clear ) { dmc = null ; ngramTrained = false ; } } if ( fileHMM != null ) { trainHMM ( ) ; hmm . save ( fileHMM ) ; if ( clear ) { hmm = null ; hmmTrained = false ; } trainHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".end" ) ; trainCleanHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".clean.end" ) ; trainReestimatedHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".reestimated.end" ) ; } if ( fileVLMC != null ) { trainVLMC ( ) ; vlmc . save ( fileVLMC ) ; if ( clear ) { vlmc = null ; vlmcTrained = false ; } } }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	7	public FeatureVector createLabeledArcFeatures ( DependencyInstance inst , int h , int c , int type ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numLabeledArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; } } return fv ; }
tr	8	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
tr	3	private void checkHighlight ( ) { Set < Integer > activeSet = myNextTurtleList . getActiveIDs ( ) ; DecoratedTurtleDrawer highlight = new HighlightActiveTurtleDrawer ( ) ; for ( int i = 0 ; i < myNextTurtleList . size ( ) ; i ++ ) { myTurtleDrawers . set ( i , myTurtleDrawers . get ( i ) . removeReference ( highlight ) ) ; if ( activeSet . contains ( i ) && isHighlighted ) { toggleDecorator ( highlight , i ) ; } } }
tr	1	private int getMaxLen ( ) throws ValidationException { String text = this . maxLenTextField . getText ( ) ; try { int M = Integer . parseInt ( text ) ; return M ; } catch ( Exception e ) { String message = "The maximum length is not an integer number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } }
tr	0	@ Override public float getX ( ) { return this . pos . x ; }
tr	1	public String getString ( String name ) { if ( ! tags . containsKey ( name ) ) return "" ; return ( ( StringTag ) tags . get ( name ) ) . data ; }
tr	5	public static Set < Cliente > getClientesPedidosColores ( Set < Color > colores ) { Set < Cliente > l = new HashSet < > ( ) ; try { sql = "SELECT DISTINCT (CLIENTES_REMITOS.IDCLIENTE) AS IDCLIENTE " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND ( " ; String tmp = "" ; for ( Color color : colores ) { tmp = tmp + Integer . toString ( color . getId ( ) ) + "  " ; } tmp = tmp . substring ( 0 , tmp . length ( ) - 2 ) ; sql = sql + " CLIENTES_DETALLE_REMITO.COLOR IN (" + tmp + ")" ; sql = sql + "));" ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null ) { while ( rs . next ( ) ) { Cliente cliente = ClienteDP . getOne ( rs . getInt ( "IDCLIENTE" ) ) ; if ( cliente != null ) { l . add ( cliente ) ; } } } } } catch ( SQLException ex ) { Utils . showError ( "Error..." , "Error al buscar clientes con pedidos por colores.\nERROR: " + ex . getMessage ( ) + "\nSQL State: " + ex . getSQLState ( ) ) ; } return l ; }
tr	7	@ Override public boolean onResponse ( Message message ) { int hour = Calendar . getInstance ( ) . get ( Calendar . HOUR_OF_DAY ) ; if ( hour <= 9 ) { for ( String word : moringWords ) { if ( message . content . contains ( word ) ) { message . reply ( moringResponseWord [ new Random ( ) . nextInt ( moringResponseWord . length ) ] ) ; return true ; } } } else if ( hour >= 21 || hour < 3 ) { for ( String word : nigthWords ) { if ( message . content . contains ( word ) ) { message . reply ( nigthResponseWords [ new Random ( ) . nextInt ( nigthResponseWords . length ) ] ) ; return true ; } } } return false ; }
tr	7	public FeatureVector createCC2FeatureVector ( DependencyInstance inst , int arg , int head , int child ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int [ ] [ ] feats = inst . featids ; int CP = pos [ arg ] ; int CW = word [ arg ] ; int HC = posA [ head ] ; int HL = lemma [ head ] ; int AC = posA [ child ] ; int AL = lemma [ child ] ; long code = 0 ; code = createArcCodePPP ( CC_CP_HC_AC , CP , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( CC_CP_HL_AL , HL , AL , CP ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_HC_AC , CW , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , pos [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , posA [ head ] , posA [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( HW_MP , lemma [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( MW_HP , lemma [ child ] , pos [ head ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( HW_MW , lemma [ head ] , lemma [ child ] ) ; addArcFeature ( code , fv ) ; if ( feats [ head ] != null && feats [ child ] != null ) { for ( int fh = 0 ; fh < feats [ head ] . length ; ++ fh ) { if ( feats [ head ] [ fh ] <= 0 ) continue ; for ( int fc = 0 ; fc < feats [ child ] . length ; ++ fc ) { if ( feats [ child ] [ fc ] <= 0 ) continue ; int IDH = feats [ head ] [ fh ] ; int IDM = feats [ child ] [ fc ] ; code = createArcCodePP ( HP_MP , IDH , IDM ) ; addArcFeature ( code , fv ) ; } } } return fv ; }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	6	public AudioDevice createAudioDevice ( ) throws JavaLayerException { AudioDevice device = null ; AudioDeviceFactory [ ] factories = getFactoriesPriority ( ) ; if ( factories == null ) throw new JavaLayerException ( this + ": no factories registered" ) ; JavaLayerException lastEx = null ; for ( int i = 0 ; ( device == null ) && ( i < factories . length ) ; i ++ ) { try { device = factories [ i ] . createAudioDevice ( ) ; } catch ( JavaLayerException ex ) { lastEx = ex ; } } if ( device == null && lastEx != null ) { throw new JavaLayerException ( "Cannot create AudioDevice" , lastEx ) ; } return device ; }
tr	8	private void updateFacingDirection ( Entity entity ) { if ( entity . tickEnd == tick || entity . animation == - 1 || entity . animationDelay != 0 || entity . currentAnimationDuration + 1 > AnimationSequence . animations [ entity . animation ] . getFrameLength ( entity . currentAnimationFrame ) ) { int duration = entity . tickEnd - entity . tickStart ; int timePassed = tick - entity . tickStart ; int differenceStartX = entity . startX * 128 + entity . boundaryDimension * 64 ; int differenceStartY = entity . startY * 128 + entity . boundaryDimension * 64 ; int differenceEndX = entity . endX * 128 + entity . boundaryDimension * 64 ; int differenceEndY = entity . endY * 128 + entity . boundaryDimension * 64 ; entity . x = ( differenceStartX * ( duration - timePassed ) + differenceEndX * timePassed ) / duration ; entity . y = ( differenceStartY * ( duration - timePassed ) + differenceEndY * timePassed ) / duration ; } entity . stepsDelayed = 0 ; if ( entity . direction == 0 ) entity . turnDirection = 1024 ; if ( entity . direction == 1 ) entity . turnDirection = 1536 ; if ( entity . direction == 2 ) entity . turnDirection = 0 ; if ( entity . direction == 3 ) entity . turnDirection = 512 ; entity . currentRotation = entity . turnDirection ; }
tr	2	static List < VcsCommit > parseCommits ( String xml ) { try { CommitReadingHandler commitReadingHandler = new CommitReadingHandler ( ) ; SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; XMLReader xmlReader = parserFactory . newSAXParser ( ) . getXMLReader ( ) ; xmlReader . setContentHandler ( commitReadingHandler ) ; xmlReader . parse ( new InputSource ( new StringReader ( xml ) ) ) ; return commitReadingHandler . commits ; } catch ( SAXException e ) { throw new RuntimeException ( "Failed to parse xml: " + xml , e ) ; } catch ( ParserConfigurationException | IOException e ) { throw new RuntimeException ( e ) ; } }
tr	7	protected final short get_action ( int state , int sym ) { short tag ; int first , last , probe ; short [ ] row = action_tab [ state ] ; if ( row . length < 20 ) for ( probe = 0 ; probe < row . length ; probe ++ ) { tag = row [ probe ++ ] ; if ( tag == sym || tag == - 1 ) { return row [ probe ] ; } } else { first = 0 ; last = ( row . length - 1 ) / 2 - 1 ; while ( first <= last ) { probe = ( first + last ) / 2 ; if ( sym == row [ probe * 2 ] ) return row [ probe * 2 + 1 ] ; else if ( sym > row [ probe * 2 ] ) first = probe + 1 ; else last = probe - 1 ; } return row [ row . length - 1 ] ; } return 0 ; }
tr	2	@ Override public void paintAfter ( Graphics g ) { if ( foundPoint != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawPoint ( g , foundPoint . point ) ; } if ( foundSegment != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawSegment ( g , foundSegment . segment ) ; } super . paintAfter ( g ) ; }
tr	2	public boolean intersects ( AABB aabb ) { final Vector3f h1 = getHalfsize ( ) ; final Vector3f h2 = aabb . getHalfsize ( ) ; final Vector3f p1 = getPosition ( ) ; final Vector3f p2 = aabb . getPosition ( ) ; return Math . abs ( p2 . x - p1 . x ) < h2 . x + h1 . x && Math . abs ( p2 . y - p1 . y ) < h2 . y + h1 . y && Math . abs ( p2 . z - p1 . z ) < h2 . z + h1 . z ; }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	0	@ Override public String toString ( ) { return getName ( ) + "=" + getValue ( ) ; }
tr	7	public Dimension preferredLayoutSize ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { if ( lastParentSize == null || ! parent . getSize ( ) . equals ( lastParentSize ) ) { for ( ComponentWrapper wrapper : ccMap . keySet ( ) ) { Component c = ( Component ) wrapper . getComponent ( ) ; if ( c instanceof JTextArea || c instanceof JEditorPane || ( c instanceof JComponent && boolean . true . equals ( ( ( JComponent ) c ) . getClientProperty ( "migLayout.dynamicAspectRatio" ) ) ) ) { layoutContainer ( parent ) ; break ; } } } lastParentSize = parent . getSize ( ) ; return getSizeImpl ( parent , LayoutUtil . PREF ) ; } }
tr	6	public Map < String , String > readAdjNounSent ( ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "unsupervisedClauseMarkup.readAdjNounSent" ) ; if ( this . myDataHolder == null ) { return null ; } Map < String , String > myAdjNounSent = new HashMap < String , String > ( ) ; Iterator < SentenceStructure > iter = this . myDataHolder . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String modifier = sentenceObject . getModifier ( ) ; String tag = sentenceObject . getTag ( ) ; myLogger . trace ( "tag: " + tag ) ; if ( ( modifier != null ) && ( tag != null ) ) { if ( ( ! ( modifier . equals ( "" ) ) ) && ( tag . matches ( "^\\[.*$" ) ) ) { modifier = modifier . replaceAll ( "\\[.*?\\]" , "" ) . trim ( ) ; myAdjNounSent . put ( tag , modifier ) ; } } } return myAdjNounSent ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Song ) ) return false ; Song song = ( Song ) o ; if ( ! artistId . equals ( song . artistId ) ) return false ; if ( ! id . equals ( song . id ) ) return false ; if ( ! lyrics . equals ( song . lyrics ) ) return false ; if ( ! title . equals ( song . title ) ) return false ; return true ; }
tr	8	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
tr	1	public ASTNode reduce ( ASTNode term , final IExpressionContext context ) { if ( term instanceof BooleanExpression ) { final BooleanExpression expr = ( BooleanExpression ) term ; ASTNode left = internalReduce ( expr . getLHS ( ) , context ) ; ASTNode right = internalReduce ( expr . getRHS ( ) , context ) ; return new BooleanExpression ( left , right ) ; } return internalReduce ( term , context ) ; }
tr	2	private Activity getActivity ( String edgeType ) throws ProvBuildException { if ( _current == null || ! ( _current instanceof Activity ) ) { throw new ProvBuildException ( edgeType + " only applies to activities" ) ; } return ( Activity ) _current ; }
tr	3	< C > NodeFactory < C > getSimpleNodeBuilder ( final String namespace , class < C > dummy ) { final NodeFactory < C > factory = new ReflectNodeFactory < > ( new AutoQualifiedClassLoader ( namespace , _classLoader ) ) ; return new SimpleNodeFactory < C > ( ) { public Predicate < C > newPredicate ( String type , String attr ) { if ( factory . newPredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newPredicate ( type , attr ) ; } @ Override public Action < C > newAction ( String type , String attr ) { if ( factory . newAction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newAction ( type , attr ) ; } private void ok ( String name ) { if ( VERBOSE ) System . out . printf ( "Class '%s' loaded\n" , name ) ; } private void error ( String name ) { System . err . printf ( "Class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
tr	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
tr	1	class < ? > [ ] groups ( ) default { } ;
tr	4	public static KeyAction [ ] compile ( String s ) { final List < KeyAction > actions = new ArrayList < KeyAction > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charAt ( i ) ; if ( c == K && s . substring ( i ) . startsWith ( "KeyEvent.VK_" ) ) try { final int k = s . indexOf ( . , i + "KeyEvent.VK_" . length ( ) ) ; final String vk = s . substring ( i + "KeyEvent." . length ( ) , k ) ; final int code = KeyEvent . class . getField ( vk ) . getInt ( null ) ; i = k + 1 ; actions . add ( new KeyAction ( code , Type . valueOf ( s . charAt ( i ) ) ) ) ; } catch ( Exception e ) { throw new RuntimeException ( "Compilation error: s=" + s + "  i=" + i + "  c=" + c , e ) ; } else compile ( c , actions ) ; } return actions . toArray ( new KeyAction [ actions . size ( ) ] ) ; }
tr	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
tr	7	protected synchronized void update ( ) { Date now = new Date ( ) ; long delta = now . getTime ( ) - lastUpdate . getTime ( ) ; if ( isDead ( ) ) return ; Point oldPos = new Point ( x , y ) ; Point dir = new Point ( speed . getDirectionX ( ) , speed . getDirectionY ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updatePosX ( delta ) ; if ( dir . y != 0 ) blocked |= ! updatePosY ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldPos . equals ( this ) ) lastUpdate = now ; }
tr	8	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == left ) { halign = Alignment . LEFT ; return ; } if ( e . getSource ( ) == center ) { halign = Alignment . CENTER ; return ; } if ( e . getSource ( ) == right ) { halign = Alignment . RIGHT ; return ; } if ( e . getSource ( ) == top ) { valign = Alignment . TOP ; return ; } if ( e . getSource ( ) == middle ) { valign = Alignment . MIDDLE ; return ; } if ( e . getSource ( ) == bottom ) { valign = Alignment . BOTTOM ; return ; } if ( e . getSource ( ) == fButton ) { Font newFont = FontDialog . getFont ( font ) ; if ( newFont == null ) return ; font = newFont ; fButton . setFont ( font ) ; } }
tr	9X	public void InitializeGameWorld ( int numEnemyTanks , int numRocks , int numTrees ) { listObjects = new LinkedList < GameObject > ( ) ; tanks = new LinkedList < Tank > ( ) ; landscape = new LinkedList < LandscapeGameObject > ( ) ; projectiles = new LinkedList < Projectile > ( ) ; playerTank = getRandomPlayerTank ( 0 ) ; for ( int i = 0 ; i < numEnemyTanks ; i ++ ) { Tank tank = getRandomTank ( ) ; while ( collidesWithWorld ( tank ) ) { if ( Game . debug ) { System . out . println ( "tank placement collision" ) ; } tank = getRandomTank ( ) ; } addTank ( tank ) ; } for ( int j = 0 ; j < numRocks ; j ++ ) { Rock rock = getRandomRock ( j ) ; while ( collidesWithWorld ( rock ) ) { if ( Game . debug ) { System . out . println ( "rock placement collision" ) ; } rock = getRandomRock ( j ) ; } addLandscapeObject ( rock ) ; } for ( int k = 0 ; k < numTrees ; k ++ ) { Tree tree = getRandomTree ( k ) ; while ( collidesWithWorld ( tree ) ) { if ( Game . debug ) { System . out . println ( "tree placement collision" ) ; } tree = getRandomTree ( k ) ; } addLandscapeObject ( tree ) ; } addTank ( playerTank ) ; lives = startingLives ; score = 0 ; gameClock = 0 ; gameOver = false ; TotaltankCount = 0 ; notifyObservers ( ) ; }
tr	7	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	2	public synchronized void produce ( ) { try { if ( product != 0 ) { wait ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } product = 1 ; System . out . println ( "Producer produce : " + product ) ; notifyAll ( ) ; }
tr	8	public Policy getPolicy ( CommandLine cmd ) { Policy policy = null ; if ( cmd . hasOption ( "checkIn" ) || cmd . hasOption ( "checkOut" ) || cmd . hasOption ( "alchohol" ) || cmd . hasOption ( "smoke" ) || cmd . hasOption ( "cancellation_deadline" ) || cmd . hasOption ( "cancellation_penalty" ) ) { policy = new Policy ( ) ; policy . setCheckInTime ( cmd . getOptionValue ( "checkIn" ) ) ; policy . setCheckOutTime ( cmd . getOptionValue ( "checkOut" ) ) ; policy . setAlcoholPolicy ( cmd . getOptionValue ( "alchohol" ) ) ; policy . setSmokingPolicy ( cmd . getOptionValue ( "smoke" ) ) ; if ( cmd . hasOption ( "cancellation_deadline" ) ) { policy . setCancellationDeadLine ( Integer . parseInt ( cmd . getOptionValue ( "cancellation_deadline" ) ) ) ; } if ( cmd . hasOption ( "cancellation_penalty" ) ) { policy . setCancellationPenalty ( Integer . parseInt ( cmd . getOptionValue ( "cancellation_penalty" ) ) ) ; } } return policy ; }
tr	7	public static void main ( String [ ] args ) { BigInteger totalSum = BigInteger . ZERO ; for ( int i = 2 ; i <= 4 ; i ++ ) { BigInteger [ ] [ ] arrangements = new BigInteger [ 51 ] [ 50 ] ; for ( int j = 0 ; j <= 50 ; j ++ ) for ( int k = 0 ; k < 50 ; k ++ ) arrangements [ j ] [ k ] = BigInteger . ZERO ; arrangements [ 1 ] [ 0 ] = BigInteger . ONE ; for ( int j = 1 ; j < 50 ; j ++ ) { for ( int k = 1 ; k <= 50 ; k ++ ) arrangements [ k ] [ j ] = arrangements [ k - 1 ] [ j - 1 ] ; for ( int k = i ; k <= 50 ; k ++ ) arrangements [ 0 ] [ j ] = arrangements [ 0 ] [ j ] . add ( arrangements [ k ] [ j ] ) ; } for ( int j = 0 ; j < 50 ; j ++ ) totalSum = totalSum . add ( arrangements [ j ] [ 49 ] ) ; } System . out . println ( totalSum ) ; }
tr	4	@ Override public void run ( ) { try { String hostname = NetBase . theNetBase ( ) . hostname ( ) ; if ( hostname != null ) { if ( hostname . isEmpty ( ) ) System . out . println ( "Host: root" ) ; else System . out . println ( "Host: '" + hostname + "'" ) ; } else System . out . println ( "Host: none" ) ; RPCService rpcService = ( RPCService ) NetBase . theNetBase ( ) . getService ( "rpc" ) ; if ( rpcService != null ) System . out . println ( "IP: " + IPFinder . localIP ( ) + "  Port: " + rpcService . localPort ( ) ) ; else System . out . println ( "No RPC service is running on this node." ) ; } catch ( Exception e ) { System . out . println ( "Caught exception: " + e . getMessage ( ) ) ; } }
tr	4	public static String nullSafeToString ( long [ ] array ) { if ( array == null ) { return NULL_STRING ; } int length = array . length ; if ( length == 0 ) { return EMPTY_ARRAY ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == 0 ) { sb . append ( ARRAY_START ) ; } else { sb . append ( ARRAY_ELEMENT_SEPARATOR ) ; } sb . append ( array [ i ] ) ; } sb . append ( ARRAY_END ) ; return sb . toString ( ) ; }
tr	5	static void updatestatus ( int m ) { switch ( m ) { case 1 : status . setText ( "Drag to create an entity" ) ; break ; case 2 : status . setText ( "Drag to create an bubble" ) ; break ; case 3 : status . setText ( "Drag to create an data store" ) ; break ; case 4 : status . setText ( "Drag to create an data flow arrow" ) ; break ; case 6 : status . setText ( "Drag to create an control flow arrow" ) ; break ; default : status . setText ( "" ) ; } }
tr	4	private String makeBetween ( LangFileElement lfe ) { if ( lfe . isNewElement ( ) ) { switch ( betweenType ) { case BETWEEN_ALIGNEMENT : int len = lfe . getPrefix ( ) . length ( ) + 9 + lfe . getLine ( ) . length ( ) ; String between = " " ; for ( int i = len ; i < betweenPadding ; i ++ ) { between += " " ; } return between ; case BETWEEN_STRING : default : return betweenString ; } } else { return lfe . getBetween ( ) ; } }
tr	9X	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
tr	9X	@ Override public boolean equals ( Object obj ) { boolean result = false ; if ( this == obj ) { result = true ; } else if ( obj != null && obj instanceof Contributor ) { Contributor other = ( Contributor ) obj ; if ( ( this . domain == null && this . domain == other . domain ) || ( this . domain != null && this . domain . equals ( other . domain ) ) ) { if ( ( this . name == null && this . name == other . name ) || ( this . name != null && this . name . equals ( other . name ) ) ) { result = true ; } } } return result ; }
tr	0	public ShareItem ( ) { }
tr	2	public OutcomingDocument createOutcomingDocument ( IncomingDocument initiatingDocument ) { if ( getEnvironment ( ) != null ) { if ( getDepartment ( ) != null ) { OutcomingDocument outcomingDocument = new OutcomingDocument ( getEnvironment ( ) . getOutcomingDocType ( ) , this , getDepartment ( ) . getPublicService ( ) ) ; outcomingDocument . setText ( this . getReplyToThank ( ) ) ; initiatingDocument . setReactionDocument ( outcomingDocument ) ; outcomingDocument . setInitiatingDocument ( initiatingDocument ) ; outcomingDocument . setDocumentName ( ExecutionDefaults . OUTCOMING_DOC_NAME ) ; return outcomingDocument ; } else throw new IllegalStateException ( ExecutionDefaults . DEPARTMENT_IS_NULL ) ; } else throw new IllegalStateException ( ExecutionDefaults . ENVIRONMENT_IS_NULL ) ; }
tr	6	public String getRecords ( ) { StringBuilder resultado = new StringBuilder ( ) ; if ( tipo != null ) { Declaracion tmp = tipo ; TipoDeclaracion tdecl = null ; TipoRecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof TipoDeclaracion ) { resultado . append ( ".namespace Ejemplo{\n" ) ; tdecl = ( ( TipoDeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getNombre ( ) ) ; resultado . append ( " extends [mscorlib]System.ValueType{\n" ) ; Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tdecl . getNombre ( ) ) ; TipoRecord record = ( ( TipoRecord ) t ) ; Collections . reverse ( record . tbsimbolo . lista ) ; Collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoRecord ) { trec1 = ( ( TipoRecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype Ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoArray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . toString ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getSiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . toString ( ) ; }
tr	6	subMapIterator ( Coord startCoord , int rangeX , int rangeY ) { this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; if ( ! ( 0 <= startCoord . getX ( ) ) || ! ( 0 <= startCoord . getY ( ) ) || ! ( startCoord . getX ( ) < latoDellaMappaIterator ) || ! ( startCoord . getY ( ) < latoDellaMappaIterator ) || ! ( 0 <= rangeX ) || ! ( 0 <= rangeY ) ) throw new IndexOutOfBoundsException ( ) ; this . startRow = startCoord . getY ( ) ; this . startColumn = startCoord . getX ( ) ; this . rowRange = rangeY ; this . columnRange = rangeX ; this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; curCoord = new Coord ( startColumn , startRow ) ; }
tr	0	public void removeColumn ( String columnID ) { htColumns . remove ( columnID ) ; }
tr	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new Items ( ) . setVisible ( true ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	8	public T resolve ( String name , Predicate < T > filter ) { name = name . trim ( ) ; T temp = map . get ( name ) ; if ( temp != null ) { return temp ; } name = name . toLowerCase ( ) ; while ( name . length ( ) > 0 ) { SortedMap < String , T > - = map . subMap ( name , name + "z" ) ; if ( - . isEmpty ( ) ) { break ; } Iterator < T > iter = - . values ( ) . iterator ( ) ; T first = null ; fail : { while ( iter . hasNext ( ) ) { T next = iter . next ( ) ; if ( ! filter . test ( next ) ) { continue ; } if ( first == null ) { first = next ; } else if ( first != next ) { break fail ; } } return first ; } if ( first == null ) { break ; } name = name . substring ( 0 , name . length ( ) - 1 ) ; } return null ; }
tr	9X	public void draw ( Graphics gPanel , float cellHeight , MapPanel panel ) { String drawImageName = "" ; Color color = null ; boolean draw = false ; if ( getBuilding ( ) != null ) { drawImageName = getBuilding ( ) . getImageLocation ( ) ; } else if ( getUnit ( ) != null ) { drawImageName = getUnit ( ) . getImageLocation ( ) ; } if ( getBuilding ( ) instanceof Base ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Factory ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Barracks ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Marine ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Tank ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } if ( draw ) { BufferedImage originalImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; try { BufferedImage rawImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; rawImage = ImageIO . read ( getClass ( ) . getResource ( drawImageName ) ) ; BufferedImage mask = generateMask ( rawImage , color , 0.3f ) ; originalImage = tint ( rawImage , mask ) ; } catch ( IOException e1 ) { System . out . println ( "Error getting map image!" ) ; } if ( getUnit ( ) != null && drawHealthBars ) { float healthScale = getUnit ( ) . getCurrentHealth ( ) / ( float ) getUnit ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } else if ( getBuilding ( ) != null && drawHealthBars ) { float healthScale = getBuilding ( ) . getCurrentHealth ( ) / ( float ) getBuilding ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } int newH = ( int ) ( 90 * panel . getZoom ( ) ) ; gPanel . drawImage ( originalImage , ( int ) ( this . getCellPosX ( ) * cellHeight ) , ( int ) ( this . getCellPosY ( ) * cellHeight ) , newH , newH , null ) ; } }
tr	1	@ Override public void act1 ( ) { Object obj = capabilities . get ( Cap1 . class ) ; if ( obj != null ) { ( ( Cap1 ) obj ) . act1 ( ) ; } else { throw new UnsupportedOperationException ( "We do not have Cap1 capability yet" ) ; } }
tr	9X	private List < String > collectInclude ( ) { List < String > list = new ArrayList < String > ( ) ; if ( javaChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JAVA ) ; } if ( txtChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_TXT ) ; } if ( jtlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JTL ) ; } if ( cvsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CVS ) ; } if ( datChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_DAT ) ; } if ( htmlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_HTML ) ; } if ( jspChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JSP ) ; } if ( cssChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CSS ) ; } if ( jsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JS ) ; } String udp = includeField . getText ( ) ; if ( udp == null || udp . isEmpty ( ) || udp . equals ( INCLUDE_RECOMMAND_STRING ) ) { } else { for ( String temp : udp . split ( ";" ) ) { list . add ( temp ) ; } } return list ; }
tr	2	public void keyReleased ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_SHIFT : if ( this . editMode == EditMode . MODE_TILE_SELECTION ) { this . editMode = EditMode . MODE_TILE_EDIT ; } break ; default : break ; } }
tr	2	public static String hashcode ( String message ) { String hash = null ; try { MessageDigest cript = MessageDigest . getInstance ( "SHA-1" ) ; cript . reset ( ) ; cript . update ( message . getBytes ( "utf8" ) ) ; hash = new BigInteger ( 1 , cript . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return hash ; }
tr	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	9X	private static void saveSystemState ( String filename ) { String out = getParameterValueList ( ) + "\n" ; out += "Changed per state \n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( systemStateChangeds != null ) { for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += systemStateChangeds . get ( systemTestType ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( lastSystemTestPoints != null ) for ( String s : lastSystemTestPoints . keySet ( ) ) { out += "\t" + s + "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Mayority" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Confidence" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Weight" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Missfire" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\n" ; } File f = new File ( filename ) ; try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; FileWriter w = new FileWriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ScienceTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	7	public long piece_can_reach ( int piece_index , int steps ) { long piece_bb = 1 << piece_index ; int piece_type = getPieceType ( piece_bb ) ; int piece_colour = piece_type & 01 ; long friend_bb = colour_bb [ piece_colour ] & ~ piece_bb ; int trap_num = trap_number [ piece_index ] ; if ( trap_num != - 1 ) { if ( ( TRAP [ trap_num ] & friend_bb ) != 0 ) { if ( ( TOUCH_TRAP [ trap_num ] & colour_bb [ piece_colour ] ) == piece_bb ) { friend_bb ^= TRAP [ trap_num ] ; } } } long unfrozen_sq_bb = ( touching_bb ( friend_bb ) | ( touching_bb ( colour_bb [ player ] ) & piece_bb ) | ~ touching_bb ( stronger_enemy_bb [ piece_type ] ) ) ; if ( ( unfrozen_sq_bb & piece_bb ) == 0 ) { return piece_bb ; } long bad_trap_bb = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( TOUCH_TRAP [ i ] & friend_bb ) == 0 ) { bad_trap_bb |= TRAP [ i ] ; } } long good_sq_bb = unfrozen_sq_bb & empty_bb & ~ bad_trap_bb ; long reached_bb = piece_bb ; for ( int i = 1 ; i < steps ; i ++ ) { reached_bb |= touching_bb ( reached_bb , piece_type ) & good_sq_bb ; } reached_bb |= touching_bb ( reached_bb , piece_type ) & empty_bb & ~ bad_trap_bb ; return reached_bb ; }
tr	8	private static Map < UnaryRule , List < String >> computeUnaryClosure ( Collection < UnaryRule > unaryRules ) { Map < UnaryRule , String > intermediateStates = new HashMap < UnaryRule , String > ( ) ; Counter < UnaryRule > pathCosts = new Counter < UnaryRule > ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByChild = new HashMap < String , List < UnaryRule >> ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByParent = new HashMap < String , List < UnaryRule >> ( ) ; Set < String > states = new HashSet < String > ( ) ; for ( UnaryRule unaryRule : unaryRules ) { relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , unaryRule , null , unaryRule . getScore ( ) ) ; states . add ( unaryRule . getParent ( ) ) ; states . add ( unaryRule . getChild ( ) ) ; } for ( String intermediateState : states ) { List < UnaryRule > incomingRules = closedUnaryRulesByChild . get ( intermediateState ) ; List < UnaryRule > outgoingRules = closedUnaryRulesByParent . get ( intermediateState ) ; if ( incomingRules == null || outgoingRules == null ) continue ; for ( UnaryRule incomingRule : incomingRules ) { for ( UnaryRule outgoingRule : outgoingRules ) { UnaryRule rule = new UnaryRule ( incomingRule . getParent ( ) , outgoingRule . getChild ( ) ) ; double newScore = pathCosts . getCount ( incomingRule ) * pathCosts . getCount ( outgoingRule ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , rule , intermediateState , newScore ) ; } } } for ( String state : states ) { UnaryRule selfLoopRule = new UnaryRule ( state , state ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , selfLoopRule , null , 1.0 ) ; } Map < UnaryRule , List < String >> closureMap = new HashMap < UnaryRule , List < String >> ( ) ; for ( UnaryRule unaryRule : pathCosts . keySet ( ) ) { unaryRule . setScore ( pathCosts . getCount ( unaryRule ) ) ; List < String > path = extractPath ( unaryRule , intermediateStates ) ; closureMap . put ( unaryRule , path ) ; } System . out . println ( "SIZE: " + closureMap . keySet ( ) . size ( ) ) ; return closureMap ; }
tr	3	@ Override protected void processMouseEvent ( MouseEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { if ( e . getX ( ) >= XLEN || e . getY ( ) >= YLEN ) return ; point p = new point ( ( double ) e . getX ( ) / XLEN , ( double ) e . getY ( ) / YLEN , current_value ) ; point_list . addElement ( p ) ; draw_point ( p ) ; } }
tr	4	public static Monster createMonsterFromReader ( String monsterString ) { String [ ] values = monsterString . split ( " " ) ; Monster monster = new Monster ( ) ; try { monster . setName ( values [ 0 ] ) ; monster . setMaxHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setCurrentHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setNaturalAC ( Integer . parseInt ( values [ 2 ] ) ) ; monster . setStrength ( Integer . parseInt ( values [ 3 ] ) ) ; monster . setDexterity ( Integer . parseInt ( values [ 4 ] ) ) ; monster . setSpeed ( Integer . parseInt ( values [ 5 ] ) ) ; monster . setAttackBonus ( Integer . parseInt ( values [ 6 ] ) ) ; monster . setBaseDamage ( Integer . parseInt ( values [ 7 ] ) ) ; monster . setBaseMeleeDescription ( values [ 8 ] ) ; monster . setSightRange ( Integer . parseInt ( values [ 9 ] ) ) ; monster . setDifficulty ( Integer . parseInt ( values [ 10 ] ) ) ; if ( values . length == 12 && values [ 11 ] != "" ) { String [ ] specials = values [ 11 ] . split ( " " ) ; monster = Monster . applySpecialTraits ( monster , specials ) ; } monster . setInSight ( false ) ; } catch ( Exception e ) { System . out . println ( "Error reading monster object" ) ; if ( monster . getName ( ) != null ) System . out . println ( monster . getName ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	9X	private static void initializeFreeSpaceMgnt ( ) { try { int noOfBlocksBitmap = 4 ; Block superBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "r" ) ; superBlock . readLine ( ) ; int [ ] freeBlockBitmapNo = new int [ noOfBlocksBitmap ] ; String tempStr = superBlock . readLine ( ) ; for ( int i = 0 ; i < noOfBlocksBitmap ; i ++ ) freeBlockBitmapNo [ i ] = Integer . parseInt ( tempStr . substring ( i , i + 1 ) ) ; byte [ ] [ ] freeSpaceBitmapContent = new byte [ 4 ] [ ] ; for ( int i = 0 ; i < 4 ; i ++ ) freeSpaceBitmapContent [ i ] = new byte [ Disk . maxBlockSize ] ; int i = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) { for ( int j = i % Disk . maxBlockSize ; j < Disk . maxBlockSize ; j ++ , i ++ ) { if ( i <= Disk . inodeEndBlock ) freeSpaceBitmapContent [ k ] [ j ] = 49 ; else freeSpaceBitmapContent [ k ] [ j ] = 48 ; } } for ( i = 0 ; i < 4 ; i ++ ) { Block bitmapBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeBlockBitmapNo [ i ] ) + ".txt" , "rw" ) ; bitmapBlock . write ( freeSpaceBitmapContent [ i ] ) ; bitmapBlock . close ( ) ; } System . out . println ( superBlock . getFilePointer ( ) ) ; int freeInodeBitmapNo = superBlock . read ( ) - 48 ; System . out . println ( superBlock . getFilePointer ( ) ) ; byte freeInodeContent [ ] = new byte [ ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ] ; freeInodeContent [ 0 ] = freeInodeContent [ 1 ] = freeInodeContent [ 2 ] = 49 ; for ( i = 3 ; i < ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ; i ++ ) { freeInodeContent [ i ] = 48 ; } Block freeInodeBitmapBlk = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeInodeBitmapNo ) + ".txt" , "rw" ) ; freeInodeBitmapBlk . write ( freeInodeContent ) ; freeInodeBitmapBlk . close ( ) ; superBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	public static Node addTwoNumbers ( Node num1 , Node num2 ) { Node num3 = null ; Node head = null ; int updigit = 0 ; while ( num1 != null && num2 != null ) { int digit1 = num1 . value ; int digit2 = num2 . value ; int newdigit = ( digit1 + digit2 + updigit ) % 10 ; updigit = ( digit1 + digit2 ) / 10 ; Node numNode = new Node ( null , newdigit ) ; if ( num3 == null ) { num3 = numNode ; head = num3 ; } else { num3 . next = numNode ; num3 = numNode ; } num1 = num1 . next ; num2 = num2 . next ; } if ( num1 != null ) { num3 . next = num1 ; } if ( num2 != null ) { num3 . next = num2 ; } return head ; }
tr	7	public static void knapsackBits ( int [ ] weights , int [ ] values , long maxWeight ) { int n = weights . length ; long numSets = ( long ) Math . pow ( 2 , n ) ; long bestSet = 0 ; long bestValue = 0 ; long bestWeight = 0 ; for ( long set = 1 ; set < numSets ; set ++ ) { long weight = 0 ; long value = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( set >> i ) & 1 ) == 1 ) { weight += weights [ i ] ; value += values [ i ] ; } } if ( weight <= maxWeight && value > bestValue ) { bestValue = value ; bestWeight = weight ; bestSet = set ; } } for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( bestSet >> i ) & 1 ) == 1 ) { System . out . print ( "[i=" + i + "  w=" + weights [ i ] + "  v=" + values [ i ] + "] " ) ; } } System . out . println ( ) ; System . out . println ( "Weight = " + bestWeight + "  Value = " + bestValue ) ; }
tr	5	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	3	public void newDocument ( ) { try { final DocumentFrame doc = new DocumentFrame ( loadOrganizer , null ) ; loadOrganizer . openDocuments . add ( doc ) ; doc . addInternalFrameListener ( new InternalFrameAdapter ( ) { @ Override public void internalFrameClosed ( InternalFrameEvent e ) { loadOrganizer . openDocuments . remove ( doc ) ; } } ) ; loadOrganizer . desktop . add ( doc , LoadOrganizer . DOCLAYER ) ; if ( preferences . isGuiNewWindowMaximize ( ) ) { doc . setMaximum ( true ) ; } doc . setVisible ( true ) ; doc . setSelected ( true ) ; } catch ( DocumentClosedException e ) { } catch ( Throwable e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } }
tr	8	public static void main ( String [ ] args ) { int port = 4444 ; Queue < String > arguments = new LinkedList < String > ( Arrays . asList ( args ) ) ; try { while ( ! arguments . isEmpty ( ) ) { String flag = arguments . remove ( ) ; try { if ( flag . equals ( "--port" ) ) { port = Integer . parseInt ( arguments . remove ( ) ) ; if ( port < 0 || port > 65535 ) { throw new IllegalArgumentException ( "port " + port + " out of range" ) ; } } else { throw new IllegalArgumentException ( "unknown option: \"" + flag + "\"" ) ; } } catch ( NoSuchElementException nsee ) { throw new IllegalArgumentException ( "missing argument for " + flag ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( "unable to parse number for " + flag ) ; } } } catch ( IllegalArgumentException iae ) { System . err . println ( iae . getMessage ( ) ) ; System . err . println ( "usage: WhiteboardServer [--port PORT]" ) ; return ; } try { runWhiteboardServer ( port ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	private int insert ( final BeanMissatge bean ) { String SQL1 = "INSERT INTO sig_missatgeria (idEntrevista destinatari idMateria materia actitud notes feina comentaris dataContestat idMensajeProfesor) " + " VALUES(? ? ? ? ? ? ? ? ? ?)" ; Object [ ] objs = new Object [ ] { bean . idEntrevista , bean . destinatari_abrev , bean . idMateria , bean . materia , bean . actitud , bean . notes , bean . feina , bean . comentari , bean . dataContestat , bean . idMensajeProfesor } ; int nup = client . getMysql ( ) . preparedUpdateID ( SQL1 , objs ) ; if ( nup > 0 ) { bean . setId ( nup ) ; } return nup ; }
tr	7	public void onEnable ( ) { Server = getServer ( ) ; log = Server . getLogger ( ) ; setPdfFile ( this . getDescription ( ) ) ; moveFiles ( ) ; setupPermissions ( ) ; questPlayerStorage = new iProperty ( "plugins/uQuest/uQuest_Players.txt" ) ; if ( new File ( "plugins/uQuest/uQuest_Quests.txt" ) . exists ( ) ) new QuestConverter ( ) ; if ( isUseDefaultUQuest ( ) ) { Cmd_uquest cmd_uquest = new Cmd_uquest ( this ) ; getCommand ( "uquest" ) . setExecutor ( cmd_uquest ) ; getCommand ( "quest" ) . setExecutor ( cmd_uquest ) ; try { getCommand ( "q" ) . setExecutor ( cmd_uquest ) ; } catch ( NullPointerException npe ) { useDefaultHelp = false ; } } setupEconomy ( ) ; Cmd_reloadquests cmd_reloadquests = new Cmd_reloadquests ( this ) ; getCommand ( "reloadquests" ) . setExecutor ( cmd_reloadquests ) ; Cmd_reloadquestconfig cmd_reloadquestconfig = new Cmd_reloadquestconfig ( this ) ; getCommand ( "reloadquestconfig" ) . setExecutor ( cmd_reloadquestconfig ) ; readConfig ( ) ; theQuestsLoadAllIntoArray ( ) ; if ( this . theQuests . isEmpty ( ) ) { System . err . println ( "\n\n\n" + pluginNameBracket ( ) + " You have an empty quest list!\n Disabling plugin.\n\n\n" ) ; Server . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( isUseSQLite ( ) == true ) { this . setDB ( new SqLiteKeyValStor < Quester > ( "questers" , "plugins/uQuest/uQuestQuesters" ) ) ; System . out . println ( pluginNameBracket ( ) + " Loaded with SQLite!" ) ; } if ( firstLoad == true && isUseSQLite ( ) == false ) { timerSavePlayers ( ) ; firstLoad = false ; System . out . println ( pluginNameBracket ( ) + " Loaded with Flatfile!" ) ; } registerEvents ( ) ; System . out . println ( pluginNameBracket ( ) + " v" + getPdfFile ( ) . getVersion ( ) + " enabled! With " + this . getQuestInteraction ( ) . getQuestTotal ( ) + " quests loaded!" ) ; }
tr	7	synchronized public void checkClipboard ( ) { if ( ClipboardDialog . systemClipboard != null && cc . viewer . sendClipboard . getValue ( ) ) { Transferable t = ClipboardDialog . systemClipboard . getContents ( this ) ; if ( ( t != null ) && t . isDataFlavorSupported ( DataFlavor . stringFlavor ) ) { try { String newContents = ( String ) t . getTransferData ( DataFlavor . stringFlavor ) ; if ( newContents != null && ! newContents . equals ( oldContents ) ) { cc . writeClientCutText ( newContents ) ; oldContents = newContents ; cc . clipboardDialog . setContents ( newContents ) ; } } catch ( Exception e ) { System . out . println ( "Exception getting clipboard data: " + e . getMessage ( ) ) ; } } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SettingsFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	1	@ Override public DataUnit read ( Protocol p , ReadableByteChannel channel ) throws IOException { ReadableByteChannel currentChannel = channel ; DataUnit dataUnit = headerProcessor . read ( p , currentChannel ) ; int totalLength = ProtocolUtil . getTotalLength ( dataUnit , p ) ; if ( totalLength != - 1 ) { int toRead = totalLength - ProtocolUtil . getHeaderBytes ( p ) ; byte [ ] bytes = IoUtil . readBytes ( toRead , currentChannel ) ; currentChannel = Channels . newChannel ( new ByteArrayInputStream ( bytes ) ) ; } dataUnit = unitProcessor . fromStream ( dataUnit , p , currentChannel ) ; currentChannel = channel ; return dataUnit ; }
tr	5	public MyPopulation ( int populationSize , int dataSize , IMyFitnessTestFunction < U > fitnessTester , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( populationSize < 4 ) { throw new Exception ( "population size should be 4 or greater" ) ; } if ( dataSize < MyIndividual . MIN_DATA_SIZE ) { throw new Exception ( "data size should be 4 or greater" ) ; } if ( fitnessTester == null ) { throw new Exception ( "fitnessTester function Cannot be null" ) ; } population = new ArrayList < > ( ) ; try { for ( int i = 0 ; i < populationSize ; i ++ ) { population . add ( new MyIndividual ( dataSize , true , 0.99 , true , fitnessTester , rFunc ) ) ; } } catch ( Exception e ) { System . err . println ( "ex in individual's constructor:" + e . getMessage ( ) ) ; } }
tr	9X	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	5	private Chunk loadChunk ( String [ ] [ ] s , Renderer rend ) { Point p1 = new Point ( Integer . decode ( s [ 0 ] [ 0 ] ) , Integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; Chunk c ; const . debug ( "(SaveHandler:loadChunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(SaveHandler:loadChunk): spawn will be loaded" ) ; c = new SpawnChunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(SaveHandler:loadChunk): underground will be loaded" ) ; c = new UndergroundChunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(SaveHandler:loadChunk): sky will be loaded" ) ; c = new SkyChunk ( map , p1 , true , rend ) ; } else { const . debug ( "(SaveHandler:loadChunk): surface will be loaded" ) ; c = new SurfaceChunk ( map , p1 , true , rend , false ) ; ( ( SurfaceChunk ) c ) . biome = Integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { System . err . println ( "error while loading chunk  wrong selection" ) ; System . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	7	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	1	private FormalParametersNode formalParameters ( ) { List < FPSectionNode > fpsections = new ArrayList < FPSectionNode > ( ) ; FPSectionNode fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; while ( test ( SEMICOLON ) ) { read ( SEMICOLON , ";" ) ; fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; } return new FormalParametersNode ( fpsections ) ; }
tr	5	public void fileNew ( SimpleFrame frame ) { frame . setAction ( false ) ; frame . setIsFileNameSetted ( false ) ; frame . setTitle ( "Text Editor" ) ; JFileChooser chooser = new JFileChooser ( ) ; if ( frame . getIsChanged ( ) ) { int selection = JOptionPane . showConfirmDialog ( null , "Do you want save document?" , "Warrning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( selection == JOptionPane . NO_OPTION ) { frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } if ( selection == JOptionPane . YES_OPTION ) { chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } } else { frame . getText ( ) . setText ( "" ) ; } frame . setAction ( true ) ; }
tr	7	public static String RegexExtraction ( String patternStr , String data ) { Pattern pattern ; if ( patternStr == null || patternStr . length ( ) == 0 || patternStr . isEmpty ( ) ) return null ; if ( RegexManager . getInstance ( ) . patternList . containsKey ( patternStr ) ) { pattern = RegexManager . getInstance ( ) . patternList . get ( patternStr ) ; } else { pattern = Pattern . compile ( patternStr ) ; RegexManager . getInstance ( ) . patternList . put ( patternStr , pattern ) ; } Matcher matcher = pattern . matcher ( data ) ; String res = "" ; if ( matcher . find ( ) ) { if ( patternStr . startsWith ( ParameterSetting . REGXWORDPATTERN_V2 ) ) { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ array . length - 1 ] . replace (   ,   ) . trim ( ) ; } else { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ 0 ] . replace (   ,   ) . trim ( ) ; } } if ( StopwordsFilter . getInstance ( ) . isStopWords ( res ) ) return null ; else return res ; }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	5	public static void main ( final String [ ] argv ) throws IOException { if ( argv . length == 0 ) { printInfoAndExit ( ) ; } else if ( "-index" . equals ( argv [ 0 ] ) && argv . length >= 4 ) { final int length = argv . length - 4 ; final String [ ] arrPKsToIgnore = new String [ length ] ; System . arraycopy ( argv , 4 , arrPKsToIgnore , 0 , length ) ; index ( argv [ 1 ] , argv [ 2 ] , argv [ 3 ] , arrPKsToIgnore ) ; } else if ( "-benchmark" . equals ( argv [ 0 ] ) && argv . length >= 3 ) { final int length = argv . length - 2 ; final String [ ] arrConfigFiles = new String [ length ] ; System . arraycopy ( argv , 2 , arrConfigFiles , 0 , length ) ; benchmark ( argv [ 1 ] , arrConfigFiles ) ; } else { printInfoAndExit ( ) ; } }
tr	3	public void setPop ( Population p ) { pop = p ; nCells = p . getGenomeLength ( ) / 2 ; popSize = p . getPopSize ( ) ; vertical = nCells > popSize ; int w = DEF_WIDTH , h = DEF_HEIGHT ; if ( vertical ) { int t = w ; w = h ; h = t ; } int w2 = w / nCells ; int h2 = h / popSize - 1 ; pixelSize = math . clamp ( Math . min ( w2 , h2 ) , 1 , 3 ) ; genSep = ( pixelSize > 1 ) ? 1 : 0 ; drawnCells = math . clamp ( w / pixelSize , 0 , nCells ) ; drawnPop = math . clamp ( h / ( pixelSize + genSep ) , 0 , popSize ) ; plotSize = vertical ? new Point ( drawnPop * ( pixelSize + genSep ) , drawnCells * pixelSize ) : new Point ( drawnCells * pixelSize , drawnPop * ( pixelSize + genSep ) ) ; }
tr	1	public static int getHoursThisYear ( int driver ) { if ( driver == 0 ) throw new InvalidQueryException ( "Nonexistent driver" ) ; return database . busDatabase . get_int ( "driver" , driver , "hours_this_year" ) ; }
tr	5	public Iterable < Position < E >> findRange ( E minValue , E maxValue ) { List < Position < E >> l = new ArrayList < > ( ) ; List < Position < E >> todas = ( List < Position < E >> ) this . positions ( ) ; for ( Position < E > pos : todas ) { E curValue = pos . element ( ) ; int compMin = findComparator . compare ( curValue , minValue ) ; int compMax = findComparator . compare ( curValue , maxValue ) ; boolean overMin = ( ( compMin == 0 ) || ( compMin == 1 ) ) ; boolean underMax = ( ( compMax == 0 ) || ( compMax == - 1 ) ) ; if ( overMin && underMax ) { l . add ( pos ) ; } } return l ; }
tr	1	public static void main ( String [ ] args ) { File dictionary = new File ( "dictionary.txt" ) ; try { List < List < String >> anagrams = getAnagramsHT ( dictionary ) ; System . out . println ( anagrams . toString ( ) ) ; } catch ( IOException e ) { System . err . println ( "IO EXCEPTION ENCOUNTERED!!" ) ; e . printStackTrace ( ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && Region . plane != plane ) { gameScreenImageProducer . initDrawingArea ( ) ; fontPlain . drawCentredText ( "Loading - please wait." , 257 , 151 , 0 ) ; fontPlain . drawCentredText ( "Loading - please wait." , 256 , 150 , ffffff ) ; gameScreenImageProducer . drawGraphics ( 4 , super . gameGraphics , 4 ) ; loadingStage = 1 ; loadRegionTime = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int successful = initialiseRegionLoading ( ) ; if ( successful != 0 && System . currentTimeMillis ( ) - loadRegionTime > 360000 ) { signlink . reporterror ( enteredUsername + " glcfb " + serverSessionKey + " " + successful + " " + lowMemory + " " + caches [ 0 ] + " " + onDemandFetcher . immediateRequestCount ( ) + " " + plane + " " + regionX + " " + regionY ) ; loadRegionTime = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != lastRegionId ) { lastRegionId = plane ; renderMinimap ( plane ) ; } }
tr	8	public void executePowerUp ( PowerupNode node ) { PowerupPlayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsFeature ) { case BOMB_MAX_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case BOMB_TEMP_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case CAN_JUMP : break ; case CAN_PUSH : break ; case FLAME_LENGTH : combatSystem . updateBombLayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case SPEED : movementSystem . updateMoveable ( node . entity_target , powerup . amount ) ; break ; case DAMAGE : combatSystem . updateBombLayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
tr	0	public JPasswordField getPassword ( ) { return password ; }
tr	4	final public CreateSubschemaCommand CreateSubschema_suffix ( ) throws ParseException { String tableName ; List < String > attrNames = new ArrayList < String > ( ) ; String attrName ; jj_consume_token ( KW_SUBSCHEMA ) ; tableName = Identifier ( ) ; attrName = Identifier ( ) ; attrNames . add ( attrName ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 5 ] = jj_gen ; break label_1 ; } jj_consume_token ( 51 ) ; attrName = Identifier ( ) ; attrNames . add ( attrName ) ; } { if ( true ) return new CreateSubschemaCommand ( token , tableName , attrNames ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	4	private void showInfo ( ) { try { FileReader file = new FileReader ( "data/info.txt" ) ; BufferedReader buff = new BufferedReader ( file ) ; boolean eof = false ; while ( ! eof ) { String line = buff . readLine ( ) ; if ( line != null ) { infoArea . append ( "\n" + line ) ; } else { eof = true ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	8	public static String allScores ( String fileName ) throws IOException { Scanner scan ; String [ ] usernames ; long [ ] wins , losses ; int fileLength = 0 , win = - 1 , lose = - 1 ; try { scan = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( "File not found: " + fileName ) ; FileWriter writeToFile = new FileWriter ( fileName ) ; writeToFile . write ( "//BEGIN\r\n" + "//END" ) ; writeToFile . close ( ) ; scan = new Scanner ( new File ( fileName ) ) ; } String fileContents = "" , fileLine = scan . nextLine ( ) ; while ( ! fileLine . equals ( "//END" ) ) { fileLine = scan . nextLine ( ) ; if ( ! fileLine . equals ( "//END" ) ) fileLength ++ ; } if ( fileLength == 0 ) return "There are no scores in the scoreboard!\nSave yours and get 1st place ;3" ; usernames = new String [ fileLength ] ; wins = new long [ fileLength ] ; losses = new long [ fileLength ] ; scan = new Scanner ( new File ( fileName ) ) ; String spare = scan . next ( ) ; int i ; for ( i = 0 ; i < fileLength ; i ++ ) { try { usernames [ i ] = scan . next ( ) ; wins [ i ] = scan . nextLong ( ) ; losses [ i ] = scan . nextLong ( ) ; } catch ( InputMismatchException ex ) { changeScore ( fileName , usernames [ i ] , 0 , 0 ) ; } } usernames = readNames ( usernames ) ; fileContents = "Username\t Wins\t Losses\n" ; for ( i = 0 ; i < fileLength ; i ++ ) { fileContents += ( i + 1 + ": " + usernames [ i ] + ( usernames [ i ] . length ( ) < 5 ? "\t\t" : "\t " ) + wins [ i ] + "\t " + losses [ i ] + "\n" ) ; } return ( fileContents ) ; }
tr	9X	@ Override public Orientation getStepOrientation ( int lineIndex ) { switch ( lineIndex ) { case 0 : case 5 : return Orientation . DOWN_LEFT ; case 1 : case 6 : return Orientation . UP_LEFT ; case 2 : case 7 : return Orientation . CENTER ; case 3 : case 8 : return Orientation . UP_RIGHT ; case 4 : case 9 : return Orientation . DOWN_RIGHT ; default : return Orientation . NONE ; } }
tr	7	public static String encode ( String text , int offset ) { char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { int c = chars [ i ] ; if ( c >= a && c <= z ) { c += offset ; if ( c > z ) { c = a + ( c - z - 1 ) ; } else if ( c < a ) { c = z - ( a - c ) + 1 ; } } else { c += offset ; if ( c > Z ) { c = A + ( c - Z - 1 ) ; } else if ( c < A ) { c = Z - ( A - c ) + 1 ; } } chars [ i ] = ( char ) c ; } return new String ( chars ) ; }
tr	5	@ SuppressWarnings ( "static-access" ) public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JLabel label = ( JLabel ) super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; label . setIcon ( null ) ; if ( table . getColumnName ( column ) . equals ( "Nom" ) || table . getColumnName ( column ) . equals ( "Ville" ) || table . getColumnName ( column ) . equals ( "Province" ) ) { label . setText ( value . toString ( ) ) ; } else if ( table . getColumnName ( column ) . equals ( "Ferm\u00E9" ) ) { label . setText ( "" ) ; if ( value . toString ( ) . equals ( "true" ) ) { label . setIcon ( ConfigIcon . getInstance ( ) . CLOSED ) ; } else { label . setIcon ( ConfigIcon . getInstance ( ) . EMPTY_16 ) ; } } label . setOpaque ( true ) ; label . setHorizontalAlignment ( CENTER ) ; return label ; }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	7	public SplitSample < T > contains ( Set < Integer > ids , boolean negate ) { ListSample < T > result = new ListSample < T > ( ) ; for ( T item : this ) { Integer id = membership . get ( item . identifier ( ) ) ; if ( id == null ) { if ( ids . contains ( SplitSample . undefined ) ) result . add ( item ) ; } else if ( ( ! negate && ids . contains ( id ) ) || ( negate && ! ids . contains ( id ) ) ) result . add ( item ) ; } return result ; }
tr	4	@ Override public String toString ( ) { StringBuffer tmp = new StringBuffer ( ) ; tmp . append ( type ) ; tmp . append ( " " ) ; tmp . append ( payLoadType ) ; tmp . append ( " " ) ; tmp . append ( httpMethod ) ; tmp . append ( " " ) ; tmp . append ( template . toUri ( ) ) ; tmp . append ( " path-params[" ) ; boolean first = true ; for ( Parameter param : pathParameters ) { if ( first ) { first = false ; } else { tmp . append ( " " ) ; } tmp . append ( param ) ; } tmp . append ( "]" ) ; tmp . append ( " query-params[" ) ; first = true ; for ( Parameter param : queryParameters ) { if ( first ) { first = false ; } else { tmp . append ( " " ) ; } tmp . append ( param ) ; } tmp . append ( "]" ) ; return tmp . toString ( ) ; }
tr	9X	public static Object [ ] commandsForAgentAndBoxToField ( Level l , Agent agent , Box box , Field agentFromField , ArrayList < Node > nodesAgentCanEndIn , Field boxToField , ArrayList < Box > boxesToIgnore , DockTask taskDock ) { if ( boxesToIgnore == null ) { boxesToIgnore = new ArrayList < Box > ( ) ; boxesToIgnore . add ( box ) ; } ArrayList < Field > pathToGuideBoxAlong = new ArrayList < Field > ( taskDock . path ) ; Collections . reverse ( pathToGuideBoxAlong ) ; Field boxFromField = box . atField ; dir boxDir = null ; GoalSequenceNode root = new GoalSequenceNode ( boxFromField , agentFromField , null ) ; root . g = 0 ; root . w = 0 ; root . h = pathToGuideBoxAlong . size ( ) - 1 ; root . f = root . g + root . w + root . h ; Queue < GoalSequenceNode > queue = new PriorityQueue < GoalSequenceNode > ( ) ; HashMap < Field , ArrayList < Field >> closedSet = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( boxFromField ) ; closedSet . put ( agentFromField , tempList ) ; queue . add ( root ) ; GoalSequenceNode currentNode = queue . poll ( ) ; while ( currentNode != null ) { if ( currentNode . boxLocation == boxToField ) { if ( nodesAgentCanEndIn == null || nodesAgentCanEndIn . contains ( currentNode . agentLocation ) ) { break ; } } boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > possibleBoxCommands = possibleBoxCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation , boxesToIgnore ) ; for ( Command command : possibleBoxCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( closedSet . containsKey ( agentLocation ) ) { if ( closedSet . get ( agentLocation ) . contains ( boxLocation ) ) { continue ; } else { closedSet . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; closedSet . put ( agentLocation , tempListe ) ; } GoalSequenceNode node = new GoalSequenceNode ( boxLocation , agentLocation , command ) ; node . parent = currentNode ; node . g = node . parent . g + 1 ; node . w = ( command . weight ) ? 15 : 0 ; if ( node . parent . h - 1 >= 0 && pathToGuideBoxAlong . get ( node . parent . h - 1 ) == node . boxLocation ) { node . h = node . parent . h - 1 ; } else { node . h = node . parent . h ; } node . f = node . g + node . w + node . h ; queue . add ( node ) ; } if ( queue . isEmpty ( ) ) { System . err . println ( "CRY" ) ; return null ; } currentNode = queue . poll ( ) ; } Field agentMoveTo = currentNode . agentLocation ; LinkedList < Command > commands = new LinkedList < Command > ( ) ; LinkedList < Field > fieldsUsed = new LinkedList < Field > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; fieldsUsed . add ( currentNode . agentLocation ) ; fieldsUsed . add ( currentNode . boxLocation ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; Collections . reverse ( fieldsUsed ) ; LinkedHashSet < Field > fieldsUsedSet = new LinkedHashSet < Field > ( fieldsUsed ) ; ArrayList < Field > fieldsUsedList = new ArrayList < Field > ( fieldsUsedSet ) ; return new Object [ ] { commands , fieldsUsedList , agentMoveTo } ; }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Service other = ( Service ) obj ; if ( clusterRef == null ) { if ( other . clusterRef != null ) return false ; } else if ( ! clusterRef . equals ( other . clusterRef ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( serviceState != other . serviceState ) return false ; if ( type != other . type ) return false ; return true ; }
tr	8	private void waitForAndConnectClients ( ) { boolean afterFirstPlayer ; try { ServerSocket serverSocket = new ServerSocket ( PORT ) ; Socket clientSocket = new Socket ( ) ; acceptConnections ( serverSocket , clientSocket ) ; } catch ( SocketTimeoutException ste ) { System . out . println ( "SocketTimeoutException occured in Server" ) ; boolean exitLoop = false ; if ( Server . numOfClients >= 2 ) { this . startupPG . broadcastMessage ( "sBegin" ) ; while ( exitLoop == false ) { if ( this . startupPG . arePlayersReadyToPlay ( ) == true ) { cGame45 . beginRound ( ) ; exitLoop = true ; } else { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { System . err . println ( "Server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { System . out . println ( "Timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( IOException ioe ) { System . out . println ( "IO Exception occured in Server" ) ; } catch ( SecurityException sc ) { System . out . println ( "SecurityExceptionException occured in Server" ) ; } catch ( IllegalBlockingModeException ibme ) { System . out . println ( "IllegalBlockingModeException occured in Server" ) ; } }
tr	8	private boolean r_perfective_gerund ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 9 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	6	private void initPanels ( ) { if ( attribs == null ) { attribs = new MyInternalFrame ( this , 1 ) ; jDesktopPane1 . add ( attribs , new Integer ( 10 ) ) ; } try { attribs . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } attribs . setVisible ( true ) ; if ( tools == null ) { tools = new MyInternalFrame ( this , 0 ) ; jDesktopPane1 . add ( tools , new Integer ( 10 ) ) ; } tools . setVisible ( true ) ; try { tools . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } if ( opers == null ) { opers = new MyInternalFrame ( this , 2 ) ; jDesktopPane1 . add ( opers , new Integer ( 10 ) ) ; } try { opers . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } opers . setVisible ( true ) ; }
tr	3	private ArraySchema parseArraySchema ( JsonNode rawSchema , URL schemaLocation ) { ArraySchema result = new ArraySchema ( ) ; JsonNode rawItems = rawSchema . get ( "items" ) ; if ( rawItems != null ) { result . setItems ( parse ( rawItems , schemaLocation ) ) ; } JsonNode rawMinItems = rawSchema . get ( "minItems" ) ; if ( rawMinItems != null ) { result . setMinItems ( rawMinItems . intValue ( ) ) ; } JsonNode rawMaxItems = rawSchema . get ( "maxItems" ) ; if ( rawMaxItems != null ) { result . setMaxItems ( rawMaxItems . intValue ( ) ) ; } return result ; }
tr	2	@ Override public boolean remove ( Object o ) { Node < E > position = head ; for ( int i = 0 ; i < size ; i ++ ) { position = position . getNextNode ( ) ; if ( position . getValue ( ) == o ) { this . remove ( i ) ; return true ; } } return false ; }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	1	protected ASTNode maybeWrapInTerm ( ASTNode node ) { if ( node . getNodeCount ( ) == 1 ) { return node ; } return new TermNode ( node ) ; }
tr	9X	public boolean isMatching ( StringBuffer word , int wordPos ) { boolean matching = true , inMulti = false , multiMatch = false ; char matchCh ; for ( int matchPos = 0 ; matchPos < match . length ; matchPos ++ ) { matchCh = match [ matchPos ] ; if ( matchCh == STARTMULTI || matchCh == ENDMULTI ) { inMulti = ! inMulti ; if ( ! inMulti ) matching = matching & multiMatch ; else multiMatch = false ; } else { if ( matchCh != word . charAt ( wordPos ) ) { if ( inMulti ) multiMatch = multiMatch | false ; else matching = false ; } else { if ( inMulti ) multiMatch = multiMatch | true ; else matching = true ; } if ( ! inMulti ) wordPos ++ ; if ( ! matching ) break ; } } if ( end && wordPos != word . length ( ) ) matching = false ; return matching ; }
tr	5	public static Method findVisitMethod ( MatchProcessor visitor , Match node ) { Method visitMethod = null ; class < ? > visitorClass = visitor . getClass ( ) ; Map < String , Method > visitMethods = __visitMethodCache . get ( visitorClass ) ; if ( visitMethods == null ) __visitMethodCache . put ( visitorClass , visitMethods = new HashMap < String , Method > ( ) ) ; String methodName = node . getParser ( ) . getLabel ( ) ; methodName = "process" + methodName . substring ( 0 , 1 ) . toUpperCase ( ) + methodName . substring ( 1 ) ; visitMethod = visitMethods . get ( methodName ) ; if ( visitMethod == null ) { try { visitMethod = visitorClass . getMethod ( methodName , Match . class ) ; visitMethods . put ( methodName , visitMethod ) ; } catch ( Exception e ) { } } if ( visitMethod == null ) return __defaultVisitMethod ; return visitMethod ; }
tr	7	public boolean mouseUp ( Event event , int x , int y ) { if ( menus . mouseUp ( x , y ) ) { damage ( ) ; return true ; } Renderer . setDragging ( false ) ; if ( x < 35 && y < 35 ) { } if ( x > W - 35 && y < 35 ) { } if ( x > W - 35 && y > H - 35 ) { } return true ; }
tr	2	public BacklogBean loadId ( BacklogBean oBacklog ) throws ServletException { try { if ( request . getParameter ( "id" ) != null ) { oBacklog . setId ( Integer . parseInt ( request . getParameter ( "id" ) ) ) ; } else { oBacklog . setId ( 0 ) ; } } catch ( NumberFormatException e ) { throw new ServletException ( "Controller: Error: loadId: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oBacklog ; }
tr	5	public BufferedImage alphaMultiply ( BufferedImage b , int a ) { BufferedImage bmp = deepCopy ( b ) ; for ( int x = 0 ; x < bmp . getWidth ( ) ; x ++ ) for ( int y = 0 ; y < bmp . getHeight ( ) ; y ++ ) { int rgb = bmp . getRGB ( x , y ) ; int red = ( int ) ( ( ( rgb >> 16 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( red > ff ) red = ff ; int green = ( int ) ( ( ( rgb >> 8 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( green > ff ) green = ff ; int blue = ( int ) ( ( ( rgb >> 0 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( blue > ff ) blue = ff ; int alpha = ( ( rgb >> 24 ) & ff ) ; rgb = ( alpha << 24 ) | ( red << 16 ) | ( green << 8 ) | blue ; bmp . setRGB ( x , y , rgb ) ; } return bmp ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	1	public Set < String > keySet ( ) { if ( mode == Mode . Map ) { return map . keySet ( ) ; } throw new PerlHashTypeException ( "Not a map" ) ; }
tr	9X	public Map < String , Object > toConfigurationNode ( ) { Map < String , Object > output = new LinkedHashMap < String , Object > ( ) ; output . put ( "group" , group ) ; if ( subgroups != null && subgroups . size ( ) != 0 ) { output . put ( "subgroups" , subgroups ) ; } if ( permissions != null && permissions . size ( ) != 0 ) { Map < String , List < String >> tmp = new LinkedHashMap < String , List < String >> ( ) ; for ( String world : permissions . keySet ( ) ) { tmp . put ( world , internalFormatToFile ( permissions . get ( world ) ) ) ; } output . put ( "permissions" , tmp ) ; } if ( info != null && info . size ( ) != 0 ) { output . put ( "info" , info ) ; } if ( globalPermissions != null && globalPermissions . size ( ) != 0 ) { output . put ( "globalpermissions" , internalFormatToFile ( globalPermissions ) ) ; } return output ; }
tr	5	private void analyze ( ) { double minPrice = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < pricings . size ( ) ; i ++ ) { if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Base" ) ) bases . add ( i ) ; else if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Reward" ) ) rewards . add ( i ) ; else penalties . add ( i ) ; if ( minPrice > pricings . get ( i ) . getCurrentPrice ( ) ) { minPrice = pricings . get ( i ) . getCurrentPrice ( ) ; indexOfCheapest . clear ( ) ; indexOfCheapest . add ( i ) ; } else if ( minPrice == pricings . get ( i ) . getCurrentPrice ( ) ) { indexOfCheapest . add ( i ) ; } } }
tr	7	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { final JToggleButton sourceBtn = ( JToggleButton ) e . getSource ( ) ; if ( sourceBtn . isSelected ( ) ) { final String host = cbxCfgAddress . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String port = cbxCfgPort . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String name = cbxCfgName . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; ConfigHistory . addEntry ( host , port , name ) ; cbxCfgAddress . addItem ( host ) ; cbxCfgPort . addItem ( port ) ; cbxCfgName . addItem ( name ) ; try { final Registry reg = LocateRegistry . getRegistry ( host , Integer . parseInt ( port ) ) ; final ServerControl remoteControl = ( ServerControl ) reg . lookup ( BINDING_ID ) ; if ( name . equals ( "" ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please enter your name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . isJoinable ( ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "The selected server is busy!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . register ( name ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please choose another name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else { cbxCfgAddress . setEnabled ( false ) ; cbxCfgName . setEnabled ( false ) ; cbxCfgPort . setEnabled ( false ) ; lblTitle . setText ( "Waiting for host..." ) ; target . setName ( name ) ; target . setController ( remoteControl ) ; registerThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { while ( ! remoteControl . isRunning ( ) ) { Thread . sleep ( 500 ) ; } ConnectionDialog . this . dispose ( ) ; } catch ( InterruptedException | RemoteException e ) { try { remoteControl . unregister ( name ) ; } catch ( Exception e1 ) { } } } } ) ; registerThread . start ( ) ; } } catch ( RemoteException | NotBoundException ex ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Host cannot be found!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } } else { registerThread . interrupt ( ) ; cbxCfgAddress . setEnabled ( true ) ; cbxCfgName . setEnabled ( true ) ; cbxCfgPort . setEnabled ( true ) ; lblTitle . setText ( "Connect to host..." ) ; } }
tr	4	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
tr	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
tr	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
tr	0	@ Override public void Lands ( Player P ) { }
tr	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
tr	9X	private Hashtable < Character , String > build_box ( int [ ] perm , String k ) { int [ ] row = new int [ 2 ] ; row [ 0 ] = perm [ 0 ] ; row [ 1 ] = perm [ 1 ] ; int [ ] col = new int [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { col [ i ] = perm [ i + 2 ] ; } boolean [ ] filled = new boolean [ 26 ] ; String k_u = k . toUpperCase ( ) ; Hashtable < Character , String > result = new Hashtable < Character , String > ( ) ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < k_u . length ( ) ; i ++ ) { char cur_c = k_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } else if ( cur_c == Z ) { cur_c = Y ; } int pos = cur_c - A ; if ( ! filled [ pos ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ pos ] = true ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 25 || i == 9 ) continue ; if ( ! filled [ i ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } char cur_c = ( char ) ( A + i ) ; result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ i ] = true ; } } return result ; }
tr	4	public static void main ( String [ ] args ) { try { getConfig ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { SubstanceLookAndFeel laf = new SubstanceMarinerLookAndFeel ( ) ; UIManager . setLookAndFeel ( laf ) ; String skinClassName = "org.pushingpixels.substance.api.skin." + skin + "Skin" ; SubstanceLookAndFeel . setSkin ( skinClassName ) ; JDialog . setDefaultLookAndFeelDecorated ( true ) ; } catch ( UnsupportedLookAndFeelException e ) { throw new RuntimeException ( e ) ; } } } ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ SuppressWarnings ( "static-access" ) public void run ( ) { frame = new MainFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; try { @ SuppressWarnings ( "resource" ) Socket telnet = new Socket ( Phone . AsteriskIp , 5038 ) ; telnet . setKeepAlive ( true ) ; telnetWriter = new PrintWriter ( telnet . getOutputStream ( ) ) ; telnetReader = new BufferedReader ( new InputStreamReader ( telnet . getInputStream ( ) ) ) ; telnetWriter . print ( "Action: login\r\n" ) ; telnetWriter . print ( "UserName: " + Phone . ReadUser + "\r\n" ) ; telnetWriter . print ( "Secret: " + Phone . ReadUserPassword + "\r\n\r\n" ) ; telnetWriter . flush ( ) ; } catch ( SocketException e1 ) { e1 . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } AsteriskThread = new AsteriskThread ( ) ; AsteriskThread . start ( ) ; } } ) ; }
tr	4	public List < SiteStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > statRows = resultset . getRows ( ) ; Map < long , SiteStatModel > siteStatModelMap = new HashMap < > ( ) ; for ( StatRow eachRow : statRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { SiteStatModel siteStatModel = new SiteStatModel ( ) ; siteStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; siteStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; siteStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; siteStatModel . setHour ( hour ) ; siteStatModel . setVideo ( 0 ) ; siteStatModel . setSite ( siteModel ) ; if ( siteStatModelMap . get ( hour . getMillis ( ) ) == null ) { siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } else { siteStatModelMap . remove ( hour . getMillis ( ) ) ; siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } } } List < SiteStatModel > siteStatModels = new ArrayList < > ( siteStatModelMap . values ( ) ) ; return siteStatModels ; }
tr	0	public void setAddressId ( int value ) { addressId = value ; }
tr	4	private static HashMap < String , Integer > addToEndGroup ( HashMap < String , Integer > endGroups , String endGroup , int end ) { if ( endGroup != null ) { if ( endGroups == null ) endGroups = new HashMap < String , Integer > ( 2 ) ; Integer oldEnd = endGroups . get ( endGroup ) ; if ( oldEnd == null || end > oldEnd ) endGroups . put ( endGroup , end ) ; } return endGroups ; }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	4	public Rectangle2D getDrawableArea ( Unit unit ) { double w = paperWidth . getValue ( unit ) ; double x = 0 ; if ( leftMargin != null ) { x = leftMargin . getValue ( unit ) ; w -= x ; } if ( rightMargin != null ) { w -= rightMargin . getValue ( unit ) ; } double h = paperHeight . getValue ( unit ) ; double y = 0 ; if ( topMargin != null ) { y = topMargin . getValue ( unit ) ; h -= y ; } if ( bottomMargin != null ) { h -= bottomMargin . getValue ( unit ) ; } return new Rectangle2D . double ( x , y , w , h ) ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	7	@ Override protected void performTask ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { IAction action = null ; String actionString = request . getParameter ( ConstantsJSP . ACTION ) ; if ( actionString == null ) { jump ( Constants . INDEX_JSP , request , response ) ; return ; } User user = null ; try { HttpSession session = request . getSession ( false ) ; if ( session != null ) { user = ( User ) session . getAttribute ( ConstantsJSP . USER ) ; } if ( user != null && user . getRole ( ) . ordinal ( ) >= Role . COURIER . ordinal ( ) ) { action = PlayCourierActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } else { action = PlaysActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } action . execute ( request , response ) ; if ( ! response . isCommitted ( ) ) { jump ( action . getDoneUrl ( ) , request , response ) ; } } catch ( IllegalArgumentException e ) { jumpError ( Constants . INDEX_JSP , Constants . INTERNAL_ERROR , request , response ) ; return ; } catch ( DAOException e ) { jumpError ( action . getErrorUrl ( ) , e . getMessage ( ) , request , response ) ; return ; } }
tr	9X	public static String getTypeName ( class < ? extends Tag > clazz ) { if ( clazz . equals ( ByteArrayTag . class ) ) { return "TAG_Byte_Array" ; } else if ( clazz . equals ( ByteTag . class ) ) { return "TAG_Byte" ; } else if ( clazz . equals ( CompoundTag . class ) ) { return "TAG_Compound" ; } else if ( clazz . equals ( DoubleTag . class ) ) { return "TAG_Double" ; } else if ( clazz . equals ( EndTag . class ) ) { return "TAG_End" ; } else if ( clazz . equals ( FloatTag . class ) ) { return "TAG_Float" ; } else if ( clazz . equals ( IntArrayTag . class ) ) { return "TAG_Int_Array" ; } else if ( clazz . equals ( IntTag . class ) ) { return "TAG_Int" ; } else if ( clazz . equals ( ListTag . class ) ) { return "TAG_List" ; } else if ( clazz . equals ( LongTag . class ) ) { return "TAG_Long" ; } else if ( clazz . equals ( ShortTag . class ) ) { return "TAG_Short" ; } else if ( clazz . equals ( StringTag . class ) ) { return "TAG_String" ; } else if ( clazz . equals ( ListStringArrayTag . class ) ) { return "TAG_ListString_Array" ; } else if ( clazz . equals ( ListItemStackArrayTag . class ) ) { return "TAG_ListItemStack_Array" ; } else { throw new IllegalArgumentException ( "Invalid tag classs (" + clazz . getName ( ) + ")." ) ; } }
tr	0	public void serviceRemoved ( ServiceEvent event ) { synchronized ( infos ) { infos . remove ( event . getName ( ) ) ; } }
tr	4	private void findNextCodel ( Codel codel ) { int x = codel . x ; int y = codel . y ; DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; if ( directionPointer . isRight ( ) ) { x += 1 ; } else if ( directionPointer . isBottom ( ) ) { y += 1 ; } else if ( directionPointer . isLeft ( ) ) { x -= 1 ; } else if ( directionPointer . isTop ( ) ) { y -= 1 ; } mNextCodel . set ( x , y ) ; }
tr	2	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	4	@ Override public void keyPressed ( KeyEvent e ) { int curKeys = e . getKeyCode ( ) ; if ( location == "Map" && movable == true ) { p . setKeyPress ( curKeys ) ; } if ( location == "Encounter" && movable == true ) { enc . setKeyPress ( curKeys ) ; clicked = true ; } }
tr	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
tr	5	private int [ ] setDistancePriority ( int xdiff , int ydiff ) { int priority [ ] = { - 1 , - 1 , - 1 , - 1 } ; if ( ( Math . abs ( xdiff ) > ( Math . abs ( ydiff ) ) ) ) { if ( ( xdiff ) > 0 ) { priority [ 0 ] = 180 ; priority [ 3 ] = 0 ; } else { priority [ 0 ] = 0 ; priority [ 3 ] = 180 ; } if ( ( ydiff ) > 0 ) { priority [ 1 ] = 90 ; priority [ 2 ] = 270 ; } else { priority [ 1 ] = 270 ; priority [ 2 ] = 90 ; } } else { if ( ( ydiff ) > 0 ) { priority [ 0 ] = 90 ; priority [ 3 ] = 270 ; } else { priority [ 0 ] = 270 ; priority [ 3 ] = 90 ; } if ( ( xdiff ) > 0 ) { priority [ 1 ] = 180 ; priority [ 2 ] = 0 ; } else { priority [ 1 ] = 0 ; priority [ 2 ] = 180 ; } } return priority ; }
tr	3	public Request < ModifyPropertyValueRequest > marshall ( ModifyPropertyValueRequest modifyPropertyValueRequest ) { if ( modifyPropertyValueRequest == null ) { throw new AmazonClientException ( "Invalid argument passed to marshall(...)" ) ; } final Request < ModifyPropertyValueRequest > request = new DefaultRequest < > ( modifyPropertyValueRequest , "EucalyptusProperties" ) ; request . addParameter ( "Action" , "ModifyPropertyValue" ) ; request . addParameter ( "Version" , "eucalyptus" ) ; if ( modifyPropertyValueRequest . getName ( ) != null ) { request . addParameter ( "Name" , StringUtils . fromString ( modifyPropertyValueRequest . getName ( ) ) ) ; } if ( modifyPropertyValueRequest . getValue ( ) != null ) { request . addParameter ( "Value" , StringUtils . fromString ( modifyPropertyValueRequest . getValue ( ) ) ) ; } return request ; }
tr	5	public static List < LineItem > transformLineItems ( Detail d ) { List < LineItem > items = d . getLineItem ( ) ; List < LineItem > aggrItems = new ArrayList < LineItem > ( ) ; for ( LineItem l : items ) { boolean duplicate = false ; if ( ! aggrItems . isEmpty ( ) ) { for ( int i = 0 ; i < aggrItems . size ( ) ; i ++ ) { LineItem curr = aggrItems . get ( i ) ; if ( curr . getItemCode ( ) . equals ( l . getItemCode ( ) ) ) { long quantity = curr . getQuantity ( ) . intValue ( ) ; quantity ++ ; curr . setQuantity ( BigDecimal . valueOf ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggrItems . add ( l ) ; } } return aggrItems ; }
tr	6	protected void recurseFields ( final DataFrame frame , final String token , final List < DataField > results ) { if ( frame != null ) { for ( int x = 0 ; x < frame . getFieldCount ( ) ; x ++ ) { final DataField field = frame . getField ( x ) ; String fname = field . getName ( ) ; if ( fname == null ) { fname = "field" + x ; } if ( token != null ) { fname = token + "." + fname ; } if ( field . isFrame ( ) ) { recurseFields ( ( DataFrame ) field . getObjectValue ( ) , fname , results ) ; } else { if ( filter . matches ( fname ) ) { results . add ( field ) ; } } } } }
tr	5	public boolean ehEnPassant ( Posicao posicaoPeca , Posicao lado ) { if ( this . espiarPeca ( posicaoPeca ) . getTipoPeca ( ) == TipoPeca . PEAO ) { if ( ! estaForaDoTabuleiro ( lado ) ) if ( this . estaInimigo ( this . espiarPeca ( posicaoPeca ) . getCorJogador ( ) , lado ) ) if ( this . espiarPeca ( lado ) . getTipoPeca ( ) == TipoPeca . PEAO ) { Peao peaoInimigo = ( Peao ) this . espiarPeca ( lado ) ; if ( peaoInimigo . isPodeEnPassant ( ) ) return true ; } } return false ; }
tr	2	public static int getStats ( ) { if ( found == 0 || all == 0 ) return 0 ; int stats = ( int ) ( ( 100 * found ) / all ) ; return stats ; }
tr	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( declaration == null ) ? 0 : declaration . hashCode ( ) ) ; result = prime * result + ( ( ident == null ) ? 0 : ident . hashCode ( ) ) ; result = prime * result + ( ( statementSequence == null ) ? 0 : statementSequence . hashCode ( ) ) ; return result ; }
tr	0	private void initComponents ( ) { this . blackBox = new JPanel ( ) ; this . redBox = new JPanel ( ) ; this . blueBox = new JPanel ( ) ; this . greenBox = new JPanel ( ) ; this . yellowBox = new JPanel ( ) ; this . orangeBox = new JPanel ( ) ; this . letterLabel = new LetterPanel ( ) ; this . coloursPanel = new JPanel ( ) ; this . blackLabel = new JLabel ( ) ; this . redLabel = new JLabel ( ) ; this . greenLabel = new JLabel ( ) ; this . blueLabel = new JLabel ( ) ; this . yellowLabel = new JLabel ( ) ; this . orangeLabel = new JLabel ( ) ; this . coloursPanel . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( blackBox , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . coloursPanel . add ( blackLabel , c ) ; c . gridx = 0 ; c . gridy = 1 ; this . coloursPanel . add ( redBox , c ) ; c . gridx = 1 ; c . gridy = 1 ; this . coloursPanel . add ( redLabel , c ) ; c . gridx = 0 ; c . gridy = 2 ; this . coloursPanel . add ( greenBox , c ) ; c . gridx = 1 ; c . gridy = 2 ; this . coloursPanel . add ( greenLabel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( blueBox , c ) ; c . gridx = 3 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( blueLabel , c ) ; c . gridx = 2 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( yellowBox , c ) ; c . gridx = 3 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( yellowLabel , c ) ; c . gridx = 2 ; c . gridy = 2 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( orangeBox , c ) ; c . gridx = 3 ; c . gridy = 2 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( orangeLabel , c ) ; this . setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; this . blackBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . BLACK ) ) ; this . blackBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blackBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . redBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . RED ) ) ; this . redBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . redBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . greenBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . GREEN ) ) ; this . greenBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . greenBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . blueBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . BLUE ) ) ; this . blueBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blueBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . yellowBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . YELLOW ) ) ; this . yellowBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . yellowBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . orangeBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . ORANGE ) ) ; this . orangeBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . orangeBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . letterLabel . setBackground ( SystemProperties . WHITE ) ; this . letterLabel . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blackLabel . setText ( "s" ) ; this . blackLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . redLabel . setText ( "r" ) ; this . redLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . greenLabel . setText ( "g" ) ; this . greenLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . blueLabel . setText ( "b" ) ; this . blueLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . yellowLabel . setText ( "y" ) ; this . yellowLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . orangeLabel . setText ( "o" ) ; this . orangeLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . setJMenuBar ( stroopMenu ) ; this . add ( this . letterLabel , BorderLayout . CENTER ) ; this . add ( this . coloursPanel , BorderLayout . SOUTH ) ; this . setTitle ( "Stroop Test" ) ; this . addComponentListener ( this ) ; this . setPreferredSize ( new Dimension ( 800 , 600 ) ) ; this . setLocation ( ( SystemProperties . SCREEN_WIDTH / 2 ) - 400 , ( SystemProperties . SCREEN_HEIGHT / 2 ) - 300 ) ; this . pack ( ) ; }
tr	4	public boolean consumeFuel ( final double mass ) { boolean outOfFuel = false ; if ( preferredFuelTanks . size ( ) == 0 ) { return false ; } final double massPerTank = mass / preferredFuelTanks . size ( ) / propellantRatios . size ( ) ; for ( final VehiclePart fuelTank : preferredFuelTanks ) { for ( final Resource resource : propellantRatios . keySet ( ) ) { final double ratio = propellantRatios . get ( resource ) ; final double resourceMass = fuelTank . getResourceMass ( resource ) ; final double newResourceMass = resourceMass - massPerTank * ratio ; if ( newResourceMass < 0 ) { outOfFuel = true ; } fuelTank . setResourceMass ( resource , Math . max ( 0 , newResourceMass ) ) ; } } return ! outOfFuel ; }
tr	0	@ Before public void setUp ( ) { undertest = new MedianStore ( ) ; }
va	9X	public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setStroke ( new BasicStroke ( 6 ) ) ; BufferedImage bimg = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2img = ( Graphics2D ) bimg . getGraphics ( ) ; g2img . setColor ( Color . black ) ; g2img . fillRect ( 0 , 0 , bimg . getWidth ( ) , bimg . getHeight ( ) ) ; HexMech . setCorner ( corner ) ; for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( i , j , g2img ) ; } } if ( corner . x > 0 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x - 1 , j , g2img ) ; } } if ( corner . y > 0 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y - 1 , g2img ) ; } } if ( corner . x < LocationManager . getSize ( ) . x - 15 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x + 15 , j , g2img ) ; } } if ( corner . y < LocationManager . getSize ( ) . y - 10 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y + 10 , g2img ) ; } } for ( Point p : selectLocs ) { HexMech . selectHex ( p . x , p . y , g2img ) ; } HexMech . cursor ( cursorLoc . x , cursorLoc . y , g2img ) ; g2 . drawImage ( bimg , 0 , 0 , null ) ; }
va	6	protected boolean isValid ( ) { if ( hasCharacter ( ) ) { if ( ! characterData . isValid ( ) ) { return false ; } } for ( TileObjectDisplayData data : itemData ) { if ( ! data . isValid ( ) ) { return false ; } } for ( TileObjectDisplayData data : edgeData . values ( ) ) { if ( ! data . isValid ( ) ) { return false ; } } return true ; }
va	4	public void focusOnHour ( int hour ) { if ( hour > 23 || hour < 0 ) return ; final JScrollBar vs = weekScroll . getVerticalScrollBar ( ) ; if ( hour < SHOWHOURS / 2 ) hour = SHOWHOURS / 2 ; if ( hour > ( 23 - SHOWHOURS / 2 ) ) hour = ( 23 - SHOWHOURS / 2 ) ; hour -= SHOWHOURS / 2 ; vs . setValue ( hour * vs . getMaximum ( ) / 2 / SHOWHOURS ) ; }
va	5	private static void parseAuthority ( URL parsed ) { if ( parsed . href . indexOf ( ":" ) == - 1 && parsed . href . indexOf ( "//" ) == 0 && "" . equals ( parsed . host ) ) { parsed . pathname = parsed . pathname . substring ( 2 ) ; final int idx = parsed . pathname . indexOf ( "/" ) ; if ( idx == - 1 ) { parsed . authority = parsed . pathname ; parsed . pathname = "" ; } else { parsed . authority = parsed . pathname . substring ( 0 , idx ) ; parsed . pathname = parsed . pathname . substring ( idx ) ; } } else { parsed . authority = parsed . host ; if ( ! "" . equals ( parsed . auth ) ) { parsed . authority = parsed . auth + "@" + parsed . authority ; } } }
va	3	@ Override public void run ( ) { Random rand = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 1 ; i <= 10 ; i ++ ) { try { if ( rand . nextInt ( 100 ) % 2 > 0 ) { threadMessage ( i + ". Increasing Counter1" ) ; locked . increase1 ( ) ; } else { threadMessage ( i + ". Increasing Counter2" ) ; locked . increase2 ( ) ; } } catch ( InterruptedException e ) { threadMessage ( "Received Interrupt!" ) ; return ; } } threadMessage ( "Done!" ) ; }
va	0	private void buttonOkMouseEntered ( java . awt . event . MouseEvent evt ) { buttonOk . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/app/images/buttonOkHover_Popup.png" ) ) ) ; }
va	8	public void updateGameLists ( boolean simple , int maxDuration , int numberOfPlayers ) { if ( simple ) { simpleResultgames . clear ( ) ; simpleResultgames . addAll ( allGames ) ; for ( Game game : allGames ) { if ( game . getMin ( ) > numberOfPlayers ) { simpleResultgames . remove ( game ) ; } if ( game . getMax ( ) < numberOfPlayers ) { simpleResultgames . remove ( game ) ; } if ( game . getTime ( ) > maxDuration ) { simpleResultgames . remove ( game ) ; } } } else { complexResultgames . clear ( ) ; for ( Game game : allGames ) { if ( ( game . getMin ( ) <= activePlayers . size ( ) ) && ( game . getMax ( ) >= activePlayers . size ( ) ) ) { complexResultgames . put ( game , getGameScore ( game ) ) ; } } } }
va	7	public ArrayList < PHASE > phasePossible ( PHASE phase ) { ArrayList < PHASE > a_faire = new ArrayList < PHASE > ( ) ; switch ( phase ) { case DEMARRAGE : if ( this . phase_prete != PHASE . CALCUL_TRAJECTOIRES ) a_faire . add ( PHASE . CALCUL_TRAJECTOIRES ) ; else break ; case CALCUL_TRAJECTOIRES : if ( this . phase_prete != PHASE . CHARGEMENT_AVION ) a_faire . add ( PHASE . CHARGEMENT_AVION ) ; else break ; case CHARGEMENT_AVION : if ( this . balises . isEmpty ( ) ) a_faire . add ( PHASE . CHARGEMENT_BALISES ) ; if ( this . aerodromes . isEmpty ( ) ) a_faire . add ( PHASE . CHARGEMENT_AD ) ; break ; default : break ; } return a_faire ; }
va	8	public boolean equals ( remover_args that ) { if ( that == null ) return false ; boolean this_present_registro = true && this . isSetRegistro ( ) ; boolean that_present_registro = true && that . isSetRegistro ( ) ; if ( this_present_registro || that_present_registro ) { if ( ! ( this_present_registro && that_present_registro ) ) return false ; if ( ! this . registro . equals ( that . registro ) ) return false ; } return true ; }
va	5	private void lastNameTextFieldKeyTyped ( java . awt . event . KeyEvent evt ) { lastNameLabel . setForeground ( Color . black ) ; int strLength = lastNameTextField . getText ( ) . length ( ) ; char c = evt . getKeyChar ( ) ; if ( strLength == 30 || ! ( Character . isAlphabetic ( c ) || c == KeyEvent . VK_BACK_SPACE || c == KeyEvent . VK_DELETE || c == KeyEvent . VK_SPACE ) ) { getToolkit ( ) . beep ( ) ; evt . consume ( ) ; } }
va	2	public static boolean isUniqueChars ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = str . charAt ( i ) - a ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
va	7	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , int p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" + " " + p1 ) ; System . out . println ( "]" ) ; AmebaDiv2 obj ; int answer ; obj = new AmebaDiv2 ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . simulate ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	1	@ Test public void test ( ) { Processor proc = new PipelineProcessor ( ) ; proc . configure ( DefaultProperties . defaultEnglishProperties ( "tokenize  ssplit  pos  lemma" ) ) ; String doc = "#TEST Sample tweet @romenesko (shares short excerpts from his online column): Josh Prager resigns from WSJ after 13 years; says he and the paper are no longer a good fit." ; Document document = Preprocessor . create ( null , doc , Splitter . DefaultSplitter . instance ( ) ) ; for ( Sentence sentence : document ) { proc . process ( sentence ) ; } String content = Persister . persist ( document ) ; System . out . println ( content ) ; }
va	0	@ Test public void testQuestionDataBooleanIntQuestionStatisticsQuestionLocationString ( ) { _qd = new MyQuestionData ( _showQuestion , _questionNumber , _questionStatistics , _questionLocation , _questionString ) ; assertEquals ( _showQuestion , _qd . getShowQuestion ( ) ) ; assertEquals ( _questionNumber , _qd . getQuestionNumber ( ) ) ; assertEquals ( _questionStatistics . getCorrectlyAnswered ( ) , _qd . getCorrectlyAnswered ( ) ) ; assertEquals ( _questionStatistics . getPercentCorrect ( ) , _qd . getPercentCorrect ( ) ) ; assertEquals ( _questionStatistics . getTotalTimesAnswered ( ) , _qd . getTotalTimesAnswered ( ) ) ; assertEquals ( _questionLocation , _qd . getLocation ( ) ) ; assertEquals ( _questionString , _qd . getQuestionString ( ) ) ; }
va	9X	private void processMainScreenClick ( ) { if ( minimapState != 0 ) return ; if ( super . clickMode3 == 1 ) { int i = super . saveClickX - 25 - 550 ; int j = super . saveClickY - 5 - 4 ; if ( i >= 0 && j >= 0 && i < 146 && j < 151 ) { i -= 73 ; j -= 75 ; int k = viewRotation + minimapRotation & 7ff ; int i1 = Texture . anIntArray1470 [ k ] ; int j1 = Texture . anIntArray1471 [ k ] ; i1 = i1 * ( minimapZoom + 256 ) >> 8 ; j1 = j1 * ( minimapZoom + 256 ) >> 8 ; int k1 = j * i1 + i * j1 >> 11 ; int l1 = j * j1 - i * i1 >> 11 ; int i2 = myPlayer . x + k1 >> 7 ; int j2 = myPlayer . y - l1 >> 7 ; boolean flag1 = doWalkTo ( 1 , 0 , 0 , 0 , myPlayer . smallY [ 0 ] , 0 , 0 , j2 , myPlayer . smallX [ 0 ] , true , i2 ) ; if ( flag1 ) { outStream1 . put ( i ) ; outStream1 . put ( j ) ; outStream1 . writeWord ( viewRotation ) ; outStream1 . put ( 57 ) ; outStream1 . put ( minimapRotation ) ; outStream1 . put ( minimapZoom ) ; outStream1 . put ( 89 ) ; outStream1 . writeWord ( myPlayer . x ) ; outStream1 . writeWord ( myPlayer . y ) ; outStream1 . put ( anInt1264 ) ; outStream1 . put ( 63 ) ; } } anInt1117 ++ ; if ( anInt1117 > 1151 ) { anInt1117 = 0 ; outStream1 . createFrame ( 246 ) ; outStream1 . put ( 0 ) ; int l = outStream1 . offset ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . put ( 101 ) ; outStream1 . put ( 197 ) ; outStream1 . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; outStream1 . put ( ( int ) ( Math . random ( ) * 256D ) ) ; outStream1 . put ( 67 ) ; outStream1 . writeWord ( 14214 ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . writeWord ( 29487 ) ; outStream1 . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . put ( 220 ) ; outStream1 . put ( 180 ) ; outStream1 . writeBytes ( outStream1 . offset - l ) ; } } }
va	3	public Dimension getRenderedDimension ( Image image , int canvasWidth , int canvasHeight ) { int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; if ( ! flickrFrame . isFullscreen ( ) ) { canvasWidth -= BORDER_SIZE * 2 ; canvasHeight -= BORDER_SIZE * 2 ; } float imageRatio = ( float ) imageWidth / ( float ) imageHeight ; float thisRatio = ( float ) canvasWidth / ( float ) canvasHeight ; int renderedWidth , renderedHeight ; if ( imageRatio > thisRatio ) { renderedWidth = canvasWidth ; renderedHeight = ( int ) ( canvasWidth / imageRatio ) ; } else if ( imageRatio < thisRatio ) { renderedHeight = canvasHeight ; renderedWidth = ( int ) ( canvasHeight * imageRatio ) ; } else { renderedWidth = canvasWidth ; renderedHeight = canvasHeight ; } return new Dimension ( renderedWidth , renderedHeight ) ; }
va	5	public void runKong ( boolean stepbystep , int pausetime ) { if ( points . size ( ) <= 3 ) return ; triangles . clear ( ) ; int index = 1 ; while ( points . size ( ) > 3 ) { if ( stepbystep ) { drawPanel . drawPolygon ( points ) ; drawPanel . drawTriangles ( triangles , Color . BLUE ) ; drawPanel . drawTriangleFromPoints ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) , Color . RED ) ; try { Thread . sleep ( pausetime ) ; } catch ( Exception ex ) { System . out . println ( ex . toString ( ) ) ; } } if ( isEar ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) ) ) { triangles . add ( new Triangle ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) ) ) ; points . remove ( points . get ( index ) ) ; index = getIndex ( index , - 1 ) ; } else { index = getIndex ( index , 1 ) ; } } triangles . add ( new Triangle ( points . get ( 0 ) , points . get ( 1 ) , points . get ( 2 ) ) ) ; }
va	5	private void method45 ( ) { aBoolean1031 = true ; for ( int j = 0 ; j < 7 ; j ++ ) { anIntArray1065 [ j ] = - 1 ; for ( int k = 0 ; k < IDK . length ; k ++ ) { if ( IDK . cache [ k ] . aBoolean662 || IDK . cache [ k ] . anInt657 != j + ( aBoolean1047 ? 0 : 7 ) ) continue ; anIntArray1065 [ j ] = k ; break ; } } }
va	1	@ Override default GCompany C ( List < GDept > gDepts ) { return new GCompany ( ) { public < Company , Dept , SubUnit , Employee , Person , Salary > Company accept ( SybAlg < Company , Dept , SubUnit , Employee , Person , Salary > alg ) { List < Dept > v = new ArrayList < Dept > ( ) ; for ( GDept o : gDepts ) { v . add ( o . accept ( alg ) ) ; } return alg . C ( v ) ; } } ; }
va	2	public int getKey ( Instrument instr ) { Set < Integer > k = bank . keySet ( ) ; for ( Integer i : k ) if ( bank . get ( i ) . equals ( instr ) ) return i ; return - 1 ; }
va	0	@ Override public void releaseSavepoint ( Savepoint savepoint ) throws SQLException { }
va	7	public void draw ( ) { if ( drawable ) { if ( currentspriteexists ( ) ) { if ( drawmode == 2 ) { mainscreen . screengraphics . drawImage ( image . get ( currentspritenumber ) . getimage ( ) , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , ( int ) ( x + spriteoffsetx + boundsx ) , ( int ) ( y + spriteoffsety + boundsy ) , ( int ) ( spriteoffsetx ) , ( int ) ( spriteoffsety ) , ( int ) ( spriteoffsetx + boundsx ) , ( int ) ( spriteoffsety + boundsy ) , null ) ; } else if ( drawmode == 3 ) { boolean drawsuccess = false ; try { Image tempimage = image . get ( currentspritenumber ) . getimage ( ) . getScaledInstance ( ( int ) ( getsizex ( ) ) , ( int ) ( getsizey ( ) ) , Image . SCALE_FAST ) ; do { drawsuccess = mainscreen . screengraphics . drawImage ( tempimage , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , null ) ; } while ( ! drawsuccess ) ; } catch ( Exception e ) { } } else { mainscreen . screengraphics . drawImage ( image . get ( currentspritenumber ) . getimage ( ) , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , null ) ; } } else { mainscreen . screengraphics . setColor ( drawcolor ) ; mainscreen . screengraphics . drawRect ( ( int ) ( x ) , ( int ) ( y ) , ( int ) boundsx , ( int ) boundsy ) ; } } if ( debugbounds ) { mainscreen . screengraphics . setColor ( drawcolor ) ; mainscreen . screengraphics . drawRect ( ( int ) ( x ) , ( int ) ( y ) , ( int ) getsizex ( ) , ( int ) getsizey ( ) ) ; } }
va	8	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class < ? > c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
va	0	public SocketNaoConectado ( String string ) { super ( string ) ; }
va	9X	public static long nameToLong ( String name ) { long longName = 0 ; for ( int c = 0 ; c < name . length ( ) && c < 12 ; c ++ ) { char character = name . charAt ( c ) ; longName *= 37 ; if ( character >= A && character <= Z ) longName += ( 1 + character ) - 65 ; else if ( character >= a && character <= z ) longName += ( 1 + character ) - 97 ; else if ( character >= 0 && character <= 9 ) longName += ( 27 + character ) - 48 ; } for ( ; longName % 37 == 0 && longName != 0 ; longName /= 37 ) ; return longName ; }
va	0	public static Length getLength ( Element e ) { return e . getLength ( ) ; }
va	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Square square = ( Square ) o ; if ( x != square . x ) return false ; if ( y != square . y ) return false ; return true ; }
va	7	private boolean center2Div ( Lexer lexer , Node node , MutableObject pnode ) { if ( node . tag == tt . tagCenter ) { if ( lexer . configuration . DropFontTags ) { if ( node . content != null ) { Node last = node . last ; Node parent = node . parent ; discardContainer ( node , pnode ) ; node = lexer . inferredTag ( "br" ) ; if ( last . next != null ) last . next . prev = node ; node . next = last . next ; last . next = node ; node . prev = last ; if ( parent . last == last ) parent . last = node ; node . parent = parent ; } else { Node prev = node . prev ; Node next = node . next ; Node parent = node . parent ; discardContainer ( node , pnode ) ; node = lexer . inferredTag ( "br" ) ; node . next = next ; node . prev = prev ; node . parent = parent ; if ( next != null ) next . prev = node ; else parent . last = node ; if ( prev != null ) prev . next = node ; else parent . content = node ; } return true ; } node . tag = tt . tagDiv ; node . element = "div" ; addStyleProperty ( node , "text-align: center" ) ; return true ; } return false ; }
va	9X	private static void analyseChildElement ( Element element , String parentKey ) { String name = element . getName ( ) ; int index = name . indexOf ( ":" ) ; if ( index != - 1 ) { name = name . substring ( index + 1 , name . length ( ) ) ; } String key = parentKey += "." + name ; if ( element . getChildElements ( ) . size ( ) == 0 ) { String id = null ; boolean saveKeyValue = true ; String value = "" ; if ( name . equalsIgnoreCase ( "question" ) ) { id = element . getAttributeValue ( "id" ) ; if ( id != null ) { key = key + "." + id ; value = element . getAttributeValue ( "selected_ans" ) ; } } else if ( key . indexOf ( "profile" ) > 0 ) { value = element . getAttributeValue ( "value" ) ; } for ( KeyValue tmpObject : keyValues ) { if ( tmpObject . getKey ( ) . indexOf ( key ) >= 0 ) { saveKeyValue = false ; break ; } } if ( saveKeyValue ) keyValues . add ( new KeyValue ( key , value ) ) ; } else { List < Element > children = element . getChildElements ( ) ; for ( Element child : children ) { analyseChildElement ( child , key ) ; } } }
va	5	static synchronized void setFilename ( String filename ) { if ( writer != null ) { try { writer . close ( ) ; writer = null ; } catch ( IOException e ) { System . out . println ( "Unable to close log file" ) ; } } if ( filename == null ) { writer = null ; return ; } FileWriter out = null ; try { out = new FileWriter ( filename ) ; } catch ( IOException e ) { System . out . println ( "Unable to open log file: " + filename ) ; writer = null ; return ; } if ( out != null ) { writer = new BufferedWriter ( out ) ; } }
va	1	private String averageGrade ( final Student student ) { double averageGrade = student . averageGrade ( ) ; if ( averageGrade == - 1 ) { return "-" ; } return String . format ( "%.02f" , averageGrade ) ; }
va	6	protected static void setEnvironment ( boolean disableHttp , boolean eagerHttpFallback , boolean disableDirectSocket , boolean enableDirectHTTP , boolean disablePlainHTTP , boolean useProxy , long connectionTimeout , boolean logging ) { System . setProperty ( "java.rmi.dgc.leaseValue" , Integer . toString ( GC_TIMEOUT ) ) ; System . setProperty ( "java.rmi.server.disableHttp" , boolean . toString ( disableHttp ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.eagerHttpFallback" , boolean . toString ( eagerHttpFallback ) ) ; System . setProperty ( "harmony.rmi.transport.disableDirectSocket" , boolean . toString ( disableDirectSocket ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.enableDirectHTTP" , boolean . toString ( enableDirectHTTP ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.disablePlainHTTP" , boolean . toString ( disablePlainHTTP ) ) ; System . setProperty ( "http.proxyHost" , ( useProxy ? PROXY_HOST : "" ) ) ; System . setProperty ( "http.proxyPort" , ( useProxy ? Integer . toString ( PROXY_PORT ) : "" ) ) ; System . setProperty ( "harmony.rmi.transport.connectionTimeout" , ( ( connectionTimeout > 0 ) ? long . toString ( connectionTimeout ) : "" ) ) ; System . setProperty ( "harmony.rmi.dgc.logLevel" , "VERBOSE" ) ; System . setProperty ( "harmony.rmi.transport.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; System . setProperty ( "harmony.rmi.transport.tcp.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; }
va	8	public List < Tuple < Integer , Integer >> aStar ( Tuple < Integer , Integer > start , Tuple < Integer , Integer > goal ) { HashSet < Tuple < Integer , Integer >> closedSet = new HashSet < Tuple < Integer , Integer >> ( ) ; HashSet < Tuple < Integer , Integer >> openSet = new HashSet < Tuple < Integer , Integer >> ( ) ; openSet . add ( start ) ; HashMap < Tuple < Integer , Integer > , Tuple < Integer , Integer >> cameFrom = new HashMap < Tuple < Integer , Integer > , Tuple < Integer , Integer >> ( ) ; HashMap < Tuple < Integer , Integer > , Integer > g_score = new HashMap < Tuple < Integer , Integer > , Integer > ( ) ; g_score . put ( start , 0 ) ; HashMap < Tuple < Integer , Integer > , Integer > f_score = new HashMap < Tuple < Integer , Integer > , Integer > ( ) ; f_score . put ( start , g_score . get ( start ) + heuristicCostEstimate ( start , goal ) ) ; while ( ! openSet . isEmpty ( ) ) { int lowestF = Integer . MAX_VALUE ; Tuple < Integer , Integer > current = null ; for ( Tuple < Integer , Integer > node : openSet ) { if ( f_score . get ( node ) < lowestF ) { lowestF = f_score . get ( node ) ; current = node ; } } if ( current . equals ( goal ) ) { return reconstructPath ( cameFrom , goal ) ; } openSet . remove ( current ) ; closedSet . add ( current ) ; HashSet < Tuple < Integer , Integer >> neighbor_nodes = getNeighborNodes ( current ) ; for ( Tuple < Integer , Integer > neighbor : neighbor_nodes ) { if ( closedSet . contains ( neighbor ) ) continue ; int tentative_g_score = g_score . get ( current ) + 1 ; if ( ! openSet . contains ( neighbor ) || tentative_g_score < g_score . get ( neighbor ) ) { openSet . add ( neighbor ) ; cameFrom . put ( neighbor , current ) ; g_score . put ( neighbor , tentative_g_score ) ; f_score . put ( neighbor , g_score . get ( neighbor ) + heuristicCostEstimate ( neighbor , goal ) ) ; } } } log . error ( "A* is returning null! This should never happen!" ) ; return null ; }
va	9X	@ SuppressWarnings ( { "static-access" } ) private static void getConfig ( ) throws IOException { File file = new File ( "C:\\temp\\config.txt" ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; String line = null ; Phone . AllExtensions = new ArrayList < String > ( ) ; Phone . usualExtensions = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . startsWith ( "Speaker" ) ) { Phone . MainExtension = line . substring ( 22 ) . trim ( ) ; Phone . AllExtensions . add ( line . substring ( 22 ) . trim ( ) ) ; } if ( line . startsWith ( "Phone number" ) ) { Phone . usualExtensions . add ( line . substring ( 14 ) . trim ( ) ) ; Phone . AllExtensions . add ( line . substring ( 14 ) . trim ( ) ) ; } if ( line . startsWith ( "Ip adress" ) ) Phone . AsteriskIp = line . substring ( 20 ) . trim ( ) ; else if ( line . startsWith ( "WriteUser" ) ) Phone . WriteUser = line . substring ( 11 ) . trim ( ) ; else if ( line . startsWith ( "WritePassword" ) ) Phone . WriteUserPassword = line . substring ( 15 ) . trim ( ) ; else if ( line . startsWith ( "Context" ) ) Phone . Context = line . substring ( 9 ) . trim ( ) ; else if ( line . startsWith ( "Skin" ) ) skin = line . substring ( 7 ) . trim ( ) ; else if ( line . startsWith ( "ReadUser" ) ) Phone . ReadUser = line . substring ( 10 ) . trim ( ) ; else if ( line . startsWith ( "ReadPassword" ) ) Phone . ReadUserPassword = line . substring ( 14 ) . trim ( ) ; else if ( line . startsWith ( "UsersInfoFile" ) ) UsersInfoFile = line . substring ( 15 ) . trim ( ) ; else if ( line . startsWith ( "PhotoFolder" ) ) Phone . PhotoFolder = line . substring ( 13 ) . trim ( ) ; else if ( line . startsWith ( "DefaultPhoto" ) ) Phone . DefaultPhoto = line . substring ( 14 ) . trim ( ) ; } br . close ( ) ; }
va	7	protected INDIProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission , int timeout ) throws IllegalArgumentException { this . driver = driver ; if ( name == null ) { throw new IllegalArgumentException ( "No name for the Property" ) ; } name = name . trim ( ) ; if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "No name for the Property" ) ; } this . name = name ; if ( label == null ) { this . label = name ; } else { label = label . trim ( ) ; if ( label . length ( ) == 0 ) { this . label = name ; } else { this . label = label ; } } if ( group == null ) { group = "Unsorted" ; } group = group . trim ( ) ; if ( group . length ( ) == 0 ) { group = "Unsorted" ; } this . group = group ; this . state = state ; this . permission = permission ; if ( timeout < 0 ) { this . timeout = 0 ; } else { this . timeout = timeout ; } this . elements = new LinkedHashMap < String , INDIElement > ( ) ; this . saveable = false ; isInit = false ; }
va	2	private int getBaseScore ( Sequence sequence ) { int length = sequence . getSequence ( ) . length ( ) ; if ( length < 4 ) return 10 ; if ( length < 7 ) return 20 ; else return 40 ; }
va	1	protected void fireChangeEvent ( ) { for ( ChangeListener l : getChangeListeners ( ) ) { l . stateChanged ( changeEvent ) ; } }
va	8	public static void main ( String [ ] args ) { RandomSearchInitialisation starter = new RandomSearchInitialisation ( ) ; starter . initLanguage ( new char [ ] { a , b } , 10 , "[ab]*abab" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 50 ; problemCount [ 1 ] = 100 ; problemCount [ 2 ] = 150 ; problemCount [ 3 ] = 200 ; problemCount [ 4 ] = 250 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "RAND_ABAB_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = 0 ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
va	4	private void joinChan ( Connection connection , String chanName , boolean newChan ) { Chan myChan = connection . joinChan ( chanName ) ; logger . debug ( "Sending Join to others chan users" ) ; connection . meSendCommandToChannel ( chanName , "JOIN :" + chanName ) ; if ( newChan ) { connection . serverSendCommandToMe ( "331 RPL_NOTOPIC " + chanName + " :No topic is set" ) ; } else { if ( myChan . getTopic ( ) != null && myChan . getTopic ( ) . length ( ) > 0 ) { connection . serverSendCommandToMe ( "332 RPL_TOPIC " + chanName + " :" + myChan . getTopic ( ) ) ; } else { connection . serverSendCommandToMe ( "331 RPL_NOTOPIC " + chanName + " :No topic is set" ) ; } } StringBuffer nickList = new StringBuffer ( ) ; for ( Connection con : myChan . getConnections ( ) . keySet ( ) ) { nickList . append ( myChan . getConnections ( ) . get ( con ) ) ; nickList . append ( con . getNickname ( ) ) ; nickList . append ( " " ) ; } connection . serverSendCommandToMe ( "353 RPL_NAMREPLY " + chanName + " :" + nickList . toString ( ) ) ; connection . serverSendCommandToMe ( "366 RPL_ENDOFNAMES " + chanName + " :End of /NAMES list" ) ; }
va	2	public void createRestartFile ( String header , int dateIndex , int depthIndex ) { File infile = new File ( header ) ; String outputName = outputFolder + "/" + sdf . format ( releaseDates [ dateIndex ] ) + "_" + mindepths [ depthIndex ] + "-" + maxdepths [ depthIndex ] + ".prm" ; File outfile = new File ( restartFile ) ; try { copyFileUsingStream ( infile , outfile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( outfile , true ) ) ; ) { bw . write ( "(java " + prms + " -jar " + jarfile + " " + outputName + " " + configurationFile + " " + source + " > " + logdir + "/" + prefix + dateIndex + "D" + depthIndex + ".log)&\n" ) ; bw . write ( cronString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	9X	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
va	5	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jScrollPane = new javax . swing . JScrollPane ( ) ; DefaultMutableTreeNode top = new DefaultMutableTreeNode ( "HelpDesk" ) ; createNodes ( top ) ; tree = new javax . swing . JTree ( top ) ; ExitButton = new javax . swing . JButton ( ) ; ReplyButton = new javax . swing . JButton ( ) ; htmlView = new javax . swing . JScrollPane ( ) ; htmlPane = new javax . swing . JEditorPane ( ) ; viewScheduleButton = new javax . swing . JButton ( ) ; setAssistantsButton = new javax . swing . JButton ( ) ; controlFormsButton = new javax . swing . JButton ( ) ; accessScheduleButton = new javax . swing . JButton ( ) ; accessFormsButton = new javax . swing . JButton ( ) ; PostButton = new javax . swing . JButton ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; tree . addTreeSelectionListener ( this ) ; jScrollPane . setViewportView ( tree ) ; ExitButton . setText ( "Sign Off" ) ; ExitButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ExitButtonActionPerformed ( evt ) ; } } ) ; ReplyButton . setText ( "Reply" ) ; ReplyButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ReplyButtonActionPerformed ( evt ) ; } } ) ; htmlPane . setEditable ( false ) ; initHelp ( ) ; htmlPane . setCursor ( new java . awt . Cursor ( java . awt . Cursor . TEXT_CURSOR ) ) ; htmlView . setViewportView ( htmlPane ) ; if ( userType == 3 ) { } else { viewScheduleButton . setVisible ( false ) ; } viewScheduleButton . setText ( "Schedule Control" ) ; viewScheduleButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { viewScheduleButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 3 ) { } else { setAssistantsButton . setVisible ( false ) ; } setAssistantsButton . setText ( "Set Assistants" ) ; setAssistantsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { setAssistantsButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 2 ) { } else { controlFormsButton . setVisible ( false ) ; } controlFormsButton . setText ( "Forms" ) ; controlFormsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { controlFormsButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 2 ) { } else { accessScheduleButton . setVisible ( false ) ; } accessScheduleButton . setText ( "My Schedule" ) ; accessScheduleButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { accessScheduleButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 1 ) { } else { accessFormsButton . setVisible ( false ) ; } accessFormsButton . setText ( "My Forms" ) ; accessFormsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { accessFormsButtonActionPerformed ( evt ) ; } } ) ; PostButton . setText ( "Post" ) ; PostButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { PostButtonActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 0 , 0 , short . MAX_VALUE ) . addComponent ( PostButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( ReplyButton ) ) . addComponent ( htmlView ) . addComponent ( jScrollPane ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( ExitButton ) . addGap ( 42 , 42 , 42 ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( accessFormsButton ) . addComponent ( accessScheduleButton ) . addComponent ( controlFormsButton ) . addComponent ( setAssistantsButton ) . addComponent ( viewScheduleButton ) ) ) . addGap ( 22 , 22 , 22 ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jScrollPane , javax . swing . GroupLayout . PREFERRED_SIZE , 149 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( htmlView , javax . swing . GroupLayout . DEFAULT_SIZE , 331 , short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( ReplyButton ) . addComponent ( PostButton ) ) . addGap ( 77 , 77 , 77 ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( ExitButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( accessFormsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( accessScheduleButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( controlFormsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( setAssistantsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( viewScheduleButton ) . addContainerGap ( 424 , short . MAX_VALUE ) ) ) ) ) ; pack ( ) ; }
va	1	private Activity getCompassActivity ( ) { if ( compassFunctionalityVerfiedActivity == null ) { compassFunctionalityVerfiedActivity = new CompassFunctionalityVerfiedActivity ( clientFactory ) ; } return compassFunctionalityVerfiedActivity ; }
va	0	public void setProdCodeGrp ( ProdCodeGrp value ) { this . prodCodeGrp = value ; }
va	9X	private boolean newlineIsWhitespace ( String set ) { int len = ( set != null ) ? set . length ( ) : 0 ; char start , end , setChar ; boolean crFound = false ; boolean lfFound = false ; for ( int ii = 0 ; ii < len ; ++ ii ) { switch ( setChar = set . charAt ( ii ) ) { case - : start = ( ii > 0 ) ? set . charAt ( ii - 1 ) : 0 ; end = ( ii < len - 1 ) ? set . charAt ( ii + 1 ) : FFFF ; if ( '' >= start && '' <= end ) { lfFound = true ; } if ( '' >= start && '' <= end ) { crFound = true ; } ii += 2 ; break ; case '' : crFound = true ; break ; case '' : lfFound = true ; break ; case \ : ii ++ ; break ; } if ( crFound && lfFound ) { return true ; } } return false ; }
va	0	public BaseInformation ( ) { this . ecrireInformations ( ) ; }
va	4	public void editFile ( int fileInodeNum ) throws PermissionDeniedException , FileNotFoundException { Inode fileInode = new Inode ( fileInodeNum ) ; if ( Directory . isReadable ( fileInode ) ) { if ( fileInode . getFileType ( ) == r ) { File tempFile = null ; String content = fileInode . getFileContent ( ) ; try { tempFile = new File ( Disk . tmpFolder . toString ( ) + "/" + fileInodeNum + ".txt" ) ; if ( tempFile . exists ( ) ) { tempFile . delete ( ) ; tempFile . createNewFile ( ) ; } tempFile . deleteOnExit ( ) ; RandomAccessFile tempRF = new RandomAccessFile ( tempFile , "rw" ) ; tempRF . writeBytes ( content ) ; Desktop . getDesktop ( ) . open ( tempFile ) ; tempRF . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else throw new PermissionDeniedException ( ) ; }
va	4	public EpisodeMatch matchElementOrThrow ( Path path , MatchElement requiredMatch ) throws MatchElementNotFoundException { EpisodeMatch e = match ( path ) ; if ( e == null ) { return null ; } switch ( requiredMatch ) { case SHOW : assertHasShow ( e , path ) ; break ; case SEASON : assertHasSeason ( e , path ) ; break ; case ALL : assertHasShow ( e , path ) ; assertHasSeason ( e , path ) ; } return e ; }
va	3	private static char getNrMinesCornerCase ( char [ ] [ ] m , int r , int c , int rAdjInd , int cAdjInd ) { int n = 0 ; if ( m [ r ] [ c + cAdjInd ] == MINE ) { n ++ ; } if ( m [ r + rAdjInd ] [ c ] == MINE ) { n ++ ; } if ( m [ r + rAdjInd ] [ c + cAdjInd ] == MINE ) { n ++ ; } return ( char ) ( 0 + n ) ; }
va	4	@ Override public void visit ( FSP_TresholdOrJoin g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| TSH_OR_JOIN }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
va	9X	private void setAirtimes ( PrintWriter out , int day , int startHour , int endHour , int startMinute , int endMinute , String startValue , String endValue ) { if ( startValue . equals ( "PM" ) && startHour != 12 ) { startHour += 12 ; } if ( startValue . equals ( "AM" ) && startHour == 12 ) { startHour = 0 ; } if ( endValue . equals ( "PM" ) && endHour != 12 ) { endHour += 12 ; } if ( endValue . equals ( "AM" ) && endHour == 12 ) { endHour = 0 ; } int mins = 0 ; if ( endHour >= startHour ) { mins = ( ( endHour - startHour ) * 60 + endMinute ) - startMinute ; } else if ( endHour == 0 ) { mins = ( 24 - startHour ) * 60 + ( endMinute - startMinute ) ; } else { mins = endHour * 60 + endMinute + ( 24 - startHour ) * 60 - startMinute ; } out . println ( mins ) ; out . println ( "* " + startMinute + " " + startHour + " ? * " + day ) ; }
va	8	@ Override public void run ( ) { int whatdo = Random . nextInt ( 0 , 10 ) ; switch ( whatdo ) { case 0 : case 1 : Mouse . move ( Random . nextInt ( 0 , 750 ) , Random . nextInt ( 16 , 500 ) ) ; break ; case 2 : case 3 : case 5 : case 4 : case 7 : case 8 : Camera . setAngle ( Random . nextInt ( 0 , 360 ) ) ; break ; default : Camera . setAngle ( Random . nextInt ( 0 , 360 ) ) ; break ; } }
va	6	private void write ( SelectionKey key ) throws IOException { SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; synchronized ( pendingData ) { BlockingQueue < ByteBuffer > queue = pendingData . get ( socketChannel ) ; while ( queue != null && ! queue . isEmpty ( ) ) { ByteBuffer buffer ; try { buffer = queue . take ( ) ; socketChannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { break ; } queue . remove ( 0 ) ; } catch ( InterruptedException e ) { log . error ( "" , e ) ; } } if ( queue != null && queue . isEmpty ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
va	2	@ Override public int compareTo ( RequestEvent requestEvent ) { if ( this . time < requestEvent . time ) return - 1 ; else if ( this . time > requestEvent . time ) return 1 ; else return 0 ; }
va	2	public String getColumnName ( int column ) { switch ( column ) { case 0 : return "Game" ; case 1 : return "\u21BB" ; default : return "" ; } }
va	7	public synchronized void toggleSpeed ( boolean faster ) { if ( faster && speedup >= 1 ) { if ( speedup >= 99 ) return ; speedup ++ ; } else if ( faster && speedup < 1 ) { speedup += 0.1 ; } else if ( speedup > 1 ) { speedup -- ; } else if ( speedup > 0.10f ) { speedup -= 0.10f ; } updateSpeedupLabel ( ) ; setCmd ( Commands . REPAINTLABEL ) ; }
va	9X	public ProgrammerAction ( String title , String tooltip , char mnemonic , String smallIcon , String largeIcon , KeyStroke accelerator ) { super ( ) ; if ( title != null && title . length ( ) > 0 ) putValue ( NAME , title ) ; if ( tooltip != null && tooltip . length ( ) > 0 ) putValue ( SHORT_DESCRIPTION , tooltip ) ; if ( smallIcon != null && smallIcon . length ( ) > 0 ) putValue ( SMALL_ICON , new ImageIcon ( getClass ( ) . getResource ( "icons/16/" + smallIcon ) ) ) ; if ( largeIcon != null && largeIcon . length ( ) > 0 ) putValue ( LARGE_ICON_KEY , new ImageIcon ( getClass ( ) . getResource ( "icons/32/" + largeIcon ) ) ) ; if ( mnemonic > 0 ) putValue ( MNEMONIC_KEY , KeyEvent . getExtendedKeyCodeForChar ( mnemonic ) ) ; if ( accelerator != null ) putValue ( ACCELERATOR_KEY , accelerator ) ; }
va	1	public void setPieceX ( int x ) { if ( ! m_dropping ) { m_pieceX = x ; repaint ( ) ; } }
va	5	public void movePhoto ( ) { if ( newAlbumName != null && ! newAlbumName . equals ( "" ) ) { int code = this . control . movePhoto ( this . photo . getFilename ( ) , this . album , this . newAlbumName ) ; if ( code == - 1 ) { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "Photo Already in that album." ) ; } else if ( code == 1 ) { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "Photo Correctly Moved." ) ; this . movePopUp . setVisible ( false ) ; try { this . photosScreen . reDrawPhotos ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } } } else { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "No Album Selected." ) ; } }
va	8	@ Override public boolean mouseClicked ( int mouseButton , int mouseX , int mouseY ) { if ( ! this . enabled || mouseButton != 0 ) { return false ; } if ( mouseX >= this . posX && mouseX <= this . posX + this . width && mouseY >= this . posY && mouseY <= this . posY + this . height ) { if ( mouseX < this . posX + this . width - 20 ) { int index = ( mouseY - this . posY ) / 20 + this . scroll ; if ( index > this . elements . size ( ) - 1 ) { return false ; } this . selectedIndex = index ; } else { } return true ; } return false ; }
va	4	public QPixmap requestMinimap ( String mapName , MapManagerCb runnable ) { File file ; byte [ ] bbuf ; QPixmap img ; mapName = mapName . replace (   , _ ) ; if ( cache . get ( mapName ) != null ) { return cache . get ( mapName ) ; } file = new File ( String . format ( "~/qsl/miniMapCache/%s.jpg" , mapName ) ) ; if ( file . exists ( ) ) { RandomAccessFile raf ; try { raf = new RandomAccessFile ( file , "rw" ) ; bbuf = new byte [ ( int ) raf . length ( ) ] ; raf . read ( bbuf ) ; raf . close ( ) ; img = new QPixmap ( ) ; img . loadFromData ( bbuf ) ; return img ; } catch ( FileNotFoundException ex ) { System . out . printf ( "warning: could not access minimap in ~/qsl/miniMapCache/" ) ; } catch ( IOException ex ) { System . out . printf ( "warning: could not access minimap in ~/qsl/miniMapCache/" ) ; } } requests . add ( new Pair ( mapName , runnable ) ) ; synchronized ( requests ) { requests . notify ( ) ; } return null ; }
va	5	public void piirraVierusLiitokset ( Graphics g , ArrayList < int [ ] > muoto , int x , int y ) { for ( int i = 0 ; i < muoto . size ( ) ; i ++ ) { int [ ] piste = muoto . get ( i ) ; int pisteXPos = x + piste [ 0 ] ; int pisteYPos = y + piste [ 1 ] ; if ( vierusPiste ( muoto , i , 1 , 0 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , pisteYPos * sivu + sisennys , sivu * 2 - sisennys * 2 , sivu - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , - 1 , 0 ) ) { g . fillRect ( ( pisteXPos - 1 ) * sivu , pisteYPos * sivu + sisennys , sivu * 2 - sisennys * 2 , sivu - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , 0 , 1 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , pisteYPos * sivu + sisennys , sivu - sisennys * 2 , sivu * 2 - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , 0 , - 1 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , ( pisteYPos - 1 ) * sivu , sivu - sisennys * 2 , sivu - sisennys * 2 ) ; } } }
va	5	public void update ( Observable o , Object arg ) { if ( ! ( arg instanceof String ) ) { return ; } SpitfireMessage message = new SpitfireMessage ( ( String ) arg ) ; if ( ! message . isValid ( ) ) return ; if ( "RA" . equals ( message . getApplication ( ) ) || "RS" . equals ( message . getApplication ( ) ) ) { final VizNode thisNode = displayNode ( message . getSrcMac ( ) ) ; if ( "000000000000ffff" . equals ( message . getDstMac ( ) ) ) { thisNode . bcastEvent ( Color . green . getRGB ( ) , message . getPayloadLength ( ) , "" ) ; } else { final VizNode otherNode = displayNode ( message . getDstMac ( ) ) ; VizLink link = displayLink ( thisNode , otherNode , VizLink . LINK_BI ) ; thisNode . sendPacket ( link , Color . green . getRGB ( ) , message . getPayload ( ) . length ( ) , thisNode , otherNode ) ; } } }
va	9X	private static int method507 ( char ac [ ] , int j , char ac1 [ ] ) { if ( j == 0 ) return 2 ; for ( int k = j - 1 ; k >= 0 ; k -- ) { if ( ! method517 ( ac [ k ] ) ) break ; if ( ac [ k ] ==   || ac [ k ] == . ) return 3 ; } int l = 0 ; for ( int i1 = j - 1 ; i1 >= 0 ; i1 -- ) { if ( ! method517 ( ac1 [ i1 ] ) ) break ; if ( ac1 [ i1 ] == * ) l ++ ; } if ( l >= 3 ) return 4 ; return ! method517 ( ac [ j - 1 ] ) ? 0 : 1 ; }
va	4	private static int method515 ( char ac [ ] , int i ) { for ( int k = i ; k < ac . length && k >= 0 ; k ++ ) if ( ac [ k ] >= 0 && ac [ k ] <= 9 ) return k ; return - 1 ; }
va	5	public FileChain ( String path , boolean singleNode , File ... node ) throws FileException { super ( path ) ; this . singleNode = singleNode ; if ( singleNode ) { if ( node . length != 1 ) { throw FileException . NODE_AND_NODEARY_MISMATCH ; } pNodes = null ; pNode = node [ 0 ] ; } else { pNode = null ; pNodes = node ; } if ( pNodes != null ) { for ( int i = 0 ; i < pNodes . length ; i ++ ) { if ( this == pNodes [ i ] ) { thisIndex = i ; currentIndex = i ; } } } else { currentIndex = - 1 ; thisIndex = - 1 ; } }
va	4	private void lazyCopyElements ( ) { if ( datanew != null && min < data . length ) { Node < K , V > node = data [ min ] ; min ++ ; Node < K , V > p = node ; while ( p != null ) { Node < K , V > nexNode = p . next ; p . next = null ; insert ( p ) ; p = nexNode ; } data [ min - 1 ] = null ; } if ( min == data . length ) { data = datanew ; datanew = null ; min = 0 ; } }
va	3	public void addDiploma ( Diploma diploma ) { boolean notFound = true ; for ( Diploma item : diplomas ) { if ( diploma . getName ( ) . equalsIgnoreCase ( item . getName ( ) ) ) { notFound = false ; break ; } } if ( notFound ) { diplomas . add ( diploma ) ; } }
va	4	@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; boolean first = true ; for ( Map . Entry < String , LinkedHashSet < String >> pair : values . entrySet ( ) ) { if ( ! first ) result . append ( / ) ; result . append ( pair . getKey ( ) ) ; for ( String v : pair . getValue ( ) ) { if ( identRegex . matcher ( v ) . matches ( ) ) result . append ( . ) . append ( v ) ; else result . append ( ".'" ) . append ( v . replace ( "'" , "\\'" ) ) . append ( ' ) ; } first = false ; } return result . toString ( ) ; }
va	3	private GenericTree < LayoutParserTreeElement > parseXML ( String layoutXML ) { GenericTree < LayoutParserTreeElement > newTree = new GenericTree < LayoutParserTreeElement > ( ) ; Document result = null ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; InputSource source = new InputSource ( new StringReader ( layoutXML ) ) ; try { result = factory . newDocumentBuilder ( ) . parse ( source ) ; } catch ( SAXException e ) { ErrorMessage . show ( "Eroare SAX" , false ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { ErrorMessage . show ( "Eroare IOException" , false ) ; e . printStackTrace ( ) ; } catch ( ParserConfigurationException e ) { ErrorMessage . show ( "Eroare ParserConfigurationException" , false ) ; e . printStackTrace ( ) ; } Match documentRoot = $ ( result ) . first ( ) ; saveImageFromXML ( documentRoot ) ; GenericTreeNode < LayoutParserTreeElement > rootDocument = parseXMLRow ( documentRoot ) ; newTree . setRoot ( rootDocument ) ; return newTree ; }
va	2	@ Override public void actualizarEstado ( Subasta subasta ) { Calendar fechaActual = Calendar . getInstance ( ) ; if ( subasta . getPeriodoActivo ( ) . incluyeA ( fechaActual ) ) { Activa activa = new Activa ( ) ; subasta . setEstado ( activa ) ; } else { if ( fechaActual . before ( subasta . getPeriodoActivo ( ) . getFechaInicio ( ) ) ) { EnPromocion enPromocion = new EnPromocion ( ) ; subasta . setEstado ( enPromocion ) ; } } }
va	6	public boolean cqualifier ( char type ) throws Exception { int c = read ( ) ; if ( c != type ) { unread ( ) ; return false ; } handler . event ( type == [ ? Types . INDEX : Types . SELECTOR ) ; handler . inc ( ) ; space ( ) ; expression ( ) ; space ( ) ; handler . dec ( ) ; handler . dec ( ) ; c = read ( ) ; if ( type == [ && c != ] ) throw new SyntaxException ( "missing ]" ) ; else if ( type == { && c != } ) throw new SyntaxException ( "missing }" ) ; return true ; }
va	1	public int getBlankPosition ( ) { return mPosition < HORIZONTAL_BLANK ? mPosition : HORIZONTAL_BLANK - 1 ; }
va	8	public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( "d:\\programDATA\\Dancing With the Googlers\\B-small-practice.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\programDATA\\Dancing With the Googlers\\B-small-practice.out" ) ) ) ; int Numcase = in . nextInt ( ) ; for ( int curr = 1 ; curr <= Numcase ; curr ++ ) { in . nextLine ( ) ; int N = in . nextInt ( ) ; int S = in . nextInt ( ) ; int P = in . nextInt ( ) ; int a [ ] = new int [ N ] ; int y = 0 ; int remainder = 0 ; int quotient = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { quotient = a [ i ] / 3 ; remainder = a [ i ] % 3 ; if ( quotient >= P ) y ++ ; else if ( quotient + 1 == P ) { if ( remainder == 2 ) { } if ( remainder == 1 ) { } if ( remainder == 0 ) { } } } } }
va	8	@ Override public void close ( ) throws IOException { if ( os != null ) { try { os . flush ( ) ; os . close ( ) ; os = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fs != null ) { try { fs . close ( ) ; fs = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( is != null ) { try { is . close ( ) ; is = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fi != null ) { try { fi . close ( ) ; fi = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } connectionInStatus = false ; connectionOutStatus = false ; }
va	0	public double getFear ( ) { return fear ; }
va	8	private boolean InputScreen ( ) { m_ComboPlayer1Type = new JComboBox ( m_PlayerTypes ) ; m_ComboPlayer1Type . setSelectedIndex ( 0 ) ; m_ComboPlayer2Type = new JComboBox ( m_PlayerTypes ) ; m_ComboPlayer2Type . setSelectedIndex ( 0 ) ; m_ComboPlayer1Colour = new JComboBox ( ) ; m_ComboPlayer2Colour = new JComboBox ( ) ; m_ComboPlayer1Colour . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( "Red" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Yellow" ) ; } else if ( "Yellow" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Red" ) ; } else if ( "Black" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "White" ) ; } else if ( "White" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Black" ) ; } } } ) ; m_ComboPlayer2Colour . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( "Red" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Yellow" ) ; } else if ( "Yellow" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Red" ) ; } else if ( "Black" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "White" ) ; } else if ( "White" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Black" ) ; } } } ) ; m_InputScreen = new JPanel ( new GridBagLayout ( ) ) ; m_InputLabel = new JLabel ( "Player Setup" ) ; m_InputLabel . setFont ( new Font ( "SansSerif" , Font . PLAIN , SECONDHEAD_FONTSIZE ) ) ; m_Player1Label = new JLabel ( "Player 1 details" ) ; m_Player1Label . setFont ( new Font ( "SansSerif" , Font . ITALIC , SMALLHEADING_FONTSIZE ) ) ; m_Player2Label = new JLabel ( "Player 2 details" ) ; m_Player2Label . setFont ( new Font ( "SansSerif" , Font . ITALIC , SMALLHEADING_FONTSIZE ) ) ; m_Player1TypeLabel = new JLabel ( "Player type:" ) ; m_Player2TypeLabel = new JLabel ( "Player type:" ) ; m_Player1ColourLabel = new JLabel ( "Player's colour:" ) ; m_Player2ColourLabel = new JLabel ( "Player's colour:" ) ; m_PlayerOK = new JButton ( "OK" ) ; m_PlayerBack = new JButton ( "Cancel" ) ; m_LoadButton = new JButton ( "Load Previous Game" ) ; m_PlayInputOne = new JTextField ( "Player One" , TEXTFIELD_COLUMNS ) ; m_PlayInputOne . setFont ( new Font ( "SansSerif" , Font . PLAIN , SUBHEADING_FONTSIZE ) ) ; m_PlayInputTwo = new JTextField ( "Player Two" , TEXTFIELD_COLUMNS ) ; m_PlayInputTwo . setFont ( new Font ( "SansSerif" , Font . PLAIN , SUBHEADING_FONTSIZE ) ) ; GridBagConstraints MainPanel = new GridBagConstraints ( ) ; GUIEventHandler handler = new GUIEventHandler ( ) ; InputEventHandler check = new InputEventHandler ( ) ; JPanel inputPanel = new JPanel ( new GridBagLayout ( ) ) ; GridBagConstraints input = new GridBagConstraints ( ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_ONE ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_InputLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_ONE ; input . insets = new Insets ( GAP_TWENTY , NO_GAP , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_LoadButton , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_TWO ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_Player1Label , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_TWO ; input . insets = new Insets ( GAP_TWENTY , GAP_TEN , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_Player2Label , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FOUR ; input . insets = new Insets ( GAP_FIFTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer1Type , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FOUR ; input . insets = new Insets ( NO_GAP , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player1TypeLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FOUR ; input . insets = new Insets ( GAP_FIFTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer2Type , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FOUR ; input . insets = new Insets ( NO_GAP , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player2TypeLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_THREE ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED ) ; inputPanel . add ( m_PlayInputOne , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_THREE ; input . insets = new Insets ( GAP_TWENTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED ) ; inputPanel . add ( m_PlayInputTwo , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FIVE ; input . insets = new Insets ( GAP_FIFTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer1Colour , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FIVE ; input . insets = new Insets ( NO_GAP , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player1ColourLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FIVE ; input . insets = new Insets ( GAP_FIFTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer2Colour , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FIVE ; input . insets = new Insets ( NO_GAP , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player2ColourLabel , input ) ; JPanel confirmPanel = new JPanel ( new GridBagLayout ( ) ) ; GridBagConstraints confirm = new GridBagConstraints ( ) ; confirm . fill = GridBagConstraints . HORIZONTAL ; confirm . gridx = COLUMN_ONE ; confirm . gridy = ROW_ONE ; confirm . insets = new Insets ( GAP_FIFTEEN , NO_GAP , NO_GAP , GAP_TWENTY ) ; confirmPanel . add ( m_PlayerBack , confirm ) ; confirm . fill = GridBagConstraints . HORIZONTAL ; confirm . gridx = COLUMN_TWO ; confirm . gridy = ROW_ONE ; confirm . insets = new Insets ( GAP_FIFTEEN , NO_GAP , NO_GAP , NO_GAP ) ; confirmPanel . add ( m_PlayerOK , confirm ) ; MainPanel . insets = new Insets ( GAP_TEN , NO_GAP , NO_GAP , NO_GAP ) ; MainPanel . gridx = COLUMN_ONE ; MainPanel . gridy = ROW_ONE ; m_InputScreen . add ( inputPanel , MainPanel ) ; MainPanel . gridx = COLUMN_ONE ; MainPanel . gridy = ROW_TWO ; m_InputScreen . add ( confirmPanel , MainPanel ) ; m_PlayerOK . addActionListener ( handler ) ; m_PlayerBack . addActionListener ( handler ) ; m_LoadButton . addActionListener ( handler ) ; m_PlayInputOne . addKeyListener ( check ) ; m_PlayInputTwo . addKeyListener ( check ) ; return true ; }
va	5	static String getDefaultLibPath ( final typeOS os ) { if ( os . equals ( typeOS . WINDOWS ) ) { try { String value = WinRegistryReadOnly . readString ( WinRegistryReadOnly . HKEY_LOCAL_MACHINE , "SOFTWARE\\Open-Transactions" , "Path" ) ; if ( null == value ) { return "" ; } Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . INFO , "Found OT path in registry:{0}" , value ) ; return value ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InvocationTargetException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } return "" ; }
va	0	public Player [ ] getPlayers ( ) { return this . players ; }
va	7	private BufferedImage createCanvas ( ) { _editor . importFromLogic ( _logic ) ; readyImageNode ( ) ; Dimension s = this . getSize ( ) ; int w = ( s . width < _logic . getCanvasWidth ( ) ? _logic . getCanvasWidth ( ) : s . width ) ; int h = ( s . height < _logic . getCanvasHeight ( ) ? _logic . getCanvasHeight ( ) : s . height ) ; this . setPreferredSize ( new Dimension ( w , h ) ) ; _canvasBackground = new BufferedImage ( _logic . getCanvasWidth ( ) , _logic . getCanvasHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g2d = _canvasBackground . createGraphics ( ) ; _canvasBackground = g2d . getDeviceConfiguration ( ) . createCompatibleImage ( _logic . getCanvasWidth ( ) , _logic . getCanvasHeight ( ) , Transparency . TRANSLUCENT ) ; g2d . dispose ( ) ; g2d = _canvasBackground . createGraphics ( ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode < Image > node = _imageList . get ( i ) ; if ( node . getX ( ) >= 0 && node . getY ( ) >= 0 ) { g2d . drawImage ( node . getData ( ) , node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) , this ) ; } } if ( _isToSave == false && _logic . getCanvasCheckerbard ( ) ) { drawCheckerboard ( g2d ) ; } g2d . dispose ( ) ; return _canvasBackground ; }
va	2	public int moveFrame ( Frame frame , int currentIndexOfPreviousItem ) { Animation oldParent = frame . getParent ( ) ; if ( currentIndexOfPreviousItem == - 1 ) { oldParent . frames . remove ( frame ) ; frames . add ( 0 , frame ) ; parent . fireFrameMoved ( oldParent , frame ) ; return 0 ; } Frame previousFrame = getFrame ( currentIndexOfPreviousItem ) ; if ( previousFrame == frame ) return currentIndexOfPreviousItem ; else { oldParent . frames . remove ( frame ) ; int newIndexOfPreviousItem = getFrameIndex ( previousFrame ) ; frames . add ( newIndexOfPreviousItem + 1 , frame ) ; parent . fireFrameMoved ( oldParent , frame ) ; return newIndexOfPreviousItem + 1 ; } }
va	4	private static File checkDirectory ( String dir ) { final File file = dir == null ? null : new File ( dir ) ; if ( file != null && ( ! file . isDirectory ( ) || ! file . canWrite ( ) ) ) { throw new RuntimeException ( String . format ( "%s is not a writeable directory." , file . getAbsolutePath ( ) ) ) ; } return file ; }
va	2	@ Override public void paintComponent ( Graphics g ) { g . setColor ( DEF_BACKGROUND_COLOUR ) ; g . fillRect ( 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE ) ; Graphics2D g2d = ( Graphics2D ) g ; if ( image != null ) { g2d . drawImage ( image , 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE , 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE , null ) ; } if ( gridVisible ) { drawGrid ( g ) ; } g2d . drawImage ( selector , selectorLocation . x , selectorLocation . y , selectorLocation . x + Util . GRID_SECTIONS , selectorLocation . y + Util . GRID_SECTIONS , 0 , 0 , Util . GRID_SECTIONS , Util . GRID_SECTIONS , null ) ; }
va	1	public boolean isShareQuantityZero ( ) { boolean result ; if ( shareQuantity == 0 ) { result = true ; } else { result = false ; } return result ; }
va	4	public void render ( Graphics g ) { i ++ ; if ( i >= 15 ) { animationStep ++ ; animationStep %= 3 ; image = sheet . getSprite ( "boss_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 8 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
va	3	public static String [ ] readAllStrings ( ) { String [ ] tokens = WHITESPACE_PATTERN . split ( readAll ( ) ) ; if ( tokens . length == 0 || tokens [ 0 ] . length ( ) > 0 ) return tokens ; String [ ] decapitokens = new String [ tokens . length - 1 ] ; for ( int i = 0 ; i < tokens . length - 1 ; i ++ ) decapitokens [ i ] = tokens [ i + 1 ] ; return decapitokens ; }
va	9X	public QuestionPanel getQuestionPanel ( ) { if ( mediaPanel . hasFinished ( ) ) createMedia ( ) ; if ( type . equals ( "plain" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , fontsize ) ; } else if ( type . equals ( "mchoice" ) ) { String [ ] split = answers . split ( ";" ) ; MultipleChoicePanel panel = new MultipleChoicePanel ( split , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , panel , fontsize ) ; } else if ( type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { String [ ] split = answers . split ( ";" ) ; JLabel [ ] labels = new JLabel [ 4 ] ; BufferedImage bufferedImage ; Image image ; for ( int i = 0 ; i < labels . length ; i ++ ) { prefHeight = Math . max ( PREF_HEIGHT , mcfont ) ; try { bufferedImage = ImageIO . read ( new File ( split [ i ] ) ) ; if ( bufferedImage . getHeight ( ) > prefHeight ) { image = bufferedImage . getScaledInstance ( bufferedImage . getWidth ( ) * prefHeight / bufferedImage . getHeight ( ) , prefHeight , BufferedImage . SCALE_SMOOTH ) ; } else { image = bufferedImage ; } } catch ( IOException e ) { bufferedImage = null ; image = null ; e . printStackTrace ( ) ; System . out . println ( "Image path: " + split [ i ] ) ; } labels [ i ] = new JLabel ( new ImageIcon ( image ) ) ; } MultipleChoicePanel panel = new MultipleChoicePanel ( labels , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , panel , fontsize ) ; } else if ( type . equals ( "list" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; String [ ] answerArray = answers . split ( ";" ) ; System . out . println ( "Create question list" ) ; questionPanel = new QuestionPanel ( text , answerArray , fontsize ) ; } else { System . out . println ( "failed to read file" ) ; System . exit ( 0 ) ; } return questionPanel ; }
va	2	private static int getPort ( ) throws Exception { if ( port != null ) { return port ; } if ( ! env . containsKey ( "BEANSTALKD_PORT" ) ) { throw new Exception ( "BEANSTALKD_PORT not set" ) ; } port = Integer . parseInt ( ( String ) env . get ( "BEANSTALKD_PORT" ) ) ; return port ; }
va	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
va	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Route route = ( Route ) o ; if ( double . compare ( route . coeffDate , coeffDate ) != 0 ) return false ; if ( double . compare ( route . coeffSeats , coeffSeats ) != 0 ) return false ; if ( id != route . id ) return false ; if ( name != null ? ! name . equals ( route . name ) : route . name != null ) return false ; return true ; }
va	6	private static boolean method518 ( char c ) { return c < a || c > z || c == v || c == x || c == j || c == q || c == z ; }
va	5	private void dumpBuffer ( String string ) throws IOException { if ( UtpAlgConfiguration . DEBUG ) { log . debug ( "dumping buffer" ) ; RandomAccessFile aFile = new RandomAccessFile ( "testData/auto/bufferdump.txt" , "rw" ) ; FileChannel inChannel = aFile . getChannel ( ) ; inChannel . truncate ( 0 ) ; ByteBuffer bbuffer = ByteBuffer . allocate ( 100000 ) ; bbuffer . put ( ( new SimpleDateFormat ( "dd_MM_hh_mm_ss" ) ) . format ( new Date ( ) ) . getBytes ( ) ) ; bbuffer . put ( ( string + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "SIZE: " + Integer . toString ( SIZE ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "count: " + Integer . toString ( elementCount ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "expect: " + Integer . toString ( expectedSequenceNumber ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "lastSeq: " + Integer . toString ( debug_lastSeqNumber ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "lastPos: " + Integer . toString ( debug_lastPosition ) + "\n" ) . getBytes ( ) ) ; for ( int i = 0 ; i < SIZE ; i ++ ) { String seq ; if ( buffer [ i ] == null ) { seq = "_; " ; } else { seq = Integer . toString ( ( buffer [ i ] . utpPacket ( ) . getSequenceNumber ( ) & FFFF ) ) + "; " ; } bbuffer . put ( ( Integer . toString ( i ) + " -> " + seq ) . getBytes ( ) ) ; if ( i % 50 == 0 ) { bbuffer . put ( "\n" . getBytes ( ) ) ; } } log . debug ( bbuffer . position ( ) + " " + bbuffer . limit ( ) ) ; bbuffer . flip ( ) ; while ( bbuffer . hasRemaining ( ) ) { inChannel . write ( bbuffer ) ; } aFile . close ( ) ; inChannel . close ( ) ; } }
va	6	private void write ( SelectionKey key ) throws IOException { SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; synchronized ( pendingData ) { BlockingQueue < ByteBuffer > queue = pendingData . get ( socketChannel ) ; while ( queue != null && ! queue . isEmpty ( ) ) { ByteBuffer buffer ; try { buffer = queue . take ( ) ; socketChannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { break ; } } catch ( InterruptedException e ) { log . error ( "" , e ) ; } } if ( queue != null && queue . isEmpty ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
va	8	public boolean restartLevel ( ) { GameState state = StateUtil . getGameState ( proxy ) ; if ( state == GameState . WON || state == GameState . LOST ) { proxy . send ( new ProxyClickMessage ( 420 , 380 ) ) ; System . out . println ( " restart the level " ) ; try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } else if ( state == GameState . PLAYING ) { proxy . send ( new ProxyClickMessage ( 100 , 39 ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } try { Thread . sleep ( 4000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "Zooming out" ) ; for ( int k = 0 ; k < 15 ; k ++ ) { proxy . send ( new ProxyMouseWheelMessage ( - 1 ) ) ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } return true ; }
va	5	public void swapInt ( int [ ] data , int from , int to ) { if ( from < 0 || from >= data . length || to < 0 || to > data . length ) { System . out . println ( "Swap Error!" ) ; throw new IndexOutOfBoundsException ( "Swap Error!" ) ; } if ( from == to ) { return ; } int tmp = data [ from ] ; data [ from ] = data [ to ] ; data [ to ] = tmp ; }
va	9X	private void readImpl ( InputStream in , SwingBoxDocument doc , int pos ) throws IOException , BadLocationException { if ( component == null ) throw new IllegalStateException ( "Component is null  editor kit is probably deinstalled from a JEditorPane." ) ; if ( pos > doc . getLength ( ) || pos < 0 ) { BadLocationException e = new BadLocationException ( "Invalid location" , pos ) ; readError ( null , e ) ; throw e ; } ContentReader rdr = new ContentReader ( ) ; URL url = ( URL ) doc . getProperty ( Document . StreamDescriptionProperty ) ; CSSBoxAnalyzer analyzer = getCSSBoxAnalyzer ( ) ; Container parent = component . getParent ( ) ; Dimension dim ; if ( parent != null && parent instanceof JViewport ) { dim = ( ( JViewport ) parent ) . getExtentSize ( ) ; } else { dim = component . getBounds ( ) . getSize ( ) ; } if ( dim . width <= 10 ) { Dimension tmp = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; dim . setSize ( tmp . width / 2.5 , tmp . height / 2.5 ) ; } List < ElementSpec > elements ; try { String ctype = null ; Object ct = doc . getProperty ( "Content-Type" ) ; if ( ct != null ) { if ( ct instanceof List ) ctype = ( String ) ( ( List < ? > ) ct ) . get ( 0 ) ; else ctype = ct . toString ( ) ; } DocumentSource docSource = new StreamDocumentSource ( in , url , ctype ) ; elements = rdr . read ( docSource , analyzer , dim ) ; String title = analyzer . getDocumentTitle ( ) ; if ( title == null ) title = "No title" ; doc . putProperty ( Document . TitleProperty , title ) ; } catch ( IOException e ) { readError ( url , e ) ; throw e ; } ElementSpec elementsArray [ ] = elements . toArray ( new ElementSpec [ 0 ] ) ; doc . create ( elementsArray ) ; readFinish ( url ) ; }
va	0	public Henkilo valitaHenkiloOlio ( String nimi ) { return henkilo = henkilot . get ( nimi ) ; }
va	7	public DeviceGUI ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 544 , 402 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JPanel panel = new JPanel ( ) ; panel . setBounds ( 0 , 0 , 542 , 373 ) ; contentPane . add ( panel ) ; panel . setLayout ( null ) ; JLabel lblAddNewDevice = new JLabel ( "Add new Device" ) ; lblAddNewDevice . setFont ( new Font ( "Dialog" , Font . BOLD , 16 ) ) ; lblAddNewDevice . setBounds ( 188 , 12 , 169 , 15 ) ; panel . add ( lblAddNewDevice ) ; JLabel lblDeviceName = new JLabel ( "Device Name:" ) ; lblDeviceName . setBounds ( 12 , 55 , 125 , 15 ) ; panel . add ( lblDeviceName ) ; txt_D_name = new JTextField ( ) ; txt_D_name . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "devicename" , txt_D_name . getText ( ) , nameID , currentID ) ; } } ) ; txt_D_name . setBounds ( 167 , 53 , 265 , 19 ) ; panel . add ( txt_D_name ) ; txt_D_name . setColumns ( 10 ) ; txt_D_price = new JTextField ( ) ; txt_D_price . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "unitprice" , txt_D_price . getText ( ) , nameID , currentID ) ; } } ) ; txt_D_price . setColumns ( 10 ) ; txt_D_price . setBounds ( 167 , 82 , 265 , 19 ) ; panel . add ( txt_D_price ) ; JLabel lblUnitPrice = new JLabel ( "Unit Price" ) ; lblUnitPrice . setBounds ( 12 , 84 , 125 , 15 ) ; panel . add ( lblUnitPrice ) ; JLabel lblDeviceType = new JLabel ( "Device Type:" ) ; lblDeviceType . setBounds ( 12 , 229 , 125 , 15 ) ; panel . add ( lblDeviceType ) ; JLabel lblProducer = new JLabel ( "Producer:" ) ; lblProducer . setBounds ( 12 , 260 , 125 , 15 ) ; panel . add ( lblProducer ) ; JButton btn_D_first = new JButton ( "<<" ) ; btn_D_first . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { result = query . query ( nameTBL , 1 , nameID ) ; insertValues ( result ) ; currentID = 1 ; } } ) ; btn_D_first . setBounds ( 8 , 299 , 54 , 25 ) ; panel . add ( btn_D_first ) ; JButton btn_D_back = new JButton ( "<" ) ; btn_D_back . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentID > 1 ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_D_back . setBounds ( 62 , 299 , 54 , 25 ) ; panel . add ( btn_D_back ) ; JButton btn_D_forward = new JButton ( ">" ) ; btn_D_forward . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID ++ ; if ( currentID > 1 && currentID <= maxID ) { result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null && currentID <= maxID ) { currentID ++ ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_D_forward . setBounds ( 114 , 299 , 54 , 25 ) ; panel . add ( btn_D_forward ) ; JButton btn_D_last = new JButton ( ">>" ) ; btn_D_last . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { while ( currentID < maxID ) { currentID ++ ; } result = query . query ( nameTBL , currentID , nameID ) ; insertValues ( result ) ; } } ) ; btn_D_last . setBounds ( 169 , 299 , 54 , 25 ) ; panel . add ( btn_D_last ) ; JButton btn_D_new = new JButton ( "New" ) ; btn_D_new . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID = maxID + 1 ; frame . txt_D_name . setText ( "" ) ; frame . txt_D_name . requestFocusInWindow ( ) ; frame . txt_D_desc . setText ( "" ) ; frame . txt_D_price . setText ( "" ) ; } } ) ; btn_D_new . setBounds ( 224 , 299 , 70 , 25 ) ; panel . add ( btn_D_new ) ; JButton btn_D_save = new JButton ( "Save" ) ; btn_D_save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { newValues [ 0 ] = "" + txt_D_name . getText ( ) ; newValues [ 1 ] = "" + txt_D_desc . getText ( ) ; newValues [ 2 ] = "" + txt_D_price . getText ( ) ; insert . insert ( nameTBL , nameTxtF , newValues ) ; update . updateFK ( nameTBL , devicetFK , cbx_device . getSelectedIndex ( ) , "devicetype_ID" , currentID ) ; update . updateFK ( nameTBL , producerFK , cbx_producer . getSelectedIndex ( ) , "producer_ID" , currentID ) ; maxID = query . maxID ( nameTBL , nameID ) ; } } ) ; btn_D_save . setBounds ( 292 , 299 , 68 , 25 ) ; panel . add ( btn_D_save ) ; JButton btn_D_del = new JButton ( "Del" ) ; btn_D_del . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { delete . delete ( nameTBL , nameID , currentID ) ; } } ) ; btn_D_del . setBounds ( 362 , 299 , 70 , 25 ) ; panel . add ( btn_D_del ) ; JLabel lblDescription = new JLabel ( "Description" ) ; lblDescription . setBounds ( 12 , 115 , 125 , 15 ) ; panel . add ( lblDescription ) ; txt_D_desc = new JTextArea ( ) ; txt_D_desc . setBounds ( 167 , 113 , 265 , 101 ) ; panel . add ( txt_D_desc ) ; int lengthDev = query . maxID ( devT , "Devicetype_ID" ) ; String [ ] cbx_d_values = new String [ lengthDev ] ; cbx_d_values = query . queryColumn ( devT , "name" , lengthDev ) ; DefaultComboBoxModel < String > model = new DefaultComboBoxModel ( cbx_d_values ) ; cbx_device = new JComboBox ( model ) ; cbx_device . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { update . updateFK ( nameTBL , devicetFK , cbx_device . getSelectedIndex ( ) , "device_ID" , currentID ) ; } } ) ; cbx_device . setBounds ( 167 , 224 , 265 , 24 ) ; panel . add ( cbx_device ) ; int lengthProd = query . maxID ( producer , "producer_ID" ) ; String [ ] cbx_p_values = new String [ lengthProd ] ; cbx_p_values = query . queryColumn ( producer , "name" , lengthProd ) ; DefaultComboBoxModel < String > modelPro = new DefaultComboBoxModel ( cbx_p_values ) ; cbx_producer = new JComboBox ( modelPro ) ; cbx_producer . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . updateFK ( nameTBL , producerFK , cbx_producer . getSelectedIndex ( ) , "producer_ID" , currentID ) ; } } ) ; cbx_producer . setBounds ( 167 , 255 , 265 , 24 ) ; panel . add ( cbx_producer ) ; JButton btnAddDeviceType = new JButton ( "Device Type" ) ; btnAddDeviceType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { DeviceTypeGUI dtGui = new DeviceTypeGUI ( ) ; dtGui . openDeviceTypeGUI ( ) ; } } ) ; btnAddDeviceType . setBounds ( 18 , 336 , 169 , 25 ) ; panel . add ( btnAddDeviceType ) ; JButton btnNewProducer = new JButton ( "Producer" ) ; btnNewProducer . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ProducerGUI pGui = new ProducerGUI ( ) ; pGui . openProducerGUI ( ) ; frame . revalidate ( ) ; frame . repaint ( ) ; } } ) ; btnNewProducer . setBounds ( 199 , 336 , 169 , 25 ) ; panel . add ( btnNewProducer ) ; setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; }
va	3	@ Override public boolean exists ( ) { return x >= 0 && y >= 0 && x < xlimit && y < ylimit ; }
va	3	private class < ? > toBeanType ( int type ) { class < ? > clz = typesMap . get ( type ) ; return clz == null ? String . class : clz ; }
va	8	public BigDecimal getAvailability ( ) { LinkedHashSet < PhysicalLink > uniqPhysicalLinks = new LinkedHashSet < PhysicalLink > ( ) ; LinkedHashSet < PhysicalNode > uniqIntermediaryNodes = new LinkedHashSet < PhysicalNode > ( ) ; for ( VirtualLink virtualLink : linksMapping . keySet ( ) ) { PhysicalNode sourcePhysicalNode = getHostingNodeFor ( ( VirtualNode ) virtualLink . getSourceNode ( ) ) ; PhysicalNode destinyPhysicalNode = getHostingNodeFor ( ( VirtualNode ) virtualLink . getDestinyNode ( ) ) ; ArrayList < PhysicalLink > hostingLinks = linksMapping . get ( virtualLink ) ; for ( PhysicalLink hostingLink : hostingLinks ) { uniqPhysicalLinks . add ( hostingLink ) ; PhysicalNode hostingLinkSourceNode = ( PhysicalNode ) hostingLink . getSourceNode ( ) ; PhysicalNode hostingLinkDestinyNode = ( PhysicalNode ) hostingLink . getDestinyNode ( ) ; PhysicalNode [ ] hostingLinkNodes = { hostingLinkSourceNode , hostingLinkDestinyNode } ; for ( PhysicalNode hostingLinkNode : hostingLinkNodes ) { if ( ! hostingLinkNode . equals ( sourcePhysicalNode ) && ! hostingLinkNode . equals ( destinyPhysicalNode ) ) { uniqIntermediaryNodes . add ( hostingLinkNode ) ; } } } } BigDecimal availability = new BigDecimal ( 1 ) ; for ( PhysicalNode hostingNode : uniqPhysicalNodes ( ) ) { availability = availability . multiply ( hostingNode . getNodeAvailability ( ) , MathContext . DECIMAL64 ) ; } for ( PhysicalLink hostingLink : uniqPhysicalLinks ) { availability = availability . multiply ( hostingLink . getAvailability ( ) , MathContext . DECIMAL64 ) ; } for ( PhysicalNode intermediaryNode : uniqIntermediaryNodes ) { availability = availability . multiply ( intermediaryNode . getIntermediaryNodeAvailability ( ) , MathContext . DECIMAL64 ) ; } return availability ; }
va	0	public Decision getLastDecision ( ) { return getDecision ( ) ; }
va	8	private void check ( class < ? > impl ) { if ( impl . isInterface ( ) ) { throw new IllegalArgumentException ( ) ; } if ( impl . isEnum ( ) ) { throw new IllegalArgumentException ( ) ; } ClassInfo classInfo = new ClassInfo ( impl ) ; List < Constructor < ? >> injectableConstructors = classInfo . getInjectableConstructors ( ) ; if ( injectableConstructors . isEmpty ( ) ) { try { classInfo . getDefaultConstructor ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( e ) ; } return ; } if ( injectableConstructors . isEmpty ( ) ) { throw new IllegalArgumentException ( ) ; } if ( injectableConstructors . size ( ) > 1 ) { throw new IllegalArgumentException ( ) ; } }
va	1	public List < Frequencia > getFrequenciaFuncionario ( Integer mes , Integer ano , Integer idFuncionario ) throws SQLException { List < Frequencia > frequencia = new ArrayList < Frequencia > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT z.dia  z.data  z.idFuncionario  f.nome  f.portaria  z.presenca FROM funcionario f  (frequencia fr join (Select data as dt  Extract('Day' From data) as dia From frequencia where idFuncionario = 13) x ON x.dt = fr.data) z WHERE f.id = z.idFuncionario AND z.idFuncionario = ? AND z.data between ? AND ? order by z.data asc" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; Calendar c = Calendar . getInstance ( ) ; c . set ( ano , ( mes - 2 ) , 21 ) ; Date dataInicial = new Date ( c . getTimeInMillis ( ) ) ; ps . setDate ( 2 , dataInicial ) ; UtilFrequencia utilFrequencia = new UtilFrequencia ( ) ; c . set ( ano , mes , 20 ) ; Date dataFinal = new Date ( c . getTimeInMillis ( ) ) ; ps . setDate ( 3 , dataFinal ) ; Frequencia f ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { f = new Frequencia ( ) ; f . setData ( rs . getDate ( "data" ) ) ; f . setPresenca ( rs . getBoolean ( "presenca" ) ) ; f . setFuncionario ( new FuncionarioDao ( ) . getfuncionario ( rs . getInt ( "idFuncionario" ) ) ) ; f . setAux ( ( int ) rs . getDouble ( "dia" ) ) ; frequencia . add ( f ) ; } return frequencia ; }
va	4	@ Override public String toString ( ) { boolean isActive = player . isActive ( ) ; StringBuilder b = new StringBuilder ( ) ; b . append ( "<html>" ) ; if ( isPlaying ) b . append ( "<b>" ) ; if ( ! isActive ) b . append ( "<strike>" ) ; b . append ( player . toString ( ) ) ; if ( ! isActive ) b . append ( "</strike>" ) ; if ( isPlaying ) b . append ( "</b>" ) ; b . append ( "</html>" ) ; return b . toString ( ) ; }
va	4	@ Override public Map < String , ScoreState > call ( ) throws Exception { for ( BinaryRule rule : IntraCellExecution . parser . grammar . getBinaryRules ( ) ) { String stateX = rule . getParent ( ) ; String stateY = rule . getLeftChild ( ) ; String stateZ = rule . getRightChild ( ) ; if ( ! intraCellExecution . cell . CKYTable . hasState ( stateY , intraCellExecution . cell . i , k ) || ! intraCellExecution . cell . CKYTable . hasState ( stateZ , k , intraCellExecution . cell . j ) ) continue ; ScoreState leftChildState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateY , intraCellExecution . cell . i , k ) ; ScoreState rightChildState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateZ , k , intraCellExecution . cell . j ) ; double updateScore = rule . getScore ( ) * leftChildState . getScore ( ) * rightChildState . getScore ( ) ; ScoreState currentState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateX , intraCellExecution . cell . i , intraCellExecution . cell . j ) ; synchronized ( currentState ) { if ( currentState . getScore ( ) < updateScore ) { currentState . state = stateX ; currentState . score = updateScore ; currentState . children = Arrays . asList ( leftChildState , rightChildState ) ; } } } intraCellExecution . decreasePairDependencyCount ( ) ; return null ; }
va	5	public int call ( CallFrame frame , int argCount ) { LuaTable table = frame . getArg ( 0 , LuaTable . class ) ; String sep = frame . getArgNull ( 1 , String . class ) ; int start = frame . getIntArg ( 2 , 1 ) ; int limit = frame . getIntArg ( 3 , table . size ( ) ) ; if ( limit == 0 || limit < start ) { frame . push ( "" ) ; return 1 ; } StringBuilder result = new StringBuilder ( ) ; for ( int index = start ; index <= limit ; index ++ ) { result . append ( LuaUtil . rawToString ( table . rawget ( index ) ) ) ; if ( sep != null && index != limit ) result . append ( sep ) ; } frame . push ( result . toString ( ) ) ; return 1 ; }
va	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ArrayDescr other = ( ArrayDescr ) obj ; if ( basetype == null ) { if ( other . basetype != null ) return false ; } else if ( ! basetype . equals ( other . basetype ) ) return false ; if ( numberOfElements != other . numberOfElements ) return false ; return true ; }
va	9X	public void Show ( boolean enabled , String uname ) { ASCII_Sound beep = new ASCII_Sound ( false ) ; ASCII_Art welcome = new ASCII_Art ( ) ; Options o = new Options ( ) ; MainMenu m = new MainMenu ( ) ; PlayMenu p = new PlayMenu ( ) ; HelpMenu h = new HelpMenu ( ) ; if ( enabled == true ) { for ( OptionsEnum options : OptionsEnum . values ( ) ) { if ( options . getMenuChoice ( ) != 0 ) { System . out . printf ( "%s. %s\n" , options . getMenuChoice ( ) , options . getMessage ( ) ) ; } } } User u = new User ( ) ; switch ( u . getUserInt ( "Select an option.\n (Enter a #)" ) ) { case 1 : setScoreOptions ( true ) ; System . out . println ( "Keep Score: " + score ) ; break ; case 2 : setScoreOptions ( false ) ; System . out . println ( "Keep Score: " + score ) ; break ; case 3 : setSoundOptions ( true ) ; System . out . println ( "Soundtrack: " + sound ) ; break ; case 4 : setSoundOptions ( false ) ; System . out . println ( "Soundtrack: " + sound ) ; break ; case 5 : matchSeconds = u . getUserInt ( "How many seconds?\n [3-10]" ) ; System . out . println ( "Timeout: " + matchSeconds ) ; break ; case 6 : tilePairs = u . getUserInt ( "How many match pairs?\n [4]" ) ; System . out . println ( "Match Pairs: " + tilePairs ) ; break ; case 7 : printOptions ( ) ; break ; case 8 : m . setEnabled ( true ) ; m . Show ( uname ) ; break ; case 99 : System . out . println ( "Invalid selection." ) ; o . Show ( enabled , uname ) ; break ; default : System . out . println ( "Invalid selection." ) ; o . Show ( enabled , uname ) ; break ; } Exit answerExit = new Exit ( ) ; do { Show ( enabled , u . user ) ; } while ( answerExit . getExit ( ) == false ) ; }
va	7	public static void bubbleSortImproved ( int [ ] a ) { System . out . println ( "Array before sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; System . out . println ( ) ; System . out . println ( "Sorting sequences after each iteration" ) ; int n = a . length ; boolean swapped = true ; for ( int i = 0 ; i < n && swapped ; i ++ ) { swapped = false ; for ( int j = 0 ; j < ( n - i - 1 ) ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { int temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; swapped = true ; } } for ( int k : a ) System . out . print ( k + " " ) ; System . out . println ( ) ; } System . out . println ( "Array after sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; }
va	1	public int GetSumOfFactorialsOfDigitsInNumber ( int candidate ) { String digits = Integer . toString ( candidate ) ; int toReturn = 0 ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { toReturn += FactorializeSmallNumber ( Integer . parseInt ( digits . substring ( i , i + 1 ) ) ) ; } return toReturn ; }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SpeciesReference other = ( SpeciesReference ) obj ; if ( species == null ) { if ( other . species != null ) return false ; } else if ( ! species . equals ( other . species ) ) return false ; return true ; }
va	6	@ Test ( groups = { "integration" } ) public void testConcurrentBehavior ( ) throws IOException , InterruptedException { final int QUEUE_ITEMS = 1024 ; final int THREADS = 10 ; log . trace ( "[start] PersistentQueueTest.testConcurrentBehavior" ) ; File tempfile = File . createTempFile ( "PersistentQueue" , ".test" ) ; try { tempfile . delete ( ) ; List < Thread > threads = new ArrayList < Thread > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; final PersistentQueue < Integer > queue = new PersistentQueue < Integer > ( Integer . class , tempfile , 9 , 4104 ) ; for ( int i = 0 ; i < THREADS ; i ++ ) { Thread thread = new Thread ( ) { public void run ( ) { log . trace ( "[thread] start {}" , Thread . currentThread ( ) . getId ( ) ) ; int x = 0 ; try { while ( true ) { Thread . yield ( ) ; Integer y = queue . poll ( 2 , TimeUnit . SECONDS ) ; Thread . yield ( ) ; if ( y == null ) break ; Thread . yield ( ) ; log . trace ( "[poll] {}" , y ) ; assert y >= x : "What happened?" ; Thread . yield ( ) ; x = y ; Thread . yield ( ) ; log . trace ( "[thread] count {}" , count . getAndIncrement ( ) ) ; } } catch ( InterruptedException exception ) { throw new IllegalStateException ( "Unexpectedly interrupted" , exception ) ; } } } ; thread . start ( ) ; threads . add ( thread ) ; } for ( int i = 0 ; i < QUEUE_ITEMS ; i ++ ) { log . trace ( "[put] {}" , i ) ; queue . put ( i ) ; } for ( Thread thread : threads ) { log . trace ( "[thread] joining {}" , thread . getId ( ) ) ; thread . join ( ) ; } int total = count . get ( ) ; assert total == QUEUE_ITEMS : "Expected " + QUEUE_ITEMS + "  observed " + total ; } finally { tempfile . delete ( ) ; } log . trace ( "[end] PersistentQueueTest.testConcurrentBehavior" ) ; }
va	6	@ Override public void validate ( ) { if ( sitename == null ) { addActionError ( "Please Enter Site Name" ) ; } if ( siteurl == null && siteurl . equals ( "http://" ) ) { addActionError ( "Please Enter Web Site Url" ) ; } if ( txtcolor == null ) { addActionError ( "Please Enter Text Color" ) ; } if ( bgcolor == null ) { addActionError ( "Please Enter Background Color" ) ; } if ( catgry . equals ( "Please select" ) ) { addActionError ( "Please Select a Category" ) ; } }
va	0	public void resetTime ( ) { totalInNano = 0 ; }
va	0	@ Test public void testGetBedReservations_1 ( ) throws Exception { Booking fixture = new Booking ( new Identifier ( "" ) , new Identifier ( "" ) , new ArrayList ( ) , new ArrayList ( ) , new Date ( ) , hostel . core . Booking . BookingStatus . CANCELLED ) ; ArrayList < Tariff > result = fixture . getBedReservations ( ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; }
va	8	public static void clusteNouns ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from extractions" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; String value = rs1 . getString ( "value" ) ; if ( extractionHash . containsKey ( attr ) ) { if ( extractionHash . get ( attr ) . containsKey ( value ) ) { extractionHash . get ( attr ) . put ( value , extractionHash . get ( attr ) . get ( value ) + 1 ) ; } else { extractionHash . get ( attr ) . put ( value , 1 ) ; } } else { Map < String , Integer > tmp = new HashMap < String , Integer > ( ) ; tmp . put ( value , 1 ) ; extractionHash . put ( attr , tmp ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; attrList = new ArrayList < String > ( ) ; sql = "select DISTINCT attr from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String attr = rs1 . getString ( "attr" ) ; attrList . add ( attr ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } valList = new ArrayList < String > ( ) ; sql = "select DISTINCT value from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String val = rs1 . getString ( "value" ) ; valList . add ( val ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; OutputtoCytoscapeFile ( "output.csv" ) ; }
va	8	public LoadPermissions ( ) { final File permissionsFolder = new File ( plugin . getDataFolder ( ) , "permissions/" ) ; if ( ! permissionsFolder . exists ( ) ) { permissionsFolder . mkdirs ( ) ; } permissionsFile = new File ( plugin . getDataFolder ( ) , "permissions/permissions.yml" ) ; if ( ! permissionsFile . exists ( ) ) { try { ConfigHandle . copy ( plugin . getResourceAsStream ( "permissions.yml" ) , permissionsFile ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } final FileConfiguration permissionsYaml = new YamlConfiguration ( ) ; try { permissionsYaml . load ( permissionsFile ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can't load permissions file!" ) ; } final HashMap < String , Group > groups = new HashMap < String , Group > ( ) ; final Set < String > groupNames = permissionsYaml . getConfigurationSection ( "groups" ) . getKeys ( false ) ; for ( final String groupName : groupNames ) { final boolean isDefault = permissionsYaml . getBoolean ( "groups." + groupName + ".default" ) ; final List < String > permissions = permissionsYaml . getStringList ( "groups." + groupName + ".permissions" ) ; final Set < String > flags = permissionsYaml . getConfigurationSection ( "groups." + groupName + ".flags" ) . getKeys ( false ) ; final List < String > tempPerms = new ArrayList < String > ( ) ; final HashMap < String , Object > tempflags = new HashMap < String , Object > ( ) ; for ( final String permission : permissions ) { tempPerms . add ( permission . toLowerCase ( ) ) ; } for ( final String flag : flags ) { tempflags . put ( flag , permissionsYaml . get ( "groups." + groupName + ".flags." + flag ) ) ; } final String tag = permissionsYaml . getString ( "groups." + groupName + ".tag" ) ; final Group group = new Group ( groupName . toLowerCase ( ) , tag , isDefault , tempPerms , tempflags ) ; permissions . clear ( ) ; tempPerms . clear ( ) ; flags . clear ( ) ; tempflags . clear ( ) ; if ( isDefault ) { PermissionData . setDefaultGroup ( group ) ; } groups . put ( groupName . toLowerCase ( ) , group ) ; } PermissionData . setGroups ( groups ) ; }
va	5	public Object getValueAt ( int r , int c ) { Player player = history . getLast ( ) . get ( r ) ; switch ( c ) { case COL_RANK : return r + 1 ; case COL_NAME : return player . clone ( ) ; case COL_PRESENT : return player . isPresent ( ) ? Attendance . PRESENT : Attendance . ABSENT ; case COL_BIDS : return new BidCounter ( player . getBids ( ) ) ; default : return null ; } }
va	2	public boolean mustProceedSecondScan ( ) { for ( IStringAnalyser analyzer : stringAnalysers ) { if ( analyzer . isTwoScansAnalyzer ( ) ) { return true ; } } return false ; }
va	8	public MainToolBar ( ) { upButton . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; upButton . setBorder ( null ) ; upButton . setOpaque ( false ) ; upButton . setContentAreaFilled ( false ) ; upButton . setBorderPainted ( false ) ; upButton . setEnabled ( false ) ; upButton . setFocusPainted ( false ) ; refreshButton . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; refreshButton . setBorder ( null ) ; refreshButton . setOpaque ( false ) ; refreshButton . setContentAreaFilled ( false ) ; refreshButton . setBorderPainted ( false ) ; refreshButton . setFocusPainted ( false ) ; upButton . setToolTipText ( "Go up a folder" ) ; refreshButton . setToolTipText ( "Refresh" ) ; locationBar . setToolTipText ( "The current path  relative to the backup directory" ) ; locationBar . setDisabledTextColor ( new Color ( 0.2f , 0.2f , 0.2f ) ) ; refreshButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { MainFrame . getInstance ( ) . menubar . copyToOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . menubar . revisionsOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . redrawTable ( MainFrame . getInstance ( ) . currentDirectory ) ; } } ) ; upButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { MainFrame . getInstance ( ) . currentDirectory = MainFrame . getInstance ( ) . currentDirectory . resolve ( ".." ) . normalize ( ) ; if ( MainFrame . getInstance ( ) . currentDirectory . equals ( Main . backupDirectory ) ) { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( false ) ; } MainFrame . getInstance ( ) . menubar . copyToOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . menubar . revisionsOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . redrawTable ( MainFrame . getInstance ( ) . currentDirectory ) ; } } ) ; locationBar . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String text = locationBar . getText ( ) ; if ( ! text . equals ( "" ) && text . charAt ( 0 ) == File . separatorChar ) { text = text . substring ( 1 ) ; } Path enteredPath = null ; try { enteredPath = Main . backupDirectory . resolve ( text ) . toFile ( ) . getCanonicalFile ( ) . toPath ( ) ; } catch ( IOException e1 ) { Errors . nonfatalError ( "Could not interpret entered path." , e1 ) ; } if ( enteredPath . toFile ( ) . isDirectory ( ) && ( ! Main . backupDirectory . startsWith ( enteredPath . normalize ( ) ) || Main . backupDirectory . equals ( enteredPath . normalize ( ) ) ) ) { MainFrame . getInstance ( ) . redrawTable ( enteredPath . normalize ( ) ) ; MainFrame . getInstance ( ) . currentDirectory = enteredPath . normalize ( ) ; } else { JOptionPane . showMessageDialog ( MainFrame . getInstance ( ) , "The entered directory does not exist or is outside of the backup directory." ) ; } if ( MainFrame . getInstance ( ) . currentDirectory . equals ( Main . backupDirectory ) ) { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( false ) ; } else { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( true ) ; } } } ) ; this . setFloatable ( false ) ; this . add ( upButton ) ; this . addSeparator ( ) ; this . add ( refreshButton ) ; this . addSeparator ( ) ; this . add ( locationBar ) ; }
va	6	public void action ( ) { boolean terminationFlag = false ; while ( ! terminationFlag ) { MessageTemplate informTemplate = MessageTemplate . MatchPerformative ( ACLMessage . INFORM ) ; ACLMessage informMessage = myAgent . receive ( informTemplate ) ; if ( informMessage != null ) { if ( informMessage . getContent ( ) . matches ( "REREGISTER" ) ) { terminationFlag = true ; registerService ( ) ; } else if ( informMessage . getContent ( ) . matches ( "UPDATE-REREGISTER-BE-HAPPY" ) ) { updateRequestedInventory ( this . order ) ; terminationFlag = true ; registerService ( ) ; } else if ( informMessage . getContent ( ) . matches ( "YOU-ARE-THE-ONE" ) ) { try { String sName = informMessage . getLanguage ( ) ; AID orderID = new AID ( sName , AID . ISGUID ) ; ACLMessage notify = new ACLMessage ( ACLMessage . REQUEST ) ; notify . setOntology ( "Check Part List" ) ; notify . addReceiver ( orderID ) ; HashMap < String , Integer > copyInventory = new HashMap < String , Integer > ( ) ; copyInventory = copyHM ( inventory ) ; notify . setContentObject ( copyInventory ) ; send ( notify ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { block ( ) ; } } }
va	3	@ Test public void testCreateFeatureHolder ( ) { FunctionExecutor < void > executor = new FunctionExecutor < void > ( ) { @ Override public void invoke ( FunctionInvocation < void > invocation , Object ... arguments ) throws ExecutorInvocationException { return invocation . next ( arguments ) ; } } ; functionDefinition . addExecutor ( FeatureHolder . class , "default" , executor ) ; functionDefinition . setParameter ( 0 , String . class ) ; Function < void > function = functionDefinition . create ( new DefaultFeatureHolder ( ) ) ; List < class < ? >> expectedParameters = new ArrayList < class < ? >> ( ) ; expectedParameters . add ( String . class ) ; Set < FunctionExecutor < void >> expectedExecutors = new HashSet < FunctionExecutor < void >> ( ) ; expectedExecutors . add ( executor ) ; Set < FunctionExecutor < void >> actualExecutors = new HashSet < FunctionExecutor < void >> ( ) ; for ( FunctionExecutorContext < void > context : function . getExecutors ( ) ) { actualExecutors . add ( context . getExecutor ( ) ) ; } assert . assertEquals ( "Function object's parameters" , expectedParameters , function . getParameters ( ) ) ; assert . assertEquals ( "Function object's executors" , expectedExecutors , actualExecutors ) ; }
va	6	public void processDocument ( XmlPullParser xpp ) throws XmlPullParserException , IOException { int eventType = xpp . getEventType ( ) ; do { if ( eventType == XmlPullParser . START_DOCUMENT ) { System . out . println ( "Start document" ) ; } else if ( eventType == XmlPullParser . END_DOCUMENT ) { System . out . println ( "End document" ) ; } else if ( eventType == XmlPullParser . START_TAG ) { processStartElement ( xpp ) ; } else if ( eventType == XmlPullParser . END_TAG ) { processEndElement ( xpp ) ; } else if ( eventType == XmlPullParser . TEXT ) { processText ( xpp ) ; } eventType = xpp . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; }
va	9X	public final JPoclASTParser . functionCall_return functionCall ( ) throws RecognitionException { JPoclASTParser . functionCall_return retval = new JPoclASTParser . functionCall_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token ID106 = null ; Token char_literal107 = null ; Token char_literal109 = null ; Token DOT110 = null ; JPoclASTParser . parameters_return parameters108 = null ; JPoclASTParser . qualifiedID_return qualifiedID111 = null ; TypeTree ID106_tree = null ; TypeTree char_literal107_tree = null ; TypeTree char_literal109_tree = null ; TypeTree DOT110_tree = null ; RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream ( adaptor , "token ID" ) ; RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream ( adaptor , "token DOT" ) ; RewriteRuleTokenStream stream_24 = new RewriteRuleTokenStream ( adaptor , "token 24" ) ; RewriteRuleTokenStream stream_25 = new RewriteRuleTokenStream ( adaptor , "token 25" ) ; RewriteRuleSubtreeStream stream_qualifiedID = new RewriteRuleSubtreeStream ( adaptor , "rule qualifiedID" ) ; RewriteRuleSubtreeStream stream_parameters = new RewriteRuleSubtreeStream ( adaptor , "rule parameters" ) ; try { { { ID106 = ( Token ) match ( input , ID , FOLLOW_ID_in_functionCall1091 ) ; stream_ID . add ( ID106 ) ; char_literal107 = ( Token ) match ( input , 24 , FOLLOW_24_in_functionCall1092 ) ; stream_24 . add ( char_literal107 ) ; int alt24 = 2 ; int LA24_0 = input . LA ( 1 ) ; if ( ( LA24_0 == boolean || ( LA24_0 >= ID && LA24_0 <= int ) || LA24_0 == 24 || LA24_0 == 27 || LA24_0 == 29 || LA24_0 == 43 || LA24_0 == 49 ) ) { alt24 = 1 ; } switch ( alt24 ) { case 1 : { pushFollow ( FOLLOW_parameters_in_functionCall1094 ) ; parameters108 = parameters ( ) ; state . _fsp -- ; stream_parameters . add ( parameters108 . getTree ( ) ) ; } break ; } char_literal109 = ( Token ) match ( input , 25 , FOLLOW_25_in_functionCall1097 ) ; stream_25 . add ( char_literal109 ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( ( TypeTree ) adaptor . create ( FUNCCALL , "FUNCCALL" ) , root_1 ) ; adaptor . addChild ( root_1 , stream_ID . nextNode ( ) ) ; if ( stream_parameters . hasNext ( ) ) { adaptor . addChild ( root_1 , stream_parameters . nextTree ( ) ) ; } stream_parameters . reset ( ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } int alt25 = 2 ; int LA25_0 = input . LA ( 1 ) ; if ( ( LA25_0 == . ) ) { alt25 = 1 ; } switch ( alt25 ) { case 1 : { DOT110 = ( Token ) match ( input , . , FOLLOW_DOT_in_functionCall1119 ) ; stream_DOT . add ( DOT110 ) ; pushFollow ( FOLLOW_qualifiedID_in_functionCall1121 ) ; qualifiedID111 = qualifiedID ( ) ; state . _fsp -- ; stream_qualifiedID . add ( qualifiedID111 . getTree ( ) ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_DOT . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_retval . nextTree ( ) ) ; adaptor . addChild ( root_1 , stream_qualifiedID . nextTree ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; } } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
va	5	private static void manageArgs ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . trim ( ) . toLowerCase ( ) ) { case "nogui" : nogui = true ; break ; case "server" : startServer = true ; break ; case "port" : if ( i < args . length - 1 ) { port = parsePositiveInt ( args [ ++ i ] ) ; } else { System . err . println ( "Found argument 'port'  but no port was given" ) ; System . exit ( 1 ) ; } break ; default : System . err . println ( "Unknown command: " + args [ i ] . trim ( ) . toLowerCase ( ) ) ; System . exit ( 1 ) ; break ; } } }
va	8	boolean handleQuery ( JmDNSImpl dns , long expirationTime ) { ServiceInfoImpl info = ( ServiceInfoImpl ) dns . getServices ( ) . get ( name . toLowerCase ( ) ) ; if ( info != null && ( port != info . port || ! server . equalsIgnoreCase ( dns . getLocalHost ( ) . getName ( ) ) ) ) { logger . finer ( "handleQuery() Conflicting probe detected from: " + getRecordSource ( ) ) ; DNSRecord . Service localService = new DNSRecord . Service ( info . getQualifiedName ( ) , DNSConstants . TYPE_SRV , DNSConstants . CLASS_IN | DNSConstants . CLASS_UNIQUE , DNSConstants . DNS_TTL , info . priority , info . weight , info . port , dns . getLocalHost ( ) . getName ( ) ) ; try { if ( dns . getInterface ( ) . equals ( getRecordSource ( ) ) ) { logger . warning ( "Got conflicting probe from ourselves\n" + "incoming: " + this . toString ( ) + "\n" + "local   : " + localService . toString ( ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } int comparison = lexCompare ( localService ) ; if ( comparison == 0 ) { logger . finer ( "handleQuery() Ignoring a identical service query" ) ; return false ; } if ( info . getState ( ) . isProbing ( ) && comparison > 0 ) { String oldName = info . getQualifiedName ( ) . toLowerCase ( ) ; info . setName ( dns . incrementName ( info . getName ( ) ) ) ; dns . getServices ( ) . remove ( oldName ) ; dns . getServices ( ) . put ( info . getQualifiedName ( ) . toLowerCase ( ) , info ) ; logger . finer ( "handleQuery() Lost tie break: new unique name chosen:" + info . getName ( ) ) ; info . revertState ( ) ; } else { return false ; } return true ; } return false ; }
va	2	public ArrayList < User > getFriends ( int id ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ArrayList < User > users = new ArrayList < User > ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM friends_join WHERE friend1ID = " + id ) ; try { while ( rs . next ( ) ) { User user = getUserFromID ( rs . getInt ( "friend2ID" ) ) ; users . add ( user ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return users ; }
va	2	Tester ( long _seed ) throws Exception { loadWords ( ) ; setSeed ( _seed ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; c = new TesterCanvas ( ) ; c . setPreferredSize ( new Dimension ( 600 , 400 ) ) ; Container cp = getContentPane ( ) ; cp . setLayout ( new BorderLayout ( ) ) ; cp . add ( c , BorderLayout . CENTER ) ; cp . add ( c . seedText , BorderLayout . NORTH ) ; JPanel jp = new JPanel ( ) ; JButton e = new JButton ( "english" ) ; e . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { int index = r . nextInt ( ewords . size ( ) ) ; String word = ewords . get ( index ) ; c . english = word ; c . portuguese = null ; count ++ ; c . repaint ( ) ; } } ) ; JButton p = new JButton ( "portuguese" ) ; p . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { int index = r . nextInt ( pwords . size ( ) ) ; System . out . println ( "index = " + index ) ; String word = pwords . get ( index ) ; c . english = null ; c . portuguese = word ; count ++ ; c . repaint ( ) ; } } ) ; JButton t = new JButton ( "translate" ) ; t . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( c . english != null ) { c . portuguese = e2p . get ( c . english ) ; } else if ( c . portuguese != null ) { c . english = p2e . get ( c . portuguese ) ; } c . repaint ( ) ; } } ) ; JButton r = new JButton ( "reset" ) ; r . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setSeed ( seed ) ; c . repaint ( ) ; } } ) ; jp . setLayout ( new FlowLayout ( ) ) ; jp . add ( e ) ; jp . add ( t ) ; jp . add ( p ) ; jp . add ( r ) ; cp . add ( jp , BorderLayout . SOUTH ) ; pack ( ) ; setVisible ( true ) ; }
va	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
va	1	public ModificationException ( final class < ? > classTriedToChange , final String fieldTryingToChange ) { super ( createMessage ( classTriedToChange , fieldTryingToChange , null , null ) ) ; }
va	4	public void printHolder ( byte holderID ) { if ( holderID == DataHolder . SENTENCE ) { printHolder ( holderID , 0 , this . sentenceTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . SINGULAR_PLURAL ) { printHolder ( holderID , 0 , this . singularPluralTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . UNKNOWNWORD ) { printHolder ( holderID , 0 , this . unknownWordTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . WORDPOS ) { printHolder ( holderID , 0 , this . wordPOSTable . size ( ) - 1 ) ; } }
va	6	@ Test public void testConstructor ( ) { String nulltag = null ; Object nullval = null ; DataField field = new DataField ( "" ) ; field . getValue ( ) ; field = new DataField ( nullval ) ; field = new DataField ( new long ( 0 ) ) ; field = new DataField ( new String ( ) , new String ( ) ) ; new DataField ( nulltag , nullval ) ; field = new DataField ( 0 ) ; field = new DataField ( new String ( ) , 0 ) ; field = new DataField ( nulltag , 0 ) ; field = new DataField ( 0 ) ; field = new DataField ( new String ( ) , 0 ) ; field = new DataField ( nulltag , 0 ) ; field = new DataField ( ( short ) 0 ) ; field = new DataField ( new String ( ) , ( short ) 0 ) ; field = new DataField ( nulltag , ( short ) 0 ) ; field = new DataField ( new byte [ 0 ] ) ; field = new DataField ( new String ( ) , new byte [ 0 ] ) ; field = new DataField ( nulltag , new byte [ 0 ] ) ; field = new DataField ( ( byte [ ] ) null ) ; field = new DataField ( nulltag , ( byte [ ] ) null ) ; field = new DataField ( 0f ) ; field = new DataField ( new String ( ) , 0f ) ; field = new DataField ( nulltag , 0f ) ; field = new DataField ( 0d ) ; field = new DataField ( new String ( ) , 0d ) ; field = new DataField ( nulltag , 0d ) ; field = new DataField ( true ) ; field = new DataField ( new String ( ) , true ) ; field = new DataField ( nulltag , true ) ; field = new DataField ( new Date ( ) ) ; field = new DataField ( new String ( ) , new Date ( ) ) ; field = new DataField ( null , new Date ( ) ) ; try { field = new DataField ( new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } try { field = new DataField ( new String ( ) , new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } try { field = new DataField ( nulltag , new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } }
va	0	private void jButton11ActionPerformed ( java . awt . event . ActionEvent evt ) { jButton9 . setEnabled ( true ) ; jButton10 . setEnabled ( false ) ; jButton11 . setEnabled ( false ) ; jButton12 . setEnabled ( false ) ; Music . Stop ( ) ; }
va	6	public List < CommitDiff > getDiffTreeFromFirstCommit ( String fileID , String commitID ) { try { List < CommitDiff > CommitList = new ArrayList < CommitDiff > ( ) ; String sql = "SELECT file_id  new_commit_id  old_commit_id  diff_text  char_start  char_end  diff_type from commits natural join file_diffs where " + "file_id=? and " + "(branch_id=? or branch_id is NULL) and commit_date<= " + "(select commit_date from commits where commit_id=? and " + "(branch_id=? OR branch_id is NULL) limit 1) AND new_commit_id= commit_id ORDER BY old_commit_id  new_commit_id" ; ISetter [ ] parms = { new StringSetter ( 1 , fileID ) , new StringSetter ( 2 , this . branchID ) , new StringSetter ( 3 , commitID ) , new StringSetter ( 4 , this . branchID ) } ; PreparedStatementExecutionItem ei = new PreparedStatementExecutionItem ( sql , parms ) ; addExecutionItem ( ei ) ; ei . waitUntilExecuted ( ) ; ResultSet rs = ei . getResult ( ) ; if ( ! rs . next ( ) ) return CommitList ; String currentNewCommitId = rs . getString ( "new_commit_id" ) ; String currentOldCommitId = rs . getString ( "old_commit_id" ) ; String currentFileId = rs . getString ( "file_id" ) ; String currentDiffTxt = rs . getString ( "diff_text" ) ; String currentDiffType = rs . getString ( "diff_type" ) ; int currentCharStart = rs . getInt ( "char_start" ) ; int currentCharEnd = rs . getInt ( "char_end" ) ; List < FileDiff > currentFileDiffList = new ArrayList < FileDiff > ( ) ; CommitDiff currentCommitDiff = new CommitDiff ( currentNewCommitId , currentOldCommitId , currentFileDiffList ) ; DiffEntry de = new DiffEntry ( currentFileId , currentNewCommitId , currentOldCommitId , currentDiffTxt , currentCharStart , currentCharEnd , currentDiffType ) ; FileDiff currentFileDiff = new FileDiff ( currentFileId , new ArrayList < DiffEntry > ( ) ) ; currentFileDiff . addDiffEntry ( de ) ; while ( rs . next ( ) ) { String newCommitId = rs . getString ( "new_commit_id" ) ; String oldCommitId = rs . getString ( "old_commit_id" ) ; String fileId = rs . getString ( "file_id" ) ; String diffTxt = rs . getString ( "diff_text" ) ; String diffType = rs . getString ( "diff_type" ) ; int charStart = rs . getInt ( "char_start" ) ; int charEnd = rs . getInt ( "char_end" ) ; if ( newCommitId . equals ( currentNewCommitId ) && oldCommitId . equals ( currentOldCommitId ) ) { if ( fileId . equals ( currentFileId ) ) { currentFileDiff . addDiffEntry ( new DiffEntry ( fileId , newCommitId , oldCommitId , diffTxt , charStart , charEnd , diffType ) ) ; } else { currentCommitDiff . addFileDiff ( currentFileDiff ) ; currentFileDiff = new FileDiff ( fileId , new ArrayList < DiffEntry > ( ) ) ; currentFileId = fileId ; } } else { currentCommitDiff . addFileDiff ( currentFileDiff ) ; CommitList . add ( currentCommitDiff ) ; currentCommitDiff = new CommitDiff ( newCommitId , oldCommitId , new ArrayList < FileDiff > ( ) ) ; currentNewCommitId = newCommitId ; currentOldCommitId = oldCommitId ; currentFileDiff = new FileDiff ( fileId , new ArrayList < DiffEntry > ( ) ) ; currentFileId = fileId ; currentFileDiff . addDiffEntry ( new DiffEntry ( fileId , newCommitId , oldCommitId , diffTxt , charStart , charEnd , diffType ) ) ; } } currentCommitDiff . addFileDiff ( currentFileDiff ) ; CommitList . add ( currentCommitDiff ) ; return CommitList ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } }
va	5	private static int copyRefs ( ArrayList < String > target , Pattern pattern1 , Pattern pattern2 ) { if ( pattern1 . refs == null && pattern2 . refs == null ) return 0 ; int offset = 0 ; if ( pattern1 . refs != null ) { offset = pattern1 . refs . size ( ) ; target . addAll ( pattern1 . refs ) ; if ( pattern2 . refs == null || pattern2 . refs . equals ( pattern1 . refs ) ) return 0 ; } target . addAll ( pattern2 . refs ) ; return offset ; }
va	8	@ Override public void mouseClicked ( int button , int x , int y , int clickcount ) { System . out . println ( "clicked in a window  x:" + x + " y:" + y ) ; boolean found = false ; for ( GUIObject obj : objects . values ( ) ) { if ( ! obj . isInput ( ) ) continue ; if ( x >= obj . getRealX ( ) && x < obj . getRealX ( ) + obj . getRealWidth ( ) ) { if ( y >= obj . getRealY ( ) && y < obj . getRealY ( ) + obj . getRealHeight ( ) ) { found = true ; System . out . println ( "Clicked " + obj . getName ( ) ) ; obj . mouseClicked ( button , x - obj . getRealX ( ) , y - obj . getRealY ( ) , clickcount ) ; break ; } } } if ( ! found ) { if ( selected != null ) { selected . setSelected ( false ) ; selected = null ; } } }
va	8	private static int [ ] [ ] LCS_length ( String X , String Y ) { int a [ ] [ ] = new int [ X . length ( ) + 1 ] [ Y . length ( ) + 1 ] ; char b [ ] [ ] = new char [ X . length ( ) ] [ Y . length ( ) ] ; for ( int i = 0 ; i < X . length ( ) ; i ++ ) { a [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j < Y . length ( ) ; j ++ ) { a [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < X . length ( ) + 1 ; i ++ ) { for ( int j = 1 ; j < Y . length ( ) + 1 ; j ++ ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { a [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] + 1 ; b [ i - 1 ] [ j - 1 ] = ↖ ; } else { if ( a [ i - 1 ] [ j ] >= a [ i ] [ j - 1 ] ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] ; b [ i - 1 ] [ j - 1 ] = ↑ ; } else { a [ i ] [ j ] = a [ i ] [ j - 1 ] ; b [ i - 1 ] [ j - 1 ] = ← ; } } } } for ( int i = 0 ; i < b . length ; i ++ ) { System . out . println ( Arrays . toString ( b [ i ] ) ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { System . out . println ( Arrays . toString ( a [ i ] ) ) ; } return a ; }
va	6	public static void main ( String [ ] args ) { int LENGTH = 5 ; int [ ] sort = new int [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { sort [ i ] = ( int ) ( Math . random ( ) * 40 ) ; } String s = "" ; for ( int nr : sort ) { s += nr + " " ; } System . out . println ( "sorting table: " + s ) ; for ( int i = 1 ; i < sort . length ; i ++ ) { int key = sort [ i ] ; int j = i - 1 ; while ( j >= 0 && sort [ j ] > key ) { sort [ j + 1 ] = sort [ j ] ; j -= 1 ; } sort [ j + 1 ] = key ; } String ss = "" ; for ( int nr : sort ) { ss += nr + " " ; } System . out . println ( "sorted table: " + ss ) ; }
va	9X	public final double nextGaussian ( ) { if ( __haveNextNextGaussian ) { __haveNextNextGaussian = false ; return __nextNextGaussian ; } else { double v1 , v2 , s ; do { int y ; int z ; int a ; int b ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } z = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; mti = 0 ; } z = mt [ mti ++ ] ; z ^= z >>> 11 ; z ^= ( z << 7 ) & TEMPERING_MASK_B ; z ^= ( z << 15 ) & TEMPERING_MASK_C ; z ^= ( z >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } a = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; mti = 0 ; } a = mt [ mti ++ ] ; a ^= a >>> 11 ; a ^= ( a << 7 ) & TEMPERING_MASK_B ; a ^= ( a << 15 ) & TEMPERING_MASK_C ; a ^= ( a >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } b = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; mti = 0 ; } b = mt [ mti ++ ] ; b ^= b >>> 11 ; b ^= ( b << 7 ) & TEMPERING_MASK_B ; b ^= ( b << 15 ) & TEMPERING_MASK_C ; b ^= ( b >>> 18 ) ; v1 = 2 * ( ( ( ( ( long ) ( y >>> 6 ) ) << 27 ) + ( z >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; v2 = 2 * ( ( ( ( ( long ) ( a >>> 6 ) ) << 27 ) + ( b >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s >= 1 || s == 0 ) ; double multiplier = StrictMath . sqrt ( - 2 * StrictMath . log ( s ) / s ) ; __nextNextGaussian = v2 * multiplier ; __haveNextNextGaussian = true ; return v1 * multiplier ; } }
va	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
va	5	public static void main ( String [ ] args ) { List < Integer > primes = new LinkedList < Integer > ( ) ; primes . add ( 2 ) ; while ( primes . size ( ) < 10002 ) { for ( Integer i = primes . get ( primes . size ( ) - 1 ) + 1 ; ; i ++ ) { boolean flag = true ; for ( Integer r : primes ) { if ( i % r == 0 ) { flag = false ; } } if ( flag ) { primes . add ( i ) ; System . out . println ( i ) ; break ; } } } System . out . println ( "result" + primes . get ( 10000 ) ) ; }
va	4	public void draw ( PrimitiveShape shape , Frustum frustum ) { if ( frustum . intersects ( this ) ) { if ( children != null ) { for ( byte i = 0 ; i < SUBDIVISIONS ; i ++ ) { children [ i ] . draw ( shape , frustum ) ; } } if ( enabled ) { shape . addAABB ( this ) ; } } }
va	9X	void checkConsistency ( ) { HalfEdge hedge = he0 ; double maxd = 0 ; int numv = 0 ; if ( numVerts < 3 ) { throw new InternalErrorException ( "degenerate face: " + getVertexString ( ) ) ; } do { HalfEdge hedgeOpp = hedge . getOpposite ( ) ; if ( hedgeOpp == null ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "unreflected half edge " + hedge . getVertexString ( ) ) ; } else if ( hedgeOpp . getOpposite ( ) != hedge ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "opposite half edge " + hedgeOpp . getVertexString ( ) + " has opposite " + hedgeOpp . getOpposite ( ) . getVertexString ( ) ) ; } if ( hedgeOpp . head ( ) != hedge . tail ( ) || hedge . head ( ) != hedgeOpp . tail ( ) ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "half edge " + hedge . getVertexString ( ) + " reflected by " + hedgeOpp . getVertexString ( ) ) ; } Face oppFace = hedgeOpp . face ; if ( oppFace == null ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "no face on half edge " + hedgeOpp . getVertexString ( ) ) ; } else if ( oppFace . mark == DELETED ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "opposite face " + oppFace . getVertexString ( ) + " not on hull" ) ; } double d = Math . abs ( distanceToPlane ( hedge . head ( ) . pnt ) ) ; if ( d > maxd ) { maxd = d ; } numv ++ ; hedge = hedge . next ; } while ( hedge != he0 ) ; if ( numv != numVerts ) { throw new InternalErrorException ( "face " + getVertexString ( ) + " numVerts=" + numVerts + " should be " + numv ) ; } }
va	7	public static List < Integer > parse ( final JTextField inputField , final MainFrame mainFrame , final int count ) { try { final String input = inputField . getText ( ) ; String [ ] tokens = removeWhiteSpace ( input ) . split ( " " ) ; if ( tokens . length != count ) { tokens = input . split ( "\\s+" ) ; if ( tokens . length != count ) throw new IllegalArgumentException ( "Invalid number of arguments." ) ; } final List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; ++ i ) { final int number = Integer . parseInt ( tokens [ i ] ) ; result . add ( number ) ; if ( ( number < Config . MIN_INT ) || ( number > Config . MAX_INT ) ) throw new NumberFormatException ( "Invalid range." ) ; } inputField . setBackground ( Color . white ) ; return result ; } catch ( IllegalArgumentException ex ) { String msg ; if ( count == 0 ) msg = "P\u0159\u00EDklad nem\u00E1 \u0159e\u0161en\u00ED." ; else msg = "Pros\u00EDm zadejte " + count + " celo\u010D\u00EDseln\u00E9 koeficienty odd\u011Blen\u00E9 mezerou." ; error ( inputField , mainFrame , msg . toString ( ) ) ; return new ArrayList < > ( ) ; } }
va	1	private void setupServerEnvironment ( ) { if ( ssl ) HTTPSSession . register ( TransportRegistry . getTransportRegistryInstance ( ) ) ; else HTTPSessionApache . register ( TransportRegistry . getTransportRegistryInstance ( ) ) ; }
va	6	public void nextPermutation ( int [ ] nums ) { if ( nums . length <= 1 ) { return ; } int i = nums . length - 2 ; for ( ; i >= 0 ; i -- ) { if ( nums [ i + 1 ] > nums [ i ] ) { break ; } } if ( i == - 1 ) { reverse ( nums , 0 , nums . length - 1 ) ; return ; } for ( int j = nums . length - 1 ; j > i ; j -- ) { if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } } reverse ( nums , i + 1 , nums . length - 1 ) ; }
va	6	public static double [ ] getAlleleTotals ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; double alleleTotals [ ] = new double [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0.0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; alleleTotals [ i ] += v ; } i ++ ; } } } return alleleTotals ; }
va	9X	private String [ ] parseLine ( String nextLine ) throws IOException { if ( nextLine == null ) { return null ; } List tokensOnThisLine = new ArrayList ( ) ; StringBuffer sb = new StringBuffer ( ) ; boolean inQuotes = false ; do { if ( inQuotes ) { sb . append ( "\n" ) ; nextLine = getNextLine ( ) ; if ( nextLine == null ) break ; } for ( int i = 0 ; i < nextLine . length ( ) ; i ++ ) { char c = nextLine . charAt ( i ) ; if ( c == quotechar ) { if ( inQuotes && nextLine . length ( ) > ( i + 1 ) && nextLine . charAt ( i + 1 ) == quotechar ) { sb . append ( nextLine . charAt ( i + 1 ) ) ; i ++ ; } else { inQuotes = ! inQuotes ; if ( i > 2 && nextLine . charAt ( i - 1 ) != this . separator && nextLine . length ( ) > ( i + 1 ) && nextLine . charAt ( i + 1 ) != this . separator ) { sb . append ( c ) ; } } } else if ( c == separator && ! inQuotes ) { tokensOnThisLine . add ( sb . toString ( ) ) ; sb = new StringBuffer ( ) ; } else { sb . append ( c ) ; } } } while ( inQuotes ) ; tokensOnThisLine . add ( sb . toString ( ) ) ; return ( String [ ] ) tokensOnThisLine . toArray ( new String [ 0 ] ) ; }
va	1	public void setHealth ( int health ) { if ( health <= getMaxHealth ( ) ) this . health = health ; else this . health = getMaxHealth ( ) ; }
va	4	public void drawComponents ( BufferedImage canvas , boolean drawCorner ) { if ( _components == null ) findComponents ( ) ; BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < _width ; x ++ ) for ( int y = 0 ; y < _height ; y ++ ) image . setRGB ( x , y , ffffff ) ; for ( ConnectedComponent cc : _components ) cc . draw ( image , true , drawCorner ) ; canvas . createGraphics ( ) . drawImage ( image , 0 , 0 , null ) ; }
va	4	private void addFieldListeners ( ) { nameField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setName ( nameField . getText ( ) ) ; nameField . setBackground ( Color . green ) ; } catch ( Exception ex ) { nameField . setBackground ( Color . red ) ; cage . setName ( "Name" ) ; nameField . setText ( "Name" ) ; } } } ) ; sizeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setSize ( double . parseDouble ( sizeField . getText ( ) ) ) ; sizeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { sizeField . setBackground ( Color . red ) ; cage . setSize ( Cage . MIN_CAGE_AREA ) ; sizeField . setText ( "" + Cage . MIN_CAGE_AREA ) ; } } } ) ; longitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLongitude ( double . parseDouble ( longitudeField . getText ( ) ) ) ; longitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { longitudeField . setBackground ( Color . red ) ; cage . setLongitude ( Cage . LONGITUDE_MIN ) ; longitudeField . setText ( "" + Cage . LONGITUDE_MIN ) ; } } } ) ; latitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLatitude ( double . parseDouble ( latitudeField . getText ( ) ) ) ; latitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { latitudeField . setBackground ( Color . red ) ; cage . setLatitude ( Cage . LATITUDE_MIN ) ; latitudeField . setText ( "" + Cage . LATITUDE_MIN ) ; } } } ) ; }
va	2	private AvlNode findMax ( AvlNode t ) { if ( t == null ) return t ; while ( t . right != null ) t = t . right ; return t ; }
va	2	public static List < InputNeuron > getInputNeurons ( ILayer layer ) { List < InputNeuron > neurons = new ArrayList < InputNeuron > ( ) ; for ( INeuron neuron : layer . getNeurons ( ) ) { if ( neuron instanceof InputNeuron ) neurons . add ( ( InputNeuron ) neuron ) ; } return neurons ; }
va	3	public void createClusterMembershipList ( Set < Integer > nodes , String map , String clusters , String output ) { try { Map < Integer , Integer > M = readMap ( map , false ) ; String line ; String [ ] parts ; BufferedReader in = new BufferedReader ( new FileReader ( clusters ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( output ) ) ; int node ; while ( ( line = in . readLine ( ) ) != null ) { parts = line . split ( " " ) ; node = M . get ( Integer . parseInt ( parts [ 0 ] . trim ( ) ) ) ; if ( nodes . contains ( node ) ) { out . write ( node + " " + parts [ 1 ] . trim ( ) + "\n" ) ; } } out . flush ( ) ; out . close ( ) ; in . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( LinkSetAnalyser . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	2	public void getStopWordSet ( ) { try { BufferedReader in = new BufferedReader ( new FileReader ( STOPWORDS_PATH ) ) ; String s ; while ( ( s = in . readLine ( ) ) != null ) stopWordSet . add ( s ) ; in . close ( ) ; } catch ( IOException e ) { System . err . println ( e ) ; } }
va	1	@ Override public void step ( ) { for ( AgentModel m : agents . values ( ) ) { m . model . step ( ) ; } }
va	1	public void parse ( ) { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { final SAXParser saxParser = factory . newSAXParser ( ) ; final InputSource source = new InputSource ( lexicon ) ; source . setEncoding ( "UTF-8" ) ; saxParser . parse ( source , this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	8	private void direccionproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != # && evt . getKeyChar ( ) != . && evt . getKeyChar ( ) != - && evt . getKeyChar ( ) !=   && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( laboratorioperteneceField . getText ( ) . length ( ) == 100 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Direccion demasiado larga." , "ADVERTENCIA" , WIDTH ) ; } }
va	5	@ Override public void onCommand ( POP3Session session , String argument1 , String argument2 ) throws POP3Exception { if ( session . getState ( ) != POP3State . AUTHORIZATION_USERSET || argument1 == null || argument2 != null ) { throw new POP3Exception ( "-ERR syntax error" ) ; } String loginUserName = session . getLoginUserName ( ) ; String password = argument1 ; UserListManager userListManager = UserListManager . getInstance ( ) ; if ( ! userListManager . checkUserLogin ( loginUserName , password ) ) { session . setState ( POP3State . AUTHORIZATION_READY ) ; throw new POP3Exception ( "-ERR authentication failed" ) ; } if ( ! userListManager . isUserLocked ( loginUserName , LockType . POP3 ) ) { userListManager . lockUser ( loginUserName , LockType . POP3 ) ; session . setUser ( userListManager . getUser ( loginUserName ) ) ; session . setState ( POP3State . TRANSACTION ) ; session . sendResponse ( "+OK welcome " + loginUserName ) ; session . getLogger ( ) . debug ( "pop3:" + loginUserName + " login successfully" ) ; } else { session . setState ( POP3State . AUTHORIZATION_READY ) ; throw new POP3Exception ( "-ERR user has logined" ) ; } }
va	4	public void merge ( final Object [ ] destSubs , final Object [ ] origSubs ) { Node origNode = findNode ( origSubs ) ; Node destNode = findNode ( destSubs ) ; if ( destNode == null ) { destNode = setting ( destSubs , null ) ; } if ( origNode == null ) { origNode = setting ( origSubs , null ) ; } if ( origNode . getValue ( ) != null ) { destNode . setValue ( origNode . getValue ( ) ) ; } if ( origNode . hasSubnodes ( ) ) { mergeSubnodesOperation . set ( destSubs , origSubs ) ; operateOverSubnodes ( origNode . getSubnode ( ) , mergeSubnodesOperation ) ; } }
va	1	public double sum ( ) { double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) sum += x [ i ] ; return sum ; }
va	0	public int getDdd ( ) { return ddd ; }
va	4	private void findPlacement ( Node tobeAdded ) { Node u = root ; while ( true ) { if ( comparator . compare ( tobeAdded . key , u . key ) < 0 ) { if ( u . left == null ) { u . left = tobeAdded ; tobeAdded . parent = u ; break ; } else u = u . left ; } else { if ( u . right == null ) { u . right = tobeAdded ; tobeAdded . parent = u ; break ; } else u = u . right ; } } }
va	3	void selectMoreRow ( ContainerComponent containerComponent ) { if ( libraryTable == null ) return ; for ( int i = 0 ; i < libraryTable . getRowCount ( ) ; i ++ ) { Container rowData = ( Container ) libraryTable . getValueAt ( i , - 1 ) ; if ( rowData == containerComponent . container ) { libraryTable . addRowSelectionInterval ( i , i ) ; Rectangle rect = libraryTable . getCellRect ( i , 0 , true ) ; libraryTable . scrollRectToVisible ( rect ) ; break ; } } }
va	6	public boolean shiftUp ( ) { boolean empty = true ; for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { if ( currentShape [ 0 ] [ j ] ) empty = false ; } if ( empty ) { for ( int i = 1 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ i - 1 ] [ j ] = currentShape [ i ] [ j ] ; } } for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ PIECE_SIZE - 1 ] [ j ] = false ; } } return empty ; }
va	0	private void show ( String prefix , String text ) { System . out . println ( prefix + text ) ; }
va	7	String toString ( int indentFactor , int indent ) throws JSONException { int j ; int n = length ( ) ; if ( n == 0 ) { return "{}" ; } Iterator keys = sortedKeys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; int newindent = indent + indentFactor ; Object o ; if ( n == 1 ) { o = keys . next ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( o ) , indentFactor , indent ) ) ; } else { while ( keys . hasNext ( ) ) { o = keys . next ( ) ; if ( sb . length ( ) > 1 ) { sb . append ( " \n" ) ; } else { sb . append ( '' ) ; } for ( j = 0 ; j < newindent ; j += 1 ) { sb . append (   ) ; } sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( o ) , indentFactor , newindent ) ) ; } if ( sb . length ( ) > 1 ) { sb . append ( '' ) ; for ( j = 0 ; j < indent ; j += 1 ) { sb . append (   ) ; } } } sb . append ( } ) ; return sb . toString ( ) ; }
va	1	private boolean r_R1 ( ) { if ( ! ( I_p1 <= cursor ) ) { return false ; } return true ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new crearCuenta ( ) . setVisible ( true ) ; } } ) ; }
va	0	public static LatLonFormat fromValue ( String v ) { return valueOf ( v ) ; }
va	5	Document createDocument ( DocumentType docType , QName rootElement ) throws FastInfosetException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DOMImplementation domImplementation ; try { domImplementation = dbf . newDocumentBuilder ( ) . getDOMImplementation ( ) ; } catch ( ParserConfigurationException ex ) { throw new FastInfosetException ( ex ) ; } org . w3c . dom . DocumentType createDocumentType = null ; if ( docType != null ) createDocumentType = domImplementation . createDocumentType ( rootElement . getLocalPart ( ) , docType . publicIdentifier , docType . systemIdentifier ) ; Document doc = domImplementation . createDocument ( rootElement . getNamespaceURI ( ) , rootElement . getPrefix ( ) . isEmpty ( ) ? rootElement . getLocalPart ( ) : rootElement . getPrefix ( ) + ":" + rootElement . getLocalPart ( ) , createDocumentType ) ; for ( ProcessingInstruction pi : _pis ) { doc . insertBefore ( doc . createProcessingInstruction ( pi . target , pi . content ) , doc . getDocumentElement ( ) ) ; } for ( String str : _comments ) { doc . insertBefore ( doc . createComment ( str ) , doc . getDocumentElement ( ) ) ; } setVersionAndStandAlone ( doc ) ; return doc ; }
va	8	public static boolean overlaps ( Rectangle r1 , Rectangle r2 ) { if ( r1 . contains ( r2 . getLocation ( ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x , r2 . y + r2 . height ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y + r2 . height ) ) ) { return true ; } if ( r2 . contains ( r1 . getLocation ( ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x , r1 . y + r1 . height ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y + r1 . height ) ) ) { return true ; } return false ; }
va	7	public void handleDeletedFiles ( ) { Iterator < Path > itrd = deletedFiles . iterator ( ) ; Iterator < Path > itrc = null ; Iterator < Path > itrm = null ; Iterator < RenamedFile > itrr = null ; RenamedFile toRename ; Path pathm , pathc , pathd ; logger . debug ( "Handle Deleted Files has started." ) ; while ( itrd . hasNext ( ) ) { pathd = itrd . next ( ) ; itrc = createdFiles . iterator ( ) ; itrm = modifiedFiles . iterator ( ) ; itrr = renamedFiles . iterator ( ) ; while ( itrc . hasNext ( ) ) { pathc = itrc . next ( ) ; if ( pathd . equals ( pathc ) ) { itrc . remove ( ) ; } } while ( itrm . hasNext ( ) ) { pathm = itrm . next ( ) ; if ( pathd . equals ( pathm ) ) { itrm . remove ( ) ; } } while ( itrr . hasNext ( ) ) { toRename = itrr . next ( ) ; if ( pathd . equals ( toRename . oldName ) ) { itrr . remove ( ) ; } } itrd . remove ( ) ; } }
va	4	public User getCreatorOfColour ( ColourRef cref ) { ClientResponse cresp ; try { cresp = service . path ( cref . getRef ( ) ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; } catch ( ClientHandlerException che ) { return null ; } if ( cresp . getStatus ( ) == 200 ) { ClientResponse u_cresp ; try { u_cresp = service . path ( cresp . getEntity ( Colour . class ) . getCreator ( ) . getRef ( ) ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; } catch ( ClientHandlerException che ) { return null ; } if ( u_cresp . getStatus ( ) == 200 ) { return u_cresp . getEntity ( User . class ) ; } } return null ; }
va	4	public final BlockContext block ( ) throws RecognitionException { BlockContext _localctx = new BlockContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 10 , RULE_block ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 94 ) ; match ( { ) ; setState ( 98 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( _la == TIPO ) { { { setState ( 95 ) ; var_decl ( ) ; } } setState ( 100 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 104 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( ( ( ( _la ) & ~ 3f ) == 0 && ( ( 1 << _la ) & ( ( 1 << if ) | ( 1 << for ) | ( 1 << return ) | ( 1 << break ) | ( 1 << continue ) | ( 1 << CALLOUT ) | ( 1 << { ) | ( 1 << ID ) ) ) != 0 ) ) { { { setState ( 101 ) ; statement ( ) ; } } setState ( 106 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 107 ) ; match ( } ) ; linea ++ ; arbol . add ( "Bloque " + linea ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
va	3	public static double test ( double [ ] [ ] A , double [ ] b ) { GaussJordanElimination gaussian = new GaussJordanElimination ( A , b ) ; System . out . print ( "\nOriginal: " ) ; for ( double aDouble : b ) { System . out . print ( aDouble + " " ) ; } System . out . println ( ) ; if ( gaussian . isFeasible ( ) ) { double suma = 0.0 ; double [ ] x = gaussian . primal ( ) ; for ( int i = 0 ; i < x . length ; i ++ ) { System . out . printf ( "%9.2f\t" , x [ i ] ) ; suma += Math . abs ( x [ i ] ) ; } System . out . printf ( "\n\t(%6.2f)\n" , varianza ( x ) ) ; return suma ; } else { System . out . println ( "no hay solucion" ) ; System . out . println ( ) ; } return double . MAX_VALUE ; }
va	5	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . indexOf (   ) >= 0 ) { if ( s . indexOf ( " ) >= 0 ) { sb . append ( ' ) ; sb . append ( s ) ; sb . append ( ' ) ; } else { sb . append ( " ) ; sb . append ( s ) ; sb . append ( " ) ; } } else { sb . append ( s ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
va	5	private CarCriterion carCriterionParse ( String a ) { if ( a . equals ( CarCriterion . COMFORT . toString ( ) ) ) { return CarCriterion . COMFORT ; } else if ( a . equals ( CarCriterion . ECONOMY . toString ( ) ) ) { return CarCriterion . ECONOMY ; } else if ( a . equals ( CarCriterion . HANDLING . toString ( ) ) ) { return CarCriterion . HANDLING ; } else if ( a . equals ( CarCriterion . PERFORMANCE . toString ( ) ) ) { return CarCriterion . PERFORMANCE ; } else if ( a . equals ( CarCriterion . QUALITY . toString ( ) ) ) { return CarCriterion . QUALITY ; } else { return null ; } }
va	5	public void serialize ( final javax . xml . namespace . QName parentQName , javax . xml . stream . XMLStreamWriter xmlWriter , boolean serializeType ) throws javax . xml . stream . XMLStreamException , org . apache . axis2 . databinding . ADBException { java . lang . String prefix = null ; java . lang . String namespace = null ; prefix = parentQName . getPrefix ( ) ; namespace = parentQName . getNamespaceURI ( ) ; writeStartElement ( prefix , namespace , parentQName . getLocalPart ( ) , xmlWriter ) ; if ( serializeType ) { java . lang . String namespacePrefix = registerPrefix ( xmlWriter , "http://tinyurl.com.src" ) ; if ( ( namespacePrefix != null ) && ( namespacePrefix . trim ( ) . length ( ) > 0 ) ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , namespacePrefix + ":getLongUrl" , xmlWriter ) ; } else { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , "getLongUrl" , xmlWriter ) ; } } if ( localShortUrlTracker ) { namespace = "http://tinyurl.com.src" ; writeStartElement ( null , namespace , "shortUrl" , xmlWriter ) ; if ( localShortUrl == null ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "nil" , "1" , xmlWriter ) ; } else { xmlWriter . writeCharacters ( localShortUrl ) ; } xmlWriter . writeEndElement ( ) ; } xmlWriter . writeEndElement ( ) ; }
va	2	public DefaultSettingsModifierPanel ( GCT gctarg , boolean [ ] editedarg ) { gct = gctarg ; edited = editedarg ; setLayout ( new BorderLayout ( ) ) ; useCode = new JCheckBox ( "Include Default Settings Modifier" , findDSMInstance ( ) ) ; useCode . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { edited [ 0 ] = true ; if ( dsm != null ) { gct . deleteDynamicCode ( dsm ) ; dsm = null ; } else { dsm = new DSM ( ) ; gct . addDynamicCode ( dsm ) ; } initialize ( ) ; } } ) ; add ( useCode , BorderLayout . NORTH ) ; container = new JPanel ( ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . Y_AXIS ) ) ; JPanel [ ] rows = { new JPanel ( ) , new JPanel ( ) , new JPanel ( ) } ; for ( JPanel p : rows ) { p . setLayout ( new BoxLayout ( p , BoxLayout . X_AXIS ) ) ; container . add ( p ) ; } add ( container , BorderLayout . CENTER ) ; gameType = new JComboBox ( ) ; gameType . addItem ( "Time" ) ; gameType . addItem ( "Stock" ) ; gameType . addItem ( "Coin" ) ; gameType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setGameType ( ( byte ) gameType . getSelectedIndex ( ) ) ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Game Type: " ) ) ; rows [ 0 ] . add ( gameType ) ; time = new SpinnerNumberModel ( 4 , 0 , 99 , 1 ) ; time . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = time . getNumber ( ) . byteValue ( ) ; dsm . setTimeLimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Time (min): " ) ) ; rows [ 0 ] . add ( new JSpinner ( time ) ) ; stock = new SpinnerNumberModel ( 4 , 1 , 99 , 1 ) ; stock . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = stock . getNumber ( ) . byteValue ( ) ; dsm . setStock ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Stock: " ) ) ; rows [ 0 ] . add ( new JSpinner ( stock ) ) ; stocktime = new SpinnerNumberModel ( 8 , 0 , 99 , 1 ) ; stocktime . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = stocktime . getNumber ( ) . byteValue ( ) ; dsm . setStockTimeLimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Stock-mode time: " ) ) ; rows [ 0 ] . add ( new JSpinner ( stocktime ) ) ; handicap = new JComboBox ( ) ; handicap . addItem ( "Off" ) ; handicap . addItem ( "Auto" ) ; handicap . addItem ( "On" ) ; handicap . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setHandicap ( ( byte ) handicap . getSelectedIndex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Handicap: " ) ) ; rows [ 1 ] . add ( handicap ) ; damageRatio = new SpinnerNumberModel ( 1.0 , 0.5 , 2.0 , .1 ) ; damageRatio . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { double d = 10 * damageRatio . getNumber ( ) . doubleValue ( ) ; dsm . setDamageRatio ( d ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Damage ratio: " ) ) ; rows [ 1 ] . add ( new JSpinner ( damageRatio ) ) ; stageMethod = new JComboBox ( ) ; stageMethod . addItem ( "Choose" ) ; stageMethod . addItem ( "Random" ) ; stageMethod . addItem ( "Take turns" ) ; stageMethod . addItem ( "Ordered" ) ; stageMethod . addItem ( "Loser's pick" ) ; stageMethod . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setStageMethod ( ( byte ) stageMethod . getSelectedIndex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Stage method: " ) ) ; rows [ 1 ] . add ( stageMethod ) ; teamAttack = new JCheckBox ( "Team attack" ) ; teamAttack . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setTeamAttack ( teamAttack . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( teamAttack ) ; pause = new JCheckBox ( "Pause" ) ; pause . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setPause ( pause . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( pause ) ; scoreDisplay = new JCheckBox ( "scoreDisplay" ) ; scoreDisplay . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setScoreDisplay ( scoreDisplay . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( scoreDisplay ) ; damageGauge = new JCheckBox ( "damageGauge" ) ; damageGauge . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setDamageGauge ( damageGauge . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( damageGauge ) ; initialize ( ) ; }
va	5	public void editar ( Categoria categoria ) throws NoExisteEntidadException , Exception { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; categoria = em . merge ( categoria ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { long id = categoria . getId ( ) ; if ( encontrarCategoria ( id ) == null ) { throw new NoExisteEntidadException ( "No existe el categoria con id " + id ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
va	2	public static int search_str ( String [ ] s , String key ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] . equals ( key ) ) return i ; } return - 1 ; }
va	4	protected BigRational recallG ( MultiplicitiesVector m , PopulationVector p ) { if ( p . isZeroVector ( ) ) { return BigRational . ONE ; } else if ( p . containsMinusOne ( ) ) { return BigRational . ZERO ; } else if ( m . isZeroVector ( ) ) { return initialConditionFor ( p ) ; } else { Map < MultiplicitiesVector , BigRational > step1 = Gmap . get ( p ) ; if ( step1 != null ) { BigRational toReturn = step1 . get ( m ) ; return toReturn ; } else { return null ; } } }
va	3	private int find ( Temporal point ) { int i ; for ( i = 0 ; i < this . points . size ( ) ; ++ i ) { if ( this . points . get ( i ) . getXCoord ( ) == point . getXCoord ( ) && this . points . get ( i ) . getYCoord ( ) == point . getYCoord ( ) ) return i ; } return - 1 ; }
va	2	public void preorderPositions ( Position < E > v , List < Position < E >> pos ) throws InvalidPositionException { pos . add ( v ) ; if ( hasLeft ( v ) ) { preorderPositions ( left ( v ) , pos ) ; } if ( hasRight ( v ) ) { preorderPositions ( right ( v ) , pos ) ; } }
va	0	protected void addPositionalPointer ( CellElement e , int wantedPos ) { PointerCell pCell = new PointerCell ( e , wantedPos ) ; this . m_pointers . add ( pCell ) ; }
va	5	public static JLabel drawCoolLineChart ( TreeMap < String , double > data ) { String [ ] dates = new String [ data . size ( ) ] ; double [ ] values = new double [ data . size ( ) ] ; String [ ] literalValues = new String [ data . size ( ) ] ; int i = 0 ; double greatest = 0 ; for ( String str : data . keySet ( ) ) { dates [ i ] = str ; values [ i ] = data . get ( str ) ; if ( values [ i ] > greatest ) greatest = values [ i ] ; i ++ ; } greatest += greatest * 1 / 6 ; for ( int j = 0 ; j < values . length ; j ++ ) { values [ j ] = ( values [ j ] * 100 ) / greatest ; } Line line1 = Plots . newLine ( Data . newData ( values ) , Color . newColor ( "CA3D05" ) ) ; line1 . setLineStyle ( LineStyle . newLineStyle ( 3 , 1 , 0 ) ) ; line1 . addShapeMarkers ( Shape . DIAMOND , Color . newColor ( "CA3D05" ) , 12 ) ; line1 . addShapeMarkers ( Shape . DIAMOND , Color . WHITE , 8 ) ; LineChart chart = GCharts . newLineChart ( line1 ) ; chart . setSize ( 600 , 450 ) ; chart . setTitle ( "Value of the title in time" , Color . WHITE , 14 ) ; chart . setGrid ( 25 , 25 , 3 , 2 ) ; AxisStyle axisStyle = AxisStyle . newAxisStyle ( Color . WHITE , 12 , AxisTextAlignment . CENTER ) ; AxisLabels xAxis = AxisLabelsFactory . newAxisLabels ( dates ) ; xAxis . setAxisStyle ( axisStyle ) ; chart . addXAxisLabels ( xAxis ) ; AxisLabels xAxis2 = AxisLabelsFactory . newAxisLabels ( "Time" , 50.0 ) ; xAxis2 . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; chart . addXAxisLabels ( xAxis2 ) ; AxisLabels yAxis = AxisLabelsFactory . newNumericRangeAxisLabels ( 0 , greatest ) ; yAxis . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; yAxis . setAxisStyle ( axisStyle ) ; chart . addYAxisLabels ( yAxis ) ; AxisLabels yAxis2 = AxisLabelsFactory . newAxisLabels ( "Valu\nin\nUSD" , 50.0 ) ; yAxis2 . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; yAxis2 . setAxisStyle ( axisStyle ) ; chart . addYAxisLabels ( yAxis2 ) ; chart . setBackgroundFill ( Fills . newSolidFill ( Color . newColor ( "1F1D1D" ) ) ) ; LinearGradientFill fill = Fills . newLinearGradientFill ( 0 , Color . newColor ( "363433" ) , 100 ) ; fill . addColorAndOffset ( Color . newColor ( "2E2B2A" ) , 0 ) ; chart . setAreaFill ( fill ) ; try { return new JLabel ( new ImageIcon ( ImageIO . read ( new URL ( chart . toURLString ( ) ) ) ) ) ; } catch ( MalformedURLException e ) { } catch ( IOException e ) { } return null ; }
va	9X	@ Override public ByteBuffer createBinaryFrame ( Framedata framedata ) { ByteBuffer mes = framedata . getPayloadData ( ) ; boolean mask = role == Role . CLIENT ; int sizebytes = mes . remaining ( ) <= 125 ? 1 : mes . remaining ( ) <= 65535 ? 2 : 8 ; ByteBuffer buf = ByteBuffer . allocate ( 1 + ( sizebytes > 1 ? sizebytes + 1 : sizebytes ) + ( mask ? 4 : 0 ) + mes . remaining ( ) ) ; byte optcode = fromOpcode ( framedata . getOpcode ( ) ) ; byte one = ( byte ) ( framedata . isFin ( ) ? - 128 : 0 ) ; one |= optcode ; buf . put ( one ) ; byte [ ] payloadlengthbytes = toByteArray ( mes . remaining ( ) , sizebytes ) ; assert ( payloadlengthbytes . length == sizebytes ) ; if ( sizebytes == 1 ) { buf . put ( ( byte ) ( ( byte ) payloadlengthbytes [ 0 ] | ( mask ? ( byte ) - 128 : 0 ) ) ) ; } else if ( sizebytes == 2 ) { buf . put ( ( byte ) ( ( byte ) 126 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else if ( sizebytes == 8 ) { buf . put ( ( byte ) ( ( byte ) 127 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else throw new RuntimeException ( "Size representation not supported/specified" ) ; if ( mask ) { ByteBuffer maskkey = ByteBuffer . allocate ( 4 ) ; maskkey . putInt ( reuseableRandom . nextInt ( ) ) ; buf . put ( maskkey . array ( ) ) ; for ( int i = 0 ; i < mes . limit ( ) ; i ++ ) { buf . put ( ( byte ) ( mes . get ( ) ^ maskkey . get ( i % 4 ) ) ) ; } } else buf . put ( mes ) ; assert ( buf . remaining ( ) == 0 ) : buf . remaining ( ) ; buf . flip ( ) ; return buf ; }
va	8	@ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { if ( value instanceof ScheduleElementViewWrapper ) { ScheduleElementViewWrapper scheduleElement = ( ScheduleElementViewWrapper ) value ; StudyProgram studyProgram = null ; if ( scheduleElement . getScheduleView ( ) instanceof ScheduleViewStudyProgram ) { studyProgram = ( ( ScheduleViewStudyProgram ) scheduleElement . getScheduleView ( ) ) . getStudyProgramm ( ) ; } if ( scheduleElement . isEmpty ( ) ) { setText ( "" ) ; setToolTipText ( "Nicht belegt." ) ; setBackground ( colorFree ) ; } else { setVerticalAlignment ( SwingConstants . TOP ) ; setBackground ( colorFree ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "<html>" ) ; for ( ScheduleAppointment appointment : scheduleElement . getAppointments ( ) ) { sb . append ( "<div style=\" margin: 3px; padding: 3px; word-wrap: break-word; overflow-x: auto; vertical-align: top;" ) ; sb . append ( "border: 2px solid #cccccc; " ) ; if ( appointment . getCourse ( ) . getType ( ) . getName ( ) . equals ( "Uebung" ) ) { sb . append ( "background-color: #99eeaa; " ) ; } else { sb . append ( "background-color: #99ddff; " ) ; } sb . append ( "\">" ) ; sb . append ( "Kurs " ) ; sb . append ( appointment . getCourse ( ) . getNumber ( ) ) . append ( " (" ) . append ( appointment . getCourse ( ) . getType ( ) . getName ( ) . equals ( "Uebung" ) ? "\u00DCbung" : "Vorlesung" ) . append ( "):<br/>" ) ; sb . append ( "<b>" ) . append ( appointment . getCourse ( ) . getName ( ) ) . append ( "</b><br/>" ) ; sb . append ( "Raum: " ) . append ( appointment . getRoom ( ) . getName ( ) ) . append ( "<br/>" ) ; sb . append ( "Dozent: " ) . append ( appointment . getCourse ( ) . getAcademic ( ) . getName ( ) ) . append ( "<br/>" ) ; sb . append ( "Teilnehmer: " ) . append ( appointment . getCourse ( ) . getStudents ( ) ) ; if ( studyProgram != null ) { sb . append ( "<br/>" ) . append ( studyProgram . getSemesterByCourse ( appointment . getCourse ( ) ) ) ; } sb . append ( "</div>" ) ; } sb . append ( "</html>" ) ; setText ( sb . toString ( ) ) ; } } else if ( value instanceof TimeSlot ) { setVerticalAlignment ( SwingConstants . CENTER ) ; setText ( value . toString ( ) ) ; setToolTipText ( "" ) ; setBackground ( colorTimeSlot ) ; } else { setToolTipText ( "Nicht belegt." ) ; setText ( "" ) ; setBackground ( colorFree ) ; } return this ; }
va	9X	public TicTacToeGameGUI ( String [ ] playerOne , String [ ] playerTwo ) { super ( WINDOW_TITLE , WINDOW_WIDTH , WINDOW_HEIGHT ) ; if ( playerOne [ 2 ] . equals ( "Cross" ) ) { if ( playerOne [ 1 ] . equals ( "Human" ) ) { setPlayerOne ( new HumanPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } else { setPlayerOne ( new TicTacToeComputerPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } if ( playerTwo [ 1 ] . equals ( "Human" ) ) { setPlayerTwo ( new HumanPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } else { setPlayerTwo ( new TicTacToeComputerPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } setPlayerLabel ( playerOne [ 0 ] , "Cross" , playerTwo [ 0 ] , "Nought" ) ; } else { if ( playerOne [ 1 ] . equals ( "Human" ) ) { setPlayerOne ( new HumanPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } else { setPlayerOne ( new TicTacToeComputerPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } if ( playerTwo [ 1 ] . equals ( "Human" ) ) { setPlayerTwo ( new HumanPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } else { setPlayerTwo ( new TicTacToeComputerPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } setPlayerLabel ( playerOne [ 0 ] , "Nought" , playerTwo [ 0 ] , "Cross" ) ; } JMenu menu = new JMenu ( "Menu" ) ; add ( menu ) ; JMenuItem newGameButton = new JMenuItem ( "New Game" ) ; JMenuItem saveGameButton = new JMenuItem ( "Save Game" ) ; JMenuItem loadGameButton = new JMenuItem ( "Load Game" ) ; menu . add ( newGameButton ) ; menu . add ( saveGameButton ) ; menu . add ( loadGameButton ) ; JMenuBar menuBar = new JMenuBar ( ) ; menuBar . add ( menu ) ; setJMenuBar ( menuBar ) ; newGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "new game clicked" ) ; displayPlayAgain ( "Start new game?" ) ; } } ) ; saveGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "save game clicked" ) ; String saveGame = JOptionPane . showInputDialog ( "Enter save name:" ) ; Date dNow = new Date ( ) ; SimpleDateFormat timeStamp = new SimpleDateFormat ( "H.mm dd.MM.yy" ) ; System . out . println ( "Current Date: " + timeStamp . format ( dNow ) ) ; new TicTacToeGameSaver ( "saves\\tictactoesaves\\" + saveGame + "  [" + timeStamp . format ( dNow ) + "]" + ".xml" ) ; } } ) ; loadGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "load game clicked" ) ; String saveFile = "" ; String fileExtension = "" ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new File ( ".\\saves\\tictactoesaves\\" ) ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Game saves only" , "xml" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showOpenDialog ( TicTacToeGameGUI . this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { saveFile = chooser . getSelectedFile ( ) . getName ( ) ; fileExtension = saveFile . substring ( saveFile . lastIndexOf ( "." ) + 1 , saveFile . length ( ) ) ; } if ( fileExtension . equals ( "xml" ) ) { if ( saveFile != "" ) { try { new TicTacToeGameLoader ( "saves\\tictactoesaves\\" + saveFile ) ; } catch ( Exception e ) { System . out . println ( "Corrupted file type." ) ; } } } else { JOptionPane . showMessageDialog ( null , "You have not chosen a game save" ) ; } } } ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { int confirmed = JOptionPane . showConfirmDialog ( null , "Are you sure you want to exit the program?" , "Exit Program Message Box" , JOptionPane . YES_NO_OPTION ) ; if ( confirmed == JOptionPane . YES_OPTION ) { dispose ( ) ; } } } ) ; init ( ) ; setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; setSize ( WINDOW_WIDTH , WINDOW_HEIGHT ) ; setLocationRelativeTo ( null ) ; setVisible ( true ) ; setResizable ( false ) ; setIconImage ( new ImageIcon ( this . getClass ( ) . getResource ( "TicTacToe.jpg" ) ) . getImage ( ) ) ; }
va	9X	public void startgetShortUrl ( src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrl getShortUrl2 , final src . com . tinyurl . TinyUrlWebServiceCallbackHandler callback ) throws java . rmi . RemoteException { org . apache . axis2 . client . OperationClient _operationClient = _serviceClient . createClient ( _operations [ 1 ] . getName ( ) ) ; _operationClient . getOptions ( ) . setAction ( "urn:getShortUrl" ) ; _operationClient . getOptions ( ) . setExceptionToBeThrownOnSOAPFault ( true ) ; addPropertyToOperationClient ( _operationClient , org . apache . axis2 . description . WSDL2Constants . ATTR_WHTTP_QUERY_PARAMETER_SEPARATOR , "&" ) ; org . apache . axiom . soap . SOAPEnvelope env = null ; final org . apache . axis2 . context . MessageContext _messageContext = new org . apache . axis2 . context . MessageContext ( ) ; env = toEnvelope ( getFactory ( _operationClient . getOptions ( ) . getSoapVersionURI ( ) ) , getShortUrl2 , optimizeContent ( new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getShortUrl" ) ) , new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getShortUrl" ) ) ; _serviceClient . addHeadersToEnvelope ( env ) ; _messageContext . setEnvelope ( env ) ; _operationClient . addMessageContext ( _messageContext ) ; _operationClient . setCallback ( new org . apache . axis2 . client . async . AxisCallback ( ) { public void onMessage ( org . apache . axis2 . context . MessageContext resultContext ) { try { org . apache . axiom . soap . SOAPEnvelope resultEnv = resultContext . getEnvelope ( ) ; java . lang . Object object = fromOM ( resultEnv . getBody ( ) . getFirstElement ( ) , src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrlResponse . class , getEnvelopeNamespaces ( resultEnv ) ) ; callback . receiveResultgetShortUrl ( ( src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrlResponse ) object ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetShortUrl ( e ) ; } } public void onError ( java . lang . Exception error ) { if ( error instanceof org . apache . axis2 . AxisFault ) { org . apache . axis2 . AxisFault f = ( org . apache . axis2 . AxisFault ) error ; org . apache . axiom . om . OMElement faultElt = f . getDetail ( ) ; if ( faultElt != null ) { if ( faultExceptionNameMap . containsKey ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ) { try { java . lang . String exceptionClassName = ( java . lang . String ) faultExceptionClassNameMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ; java . lang . class exceptionClass = java . lang . class . forName ( exceptionClassName ) ; java . lang . reflect . Constructor constructor = exceptionClass . getConstructor ( String . class ) ; java . lang . Exception ex = ( java . lang . Exception ) constructor . newInstance ( f . getMessage ( ) ) ; java . lang . String messageClassName = ( java . lang . String ) faultMessageMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ; java . lang . class messageClass = java . lang . class . forName ( messageClassName ) ; java . lang . Object messageObject = fromOM ( faultElt , messageClass , null ) ; java . lang . reflect . Method m = exceptionClass . getMethod ( "setFaultMessage" , new java . lang . class [ ] { messageClass } ) ; m . invoke ( ex , new java . lang . Object [ ] { messageObject } ) ; callback . receiveErrorgetShortUrl ( new java . rmi . RemoteException ( ex . getMessage ( ) , ex ) ) ; } catch ( java . lang . ClassCastException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . ClassNotFoundException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . NoSuchMethodException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . IllegalAccessException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . InstantiationException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( error ) ; } } public void onFault ( org . apache . axis2 . context . MessageContext faultContext ) { org . apache . axis2 . AxisFault fault = org . apache . axis2 . util . Utils . getInboundFaultFromMessageContext ( faultContext ) ; onError ( fault ) ; } public void onComplete ( ) { try { _messageContext . getTransportOut ( ) . getSender ( ) . cleanup ( _messageContext ) ; } catch ( org . apache . axis2 . AxisFault axisFault ) { callback . receiveErrorgetShortUrl ( axisFault ) ; } } } ) ; org . apache . axis2 . util . CallbackReceiver _callbackReceiver = null ; if ( _operations [ 1 ] . getMessageReceiver ( ) == null && _operationClient . getOptions ( ) . isUseSeparateListener ( ) ) { _callbackReceiver = new org . apache . axis2 . util . CallbackReceiver ( ) ; _operations [ 1 ] . setMessageReceiver ( _callbackReceiver ) ; } _operationClient . execute ( false ) ; }
va	8	@ Override public String cookieLogin ( User user , Map < String , Object > session ) throws ServiceException { User fu = this . findUserByEmail ( user ) ; if ( fu == null ) { logger . info ( "Email is not exist !" ) ; return OtherConstants . EMAIL_NOT_EXIST ; } if ( ! fu . getUserPWD ( ) . equals ( user . getUserPWD ( ) ) ) { logger . info ( "Password is error !" ) ; return OtherConstants . PASSWORD_ERROR ; } String userID = fu . getId ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = groupDaoImpl . query ( fu , SqlConstants . GROUP_QUERY_BY_UID ) ; List < Group > groups = new ArrayList < Group > ( ) ; int temp = 0 ; for ( Object object : list ) { Group group = ( Group ) object ; int groupID = Integer . parseInt ( group . getId ( ) ) ; if ( groupID > 0 ) { temp = groupID ; } groups . add ( group ) ; } fu . setGroups ( groups ) ; fu . setAuth ( String . valueOf ( temp ) ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } Money money = new Money ( ) ; money . setUserID ( userID ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = moneyDaoImpl . query ( money , SqlConstants . MONEY_FIND_BY_UID ) ; if ( list != null && list . size ( ) > 0 ) { money = ( Money ) list . get ( 0 ) ; fu . setMoneyValue ( money . getMoneyValue ( ) ) ; } else { fu . setMoneyValue ( 0 ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } session . put ( OtherConstants . CURRENT_USER , fu ) ; return null ; }
va	9X	@ SuppressWarnings ( "rawtypes" ) public void paint ( Graphics g ) { super . paint ( g ) ; Graphics2D g2d = ( Graphics2D ) g ; drawbackground ( g ) ; drawScore ( g ) ; if ( GameCraft . direction == 3 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerback.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 0 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 1 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerleft.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 2 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerright.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } ArrayList ms = GameCraft . getBulletDOWN ( ) ; for ( int i = 0 ; i < ms . size ( ) ; i ++ ) { BulletDOWN m = ( BulletDOWN ) ms . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msUP = GameCraft . getBulletUP ( ) ; for ( int i = 0 ; i < msUP . size ( ) ; i ++ ) { BulletUP m = ( BulletUP ) msUP . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msLEFT = GameCraft . getBulletLEFT ( ) ; for ( int i = 0 ; i < msLEFT . size ( ) ; i ++ ) { BulletLEFT m = ( BulletLEFT ) msLEFT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msRIGHT = GameCraft . getBulletRIGHT ( ) ; for ( int i = 0 ; i < msRIGHT . size ( ) ; i ++ ) { BulletRIGHT m = ( BulletRIGHT ) msRIGHT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msEnemys = GameCraft . getEnemys ( ) ; for ( int i = 0 ; i < msEnemys . size ( ) ; i ++ ) { Enemys m = ( Enemys ) msEnemys . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } Toolkit . getDefaultToolkit ( ) . sync ( ) ; g . dispose ( ) ; }
va	3	private static void Insert ( int [ ] a , int num , int length ) { int i ; for ( i = 0 ; i < length ; i ++ ) { if ( num < a [ i ] ) break ; } for ( int j = length ; j >= i ; j -- ) { a [ j + 1 ] = a [ j ] ; } length ++ ; a [ i ] = num ; }
va	1	static int modInverse ( int a , int mod ) { int [ ] xy = new int [ 2 ] ; if ( extgcd ( a , mod , xy ) != 1 ) throw new ArithmeticException ( "no inverse exsits" ) ; return ( mod + xy [ 0 ] % mod ) % mod ; }
va	6	private Vector reOrder ( Vector list ) { Vector newList = new Vector ( ) ; if ( list . size ( ) == 0 ) { return newList ; } int previousMsgId = 0 ; int largestGap = 0 ; int largestGapMsgIdPosInList = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int currentMsgId = ( ( MqttWireMessage ) list . elementAt ( i ) ) . getMessageId ( ) ; if ( currentMsgId - previousMsgId > largestGap ) { largestGap = currentMsgId - previousMsgId ; largestGapMsgIdPosInList = i ; } previousMsgId = currentMsgId ; } int lowestMsgId = ( ( MqttWireMessage ) list . elementAt ( 0 ) ) . getMessageId ( ) ; int highestMsgId = previousMsgId ; if ( MAX_MSG_ID - highestMsgId + lowestMsgId > largestGap ) { largestGapMsgIdPosInList = 0 ; } for ( int i = largestGapMsgIdPosInList ; i < list . size ( ) ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } for ( int i = 0 ; i < largestGapMsgIdPosInList ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } return newList ; }
va	3	static String decode ( String ciphertext , String mustOccur ) throws Exception { if ( ciphertext . contains ( mustOccur ) ) { return ciphertext ; } for ( int i = 1 ; i < 26 ; i ++ ) { String decode = encode ( ciphertext , i ) ; if ( decode . contains ( mustOccur ) ) { return decode ; } } throw new Exception ( "Decoded string not found" ) ; }
va	6	public boolean overlaps ( PriceStep other ) { if ( this . getEndPrice ( ) == 0 && other . getEndPrice ( ) == 0 ) { return true ; } if ( ( this . getEndPrice ( ) != 0 && other . getStartPrice ( ) >= this . getEndPrice ( ) ) || ( other . getEndPrice ( ) != 0 && other . getEndPrice ( ) <= this . getStartPrice ( ) ) ) { return false ; } else { return true ; } }
va	8	public String login ( User user , Map < String , Object > session ) throws ServiceException { String email = user . getEmail ( ) + SysConfig . getConfig ( SysConfig . EMAIL_SUFFIX ) ; String password = user . getUserPWD ( ) ; String relPwd = MD5 . getMD5 ( email + password ) ; User u = new User ( ) ; u . setEmail ( email ) ; u . setUserPWD ( password ) ; u . setUserState ( OtherConstants . STATE_YES ) ; User fu = this . findUserByEmail ( u ) ; if ( fu == null ) { logger . info ( "Email is not exist !" ) ; return OtherConstants . EMAIL_NOT_EXIST ; } if ( ! fu . getUserPWD ( ) . equals ( relPwd ) ) { logger . info ( "Password is error !" ) ; return OtherConstants . PASSWORD_ERROR ; } String userID = fu . getId ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = groupDaoImpl . query ( fu , SqlConstants . GROUP_QUERY_BY_UID ) ; List < Group > groups = new ArrayList < Group > ( ) ; int temp = 0 ; for ( Object object : list ) { Group group = ( Group ) object ; int groupID = Integer . parseInt ( group . getId ( ) ) ; if ( groupID > 0 ) { temp = groupID ; } groups . add ( group ) ; } fu . setGroups ( groups ) ; fu . setAuth ( String . valueOf ( temp ) ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } Money money = new Money ( ) ; money . setUserID ( userID ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = moneyDaoImpl . query ( money , SqlConstants . MONEY_FIND_BY_UID ) ; if ( list != null && list . size ( ) > 0 ) { money = ( Money ) list . get ( 0 ) ; fu . setMoneyValue ( money . getMoneyValue ( ) ) ; } else { fu . setMoneyValue ( 0 ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } session . put ( OtherConstants . CURRENT_USER , fu ) ; return null ; }
va	5	@ Override public void moveDown ( ) { if ( ! checkMove ( ) ) { return ; } score -- ; final GameControllerEvent event = createEvent ( DOWN_MOVE ) ; final Cell before = map . findRobot ( ) ; if ( before . y > 1 ) { final Cell after = before . down ( ) ; final AbstractElement e = map . get ( after ) ; if ( isNavigable ( e ) ) { if ( e . getSymbol ( ) == Lambda . SYMBOL ) { collectLambda ( after ) ; } performMove ( before , after , event ) ; } else if ( e . getSymbol ( ) == OpenLift . SYMBOL ) { win ( ) ; map . set ( before , EmptyCell . SYMBOL ) ; event . addChange ( before ) ; notifyListeners ( event ) ; return ; } } endRound ( event ) ; }
va	5	protected final ImmutableSet < Position > getMovesTo ( final Board < ? > board , final Direction dir ) { checkNotNull ( board ) ; checkNotNull ( dir ) ; final ImmutableSet . Builder < Position > moves = ImmutableSet . builder ( ) ; Position pos = board . getPositionFor ( this ) . relative ( dir . i ( ) , dir . j ( ) ) ; while ( board . isValidPosition ( pos ) && ( ! board . isPieceAt ( pos ) || isEnemy ( board . getPieceAt ( pos ) ) ) ) { moves . add ( pos ) ; if ( board . isPieceAt ( pos ) ) { break ; } pos = pos . relative ( dir . i ( ) , dir . j ( ) ) ; } return moves . build ( ) ; }
va	7	private void AreaDFS ( AreaNode n ) { ArrayList < Goal > neighborGoals = new ArrayList < Goal > ( ) ; Queue < Field > queue = new LinkedList < Field > ( ) ; queue . add ( n . fields . get ( 0 ) ) ; while ( queue . size ( ) > 0 ) { Field t = queue . poll ( ) ; for ( Field field : t . neighbors ) { if ( field == null ) continue ; if ( field instanceof Goal ) { neighborGoals . add ( ( Goal ) field ) ; } else if ( field . node == null ) { queue . add ( field ) ; fields . add ( field ) ; field . td = this ; n . addField ( field ) ; } } } for ( Goal g : neighborGoals ) { if ( g . node == null ) { goals . add ( g ) ; g . td = this ; GoalNode m = new GoalNode ( g ) ; graph . add ( m ) ; GoalDFS ( m ) ; } else { g . node . neighbors . add ( n ) ; n . neighbors . add ( g . node ) ; } } }
va	0	public ParserException ( String message ) { super ( message ) ; }
va	5	public void getFlower ( ) { if ( deathTime > 0 || world . paused ) return ; if ( ! fire ) { world . paused = true ; powerUpTime = 3 * 6 ; world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_POWER_UP ] , this , 1 , 1 , 1 ) ; world . mario . setLarge ( true , true ) ; if ( world . recorder != null ) { if ( large ) { world . recorder . endLargeRecord ( ) ; } else { world . recorder . endLittleRecord ( ) ; } world . recorder . startFireRecord ( ) ; } } else { Mario . getCoin ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_GET_COIN ] , this , 1 , 1 , 1 ) ; } }
va	4	@ Override public long read ( DataInputStream in , PassthroughConnection ptc , KillableThread thread , boolean serverToClient , DownlinkState linkState ) { while ( true ) { try { value = in . readLong ( ) ; } catch ( SocketTimeoutException toe ) { if ( timedOut ( thread ) ) { continue ; } return null ; } catch ( IOException e ) { return null ; } super . timeout = 0 ; return value ; } }
va	9X	public void elemSelected ( ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) optionsTree . getLastSelectedPathComponent ( ) ; if ( node == null ) { return ; } if ( model . getSelectedNodes ( ) . isEmpty ( ) && model . getSelectedEdges ( ) . isEmpty ( ) ) { return ; } String name = node . toString ( ) ; switch ( name ) { case ( "Constraint" ) : model . addConstraint ( ) ; break ; case ( "Support Parameters" ) : model . addSupport ( ) ; break ; case ( "Force" ) : model . addForce ( ) ; break ; case ( "Pressure" ) : model . addPressure ( ) ; break ; case ( "Spring" ) : model . addSpring ( ) ; break ; case ( "Add Group" ) : model . addFluidFlow ( ) ; break ; default : System . out . println ( name ) ; break ; } model . setSelectedNodes ( new ArrayList < > ( ) ) ; model . setSelectedEdges ( new ArrayList < > ( ) ) ; }
va	3	public JSONArray put ( int index , Object value ) throws JSONException { JSONObject . testValidity ( value ) ; if ( index < 0 ) { throw new JSONException ( "JSONArray[" + index + "] not found." ) ; } if ( index < length ( ) ) { this . myArrayList . set ( index , value ) ; } else { while ( index != length ( ) ) { put ( JSONObject . null ) ; } put ( value ) ; } return this ; }
va	8	private void drawTooltip ( ) { if ( menuActionRow < 2 && itemSelected == 0 && spellSelected == 0 ) return ; String s ; if ( itemSelected == 1 && menuActionRow < 2 ) s = "Use " + selectedItemName + " with..." ; else if ( spellSelected == 1 && menuActionRow < 2 ) s = spellTooltip + "..." ; else s = menuActionName [ menuActionRow - 1 ] ; if ( menuActionRow > 2 ) s = s + "@whi@ / " + ( menuActionRow - 2 ) + " more options" ; chatTextDrawingArea . method390 ( 4 , ffffff , s , loopCycle / 1000 , 15 ) ; }
va	1	public static void main ( String [ ] args ) { System . out . println ( "Testing binary Max Heap\n" ) ; MaxHeap heap = new MaxHeap ( ) ; int [ ] inputs = { 10 , 20 , 30 , 40 , 100 , 50 , 60 , 70 , 80 , 90 , 190 } ; for ( int i = 0 ; i < inputs . length ; i ++ ) heap . insert ( inputs [ i ] ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Inserting 3" ) ; heap . insert ( 3 ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; }
va	0	public void setHabs ( Set < TipusHabInformation > habs ) { this . habs = habs ; }
va	1	public int count ( final DataFrame frame ) { final List < DataField > retval = new ArrayList < DataField > ( ) ; if ( frame != null ) { recurseFields ( frame , null , retval ) ; } return retval . size ( ) ; }
va	7	static public Point [ ] find2CirclesIntersections ( final Point c1 , final double r1 , final Point c2 , final double r2 ) { if ( r1 < 0 || r2 < 0 ) return null ; Point [ ] result = null ; if ( r1 == 0 || r2 == 0 ) { result = new Point [ 2 ] ; if ( r1 == 0 ) result [ 0 ] = new Point ( c1 . getX ( ) , c1 . getY ( ) ) ; else result [ 0 ] = new Point ( c2 . getX ( ) , c2 . getY ( ) ) ; result [ 1 ] = result [ 0 ] ; return result ; } double d = distance ( c1 , c2 ) ; double cosAlpha = 0.5 * ( d * d - r2 * r2 + r1 * r1 ) / d / r1 ; double theta = Math . atan2 ( c2 . getY ( ) - c1 . getY ( ) , c2 . getX ( ) - c1 . getX ( ) ) ; if ( cosAlpha < 1 ) { double alpha = Math . acos ( cosAlpha ) ; result = new Point [ 2 ] ; result [ 0 ] = new Point ( c1 . getX ( ) + r1 * Math . cos ( theta + alpha ) , c1 . getY ( ) + r1 * Math . sin ( theta + alpha ) ) ; result [ 1 ] = new Point ( c1 . getX ( ) + r1 * Math . cos ( theta - alpha ) , c1 . getY ( ) + r1 * Math . sin ( theta - alpha ) ) ; } else if ( ( r1 + r2 ) / d > 0.85 ) { result = new Point [ 2 ] ; result [ 0 ] = new Point ( c1 . getX ( ) + ( c2 . getX ( ) - c1 . getX ( ) ) * r1 / d , c1 . getY ( ) + ( c2 . getY ( ) - c1 . getY ( ) ) * r1 / d ) ; result [ 1 ] = result [ 0 ] ; } return result ; }
va	5	public String format ( LogRecord r ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( r . getLevel ( ) . getName ( ) + "\t" ) ; sb . append ( MessageFormat . format ( "{0  date  yy-MM-dd} {0  time  kk:mm:ss.SSSS} " , new Object [ ] { new Date ( r . getMillis ( ) ) } ) + "\t" ) ; String cnm = r . getSourceClassName ( ) ; String cn = "" ; if ( cnm != null ) { int cnl = cnm . length ( ) ; if ( cnl > 20 ) { cn = r . getSourceClassName ( ) . substring ( cnl - 19 ) ; } else { char sp [ ] = {   } ; StringBuffer sb1 = new StringBuffer ( ) . append ( cnm ) ; cn = sb1 . append ( sp , 0 , 1 ) . toString ( ) ; } } sb . append ( cn + "\t" ) . append ( " " ) ; sb . append ( left ( r . getSourceMethodName ( ) , 23 ,   ) + "\t" ) ; sb . append ( r . getThreadID ( ) + "\t" ) ; sb . append ( formatMessage ( r ) ) . append ( ls ) ; if ( null != r . getThrown ( ) ) { sb . append ( "Throwable occurred: " ) ; Throwable t = r . getThrown ( ) ; PrintWriter pw = null ; try { StringWriter sw = new StringWriter ( ) ; pw = new PrintWriter ( sw ) ; t . printStackTrace ( pw ) ; sb . append ( sw . toString ( ) ) ; } finally { if ( pw != null ) { try { pw . close ( ) ; } catch ( Exception e ) { } } } } return sb . toString ( ) ; }
va	1	public String format ( String unformattedXml ) { TransformerFactory tfactory = TransformerFactory . newInstance ( ) ; Transformer serializer ; try { serializer = tfactory . newTransformer ( ) ; serializer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; serializer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; serializer . setOutputProperty ( "{http://xml.apache.org/xslt}indent-amount" , "4" ) ; Element node = parseXmlFile ( unformattedXml ) ; StringWriter out = new StringWriter ( ) ; serializer . transform ( new DOMSource ( node ) , new StreamResult ( out ) ) ; return out . toString ( ) ; } catch ( TransformerException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } }
va	1	private String getEncodedSecret ( OAuthToken consumer , OAuthToken token ) { StringBuilder secret = new StringBuilder ( ) ; secret . append ( IOUtil . urlEncode ( new String ( consumer . getSecret ( ) ) ) ) ; secret . append ( "&" ) ; if ( token != null ) secret . append ( IOUtil . urlEncode ( new String ( token . getSecret ( ) ) ) ) ; return secret . toString ( ) ; }
va	1	public double getAsDouble ( String key , double defaultValue ) { double value = getAsDouble ( key ) ; return value == null ? defaultValue : value ; }
va	4	protected Object extractUnmarshalResult ( List < Map < String , Object >> models ) { if ( getClassType ( ) != null ) { List < Object > answer = new ArrayList < Object > ( ) ; for ( Map < String , Object > entry : models ) { Object data = entry . get ( getClassType ( ) . getName ( ) ) ; if ( data != null ) { answer . add ( data ) ; } } if ( answer . size ( ) == 1 ) { return answer . get ( 0 ) ; } else { return answer ; } } else { return models ; } }
va	1	@ Override public boolean removeLogicable ( Logical logicable ) { if ( logicable != null ) { return logicablesToChange . add ( new Tuple < Logical , boolean > ( logicable , false ) ) ; } return false ; }
va	2	private PreparedStatement addToBatch ( PreparedStatement statement ) throws SQLException { statement . addBatch ( ) ; if ( params != null ) { for ( ISetter s : params ) { s . set ( statement ) ; } } return statement ; }
va	5	public static void main ( String Arg [ ] ) { int theMost = 0 ; for ( int p = 120 ; p < 1000 ; p ++ ) { int counter = 0 ; for ( int a = 1 ; a < p ; a ++ ) for ( int b = 1 ; b < a ; b ++ ) { int c = p - a - b ; if ( a * a + b * b == c * c ) counter ++ ; } if ( counter > theMost ) { theMost = counter ; System . out . println ( "p=" + p + " generates " + counter + " triangles" ) ; } } uptime ( ) ; }
va	3	public void setCellScoresMatrix ( ) { int r , c , sc ; char cS1 , cS2 ; ScoredCellElement tmpCell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cS1 = m_s1 . charAt ( c ) ; cS2 = m_s1 . charAt ( r ) ; tmpCell = ( ScoredCellElement ) m_dpTable . getCell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpCell . setScoreVal ( m_scoreHash . getScore ( cS1 , cS2 ) ) ; } else { tmpCell . setColor ( Color . BLACK ) ; } } } }
va	9X	@ Override public void set ( long i , Object o ) { if ( o == null ) { if ( ptr != 0 ) { stringLengths . setShort ( i , ( short ) - 1 ) ; } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = null ; } } else { if ( ! ( o instanceof String ) ) { throw new IllegalArgumentException ( o + " is not a string." ) ; } String s = ( String ) o ; if ( ptr != 0 ) { if ( s . length ( ) > maxStringLength ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } byte [ ] tmp ; try { tmp = s . getBytes ( CHARSET ) ; } catch ( UnsupportedEncodingException ex ) { return ; } int strLen = tmp . length ; if ( strLen > short . MAX_VALUE ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } stringLengths . setShort ( i , ( short ) strLen ) ; long offset = sizeof * i * maxStringLength * CHARSET_SIZE ; for ( int j = 0 ; j < strLen ; j ++ ) { Utilities . UNSAFE . putByte ( ptr + offset + sizeof * j , tmp [ j ] ) ; } } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = s ; } } }
va	3	public static int method156 ( int i , int j , int l ) { j &= 3 ; if ( j == 0 ) return i ; if ( j == 1 ) return 7 - l ; if ( j == 2 ) return 7 - i ; else return l ; }
va	6	private AbstractNode expression ( ) { AbstractNode res = simpleExp ( ) ; if ( test ( = ) ) { read ( = , "=" ) ; res = new BinOpNode ( = , res , simpleExp ( ) ) ; } if ( test ( NEQ ) ) { read ( NEQ , "#" ) ; res = new BinOpNode ( NEQ , res , simpleExp ( ) ) ; } if ( test ( LO ) ) { read ( LO , "<" ) ; res = new BinOpNode ( LO , res , simpleExp ( ) ) ; } if ( test ( LOEQ ) ) { read ( LOEQ , "<=" ) ; res = new BinOpNode ( LOEQ , res , simpleExp ( ) ) ; } if ( test ( HI ) ) { read ( HI , ">" ) ; res = new BinOpNode ( HI , res , simpleExp ( ) ) ; } if ( test ( HIEQ ) ) { read ( HIEQ , ">=" ) ; res = new BinOpNode ( HIEQ , res , simpleExp ( ) ) ; } return res ; }
va	3	public Carrera getCarreraCerrada ( ) { if ( carreraCerrada == null ) { for ( Carrera c : carreras ) { if ( c . getEstado ( ) == Carrera . EstadoCarrera . CERRADA ) { setCarreraCerrada ( c ) ; } } } return carreraCerrada ; }
va	5	private void addGuestToBookingButtonActionPerformed ( java . awt . event . ActionEvent evt ) { boolean addGuestSuccess ; Booking currentBooking = ctr . getCurrentBooking ( ) ; if ( currentBooking != null && guestJList2 . getSelectedValue ( ) != null ) { Guest guest = ( Guest ) guestJList2 . getSelectedValue ( ) ; if ( ! addedGuestsModel . contains ( guest ) ) { if ( ctr . checkRoomAvailability ( currentBooking , addedGuestsModel . getSize ( ) ) > 0 ) { addGuestSuccess = ctr . createBookingDetail ( guest , currentBooking ) ; if ( addGuestSuccess ) { addedGuestsModel . addElement ( guest ) ; addedGuestsJList . setModel ( addedGuestsModel ) ; jOptionPane . showMessageDialog ( this , guest . getFirstName ( ) + " " + guest . getLastName ( ) + " added to roomNo " + currentBooking . getRoomNo ( ) ) ; } else { jOptionPane . showMessageDialog ( this , "Could not add guest to room.\nGuest might already be booked to a room in that period." , "Error." , jOptionPane . INFORMATION_MESSAGE ) ; } } else { jOptionPane . showMessageDialog ( this , "Cannot add guest because room is full!" , "Room is full." , jOptionPane . INFORMATION_MESSAGE ) ; } } else { jOptionPane . showMessageDialog ( this , "Guest already added!" , "Error." , jOptionPane . INFORMATION_MESSAGE ) ; } } }
va	9X	public boolean addDye ( DyeParent dyeParent ) { if ( dyeParent . getClass ( ) . equals ( Lakk . class ) && lakkNum < MAX_NUMBER_OF_LAKKS ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; lakkNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Metal . class ) && metalNum < MAX_NUMBER_OF_METALS && metalNum + dyeNum < MAX_NUMBER_OF_DYES ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; metalNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Dye . class ) && metalNum + dyeNum < MAX_NUMBER_OF_DYES ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; dyeNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Fluo . class ) ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; fluoNum ++ ; return true ; } return false ; } return false ; }
va	7	public boolean validarEntradaRegistro ( ) { if ( this . txtNombre . getText ( ) . equals ( "" ) || this . txtEmail . getText ( ) . equals ( "" ) || this . txtContraseña . getText ( ) . equals ( "" ) || this . txtRepetirContraseña . getText ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Debe completar todos los campos llave (*)" , "Campos Incompletos" , JOptionPane . INFORMATION_MESSAGE ) ; return false ; } else if ( ! txtContraseña . getText ( ) . equals ( this . txtRepetirContraseña . getText ( ) ) ) { JOptionPane . showMessageDialog ( null , "Las contrase\u00F1as no coinciden" , "Error Contrase\u00F1a" , JOptionPane . INFORMATION_MESSAGE ) ; txtContraseña . requestFocus ( ) ; txtContraseña . selectAll ( ) ; txtRepetirContraseña . setText ( "" ) ; return false ; } else if ( ! this . jCheckBox1 . isSelected ( ) ) { JOptionPane . showMessageDialog ( null , "Debe Aceptar los terminos y condiciones" , "Terminos y Condiciones" , JOptionPane . INFORMATION_MESSAGE ) ; return false ; } else if ( this . txtTelefono . getText ( ) . length ( ) > 10 ) { JOptionPane . showMessageDialog ( null , "El n\u00FAmero telef\u00F3nico no puede tener m\u00E1s de 10 n\u00FAmeros" , "N\u00FAmero inv\u00E1lido" , JOptionPane . INFORMATION_MESSAGE ) ; this . txtTelefono . requestFocus ( ) ; } return crearEntradaRegistro ( ) ; }
va	7	private Entity lookupEntity ( String object ) { Entity entity = null ; String specialEntity = vocabulary . getSpecialEntities ( ) . get ( object ) ; if ( specialEntity != null ) { if ( specialEntity . equals ( "thisLocation" ) ) { entity = currentLocation ; } else if ( specialEntity . equals ( "lastLocation" ) ) { entity = previousLocation ; } else if ( specialEntity . equals ( "inventory" ) ) { entity = inventory ; } } else { entity = currentLocation . getEntity ( object ) ; if ( entity == null ) { entity = inventory . getEntity ( object ) ; } if ( entity == null || ! entity . isVisible ( ) ) { console . display ( vocabulary . getMessages ( ) . get ( "cantDo" ) ) ; entity = null ; } } return entity ; }
va	7	private static void parseMultiPartParameter ( byte [ ] input , byte [ ] boundary , List < MultiPartParameter > multiPartParameters , Map < String , String > paramsPost ) { try { MultipartStream multipartStream = new MultipartStream ( new ByteArrayInputStream ( input ) , boundary ) ; boolean nextPart = multipartStream . skipPreamble ( ) ; while ( nextPart ) { String header = multipartStream . readHeaders ( ) ; Matcher mN = PATTERN_MULTIPART_PARAM_NAME . matcher ( header ) ; Matcher mF = PATTERN_MULTIPART_PARAM_FILENAME . matcher ( header ) ; Matcher mCT = PATTERN_MULTIPART_PARAM_CONTENT_TYPE . matcher ( header ) ; String name = mN . find ( ) ? mN . group ( 1 ) : null ; String filename = mF . find ( ) ? mF . group ( 1 ) : null ; String contentType = mCT . find ( ) ? mCT . group ( 1 ) : "application/octet-stream" ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; multipartStream . readBodyData ( output ) ; if ( filename != null ) { multiPartParameters . add ( new MultiPartParameter ( name , output . toString ( ) , contentType , filename ) ) ; } else { paramsPost . put ( name , output . toString ( ) ) ; } nextPart = multipartStream . readBoundary ( ) ; } } catch ( MultipartStream . MalformedStreamException e ) { } catch ( IOException e ) { } }
va	8	@ Override public void run ( ) { enabled = true ; while ( enabled ) { try { Object o = Client . this . inputStream . readObject ( ) ; if ( ! enabled ) { NetServer . this . logger . log ( "object from client " + Client . this . getIp ( ) + " received but listening disabled" , ConsoleLogger . Type . INFO ) ; return ; } if ( o instanceof Message ) { NetServer . this . logger . log ( "received " + ( ( Message ) o ) . toString ( ) + " from " + Client . this . toString ( ) , ConsoleLogger . Type . DEBUG ) ; if ( o . equals ( Message . DISCONNECT ) ) { NetServer . this . disconnectClient ( Client . this ) ; } NetServer . this . messageReceived ( Client . this , ( Message ) o ) ; } else { NetServer . this . logger . log ( "non message type received from " + Client . this . toString ( ) , ConsoleLogger . Type . WARNING ) ; } } catch ( ClassNotFoundException | IOException ex ) { if ( ! enabled && ex instanceof SocketException && ex . getMessage ( ) . equalsIgnoreCase ( "socket closed" ) ) { NetServer . this . logger . log ( "listening from " + Client . this . toString ( ) + " stopped" , ConsoleLogger . Type . INFO ) ; return ; } else { NetServer . this . logger . log ( "error during reading object from " + Client . this . getIp ( ) , ConsoleLogger . Type . ERROR ) ; ex . printStackTrace ( System . err ) ; } } } }
va	8	private void populateSubSet ( ArrayList < ArrayList < Integer >> arrayLists , int [ ] candidateCount , int startIndex , int endIndex , int [ ] candidates , int target ) { if ( startIndex >= ( endIndex + 1 ) ) { ArrayList < Integer > currentCombination = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= endIndex ; i ++ ) { if ( candidateCount [ i ] != 0 ) { for ( int j = 0 ; j < candidateCount [ i ] ; j ++ ) { currentCombination . add ( candidates [ i ] ) ; } } } if ( currentCombination . size ( ) > 0 ) { arrayLists . add ( currentCombination ) ; } return ; } if ( startIndex == endIndex ) { if ( target % candidates [ startIndex ] == 0 ) { candidateCount [ startIndex ] = target / candidates [ startIndex ] ; populateSubSet ( arrayLists , candidateCount , startIndex + 1 , endIndex , candidates , 0 ) ; } } else { int iterateUpTo = target / candidates [ startIndex ] ; for ( int i = 0 ; i <= iterateUpTo ; i ++ ) { candidateCount [ startIndex ] = i ; populateSubSet ( arrayLists , candidateCount , startIndex + 1 , endIndex , candidates , target - candidates [ startIndex ] * i ) ; } } }
va	5	protected Influence makeInfluence ( PhysicalInfluence i ) { if ( i . target ( ) == null ) return null ; if ( i instanceof MovementInfluence ) return this . makeInfluence ( ( MovementInfluence ) i ) ; if ( i instanceof CollideInfluence ) return this . makeInfluence ( ( CollideInfluence ) i ) ; if ( i instanceof ChangeBodyPropertyInfluence ) return this . makeInfluence ( ( ChangeBodyPropertyInfluence ) i ) ; if ( i instanceof DeathInfluence ) return this . makeInfluence ( ( DeathInfluence ) i ) ; return null ; }
va	4	public TrainingSet ( String line ) { String [ ] values = line . split ( " " ) ; int [ ] [ ] startBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { startBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + 2 ] . trim ( ) ) ; } } int readOffset = 2 + GameOfLife . HEIGHT * GameOfLife . WIDTH ; int [ ] [ ] endBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { endBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + readOffset ] . trim ( ) ) ; } } this . startBoard = new Board ( startBoard ) ; this . endBoard = new Board ( endBoard ) ; this . id = Integer . parseInt ( values [ 0 ] ) ; this . delta = Integer . parseInt ( values [ 1 ] ) ; }
va	7	public EigenvalueDecomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . getArray ( ) ; n = Arg . getColumnDimension ( ) ; V = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = true ; for ( int j = 0 ; ( j < n ) & issymmetric ; j ++ ) { for ( int i = 0 ; ( i < n ) & issymmetric ; i ++ ) { issymmetric = ( A [ i ] [ j ] == A [ j ] [ i ] ) ; } } if ( issymmetric ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { V [ i ] [ j ] = A [ i ] [ j ] ; } } tred2 ( ) ; tql2 ( ) ; } else { H = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { H [ i ] [ j ] = A [ i ] [ j ] ; } } orthes ( ) ; hqr2 ( ) ; } }
va	6	private boolean processProduction ( Production production , Grammar grammar , FirstSets firstSets ) { if ( production . isEpsilonMove ( ) ) { return false ; } boolean result = false ; int index = 0 ; for ( final Symbol symbol : production . getRight ( ) ) { final Set < Symbol > follow = sets . get ( symbol ) ; final Set < Symbol > first = firstSets . getFirstSet ( production . getRight ( ) , index + 1 ) ; if ( ( first . remove ( grammar . getEpsilon ( ) ) || ( index == production . getRight ( ) . size ( ) - 1 ) ) && follow . addAll ( sets . get ( production . getLeft ( ) ) ) ) { result = true ; } if ( follow . addAll ( first ) ) { result = true ; } index ++ ; } return result ; }
va	9X	protected boolean fireAndHandleEvent ( WordTokenizer tokenizer , SpellCheckEvent event ) { fireSpellCheckEvent ( event ) ; String word = event . getInvalidWord ( ) ; switch ( event . getAction ( ) ) { case SpellCheckEvent . INITIAL : break ; case SpellCheckEvent . IGNORE : break ; case SpellCheckEvent . IGNOREALL : ignoreAll ( word ) ; break ; case SpellCheckEvent . REPLACE : tokenizer . replaceWord ( event . getReplaceWord ( ) ) ; break ; case SpellCheckEvent . REPLACEALL : String replaceAllWord = event . getReplaceWord ( ) ; if ( ! autoReplaceWords . containsKey ( word ) ) { autoReplaceWords . put ( word , replaceAllWord ) ; } tokenizer . replaceWord ( replaceAllWord ) ; break ; case SpellCheckEvent . ADDTODICT : String addWord = event . getReplaceWord ( ) ; if ( ! addWord . equals ( word ) ) tokenizer . replaceWord ( addWord ) ; userdictionary . addWord ( addWord ) ; break ; case SpellCheckEvent . CANCEL : return true ; default : throw new IllegalArgumentException ( "Unhandled case." ) ; } return false ; }
va	1	int step5Status ( ) { if ( event . getSeatsPerTable ( ) . isEmpty ( ) ) return 0 ; else return 1 ; }
va	3	@ Override public void addFirstLevel ( final ILevel myFirstLevel ) { if ( myFirstLevel != null ) { if ( levelStage != null ) { myFirstLevel . setLevelStage ( levelStage ) ; } else if ( myFirstLevel . getLevelStage ( ) != null ) { setLevelStage ( myFirstLevel . getLevelStage ( ) ) ; } myFirstLevel . setLevelPack ( this ) ; getFirstLevels ( ) . add ( myFirstLevel ) ; } }
va	4	public int getAction ( Game game , long dueTime ) { if ( key == KeyEvent . VK_UP ) return 0 ; if ( key == KeyEvent . VK_RIGHT ) return 1 ; if ( key == KeyEvent . VK_DOWN ) return 2 ; if ( key == KeyEvent . VK_LEFT ) return 3 ; return 4 ; }
va	8	public void drawAlphaTextWithShadow ( String text , int x , int y , int currentColour , int seed ) { if ( text == null ) return ; random . setSeed ( seed ) ; int alpha = 192 + ( random . nextInt ( ) & 1f ) ; y -= fontHeight ; for ( int c = 0 ; c < text . length ( ) ; c ++ ) { if ( text . charAt ( c ) == @ && c + 4 < text . length ( ) && text . charAt ( c + 4 ) == @ ) { int colour = handleEmbeddedEffect ( text . substring ( c + 1 , c + 4 ) ) ; if ( colour != - 1 ) currentColour = colour ; c += 4 ; } else { char character = text . charAt ( c ) ; if ( character !=   ) { drawGlyphAlpha ( glyphPixels [ character ] , x + horizontalKerning [ character ] + 1 , y + verticalKerning [ character ] + 1 , glyphWidth [ character ] , glyphHeight [ character ] , 0 , 192 ) ; drawGlyphAlpha ( glyphPixels [ character ] , x + horizontalKerning [ character ] , y + verticalKerning [ character ] , glyphWidth [ character ] , glyphHeight [ character ] , currentColour , alpha ) ; } x += glyphDisplayWidth [ character ] ; if ( ( random . nextInt ( ) & 3 ) == 0 ) x ++ ; } } }
va	3	public static void main ( String [ ] args ) throws IOException { if ( args . length >= 2 ) { File inDir = new File ( args [ 0 ] ) ; File outDir = new File ( args [ 1 ] ) ; if ( ! outDir . exists ( ) ) { outDir . mkdirs ( ) ; } File [ ] fList = inDir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File arg0 ) { return ( arg0 . getName ( ) . startsWith ( "d-" ) && arg0 . getName ( ) . endsWith ( ".txt.csv" ) ) ; } } ) ; Utilities . recompose ( fList , outDir ) ; } }
va	3	@ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( familyName != null ? familyName . hashCode ( ) : 0 ) ; result = 31 * result + ( address != null ? address . hashCode ( ) : 0 ) ; return result ; }
va	9X	public final static byte [ ] decodeFast ( byte [ ] sArr ) { int sLen = sArr . length ; if ( sLen == 0 ) return new byte [ 0 ] ; int sIx = 0 , eIx = sLen - 1 ; while ( sIx < eIx && IA [ sArr [ sIx ] & ff ] < 0 ) sIx ++ ; while ( eIx > 0 && IA [ sArr [ eIx ] & ff ] < 0 ) eIx -- ; int pad = sArr [ eIx ] == = ? ( sArr [ eIx - 1 ] == = ? 2 : 1 ) : 0 ; int cCnt = eIx - sIx + 1 ; int sepCnt = sLen > 76 ? ( sArr [ 76 ] == '' ? cCnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cCnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dArr = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = IA [ sArr [ sIx ++ ] ] << 18 | IA [ sArr [ sIx ++ ] ] << 12 | IA [ sArr [ sIx ++ ] ] << 6 | IA [ sArr [ sIx ++ ] ] ; dArr [ d ++ ] = ( byte ) ( i >> 16 ) ; dArr [ d ++ ] = ( byte ) ( i >> 8 ) ; dArr [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sIx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sIx <= eIx - pad ; j ++ ) i |= IA [ sArr [ sIx ++ ] ] << ( 18 - j * 6 ) ; for ( int r = 16 ; d < len ; r -= 8 ) dArr [ d ++ ] = ( byte ) ( i >> r ) ; } return dArr ; }
va	9X	@ Override protected void handleKeyboard ( ) { if ( keyPoller . isKeyDown ( KeyEvent . VK_LEFT ) ) { player1 . Direction ( - bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player1 . Direction ( bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyPoller . isKeyDown ( KeyEvent . VK_UP ) ) { player1 . Direction ( 0 , - bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_DOWN ) ) { player1 . Direction ( 0 , bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_SPACE ) ) { playAudio . playSound ( "Put" ) ; int posX = player1 . getPosXForBomb ( ) ; int posY = player1 . getPosYForBomb ( ) ; if ( ! bLevel . hasBombByPixel ( posX , posY ) && player1 . bombplantable ( ) ) { bombsP1 . add ( new Bomben ( ( posX / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , ( posY / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , player1 . maxradius ( ) , player1 , bLevel ) ) ; sendBomb ( posX , posY , player1 . maxradius ( ) ) ; player1 . addcurrentbombs ( ) ; } } if ( keyReceiver . isKeyDown ( KeyEvent . VK_LEFT ) ) { player2 . Direction ( - bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player2 . Direction ( bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyReceiver . isKeyDown ( KeyEvent . VK_UP ) ) { player2 . Direction ( 0 , - bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_DOWN ) ) { player2 . Direction ( 0 , bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_SPACE ) ) { playAudio . playSound ( "Put" ) ; int posX = player2 . getPosXForBomb ( ) ; int posY = player2 . getPosYForBomb ( ) ; if ( ! bLevel . hasBombByPixel ( posX , posY ) && player2 . bombplantable ( ) ) { bombsP2 . add ( new Bomben ( ( posX / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , ( posY / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , player2 . maxradius ( ) , player2 , bLevel ) ) ; sendBomb ( posX , posY , player2 . maxradius ( ) ) ; player2 . addcurrentbombs ( ) ; } } }
va	0	public void clearBooster ( ) { getBooster ( ) . clear ( ) ; }
va	7	void removeDev ( DeviceImpl dev ) { synchronized ( devices ) { DeviceImpl d = devices [ dev . getAddress ( ) - 1 ] ; int i ; if ( d == null || d != dev ) return ; i = d . getAddress ( ) - 1 ; devices [ i ] = null ; if ( root == i ) { root = - 1 ; if ( Windows . trace ) System . err . println ( "bus root hub removed!" ) ; if ( Windows . debug ) { for ( i = 0 ; i < 127 ; i ++ ) { if ( devices [ i ] != null ) System . err . println ( "? addr " + ( i + 1 ) + " present with no root ?" ) ; } } } } }
va	5	private void btnLearnCompleteActionPerformed ( java . awt . event . ActionEvent evt ) { ScienceTool . clearAll ( ) ; while ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) - 1 ) { System . out . println ( "learning " + txtFile . getText ( ) ) ; File file = new File ( "data/" + txtFile . getText ( ) ) ; if ( file . exists ( ) ) { for ( LinkKNN knn : knns ) { knn . learnType ( ( String ) lstTypes . getSelectedValue ( ) ) ; } Datasource . getInstance ( ) . playRecording ( file ) ; for ( LinkKNN knn : knns ) { knn . stopLearning ( ) ; } } if ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) ) { lstTypes . setSelectedIndex ( lstTypes . getSelectedIndex ( ) + 1 ) ; } } jlDatas . updateUI ( ) ; jlDatas . setSelectionInterval ( 0 , jlDatas . getModel ( ) . getSize ( ) ) ; }
va	4	public static void patch ( int addr , int displacement ) { if ( addr < 0 || addr >= CT ) { System . out . println ( "patch:  address of instruction to be patched is out of range" ) ; return ; } if ( displacement < 0 || displacement > CT ) { System . out . println ( "patch:  target address of patch is out of range" ) ; return ; } Machine . code [ addr ] . d = displacement ; return ; }
va	2	public Map < long , Map < long , long >> read ( File f ) throws IOException { Map < long , Map < long , long >> fm = new TreeMap < long , Map < long , long >> ( ) ; BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String ln = br . readLine ( ) ; StringTokenizer stk ; long key1 ; while ( ln != null ) { stk = new StringTokenizer ( ln ) ; key1 = long . parseLong ( stk . nextToken ( ) ) ; if ( ! fm . containsKey ( key1 ) ) { fm . put ( key1 , new TreeMap < long , long > ( ) ) ; } fm . get ( key1 ) . put ( long . parseLong ( stk . nextToken ( ) ) , long . parseLong ( stk . nextToken ( ) ) ) ; } br . close ( ) ; return fm ; }
va	2	public String collectAndReset ( String timeStamp ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "<" ) . append ( name ) . append ( ">" ) ; double mean ; double dispersion ; for ( Map . Entry < String , Map < String , double >> entry : mappedValues . entrySet ( ) ) { mean = getMean ( entry . getValue ( ) ) ; dispersion = getDispersion ( entry . getValue ( ) , mean ) ; sb . append ( "<" ) . append ( entry . getKey ( ) ) ; sb . append ( " mean=\"" ) . append ( mean ) ; sb . append ( "\" disp=\"" ) . append ( dispersion ) . append ( "\"/>" ) ; } sb . append ( "</" ) . append ( name ) . append ( ">" ) ; for ( Map < String , double > innerObservation : mappedValues . values ( ) ) { innerObservation . clear ( ) ; } mappedValues . clear ( ) ; return sb . toString ( ) ; }
va	8	public static DatabaseType insertBroker ( JFrame frame ) { JPanel panel = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; JPanel label = new JPanel ( new GridLayout ( 3 , 1 , 2 , 2 ) ) ; label . add ( new JLabel ( "Broker Number" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Rating" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Bank market code" , SwingConstants . RIGHT ) ) ; panel . add ( label , BorderLayout . WEST ) ; JPanel controls = new JPanel ( new GridLayout ( 3 , 1 , 2 , 2 ) ) ; JTextField relationF = new JTextField ( ) ; relationF . setToolTipText ( "Insert the broker's id  which should be an integer number!" ) ; TextPrompt relationP = new TextPrompt ( "12345" , relationF ) ; relationP . setForeground ( Color . RED ) ; relationP . changeAlpha ( 0.5f ) ; relationP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( relationF ) ; JTextField ratingF = new JTextField ( ) ; ratingF . setToolTipText ( "Insert the rating for the Broker  which should be an integer between 0 and 10" ) ; TextPrompt ratingP = new TextPrompt ( "7" , ratingF ) ; ratingP . setForeground ( Color . RED ) ; ratingP . changeAlpha ( 0.5f ) ; ratingP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( ratingF ) ; JTextField market_codeF = new JTextField ( ) ; market_codeF . setToolTipText ( "Type the market code of the bank where this account is stored at. Like RT.b" ) ; TextPrompt market_codeP = new TextPrompt ( "RBS.L" , market_codeF ) ; market_codeP . setForeground ( Color . RED ) ; market_codeP . changeAlpha ( 0.5f ) ; market_codeP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( market_codeF ) ; controls . setPreferredSize ( new Dimension ( 300 , 100 ) ) ; panel . add ( controls , BorderLayout . CENTER ) ; while ( JOptionPane . showConfirmDialog ( frame , panel , "Add" , JOptionPane . OK_CANCEL_OPTION ) == 0 ) { String id = relationF . getText ( ) ; String rating = ratingF . getText ( ) ; String market_code = market_codeF . getText ( ) . toUpperCase ( ) ; boolean validData = true ; try { Integer . parseInt ( id ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Broker id must be integer number!" ) ; } try { int i = Integer . parseInt ( rating ) ; if ( i < 0 || i > 10 ) throw new Exception ( ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Rating should be integer between 0 and 10!" ) ; } if ( market_code . length ( ) > 10 || ! market_code . matches ( "[A-z]+|[A-z]+.[A-z]+" ) ) { JOptionPane . showMessageDialog ( frame , "Market code maximum allowed 10 alphabetical characters + the dot (.) sign!" ) ; validData = false ; } if ( validData ) { return new Broker ( Integer . parseInt ( id ) , Integer . parseInt ( rating ) , market_code ) ; } } return null ; }
va	2	public FTreeMap ( Map < ? extends Key , ? extends Val > map ) { comp = null ; tree = fromMap ( ( Map < Key , Val > ) map ) ; dflt = null ; }
va	1	private class < ? > findClass ( byte [ ] b ) throws ClassNotFoundException { return defineClass ( null , b , 0 , b . length ) ; }
va	2	public void cargarComboDepto ( ) { int codigoEdificio = Integer . parseInt ( codEdificio . getText ( ) ) ; Lavanderia l = new Lavanderia ( ) ; ArrayList < String > listado = l . listarDeptos ( codigoEdificio ) ; if ( listado != null ) { for ( int i = 0 ; i < listado . size ( ) ; i ++ ) { numDepto . addItem ( listado . get ( i ) ) ; } } }
va	1	private static void pagarPlan ( int numero ) { PlanCelular pc = buscar ( numero ) ; if ( pc != null ) { System . out . println ( "cant min: " ) ; int cms = lea . nextInt ( ) ; System . out . println ( "Cant msgs: " ) ; int cmgs = lea . nextInt ( ) ; double monto = pc . pagoMensual ( cms , cmgs ) ; System . out . println ( "Total: " + monto ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { } } ) ; }
va	8	public void checkOut ( Vector < Integer > callNumbers , int bid ) { PreparedStatement ps = null ; Statement stmt ; ResultSet rs , rs2 , rs3 ; int copyNumber ; try { stmt = con . con . createStatement ( ) ; rs = stmt . executeQuery ( "select * from (Select * from borrower where bid = " + bid + " AND expiryDate < sysdate) b FULL JOIN (select bid from fine f borrowing b where b.borid = f.borid AND b.bid = " + bid + " AND f.paidDate IS NULL) c on b.bid = c.bid" ) ; int c = 0 ; while ( rs . next ( ) ) { c ++ ; } System . out . println ( c ) ; if ( c == 0 ) { rs2 = stmt . executeQuery ( "select bookTimeLimit from borrower b  borrower_type bt where bt.type LIKE b.type AND b.bid = " + bid ) ; if ( rs2 . next ( ) ) { int limit = rs2 . getInt ( "bookTimeLimit" ) ; for ( int i = 0 ; i < callNumbers . size ( ) ; i ++ ) { rs3 = null ; Statement stm1 = con . con . createStatement ( ) ; rs3 = stm1 . executeQuery ( "select * from bookcopy where callNumber = " + callNumbers . get ( i ) . toString ( ) + " AND (status LIKE 'in' or status LIKE 'on-hold')" ) ; if ( rs3 . next ( ) ) { copyNumber = rs3 . getInt ( "copyNo" ) ; ps = con . con . prepareStatement ( "INSERT INTO borrowing VALUES (borid_sequence.nextval ? ? ? ? null)" ) ; java . util . Date today = new java . util . Date ( ) ; java . sql . Date todaysql2 = new java . sql . Date ( today . getTime ( ) ) ; ps . setInt ( 1 , bid ) ; ps . setInt ( 2 , callNumbers . get ( i ) ) ; System . out . println ( callNumbers . get ( i ) ) ; System . out . println ( copyNumber ) ; ps . setInt ( 3 , copyNumber ) ; ps . setDate ( 4 , todaysql2 ) ; ps . executeUpdate ( ) ; ps . close ( ) ; System . out . println ( callNumbers . get ( i ) . toString ( ) + " checked out!\n" ) ; ps = con . con . prepareStatement ( "UPDATE bookcopy SET status='out' WHERE callNumber = ? AND copyNo = ?" ) ; ps . setInt ( 1 , callNumbers . get ( i ) ) ; ps . setInt ( 2 , copyNumber ) ; ps . executeUpdate ( ) ; ps . close ( ) ; con . con . commit ( ) ; System . out . println ( "executed update" ) ; ResultSet returnTime ; Statement stm = con . con . createStatement ( ) ; returnTime = stm . executeQuery ( "SELECT bc.callNumber  (bc.outDate + t.bookTimeLimit)duedate FROM borrower_type t  (SELECT * FROM borrower b  (SELECT * FROM borrowing WHERE callNumber = " + callNumbers . get ( i ) + " AND copyNo = " + copyNumber + " AND INDATE IS NULL) c WHERE b.bid = c.bid) bc WHERE bc.type like t.type" ) ; if ( returnTime . next ( ) ) { new NotificationDialog ( null , "Checked out!" , "Book: " + returnTime . getInt ( "callNumber" ) + " Copy No: " + copyNumber + "\n Due: " + returnTime . getDate ( "duedate" ) . toString ( ) ) ; } rs3 . close ( ) ; stm . close ( ) ; stm1 . close ( ) ; } else { new NotificationDialog ( null , "ERROR!" , "No more copies available for Call Number " + callNumbers . get ( i ) + "! Unable to check out." ) ; } } con . con . commit ( ) ; } else { new NotificationDialog ( null , "ERROR!" , "The borrower does not exist  or his/her account is expired." ) ; } } else { new NotificationDialog ( null , "ERROR!" , "This borrower has outstanding unpaid fines or his account is expired. " ) ; } } catch ( SQLException e ) { new NotificationDialog ( null , "ERROR!" , "Something went wrong somewhere in the Database Handler  method: check out. Damn. " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; System . out . println ( "Message: " + e . getMessage ( ) ) ; try { con . con . rollback ( ) ; } catch ( SQLException ex2 ) { System . out . println ( "Message: " + ex2 . getMessage ( ) ) ; System . exit ( - 1 ) ; } } }
va	8	public String longestCommonPrefix ( String [ ] strs ) { if ( strs == null || strs . length == 0 ) return "" ; int num = strs . length ; if ( num == 1 ) return strs [ 0 ] ; int len1 = strs [ 0 ] . length ( ) ; String prefix = "" ; for ( int idx = 0 ; idx < len1 ; idx ++ ) { boolean flag = false ; char key = strs [ 0 ] . charAt ( idx ) ; for ( int i = 1 ; i < num ; i ++ ) { if ( strs [ i ] . length ( ) <= idx || strs [ i ] . charAt ( idx ) != key ) { flag = true ; break ; } } if ( flag ) break ; else { prefix += key ; } } return prefix ; }
va	8	public void die ( ) { xDeathPos = ( int ) x ; yDeathPos = ( int ) y ; world . paused = true ; deathTime = 1 ; Art . stopMusic ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_DEATH ] , this , 1 , 1 , 1 ) ; if ( world . recorder != null ) { if ( running ) world . recorder . endRunningRecord ( ) ; if ( large && ! fire ) { world . recorder . endLargeRecord ( ) ; } if ( fire ) { world . recorder . endFireRecord ( ) ; } if ( ! large && ! fire ) world . recorder . endLittleRecord ( ) ; if ( ducking ) world . recorder . endDuckRecord ( ) ; world . recorder . endTime ( ) ; world . recorder . recordJumpLand ( ) ; } large = false ; fire = false ; }
va	8	public static boolean isVisible ( int rowIndex , int columnIndex ) { rowIndex += 1 ; columnIndex += 1 ; if ( ( rowIndex > 9 ) && ( rowIndex < 13 ) ) { if ( ( columnIndex < 7 ) || ( columnIndex > 15 ) ) { return false ; } } if ( ( columnIndex > 9 ) && ( columnIndex < 13 ) ) { if ( ( rowIndex < 7 ) || ( rowIndex > 15 ) ) { return false ; } } return true ; }
va	1	public void push ( T data , int stackNumber ) { int arrayStackNumber = stackNumber - 1 ; int currentIndex = arrayStackNumber * STACK_SIZE + stackPointer [ arrayStackNumber ] + 1 ; if ( currentIndex >= stackNumber * STACK_SIZE ) { throw new StackOverflowError ( ) ; } stacks [ currentIndex ] = data ; stackPointer [ arrayStackNumber ] ++ ; }
va	4	@ Override public void visit ( YTask t ) { visited . add ( t ) ; if ( phase == 1 ) { FSPAbstractTask c ; if ( t . canceledBy ( ) != null ) { c = new FSPCancelableTask ( t . name ( ) ) ; } else { c = new FSPTask ( t . name ( ) ) ; } c . container ( _current_net ) ; _current_net . components ( ) . put ( c . name ( ) , c ) ; _components . put ( t , c ) ; assert t . name ( ) == c . name ( ) ; process_gates ( t , c ) ; } else if ( phase == 2 ) { process_outgoing_links ( t ) ; } else if ( phase == 3 ) { process_cancel_regions ( t ) ; } else { } }
va	1	private SerializationManager ( ) { if ( instance != null ) throw new IllegalStateException ( "Already instantiated" ) ; registerBuiltInSerializers ( ) ; }
va	1	private boolean whenToken ( TokenType t ) { if ( testToken ( t ) ) { data . pop ( ) ; return true ; } else { return false ; } }
va	5	Call exit ( MethodData method , ArrayList < TraceAction > trace ) { Call call = top ( ) ; if ( call . mCaller == null ) { return null ; } if ( call . getMethodData ( ) != method ) { String error = "Method exit (" + method . getName ( ) + ") does not match current method (" + call . getMethodData ( ) . getName ( ) + ")" ; throw new RuntimeException ( error ) ; } mStack . remove ( mStack . size ( ) - 1 ) ; if ( trace != null ) { trace . add ( new TraceAction ( TraceAction . ACTION_EXIT , call ) ) ; } Integer num = mStackMethods . get ( method ) ; if ( num != null ) { if ( num == 1 ) { mStackMethods . remove ( method ) ; } else { mStackMethods . put ( method , num - 1 ) ; } } return call ; }
va	2	public void makeTDs ( ) { ArrayList < Goal > levelGoals = level . goals ; for ( int i = 0 ; i < levelGoals . size ( ) ; i ++ ) { Goal goal = levelGoals . get ( i ) ; if ( goal . td == null ) { TaskDispenser td = new TaskDispenser ( goal , level ) ; taskDispensers . add ( td ) ; } } }
va	7	private Object readJSON ( ) throws JSONException { switch ( read ( 3 ) ) { case zipObject : return readObject ( ) ; case zipArrayString : return readArray ( true ) ; case zipArrayValue : return readArray ( false ) ; case zipEmptyObject : return new JSONObject ( ) ; case zipEmptyArray : return new JSONArray ( ) ; case zipTrue : return boolean . true ; case zipFalse : return boolean . false ; default : return JSONObject . null ; } }
va	8	public boolean equals ( get_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . is_set_success ( ) ; boolean that_present_success = true && that . is_set_success ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
va	0	@ Override public int read ( WritableByteChannel channel ) throws IOException { int read = read ( channel , getReadableBytes ( ) , null ) ; return read ; }
va	0	public static double distance ( double x0 , double y0 , double x1 , double y1 ) { return distance ( x1 - x0 , y1 - y0 ) ; }
va	4	public static void loadTexture ( BufferedImage image , int id ) { if ( image == null || id < 0 ) { return ; } int [ ] pixels = new int [ image . getWidth ( ) * image . getHeight ( ) ] ; image . getRGB ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) , pixels , 0 , image . getWidth ( ) ) ; ByteBuffer buffer = BufferUtils . createByteBuffer ( image . getWidth ( ) * image . getHeight ( ) * 4 ) ; for ( int y = 0 ; y < image . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < image . getWidth ( ) ; x ++ ) { int pixel = pixels [ y * image . getWidth ( ) + x ] ; buffer . put ( ( byte ) ( ( pixel >> 16 ) & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 8 ) & FF ) ) ; buffer . put ( ( byte ) ( pixel & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 24 ) & FF ) ) ; } } buffer . flip ( ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , id ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , GL12 . GL_CLAMP_TO_EDGE ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , GL12 . GL_CLAMP_TO_EDGE ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MIN_FILTER , GL11 . GL_NEAREST ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ; GL11 . glTexImage2D ( GL11 . GL_TEXTURE_2D , 0 , GL11 . GL_RGBA8 , image . getWidth ( ) , image . getHeight ( ) , 0 , GL11 . GL_RGBA , GL11 . GL_UNSIGNED_BYTE , buffer ) ; }
va	2	@ Override public void NewEntry ( SourceTextEntry active_entry ) { if ( current_file_node != null && active_entry != null ) { last_edited_text = Core . getEditor ( ) . getCurrentTranslation ( ) ; caretupdates_to_ignore = 1 ; sessionlog . GetMenu ( ) . setPauseTimestamp ( 0 ) ; sessionlog . GetMenu ( ) . getPausetiming ( ) . setSelected ( false ) ; Element element = NewElement ( "segment" , true ) ; element . setAttribute ( "number" , Integer . toString ( Core . getEditor ( ) . getCurrentEntry ( ) . entryNum ( ) ) ) ; Element source_element = NewElement ( "source" , false ) ; source_element . appendChild ( log_document . createTextNode ( Core . getEditor ( ) . getCurrentEntry ( ) . getSrcText ( ) ) ) ; element . appendChild ( source_element ) ; Element target_element = NewElement ( "initialTarget" , false ) ; target_element . appendChild ( log_document . createTextNode ( Core . getEditor ( ) . getCurrentTranslation ( ) ) ) ; element . appendChild ( target_element ) ; current_entry_node = element ; current_file_node . appendChild ( current_entry_node ) ; current_editions_node = NewElement ( "events" , false ) ; chosen_entry_time = System . nanoTime ( ) ; current_segment_number = Core . getEditor ( ) . getCurrentEntry ( ) . entryNum ( ) ; } }
va	0	public Matrix m ( ) { return core . m ( ) ; }
va	2	@ Override public void actionPerformed ( ActionEvent event ) { String eventName = event . getActionCommand ( ) ; System . out . println ( "event:" + eventName ) ; switch ( eventName ) { case "comboBoxChanged" : String prefName = sysAdminUI . getPreferenceListBoxSelection ( ) ; String value = systemPrefs . get ( prefName ) . toString ( ) ; sysAdminUI . setPreferenceField ( value ) ; break ; case "Set Preference" : String preference = sysAdminUI . getPreferenceListBoxSelection ( ) ; String valueField = sysAdminUI . getPreferenceField ( ) ; systemPrefs . put ( preference , valueField ) ; setChanged ( ) ; notifyObservers ( ) ; break ; } }
va	2	public void deleteClient ( int id ) throws ClientDeleteException , ClientDoesNotExistException { try { CallableStatement callStat = _connection . prepareCall ( "{ call deleteClient(?) }" ) ; callStat . setInt ( 1 , id ) ; callStat . execute ( ) ; callStat . close ( ) ; } catch ( SQLException e ) { if ( e . getSQLState ( ) . equals ( "V2002" ) ) { throw new ClientDoesNotExistException ( e ) ; } throw new ClientDeleteException ( e ) ; } }
va	1	public XMLReaderDOM getDOMReader ( ) { if ( domReader == null ) { domReader = new XMLReaderDOM ( ) ; } return domReader ; }
va	7	private void createNewKey ( BigInteger value ) { if ( this . keyMode == KeyMode . MULTI_KEY ) { MultiKey temp = new MultiKey ( value ) ; if ( ! this . allMultiKeys . add ( temp ) ) throw new RuntimeException ( "MultiKey was in treeset!" ) ; for ( Key key : temp . values ) if ( ! this . allKeys . add ( key ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else { if ( ! this . allKeys . add ( new CountableKey ( value ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } }
va	4	@ Override public void actionPerformed ( ActionEvent e ) { int newRow = row + 1 ; if ( newRow > 20 ) newRow = 0 ; if ( ! SamuraiTableModel . isVisible ( newRow , column ) ) { if ( column < 9 || column > 11 ) newRow += 3 ; else newRow = 6 ; } moveToCell ( newRow , column ) ; }
va	5	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
va	1	public List < T > getList ( T [ ] x ) { List < T > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < x . length ; ++ i ) { l . add ( x [ i ] ) ; } return l ; }
va	8	public void keyPressed ( KeyEvent e ) { char keychar = e . getKeyChar ( ) ; int keycode = e . getKeyCode ( ) ; if ( keycode >= 0 && keycode < 256 ) { keymap [ keycode ] = true ; lastkey = keycode ; lastkeychar = keychar ; if ( wakeup_key == - 1 || wakeup_key == keycode ) { if ( ! eng . isRunning ( ) ) { eng . start ( ) ; keymap [ keycode ] = false ; } } } if ( e . isShiftDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ESCAPE && ! eng . isApplet ( ) ) { System . exit ( 0 ) ; } }
va	5	@ SuppressWarnings ( "rawtypes" ) public boolean survivalInstinct ( ) { int foxCount = 0 ; int rabbitCount = 0 ; int wolfCount = 0 ; HashMap < class , Counter > classStats = MainProgram . getSimulator ( ) . getSimulatorView ( ) . getStats ( ) . getPopulation ( ) ; for ( class c : classStats . keySet ( ) ) { Counter info = classStats . get ( c ) ; if ( info . getName ( ) . equals ( "bin.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } } if ( 1.5 * ( wolfCount + ( wolfCount * getBreedingProbability ( ) * getMaxLitterSize ( ) ) ) >= 0.5 * rabbitCount + foxCount ) { return false ; } return true ; }
va	3	public void eventDispatched ( AWTEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { this . buttonPressed ( ( MouseEvent ) e ) ; } if ( e . getID ( ) == MouseEvent . MOUSE_RELEASED ) { this . buttonReleased ( ( MouseEvent ) e ) ; } if ( e . getID ( ) == MouseEvent . MOUSE_MOVED ) { this . moved ( ( MouseEvent ) e ) ; } }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Ticket other = ( Ticket ) obj ; if ( code == null ) { if ( other . code != null ) return false ; } else if ( ! code . equals ( other . code ) ) return false ; return true ; }
va	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { this . put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
va	3	private void processNewXXXVector ( Element xml ) { String device = xml . getAttribute ( "device" ) . trim ( ) ; if ( device . length ( ) == 0 ) { return ; } String property = xml . getAttribute ( "name" ) . trim ( ) ; if ( property . length ( ) == 0 ) { return ; } if ( this . listensToProperty ( device , property ) ) { server . notifyClientListenersNewXXXVector ( this , xml ) ; } }
va	2	private static String jsonArray ( Object ... elements ) { if ( elements . length == 0 ) { return "[]" ; } StringBuilder result = new StringBuilder ( "[" + elements [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < elements . length ; i ++ ) { result . append ( " " ) ; result . append ( elements [ i ] . toString ( ) ) ; } result . append ( "]" ) ; return result . toString ( ) ; }
va	6	@ Override public AATileGenerator getAATileGenerator ( Shape s , AffineTransform at , Region clip , BasicStroke bs , boolean thin , boolean normalize , int [ ] bbox ) { MarlinTileGenerator ptg = null ; Renderer r = null ; final RendererContext rdrCtx = getRendererContext ( ) ; try { final AffineTransform _at = ( at != null && ! at . isIdentity ( ) ) ? at : null ; final NormMode norm = ( normalize ) ? NormMode . ON_WITH_AA : NormMode . OFF ; if ( bs == null ) { final PathIterator pi = getNormalizingPathIterator ( rdrCtx , norm , s . getPathIterator ( _at ) ) ; r = rdrCtx . renderer . init ( clip . getLoX ( ) , clip . getLoY ( ) , clip . getWidth ( ) , clip . getHeight ( ) , pi . getWindingRule ( ) ) ; pathTo ( rdrCtx , pi , r ) ; } else { r = rdrCtx . renderer . init ( clip . getLoX ( ) , clip . getLoY ( ) , clip . getWidth ( ) , clip . getHeight ( ) , PathIterator . WIND_NON_ZERO ) ; strokeTo ( rdrCtx , s , _at , bs , thin , norm , true , r ) ; } if ( r . endRendering ( ) ) { ptg = rdrCtx . ptg . init ( ) ; ptg . getBbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; MarlinRenderingEngine . returnRendererContext ( rdrCtx ) ; } } return ptg ; }
va	1	public static boolean downloadReqFiles ( String folder , String address ) { try { URL url = new URL ( address ) ; File out = new File ( folder + "\\temp.zip" ) ; Downloader . downloadFile ( url , out , System . out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } return true ; }
va	9X	public void Run ( ) { try { this . heartBeatThread . start ( ) ; ArrayList < KeyValuePair < Key1 , Value1 >> inputList = new ArrayList < KeyValuePair < Key1 , Value1 >> ( ) ; for ( String path : localInputPaths ) { FileInputStream fis = new FileInputStream ( path ) ; ObjectInputStream ois = new ObjectInputStream ( fis ) ; ArrayList < KeyValuePair < Key1 , Value1 >> subList = ( ArrayList < KeyValuePair < Key1 , Value1 >> ) ois . readObject ( ) ; ois . close ( ) ; inputList . addAll ( subList ) ; } Collections . sort ( inputList ) ; Reducer < Key1 , Value1 , Key2 , Value2 > r = reducerClass . newInstance ( ) ; Logger . log ( outputLocalPath ) ; Context < Key2 , Value2 > context = new Context < Key2 , Value2 > ( outputLocalPath ) ; Key1 previousKey = null ; ArrayList < Value1 > valueList = null ; for ( KeyValuePair < Key1 , Value1 > p : inputList ) { if ( previousKey == null || ! previousKey . equals ( p . key ) ) { if ( valueList != null ) r . reduce ( previousKey , valueList , context ) ; valueList = new ArrayList < Value1 > ( ) ; valueList . add ( p . value ) ; previousKey = p . key ; } else valueList . add ( p . value ) ; } if ( valueList != null && previousKey != null ) r . reduce ( previousKey , valueList , context ) ; context . dumpToFile ( ) ; this . % = 100 ; } catch ( InstantiationException | IllegalAccessException e ) { Logger . log ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( Exception ex ) { Logger . log ( "2" + ex . getMessage ( ) ) ; } }
va	4	public static String unescapeHtmlAndCapitalizeAndReplaceDash ( String inputText ) { if ( StringUtils . isEmpty ( inputText ) ) { return inputText ; } String cleanText ; cleanText = StringEscapeUtils . unescapeHtml ( inputText ) ; cleanText = cleanText . replaceAll ( "-" , " " ) ; cleanText = cleanText . replaceFirst ( "^\\s" , "" ) ; if ( Character . isLetter ( cleanText . charAt ( 0 ) ) ) { cleanText = StringUtils . capitalize ( cleanText ) ; } else { char [ ] stringArray = cleanText . toCharArray ( ) ; for ( int i = 0 ; i < cleanText . length ( ) ; i ++ ) { if ( Character . isLetter ( cleanText . charAt ( i ) ) ) { stringArray [ i ] = Character . toUpperCase ( stringArray [ i ] ) ; cleanText = new String ( stringArray ) ; break ; } } } return cleanText ; }
va	1	@ Override public void save ( Pagina entity ) throws HibernatePaooException { try { iniciarOperacion ( ) ; sesion . saveOrUpdate ( entity ) ; tx . commit ( ) ; } catch ( HibernateException he ) { throw new HibernatePaooException ( he . getMessage ( ) ) ; } finally { sesion . close ( ) ; } }
va	4	public void bloquearBoton ( ) { if ( this . tipoBarco == A ) { this . main . desactivarBotonUbicar ( 2 ) ; } else if ( this . tipoBarco == B ) { this . main . desactivarBotonUbicar ( 3 ) ; } else if ( this . tipoBarco == C ) { this . main . desactivarBotonUbicar ( 4 ) ; } else if ( this . tipoBarco == D ) { this . main . desactivarBotonUbicar ( 5 ) ; } }
va	4	public static void normalize ( final SampleSet set , final double [ ] mean , final double [ ] stddev , final int ... idxs ) { if ( set . size ( ) == 0 ) return ; final int inputsize = set . get ( 0 ) . getInputSize ( ) ; for ( Sample sample : set ) { final double [ ] input = sample . getInput ( ) ; int offset = 0 ; for ( int s = 0 ; s < sample . getInputLength ( ) ; s ++ ) { for ( int i = 0 ; i < idxs . length ; i ++ ) { final int idx = idxs [ i ] ; final double x = input [ offset + idx ] ; input [ offset + idx ] = ( ( x - mean [ idx ] ) / stddev [ idx ] ) ; } offset += inputsize ; } } }
va	0	public String getRowId ( ) { return rowId ; }
va	2	public void executeMacro ( VMacro macro ) throws TypeException { ArrayList < IValue > macroQueue = new ArrayList < IValue > ( ) ; for ( Object o : macro . getStackList ( ) ) { VQuote q = ( VQuote ) o ; macroQueue . add ( 0 , q . getInner ( ) ) ; } for ( IValue val : macroQueue ) { push ( val ) ; evaluateStack ( ) ; } }
va	4	private static void doSort ( OffHeapStructCollection a , long left , long right , int keyOffset , byte [ ] pi , byte [ ] pj , byte [ ] pe1 , byte [ ] pe2 , byte [ ] pe3 , byte [ ] pe4 , byte [ ] pe5 ) { if ( right - left + 1 < INSERTION_SORT_THRESHOLD ) { for ( long i = left + 1 ; i <= right ; i ++ ) { long ai = a . getInt ( i , keyOffset ) ; a . get ( i , pi ) ; long j ; for ( j = i - 1 ; j >= left && ai < a . getInt ( j , keyOffset ) ; j -- ) { a . get ( j , pj ) ; a . set ( j + 1 , pj ) ; } a . set ( j + 1 , pi ) ; } } else { dualPivotQuicksort ( a , left , right , keyOffset , pi , pj , pe1 , pe2 , pe3 , pe4 , pe5 ) ; } }
va	4	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Product other = ( Product ) obj ; if ( id != other . id ) return false ; return true ; }
va	3	@ Override protected void generateXML ( BufferedWriter out ) throws IOException { for ( int i = 0 ; i < this . answers . size ( ) ; i ++ ) { out . write ( "\t\t<choice" ) ; if ( i == this . correctAnswer ) out . write ( " correct=\"true\"" ) ; if ( i == this . selectedAnswer ) out . write ( " selected=\"true\"" ) ; out . write ( ">" ) ; out . write ( this . answers . get ( i ) ) ; out . write ( "</choice>\n" ) ; out . flush ( ) ; } }
va	5	public static JFrame getVisibleWindowByName ( String name ) { JFrame result = null ; if ( name != null ) { Frame [ ] windows = JFrame . getFrames ( ) ; for ( Frame window : windows ) { if ( window instanceof JFrame && window . isVisible ( ) && name . equals ( window . getName ( ) ) ) { result = ( JFrame ) window ; break ; } } } return result ; }
va	8	public static void BitFilter ( BufferedWrapper bw , int type ) { BufferedImage temp = bw . Clone ( ) ; int w_Squares , h_Squares , s ; Color c ; switch ( type ) { case SixteenBit : int pixels = temp . getWidth ( ) * temp . getHeight ( ) ; if ( pixels < 1000000 ) { s = 4 ; } else { s = 8 ; } w_Squares = temp . getWidth ( ) / s ; h_Squares = temp . getHeight ( ) / s ; for ( int i = 0 ; i < w_Squares ; i ++ ) { for ( int j = 0 ; j < h_Squares ; j ++ ) { c = GetColor ( temp , i , j , s ) ; if ( c . getRGB ( ) == Color . BLACK . getRGB ( ) ) { continue ; } for ( int k = 0 ; k < s ; k ++ ) { for ( int m = 0 ; m < s ; m ++ ) { temp . setRGB ( ( i * s ) + k , ( j * s ) + m , c . getRGB ( ) ) ; } } } } bw . img = temp ; break ; case EightBit : break ; } }
va	0	public void setRespGrp ( RespGrp value ) { this . respGrp = value ; }
va	7	@ Override public void run ( ) { BufferedReader stdIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String userInput ; try { while ( ( ( userInput = stdIn . readLine ( ) ) != null ) && exit == false ) { if ( userInput . equals ( "!exit" ) ) { exit = true ; stdIn . close ( ) ; AuctionServer_ServerSocket . shutdown ( ) ; Main_AuctionServer . auctionServerExecutionService . shutdown ( ) ; try { if ( ! Main_AuctionServer . auctionServerExecutionService . awaitTermination ( 3 , TimeUnit . SECONDS ) ) { Main_AuctionServer . auctionServerExecutionService . shutdownNow ( ) ; if ( ! Main_AuctionServer . auctionServerExecutionService . awaitTermination ( 3 , TimeUnit . SECONDS ) ) System . err . println ( "Pool did not terminate" ) ; } } catch ( InterruptedException ie ) { Main_AuctionServer . auctionServerExecutionService . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } break ; } } } catch ( IOException e ) { System . out . println ( "Error: Failed to read from stdIn!" ) ; } }
va	7	private static AccessibleObjectCandidate betterSignature ( AccessibleObjectCandidate methodCandidate , AccessibleObjectCandidate methodCandidate1 ) { final class [ ] parameters = methodCandidate . getParameterTypes ( ) ; final class [ ] parameters1 = methodCandidate1 . getParameterTypes ( ) ; int c = 0 , c1 = 0 ; for ( int i = 0 ; i < parameters . length ; i ++ ) { final class parameterClass = parameters [ i ] ; final class parameterClass1 = parameters1 [ i ] ; if ( parameterClass != parameterClass1 ) { if ( parameterClass . isPrimitive ( ) && parameterClass1 . isPrimitive ( ) ) { if ( ( ( Integer ) primitiveRankings . get ( parameterClass . getName ( ) ) ) . intValue ( ) < ( ( Integer ) primitiveRankings . get ( parameterClass1 . getName ( ) ) ) . intValue ( ) ) { c ++ ; } else { c1 ++ ; } } else if ( parameterClass . isAssignableFrom ( parameterClass1 ) ) { c1 ++ ; } else { c ++ ; } } } if ( c1 > c ) { return methodCandidate1 ; } return methodCandidate ; }
va	3	private void updateArea ( int x0 , int y0 , int w , int h ) { g . setBackground ( transparent ) ; g . clearRect ( x0 , y0 , w , h ) ; int xTileStart = ( x0 + xCam ) / 16 ; int yTileStart = ( y0 + yCam ) / 16 ; int xTileEnd = ( x0 + xCam + w ) / 16 ; int yTileEnd = ( y0 + yCam + h ) / 16 ; for ( int x = xTileStart ; x <= xTileEnd ; x ++ ) { for ( int y = yTileStart ; y <= yTileEnd ; y ++ ) { int b = level . getBlock ( x , y ) & ff ; if ( ( ( Level . TILE_BEHAVIORS [ b ] ) & Level . BIT_ANIMATED ) == 0 ) { g . drawImage ( Art . level [ b % 16 ] [ b / 16 ] , ( x << 4 ) - xCam , ( y << 4 ) - yCam , null ) ; } } } }
va	4	private static void init_perm ( long [ ] [ ] perm , byte [ ] p , int chars_in , int chars_out ) { for ( int k = 0 ; k < chars_out * 8 ; k ++ ) { int l = p [ k ] - 1 ; if ( l < 0 ) continue ; int i = l >> 2 ; l = 1 << ( l & 03 ) ; for ( int j = 0 ; j < 16 ; j ++ ) { int s = ( ( k & 07 ) + ( ( 7 - ( k >> 3 ) ) << 3 ) ) ; if ( ( j & l ) != 00 ) perm [ i ] [ j ] |= ( 1 << s ) ; } } }
va	8	public static void main ( String [ ] args ) throws IOException , InterruptedException { File testDir = new File ( System . getProperty ( "java.class.path" ) + "/../tests/pa3_tests" ) ; int failures = 0 ; for ( File x : testDir . listFiles ( ) ) { if ( x . getName ( ) . endsWith ( "out" ) || x . getName ( ) . startsWith ( "." ) || x . getName ( ) . endsWith ( "mJAM" ) || x . getName ( ) . endsWith ( "asm" ) ) continue ; int returnCode = runTest ( x ) ; if ( x . getName ( ) . indexOf ( "pass" ) != - 1 ) { if ( returnCode == 0 ) { System . out . println ( x . getName ( ) + " processed successfully!" ) ; } else { failures ++ ; System . err . println ( x . getName ( ) + " failed to be processed!" ) ; } } else { if ( returnCode == 4 ) System . out . println ( x . getName ( ) + " failed successfully!" ) ; else { System . err . println ( x . getName ( ) + " did not fail properly!" ) ; failures ++ ; } } } System . out . println ( failures + " failures in all." ) ; }
va	9X	private String getDirectionState ( Direction direction ) { String tmp ; switch ( direction . toString ( ) ) { case "EAST" : tmp = "EAST" ; break ; case "NORTH" : case "NORTHWEST" : case "NORTHEAST" : case "NONE" : tmp = "NORTH" ; break ; case "SOUTH" : case "SOUTHWEST" : case "SOUTHEAST" : tmp = "SOUTH" ; break ; case "WEST" : tmp = "WEST" ; break ; default : tmp = "ERROR" ; break ; } return tmp ; }
va	1	private String get_ct ( String str , int [ ] num_key , int start , int end , char [ ] keyed_alphabet , int add_index ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = start ; i < end ; i ++ ) { int p_loc = str . charAt ( i ) - A ; int ct_pos = ( p_loc + add_index + num_key [ i - start ] ) % 26 ; sb . append ( keyed_alphabet [ ct_pos ] ) ; } return sb . toString ( ) ; }
va	9X	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c ==   || c == 	 ) ; switch ( c ) { case 0 : return null ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '' || c == '' ) { throw x . syntaxError ( "Missing close quote '" + q + "'." ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case   : x . back ( ) ; return "" ; default : x . back ( ) ; return x . nextTo (   ) ; } }
va	9X	public void blendDraw ( Bitmap b , int xp , int yp , int col ) { xp += xOffs ; yp += yOffs ; int x0 = xp ; int x1 = xp + b . w ; int y0 = yp ; int y1 = yp + b . h ; if ( x0 < 0 ) x0 = 0 ; if ( y0 < 0 ) y0 = 0 ; if ( x1 > w ) x1 = w ; if ( y1 > h ) y1 = h ; if ( xFlip ) { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w + xp + b . w - 1 ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp - x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp - x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } else { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w - xp ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp + x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp + x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } }
va	9X	private static String readLastLine ( File file , String charset ) throws IOException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { return null ; } RandomAccessFile raf = null ; try { raf = new RandomAccessFile ( file , "r" ) ; long len = raf . length ( ) ; if ( len == 0 ) { return "" ; } else { long pos = len - 1 ; while ( pos > 0 ) { pos -- ; raf . seek ( pos ) ; if ( raf . readByte ( ) == '' ) { break ; } } if ( pos == 0 ) { raf . seek ( 0 ) ; } byte [ ] bytes = new byte [ ( int ) ( len - pos ) ] ; raf . read ( bytes ) ; if ( charset == null ) { return new String ( bytes ) ; } else { return new String ( bytes , charset ) ; } } } catch ( FileNotFoundException e ) { } finally { if ( raf != null ) { try { raf . close ( ) ; } catch ( Exception e2 ) { } } } return null ; }
va	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
va	0	public SecurityServiceException ( String code , String message ) { this ( code , message , null ) ; }
va	1	public void send ( ) { try { this . sendMsgs ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; this . close ( ) ; } }
va	5	private ILista CaminoMasLargo ( int nodoInicial , int nodoFinal , ILista caminoMasLargo , ILista caminoActual , Integer costoMaximo , int costoActual ) { if ( nodoInicial == nodoFinal ) { if ( costoMaximo . intValue ( ) < costoActual ) { caminoMasLargo = caminoActual . clone ( ) ; costoMaximo = costoActual ; } } else { ILista adyacentes = this . verticesAdyacentes ( nodoInicial ) ; while ( ! adyacentes . esVacia ( ) ) { int v = adyacentes . elementoInicial ( ) ; adyacentes . eliminar ( v ) ; boolean visitado = false ; if ( ! caminoActual . esVacia ( ) ) visitado = caminoActual . existe ( v ) ; if ( ! visitado ) { caminoActual . agregar ( v ) ; int costo = matrizAdyacencia [ nodoInicial ] [ v ] . peso ; caminoMasLargo = CaminoMasLargo ( v , nodoFinal , caminoMasLargo , caminoActual , costoMaximo , costoActual + costo ) ; caminoActual . eliminar ( v ) ; } } } return caminoMasLargo ; }
va	2	private Object lessMin ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return subseq ( ary , 1 , ary . length ) ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) return node . right ; else return concat ( node . element , lessMin ( node . left ) , node . right ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Modificar_observaciones_front ( ) . setVisible ( true ) ; } } ) ; }
va	3	public static void insertionSort ( int [ ] xs ) { for ( int j = 1 ; j < xs . length ; j ++ ) { int key = xs [ j ] ; int i = j - 1 ; while ( i >= 0 && key < xs [ i ] ) { xs [ i + 1 ] = xs [ i ] ; i -- ; } xs [ i + 1 ] = key ; } return ; }
va	3	public static int getSizeSafe ( int [ ] sizes , int sizeType ) { if ( sizes == null || sizes [ sizeType ] == NOT_SET ) return sizeType == MAX ? LayoutUtil . INF : 0 ; return sizes [ sizeType ] ; }
va	4	@ Override public boolean checkMember ( String memberName , String memberPassword ) { conn = DB . getConn ( ) ; try { pstmt = conn . prepareStatement ( "select MemberName MemberPassword from T_Member" ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { if ( memberName . equals ( rs . getString ( 1 ) ) || memberPassword . equals ( rs . getString ( 2 ) ) ) { return true ; } } return false ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return false ; }
va	1	public static void flipDirectionTo ( int x ) { if ( Proto . x > x ) setDirectionToLeft ( ) ; else setDirectionToRight ( ) ; }
va	8	public static void main ( String [ ] args ) { EvolvingGlobalProblemSetInitialisation starter = new EvolvingGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(1(01*0)*1|0)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 25 ] ; int [ ] candidatesCount = new int [ 1 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 3 ; problemCount [ 1 ] = 6 ; problemCount [ 2 ] = 9 ; problemCount [ 3 ] = 12 ; problemCount [ 4 ] = 15 ; problemCount [ 5 ] = 18 ; problemCount [ 6 ] = 21 ; problemCount [ 7 ] = 24 ; problemCount [ 8 ] = 27 ; problemCount [ 9 ] = 30 ; problemCount [ 10 ] = 33 ; problemCount [ 11 ] = 36 ; problemCount [ 12 ] = 39 ; problemCount [ 13 ] = 42 ; problemCount [ 14 ] = 45 ; problemCount [ 15 ] = 48 ; problemCount [ 16 ] = 51 ; problemCount [ 17 ] = 54 ; problemCount [ 18 ] = 57 ; problemCount [ 19 ] = 60 ; problemCount [ 20 ] = 63 ; problemCount [ 21 ] = 66 ; problemCount [ 22 ] = 69 ; problemCount [ 23 ] = 72 ; problemCount [ 24 ] = 75 ; candidatesCount [ 0 ] = 50 ; problemCount [ 0 ] = 100 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 1 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "E_G_PS_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n ] ; cc = candidatesCount [ 0 ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
va	7	private Point findSpawnLocation ( LayeredMap map ) { for ( int y = 3 ; y < map . getHeight ( ) ; y ++ ) { for ( int x = 3 ; x < map . getWidth ( ) ; x ++ ) { boolean ok = true ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int i = 0 ; i < 4 ; i ++ ) { int ground = map . get ( 0 , x + i , y + j ) & FFFF ; int feat = map . get ( 1 , x + i , y + j ) & FFFF ; if ( ground != . || feat != 0 ) { ok = false ; } } } if ( ok ) { return new Point ( x , y ) ; } } } return new Point ( 10 , 10 ) ; }
va	4	public static float pcaAngle ( Collection < Vector2f > points ) { final float size = points . size ( ) ; if ( size < 2 ) return 0.0f ; final Vector2f mean = mean ( points ) ; double cov00 = 0.0 ; double cov01 = 0.0 ; double cov11 = 0.0 ; for ( Vector2f p : points ) { final float x = mean . x - p . x ; final float y = mean . y - p . y ; cov00 += ( x * x ) ; cov01 += ( x * y ) ; cov11 += ( y * y ) ; } final double in = ( size > 0.0f ) ? ( 1.0f / size ) : ( 0.0f ) ; cov00 *= ( in ) ; cov01 *= ( in ) ; cov11 *= ( in ) ; final double covd = ( cov00 - cov11 ) ; if ( covd == 0.0 ) return 0.0f ; final double theta = 0.5 * Math . atan ( ( 2.0 * cov01 ) / covd ) ; return ( float ) theta ; }
va	0	@ Override public DataEntry clone ( ) { DataEntry retval = new DataEntry ( this . x . clone ( ) , this . y ) ; retval . extra = this . extra ; return retval ; }
va	4	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ Override public Object instantiate ( ObjectBinder context , Object value , Type targetType , class targetClass ) { if ( value instanceof Map && targetClass == URLList . class ) { Map < String , ? > map = ( Map < String , ? > ) value ; URLList u = new URLList ( ) ; context . use ( URL . class , new URL ( ) ) ; context . bindIntoObject ( ( Map ) map . get ( "items" ) , u , targetClass ) ; return u ; } throw context . cannotConvertValueToTargetType ( value , targetClass ) ; }
va	4	protected void setMoveLocations ( Location [ ] newMoves ) { if ( this . moveLocations != null ) for ( Location loc : this . moveLocations ) { this . pieces . get ( loc ) . resetColor ( ) ; } this . moveLocations = newMoves ; if ( this . moveLocations != null ) for ( Location loc : this . moveLocations ) { this . pieces . get ( loc ) . setCurColor ( BoardColor . MOVES ) ; } }
va	6	public static int dehexchar ( char c ) { if ( c >= 0 && c <= 9 ) { return c - 0 ; } if ( c >= A && c <= F ) { return c - ( A - 10 ) ; } if ( c >= a && c <= f ) { return c - ( a - 10 ) ; } return - 1 ; }
va	9X	private Collection < String > missingRequiredOptions ( OptionSet options ) { Collection < String > missingRequiredOptions = new HashSet < String > ( ) ; for ( AbstractOptionSpec < ? > each : recognizedOptions . toJavaUtilMap ( ) . values ( ) ) { if ( each . isRequired ( ) && ! options . has ( each ) ) missingRequiredOptions . addAll ( each . options ( ) ) ; } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredIf . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredUnless . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( ! optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } return missingRequiredOptions ; }
va	1	public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; }
va	6	@ Override public int getChannelVolume ( int inputChannel , int outputChannel ) { if ( inputChannel < 0 || inputChannel >= channelVolumes . size ( ) ) throw new IndexOutOfBoundsException ( "Input channel must be in legal range!" ) ; if ( outputChannel >= channelCount ) throw new IndexOutOfBoundsException ( "Output channel must be in legal range!" ) ; if ( outputChannel < 0 ) { int [ ] v = channelVolumes . get ( inputChannel ) ; int max = v [ 0 ] ; for ( int i = 1 ; i < channelCount ; i ++ ) max = v [ i ] > max ? v [ i ] : max ; return max ; } else { return channelVolumes . get ( inputChannel ) [ outputChannel ] ; } }
va	7	@ Override public boolean nextKeyValue ( ) throws IOException , InterruptedException { if ( key == null ) { key = new LongWritable ( ) ; } key . set ( pos ) ; if ( value == null ) { value = new Text ( ) ; } value . clear ( ) ; final Text endline = new Text ( "\n" ) ; int newSize = 0 ; for ( int i = 0 ; i < NLINESTOPROCESS ; i ++ ) { Text v = new Text ( ) ; while ( pos < end ) { newSize = in . readLine ( v , maxLineLength , Math . max ( ( int ) Math . min ( Integer . MAX_VALUE , end - pos ) , maxLineLength ) ) ; value . append ( v . getBytes ( ) , 0 , v . getLength ( ) ) ; value . append ( endline . getBytes ( ) , 0 , endline . getLength ( ) ) ; if ( newSize == 0 ) { break ; } pos += newSize ; if ( newSize < maxLineLength ) { break ; } } } if ( newSize == 0 ) { key = null ; value = null ; return false ; } else { return true ; } }
va	2	@ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { final Component c = super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; if ( dataholder . getResult ( ) . get ( row ) . getSignificance ( ) == EdasomindSignificance . HIGH ) { c . setForeground ( Color . WHITE ) ; c . setBackground ( Color . RED ) ; } else if ( dataholder . getResult ( ) . get ( row ) . getSignificance ( ) == EdasomindSignificance . MEDIUM ) { c . setForeground ( Color . black ) ; c . setBackground ( Color . ORANGE ) ; } else { c . setBackground ( Color . GREEN ) ; c . setForeground ( Color . black ) ; } return c ; }
va	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } ClienteDao oClienteDAO = new ClienteDao ( ) ; int pages = oClienteDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "ClienteGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
va	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PersistentVector < ? > other = ( PersistentVector < ? > ) obj ; if ( ls == null ) { if ( other . ls != null ) return false ; } else if ( ! ls . equals ( other . ls ) ) return false ; return true ; }
va	0	public InviteDaoException ( String message , Throwable cause ) { super ( message , cause ) ; }
va	3	public void testContinue ( ) { outer : for ( int j = 0 ; j < 5 ; j ++ ) { System . out . println ( "Starting main loop j=" + j ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { int num = ( int ) ( Math . random ( ) * 100 ) ; if ( num == 0 ) { System . out . println ( "********** Got 0" ) ; break outer ; } System . out . println ( i / num ) ; } } }
va	6	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) return true ; if ( p == null || q == null ) return false ; if ( p . val != q . val ) return false ; return isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ; }
va	0	public int amount ( ) { return this . amount ; }
va	2	@ SuppressWarnings ( "unchecked" ) public void registerRemoved ( DomainObject obj ) { if ( newObjects . remove ( obj ) ) return ; dirtyObjects . remove ( obj ) ; if ( ! removedObjects . contains ( obj ) ) { removedObjects . add ( obj ) ; } }
va	8	private Node cleanNode ( Lexer lexer , Node node ) { Node next = null ; MutableObject o = new MutableObject ( ) ; boolean b = false ; for ( next = node ; node . isElement ( ) ; node = next ) { o . setObject ( next ) ; b = dir2Div ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = nestedList ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = center2Div ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = mergeDivs ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = blockStyle ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = inlineStyle ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = font2Span ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; break ; } return next ; }
va	2	@ Override public String getAsString ( FacesContext facesContext , UIComponent component , Object object ) { if ( object == null ) { return null ; } if ( object instanceof Keystate ) { Keystate o = ( Keystate ) object ; return getStringKey ( o . getIdkeystate ( ) ) ; } else { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "object {0} is of type {1}; expected type: {2}" , new Object [ ] { object , object . getClass ( ) . getName ( ) , Keystate . class . getName ( ) } ) ; return null ; } }
va	7	private void handleMessage ( String message ) { JSONObject data = ( JSONObject ) JSONValue . parse ( message ) ; String action = ( String ) data . get ( Messages . type ) ; if ( action . equals ( Messages . switchWhiteboard ) ) { newCanvas ( ) ; SwitchWhiteboardMessage m = SwitchWhiteboardMessage . static . fromJSON ( data ) ; model . whiteboard = new Whiteboard ( m . whiteboardID , model ) ; frame . setTitle ( "Now connected to: " + m . whiteboardID ) ; return ; } else if ( action . equals ( Messages . whiteboardCreated ) ) { newCanvas ( ) ; WhiteboardCreatedMessage m = WhiteboardCreatedMessage . static . fromJSON ( data ) ; model . whiteboard = new Whiteboard ( m . whiteboardID , model ) ; frame . setTitle ( "Now connected to: " + m . whiteboardID ) ; return ; } else if ( model . whiteboard != null ) { if ( action . equals ( Messages . currentUsers ) ) { UserListMessage m = UserListMessage . static . fromJSON ( data ) ; if ( m . whiteboardID . equals ( model . whiteboard . whiteboardID ) ) { setCurrentUsers ( m . getUsers ( ) ) ; } } else if ( action . equals ( Messages . fromServerStroke ) ) { FromServerStrokeMessage m = FromServerStrokeMessage . static . fromJSON ( data ) ; if ( m . whiteboardID . equals ( model . whiteboard . whiteboardID ) ) { model . whiteboard . addDrawableFromServer ( m . id , m . drawable ) ; } } } frame . repaint ( ) ; }
va	7	public String multiply ( String num1 , String num2 ) { if ( num1 == null || num2 == null || num1 . length ( ) == 0 || num2 . length ( ) == 0 ) { return "" ; } if ( num1 . length ( ) + num2 . length ( ) <= 8 ) { return Integer . toString ( Integer . parseInt ( num1 ) * Integer . parseInt ( num2 ) ) ; } int l1 = num1 . length ( ) ; int l2 = num2 . length ( ) ; String a = num1 . substring ( 0 , l1 >> 1 ) ; String b = num1 . substring ( l1 >> 1 ) ; String c = num2 . substring ( 0 , l2 >> 1 ) ; String d = num2 . substring ( l2 >> 1 ) ; StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; int limit = l1 - ( l1 >> 1 ) ; for ( int i = 0 ; i < limit ; i ++ ) { sb1 . append ( "0" ) ; } limit = l2 - ( l2 >> 1 ) ; for ( int i = 0 ; i < limit ; i ++ ) { sb2 . append ( "0" ) ; } String ac = multiply ( a , c ) + sb1 . toString ( ) + sb2 . toString ( ) ; String ad = multiply ( a , d ) + sb1 . toString ( ) ; String bc = multiply ( b , c ) + sb2 . toString ( ) ; String bd = multiply ( b , d ) ; String result = add ( ac , ad ) ; result = add ( result , bc ) ; result = add ( result , bd ) ; return result ; }
va	1	@ Override public AIMove move ( ) { AIManager manager = AIManager . getInstance ( ) ; AIHockeyist hockeyist = manager . getTeammate ( hockeyistId ) ; AIPuck puck = manager . getPuck ( ) ; AIMove move = AIGo . to ( hockeyist , puck ) ; if ( hockeyist . isInStickRange ( puck ) ) { move . setAction ( ActionType . TAKE_PUCK ) ; } return move ; }
va	1	public Muckyluat merge ( Muckyluat detachedInstance ) { log . debug ( "merging Muckyluat instance" ) ; try { Muckyluat result = ( Muckyluat ) sessionFactory . getCurrentSession ( ) . merge ( detachedInstance ) ; log . debug ( "merge successful" ) ; return result ; } catch ( RuntimeException re ) { log . error ( "merge failed" , re ) ; throw re ; } }
va	0	public String getObservacoes ( ) { return observacoes ; }
va	7	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnBorrarBusqueda ) { txtBuscar . setText ( "" ) ; filtrarMedio ( txtBuscar . getText ( ) , raizNegativa , raizArbol , false ) ; modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnActualizar ) { cargarMedios ( ) ; modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnExpandir ) { expandido = ! expandido ; if ( ! expandido ) btnExpandir . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_EXPANDIR_16 ) ) ) ; else btnExpandir . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_COLAPSAR_16 ) ) ) ; expandirTodo ( arbolPrincipal , expandido ) ; if ( ! expandido ) modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnConfigurar ) personalizarBusqueda = new DialogoPersonalizarBusqueda ( ) ; if ( e . getSource ( ) == itmAgregar ) ; }
va	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
va	3	public void requestNewPose ( ) { boolean continueToMakeNew = true ; if ( ! saved ) { continueToMakeNew = promptToSave ( ) ; } if ( continueToMakeNew ) { continueToMakeNew = promptForNew ( ) ; if ( continueToMakeNew ) { PoseurStateManager poseurStateManager = Poseur . getPoseur ( ) . getStateManager ( ) ; poseurStateManager . resetState ( ) ; poseurStateManager . setState ( PoseurState . SELECT_SHAPE_STATE ) ; } } }
va	3	public void shoot ( double xa , double ya , double za ) { super . shoot ( xa , ya , za ) ; for ( int i = 0 ; i < bombs . size ( ) ; i ++ ) { if ( bombs . get ( i ) . removed ) bombs . remove ( i -- ) ; } if ( bombs . size ( ) == 8 ) { bombs . remove ( 0 ) . detonate ( ) ; } StickyBomb bomb = new StickyBomb ( owner , this , xa , ya , za , 90 ) ; bombs . add ( bomb ) ; owner . level . add ( bomb ) ; shootDelay = shootDelayTime ; }
va	2	public String consumeResponse ( HttpResponse response ) { printStatus ( getResponseStatus ( ) ) ; printHeaders ( getResponseHeaders ( ) ) ; printCookies ( getCookies ( ) ) ; printSeparatorLine ( ) ; String content = null ; try { content = consumeResponseContent ( response ) ; } catch ( IllegalStateException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } printSeparatorLine ( ) ; return content ; }
va	6	public boolean doSave ( boolean saveAs ) { File f = file ; if ( saveAs || file == null ) { f = getFile ( true ) ; if ( f == null ) return false ; String name = f . getName ( ) . toLowerCase ( ) ; if ( ! name . endsWith ( ".png" ) ) { if ( name . contains ( "." ) ) name = name . substring ( 0 , name . lastIndexOf ( . ) ) ; f = new File ( f . getParentFile ( ) , name + ".png" ) ; } } try { ImageIO . write ( canvas . getRenderImage ( ) , "PNG" , f ) ; file = f ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; }
va	4	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ Override public Object instantiate ( ObjectBinder context , Object value , Type targetType , class targetClass ) { if ( value instanceof Map && targetClass == Message . class ) { Map < String , ? > map = ( Map < String , ? > ) value ; Message m = new Message ( ) ; m . fileId = stringVal ( map . get ( "user_file_id" ) ) ; m . hidden = boolVal ( map . get ( "hidden" ) ) ; m . userId = stringVal ( map . get ( "user_id" ) ) ; m . description = stringVal ( map . get ( "description" ) ) ; m . title = stringVal ( map . get ( "title" ) ) ; m . importance = stringVal ( map . get ( "importance" ) ) ; m . fileName = stringVal ( map . get ( "file_name" ) ) ; m . fileType = stringVal ( map . get ( "file_type" ) ) ; m . fromUserId = stringVal ( map . get ( "from_user_id" ) ) ; m . id = stringVal ( map . get ( "id" ) ) ; m . channel = stringVal ( map . get ( "channel" ) ) ; return m ; } throw context . cannotConvertValueToTargetType ( value , targetClass ) ; }
va	0	private void button1ActionPerformed ( java . awt . event . ActionEvent evt ) { String userInput = jTextField2 . getText ( ) ; this . main . hideView ( Main . view . GenreSearch ) ; this . main . showView ( Main . view . GenreSearchResult ) ; }
va	5	public void rotate ( final int i , final double a , final double b ) { int j ; double c , fact , s , w , y ; if ( a == 0.0 ) { c = 0.0 ; s = ( b >= 0.0 ? 1.0 : - 1.0 ) ; } else if ( abs ( a ) > abs ( b ) ) { fact = b / a ; c = SIGN ( 1.0 / sqrt ( 1.0 + ( fact * fact ) ) , a ) ; s = fact * c ; } else { fact = a / b ; s = SIGN ( 1.0 / sqrt ( 1.0 + ( fact * fact ) ) , b ) ; c = fact * s ; } for ( j = i ; j < n ; j ++ ) { y = r [ i ] [ j ] ; w = r [ i + 1 ] [ j ] ; r [ i ] [ j ] = c * y - s * w ; r [ i + 1 ] [ j ] = s * y + c * w ; } for ( j = 0 ; j < n ; j ++ ) { y = qt [ i ] [ j ] ; w = qt [ i + 1 ] [ j ] ; qt [ i ] [ j ] = c * y - s * w ; qt [ i + 1 ] [ j ] = s * y + c * w ; } }
va	2	public static void printWarnings ( Connection conn , PrintWriter pw ) { if ( conn != null ) { try { printStackTrace ( conn . getWarnings ( ) , pw ) ; } catch ( SQLException e ) { printStackTrace ( e , pw ) ; } } }
va	2	private static void allSubsetsOfSizeK ( List < String > items , int k , int startIndex , List < String > currentSubset , List < String > resultHolder ) { if ( currentSubset . size ( ) == k ) { resultHolder . add ( StringUtils . join ( currentSubset , " " ) ) ; return ; } for ( int i = startIndex ; i < items . size ( ) ; i ++ ) { currentSubset . add ( items . get ( i ) ) ; allSubsetsOfSizeK ( items , k , i + 1 , currentSubset , resultHolder ) ; currentSubset . remove ( currentSubset . size ( ) - 1 ) ; } }
va	6	public void testAttribUniq ( ) throws IOException , XmlPullParserException { final String attribsOk = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='c' n:b='d' n:x='e'" + "/>\n" + "" ; final String duplicateAttribs = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='a' n:b='b' a='x'" + "/>\n" + "" ; final String duplicateNsAttribs = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='a' n:b='b' n:a='a'" + "/>\n" + "" ; final String duplicateXmlns = "<m:test xmlns:m='Some-Namespace-URI' xmlns:m='Some-Namespace-URI'" + "" + "/>\n" + "" ; final String duplicateAttribXmlnsDefault = "<m:test xmlns='Some-Namespace-URI' xmlns:m='Some-Namespace-URI'" + " a='a' b='b' m:b='b' m:a='x'" + "/>\n" + "" ; XmlPullParser pp = factory . newPullParser ( ) ; parseOneElement ( pp , attribsOk , false ) ; assertEquals ( "a" , pp . getAttributeValue ( null , "a" ) ) ; assertEquals ( "b" , pp . getAttributeValue ( null , "b" ) ) ; assertEquals ( "c" , pp . getAttributeValue ( null , "m:a" ) ) ; assertEquals ( "d" , pp . getAttributeValue ( null , "n:b" ) ) ; assertEquals ( "e" , pp . getAttributeValue ( null , "n:x" ) ) ; parseOneElement ( pp , attribsOk , true ) ; assertEquals ( "a" , pp . getAttributeValue ( "" , "a" ) ) ; assertEquals ( "b" , pp . getAttributeValue ( "" , "b" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "m:a" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "n:b" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "n:x" ) ) ; assertEquals ( "c" , pp . getAttributeValue ( "Some-Namespace-URI" , "a" ) ) ; assertEquals ( "d" , pp . getAttributeValue ( "Some-Namespace-URI" , "b" ) ) ; assertEquals ( "e" , pp . getAttributeValue ( "Some-Namespace-URI" , "x" ) ) ; parseOneElement ( pp , duplicateNsAttribs , false ) ; parseOneElement ( pp , duplicateAttribXmlnsDefault , false ) ; parseOneElement ( pp , duplicateAttribXmlnsDefault , true ) ; Exception ex ; ex = null ; try { parseOneElement ( pp , duplicateAttribs , false ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateAttribs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateXmlns , false ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateXmlns , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateNsAttribs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; final String declaringDefaultEmptyNs = "<m:test xmlns='' xmlns:m='uri'/>" ; parseOneElement ( pp , declaringDefaultEmptyNs , false ) ; parseOneElement ( pp , declaringDefaultEmptyNs , true ) ; final String declaringPrefixedEmptyNs = "<m:test xmlns:m='' />" ; parseOneElement ( pp , declaringPrefixedEmptyNs , false ) ; ex = null ; try { parseOneElement ( pp , declaringPrefixedEmptyNs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; }
va	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
va	9X	protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case  : retval . append ( "\\b" ) ; continue ; case 	 : retval . append ( "\\t" ) ; continue ; case '' : retval . append ( "\\n" ) ; continue ; case  : retval . append ( "\\f" ) ; continue ; case '' : retval . append ( "\\r" ) ; continue ; case " : retval . append ( "\\\"" ) ; continue ; case ' : retval . append ( "\\'" ) ; continue ; case \ : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 20 || ch > 7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
va	9X	public Object run ( ) throws Exception { return Util . getWorkingDirectory ( ) + File . separator + "bin" + File . separator ; }
va	3	public void writeMarkov ( PrintWriter pw ) { pw . println ( "<state name=\"" + this . getName ( ) + "\" fallback=\"" + masterConnection . getTo ( ) . getName ( ) + "\">" ) ; pw . println ( "<connections>" ) ; for ( Entry < String , int > ent : transitionCounter . entrySet ( ) ) { if ( ent . getValue ( ) . getValue ( ) > 0 ) { Connection cn = findConnection ( ent . getKey ( ) ) ; if ( cn != null ) { pw . println ( "<connection tag=\"" + ent . getKey ( ) + "\" counter=\"" + ent . getValue ( ) . toString ( ) + "\" to=\"" + cn . getTo ( ) . getName ( ) + "\" />" ) ; } else { pw . println ( "<connection tag=\"" + ent . getKey ( ) + "\" counter=\"" + ent . getValue ( ) . toString ( ) + "\" to=\"" + masterConnection . getTo ( ) . getName ( ) + "\" />" ) ; } } } pw . println ( "</connections>" ) ; pw . println ( "</state>" ) ; }
va	0	public HTTPMessage getMessage ( ) { return msg ; }
va	8	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final WorkPayment other = ( WorkPayment ) obj ; if ( this . payment != other . payment && ( this . payment == null || ! this . payment . equals ( other . payment ) ) ) { return false ; } if ( this . workType != other . workType && ( this . workType == null || ! this . workType . equals ( other . workType ) ) ) { return false ; } return true ; }
va	4	public static void createOfficeObject ( OfficeObject officeObject ) { PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , officeObject . getId ( ) ) ; ps . setString ( 2 , officeObject . getName ( ) ) ; ps . setInt ( 3 , officeObject . getType ( ) ) ; ps . setInt ( 4 , officeObject . getOfficeObjectStatusId ( ) ) ; ps . executeUpdate ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } }
va	5	@ Override public void marshal ( Element agent , Document doc ) { super . marshal ( agent , doc ) ; agent . setAttribute ( "ROLE" , this . role . value ( ) ) ; if ( this . agenttype != null ) agent . setAttribute ( "AGENTTYPE" , this . agenttype . value ( ) ) ; if ( this . otherrole != null ) agent . setAttribute ( "OTHERROLE" , this . otherrole ) ; if ( this . othertype != null ) agent . setAttribute ( "OTHERTYPE" , this . othertype ) ; Element name = doc . createElementNS ( NS . METS . ns ( ) , "mets:name" ) ; name . setTextContent ( this . name ) ; agent . appendChild ( name ) ; if ( this . note != null ) { for ( String n : this . note ) { Element note ; note = doc . createElementNS ( NS . METS . ns ( ) , "mets:note" ) ; note . setTextContent ( n ) ; agent . appendChild ( note ) ; } } }
va	9X	public static void main ( String [ ] args ) { RotateListProblem problem1 = new RotateListProblem ( Arrays . asList ( 1 , 2 , 4 , 8 , 16 , 32 ) ) ; RotateListProblem problem2 = new RotateListProblem ( Arrays . asList ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ) ) ; Genejector . getSettings ( ) . setScoreLimit ( 4 ) ; Genejector . getSettings ( ) . setPrintAllIndividuals ( true ) ; Genejector . getSettings ( ) . addClass ( "int" , false ) ; Genejector . getSettings ( ) . addClass ( "java.util.ArrayList" , false ) ; while ( ! Genejector . isSolutionFound ( ) ) { Genejector . geneject ( RotateListProblem . class ) ; long score = 0 ; Genejector . execute ( problem1 ) ; if ( problem1 . list != null && problem1 . list . equals ( Arrays . asList ( 2 , 4 , 8 , 16 , 32 , 1 ) ) ) { score += 2 ; } else if ( problem1 . list != null && ( problem1 . list . equals ( Arrays . asList ( 2 , 4 , 8 , 16 , 32 ) ) || problem1 . list . equals ( Arrays . asList ( 1 , 2 , 4 , 8 , 16 , 32 , 1 ) ) ) ) { score += 1 ; } Genejector . execute ( problem2 ) ; if ( problem2 . list != null && problem2 . list . equals ( Arrays . asList ( 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 0 ) ) ) { score += 2 ; } else if ( problem2 . list != null && ( problem2 . list . equals ( Arrays . asList ( 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ) ) || problem2 . list . equals ( Arrays . asList ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 0 ) ) ) ) { score += 1 ; } Genejector . submitScore ( score ) ; } System . out . println ( "Solution: " + Genejector . getSolutionSourceCode ( ) ) ; }
va	4	public void move ( int dx , int dy ) { dy = dy * - 1 ; if ( ScreenX + dx > 0 && ScreenX + Width + dx < 800 ) { ScreenX += dx ; } if ( ScreenY + dy > 0 && ScreenY + dy + getTotalHeight ( ) < Standards . W_HEIGHT ) { ScreenY += dy ; } }
va	1	public static byte [ ] encodeBytesToBytes ( byte [ ] source ) { byte [ ] encoded = null ; try { encoded = encodeBytesToBytes ( source , 0 , source . length , Base64 . NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { assert false : "IOExceptions only come from GZipping  which is turned off: " + ex . getMessage ( ) ; } return encoded ; }
va	6	public void createRoster ( ) { Calendar today = ( Calendar ) startDate . clone ( ) ; int count ; for ( int i = 0 ; i < numberOfDays ; i ++ ) { count = 0 ; numberOfServices = getNumberOfServices ( today . getTime ( ) ) ; driversUsed = new driverUsed [ numberOfServices ] ; busesUsed = new busUsed [ numberOfServices ] ; getServices ( today ) ; packs [ i ] = new Pack [ numberOfServices ] ; for ( int j = 0 ; j < numberOfServices ; j ++ ) { packs [ i ] [ j ] = new Pack ( ) ; packs [ i ] [ j ] . serv = getNextService ( ) ; packs [ i ] [ j ] . driver_id = getLeastWorkingDriver ( drivers , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; packs [ i ] [ j ] . bus_id = getAvailableBus ( buses , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; int findDriver = 0 ; int findBus = 0 ; for ( int k = 0 ; k < drivers . length ; k ++ ) if ( packs [ i ] [ j ] . driver_id == drivers [ k ] ) { findDriver = k ; } for ( int k = 0 ; k < buses . length ; k ++ ) if ( packs [ i ] [ j ] . bus_id == buses [ k ] ) { findBus = k ; } minutesDriverWorked [ findDriver ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; minutesBusWorked [ findBus ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; } today . add ( Calendar . DAY_OF_MONTH , 1 ) ; driversUsedIndex = 0 ; busesUsedIndex = 0 ; } printPacks ( ) ; toDatabase ( packs ) ; }
va	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back != null ) != ( that . back != null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
va	2	public void paint ( Graphics g ) { if ( vertexList . size ( ) == 0 ) return ; Polygon p = getPolygon ( ) ; if ( isFilled ( ) ) { g . setColor ( getFillColor ( ) ) ; g . fillPolygon ( p . xpoints , p . ypoints , p . npoints ) ; g . setColor ( getColor ( ) ) ; } g . drawPolygon ( p . xpoints , p . ypoints , p . npoints ) ; }
va	3	public static void init ( ) { if ( colors != null ) return ; maxColors = COLOR_RECORDS ; colors = new Color [ maxColors * COLOR_LEVELS ] ; final int [ ] def = { 255 , 255 , 255 , 192 , 192 , 192 , 128 , 128 , 128 , 64 , 64 , 64 , 0 , 0 , 0 , 255 , 0 , 0 , 255 , 175 , 175 , 255 , 200 , 0 , 255 , 255 , 0 , 0 , 255 , 0 , 255 , 0 , 255 , 0 , 255 , 255 , 0 , 0 , 255 , 99 , 66 , 33 , 33 , 99 , ff , 00 , 88 , 00 , } ; for ( int i = 0 ; i < def . length ; i += 3 ) { add ( i / 3 , def [ i + 0 ] , def [ i + 1 ] , def [ i + 2 ] ) ; } final int [ ] trans = { BLUE , RED , RED , DARKGREEN , DARKGREEN , BLUE , GRAY , RED , GRAY , DARKGREEN , } ; for ( int i = 0 , j = BLUERED ; i < trans . length ; i += 2 , j ++ ) { int s = trans [ i + 0 ] * 3 ; int d = trans [ i + 1 ] * 3 ; addTransition ( j , def [ s + 0 ] , def [ s + 1 ] , def [ s + 2 ] , def [ d + 0 ] , def [ d + 1 ] , def [ d + 2 ] ) ; } }
va	9X	public ListNode rotateRight ( ListNode head , int n ) { int length = 0 ; if ( head == null ) { return null ; } if ( n == 0 ) { return head ; } ListNode currentNode = head ; while ( currentNode != null ) { length ++ ; currentNode = currentNode . next ; } n = n % length ; if ( length == 1 || n == 0 ) { return head ; } int count = 0 ; currentNode = head ; while ( count != n ) { count ++ ; currentNode = currentNode . next ; } currentNode = currentNode . next ; ListNode temp = head ; ListNode tempLast = null ; while ( currentNode != null ) { if ( currentNode . next == null ) { tempLast = currentNode ; } temp = temp . next ; currentNode = currentNode . next ; } currentNode = temp . next ; temp . next = null ; if ( tempLast == null ) { tempLast = currentNode ; while ( tempLast . next != null ) { tempLast = tempLast . next ; } } tempLast . next = head ; head = currentNode ; return head ; }
va	2	@ Override public void actionPerformed ( ActionEvent e ) { String name = "" , pass ; if ( e . getSource ( ) == this . btnLogin ) name = getLoginName ( ) ; pass = getPasswort ( ) ; if ( steuerung . login ( name , pass ) == true ) { dispose ( ) ; } else { nameField . setText ( "" ) ; passwordField . setText ( "" ) ; } }
va	3	private void clear ( ) { where = new ArrayList < String > ( ) ; comboBoxPanel . removeAll ( ) ; labelPanel . removeAll ( ) ; textFieldPanel . removeAll ( ) ; HashMap < String , ArrayList < String >> query = db . get ( "*" , relation . getSelectedItem ( ) . toString ( ) ) ; columns = query . keySet ( ) . toArray ( new String [ 0 ] ) ; constrains = new JComboBox [ columns . length ] ; JLabel [ ] labels = new JLabel [ columns . length ] ; modifications = new JTextField [ columns . length ] ; comboBoxPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; labelPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; textFieldPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; matchTable = new JTable ( db . convert ( query ) , query . keySet ( ) . toArray ( ) ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; JScrollPane scrollPane = new JScrollPane ( matchTable ) ; scrollPane . setPreferredSize ( new Dimension ( 720 , 170 ) ) ; matchTable . setFillsViewportHeight ( true ) ; int i = 0 ; for ( String column : columns ) { ArrayList < String > list = query . get ( column ) ; list . add ( "ALL" ) ; Collections . reverse ( list ) ; constrains [ i ] = new JComboBox ( new LinkedHashSet ( list ) . toArray ( ) ) ; constrains [ i ] . setSelectedItem ( "ALL" ) ; constrains [ i ] . addActionListener ( optionListener ) ; labels [ i ] = new JLabel ( "Set " + columns [ i ] + ":" ) ; modifications [ i ] = new JTextField ( ) ; comboBoxPanel . add ( constrains [ i ] ) ; labelPanel . add ( labels [ i ] ) ; textFieldPanel . add ( modifications [ i ] ) ; i ++ ; } tablePanel . removeAll ( ) ; tablePanel . add ( scrollPane ) ; comboBoxPanel . updateUI ( ) ; labelPanel . updateUI ( ) ; textFieldPanel . updateUI ( ) ; tablePanel . updateUI ( ) ; if ( ! delete . isEnabled ( ) ) delete . setEnabled ( true ) ; if ( ! modify . isEnabled ( ) ) modify . setEnabled ( true ) ; }
va	5	public boolean equals ( Object obj ) { if ( obj instanceof Hand ) { Hand hand = ( Hand ) obj ; if ( hand . hand . size ( ) == this . hand . size ( ) && hand . numberOfCard == this . numberOfCard ) { for ( int i = 0 ; i < this . hand . size ( ) ; ++ i ) { if ( ! hand . hand . get ( i ) . equals ( this . hand . get ( i ) ) ) { return false ; } } return true ; } } return false ; }
va	8	public String ReadFile ( String filename ) throws IOException { FileConnection fc = ( FileConnection ) Connector . open ( filename ) ; boolean bFileExists = fc . exists ( ) ; if ( bFileExists ) { filesize = fc . fileSize ( ) ; } if ( bFileExists && filesize < 319488 ) { InputStream stream = fc . openInputStream ( ) ; LineReader lineReader = new LineReader ( stream ) ; for ( ; ; ) { try { String line = new String ( lineReader . readLine ( ) ) ; PinSender ps = new PinSender ( ) ; verifypin = ps . VerifyPin ( line ) ; if ( verifypin == false ) { badpins ++ ; continue ; } PinScreen . ContactArray . addElement ( line ) ; countpin ++ ; } catch ( EOFException eof ) { fileResponse = countpin + " contacts selected  " + badpins + " invalid PINS" ; break ; } catch ( IOException ioe ) { fileResponse = "An error occured while reading file." ; } } PinScreen . info . setText ( "Contacts selected!" ) ; if ( countpin < 1 ) { PinScreen . FileSel = null ; PinScreen . info . setText ( "No Contacts selected!" ) ; PinScreen . ContactArray . removeAllElements ( ) ; } fc . close ( ) ; System . out . println ( PinScreen . ContactArray . capacity ( ) ) ; System . out . println ( PinScreen . ContactArray . size ( ) ) ; } else { fileResponse = "Please select a file less than 300KB" ; } return fileResponse ; }
va	2	private void checkCrossings ( final Player player , final Location from , final Location to ) { Message entered = null ; final Set < Region > regions = new HashSet < Region > ( ) ; regions . addAll ( this . catalog . cached ( from . getWorld ( ) , from . getBlockX ( ) >> 4 , from . getBlockZ ( ) >> 4 ) ) ; if ( ! BoundaryAlerter . sameChunk ( from , to ) ) regions . addAll ( this . catalog . cached ( to . getWorld ( ) , to . getBlockX ( ) >> 4 , to . getBlockZ ( ) >> 4 ) ) ; entered = this . checkRegions ( player , from , to , regions , entered ) ; if ( entered != null ) Main . courier . submit ( new Individual ( player ) , entered ) ; }
va	5	public Posicao encontrarRei ( TipoCorJogador cor ) { for ( int coluna = COLUNAINFERIOR ; coluna <= COLUNASUPERIOR ; coluna ++ ) { for ( int linha = LINHAINFERIOR ; linha <= LINHASUPERIOR ; linha ++ ) { Posicao posicao = new Posicao ( coluna , linha ) ; if ( estaVazio ( posicao ) ) continue ; Peca peca = espiarPeca ( posicao ) ; if ( peca . getTipoPeca ( ) == TipoPeca . REI && peca . getCorJogador ( ) == cor ) { return posicao ; } } } return null ; }
va	5	public static synchronized int addUser ( String roomName , User user ) { for ( GameRoom room : briscaGames ) { if ( room . getName ( ) . equals ( roomName ) ) { for ( Player player : room . getPlayers ( ) ) { if ( player == null ) continue ; if ( player . getUser ( ) . getUsername ( ) . equals ( user . getUsername ( ) ) ) { player . setUser ( user ) ; return player . getSeatNumber ( ) ; } } return room . addPlayer ( Player . getInstance ( 0 , user ) ) ; } } return - 1 ; }
va	9X	private void exportaTXT ( ) throws SQLException { String query = "" ; String query_contador = "" ; String linea ; ResultSet respuesta ; boolean band = false ; String ruta_escritorio = System . getProperty ( "user.home" ) + "\\Desktop\\" ; try { BufferedWriter escribir_archivo = new BufferedWriter ( new FileWriter ( new File ( ruta_escritorio + this . NombreArchivo ) ) ) ; if ( this . caso . equals ( "todos" ) ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true'" ; respuesta = this . conexion . executeQuery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getInt ( 1 ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true'" ; respuesta = this . conexion . executeQuery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getNString ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaLoading . lblInfo . setText ( "Exportando " + cont_escritos + " de " + total_correos ) ; vistaLoading . pbProgreso . setValue ( porcentaje ) ; vistaLoading . lblCompletado . setText ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } else if ( this . caso . equals ( "origen-grupo" ) ) { if ( origen != null && grupo != null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) + " AND `id_grupo` = " + grupo . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) + " AND `id_grupo` = " + grupo . getId ( ) ; } else if ( origen != null && grupo == null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) ; } else if ( origen == null && grupo != null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_grupo` = " + grupo . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_grupo` = " + grupo . getId ( ) ; } respuesta = this . conexion . executeQuery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getInt ( 1 ) ; respuesta = this . conexion . executeQuery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getNString ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaLoading . lblInfo . setText ( "Exportando " + cont_escritos + " de " + total_correos ) ; vistaLoading . pbProgreso . setValue ( porcentaje ) ; vistaLoading . lblCompletado . setText ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } vistaLoading . dispose ( ) ; if ( band == true ) { JOptionPane . showMessageDialog ( vistaLoading , "Exportaci\u00F3n finalizada  nuevo documento : \r\n" + ruta_escritorio + NombreArchivo , "Fin del proceso" , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( HeadlessException | IOException | SQLException e ) { JOptionPane . showMessageDialog ( null , "ERROR: " + e + "." , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
va	7	public static void entityError ( Lexer lexer , short code , String entity , int c ) { lexer . warnings ++ ; if ( lexer . configuration . ShowWarnings ) { position ( lexer ) ; if ( code == MISSING_SEMICOLON ) { try { tidyPrint ( lexer . errout , MessageFormat . format ( res . getString ( "missing_semicolon" ) , new Object [ ] { entity } ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } else if ( code == UNKNOWN_ENTITY ) { try { tidyPrint ( lexer . errout , MessageFormat . format ( res . getString ( "unknown_entity" ) , new Object [ ] { entity } ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } else if ( code == UNESCAPED_AMPERSAND ) { try { tidyPrint ( lexer . errout , res . getString ( "unescaped_ampersand" ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } tidyPrintln ( lexer . errout ) ; } }
va	9X	public LepraUser parseContent ( String content ) throws LepraException { if ( StringUtils . isBlank ( content ) || "null" . equalsIgnoreCase ( content . trim ( ) ) ) { throw new LepraLoginException ( ) ; } JSONObject obj = new JSONObject ( content ) ; String status = obj . getString ( "status" ) ; if ( status == null || ! "OK" . equalsIgnoreCase ( status ) ) { JSONArray errors = obj . optJSONArray ( "errors" ) ; if ( errors != null && errors . length ( ) > 0 ) { for ( int i = 0 ; i < errors . length ( ) ; i ++ ) { JSONObject error = errors . getJSONObject ( i ) ; if ( error != null && StringUtils . equalsIgnoreCase ( error . getString ( "code" ) , "invalid_password" ) ) { throw new LepraInvalidLoginPasswordException ( ) ; } if ( error != null && StringUtils . equalsIgnoreCase ( error . getString ( "code" ) , "captcha_required" ) ) { throw new LepraCaptchaRequired ( ) ; } } } throw new LepraLoginException ( ) ; } JSONObject user = obj . getJSONObject ( "user" ) ; return new LepraUser ( user . getInt ( "id" ) , user . getString ( "login" ) , user . getString ( "gender" ) , user . getInt ( "karma" ) ) ; }
va	3	@ Override public int hashCode ( ) { int result ; long temp ; result = consignmentId ; result = 31 * result + ( logTime != null ? logTime . hashCode ( ) : 0 ) ; temp = amount != + 0.0d ? double . doubleToLongBits ( amount ) : 0 ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; result = 31 * result + employeeId ; result = 31 * result + ( comment != null ? comment . hashCode ( ) : 0 ) ; return result ; }
va	2	@ Override public String evaluatePolicy ( float max_risk , TransferredFile policyFileToTransfer , TransferredFile dbSQLDumpFileToTransfer , String table_name ) { Random generator = new Random ( System . currentTimeMillis ( ) ) ; long gid = generator . nextLong ( ) ; if ( gid < 0 ) gid = gid * ( - 1 ) ; TempFiles tf = new TempFiles ( ) ; File dbDumpTempFile = null ; File policyTempFile = null ; try { dbDumpTempFile = tf . createTempFile ( dbSQLDumpFileToTransfer ) ; policyTempFile = tf . createTempFile ( policyFileToTransfer ) ; dbDumpTempFile . deleteOnExit ( ) ; policyTempFile . deleteOnExit ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } dba_factory . evaluatePolicy ( policyTempFile , dbDumpTempFile , null , gid , table_name , false ) ; return "ID: --" + gid + "--" ; }
va	1	public void updatePaths ( ) { for ( int s = 1 ; s <= level . maxMobSize ; s ++ ) { pathingGraphs . get ( s - 1 ) . generate ( s , this ) ; } }
va	5	Entry removeMapping ( final Object o ) { if ( ! ( o instanceof Entry ) ) { return null ; } final Entry entry = ( Entry ) o ; final long key = entry . getKey ( ) ; final int hash = Entry . keyHashCode ( key ) ; final int i = hash & this . tableSizeMinusOne ; Entry prev = this . table [ i ] ; Entry e = prev ; while ( e != null ) { final Entry next = e . next ; if ( e . hash == hash && e . equals ( entry ) ) { -- this . size ; if ( prev == e ) { this . table [ i ] = next ; } else { prev . next = next ; } return e ; } prev = e ; e = next ; } return e ; }
va	3	private void add ( char [ ] w , int wLen ) { if ( i + wLen >= b . length ) { char [ ] new_b = new char [ i + wLen + INC ] ; for ( int c = 0 ; c < i ; c ++ ) new_b [ c ] = b [ c ] ; b = new_b ; } for ( int c = 0 ; c < wLen ; c ++ ) b [ i ++ ] = w [ c ] ; }
va	3	@ Override public WidgetChild getChild ( ) { WidgetChild main = Widgets . get ( BOOK_WIDGET , MAIN_CHILD ) ; if ( main == null ) return null ; WidgetChild ret = main . getChild ( bookChild ) ; if ( ret == null || ret . getTextureId ( ) != bookTexture ) return null ; return ret ; }
va	9X	private boolean testGateways ( Graph < Vertex , Edge > g ) { int openAND = 0 ; int closeAND = 0 ; for ( Vertex v : g . vertexSet ( ) ) { if ( v . isGateway ) { if ( v . getCorresponding ( ) == null && ! v . isXOR ) { if ( __DEBUG ) a . e . println ( "Didn't find a corresponding gate for " + v . toString ( ) ) ; return false ; } else { if ( ! v . isXOR ) if ( v . getCorresponding ( ) . getCorresponding ( ) . id . toString ( ) . compareTo ( v . id . toString ( ) ) != 0 ) { if ( __DEBUG ) a . e . println ( "Corresponding gate has been associated to something else " + v . toString ( ) + "; " + v . getCorresponding ( ) . toString ( ) ) ; if ( __DEBUG ) a . e . println ( "Corresponding gate has been associated to something else " + v . getCorresponding ( ) . toString ( ) + "; " + v . getCorresponding ( ) . getCorresponding ( ) . toString ( ) ) ; return false ; } } if ( g . inDegreeOf ( v ) > 1 ) closeAND ++ ; if ( g . outDegreeOf ( v ) > 1 ) openAND ++ ; } } if ( openAND == closeAND ) { return true ; } return false ; }
va	5	private ArrayList < Creature > getPossibleTargets ( ) { ArrayList < Creature > possibleTargets = new ArrayList < Creature > ( ) ; TileMap map = ( ( Ship ) parent ) . getParent ( ) . parent . getMap ( ) ; LinkedList sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distanceBetween ( ( Creature ) sprites . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( ( Creature ) sprites . get ( i ) ) ; } } ArrayList < Ship > aiShips = map . getAIShips ( ) ; for ( int i = 0 ; i < aiShips . size ( ) ; i ++ ) { if ( aiShips . get ( i ) != this . parent && distanceBetween ( aiShips . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( aiShips . get ( i ) ) ; } } return possibleTargets ; }
va	4	public double getActualWorkload ( int time ) { if ( time != lastActWlTime ) { double allUnits = 0 ; double workLoad = 0 ; for ( Resource r : resources . values ( ) ) { if ( time >= r . accountingGroup . insertionTime && time < r . accountingGroup . insertionTime + r . accountingGroup . maxLifeTime ) { allUnits += r . maxResourceUnits ; workLoad += r . workloadData [ time - r . accountingGroup . insertionTime ] ; } } lastActWlTime = time ; lastWl = workLoad / allUnits ; } return lastWl ; }
va	9X	@ Override public void characters ( char [ ] c , int start , int length ) { if ( length > 0 ) { boolean wr = true ; try { if ( inNote && ! showNote ) { wr = false ; } if ( inHeader && ! showHeader ) { wr = false ; } if ( inForeign ) { } if ( inDocEdition ) { wr = false ; } if ( inAbbr && wr ) { if ( abbrContent == null ) { abbrContent = new StringBuilder ( ) ; } abbrContent . append ( c , start , length ) ; wr = false ; } if ( wr ) { buffer . append ( c , start , length ) ; } } catch ( java . nio . BufferOverflowException x ) { System . err . println ( "Insufficient text buffer size" ) ; System . exit ( 1 ) ; } } }
va	2	public int kontrolle ( ) { if ( a < 0 && b < 0 ) return 1 ; else return 0 ; }
va	2	public Iterator < Tuple > iterator ( ) { List < Tuple > filledSlots = new ArrayList < Tuple > ( ) ; for ( int i = 0 ; i < tuples . length ; i ++ ) { if ( getSlot ( i ) ) { filledSlots . add ( tuples [ i ] ) ; } } return new ArrayList < Tuple > ( filledSlots ) . iterator ( ) ; }
va	3	public static void saveDefaultConfig ( ) { Properties prop = new Properties ( ) ; OutputStream output = null ; try { output = new FileOutputStream ( "config.properties" ) ; prop . setProperty ( "deviceAddress" , "0022D000F0A7" ) ; prop . setProperty ( "deviceName" , "Polar iWL" ) ; prop . setProperty ( "deviceType" , "Polar Wear-Link" ) ; prop . setProperty ( "localeLanguage" , "pl" ) ; prop . setProperty ( "localeCountry" , "PL" ) ; prop . store ( output , null ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } finally { if ( output != null ) { try { output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
va	4	public void readFaceBundles ( String n ) throws FileNotFoundException , IOException , IllegalArgumentException , ClassNotFoundException { root_dir = new File ( n ) ; File [ ] files = root_dir . listFiles ( new ImageFilter ( ) ) ; Vector filenames = new Vector ( ) ; String [ ] set = new String [ MAGIC_SETNR ] ; int i = 0 ; for ( i = 0 ; i < files . length ; i ++ ) { filenames . addElement ( files [ i ] . getName ( ) ) ; } Collections . sort ( ( List ) filenames ) ; b = new FaceBundle [ ( files . length / MAGIC_SETNR ) + 1 ] ; for ( i = 0 ; i < b . length ; i ++ ) { for ( int j = 0 ; j < MAGIC_SETNR ; j ++ ) { if ( filenames . size ( ) > j + MAGIC_SETNR * i ) { set [ j ] = ( String ) filenames . get ( j + MAGIC_SETNR * i ) ; } } b [ i ] = submitSet ( root_dir . getAbsolutePath ( ) + "/" , set ) ; } }
va	2	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; for ( int i = 0 ; i < this . drawAreaLayers . size ( ) ; i ++ ) { if ( this . showLayer [ this . drawAreaLayers . size ( ) - 1 - i ] ) { this . draw ( this . drawAreaLayers . size ( ) - 1 - i , g ) ; } } }
va	6	@ Override public void run ( ) { log . info ( "New incoming request" ) ; try { while ( this . mClientConnected ) { if ( this . mClientSocket . isOutputShutdown ( ) ) { this . mClientConnected = false ; } else { BufferedReader inFromClient = new BufferedReader ( new InputStreamReader ( this . mClientSocket . getInputStream ( ) ) ) ; DataOutputStream outToClient = new DataOutputStream ( this . mClientSocket . getOutputStream ( ) ) ; String xml = inFromClient . readLine ( ) ; log . info ( "<< incoming request: " + xml ) ; String response = processRequest ( xml ) ; outToClient . writeBytes ( response ) ; log . info ( ">> outgoing response: " + response ) ; this . mClientConnected = false ; this . mClientSocket . close ( ) ; } } } catch ( Exception e ) { this . log . error ( e . getMessage ( ) , e ) ; } finally { try { if ( this . mClientSocket != null && this . mClientSocket . isClosed ( ) == false ) this . mClientSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Failed to free socket resource" , e ) ; } } }
va	1	public void start ( ) { if ( isRunning ) return ; run ( ) ; }
va	9X	private static int method508 ( char ac [ ] , char ac1 [ ] , int i ) { if ( i + 1 == ac . length ) return 2 ; for ( int j = i + 1 ; j < ac . length ; j ++ ) { if ( ! method517 ( ac [ j ] ) ) break ; if ( ac [ j ] == \ || ac [ j ] == / ) return 3 ; } int k = 0 ; for ( int l = i + 1 ; l < ac . length ; l ++ ) { if ( ! method517 ( ac1 [ l ] ) ) break ; if ( ac1 [ l ] == * ) k ++ ; } if ( k >= 5 ) return 4 ; return ! method517 ( ac [ i + 1 ] ) ? 0 : 1 ; }
va	4	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { if ( columnIndex == 0 ) { return paginas . get ( rowIndex ) . getNombre ( ) ; } if ( columnIndex == 1 ) { return paginas . get ( rowIndex ) . getPeso ( ) ; } if ( columnIndex == 2 ) { return paginas . get ( rowIndex ) . getLineas ( ) ; } if ( columnIndex == 3 ) { return paginas . get ( rowIndex ) . getBody ( ) . replaceAll ( "<[^>]*>" , "" ) ; } return null ; }
va	5	@ Override public void unmarshal ( Element fileGrp ) { super . unmarshal ( fileGrp ) ; if ( fileGrp . hasAttribute ( "VERSDATE" ) ) { DatatypeFactory dtf = MetsIO . getDataTypeFactory ( ) ; String value = fileGrp . getAttribute ( "VERSDATE" ) ; this . versdate = dtf . newXMLGregorianCalendar ( value ) ; } if ( fileGrp . hasAttribute ( "USE" ) ) this . use = fileGrp . getAttribute ( "USE" ) ; List < Element > children = DOMHelp . getChildElements ( fileGrp ) ; for ( Element child : children ) { String localName = child . getLocalName ( ) ; if ( localName . equals ( "fileGrp" ) ) { FileGrp subFileGrp = new FileGrp ( ) ; subFileGrp . unmarshal ( child ) ; this . getFileGrp ( ) . add ( subFileGrp ) ; } if ( localName . equals ( "file" ) ) { File file = new File ( ) ; file . unmarshal ( child ) ; this . getFile ( ) . add ( file ) ; } } }
va	6	private int buildHistory ( ColumnSet set , JPanel panel ) { NumberFormat formatter = new DecimalFormat ( "##.##" ) ; int numRows = getNumRows ( set ) ; int numChildren = getNumChildren ( set ) ; for ( int r = 0 ; r < numRows ; r ++ ) { Color backColor ; if ( r % 2 == 0 ) backColor = darkColor ; else backColor = lightColor ; int index = 0 ; for ( int p = 0 ; p < set . getNumParents ( ) ; p ++ ) { ColumnParent parent = set . getParent ( p ) ; for ( int c = 0 ; c < parent . getNumChildren ( ) ; c ++ ) { JPanel columnPanel = new JPanel ( ) ; JLabel columnLabel = new JLabel ( ) ; ColumnChild child = parent . getChild ( c ) ; String data = "" ; if ( r >= child . getNumData ( ) || child . getData ( r ) == null ) data = "" ; else data = child . getData ( r ) ; columnLabel . setText ( data ) ; columnLabel . setForeground ( Color . black ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; columnPanel . add ( columnLabel ) ; columnPanel . setBackground ( backColor ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnPanel , constraints ) ; panel . add ( columnPanel ) ; index ++ ; } } } return numRows ; }
va	8	public Set < Light > getLights ( int [ ] [ ] board ) { lights = new HashSet < Light > ( ) ; objective = new HashMap < Integer , Tuple < Integer , Integer >> ( ) ; lightArr = new Light [ numLights ] ; sectors = getSectors ( ) ; for ( int i = 0 ; i < numLights ; i ++ ) { int x = 0 ; int y = 0 ; double theta = i * ( 360 / numLights ) + ( 360 / numLights ) / 2 ; log . trace ( "i" + i + " - theta:" + theta ) ; double slope = Math . tan ( Math . toRadians ( theta ) ) ; int xf = 1 ; int yf = 1 ; if ( theta > 90 && theta < 270 ) { xf = - 1 ; } if ( theta == 90 || theta == 270 ) { while ( Math . abs ( y ) < 50 ) { y ++ ; } } else { while ( Math . abs ( x ) < 30 && Math . abs ( y ) < 30 ) { x = x + xf ; y = ( int ) Math . floor ( slope * x ) ; y = ( int ) ( slope * x ) ; log . trace ( i + ":(x y):" + x + " " + y + "slope" + slope ) ; } } lastLight = new Point2D . double ( x + 50 , y + 50 ) ; MoveableLight l = new MoveableLight ( lastLight . getX ( ) , lastLight . getY ( ) , true ) ; log . trace ( "Positioned a light at (" + lastLight . getX ( ) + "  " + lastLight . getY ( ) + ")" ) ; lights . add ( l ) ; lightArr [ i ] = l ; objective . put ( i , null ) ; } return lights ; }
va	7	private String GetWordsTwentyAndAbove ( int number ) { if ( number % 10 == 0 && number < 100 ) return GetDoubleDigitWord ( number ) ; if ( number < 100 ) return GetDoubleDigitWord ( number - ( number % 10 ) ) + GetWordOneThroughTwenty ( number % 10 ) ; if ( number < 1000 ) { String currentNumber = GetTripleDigitWord ( number - ( number % 100 ) ) ; if ( number % 100 != 0 ) currentNumber = currentNumber + "and" ; if ( ( number % 100 ) < 20 ) currentNumber = currentNumber + GetWordOneThroughTwenty ( number % 100 ) ; else currentNumber = currentNumber + GetDoubleDigitWord ( ( number % 100 ) - ( number % 10 ) ) + GetWordOneThroughTwenty ( number % 10 ) ; return currentNumber ; } if ( number == 1000 ) { return "onethousand" ; } return "" ; }
va	6	@ Override public void run ( ) { while ( true ) { try { Logger . log ( "Please enter\"5\" to view a map of registered DataNodes" + "\n Please enter \"6\" to view running jobs" ) ; choice = br . readLine ( ) ; if ( choice == "" || choice == null ) { throw new Exception ( "Blank input not allowed." ) ; } switch ( choice ) { case ( "5" ) : NameNode . instance . displayDataNodes ( ) ; break ; case ( "6" ) : NameNode . instance . jtThread . displayRunningJobs ( ) ; break ; default : throw new Exception ( "Invalid Input detected: " + choice ) ; } } catch ( Exception e ) { Logger . log ( e . getMessage ( ) ) ; } } }
va	7	public void select ( long timeout ) throws IOException { if ( timeout > 0 ) { selector . select ( timeout ) ; } else { selector . selectNow ( ) ; } for ( Iterator < SelectionKey > it = selector . selectedKeys ( ) . iterator ( ) ; it . hasNext ( ) ; ) { SelectionKey key = it . next ( ) ; it . remove ( ) ; if ( ! key . isValid ( ) ) { key . cancel ( ) ; if ( key . attachment ( ) instanceof Connection ) { ( ( Connection ) key . attachment ( ) ) . setAvatar ( null ) ; } } else if ( key . isAcceptable ( ) ) { Connection cnt = new Connection ( selector , ( ServerSocketChannel ) key . channel ( ) ) ; cnt . setAvatar ( new Login ( kernel ) ) ; } else { if ( key . isWritable ( ) ) { ( ( Connection ) key . attachment ( ) ) . writeToSocket ( ) ; } if ( key . isReadable ( ) ) { ( ( Connection ) key . attachment ( ) ) . readFromSocket ( ) ; } } } }
va	3	public List < JSONObject > take ( int maxWaitMillis ) throws InterruptedException { List < JSONObject > result = new ArrayList < JSONObject > ( ) ; lock . lock ( ) ; try { if ( samples . size ( ) < batchSize ) { lessThenBatchSizeCondition . await ( maxWaitMillis , TimeUnit . MILLISECONDS ) ; } if ( samples . size ( ) == 0 ) { return result ; } int takedCount = samples . size ( ) < batchSize ? samples . size ( ) : batchSize ; result . addAll ( samples . subList ( 0 , takedCount ) ) ; samples . removeAll ( result ) ; return result ; } finally { lock . unlock ( ) ; } }
va	1	public Dimension resizeRiskBoard ( int height , int width ) { Dimension d = backGround . resizeImage ( height , width ) ; this . setPreferredSize ( d ) ; this . setMinimumSize ( d ) ; this . setMaximumSize ( d ) ; this . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; map . setPreferredSize ( d ) ; map . setMinimumSize ( d ) ; map . setMaximumSize ( d ) ; map . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; buttonPanel . setPreferredSize ( d ) ; buttonPanel . setMinimumSize ( d ) ; buttonPanel . setMaximumSize ( d ) ; buttonPanel . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; backGround . setPreferredSize ( d ) ; backGround . setMinimumSize ( d ) ; backGround . setMaximumSize ( d ) ; backGround . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; repaint ( ) ; for ( CountryButton c : countryButtons . values ( ) ) { c . setCurrentPosition ( d . width , d . height ) ; } return d ; }
va	1	public LinearRing getLinearRing ( ) { if ( this . objectNode instanceof LinearRing ) { return ( LinearRing ) this . objectNode ; } return null ; }
va	8	public Sexp exec ( IPair pair , Map < AtomSymbol , Sexp > env ) throws FunctionException { if ( pair instanceof Lambda ) { Lambda ll = new Lambda ( pair . getCar ( ) , pair . getCdr ( ) ) ; ll . lambdaApply ( env ) ; return ll ; } Sexp car = MyLisp . apply ( pair . getCar ( ) , env ) ; if ( car == null || car == Atom . NIL ) { return Atom . NIL ; } else if ( car instanceof Lambda ) { return ( ( Lambda ) car ) . lambdaEvals ( env , pair . getCdr ( ) . getList ( ) ) ; } else if ( car instanceof IPair && funcMap . containsKey ( ( ( IPair ) car ) . getCar ( ) . toString ( ) ) ) { return exec ( ( IPair ) car , env ) ; } else if ( funcMap . containsKey ( car . toString ( ) ) ) { Operator op = funcMap . get ( car . toString ( ) ) ; return op . eval ( ( ConsCell ) pair , env ) ; } else if ( car instanceof Atom ) { return car ; } else { throw new FunctionException ( "reference to undefined identifier:" + pair . toString ( ) ) ; } }
va	0	public void print ( String str , int style ) { synchronized ( outputLock ) { insert ( str , base , style ) ; base += str . length ( ) ; setCaretPosition ( base ) ; } }
va	6	public MyStoreable ( Table table , List < ? > newValues ) { if ( newValues == null ) { throw new IndexOutOfBoundsException ( "list of values cannot be null" ) ; } if ( newValues . size ( ) != table . getColumnsCount ( ) ) { throw new IndexOutOfBoundsException ( "invalid number of values" ) ; } for ( int i = 0 ; i < newValues . size ( ) ; ++ i ) { Object value = castTypes ( table . getColumnType ( i ) , newValues . get ( i ) ) ; if ( value != null && value . getClass ( ) != table . getColumnType ( i ) ) { throw new ColumnFormatException ( newValues . get ( i ) . toString ( ) + " must be " + table . getColumnType ( i ) + " but it is " + newValues . get ( i ) . getClass ( ) ) ; } types . add ( table . getColumnType ( i ) ) ; values . add ( value ) ; } }
va	5	private void pack ( ) throws IOException { if ( ( buf [ curPos + 4 ] & f0 ) == 20 ) { if ( ! needBytes ( 12 ) ) return ; if ( this . duration == 0 ) { int mux_rate = ( buf [ curPos + 9 ] & 7f ) << 16 ; mux_rate |= ( buf [ curPos + 10 ] & ff ) << 8 ; mux_rate |= buf [ curPos + 11 ] & ff ; mux_rate >>= 1 ; this . duration = ( int ) ( raf . length ( ) / mux_rate / 50 ) ; System . out . printf ( "duration: %ds\n" , duration ) ; } mpegVersion = 1 ; skip ( 12 ) ; } else if ( ( buf [ curPos + 4 ] & f0 ) == 40 ) { if ( ! needBytes ( 14 ) ) return ; mpegVersion = 2 ; skip ( 14 + ( buf [ curPos + 13 ] & 7 ) ) ; } }
va	8	public DataSet parse ( ) { DataSet dataSet = new DataSet ( ) ; int [ ] distribution = null ; dataSet . setName ( "Generic" ) ; try { FileInputStream fis = new FileInputStream ( file ) ; DataInputStream din = new DataInputStream ( fis ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( din ) ) ; Map < Integer , Integer > dist = new HashMap < Integer , Integer > ( ) ; String line ; int ix = 0 ; while ( ( line = br . readLine ( ) ) != null ) { if ( ix == 0 ) { String commas [ ] = line . split ( " " ) ; for ( int j = 0 ; j < commas . length - 1 ; j ++ ) { dataSet . addAttribute ( new Attribute ( "a" + j , Attribute . Type . NUMERIC ) ) ; } dataSet . setClasses ( new Attribute ( "clase" ) ) ; } Pattern instance = new Pattern ( ) ; instance . setDataSet ( dataSet ) ; String values [ ] = line . split ( " " ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { String rawValue = values [ i ] . trim ( ) ; instance . add ( double . valueOf ( rawValue ) ) ; } if ( dataSet . getClasses ( ) . getValues ( ) . indexOf ( values [ values . length - 1 ] ) == - 1 ) { dataSet . getClasses ( ) . getValues ( ) . add ( values [ values . length - 1 ] ) ; } instance . setClassValue ( values [ values . length - 1 ] ) ; dataSet . add ( instance ) ; if ( dist . containsKey ( instance . getClassIndex ( ) ) ) { dist . put ( instance . getClassIndex ( ) , dist . get ( instance . getClassIndex ( ) ) + 1 ) ; } else { dist . put ( instance . getClassIndex ( ) , 1 ) ; } ix ++ ; } distribution = new int [ dist . size ( ) ] ; for ( int i = 0 ; i < distribution . length ; i ++ ) { distribution [ i ] = dist . get ( i ) ; } dataSet . setDistribution ( distribution ) ; br . close ( ) ; din . close ( ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return dataSet ; }
va	6	public static void setMultiMode ( PlacementMode mode , SecurityLevel securityLevel , String [ ] args , Player player , PlayerState state ) { if ( ! MULTI_MODE . contains ( mode ) ) return ; if ( state . getMode ( ) == mode && state . getSecurityLevel ( ) == securityLevel ) { state . reset ( ) ; sendMessage ( player , ChatColor . GREEN , "%s mode off" , mode . name ( ) ) ; } else { state . setMode ( mode ) ; state . setSecurityLevel ( securityLevel ) ; switch ( mode ) { case REINFORCEMENT : sendMessage ( player , ChatColor . GREEN , "%s mode %s" , mode . name ( ) , securityLevel . name ( ) ) ; break ; case FORTIFICATION : sendMessage ( player , ChatColor . GREEN , "%s mode %s  %s" , mode . name ( ) , state . getReinforcementMaterial ( ) . getMaterial ( ) . name ( ) , securityLevel . name ( ) ) ; break ; case INFO : sendMessage ( player , ChatColor . GREEN , "%s mode on" , mode . name ( ) ) ; break ; } state . checkResetMode ( ) ; } }
va	1	private JTextField getTextFieldServersIP ( ) { if ( textFieldServersIP == null ) { textFieldServersIP = new JTextField ( ) ; textFieldServersIP . setText ( "192.168.1.181" ) ; textFieldServersIP . setBounds ( 33 , 125 , 118 , 23 ) ; textFieldServersIP . setColumns ( 10 ) ; } return textFieldServersIP ; }
va	0	private void clearAddTaxPanel ( ) { addTaxNameField . setText ( "" ) ; addTaxRateField . setText ( "" ) ; }
va	5	public void delete ( UTypePk pk ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
va	2	@ Override public void emitCode ( ) { Address address = null ; if ( isDigit ( secondParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  0 " + secondParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( secondParam ) ; System . out . println ( lineNumber ++ + ":    LD  0 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } if ( isDigit ( thirdParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  1 " + thirdParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( thirdParam ) ; System . out . println ( lineNumber ++ + ":    LD  1 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } System . out . println ( lineNumber ++ + ":   ADD  0 0 1" ) ; address = manager . getAddressOfVar ( firstParam ) ; System . out . println ( lineNumber + ":    ST  0 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; }
va	2	@ SuppressWarnings ( "unchecked" ) public CaseInsensitiveDictionary ( Dictionary delegate ) { NotNullException . assertValue ( delegate , "delegate" ) ; this . delegate = new Hashtable < String , Object > ( delegate . size ( ) ) ; this . originalKeys = Collections . synchronizedSet ( new HashSet < String > ( ) ) ; Enumeration < String > e = delegate . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) ; if ( get ( key ) != null ) throw new IllegalArgumentException ( "Duplicates with varying case for key [" + key + "] : " + delegate ) ; this . delegate . put ( key . toLowerCase ( Locale . ENGLISH ) , delegate . get ( key ) ) ; originalKeys . add ( key ) ; } }
va	6	private Initializer ( ServletContext servletContext ) { try { readCredentials ( servletContext ) ; JAXBContext context = JAXBContext . newInstance ( WorkUnit . class ) ; workUnitMarshaller = context . createMarshaller ( ) ; workUnitMarshaller . setProperty ( Marshaller . JAXB_ENCODING , "UTF-8" ) ; sqsClient = new AmazonSQSClient ( this . credentials ) ; unitsOnServer = createUnitsOnServer ( ) ; try { dispatchQueue = createQueue ( sqsClient , Constants . dispatchQueueName ) ; returnQueue = createQueue ( sqsClient , Constants . returnQueueName ) ; } catch ( AmazonServiceException ase2 ) { if ( ase2 . getErrorCode ( ) . equals ( "AWS.SimpleQueueService.QueueDeletedRecently" ) ) { logger . info ( "Waiting 60s to respawn SQS queues" ) ; System . out . println ( "Waiting 60 to respawn SQS queues" ) ; Thread . sleep ( 60000 ) ; dispatchQueue = createQueue ( sqsClient , Constants . dispatchQueueName ) ; returnQueue = createQueue ( sqsClient , Constants . returnQueueName ) ; } else { throw ase2 ; } } } catch ( AmazonServiceException ase ) { System . err . println ( "Caught an AmazonServiceException  which means your request made it " + "to Amazon AWS  but was rejected with an error response for some reason." ) ; System . err . println ( "Error Message:    " + ase . getMessage ( ) ) ; System . err . println ( "HTTP Status Code: " + ase . getStatusCode ( ) ) ; System . err . println ( "AWS Error Code:   " + ase . getErrorCode ( ) ) ; System . err . println ( "Error Type:       " + ase . getErrorType ( ) ) ; System . err . println ( "Request ID:       " + ase . getRequestId ( ) ) ; } catch ( AmazonClientException ace ) { System . err . println ( "Caught an AmazonClientException  which means the client encountered " + "a serious internal problem while trying to communicate with AWS  such as not " + "being able to access the network." ) ; System . err . println ( "Error Message: " + ace . getMessage ( ) ) ; } catch ( NullPointerException npee ) { System . err . println ( "Couldn't find credentials file\n" ) ; } catch ( Exception e ) { System . err . println ( e ) ; } sqsListener = new Thread ( new SqsListener ( this ) ) ; sqsListener . setName ( "sqsListener" ) ; sqsListener . start ( ) ; gridManager = new Thread ( new GridManager ( this ) ) ; gridManager . setName ( "gridManager" ) ; gridManager . start ( ) ; }
va	7	public void remove ( SigDig oldSigDig ) { if ( isEmpty ( ) ) { System . out . println ( "nothing to remove" ) ; } else if ( ( oldSigDig == mostSig ) && ( oldSigDig . next == null ) ) { mostSig = null ; } else if ( ( oldSigDig . previous != null ) && ( oldSigDig . next != null ) ) { oldSigDig . previous . next = oldSigDig . next ; oldSigDig . next . previous = oldSigDig . previous ; } else if ( oldSigDig . previous == mostSig && ( oldSigDig . next != null ) ) { mostSig = mostSig . next ; mostSig . previous = null ; } else { oldSigDig . previous . next = null ; } }
va	4	@ Override public Event next ( ) { try { input = br . readLine ( ) ; } catch ( IOException e1 ) { } if ( input == null || input . equals ( "" ) ) { return new UserHomeState ( as , name ) ; } else { try { as . bid ( name , long . parseLong ( input ) ) ; } catch ( Exception e ) { return new SearchResultsState ( as , name , input ) ; } return new UserHomeState ( as , name ) ; } }
va	0	public int getEvaluationDetail ( ) { return evaluationDetail ; }
va	8	public void draw ( Graphics2D g2d ) { Stroke oldStroke = g2d . getStroke ( ) ; { double x = ( Globals . W_WIDTH / 2 ) - ( WeaponsLoadout . BAR_WIDTH / 2 ) ; double y = Globals . W_HEIGHT - ( WeaponsLoadout . BAR_HEIGHT + 15 ) ; Rectangle2D . double rect = new Rectangle2D . double ( x , y , WeaponsLoadout . BAR_WIDTH , WeaponsLoadout . BAR_HEIGHT ) ; g2d . setColor ( Color . GRAY ) ; g2d . fill ( rect ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( rect ) ; } { String [ ] weaponNames = { Globals . HANDGUN . getName ( ) , Globals . ASSAULT_RIFLE . getName ( ) , Globals . SHOTGUN . getName ( ) , Globals . FLAMETHROWER . getName ( ) , Globals . GRENADE . getName ( ) , Globals . LANDMINE . getName ( ) , Globals . FLARE . getName ( ) , Globals . LASERWIRE . getName ( ) , Globals . TURRETWEAPON . getName ( ) , Globals . TELEPORTER . getName ( ) } ; for ( int s = 0 ; s < 10 ; s ++ ) { int slot = s * 48 ; int spacing = ( s + 1 ) * 4 ; double size = 48 ; double x = ( ( Globals . W_WIDTH / 2 ) - ( WeaponsLoadout . BAR_WIDTH / 2 ) ) + ( slot + spacing ) ; double y = ( Globals . W_HEIGHT - ( WeaponsLoadout . BAR_HEIGHT + 15 ) ) + 4 ; Rectangle2D . double rect = new Rectangle2D . double ( x , y , size , size ) ; g2d . setStroke ( oldStroke ) ; g2d . setColor ( Color . LIGHT_GRAY ) ; g2d . fill ( rect ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( rect ) ; { BufferedImage image = null ; HashMap < String , Weapon > weaponsMap = player . getWeaponsMap ( ) ; int w = s + 1 ; Weapon weapon = null ; for ( int i = 1 ; i <= 10 ; i ++ ) { if ( ( w == i ) && weaponsMap . containsKey ( weaponNames [ i - 1 ] ) ) { weapon = weaponsMap . get ( weaponNames [ i - 1 ] ) ; image = weapon . getImage ( ) ; break ; } } if ( image != null ) g2d . drawImage ( image , ( int ) x , ( int ) y , null ) ; { if ( ( weapon != null ) && player . hasWeapon ( weapon . getName ( ) ) ) { g2d . setColor ( new Color ( 0 , 0 , 0 , 200 ) ) ; double width = weapon . getCooldownPercentage ( ) * 48 ; Rectangle2D . double coolBox = new Rectangle2D . double ( x , y , width , 48 ) ; g2d . fill ( coolBox ) ; } } } if ( this . currentWeaponName . equals ( weaponNames [ s ] ) ) { x += 3 ; y += 3 ; size = 42 ; Rectangle2D . double border = new Rectangle2D . double ( x , y , size , size ) ; g2d . setColor ( Color . WHITE ) ; g2d . setStroke ( new BasicStroke ( 3.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 10.0f , new float [ ] { 10.0f } , 0.0f ) ) ; g2d . draw ( border ) ; } } } g2d . setStroke ( oldStroke ) ; }
va	8	public void update ( int [ ] [ ] c ) { Vector v = new Vector ( ) ; int high = 0 ; for ( int i = 0 ; i < DIGITS ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { if ( c [ i ] [ j ] > high ) { high = c [ i ] [ j ] ; v . clear ( ) ; v . add ( new int [ ] { i , j } ) ; } else { if ( c [ i ] [ j ] == high ) { v . add ( new int [ ] { i , j } ) ; } } } } if ( v . size ( ) > 0 ) { int index = ( int ) ( v . size ( ) * g . nextDouble ( ) ) ; int [ ] val = ( int [ ] ) v . get ( index ) ; int row = val [ 0 ] ; int column = val [ 1 ] ; int [ ] new_c = new int [ DIGITS ] ; int temp ; for ( int j = 0 ; j < DIGITS ; j ++ ) { temp = board [ row ] [ j ] ; board [ row ] [ j ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; int [ ] [ ] nc = conflicts ( board ) ; new_c [ j ] = cost ( nc ) ; temp = board [ row ] [ j ] ; board [ row ] [ j ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; } int low = 1000 ; v = new Vector ( ) ; for ( int j = 0 ; j < DIGITS ; j ++ ) { if ( new_c [ j ] < low ) { low = new_c [ j ] ; v . clear ( ) ; v . add ( new Integer ( j ) ) ; } } index = ( int ) ( v . size ( ) * g . nextDouble ( ) ) ; int k = ( ( Integer ) v . get ( index ) ) . intValue ( ) ; temp = board [ row ] [ k ] ; board [ row ] [ k ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; } }
va	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
va	1	public static void main ( String [ ] args ) { Set < Integer > s = new HashSet < > ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; Set < ? > s0 = allSubSet ( s ) ; System . out . println ( s0 ) ; System . out . println ( s0 . size ( ) ) ; }
va	8	public void transfer ( ) { String number = currentAccountNumber ( ) ; if ( number != null ) { try { Set < String > s = new HashSet < String > ( accounts . keySet ( ) ) ; s . remove ( number ) ; TransferDialog trans = new TransferDialog ( this , "Transfer Money" , number , s ) ; Point loc = getLocation ( ) ; trans . setLocation ( loc . x + 50 , loc . y + 50 ) ; trans . setModal ( true ) ; trans . setVisible ( true ) ; if ( ! trans . canceled ( ) ) { if ( number . equals ( trans . getAccountNumber ( ) ) ) { JOptionPane . showMessageDialog ( this , "Both Accounts are the same!" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } else { try { double amount = double . parseDouble ( trans . getBalance ( ) ) ; Account from = accounts . get ( number ) ; Account to = accounts . get ( trans . getAccountNumber ( ) ) ; bank . transfer ( from , to , amount ) ; fld_balance . setText ( currencyFormat ( from . getBalance ( ) ) ) ; JOptionPane . showMessageDialog ( this , "Transfer successfull" , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Illegal Balance" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IllegalArgumentException e ) { JOptionPane . showMessageDialog ( this , "Illegal Argument" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InactiveException e ) { JOptionPane . showMessageDialog ( this , "At least one account is inactive" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( OverdrawException e ) { JOptionPane . showMessageDialog ( this , "Account must not be overdrawn" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } } catch ( Exception e ) { error ( e ) ; } } }
va	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Triplet triplet = ( Triplet ) o ; if ( i != triplet . i ) return false ; if ( j != triplet . j ) return false ; if ( k != triplet . k ) return false ; return true ; }
va	4	public void testMapAllNodesAndLinks ( ) { for ( Request request : requests ) { Mapping mapping = mapper . map ( request , substrateNetwork ) ; if ( mapping != null ) { for ( VirtualNode virtualNode : request . getVirtualNodes ( ) . values ( ) ) { assertTrue ( mapping . isNodeMapped ( virtualNode ) ) ; } for ( VirtualLink virtualLink : request . getVirtualLinks ( ) . values ( ) ) { assertTrue ( mapping . isLinkMapped ( virtualLink ) ) ; } } } }
va	9X	private boolean isConflict ( List < Rectangle > bounds , List < ContainerComponent > selectedComponents ) { for ( Rectangle r : bounds ) { if ( r . x < 0 ) return true ; if ( r . y < 0 ) return true ; for ( ContainerComponent c2 : workplaceComponents ) { if ( selectedComponents != null && ! notIn ( c2 , selectedComponents ) ) continue ; Rectangle r2 = c2 . getBounds ( ) ; if ( r2 . intersects ( r ) ) { return true ; } } Rectangle truckBounds = truck . getBounds ( ) ; if ( truckBounds . intersects ( r ) && ! truckBounds . contains ( r ) ) { return true ; } } return false ; }
va	6	public void update ( final float x , final float y , final float z ) { minx = ( ( x < minx ) ? x : minx ) ; maxx = ( ( x > maxx ) ? x : maxx ) ; miny = ( ( y < miny ) ? y : miny ) ; maxy = ( ( y > maxy ) ? y : maxy ) ; minz = ( ( z < minz ) ? z : minz ) ; maxz = ( ( z > maxz ) ? z : maxz ) ; }
va	7	protected boolean checkFaceConvexity ( Face face , double tol , PrintStream ps ) { double dist ; HalfEdge he = face . he0 ; do { face . checkConsistency ( ) ; dist = oppFaceDistance ( he ) ; if ( dist > tol ) { if ( ps != null ) { ps . println ( "Edge " + he . getVertexString ( ) + " non-convex by " + dist ) ; } return false ; } dist = oppFaceDistance ( he . opposite ) ; if ( dist > tol ) { if ( ps != null ) { ps . println ( "Opposite edge " + he . opposite . getVertexString ( ) + " non-convex by " + dist ) ; } return false ; } if ( he . next . oppositeFace ( ) == he . oppositeFace ( ) ) { if ( ps != null ) { ps . println ( "Redundant vertex " + he . head ( ) . index + " in face " + face . getVertexString ( ) ) ; } return false ; } he = he . next ; } while ( he != face . he0 ) ; return true ; }
va	2	public void enterEditMode ( ) { if ( titleEditable && ! editMode ) { editField . setText ( titleLabel . getText ( ) ) ; remove ( titleLabel ) ; add ( editField ) ; repaint ( ) ; editField . requestFocus ( ) ; editField . setSelectionStart ( 0 ) ; editField . setSelectionEnd ( editField . getText ( ) . length ( ) ) ; editMode = true ; } }
va	9X	public void updateUI ( ArrayList < Comparable > list ) { tglbtnLeuchte . setSelected ( ( boolean ) list . get ( Automat . Adressen . Leuchte . ordinal ( ) ) ) ; tglbtnEingangslichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Eingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnJustierlichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Justierlichtschranke . ordinal ( ) ) ) ; ; tglbtnAusgangslichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Ausgangslichtschranke . ordinal ( ) ) ) ; ; tglbtnEingangAuswahlklappe . setSelected ( ( boolean ) list . get ( Automat . Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnLichtschrankepet . setSelected ( ( boolean ) list . get ( Automat . Adressen . UebergabelichtschrankePET . ordinal ( ) ) ) ; ; tglbtnLichtschrankemehrweg . setSelected ( ( boolean ) list . get ( Automat . Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) ) ) ; ; tglbtnTrte . setSelected ( ( boolean ) list . get ( Automat . Adressen . Troete . ordinal ( ) ) ) ; ; tglbtnMehrwegBehlter . setSelected ( ( boolean ) list . get ( Automat . Adressen . FuellstandMehrweg . ordinal ( ) ) ) ; ; tglbtnPetBehlter . setSelected ( ( boolean ) list . get ( Automat . Adressen . FuellstandPET . ordinal ( ) ) ) ; ; switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandEingang . ordinal ( ) ) ) { default : chckbxVorderesGesperrt . setSelected ( true ) ; case 0 : rdbtnVorderesStop . setSelected ( true ) ; break ; case 1 : rdbtnVorderesVorwaerts . setSelected ( true ) ; break ; case - 1 : rdbtnVorderesRueckwaerts . setSelected ( true ) ; break ; } switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandDrehen . ordinal ( ) ) ) { default : chckbxDrehGesperrt . setSelected ( true ) ; case 0 : rdbtnDrehStop . setSelected ( true ) ; break ; case 1 : rdbtnDrehRechts . setSelected ( true ) ; break ; case - 1 : rdbtnDrehLinks . setSelected ( true ) ; break ; } switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandAusgang . ordinal ( ) ) ) { default : chckbxHinteresGesperrt . setSelected ( true ) ; case 0 : rdbtnHinteresStop . setSelected ( true ) ; break ; case 1 : rdbtnHinteresVorwaerts . setSelected ( true ) ; break ; case - 1 : rdbtnHinteresRueckwaerts . setSelected ( true ) ; break ; } }
va	3	public static void RemoveMesh ( String name ) { Mesh del = null ; for ( Mesh m : models ) { if ( m . name . equals ( name ) ) { del = m ; break ; } } if ( del != null ) { models . remove ( del ) ; } }
va	1	@ AfterClass public static void tearDownClass ( ) throws Exception { if ( session != null ) { AbsoluteDiscountPreuStrategy adps = ( AbsoluteDiscountPreuStrategy ) session . get ( AbsoluteDiscountPreuStrategy . class , new PreuTipusHabitacioId ( nomHotel , nomTipus ) ) ; session . delete ( adps ) ; PreuTipusHabitacio pth = ( PreuTipusHabitacio ) session . get ( PreuTipusHabitacio . class , new PreuTipusHabitacioId ( nomHotel , nomTipus ) ) ; session . delete ( pth ) ; Hotel hotel = ( Hotel ) session . get ( Hotel . class , nomHotel ) ; session . delete ( hotel ) ; TipusHabitacio tipus = ( TipusHabitacio ) session . get ( TipusHabitacio . class , nomTipus ) ; session . delete ( tipus ) ; session . getTransaction ( ) . commit ( ) ; } }
va	7	@ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { private Node < T > current = head ; private Node < T > prev = null ; @ Override public boolean hasNext ( ) { return current != null ; } @ Override public T next ( ) { prev = current ; if ( current != null ) { current = current . getNext ( ) ; } if ( prev != null ) { return prev . getData ( ) ; } else { return null ; } } @ Override public void remove ( ) { if ( prev == null ) { return ; } if ( prev . getNext ( ) != null ) { prev . getNext ( ) . setPrev ( prev . getPrev ( ) ) ; } if ( prev . getPrev ( ) != null ) { prev . getPrev ( ) . setNext ( prev . getNext ( ) ) ; } if ( head == prev ) { head = prev . getNext ( ) ; } if ( tail == prev ) { tail = prev . getPrev ( ) ; } prev = prev . getPrev ( ) ; len -- ; } } ; }
va	0	@ XmlElementDecl ( namespace = "" , name = "terms-discount-due-days" ) public JAXBElement < String > createTermsDiscountDueDays ( String value ) { return new JAXBElement < String > ( _TermsDiscountDueDays_QNAME , String . class , null , value ) ; }
va	3	public JSONObject ( Map map ) { this . map = new HashMap ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; Object value = e . getValue ( ) ; if ( value != null ) { this . map . put ( e . getKey ( ) , wrap ( value ) ) ; } } } }
va	8	static void setCurrentTab ( boolean isSelection , int tabId , String url , JavaScriptObject tab ) { BrowserTab t = getById ( tabId ) ; t . url = url ; AppState . isWebUrl = WebContent . isWebUrl ( url ) ; AppState . isInPearltrees = AppState . isWebUrl && WebContent . isInPearltrees ( url ) ; MainButton . setIcon ( false , false ) ; if ( isSelection && AppState . isInPearltrees && AppState . getSelectedTree ( ) != null && AppState . lastPearled != null && t . creation . before ( AppState . lastPearled ) ) { AppState . reveal ( AppState . getSelectedTree ( ) , AppState . getSelectedAsso ( ) , tabId , url ) ; } else if ( AppState . isInPearltrees ) { String tree = WebContent . getCurrentTree ( url ) ; if ( tree != null ) { AppState . setSelectedTree ( tree , "" ) ; } } }
va	6	@ Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( other == this ) return true ; if ( ! this . getClass ( ) . isInstance ( other ) ) return false ; Vect o = ( Vect ) other ; if ( o . getX ( ) != this . getX ( ) ) return false ; if ( o . getY ( ) != this . getY ( ) ) return false ; if ( o . getZ ( ) != this . getZ ( ) ) return false ; return true ; }
va	2	@ Override public String stringValue ( byte [ ] val ) { if ( val == null ) { return "" ; } else { Object obj = decode ( val ) ; if ( obj != null ) return obj . toString ( ) ; else return "" ; } }
va	8	@ Override public void onAnalog ( String name , float isPressed , float tpf ) { float pos = isPressed / tpf ; if ( name . equals ( "Accelerate Vehicle" ) ) { if ( car != null ) { car . throttlePressed ( pos ) ; } } if ( name . equals ( "Brake Vehicle" ) ) { if ( car != null ) { car . brakePressed ( pos ) ; } } if ( name . equals ( "Steer Left" ) ) { if ( car != null ) { car . steer ( pos , tpf ) ; } } if ( name . equals ( "Steer Right" ) ) { if ( car != null ) { car . steer ( - pos , tpf ) ; } } }
va	4	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; Location loc = spg . getFirstSquareNeighborLocation ( x , y , 5 , zombie . id ) ; if ( loc == null ) { if ( filterByID ( spg . getSquareNeighbors ( x , y , 2 ) , human . id ) . isEmpty ( ) ) { loc = Location . idleWander ( x , y , 1 , 50 ) ; if ( loc != null ) { spg . moveEntity ( x , y , loc ) ; } } } else { if ( ! spg . moveEntity ( x , y , Location . towards ( x , y , loc , 2 ) ) ) { spg . moveEntity ( x , y , Location . wander ( x , y , 1 ) ) ; } } }
va	8	public List < Qso > read ( ) throws Exception { ADIFParser parser = new ADIFParser ( ) ; BufferedReader r = new BufferedReader ( new FileReader ( file ) ) ; String line ; int i = 1 ; boolean read = false ; boolean gotRecord = false ; StringBuffer record = new StringBuffer ( ) ; while ( ( line = r . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . toUpperCase ( ) . indexOf ( "<EOH>" ) > - 1 ) { read = true ; } else { if ( read ) { record . append ( line ) ; if ( line . indexOf ( "<EOR>" ) > - 1 ) { gotRecord = true ; } } } if ( gotRecord ) { try { Qso qso = parser . parseLine ( record . toString ( ) . replaceAll ( "\n" , "\\n" ) ) ; if ( ( qso != null ) && ( qso . getCall ( ) != null ) ) { list . add ( qso ) ; setOtherBandsIfExist ( qso ) ; } else { log . error ( "Qso With null call found  possible paser error" ) ; } } catch ( Exception e ) { log . error ( "Error" , e ) ; } finally { record = new StringBuffer ( ) ; gotRecord = false ; } } } return list ; }
va	2	@ Deprecated private boolean checkCondition ( String condition ) { if ( condition == null || condition . length ( ) == 0 ) { db . writeError ( "Skipping null or empty WHERE condition." , false ) ; return false ; } return true ; }
va	9X	public void notifyWindowListeners ( List < EngineWindowListener > listeners ) { while ( ! windowEvents . isEmpty ( ) ) { WindowEvent event = windowEvents . poll ( ) ; switch ( event . getID ( ) ) { case WindowEvent . WINDOW_OPENED : for ( EngineWindowListener listener : listeners ) { listener . windowOpened ( event ) ; } break ; case WindowEvent . WINDOW_CLOSING : for ( EngineWindowListener listener : listeners ) { listener . windowClosing ( event ) ; } break ; case WindowEvent . WINDOW_CLOSED : for ( EngineWindowListener listener : listeners ) { listener . windowClosed ( event ) ; } break ; case WindowEvent . WINDOW_ICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowIconified ( event ) ; } break ; case WindowEvent . WINDOW_DEICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowDeiconified ( event ) ; } break ; case WindowEvent . WINDOW_ACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowActivated ( event ) ; } break ; case WindowEvent . WINDOW_DEACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowDeactivated ( event ) ; } break ; } } }
va	8	public void loadSimulationFromFile ( File f ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; HashMap < String , Element > elements = new HashMap < String , Element > ( ) ; snapshots . clear ( ) ; elements . clear ( ) ; time = 0 ; Snapshot current = null ; String heightMapName = in . readLine ( ) ; if ( heightMapName . equals ( "-1" ) || ! new File ( heightMapName ) . exists ( ) ) hm = new HeightMap ( ) ; else hm = new HeightMap ( new File ( heightMapName ) ) ; while ( in . ready ( ) ) { String line = in . readLine ( ) ; if ( line . equals ( "{" ) ) current = new Snapshot ( 0 , Integer . parseInt ( in . readLine ( ) ) ) ; else if ( line . equals ( "}" ) && current != null ) snapshots . add ( current ) ; else if ( current != null ) current . add ( RenderObject . fromString ( line , elements ) ) ; } if ( snapshots . size ( ) > 0 ) { totalTime = snapshots . get ( snapshots . size ( ) - 1 ) . timeTaken ; apply ( 0 ) ; } else totalTime = 0 ; in . close ( ) ; }
va	4	public boolean touches ( Tile otherTile ) { if ( match ( getArea ( ) . getMaxX ( ) , otherTile . getArea ( ) . getMinX ( ) ) || match ( getArea ( ) . getMinX ( ) , otherTile . getArea ( ) . getMaxX ( ) ) ) return checkOverlap ( getArea ( ) . getMinY ( ) , getArea ( ) . getMaxY ( ) , otherTile . getArea ( ) . getMinY ( ) , otherTile . getArea ( ) . getMaxY ( ) ) ; if ( match ( getArea ( ) . getMaxY ( ) , otherTile . getArea ( ) . getMinY ( ) ) || match ( getArea ( ) . getMinY ( ) , otherTile . getArea ( ) . getMaxY ( ) ) ) return checkOverlap ( getArea ( ) . getMinX ( ) , getArea ( ) . getMaxX ( ) , otherTile . getArea ( ) . getMinX ( ) , otherTile . getArea ( ) . getMaxX ( ) ) ; return false ; }
va	3	static String stripLeadingHyphens ( String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( "--" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "-" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; StatementSequenceNode other = ( StatementSequenceNode ) obj ; if ( list == null ) { if ( other . list != null ) return false ; } else if ( ! list . equals ( other . list ) ) return false ; return true ; }
va	7	private void viewMoreInfo ( ) { String t = "" ; String [ ] data = query . Info ( DeleteNonNummeric ( ) , true , null , null , false ) ; idM = Integer . valueOf ( data [ 0 ] ) ; id . setText ( data [ 0 ] ) ; name . setText ( data [ 2 ] + "  " + data [ 1 ] ) ; gender . setText ( data [ 3 ] ) ; pos . setText ( data [ 4 ] ) ; if ( Integer . valueOf ( data [ 9 ] ) == 1 ) adm . setText ( " ADMIN" ) ; else adm . setText ( "  USER" ) ; if ( Integer . valueOf ( data [ 10 ] ) == 1 ) act . setText ( "ACTIVE" ) ; else act . setText ( " INACTIVE" ) ; birth . setText ( data [ 5 ] ) ; if ( data [ 6 ] . equalsIgnoreCase ( "" ) ) data [ 6 ] = "[no data]" ; cont . setText ( data [ 6 ] ) ; if ( data [ 7 ] . equalsIgnoreCase ( "" ) ) data [ 7 ] = "[no data]" ; addr . setText ( data [ 7 ] ) ; date . setText ( data [ 8 ] ) ; if ( data [ 11 ] == null ) t = "[no last active]" ; else if ( data [ 11 ] != null && act . getText ( ) . equals ( "ACTIVE" ) ) t = "[currently active]" ; else t = data [ 11 ] ; lastDate . setText ( t ) ; fn = data [ 1 ] ; ln = data [ 2 ] ; send . setText ( "send to " + data [ 2 ] + "  " + data [ 1 ] ) ; update . setText ( "update info of " + data [ 1 ] ) ; secure . setText ( "reset password of " + data [ 1 ] ) ; age . setText ( String . valueOf ( new Methods ( ) . DateToAge ( data [ 5 ] ) ) ) ; update_info = data ; }
va	6	private int hexToNibble ( char hexChar ) { if ( hexChar >= 0 && hexChar <= 9 ) { return hexChar - 0 ; } if ( hexChar >= a && hexChar <= f ) { return hexChar - a + 10 ; } if ( hexChar >= A && hexChar <= F ) { return hexChar - A + 10 ; } throw new RuntimeException ( "Invalid Hex Character: " + hexChar ) ; }
va	1	public static JFrame makePreferencesWindow ( boolean alwaysOnTop , UIPreferences prefs , UIPreferencesChangeListener listener , ApplicationController controller ) { JFrame window = WindowUtils . getVisibleWindowByName ( NAME_PREFS ) ; if ( window == null ) { window = new ApplicationWindow ( "app.settings" , NAME_PREFS , new PreferencesPanel ( prefs , listener , controller ) , alwaysOnTop ) ; } return window ; }
va	6	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 20 ) ; case 95 : return jjMoveStringLiteralDfa14_0 ( active0 , 1000 ) ; case 97 : return jjMoveStringLiteralDfa14_0 ( active0 , 2000 ) ; case 122 : return jjMoveStringLiteralDfa14_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
va	9X	static List < String > digestProtein ( String sequence , int minLen , int maxLen ) { List < String > peptides = new ArrayList < String > ( ) ; String peptide ; int i = 0 , idx ; while ( i < sequence . length ( ) ) { idx = i ; while ( ( idx < sequence . length ( ) - 1 ) && ( ( ( sequence . charAt ( idx ) == K || sequence . charAt ( idx ) == R ) && sequence . charAt ( idx + 1 ) == P ) || ( sequence . charAt ( idx ) != K && sequence . charAt ( idx ) != R ) ) ) { idx += 1 ; } peptide = sequence . substring ( i , idx + 1 ) ; if ( ( peptide . length ( ) >= minLen ) && ( peptide . length ( ) <= maxLen ) ) { peptides . add ( peptide ) ; } i = idx + 1 ; } return peptides ; }
va	1	private void waitABit ( String message ) { try { Thread . sleep ( 10000 ) ; System . out . println ( message ) ; } catch ( InterruptedException e ) { } }
va	0	public Response ( String responseText , int statusCode ) { this . responseText = responseText ; this . statusCode = statusCode ; created_on = TimeUtility . getNowByGMT ( ) . getTime ( ) ; }
va	8	public Map < String , Map < String , boolean >> getPermissions ( String world ) { Map < String , Map < String , boolean >> result = new HashMap < String , Map < String , boolean >> ( ) ; Map < String , boolean > groupperms = new LinkedHashMap < String , boolean > ( ) ; groupperms . put ( "droxperms.meta.group." + group , true ) ; if ( world != null ) { groupperms . put ( "droxperms.meta.group." + group + "." + Config . getRealWorld ( world ) , true ) ; } result . put ( "group" , groupperms ) ; if ( subgroups != null ) { Map < String , boolean > subgroupperms = new LinkedHashMap < String , boolean > ( ) ; for ( Iterator < String > iterator = subgroups . iterator ( ) ; iterator . hasNext ( ) ; ) { String subgroup = iterator . next ( ) ; subgroupperms . put ( "droxperms.meta.group." + subgroup , true ) ; if ( world != null ) { subgroupperms . put ( "droxperms.meta.group." + subgroup + "." + Config . getRealWorld ( world ) , true ) ; } } result . put ( "subgroups" , subgroupperms ) ; } if ( globalPermissions != null ) { result . put ( "global" , globalPermissions ) ; } if ( world != null && permissions != null ) { Map < String , boolean > worldperms = new LinkedHashMap < String , boolean > ( ) ; if ( permissions . get ( Config . getRealWorld ( world ) ) != null ) { worldperms . putAll ( permissions . get ( Config . getRealWorld ( world ) ) ) ; } result . put ( "world" , worldperms ) ; } return result ; }
va	0	public void setCurrency ( java . lang . String currency ) { this . currency = currency ; }
va	5	@ Override public Map < StatsType , LongSummaryStatistics > call ( ) throws IOException { final LongSummaryStatistics initTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics symbolTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics decTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics totalDecsStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics numDecFailsStats = new LongSummaryStatistics ( totalDecsStats ) ; final LongSummaryStatistics decFailTimeStats = new LongSummaryStatistics ( ) ; final ByteBuffer dataHeaderBuf = DataHeader . allocateNewBuffer ( ) ; final ByteBuffer symbolHeaderBuf = SymbolHeader . allocateNewBuffer ( ) ; for ( int n = 0 ; n < numIterations ; n ++ ) { dataHeaderBuf . clear ( ) ; readBytes ( dataHeaderBuf ) ; final DataHeader dataHeader = DataHeader . parseDataHeader ( dataHeaderBuf ) ; final FECParameters fecParams = dataHeader . getFECParams ( ) ; final int extraSymbols = dataHeader . getExtraSymbols ( ) ; final ByteBuffer symbolBuf = ByteBuffer . allocate ( fecParams . symbolSize ( ) ) ; final ArrayDataDecoder dataDec = initDataDecoder ( fecParams , extraSymbols , initTimeStats ) ; final int Z = dataDec . numberOfSourceBlocks ( ) ; for ( int sbn = 0 ; sbn < Z ; sbn ++ ) { final SourceBlockDecoder srcBlockDec = dataDec . decoderForSourceBlock ( sbn ) ; final int totalSymbols = srcBlockDec . numberOfSourceSymbols ( ) + extraSymbols ; for ( int i = 0 ; i < totalSymbols ; ) { symbolHeaderBuf . clear ( ) ; readBytes ( symbolHeaderBuf ) ; final SymbolHeader symbolHeader = SymbolHeader . parseSymbolHeader ( symbolHeaderBuf , fecParams , sbn ) ; final int firstESI = symbolHeader . getFECPayloadID ( ) . encodingSymbolID ( ) ; final int numSymbolsInPacket = symbolHeader . getNumSymbols ( ) ; for ( int s = 0 ; s < numSymbolsInPacket ; s ++ ) { symbolBuf . clear ( ) ; readBytes ( symbolBuf ) ; putSymbol ( srcBlockDec , firstESI + s , symbolBuf , symbolTimeStats , decTimeStats , decFailTimeStats , totalDecsStats , numDecFailsStats ) ; } i += numSymbolsInPacket ; } } checkData ( dataDec ) ; } final EnumMap < StatsType , LongSummaryStatistics > map = new EnumMap < > ( StatsType . class ) ; map . put ( StatsType . DECODER_INIT_TIME , initTimeStats ) ; map . put ( StatsType . SYMBOL_INPUT_TIME , symbolTimeStats ) ; map . put ( StatsType . DECODING_TIME , decTimeStats ) ; map . put ( StatsType . NUM_DECODING_FAILURES , numDecFailsStats ) ; if ( numDecFailsStats . getCount ( ) > 0 ) { map . put ( StatsType . DECODING_FAILURE_TIME , decFailTimeStats ) ; } return map ; }
va	0	protected Logger getLogger ( ) { return this . logger ; }
va	3	public static boolean createTable ( Connection con , TableInfo tableInfo ) { System . out . println ( "Creating table " + tableInfo . tableName ) ; String tableCreate = "CREATE TABLE " + tableInfo . tableName + " ( " ; for ( String i : tableInfo . columns ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " " + tmp [ 0 ] + " " + tmp [ 1 ] + "   " ; } for ( String i : tableInfo . foreignKeys ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " FOREIGN KEY (" + tmp [ 0 ] + ") REFERENCES  " + tmp [ 1 ] + "   " ; } tableCreate += " PRIMARY KEY (ID) )" ; try { Statement stmt = con . createStatement ( ) ; stmt . execute ( tableCreate ) ; stmt . close ( ) ; } catch ( SQLException sqle ) { System . out . println ( "DBObject createTable(" + tableInfo . tableName + "): " + "Unhandled SQLException  create string:\n" + tableCreate + "\n\n Exception: \n" + sqle + "\n\n" ) ; return false ; } return true ; }
va	4	public double getDeltaV ( ) { double totalDeltaV = 0 ; final double stageMass = getMass ( ) ; int totalLiquidEngines = 0 ; for ( final Engine engine : activeEngines ) { if ( engine . getSolidFuelMass ( ) == 0 ) { ++ totalLiquidEngines ; } } final double g = environment . getGravity ( vehicle . getAltitude ( ) ) ; for ( final Engine engine : activeEngines ) { double burnedFuelMass ; if ( engine . getSolidFuelMass ( ) > 0 ) { burnedFuelMass = engine . getSolidFuelMass ( ) ; } else { burnedFuelMass = getLOXFuelMass ( ) / totalLiquidEngines ; } final double deltaV = g * engine . getIsp ( ) * Math . log ( stageMass / ( stageMass - burnedFuelMass ) ) ; totalDeltaV += deltaV ; } return totalDeltaV ; }
va	3	public synchronized void newShareAvailable ( ShareAvailability file ) { String hash = file . getFile ( ) . getHash ( ) ; System . out . println ( "new share available: " + hash ) ; if ( ! downloaded . contains ( hash ) && ! downloading . contains ( hash ) && ! queue . contains ( hash ) ) queue . add ( hash ) ; }
va	5	public static int countABC ( String str ) { int zmCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( ( c >= a && c <= z ) || ( c >= A && c <= Z ) ) zmCount ++ ; } return zmCount ; }
va	0	public static void main ( String [ ] args ) { int x , y , z ; x = y = z = 1 ; System . out . println ( "x = " + x + "  y = " + y + "  z = " + z ) ; System . out . println ( 32 % 7 % 3 ) ; System . out . println ( ( 32 % 7 ) % 3 ) ; System . out . println ( 32 % ( 7 % 3 ) ) ; }
va	5	private boolean getToBoxDesireCompleted ( Agent a ) { for ( dir d : dir . values ( ) ) { if ( a . desire != null && a . desire . goal == null && a . getAtField ( ) . neighbors [ d . ordinal ( ) ] != null && a . getAtField ( ) . neighbors [ d . ordinal ( ) ] . equals ( a . desire . box . getAtField ( ) ) ) return true ; } return false ; }
va	5	public void setPause ( boolean pause ) { if ( ogg != null ) { if ( pause ) { ogg . pause ( ) ; } else { ogg . resume ( ) ; } } if ( clip != null ) { try { if ( clip . isControlSupported ( BooleanControl . Type . MUTE ) ) { BooleanControl muteControl = ( BooleanControl ) clip . getControl ( BooleanControl . Type . MUTE ) ; muteControl . setValue ( pause ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
va	2	public static List < Point2D > getObjectContourPoints ( ABObject ob ) { List < Point2D > bounds = new ArrayList < Point2D > ( ) ; if ( ob . getType ( ) == ABType . Pig || ob . shape == ABShape . Circle ) { bounds = CircleContour ( ob ) ; } else { List < Point > ps = PolyContour ( PolyCorners ( ob ) ) ; bounds = convertToPoint2D ( ps ) ; } return bounds ; }
va	4	public void insertPoint ( Point p , int index ) { if ( bounds != null && ! bounds . contains ( p ) ) bounds = null ; if ( index > size || index < 0 ) throw new IndexOutOfBoundsException ( "Index: " + index + "  Size: " + size ) ; index *= 2 ; int length = points . length ; int old [ ] = points ; points = new int [ length + 2 ] ; System . arraycopy ( old , 0 , points , 0 , index ) ; System . arraycopy ( old , index , points , index + 2 , length - index ) ; points [ index ] = p . x ; points [ index + 1 ] = p . y ; size ++ ; }
va	4	public int call ( CallFrame frame , int argCount ) { Coroutine coroutine = frame . getArg ( 0 , Coroutine . class ) ; if ( coroutine . isDead ( ) ) throw new LuaException ( "unable to resume a dead coroutine" ) ; coroutine . resume ( frame . coroutine ) ; CallFrame nextFrame = coroutine . getCurrentFrame ( ) ; boolean isFirst = ( nextFrame . argCount == - 1 ) ; if ( isFirst ) nextFrame . setTop ( 0 ) ; for ( int index = 1 ; index < argCount ; index ++ ) nextFrame . push ( frame . get ( index ) ) ; if ( isFirst ) { nextFrame . argCount = argCount - 1 ; nextFrame . init ( ) ; } frame . getThread ( ) . coroutine = coroutine ; return 0 ; }
va	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
va	7	private void showSaveDialog ( ) { String saveFilepath = ZettaUtil . pathComponent ( LevelEditor . editor . currentFilepath ) ; JFileChooser fc = new JFileChooser ( saveFilepath ) ; fc . setFileFilter ( new FileFilter ( ) { @ Override public boolean accept ( File f ) { if ( f . isDirectory ( ) ) { return true ; } String extension = ZettaUtil . getExtension ( f ) ; return extension != null && extension . equals ( STAGE_DATA_FILE_EXTENSION ) ; } @ Override public String getDescription ( ) { return "Stage Data Files" ; } } ) ; int returnVal = fc . showSaveDialog ( LevelEditor . editor ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { try { File f = fc . getSelectedFile ( ) ; if ( ! ZettaUtil . getExtension ( f ) . equals ( STAGE_DATA_FILE_EXTENSION ) ) { f = new File ( f . getAbsolutePath ( ) + "." + STAGE_DATA_FILE_EXTENSION ) ; } if ( f . exists ( ) ) { int i = JOptionPane . showConfirmDialog ( this , "Are you sure you want to overwrite?" , "Save As" , JOptionPane . YES_NO_OPTION ) ; if ( i != JOptionPane . OK_OPTION ) { return ; } } this . saveData ( f ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
va	4	public static Map < String , List < String >> getAbbreviations ( Collection < String > names ) { Map < String , List < String >> abbrevs = new LinkedHashMap < String , List < String >> ( ) ; for ( String name : names ) { for ( int len = name . length ( ) - 1 ; len > 0 ; -- len ) { String abbrev = name . substring ( 0 , len ) ; if ( ! abbrevs . containsKey ( abbrev ) ) { abbrevs . put ( abbrev , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } else { abbrevs . get ( abbrev ) . add ( name ) ; } } } for ( String name : names ) { abbrevs . put ( name , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } return abbrevs ; }
va	5	public void sendDataToClient ( ) throws IOException { if ( sock instanceof SSLSocket ) { SSLSocket sslSock = ( SSLSocket ) sock ; if ( sslSock == null || resp == null ) { return ; } sslSock . getOutputStream ( ) . write ( resp . byteContents ( ) ) ; } else { this . sock . getOutputStream ( ) . write ( resp . byteContents ( ) ) ; this . sock . getOutputStream ( ) . flush ( ) ; } if ( version . equals ( "1.0" ) && ! cached ) { this . sock . close ( ) ; } this . sent = true ; }
va	6	@ Override public void run ( ) { if ( i_nbDifferentCalcWay > 0 ) { while ( listWayToBrowse . size ( ) > 0 && ( listWayWithPointStop . size ( ) > 0 || listWayToBrowse . size ( ) < i_nbDifferentCalcWay ) ) { findNextPoint ( ) ; } if ( listWayToBrowse . size ( ) == 0 ) { threadManager . setHasTerminatedFirstThread ( true ) ; } } else { while ( listWayToBrowse . size ( ) > 0 ) { findNextPoint ( ) ; } } threadManager . addListWayPointStop ( listWayWithPointStop ) ; }
va	6	public static void drawCell ( Graphics g , Rectangle bounds , JTree tree , TreePath path , int row ) { boolean isRowSelected = tree . isRowSelected ( row ) ; DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; if ( node instanceof LeafNode ) { Color colorTmp = colorLeaf ; Color colorBorderTmp = colorLeafBorder ; if ( isRowSelected ) { colorTmp = colorLeafSel ; colorBorderTmp = colorLeafSelBorder ; } else if ( ( ( LeafNode ) node ) . getDownload ( ) != null && ( ( LeafNode ) node ) . getDownload ( ) . isPaused ( ) ) { colorTmp = colorLeafPause ; colorBorderTmp = colorLeafPauseBorder ; } else if ( ( ( LeafNode ) node ) . getDownload ( ) != null && ( ( LeafNode ) node ) . getDownload ( ) . isFaulty ( ) ) { colorTmp = colorLeafFaulty ; colorBorderTmp = colorLeafFaultyBorder ; } Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . setColor ( colorTmp ) ; g2 . fillRect ( tree . getVisibleRect ( ) . x + 4 , bounds . y + 2 , Math . round ( ( ( tree . getVisibleRect ( ) . width - 10 ) * ( ( LeafNode ) node ) . getDownPerc ( ) * 100 ) / 100 ) , bounds . height - 5 ) ; g2 . setColor ( colorBorderTmp ) ; g2 . drawRect ( tree . getVisibleRect ( ) . x + 4 , bounds . y + 2 , tree . getVisibleRect ( ) . width - 10 , bounds . height - 5 ) ; g2 . dispose ( ) ; } }
va	4	private void processNode ( ) { Edge minEdge = null ; int minDijkstraCriterion = Integer . MAX_VALUE ; Set < Edge > frontierEdges = getFrontierEdges ( ) ; if ( frontierEdges . isEmpty ( ) ) { noFrontierEdges = true ; return ; } for ( Edge edge : frontierEdges ) { int dijkstraGreedyCriterion = dijkstraGreedyCriterion ( edge ) ; if ( dijkstraGreedyCriterion < minDijkstraCriterion ) { minDijkstraCriterion = dijkstraGreedyCriterion ; minEdge = edge ; } } assert minEdge != null : "No edges to remaining nodes" ; Node processedNode = null ; if ( ! minEdge . getTargetNode ( ) . isExplored ( ) ) { processedNode = minEdge . getTargetNode ( ) ; } else { processedNode = minEdge . getSourceNode ( ) ; } markProcessed ( processedNode ) ; shortestPathLengths . put ( processedNode , minDijkstraCriterion ) ; }
va	8	private void filter ( KDTreeCell cell , ArrayList < FCECenter > candidates ) { try { ArrayList < FCECenter > input = new ArrayList < > ( ) ; input . addAll ( candidates ) ; if ( cell . isLeafNode ( ) && ! cell . isEmpty ( ) ) { Collections . sort ( input , new CenterDistanceComparator ( cell . getPoint ( ) ) ) ; input . get ( 0 ) . addToCount ( 1 ) ; input . get ( 0 ) . addToSum ( cell . getPoint ( ) ) ; } else { Collections . sort ( input , new CenterDistanceComparator ( cell . getCenter ( ) ) ) ; FCECenter closest = input . get ( 0 ) ; Iterator < FCECenter > it = input . iterator ( ) ; it . next ( ) ; while ( it . hasNext ( ) ) { FCECenter z = it . next ( ) ; Point midpoint = closest . getCenter ( ) . midpointFromPoint ( z . getCenter ( ) ) ; Vector normal = new Vector ( midpoint , closest . getCenter ( ) ) ; if ( cell . getBoundingBox ( ) . intersectWithPlane ( new Plane ( midpoint , normal ) ) == BoundingBox . BB_INFRONT ) it . remove ( ) ; } if ( input . size ( ) > 1 ) { ArrayList < FCECenter > newCandidates = new ArrayList < > ( ) ; newCandidates . addAll ( input ) ; this . filter ( cell . getChild ( 0 ) , newCandidates ) ; this . filter ( cell . getChild ( 1 ) , input ) ; } else { closest . addToCount ( cell . getPointCount ( ) ) ; closest . addToSum ( cell . getSum ( ) ) ; } } } catch ( CenterDistanceComparatorException cdce ) { } catch ( GeometryException | KDTreeCellException ge ) { } catch ( FCEException fcee ) { } }
va	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; IfNode other = ( IfNode ) obj ; if ( elseifs == null ) { if ( other . elseifs != null ) return false ; } else if ( ! elseifs . equals ( other . elseifs ) ) return false ; if ( exp1 == null ) { if ( other . exp1 != null ) return false ; } else if ( ! exp1 . equals ( other . exp1 ) ) return false ; if ( stateSeq1 == null ) { if ( other . stateSeq1 != null ) return false ; } else if ( ! stateSeq1 . equals ( other . stateSeq1 ) ) return false ; if ( stateSeq2 == null ) { if ( other . stateSeq2 != null ) return false ; } else if ( ! stateSeq2 . equals ( other . stateSeq2 ) ) return false ; return true ; }
va	3	@ Override protected boolean doDecode ( IoSession session , ByteBuffer in , ProtocolDecoderOutput out ) throws Exception { if ( in . remaining ( ) >= MessageHeader . HEADER_BYTES_SIZE + Body . BODY_BYTES_SIZE ) { int start = in . position ( ) ; MessageHeader header = MessageHeader . tryDecodeHeader ( SGIP_BIND_RESP , in ) ; if ( header == null ) { in . position ( start ) ; return false ; } Body body = tryDecodeBody ( in ) ; if ( body == null ) { in . position ( start ) ; return false ; } BindResponse bindRequest = new BindResponse ( header , body ) ; out . write ( bindRequest ) ; return true ; } else { return false ; } }
va	9X	protected void serialize_primitive ( Object obj , PrintWriter p , int level ) { if ( obj instanceof boolean || obj . getClass ( ) == boolean . TYPE ) { p . print ( obj . equals ( boolean . true ) ? "True" : "False" ) ; } else if ( obj instanceof float || obj . getClass ( ) == float . TYPE ) { float f = ( float ) obj ; serialize_primitive ( f . doubleValue ( ) , p , level ) ; } else if ( obj instanceof double || obj . getClass ( ) == double . TYPE ) { double d = ( double ) obj ; if ( d . isInfinite ( ) ) { if ( d > 0.0 ) { p . print ( "1e30000" ) ; } else { p . print ( "-1e30000" ) ; } } else if ( d . isNaN ( ) ) { p . print ( "{'__class__':'float' 'value':'nan'}" ) ; } else { p . print ( d ) ; } } else { p . print ( obj ) ; } }
va	3	public void deleteAtPos ( int position ) { DNode cur = HEADER . next ; int size = 0 ; while ( cur != TRAILER ) { size ++ ; cur = cur . next ; } if ( position > size ) { System . out . println ( "Invalid Position cannot insert" ) ; return ; } int i = 0 ; cur = HEADER . next ; while ( i != position ) { i ++ ; cur = cur . next ; } DNode posprev = cur . prev ; DNode posnext = cur . next ; posprev . next = posnext ; posnext . prev = posprev ; }
va	7	private int [ ] merge ( int [ ] leftArray , int [ ] rightArray ) { int mergedLength = leftArray . length + rightArray . length ; int [ ] mergedArray = new int [ mergedLength ] ; int leftIndex = 0 ; int rightIndex = 0 ; while ( leftIndex + rightIndex < mergedLength ) { if ( leftIndex < leftArray . length && rightIndex < rightArray . length ) { if ( leftArray [ leftIndex ] <= rightArray [ rightIndex ] ) { mergedArray [ leftIndex + rightIndex ] = leftArray [ leftIndex ] ; leftIndex ++ ; } else { mergedArray [ leftIndex + rightIndex ] = rightArray [ rightIndex ] ; rightIndex ++ ; } } else if ( leftIndex < leftArray . length ) { while ( leftIndex < leftArray . length ) { mergedArray [ leftIndex + rightIndex ] = leftArray [ leftIndex ] ; leftIndex ++ ; } } else { while ( rightIndex < rightArray . length ) { mergedArray [ leftIndex + rightIndex ] = rightArray [ rightIndex ] ; rightIndex ++ ; } } } return mergedArray ; }
va	4	public int solve ( int index , boolean [ ] config , boolean [ ] bestConfig , int bestPrice ) { if ( index == weights . length ) { int price = priceOfConfig ( config ) ; if ( price > bestPrice ) { bestPrice = price ; copyConfig ( config , bestConfig ) ; } return bestPrice ; } else { config [ index ] = false ; int price1 = solve ( index + 1 , config , bestConfig , bestPrice ) ; if ( price1 > bestPrice ) { bestPrice = price1 ; } config [ index ] = true ; int price2 = solve ( index + 1 , config , bestConfig , bestPrice ) ; if ( price2 > bestPrice ) { bestPrice = price2 ; } return bestPrice ; } }
va	4	@ SuppressWarnings ( "resource" ) @ Test public void testUpdateOverflow ( ) throws IOException { storageManager = new StorageManager ( testDir , 1024 * 1024 , 2 , storageMode , size ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; byte [ ] sourceBytes = new byte [ 1024 ] ; IStorageBlock previousBlock = null ; Pointer pointer = null ; for ( int i = 0 ; i < 1024 ; i ++ ) { pointer = storageManager . store ( sourceBytes ) ; assertNotNull ( pointer ) ; if ( previousBlock == null ) previousBlock = pointer . getStorageBlock ( ) ; else { assertTrue ( pointer . getStorageBlock ( ) == previousBlock ) ; previousBlock = pointer . getStorageBlock ( ) ; } } assertTrue ( 1024 * 1024 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 512 ] ) ; assertTrue ( previousBlock == pointer . getStorageBlock ( ) ) ; assertTrue ( 1023 * 1024 + 512 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 1024 ] ) ; assertTrue ( previousBlock != pointer . getStorageBlock ( ) ) ; previousBlock = pointer . getStorageBlock ( ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 0 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 2 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 1024 == storageManager . getDirty ( ) ) ; double expectedRatio = 1024 * 1.0 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( 1024 * 1024 == storageManager . getUsed ( ) ) ; for ( int i = 1 ; i < 1024 ; i ++ ) { pointer = storageManager . store ( sourceBytes ) ; assertNotNull ( pointer ) ; if ( previousBlock == null ) previousBlock = pointer . getStorageBlock ( ) ; else { assertTrue ( pointer . getStorageBlock ( ) == previousBlock ) ; previousBlock = pointer . getStorageBlock ( ) ; } } assertTrue ( 2047 * 1024 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 512 ] ) ; assertTrue ( previousBlock == pointer . getStorageBlock ( ) ) ; assertTrue ( 2047 * 1024 - 512 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 1024 ] ) ; assertTrue ( previousBlock != pointer . getStorageBlock ( ) ) ; previousBlock = pointer . getStorageBlock ( ) ; assertTrue ( 2047 * 1024 == storageManager . getUsed ( ) ) ; assertTrue ( 3 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 0 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 3 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 3 == storageManager . getCapacity ( ) ) ; assertTrue ( 1024 * 2 == storageManager . getDirty ( ) ) ; expectedRatio = 1024 * 1.0 * 2 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; }
va	0	public void setMaxDesolvApolar ( float value ) { this . maxDesolvApolar = value ; }
va	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
va	6	public void update ( ) { for ( ModelObject o : objects ) o . update ( ) ; for ( ModelObject o : removelist ) o . dispose ( ) ; objects . removeAll ( removelist ) ; removelist . clear ( ) ; objects . addAll ( addlist ) ; addlist . clear ( ) ; if ( seaObject . controller . addlist . size ( ) > 0 || seaObject . controller . removelist . size ( ) > 0 ) { seaObject . controller . controllers . removeAll ( seaObject . controller . removelist ) ; seaObject . controller . controllers . addAll ( seaObject . controller . addlist ) ; seaObject . controller . removelist . clear ( ) ; seaObject . controller . addlist . clear ( ) ; } if ( radarObject . controller . addlist . size ( ) > 0 || radarObject . controller . removelist . size ( ) > 0 ) { radarObject . controller . controllers . removeAll ( radarObject . controller . removelist ) ; radarObject . controller . controllers . addAll ( radarObject . controller . addlist ) ; radarObject . controller . removelist . clear ( ) ; radarObject . controller . addlist . clear ( ) ; } }
va	5	private static void flatten ( Node < ? > node , LinkedList < Node < ? >> result ) { if ( node == null ) return ; result . add ( node ) ; if ( node instanceof UnaryNode ) { flatten ( ( ( UnaryNode ) node ) . getSibling ( ) , result ) ; } else if ( node instanceof BinaryNode ) { BinaryNode binaryNode = ( BinaryNode ) node ; flatten ( binaryNode . getFirstSibling ( ) , result ) ; flatten ( binaryNode . getSecondSibling ( ) , result ) ; } }
va	6	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
va	7	@ Override public void afterPhase ( PhaseEvent event ) { FacesContext facesContext = event . getFacesContext ( ) ; String currentPage = facesContext . getViewRoot ( ) . getViewId ( ) ; HttpSession session = ( HttpSession ) facesContext . getExternalContext ( ) . getSession ( true ) ; Integer idCidadeSessao = ( Integer ) session . getAttribute ( "idCidade" ) ; ExternalContext externalContext = facesContext . getExternalContext ( ) ; String idCidadeURL = externalContext . getRequestParameterMap ( ) . get ( "idCidade" ) ; System . out . println ( "P\u00E1gina: " + currentPage ) ; System . out . println ( "AUTENTICA SESSAO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; System . out . println ( "ID DA CIDADE PELA URAL = " + idCidadeURL ) ; if ( idCidadeURL == null ) { if ( idCidadeSessao == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } } else { CidadesEnum cidade = CidadesEnum . getValue ( Integer . parseInt ( idCidadeURL ) ) ; if ( cidade == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } else { session . setAttribute ( "idCidade" , cidade . getCodigo ( ) ) ; } } boolean isLoginPage = ( currentPage . lastIndexOf ( "login.xhtml" ) > - 1 ) ; boolean isSemSessao = ( currentPage . lastIndexOf ( "semsessao.xhtml" ) > - 1 ) ; Object idCidade = session . getAttribute ( "idCidade" ) ; Object isLogado = session . getAttribute ( "isLogado" ) ; if ( ! isLoginPage && ! isSemSessao && idCidade == null && isLogado == null ) { String errorPageLocation = "/pages/public/semsessao.xhtml?faces-redirect=true" ; facesContext . setViewRoot ( facesContext . getApplication ( ) . getViewHandler ( ) . createView ( facesContext , errorPageLocation ) ) ; facesContext . getPartialViewContext ( ) . setRenderAll ( true ) ; facesContext . renderResponse ( ) ; } }
va	3	public String toString ( ) { Nodo node = this . raiz ; if ( node == null ) return "" ; StringBuilder sb = new StringBuilder ( ) ; while ( node != null ) { sb . append ( node . elem ) ; if ( node . sig != null ) sb . append (   ) ; node = node . sig ; } return sb . toString ( ) ; }
va	1	@ Override public short readShort ( ) { byte [ ] data = new byte [ 2 ] ; read ( data ) ; short value ; if ( order == ByteOrder . LITTLE_ENDIAN ) { value = ( short ) ( ( FF & data [ 0 ] ) ) ; value |= ( short ) ( ( FF & data [ 1 ] ) << 8 ) ; } else { value = ( short ) ( ( FF & data [ 1 ] ) ) ; value |= ( short ) ( ( FF & data [ 0 ] ) << 8 ) ; } return value ; }
va	2	public long getLong_safe ( final long i ) { if ( i < 0 || i >= length ) { throw new ArrayIndexOutOfBoundsException ( long . toString ( i ) ) ; } return getLong ( i ) ; }
va	1	protected void createWebSocketPingServer ( ) { RxHttpServer server = new RxHttpServer ( vertx . createHttpServer ( ) ) ; server . websocket ( ) . subscribe ( new Action1 < RxServerWebSocket > ( ) { public void call ( final RxServerWebSocket s ) { System . out . println ( "WebSocketServer:" + s . path ( ) ) ; s . asObservable ( ) . subscribe ( new Action1 < Buffer > ( ) { public void call ( Buffer b ) { System . out . println ( "WebSocketServer:received[" + b + "]" ) ; if ( "EOF" . equals ( b . toString ( ) ) ) { s . close ( ) ; } else { s . writeTextFrame ( b . toString ( ) ) ; } } } ) ; } } ) ; server . coreHttpServer ( ) . listen ( 8090 , "localhost" ) ; }
va	7	public static double checkWeight ( String sweight ) { final int MIN = 20 ; final int MAX = 299 ; double dweight = 0 ; if ( sweight == null || sweight . trim ( ) . length ( ) == 0 ) { JOptionPane . showMessageDialog ( null , "Bitte  geben Sie ein Gewicht in das Gewichtsfeld ein" , "Gewichtseingabe fehlt" , JOptionPane . ERROR_MESSAGE ) ; } else try { dweight = double . parseDouble ( sweight ) ; } catch ( NumberFormatException nfe ) { JOptionPane . showMessageDialog ( null , "Bitte  geben Sie ihr Gewicht nur mit Zahlen ein! \n Vewenden sie einen Punkt statt Komma!!!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; } if ( dweight < MIN ) JOptionPane . showMessageDialog ( null , "Das eingegebene Gewicht muss gr\u00F6\u00DFer als 20 Kilogramm sein!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dweight > MAX ) JOptionPane . showMessageDialog ( null , "Das eingegebene Gewicht muss kleiner als 300 Kilogramm sein!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dweight < MIN && dweight > MAX ) return dweight ; return dweight ; }
va	3	static < K extends Comparable < K > , E > boolean containsElement ( BSTNode < K , E > node , E element ) { if ( node == null ) { return false ; } else { return element . equals ( node . getElement ( ) ) || containsElement ( node . leftChild , element ) || containsElement ( node . rightChild , element ) ; } }
va	2	public ArrayPriorityQueueItem < T > insert ( T item , double key ) { ArrayPriorityQueueItem < T > newItem = new ArrayPriorityQueueItem < T > ( item , key , numberOfElements ) ; if ( minItem == null || key < minItem . key ) { minItem = newItem ; } a [ numberOfElements ++ ] = newItem ; return newItem ; }
va	3	public Simulator ( ) throws InterruptedException { GUIManager . simulator = this ; phase = Phase . INIT ; Thread simulatorThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { Log . finer ( "maked Simulation Instance." ) ; setting ( ) ; int periodTime = Conf . CountPeriod ; long start , end , - , sleepTime ; while ( true ) { start = System . currentTimeMillis ( ) ; select ( ) ; end = System . currentTimeMillis ( ) ; - = end - start ; sleepTime = 1000 / periodTime - - ; try { Thread . sleep ( ( sleepTime >= 0 ? sleepTime : 0 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ) ; simulatorThread . start ( ) ; Log . finer ( "end of Simulation Instance." ) ; }
va	1	public Sonido getNewSonido ( int nombreSonido ) { return nombreSonido < sonidos . size ( ) ? sonidos . get ( nombreSonido ) . clonar ( ) : null ; }
va	7	IndexTable ( byte [ ] record ) { this . record = record ; int offset = 0 ; offset += 4 ; int nameLength = RecordAccess . getU16 ( this . record , offset ) ; offset += 2 ; if ( nameLength > 0 ) { offset += nameLength ; } peerCount = RecordAccess . getU16 ( this . record , offset ) ; offset += 2 ; peerIp = new Vector < InetAddress > ( peerCount ) ; for ( int i = 0 ; i < peerCount ; i ++ ) peerIp . addElement ( null ) ; peerBgp = new long [ peerCount ] ; peerAs = new long [ peerCount ] ; for ( int i = 0 ; i < peerCount ; i ++ ) { int bit0 = 1 ; int bit1 = 2 ; int peerType = RecordAccess . getU8 ( this . record , offset ) ; offset ++ ; int firstBit ; int secondBit ; if ( ( peerType & bit0 ) != 0 ) { firstBit = 16 ; } else firstBit = 4 ; if ( ( peerType & bit1 ) != 0 ) { secondBit = 4 ; } else secondBit = 2 ; long peerBgpId = RecordAccess . getU32 ( this . record , offset ) ; peerBgp [ i ] = peerBgpId ; offset += 4 ; try { takeIp = InetAddress . getByAddress ( RecordAccess . getBytes ( this . record , offset , firstBit ) ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } peerIp . set ( i , takeIp ) ; offset += firstBit ; long takePeerAs ; if ( secondBit == 2 ) takePeerAs = RecordAccess . getU16 ( this . record , offset ) ; else takePeerAs = RecordAccess . getU32 ( this . record , offset ) ; peerAs [ i ] = takePeerAs ; offset += secondBit ; } }
va	9X	public static LMDrillModel getAllTweetsByDate ( String startDate , String endDate ) { ArrayList < tweetModel > results = new ArrayList < tweetModel > ( ) ; LMDrillModel lmDrillModel = new LMDrillModel ( ) ; String [ ] start = startDate . split ( " " ) ; String [ ] end = endDate . split ( " " ) ; tweetModel t ; String tablename = "temp-" + start [ 0 ] + "." + start [ 1 ] + "." + start [ 2 ] + "-" + end [ 0 ] + "." + end [ 1 ] + "." + end [ 2 ] ; System . out . println ( tablename ) ; String whereCondition = "" ; int year = Integer . parseInt ( start [ 2 ] ) ; for ( int month = monthNumber ( start [ 0 ] ) ; month <= monthNumber ( end [ 0 ] ) ; month ++ ) { int currentday = 1 ; if ( month == monthNumber ( start [ 0 ] ) ) currentday = Integer . parseInt ( start [ 1 ] ) ; for ( int day = currentday ; day <= numDaysinMonth ( month ) ; day ++ ) { if ( month == monthNumber ( end [ 0 ] ) && day > Integer . parseInt ( end [ 1 ] ) ) break ; if ( whereCondition . equals ( "" ) ) whereCondition = "'" + start [ 1 ] + " " + start [ 0 ] + " " + start [ 2 ] + "%'" ; else whereCondition = whereCondition . concat ( " or date like '" + day + " " + monthName ( month ) + " " + year + "%'" ) ; } } System . out . println ( "[3] " + whereCondition ) ; try { Connection c = DBFactory . getConnection ( ) ; PreparedStatement ps = c . prepareStatement ( "DROP TABLE IF EXISTS `" + tablename + "`; " ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "CREATE TABLE `" + tablename + "` (" + "`username` varchar(20) NOT NULL " + "`date` varchar(30) NOT NULL " + "`message` varchar(180) NOT NULL" + ")ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "INSERT INTO `" + tablename + "` (username  date  message) " + "SELECT username  date  message FROM `tweets` " + "WHERE date like " + whereCondition ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "SELECT * from `" + tablename + "`;" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { t = new tweetModel ( ) ; t . setUsername ( rs . getString ( "username" ) ) ; t . setDate ( rs . getString ( "date" ) ) ; t . setMessage ( cleanTweet ( rs . getString ( "message" ) ) ) ; NGramDriver . NGramTweet ( cleanTweet ( t . getMessage ( ) ) ) ; results . add ( t ) ; } rs . close ( ) ; ps . close ( ) ; c . close ( ) ; System . out . println ( "******************************* " ) ; if ( results . isEmpty ( ) ) { lmDrillModel = new LMDrillModel ( - 1 ) ; } else { sortNgramAndRemoveOutliers ( ) ; TfidfDriver . idfchecker ( results ) ; lmDrillModel = new LMDrillModel ( 0 , tablename , TfidfDriver . getToplist ( ) ) ; } } catch ( ClassNotFoundException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return lmDrillModel ; }
va	6	private boolean dijkstra ( V s , V g ) { if ( s == null ) { return false ; } initTable ( ) ; List < V > candidates = new ArrayList < V > ( ) ; distance . put ( s , 0.0 ) ; candidates . add ( s ) ; while ( ! candidates . isEmpty ( ) ) { V v = getMinVertex ( candidates ) ; candidates . remove ( v ) ; if ( v == g ) { return true ; } for ( V w : graph . getAdjacentVertexList ( v ) ) { if ( double . isInfinite ( distance . get ( w ) ) ) { candidates . add ( w ) ; } if ( ( distance . get ( v ) + graph . getWeight ( v , w ) ) < distance . get ( w ) . doubleValue ( ) ) { prevVertex . put ( w , v ) ; distance . put ( w , distance . get ( v ) + graph . getWeight ( v , w ) ) ; } } } startVertex = s ; return true ; }
va	9X	public Tariff getTariffForDate ( Date start , Date end ) { int price = 0 ; if ( BedTariff . size ( ) > 0 && ( start . after ( BedTariff . get ( 0 ) . getStartDate ( ) ) || start . equals ( BedTariff . get ( 0 ) . getStartDate ( ) ) ) ) { for ( Tariff tr : BedTariff ) { if ( tr . getEndDate ( ) != null && start . after ( tr . getEndDate ( ) ) ) { continue ; } if ( tr . getEndDate ( ) == null || end . before ( tr . getEndDate ( ) ) || end . equals ( tr . getEndDate ( ) ) ) { if ( start . after ( tr . getStartDate ( ) ) || start . equals ( tr . getStartDate ( ) ) ) { price += ( tr . getPrice ( ) * GenericUtility . getDiffDays ( end , start ) ) ; } else { price += ( tr . getPrice ( ) * GenericUtility . getDiffDays ( end , tr . getStartDate ( ) ) ) ; } return new Tariff ( new Integer ( price ) , start , end ) ; } else { if ( start . after ( tr . getStartDate ( ) ) ) { price += ( ( GenericUtility . getDiffDays ( tr . getEndDate ( ) , start ) + 1 ) * tr . getPrice ( ) ) ; } else { price += ( ( GenericUtility . getDiffDays ( tr . getEndDate ( ) , tr . getStartDate ( ) ) + 1 ) * tr . getPrice ( ) ) ; } } } } return null ; }
va	7	@ Override public void putChar ( char c ) throws ParsingException { switch ( c ) { case Characters . SPACE : context . putSpace ( ) ; break ; case Characters . SEPARATOR : context . putSeparator ( ) ; break ; case Characters . END : context . putEnd ( ) ; break ; case Characters . PARAMETER : context . putParameter ( ) ; break ; case Characters . SUB_ID : context . putSubId ( ) ; break ; case Characters . TAB : context . putTab ( ) ; break ; case Characters . NEWLINE : context . putNewLine ( ) ; ++ rowNum ; colNum = 0 ; break ; default : context . putChar ( c ) ; break ; } postProcess ( c ) ; }
va	8	public boolean postMortem ( PostMortem pm ) { Node that = ( Node ) pm ; if ( that == null ) { JSONzip . log ( "\nMisalign" ) ; return false ; } if ( this . integer != that . integer ) { JSONzip . log ( "\nInteger " + this . integer + " <> " + that . integer ) ; return false ; } if ( this . next == null ) { if ( that . next == null ) { return true ; } JSONzip . log ( "\nNext is null " + this . integer ) ; return false ; } for ( int i = 0 ; i < 256 ; i += 1 ) { Node node = this . next [ i ] ; if ( node != null ) { if ( ! node . postMortem ( that . next [ i ] ) ) { return false ; } } else if ( that . next [ i ] != null ) { JSONzip . log ( "\nMisalign " + i ) ; return false ; } } return true ; }
va	8	@ Override public void keyPressed ( KeyEvent e ) { traceKeyEvents ( e ) ; switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_LEFT : case KeyEvent . VK_NUMPAD4 : case KeyEvent . VK_A : deltaX -- ; xPosition = xPosition + deltaX ; if ( xPosition < 0 ) xPosition = canvasWidth ; repaint ( ) ; break ; case KeyEvent . VK_RIGHT : case KeyEvent . VK_NUMPAD6 : case KeyEvent . VK_D : deltaX ++ ; xPosition = xPosition + deltaX ; if ( xPosition > canvasWidth ) xPosition = 0 ; repaint ( ) ; break ; } }
va	1	public final void setHeight ( BoundSize size ) { this . height = size != null ? size : BoundSize . NULL_SIZE ; }
va	4	public void hurt ( double amount , Entity entity ) { if ( entity instanceof Player ) { Player player = ( Player ) entity ; player . lives -= amount ; if ( player . lives <= 0 ) { player . die ( ) ; } } else if ( entity instanceof Mob ) { Mob mob = ( Mob ) entity ; mob . lives -= amount ; if ( mob . lives - amount <= 0 ) die ( mob ) ; } }
va	2	private int max ( T [ ] array , int leftIndex , int rightIndex ) { int maxIndex = leftIndex ; for ( int i = leftIndex + 1 ; i <= rightIndex ; i ++ ) { if ( array [ i ] . compareTo ( array [ maxIndex ] ) > 0 ) { maxIndex = i ; } } return maxIndex ; }
va	5	public void close ( ) { if ( ! saved ) { int choice = JOptionPane . showConfirmDialog ( this , "Modifications have been done. Do you want to save ?" , "Last Warning" , JOptionPane . INFORMATION_MESSAGE , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( choice == 0 ) { JFileChooser FCdialog = new JFileChooser ( ) ; int opt = FCdialog . showSaveDialog ( this ) ; if ( opt == JFileChooser . APPROVE_OPTION ) { try { BufferedWriter out = new BufferedWriter ( new FileWriter ( FCdialog . getSelectedFile ( ) . getPath ( ) ) ) ; out . write ( this . textPane . getText ( ) ) ; out . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } this . dispose ( ) ; } } else if ( choice == 1 ) { this . dispose ( ) ; } } else this . dispose ( ) ; }
va	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
va	3	AbstractNode type ( ) { AbstractNode node = null ; if ( test ( IDENT ) ) { node = constIdent ( ) ; } else if ( test ( ARRAY ) ) { node = arrayType ( ) ; } else if ( test ( RECORD ) ) { node = recordType ( ) ; } else { failExpectation ( "type" ) ; } return node ; }
va	8	private PhoneId initPhoneIdParams ( ) { if ( CUSTOMER_ID . isEmpty ( ) || SECRET_KEY . isEmpty ( ) ) { fail ( "CUSTOMER_ID and SECRET_KEY must be set to pass this test" ) ; } PhoneId pid ; if ( ! timeouts && ! isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY ) ; else if ( timeouts && ! isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , connectTimeout , readTimeout ) ; else if ( ! timeouts && isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , HTTPS_PROTOCOL ) ; else pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , connectTimeout , readTimeout , HTTPS_PROTOCOL ) ; return pid ; }
va	8	@ Override protected byte [ ] packFrameData ( ) { byte [ ] bytes = new byte [ getLength ( ) ] ; if ( description != null ) bytes [ 0 ] = description . getTextEncoding ( ) ; else bytes [ 0 ] = 0 ; int mimeTypeLength = 0 ; if ( mimeType != null && mimeType . length ( ) > 0 ) { mimeTypeLength = mimeType . length ( ) ; try { BufferTools . stringIntoByteBuffer ( mimeType , 0 , mimeTypeLength , bytes , 1 ) ; } catch ( UnsupportedEncodingException e ) { } } int marker = mimeTypeLength + 1 ; bytes [ marker ++ ] = 0 ; bytes [ marker ++ ] = pictureType ; if ( description != null && description . toBytes ( ) . length > 0 ) { byte [ ] descriptionBytes = description . toBytes ( true , true ) ; BufferTools . copyIntoByteBuffer ( descriptionBytes , 0 , descriptionBytes . length , bytes , marker ) ; marker += descriptionBytes . length ; } else { bytes [ marker ++ ] = 0 ; } if ( imageData != null && imageData . length > 0 ) { BufferTools . copyIntoByteBuffer ( imageData , 0 , imageData . length , bytes , marker ) ; } return bytes ; }
va	1	public boolean execute ( CommandSender sender , String [ ] args ) { String status = PlayerState . get ( ( Player ) sender ) . toggleBypassMode ( ) ? "enabled" : "disabled" ; sendMessage ( sender , ChatColor . GREEN , "Bypass mode %s" , status ) ; return true ; }
va	5	@ Override public void update ( ) { for ( Modifier mod : mods ) { if ( mod . getDuration ( ) > 0 ) { mod . setDuration ( mod . getDuration ( ) - 1 ) ; if ( mod . isAdditive ( ) ) { mod . setTotal ( mod . getTotal ( ) + mod . getAmount ( ) ) ; curValue += mod . getAmount ( ) ; } } else if ( mod . getDuration ( ) <= 0 ) { if ( mod . isTemporary ( ) ) { curValue -= mod . getTotal ( ) ; } mods . remove ( mod ) ; } } }
va	8	public static boolean checkSudokuSolution ( int [ ] [ ] grid , int subSquareSize ) { final int size = grid . length ; if ( ! checkValues ( grid , 1 , size ) ) { return false ; } for ( int row = 0 ; row < size ; ++ row ) { if ( ! checkRow ( grid , row ) ) { return false ; } } for ( int col = 0 ; col < size ; ++ col ) { if ( ! checkColumn ( grid , col ) ) { return false ; } } for ( int baseRow = 0 ; baseRow < size ; baseRow += subSquareSize ) { for ( int baseCol = 0 ; baseCol < size ; baseCol += subSquareSize ) { if ( ! checkSquare ( grid , baseRow , baseCol , subSquareSize ) ) { return false ; } } } return true ; }
va	5	public static void main ( String [ ] args ) throws Exception { System . out . println ( "***************************************************" ) ; System . out . println ( "  Using Hybrid MapReduce 3D Convex Hull Algorithm  " ) ; System . out . println ( "***************************************************" ) ; int count = 0 ; long CurrentCount = - 3 ; long PreviousCount = - 6 ; boolean FastPass = false ; String TempDir1 = "/input" ; String TempDir2 = "/QH" ; while ( CurrentCount != PreviousCount ) { count ++ ; PreviousCount = CurrentCount ; System . out . println ( "***************************************************" ) ; System . out . println ( "Hybird MapReduce 3D Convex Hull Iteration >> " + count ) ; System . out . println ( "***************************************************" ) ; JobConf conf7 = new JobConf ( ) ; conf7 . setInt ( "n.lines.records.token" , 100 ) ; conf7 . setNumTasksToExecutePerJvm ( - 1 ) ; Job job7 = new Job ( conf7 , "QH" ) ; job7 . setJarByClass ( HMR3DConvexHull . class ) ; job7 . setMapperClass ( QHMapper . class ) ; job7 . setInputFormatClass ( NLinesInputFormat . class ) ; job7 . setReducerClass ( QHReducer . class ) ; job7 . setMapOutputKeyClass ( Text . class ) ; job7 . setMapOutputValueClass ( Text . class ) ; FileInputFormat . addInputPath ( job7 , new Path ( TempDir1 ) ) ; FileOutputFormat . setOutputPath ( job7 , new Path ( TempDir2 ) ) ; job7 . waitForCompletion ( true ) ; if ( count != 1 ) { FileSystem fs = FileSystem . get ( new Configuration ( ) ) ; fs . delete ( new Path ( "hdfs://192.168.0.206:9000" + TempDir1 + "/" ) , true ) ; } TempDir1 = TempDir2 ; TempDir2 = "/QH" + "-" + count ; org . apache . hadoop . mapreduce . Counters counters = job7 . getCounters ( ) ; long OutputRec = counters . findCounter ( "org.apache.hadoop.mapred.Task$Counter" , "REDUCE_OUTPUT_RECORDS" ) . getValue ( ) ; CurrentCount = OutputRec ; if ( ( OutputRec <= 10000000 ) && ( OutputRec != 0 ) ) { FastPass = true ; break ; } } if ( FastPass == true ) { JobConf conf8 = new JobConf ( ) ; conf8 . setInt ( "n.lines.records.token" , 1 ) ; conf8 . setNumTasksToExecutePerJvm ( - 1 ) ; Job job8 = new Job ( conf8 , "FinalQH" ) ; job8 . setJarByClass ( HMR3DConvexHull . class ) ; job8 . setMapperClass ( FinalQHMapper . class ) ; job8 . setInputFormatClass ( NLinesInputFormat . class ) ; job8 . setReducerClass ( FinalQHReducer . class ) ; job8 . setMapOutputKeyClass ( Text . class ) ; job8 . setMapOutputValueClass ( Text . class ) ; FileInputFormat . addInputPath ( job8 , new Path ( TempDir1 ) ) ; FileOutputFormat . setOutputPath ( job8 , new Path ( "/Convex-Hull-Faces" ) ) ; job8 . waitForCompletion ( true ) ; } else { System . out . println ( "Sorry !!! The data set is too big !!! Try to increase the threshold." ) ; } }
va	9X	public void update ( List < Zombie > targets ) { if ( this . isAlive ( ) ) { { synchronized ( this . particles ) { if ( ! this . particles . isEmpty ( ) ) { Iterator < Particle > it = this . particles . iterator ( ) ; while ( it . hasNext ( ) ) { Particle p = it . next ( ) ; p . update ( ) ; if ( ! p . isAlive ( ) || p . outOfBounds ( ) ) { it . remove ( ) ; continue ; } } } } } { if ( ! targets . isEmpty ( ) ) { double xD = 1000 ; double yD = 1000 ; double dist = Math . sqrt ( ( xD * xD ) + ( yD * yD ) ) ; if ( this . target != null ) { xD = this . target . x - this . x ; yD = this . target . y - this . y ; dist = Math . sqrt ( ( xD * xD ) + ( yD * yD ) ) ; } synchronized ( targets ) { Iterator < Zombie > it = targets . iterator ( ) ; while ( it . hasNext ( ) ) { Zombie z = it . next ( ) ; double xD2 = z . x - this . x ; double yD2 = z . y - this . y ; double dist2 = Math . sqrt ( ( xD2 * xD2 ) + ( yD2 * yD2 ) ) ; if ( ( ! z . isDead ( ) && ( dist2 < dist ) ) && ( dist2 <= Turret . ATTACK_RADIUS ) ) { this . target = z ; } } } if ( this . target != null ) { this . theta = Math . atan2 ( ( this . y - this . target . y ) , ( this . x - this . target . x ) ) - ( Math . PI / 2 ) ; } } } if ( ( this . target != null ) && ( this . target . isDead ( ) ) ) this . target = null ; if ( this . target != null ) this . fire ( ) ; } }
va	6	public static Pattern times ( Pattern pattern , int n , boolean grammar ) { if ( n <= 0 ) throw new IllegalArgumentException ( "n <= 0" ) ; if ( n == 1 ) return pattern ; if ( ! grammar ) { if ( pattern . root . isNullable ( ) ) throw new IllegalArgumentException ( "Loop body may accept the empty string" ) ; SeqNode seqNode = new SeqNode ( pattern . root . copy ( ) , pattern . root . copy ( ) ) ; while ( n -- > 2 ) seqNode = new SeqNode ( pattern . root . copy ( ) , seqNode ) ; return new Pattern ( seqNode , pattern . refs ) ; } Pattern ref = ref ( "p" ) ; Pattern refs = seq ( ref , ref ) ; for ( int i = 2 ; i < n ; ++ i ) refs = seq ( refs , ref ) ; return grammar ( new Rule ( "c" , refs ) , new Rule ( "p" , pattern ) ) ; }
va	0	@ Override public int length ( ) { return contents . length ( ) ; }
va	2	public FileChooseElement ( final FileChooser fileChooser ) { init ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent actionEvent ) { if ( mChosenFile . get ( ) != null ) fileChooser . setInitialDirectory ( mChosenFile . get ( ) . toFile ( ) . getParentFile ( ) ) ; File chosen = fileChooser . showSaveDialog ( getScene ( ) . getWindow ( ) ) ; if ( chosen != null ) setChosenFile ( chosen . toPath ( ) ) ; } } ) ; }
va	9X	void moveDown ( int i , boolean min ) { int size = heap . size ( ) ; while ( i < size ) { int p = highDescendant ( i , min ) ; if ( p < 0 ) { return ; } int cmp = compare ( heap . get ( p ) , heap . get ( i ) ) ; if ( i == grandParent ( p ) ) { if ( min ? cmp < 0 : cmp > 0 ) { swap ( i , p ) ; int pr = parent ( p ) ; int c = compare ( heap . get ( p ) , heap . get ( pr ) ) ; if ( min ? c > 0 : c < 0 ) { swap ( p , pr ) ; } } } else { if ( min ? cmp < 0 : cmp > 0 ) { swap ( i , p ) ; return ; } } i = p ; } }
va	7	private void editButtonActionPerformed ( java . awt . event . ActionEvent evt ) { RBGoodsController . Row row = controller . getRow ( goodsTable . getSelectedRow ( ) ) ; if ( row == null ) { return ; } if ( row . rowtype == RBGoodsController . ROWTYPE . CATEGORY ) { CategoryPanel panel = new CategoryPanel ( row . category ) ; ValidationPanel validationPanel = new ValidationPanel ( panel . getValidationGroup ( ) ) ; validationPanel . setInnerComponent ( panel ) ; if ( validationPanel . showOkCancelDialog ( "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0438" ) ) { try { row . category = panel . getCategory ( ) ; controller . updateRow ( row ) ; } catch ( SQLException ex ) { Exceptions . printStackTrace ( ex ) ; } } } else if ( row . article != null ) { try { ArticlePanel panel = new ArticlePanel ( row . article ) ; ValidationPanel validationPanel = new ValidationPanel ( panel . getValidationGroup ( ) ) ; validationPanel . setInnerComponent ( panel ) ; if ( validationPanel . showOkCancelDialog ( "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0430\u0440\u0442\u0438\u043A\u0443\u043B\u0430" ) ) { row . article = panel . getArticle ( ) ; controller . updateRow ( row ) ; } } catch ( SQLException ex ) { Exceptions . printStackTrace ( ex ) ; } } }
va	0	public DefensaTerrestre ( JLabel panel , CampoMatriz [ ] [ ] matriz , ArrayList < Guerrero > ejercito , int vida , String mainImg , int alcance , int daño ) { super ( panel , matriz , ejercito , vida , mainImg , alcance , daño ) ; }
va	2	@ Override public List < Service > getAllServices ( String clusterName ) { ServiceList serviceItems = http . get ( SERVICES_URL , ServiceList . class , clusterName ) ; if ( serviceItems == null || serviceItems . getItems ( ) == null ) { return new ArrayList < Service > ( ) ; } return serviceItems . getItems ( ) ; }
va	8	public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( "VALUE(" ) . append ( value ) . append ( ")" ) ; break ; case TYPE_LEFT_BRACE : sb . append ( "LEFT BRACE({)" ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( "RIGHT BRACE(})" ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( "LEFT SQUARE([)" ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( "RIGHT SQUARE(])" ) ; break ; case TYPE_COMMA : sb . append ( "COMMA( )" ) ; break ; case TYPE_COLON : sb . append ( "COLON(:)" ) ; break ; case TYPE_EOF : sb . append ( "END OF FILE" ) ; break ; } return sb . toString ( ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Config ( ) . setVisible ( true ) ; } } ) ; }
va	9X	public static void setRotateM ( float [ ] rm , int rmOffset , float a , float x , float y , float z ) { rm [ rmOffset + 3 ] = 0 ; rm [ rmOffset + 7 ] = 0 ; rm [ rmOffset + 11 ] = 0 ; rm [ rmOffset + 12 ] = 0 ; rm [ rmOffset + 13 ] = 0 ; rm [ rmOffset + 14 ] = 0 ; rm [ rmOffset + 15 ] = 1 ; a *= ( float ) ( Math . PI / 180.0f ) ; float s = ( float ) Math . sin ( a ) ; float c = ( float ) Math . cos ( a ) ; if ( 1.0f == x && 0.0f == y && 0.0f == z ) { rm [ rmOffset + 5 ] = c ; rm [ rmOffset + 10 ] = c ; rm [ rmOffset + 6 ] = s ; rm [ rmOffset + 9 ] = - s ; rm [ rmOffset + 1 ] = 0 ; rm [ rmOffset + 2 ] = 0 ; rm [ rmOffset + 4 ] = 0 ; rm [ rmOffset + 8 ] = 0 ; rm [ rmOffset + 0 ] = 1 ; } else if ( 0.0f == x && 1.0f == y && 0.0f == z ) { rm [ rmOffset + 0 ] = c ; rm [ rmOffset + 10 ] = c ; rm [ rmOffset + 8 ] = s ; rm [ rmOffset + 2 ] = - s ; rm [ rmOffset + 1 ] = 0 ; rm [ rmOffset + 4 ] = 0 ; rm [ rmOffset + 6 ] = 0 ; rm [ rmOffset + 9 ] = 0 ; rm [ rmOffset + 5 ] = 1 ; } else if ( 0.0f == x && 0.0f == y && 1.0f == z ) { rm [ rmOffset + 0 ] = c ; rm [ rmOffset + 5 ] = c ; rm [ rmOffset + 1 ] = s ; rm [ rmOffset + 4 ] = - s ; rm [ rmOffset + 2 ] = 0 ; rm [ rmOffset + 6 ] = 0 ; rm [ rmOffset + 8 ] = 0 ; rm [ rmOffset + 9 ] = 0 ; rm [ rmOffset + 10 ] = 1 ; } else { float len = length ( x , y , z ) ; if ( 1.0f != len ) { float recipLen = 1.0f / len ; x *= recipLen ; y *= recipLen ; z *= recipLen ; } float nc = 1.0f - c ; float xy = x * y ; float yz = y * z ; float zx = z * x ; float xs = x * s ; float ys = y * s ; float zs = z * s ; rm [ rmOffset + 0 ] = x * x * nc + c ; rm [ rmOffset + 4 ] = xy * nc - zs ; rm [ rmOffset + 8 ] = zx * nc + ys ; rm [ rmOffset + 1 ] = xy * nc + zs ; rm [ rmOffset + 5 ] = y * y * nc + c ; rm [ rmOffset + 9 ] = yz * nc - xs ; rm [ rmOffset + 2 ] = zx * nc - ys ; rm [ rmOffset + 6 ] = yz * nc + xs ; rm [ rmOffset + 10 ] = z * z * nc + c ; } }
va	8	public Object execute ( String sql , Object [ ] params , ResultSetExtractor extractor ) throws RemoteException { checkStarted ( ) ; PreparedStatement ps = null ; ResultSet rs = null ; try { ps = getConnection ( ) . prepareStatement ( sql ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; ++ i ) { Object o = params [ i ] ; if ( o == null ) ps . setNull ( ( i + 1 ) , Types . null ) ; else ps . setObject ( ( i + 1 ) , params [ i ] ) ; } } rs = ps . executeQuery ( ) ; return extractor . extract ( rs ) ; } catch ( SQLException e ) { Logger . error ( "error while executing sql statement" , e ) ; throw new RemoteException ( "error while executing sql statement: " + e . getMessage ( ) , e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Throwable t ) { Logger . error ( "error while closing resultset" , t ) ; } } if ( ps != null ) { try { ps . close ( ) ; } catch ( Throwable t2 ) { Logger . error ( "error while closing statement" , t2 ) ; } } } }
va	6	private void stopPosition ( ) { StreamsterApiInterfaceProxy proxy = new StreamsterApiInterfaceProxy ( ) ; Position [ ] positions = new Position [ 0 ] ; try { positions = proxy . getPositions ( ) ; } catch ( RemoteException ex ) { Logger . getLogger ( JobTradeUp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } for ( Position position : positions ) { if ( position . getStatus ( ) . equalsIgnoreCase ( "OPEN" ) ) { if ( position . getPoints ( ) . compareTo ( new BigDecimal ( 3 ) ) == 0 || position . getPoints ( ) . compareTo ( new BigDecimal ( 3 ) ) == 1 ) { try { proxy . closePosition ( position . getPositionID ( ) ) ; } catch ( RemoteException ex ) { Logger . getLogger ( JobTradeUp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } } }
va	9X	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; double out = 1.0 ; int k = 1 ; if ( n > 0 ) { while ( n > 0 ) { k = 2 ; double temp = x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } else if ( n < 0 ) { n = - n ; while ( n > 0 ) { k = 2 ; double temp = 1 / x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } return out ; }
va	1	public static boolean isValidPropertyState ( String state ) { try { parsePropertyState ( state ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
va	4	static public BufferedImage cambiarColor ( BufferedImage img , Color crSeleccionado , Color crCambiar , float tolerancia ) { if ( img == null ) return null ; Color colorPixel ; for ( int i = 0 ; i < img . getWidth ( ) ; i ++ ) { for ( int j = 0 ; i < img . getHeight ( ) ; j ++ ) { colorPixel = new Color ( img . getRGB ( i , j ) ) ; if ( tolerancia > Math . sqrt ( Math . pow ( crSeleccionado . getRed ( ) - colorPixel . getRed ( ) , 2 ) + Math . pow ( crSeleccionado . getGreen ( ) - colorPixel . getGreen ( ) , 2 ) + Math . pow ( crSeleccionado . getBlue ( ) - colorPixel . getBlue ( ) , 2 ) ) ) img . setRGB ( i , j , crCambiar . getRGB ( ) ) ; } } return img ; }
va	4	public static void main ( String [ ] args ) throws IOException { if ( args . length >= 5 ) { File baseFreqFile = new File ( args [ 0 ] ) ; File sampleFreqDir = new File ( args [ 1 ] ) ; File sizeFile = new File ( args [ 2 ] ) ; File outFile = new File ( args [ 3 ] ) ; double rate = double . parseDouble ( args [ 4 ] ) ; byte mode = GREEDY_SAMPLE ; if ( args . length >= 6 ) { String modeString = args [ 5 ] ; if ( modeString . equalsIgnoreCase ( "random" ) ) { mode = RANDOM_SAMPLE ; } else if ( modeString . equalsIgnoreCase ( "greedy" ) ) { mode = GREEDY_SAMPLE ; } } ComposeSample composer = new ComposeSample ( ) ; composer . doSample ( baseFreqFile , sampleFreqDir , sizeFile , outFile , rate , mode ) ; } else { System . out . println ( "Missing parameters ... " ) ; IndexBuilder . printHelp ( ) ; } }
va	7	public void createLatinSquare ( ) { List < Integer > seed = new ArrayList < > ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) seed . add ( i ) ; Collections . shuffle ( seed ) ; Integer corner = seed . get ( 0 ) ; for ( int c = 0 ; c < maxValue ; c ++ ) { Point p = new Point ( c + 1 , 1 ) ; try { Cell cell = cells . get ( p ) ; cell . setValue ( seed . get ( c ) ) ; } catch ( CellContentException e ) { System . err . println ( "Shouldn't happen " + e ) ; } } seed . clear ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) { if ( i != corner ) { seed . add ( i ) ; } } Collections . shuffle ( seed ) ; for ( int r = 1 ; r < maxValue ; r ++ ) { Point p = new Point ( 1 , r + 1 ) ; try { Cell cell = cells . get ( p ) ; cell . setValue ( seed . get ( r - 1 ) ) ; } catch ( CellContentException e ) { System . err . println ( "Shouldn't happen " + e ) ; } } solveBruteForce ( ) ; }
va	1	public String toString ( ) { NumberFormat nf = NumberFormat . getCurrencyInstance ( Locale . US ) ; StringBuilder buffer = new StringBuilder ( ) ; if ( tipo ) { buffer . append ( nf . format ( monto ) ) . append ( " " ) . append ( fecha . getDate ( ) ) ; } else { buffer . append ( fecha . getDate ( ) ) . append ( " " ) . append ( nf . format ( monto ) ) ; } return buffer . toString ( ) ; }
va	3	@ Override public boolean overlaps ( R other ) { return other != null && ( other . contains ( start ) || other . contains ( end ) || this . contains ( other ) ) ; }
va	1	private void addShortOption ( String shortcut , String value ) throws RuntimeException { if ( ! definition . hasShortcut ( shortcut ) ) { throw new RuntimeException ( String . format ( "The \"-%s\" option does not exist." , shortcut ) ) ; } addLongOption ( definition . getOptionForShortcut ( shortcut ) . getName ( ) , value ) ; }
va	4	private HttpRequest getHttp ( HttpMethod httpMethod , StringEntity entity ) { if ( HttpMethod . post . equals ( httpMethod ) ) { HttpPost http = new HttpPost ( ) ; http . setEntity ( entity ) ; return http ; } else if ( HttpMethod . put . equals ( httpMethod ) ) { HttpPut http = new HttpPut ( ) ; http . setEntity ( entity ) ; return http ; } else if ( HttpMethod . get . equals ( httpMethod ) ) { HttpGet http = new HttpGet ( ) ; return http ; } else if ( HttpMethod . delete . equals ( httpMethod ) ) { HttpDelete http = new HttpDelete ( ) ; return http ; } return null ; }
va	1	@ Override public void run ( ) { setSpriteX ( 1 ) ; try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } setSpriteX ( 0 ) ; }
va	8	@ SuppressWarnings ( "unchecked" ) public static Iterator < Object > createIterator ( Object value , String delimiter ) { if ( value == null ) { return Collections . emptyList ( ) . iterator ( ) ; } else if ( value instanceof Iterator ) { return ( Iterator ) value ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return CastUtils . cast ( new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ( idx + 1 ) < nodeList . getLength ( ) ; } public Node next ( ) { idx ++ ; return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ) ; } else if ( value instanceof String ) { final String s = ( String ) value ; if ( s . contains ( delimiter ) ) { Scanner scanner = new Scanner ( ( String ) value ) ; scanner . useDelimiter ( delimiter ) ; return CastUtils . cast ( scanner ) ; } else { return CastUtils . cast ( new Iterator < String > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return idx + 1 == 0 && ObjectHelper . isNotEmpty ( s ) ; } public String next ( ) { idx ++ ; return s ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ) ; } } else { return Collections . singletonList ( value ) . iterator ( ) ; } }
va	2	public static void writeFile ( String pathName , List < Command > list ) { File f = new File ( pathName ) ; ObjectOutputStream oout = null ; try { oout = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( f ) ) ) ; oout . writeObject ( list ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { oout . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
va	5	public List < Vak > getVakkenVanStudent ( long studentId ) { List < Vak > vakken = new ArrayList < Vak > ( ) ; List < long > klasIds = new ArrayList < long > ( ) ; List < long > vakIds = new ArrayList < long > ( ) ; try { PreparedStatement prepareStatement = manager . prepareStatement ( "SELECT klas_id FROM leerling_klas WHERE leerling_id = ?" ) ; prepareStatement . setLong ( 1 , studentId ) ; ResultSet resultSet = prepareStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { klasIds . add ( resultSet . getLong ( 1 ) ) ; } PreparedStatement prepareStatement2 = manager . prepareStatement ( "SELECT vak_id FROM vak_klas WHERE klas_id = ?" ) ; for ( long klasId : klasIds ) { prepareStatement2 . setLong ( 1 , klasId ) ; ResultSet resultSet2 = prepareStatement2 . executeQuery ( ) ; while ( resultSet2 . next ( ) ) { vakIds . add ( resultSet2 . getLong ( 1 ) ) ; } } for ( long vakId : vakIds ) { vakken . add ( getVak ( vakId ) ) ; } return vakken ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return vakken ; } }
va	7	public boolean hasEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null || vTo == null ) { return false ; } for ( Vertex v2 : vFrom . adjacent ) { if ( v2 . vertex == vj ) { return true ; } } return false ; }
va	4	public void removeAll ( final String name ) { modified = true ; if ( name != null ) { for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { final DataField field = fields . get ( i ) ; if ( ( field . name != null ) && field . name . equals ( name ) ) { fields . remove ( i -- ) ; } } } }
va	1	public static double L2Norm ( double [ ] a ) { double result = 0.0 ; for ( double d : a ) { result += Math . pow ( d , 2 ) ; } return Math . sqrt ( result ) ; }
va	1	private static void log ( String message ) { if ( DEBUG ) { log . debug ( message ) ; } }
va	4	public GameMap parseMap ( File mapFile ) { try { reader = new BufferedReader ( new FileReader ( mapFile ) ) ; parseDimensions ( ) ; parseSpriteSheets ( ) ; parseTerrain ( ) ; parseMapLayout ( ) ; parseUnits ( ) ; parseUnitsPosition ( ) ; map . buildGraph ( ) ; scanner . close ( ) ; reader . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( mapFile + " not found" ) ; return null ; } catch ( IOException e ) { System . out . println ( "Could not read line" ) ; return null ; } catch ( InvalidTokenException e ) { System . out . println ( e . getMessage ( ) ) ; return null ; } catch ( ExpectedTokenException e ) { System . out . println ( e . getMessage ( ) ) ; return null ; } return map ; }
va	5	private void pop ( char c ) throws JSONException { if ( this . top <= 0 ) { throw new JSONException ( "Nesting error." ) ; } char m = this . stack [ this . top - 1 ] == null ? a : k ; if ( m != c ) { throw new JSONException ( "Nesting error." ) ; } this . top -= 1 ; this . mode = this . top == 0 ? d : this . stack [ this . top - 1 ] == null ? a : k ; }
va	4	private void jMenuItem3ActionPerformed ( java . awt . event . ActionEvent evt ) { try { JFileChooser fileChooser = new JFileChooser ( "E:\\" ) ; fileChooser . setMultiSelectionEnabled ( true ) ; fileChooser . showOpenDialog ( this ) ; File playList = fileChooser . getSelectedFile ( ) ; if ( playList . exists ( ) ) { ObjectInputStream inputStream = new ObjectInputStream ( new FileInputStream ( playList ) ) ; Object readObject = inputStream . readObject ( ) ; if ( readObject instanceof File [ ] ) { playFiles = ( File [ ] ) readObject ; DurationThread durationThread = new DurationThread ( playFiles ) ; ArrayList < String > durationList = durationThread . getTrackDuration ( ) ; addToTable ( playFiles , durationList , "Open" ) ; } } } catch ( IOException ex ) { Logger . getLogger ( EchoPlayer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( EchoPlayer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
va	6	public Object convertFromJAXB ( Object value ) throws Exception { if ( value instanceof JAXBDict ) { value = dictAdapter . unmarshal ( ( JAXBDict ) value ) ; } else if ( value instanceof JAXBArray ) { value = arrayAdapter . unmarshal ( ( JAXBArray ) value ) ; } else if ( value instanceof JAXBTrue ) { value = boolean . true ; } else if ( value instanceof JAXBFalse ) { value = boolean . false ; } else if ( value instanceof JAXBDate ) { JAXBDate date = ( JAXBDate ) value ; value = DatatypeConverter . parseDateTime ( date . getValue ( ) ) . getTime ( ) ; } else if ( value instanceof JAXBData ) { JAXBData data = ( JAXBData ) value ; value = DatatypeConverter . parseBase64Binary ( data . getValue ( ) ) ; } return value ; }
va	9X	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnSelectDate ) { int index = dateOfVisitcomboBox . getSelectedIndex ( ) ; currVisit = visits . get ( index ) ; prescs = parent . getHandler ( ) . getVisitPrescriptions ( visits . get ( index ) . getPatUsername ( ) , visits . get ( index ) . getDocUsername ( ) , visits . get ( index ) . getDateOfVisit ( ) ) ; model . removeAllElements ( ) ; for ( Prescription p : prescs ) { model . addElement ( p . getMedicineName ( ) ) ; } } else if ( e . getSource ( ) == btnSelect ) { String medName = ( String ) medList . getSelectedValue ( ) ; Prescription pres = new Prescription ( ) ; for ( Prescription p : prescs ) { if ( p . getMedicineName ( ) . equals ( medName ) ) { pres = p ; break ; } } int duration = pres . getDuration ( ) ; Integer monthsD = duration / 30 ; Integer daysD = duration % 30 ; Integer dosage = pres . getDosage ( ) ; medNameTextField . setText ( medName ) ; dosageTextField . setText ( dosage . toString ( ) ) ; monthsTextField . setText ( monthsD . toString ( ) ) ; daysTextField . setText ( daysD . toString ( ) ) ; Doctor doc = parent . getHandler ( ) . getDoctor ( currVisit . getDocUsername ( ) ) ; String name = "Dr. " + doc . getfName ( ) + " " + doc . getlName ( ) ; consultingDoctorTextField . setText ( name ) ; } else if ( e . getSource ( ) == btnAddToCart ) { int durationz = Integer . parseInt ( monthsTextField . getText ( ) ) * 30 + Integer . parseInt ( daysTextField . getText ( ) ) ; Prescription prescription = new Prescription ( username , consultingDoctorTextField . getText ( ) , ( String ) dateOfVisitcomboBox . getSelectedItem ( ) , medNameTextField . getText ( ) , Integer . parseInt ( dosageTextField . getText ( ) ) , durationz , "" , "No" ) ; cart . add ( prescription ) ; model2 . addElement ( prescription . getMedicineName ( ) ) ; } else if ( e . getSource ( ) == btnCheckout ) { if ( ! cart . isEmpty ( ) ) { PaymentInfoPanel pip = new PaymentInfoPanel ( parent , username , cart ) ; parent . getContentPane ( ) . add ( pip ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else { JOptionPane . showMessageDialog ( null , "Cart is Empty." ) ; } } else if ( e . getSource ( ) == btnBack ) { CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; parent . getContentPane ( ) . remove ( parent . getContentPane ( ) . getComponents ( ) . length - 1 ) ; cl . last ( parent . getContentPane ( ) ) ; } }
va	5	private Nodo borrarElemento ( V elemento , Nodo nodo ) { if ( nodo == null ) return null ; int cmp = elemento . compareTo ( nodo . elemento ) ; if ( cmp < 0 ) nodo . izquierda = borrarElemento ( elemento , nodo . izquierda ) ; else if ( cmp > 0 ) nodo . derecha = borrarElemento ( elemento , nodo . derecha ) ; else { if ( nodo . derecha == null ) return nodo . izquierda ; if ( nodo . izquierda == null ) return nodo . derecha ; Nodo t = nodo ; nodo = min ( t . derecha ) ; nodo . derecha = borrarMinimo ( t . derecha ) ; nodo . izquierda = t . izquierda ; } return nodo ; }
va	1	private void milisecondwaitnumstartOnOff ( java . awt . event . MouseEvent evt ) { if ( ckwaitnummillbefkernel . isSelected ( ) ) { boot_delay_ms . setEnabled ( true ) ; } else boot_delay_ms . setEnabled ( false ) ; boot_delay_ms . repaint ( ) ; }
va	9X	@ Override public Vector < SerializableObject > deSerialize ( ) throws Exception { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( fileName ) ; } catch ( FileNotFoundException fnfe ) { System . out . println ( "File not found.If you did not run ser option first please run it first before running deser option" ) ; return null ; } Document document = builder . parse ( fis ) ; NodeList nodeList = document . getElementsByTagName ( "DPSerialization" ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node node = nodeList . item ( i ) ; if ( node instanceof Element ) { class < ? extends SerializableObject > classDefinition = null ; Object instance = null ; Node complexTypeNode = ( ( Element ) node ) . getElementsByTagName ( "complexType" ) . item ( 0 ) ; String className = "" ; if ( complexTypeNode instanceof Element ) { Element e = ( Element ) complexTypeNode ; className = e . getAttribute ( "xsi:type" ) ; classDefinition = class . forName ( className ) . asSubclass ( SerializableObject . class ) ; instance = classDefinition . newInstance ( ) ; } NodeList childNodes = complexTypeNode . getChildNodes ( ) ; for ( int j = 0 ; j < childNodes . getLength ( ) ; j ++ ) { Node cNode = childNodes . item ( j ) ; if ( cNode instanceof Element ) { String content = cNode . getLastChild ( ) . getTextContent ( ) . trim ( ) ; Element propNode = ( Element ) cNode ; String propType = propNode . getAttribute ( "xsi:type" ) ; String propName = cNode . getNodeName ( ) ; Field field = classDefinition . getDeclaredField ( propName ) ; field . setAccessible ( true ) ; switch ( propType ) { case "xsd:int" : field . setInt ( instance , Integer . parseInt ( content ) ) ; break ; case "xsd:string" : field . set ( instance , content ) ; break ; case "xsd:double" : field . setDouble ( instance , double . parseDouble ( content ) ) ; break ; case "xsd:long" : field . setLong ( instance , long . parseLong ( content ) ) ; break ; case "xsd:char" : if ( content . length ( ) > 1 ) { System . out . println ( "character should be of length only 1" ) ; return null ; } field . setChar ( instance , content . charAt ( 0 ) ) ; } } } deSerList . add ( ( SerializableObject ) instance ) ; } } return deSerList ; }
va	4	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPathLimit ) { ASPathLimit a = ( ASPathLimit ) o ; return this . limit == a . limit && this . origAS . equals ( a . origAS ) ; } return false ; }
va	8	private int compareHands ( String hand1 , String hand2 ) { int r1 = ( int ) ( hand1 . charAt ( 0 ) ) - 48 , r2 = ( int ) ( hand2 . charAt ( 0 ) ) - 48 ; if ( r1 > r2 ) { return 1 ; } else if ( r2 > r1 ) { return 2 ; } if ( r1 == 9 ) { return ( r2 == 9 ) ? 0 : 1 ; } else if ( r2 == 9 ) { return 2 ; } int hand_length = hand1 . length ( ) - 1 ; for ( int i = 1 ; i <= hand_length ; ++ i ) { if ( Card . getRank ( hand1 . charAt ( i ) ) > Card . getRank ( hand2 . charAt ( i ) ) ) { return 1 ; } else if ( Card . getRank ( hand1 . charAt ( i ) ) < Card . getRank ( hand2 . charAt ( i ) ) ) { return 2 ; } } return 0 ; }
va	6	public static void main ( final String [ ] args ) { int value = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( i == 6 || i == 28 || i == 496 || i == 8128 ) continue ; if ( isAmicable ( i ) ) { value += i ; } } System . out . println ( value ) ; uptime ( ) ; }
va	2	@ Override public int hashCode ( ) { int result ; long temp ; temp = re != + 0.0d ? double . doubleToLongBits ( re ) : 0 ; result = ( int ) ( temp ^ ( temp >>> 32 ) ) ; temp = im != + 0.0d ? double . doubleToLongBits ( im ) : 0 ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; return result ; }
va	2	@ Override public void run ( ) { while ( this . Console . isVisible ( ) ) { try { this . Console . ConsoleArea . setCaretPosition ( this . Console . ConsoleArea . getDocument ( ) . getLength ( ) ) ; } catch ( IllegalArgumentException e ) { this . Console . ConsoleArea . SetText ( "" ) ; this . Console . ConsoleArea . setCaretPosition ( 0 ) ; } } }
va	4	private Node getNext ( Node u ) { if ( u . right == null ) { Node n = u ; do { u = n ; n = n . parent ; if ( n == null ) return null ; } while ( u == n . right ) ; return n ; } Node n = u . right ; while ( n . left != null ) n = n . left ; return n ; }
va	2	public void create ( Announcements transientInstance ) { log . debug ( "creating " + entitySimpleName + " instance" ) ; try { super . create ( transientInstance ) ; log . debug ( "creating " + entitySimpleName + " successful" ) ; } catch ( EntityAlreadyExistsException ex ) { log . debug ( "creating " + entitySimpleName + " failed: " + ex . getMessage ( ) ) ; } catch ( RuntimeException re ) { log . error ( "creating " + entitySimpleName + " failed" , re ) ; throw re ; } }
va	0	public TableColumnAdjuster ( JTable table ) { this ( table , 6 ) ; }
va	1	public long getElapsedMillis ( ) { if ( running ) { return System . currentTimeMillis ( ) - start ; } return stop - start ; }
va	0	public Cliente ( ) { mascotas = new ArrayList ( ) ; }
va	1	public static int [ ] getRoutes ( int busStop ) { if ( busStop == 0 ) throw new InvalidQueryException ( "Nonexistent bus stop" ) ; return database . busDatabase . select_ids ( "route" , "path" , "bus_stop" , busStop , "" ) ; }
va	8	public String getColumnName ( int colIndex ) { String name ; int index = colIndex + firstDayOfWeek ; if ( index > Calendar . SATURDAY ) { index = Calendar . SUNDAY ; } switch ( index ) { case Calendar . SUNDAY : name = NAMES_OF_DAYS [ 0 ] ; break ; case Calendar . MONDAY : name = NAMES_OF_DAYS [ 1 ] ; break ; case Calendar . TUESDAY : name = NAMES_OF_DAYS [ 2 ] ; break ; case Calendar . WEDNESDAY : name = NAMES_OF_DAYS [ 3 ] ; break ; case Calendar . THURSDAY : name = NAMES_OF_DAYS [ 4 ] ; break ; case Calendar . FRIDAY : name = NAMES_OF_DAYS [ 5 ] ; break ; case Calendar . SATURDAY : name = NAMES_OF_DAYS [ 6 ] ; break ; default : name = "" ; } return name ; }
va	4	public void showMenu ( ) { int choice ; do { System . out . println ( ) ; System . out . println ( "ShowTimes Management" ) ; System . out . println ( "====================" ) ; System . out . println ( "1) List ShowTimes" ) ; System . out . println ( "2) Create ShowTimes" ) ; System . out . println ( "3) Manage ShowTimes" ) ; System . out . println ( "4) Back" ) ; System . out . print ( "Please enter your choice: " ) ; choice = ConsoleReader . readIntInput ( ) ; System . out . println ( ) ; switch ( choice ) { case 1 : listShowTimes ( ) ; System . out . println ( ) ; break ; case 2 : createShowTimes ( ) ; System . out . println ( ) ; break ; case 3 : manageShowTimes ( ) ; System . out . println ( ) ; break ; default : break ; } } while ( choice != 4 ) ; }
va	5	private Response httpsMultPart ( String fileParamName , String url , PostParameter [ ] params , File file , boolean authenticated ) throws TBlogException { PostMethod post = new PostMethod ( url ) ; org . apache . commons . httpclient . HttpClient client = new org . apache . commons . httpclient . HttpClient ( ) ; Part [ ] parts = null ; if ( params == null ) { parts = new Part [ 1 ] ; } else { parts = new Part [ params . length + 1 ] ; } if ( params != null ) { int i = 0 ; for ( PostParameter entry : params ) { parts [ i ++ ] = new StringPart ( entry . getName ( ) , ( String ) entry . getValue ( ) ) ; } } FilePart filePart ; try { filePart = new FilePart ( fileParamName , file . getName ( ) , file , new MimetypesFileTypeMap ( ) . getContentType ( file ) , "UTF-8" ) ; filePart . setTransferEncoding ( "binary" ) ; parts [ parts . length - 1 ] = filePart ; post . setRequestEntity ( new MultipartRequestEntity ( parts , post . getParams ( ) ) ) ; if ( authenticated ) { post . addRequestHeader ( "Authorization" , "OAuth2 " + this . oauth2AccessToken ) ; } client . executeMethod ( post ) ; Response response = new Response ( ) ; response . setResponseAsString ( post . getResponseBodyAsString ( ) ) ; response . setStatusCode ( post . getStatusCode ( ) ) ; return response ; } catch ( Exception ex ) { throw new TBlogException ( ex . getMessage ( ) , ex , - 1 ) ; } finally { post . releaseConnection ( ) ; client = null ; } }
va	0	public String getProvincia ( ) { return provincia ; }
va	0	private if ( BooleanExpression condition ) { this . condition = condition ; }
va	2	void updateStep6 ( ) { double totalBudget = lg . getBudget ( ) ; double totalExpenses = lg . getHotelBudgetSpent ( ) + lg . getExpenseSpent ( ) ; double remainingBudget = totalBudget - totalExpenses ; textPane6_TotalBudget . setText ( String . valueOf ( "$" + totalBudget ) ) ; textPane6_Spent . setText ( String . valueOf ( "$" + totalExpenses ) ) ; textPane6_Remaining . setText ( String . valueOf ( "$" + remainingBudget ) ) ; if ( lg . getGuestList ( ) . size ( ) != 0 ) { lg . setCostPerHead ( ) ; DecimalFormat df = new DecimalFormat ( "0.00" ) ; df . setGroupingUsed ( false ) ; double costPerHead = lg . getCostPerHead ( ) ; String costPerHeadStr = df . format ( costPerHead ) ; textPane6_CostPerHead . setText ( String . valueOf ( "$" + costPerHeadStr ) ) ; } if ( lg . completedExpenseFields ( ) ) chckbx6_ExpensesFinalised . setEnabled ( true ) ; chckbx6_ExpensesFinalised . setSelected ( lg . getExpenseFinalised ( ) ) ; panel6 . remove ( scrollPane6 ) ; createTable6 ( lg . getExpenseList ( ) , expensesCols ) ; }
va	9X	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Placemark" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . geometry != null && this . geometry . isDirty ( ) ) { change += this . geometry . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Placemark>\n" ; } setNotDirty ( ) ; return change ; }
va	6	public Object clone ( ) throws CloneNotSupportedException { Feature result = ( Feature ) super . clone ( ) ; if ( result . lookAt != null ) { result . lookAt = ( LookAt ) this . lookAt . clone ( ) ; result . lookAt . setParent ( result ) ; } if ( result . timePrimitive != null ) { result . timePrimitive = ( TimePrimitive ) this . timePrimitive . clone ( ) ; result . timePrimitive . setParent ( result ) ; } if ( result . styleSelector != null ) { result . styleSelector = new ArrayList ( ) ; for ( Iterator iter = this . styleSelector . iterator ( ) ; iter . hasNext ( ) ; ) { StyleSelector element = ( StyleSelector ) iter . next ( ) ; StyleSelector elementClone = ( StyleSelector ) element . clone ( ) ; elementClone . setParent ( result ) ; result . styleSelector . add ( elementClone ) ; } } if ( result . region != null ) { result . region = ( Region ) this . region . clone ( ) ; result . region . setParent ( result ) ; } if ( result . metadata != null ) { result . metadata = ( Metadata ) this . metadata . clone ( ) ; result . metadata . setParent ( result ) ; } return result ; }
va	8	public String evaluatePolicy_innerMethod ( TransferredFile policyFileToTransfer , TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { logger . writeLog ( Level . ALL , "Method evaluatePolicy_innerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = policyRiskEvaluator ( policyFileToTransfer , "" , "" , true ) ; mySQLFactory . dropWorkingViews ( gid ) ; mySQLFactory . dropWorkingTable ( gid ) ; MySQLResultsManager rs = new MySQLResultsManager ( ) ; rs . storeResult ( gid , result ) ; return result ; }
va	2	public void store ( List < StrawEventHandler > handlers ) { if ( handlers == null ) { return ; } for ( StrawEventHandler handler : handlers ) { this . store ( handler ) ; } }
va	5	@ Override public void insertAfter ( Element element , Element after , String outerBlockNames ) throws RemoteException { if ( "" . equals ( outerBlockNames . trim ( ) ) ) { confText = ReadConf ( ) ; String editconfText = BlockInsertAfter ( confText , element , after ) ; WriteConf ( editconfText ) ; WriteRemoteConf ( ) ; return ; } if ( CheckOuterBlockNames ( outerBlockNames ) ) { throw new RemoteException ( "outerBlockNames is not correct outerBlockNames =" + outerBlockNames ) ; } if ( ( null == after . toString ( ) ) || ( "" == after . toString ( ) ) ) { return ; } if ( ! outerBlockNames . contains ( ":" ) ) { outerBlockNames += ":0" ; } HashMap < String , String > objHashMap = EditCommon ( outerBlockNames ) ; String BlockText = objHashMap . get ( "blocktext" ) ; int BlockLength = Integer . parseInt ( objHashMap . get ( "blocklength" ) ) ; int nblockNameNum = Integer . parseInt ( objHashMap . get ( "nblocknamenum" ) ) ; String editBlockText = BlockInsertAfter ( BlockText , element , after ) ; String newConfText = GetPreBlockText ( confText , nblockNameNum ) + editBlockText + GetSufBlockText ( confText , nblockNameNum + BlockLength ) ; WriteConf ( newConfText ) ; WriteRemoteConf ( ) ; }
va	7	@ Override public void combine ( int [ ] rows , int [ ] columns ) { if ( isOutOfBounds ( rows , columns ) ) { return ; } int rowSpan = rows . length ; int columnSpan = columns . length ; int startRow = rows [ 0 ] ; int startColumn = columns [ 0 ] ; for ( int i = 0 ; i < rowSpan ; i ++ ) { for ( int j = 0 ; j < columnSpan ; j ++ ) { if ( ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] != 1 ) || ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] != 1 ) ) { return ; } } } for ( int i = 0 , ii = 0 ; i < rowSpan ; i ++ , ii -- ) { for ( int j = 0 , jj = 0 ; j < columnSpan ; j ++ , jj -- ) { span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] = jj ; span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] = ii ; } } span [ startRow ] [ startColumn ] [ CellSpan . COLUMN ] = columnSpan ; span [ startRow ] [ startColumn ] [ CellSpan . ROW ] = rowSpan ; }
va	2	@ Override public void onRobotUpdate ( RobotUpdateEvent e ) { if ( missile == null ) { missile = setFireMissile ( e . getPosition ( ) . - ( getPosition ( ) ) ) ; target = e . getName ( ) ; } else if ( e . getName ( ) . equals ( target ) ) { missile . setThrust ( e . getPosition ( ) . - ( missile . getPosition ( ) ) ) ; } }
va	6	public Object put ( Object key , Object value ) { Object retval = null ; if ( key != null ) { if ( key instanceof String ) { String name = ( String ) key ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { final DataField field = fields . get ( i ) ; if ( ( field . name != null ) && field . name . equals ( name ) ) { if ( value != null ) { retval = field . getObjectValue ( ) ; field . type = DataField . getType ( value ) ; field . value = DataField . encode ( value ) ; } else { retval = fields . remove ( i ) ; } modified = true ; return retval ; } } return add ( name , value ) ; } else { throw new IllegalArgumentException ( "DataFrame keys must be of type String" ) ; } } else { add ( value ) ; } return retval ; }
va	5	@ Override public boolean dispatchKeyEvent ( KeyEvent arg0 ) { if ( arg0 . getID ( ) != KeyEvent . KEY_PRESSED ) return false ; int keyPressed = arg0 . getKeyCode ( ) ; if ( keyPressed == KeyEvent . VK_U ) undoCommand ( ) ; else if ( keyPressed == KeyEvent . VK_R ) redoCommand ( ) ; else { Command c = keyToCommandMap . get ( keyPressed ) ; if ( c != null ) if ( c . execute ( ) ) saveGameState ( c ) ; } return false ; }
va	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && ObjectManager . anInt131 != plane ) { aRSImageProducer_1165 . initDrawingArea ( ) ; aTextDrawingArea_1271 . drawText ( 0 , "Loading - please wait." , 151 , 257 ) ; aTextDrawingArea_1271 . drawText ( ffffff , "Loading - please wait." , 150 , 256 ) ; aRSImageProducer_1165 . drawGraphics ( 4 , super . graphics , 4 ) ; loadingStage = 1 ; aLong824 = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int j = method54 ( ) ; if ( j != 0 && System . currentTimeMillis ( ) - aLong824 > 57e40 ) { signlink . reporterror ( myUsername + " glcfb " + isaacSeed + " " + j + " " + lowMemory + " " + decompressors [ 0 ] + " " + onDemandFetcher . getNodeCount ( ) + " " + plane + " " + anInt1069 + " " + anInt1070 ) ; aLong824 = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != anInt985 ) { anInt985 = plane ; method24 ( plane ) ; } }
va	0	private String initBuildManager ( ) { BuildManager bm = new BuildManager ( "src/com/dysnomia/build.props" ) ; return String . valueOf ( bm . getBuild ( ) ) ; }
va	1	public void openFile ( ) { try { br = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( Exception e ) { System . out . println ( "Problem occured while opening a file" ) ; System . exit ( 1 ) ; } }
va	8	public void validateLists ( ) { Iterator < Path > createdIterator = createdFiles . iterator ( ) ; while ( createdIterator . hasNext ( ) ) { if ( ! createdIterator . next ( ) . toFile ( ) . exists ( ) ) { createdIterator . remove ( ) ; } } Iterator < Path > modifiedIterator = modifiedFiles . iterator ( ) ; while ( modifiedIterator . hasNext ( ) ) { if ( ! modifiedIterator . next ( ) . toFile ( ) . exists ( ) ) { modifiedIterator . remove ( ) ; } } Iterator < RenamedFile > renamedIterator = renamedFiles . iterator ( ) ; while ( renamedIterator . hasNext ( ) ) { if ( ! renamedIterator . next ( ) . newName . toFile ( ) . exists ( ) ) { renamedIterator . remove ( ) ; } } Iterator < Path > deletedIterator = deletedFiles . iterator ( ) ; while ( deletedIterator . hasNext ( ) ) { if ( ! deletedIterator . next ( ) . toFile ( ) . exists ( ) ) { deletedIterator . remove ( ) ; } } }
va	5	private boolean load ( ) { if ( ! loc . exists ( ) ) { System . err . println ( "File " + loc . getAbsolutePath ( ) + " does not exist!" ) ; return false ; } if ( ! loc . getName ( ) . endsWith ( ".png" ) ) { System . err . println ( "File " + loc . getAbsolutePath ( ) + " is not a supported format!" ) ; return false ; } BufferedImage img = null ; try { img = ImageIO . read ( loc ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; return false ; } if ( img != null ) { size . set ( img . getWidth ( ) , img . getHeight ( ) ) ; pixels = img . getRGB ( 0 , 0 , getWidth ( ) , getHeight ( ) , pixels , 0 , getWidth ( ) ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] = pixels [ i ] & 00FFFFFF ; } } return true ; }
va	7	public static void main ( String args [ ] ) { int portNumber = 4444 ; if ( args . length < 1 ) { System . out . println ( "Usage: java MultiThreadChatServerSync <portNumber>\n" + "Now using port number=" + portNumber ) ; } else { portNumber = Integer . valueOf ( args [ 0 ] ) . intValue ( ) ; } try { serverSocket = new ServerSocket ( portNumber ) ; } catch ( IOException e ) { System . out . println ( e ) ; } while ( true ) { try { clientSocket = serverSocket . accept ( ) ; int i = 0 ; for ( i = 0 ; i < maxClientsCount ; i ++ ) { if ( threads [ i ] == null ) { threads [ i ] = new clientThread ( clientSocket , threads ) ; threads [ i ] . start ( ) ; break ; } } if ( i == maxClientsCount ) { PrintStream os = new PrintStream ( clientSocket . getOutputStream ( ) ) ; os . println ( "Server too busy. Try later." ) ; os . close ( ) ; clientSocket . close ( ) ; } } catch ( IOException e ) { System . out . println ( e ) ; } } }
va	6	private void initialize ( ) { mnButtons = new HashMap < MenuContent , JMenu > ( ) ; mnItems = new HashMap < MenuItem , JMenuItem > ( ) ; for ( final MenuContent menu : MenuContent . values ( ) ) { final JMenu mnButton = new JMenu ( Window . geti18nString ( menu . getSection ( ) ) ) ; mnButtons . put ( menu , mnButton ) ; add ( mnButton ) ; final List < MenuItem > items = menu . getItems ( ) ; for ( final MenuItem item : items ) { final JMenuItem mnItem = new ExtJMenuItem ( Window . geti18nString ( item . getName ( ) ) , parent ) ; mnItems . put ( item , mnItem ) ; mnButton . add ( mnItem ) ; try { switch ( menu ) { case FILE : mnItem . addActionListener ( new FileButtonsListener ( item ) ) ; break ; case EDIT : mnItem . addActionListener ( new EditButtonsListener ( item ) ) ; break ; case ABOUT : mnItem . addActionListener ( new AboutButtonActionListener ( ) ) ; break ; } } catch ( final IllegalParametrs e ) { e . printStackTrace ( ) ; } } } }
va	8	@ Override public void execute ( Map < String , Object > map , MainFrame frame ) { System . out . println ( "Receive Confirm Msg" + map ) ; String origin = ( String ) map . get ( "Origin" ) ; Map < String , Object > reply = ( Map < String , Object > ) Utilities . deserialize ( ( byte [ ] ) map . get ( "Content" ) ) ; boolean isConfirmed = ( boolean ) reply . get ( "Reply" ) ; Integer event = ( Integer ) reply . get ( "Event" ) ; switch ( event ) { case Event . INVITATION : case Event . INVITATION_RO : Set < String > invitee = LocalInfo . getInviteeCandidate ( ) ; String ip = ( String ) reply . get ( "IP" ) ; Integer port = ( Integer ) reply . get ( "Port" ) ; if ( invitee . contains ( ip + ":" + port ) && isConfirmed ) { invitee . remove ( ip + ":" + port ) ; LocalInfo . addPeer ( origin , new Peer ( ip , port ) ) ; } break ; case Event . KICKOUT_REQEUST : String target = ( String ) reply . get ( "Target" ) ; VoteTool . vote ( origin ) ; if ( VoteTool . isComplete ( ) ) { LocalSender . sendKickoutCommandMsg ( target . getBytes ( ) ) ; } break ; case Event . LOCK_REQUEST : VoteTool . vote ( origin ) ; if ( VoteTool . isComplete ( ) ) { LocalSender . sendLockCommandMsg ( ) ; } break ; } }
va	7	public boolean equivalentWasStartedBys ( WasStartedBy description1 , WasStartedBy description2 ) { return bothNull ( description1 , description2 ) || ( neitherNull ( description1 , description2 ) && equivalentIdentifiers ( description1 , description2 ) && equivalentAttributes ( description1 , description2 ) && equivalentEventArguments ( description1 , description2 ) && equivalentEntities ( description1 . getTrigger ( ) , description2 . getTrigger ( ) ) && equivalentActivities ( description1 . getStarted ( ) , description2 . getStarted ( ) ) && equivalentActivities ( description1 . getStarter ( ) , description2 . getStarter ( ) ) ) ; }
va	5	public int read ( int addr ) { if ( ! getBit ( addr , 12 ) && getBit ( addr , 7 ) ) { mRAM . setRS ( getBit ( addr , 9 ) ) ; mData = mRAM . read ( addr & 7F ) ; } if ( ! getBit ( addr , 12 ) && ! getBit ( addr , 7 ) ) { mData = mStella . read ( addr & 3F ) ; } if ( getBit ( addr , 12 ) ) { mData = mGame . read ( addr ) ; } return mData ; }
va	5	public void changeChunk ( Chunk newC , int n , AvaloneGLAPI glapi ) { const . debug ( "(Player:changeChunk): oldChunkX = " + currentChunk . pos . x ) ; const . debug ( "(Player:changeChunk): oldChunkY = " + currentChunk . pos . y ) ; currentChunk . playerList . remove ( this ) ; super . changeChunk ( newC , n , glapi ) ; currentChunk . playerList . add ( this ) ; const . debug ( "(Player:changeChunk): newChunkX = " + currentChunk . pos . x ) ; const . debug ( "(Player:changeChunk): newChunkY = " + currentChunk . pos . y ) ; Map . allowedToDraw = false ; if ( newC instanceof SurfaceChunk ) { const . debug ( "(Player:changeChunk): biome id = " + ( ( SurfaceChunk ) newC ) . biome ) ; } int centerX = const . tailleFenX / 2 ; int centerY = const . tailleFenY / 2 ; if ( n == 1 ) { glapi . setView ( centerX - const . tailleCase , pos . y - centerY ) ; } else if ( n == 2 ) { glapi . setView ( - centerX , pos . y - centerY ) ; } else if ( n == 3 ) { glapi . setView ( pos . x - centerX , centerY - const . tailleCase ) ; } else if ( n == 4 ) { glapi . setView ( pos . x - centerX , - centerY ) ; } }
va	0	public void setSManualCashbackStatusDescription ( String manualCashbackStatusDescription ) { sManualCashbackStatusDescription = manualCashbackStatusDescription ; }
va	0	public void setfFirst ( int fFirst ) { this . fFirst = fFirst ; }
va	3	public void addIntForKey ( String key ) { ints . add ( key ) ; if ( reference != null ) { ArrayList < GameEntity > entities = reference . getEntities ( ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { EntityState state = entities . get ( i ) . getState ( ) ; if ( this == state . getReference ( ) ) { StringToInt temp = new StringToInt ( ) ; temp . setKey ( key ) ; state . getInts ( ) . add ( temp ) ; } } } else { System . out . println ( "Major Error :: LevelContainer null :: SavedEntityState" ) ; } }
va	9X	private void _move ( double xxa , double yya , double zza ) { if ( removed ) return ; double xn = x + xxa ; double yn = y + yya ; double zn = z + zza ; if ( xn < 0 || yn < 0 || xn >= level . w * 16 || yn >= level . h * 16 || zn < 0 || zn > level . maxHeight ) { if ( zn < 0 ) z = 0 ; collide ( null , xxa , yya , zza ) ; return ; } List < Entity > entities = level . getEntities ( xn - xr , yn - yr , zn , xn + xr , yn + yr , zn + zh ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { Entity e = entities . get ( i ) ; if ( e == this ) continue ; if ( e . blocks ( this ) && blocks ( e ) ) { collide ( e , xxa , yya , zza ) ; return ; } } if ( level . wallBlocks ( xn - xr , yn - yr , zn , xn + xr , yn + yr , zn + zh ) ) { collide ( null , xxa , yya , zza ) ; return ; } x = xn ; y = yn ; z = zn ; return ; }
va	3	public static byte getWorth ( final MineType mt ) { switch ( mt ) { case COAL : return 1 ; case GOLD : return 4 ; case IRON : return 2 ; default : return 0 ; } }
va	4	private int getParticleSize ( Particle p ) { double time = p . getTime ( ) ; if ( time > 3 ) return 28 ; else if ( time > 2 ) return 20 ; else if ( time > .8 ) return 14 ; else if ( time > .4 ) return 12 ; else return 10 ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { MenuProductosCliente dialog = new MenuProductosCliente ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	9X	public void actionPerformed ( ActionEvent e ) { String act = e . getActionCommand ( ) ; if ( act . equals ( "BLUR" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.BLUR_AMOUNT" ) , 1 , 9 , 3 , 3 ) ; if ( integer != null ) applyAction ( new Blur ( integer ) ) ; return ; } if ( act . equals ( "SATURATION" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.SATURATION_AMOUNT" ) , 0 , 200 , 100 , 50 ) ; if ( integer != null ) applyAction ( new Saturation ( integer ) ) ; return ; } if ( act . equalsIgnoreCase ( "VALUE" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.VALUE_AMOUNT" ) , - 10 , 10 , 0 , 5 ) ; if ( integer != null ) applyAction ( new Value ( ( integer + 10 ) / 10.0f ) ) ; return ; } if ( act . equals ( "INVERT" ) ) { applyAction ( new Invert ( ) ) ; return ; } if ( act . equals ( "FADE" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.FADE_AMOUNT" ) , 0 , 256 , 128 , 64 ) ; if ( integer != null ) applyAction ( new Fade ( Color . BLACK , ( ( float ) integer ) / 256.0f ) ) ; return ; } }
va	7	public static Packet readPacket ( Stream s ) { try { if ( s . getInStream ( ) . available ( ) > 0 ) { int size = s . readInt ( ) ; if ( size == 0 ) return null ; Packet p ; try { byte id = s . readByte ( ) ; if ( Packet . getPacketFromId ( id ) == null ) return null ; p = Packet . getPacketFromId ( id ) . getClass ( ) . newInstance ( ) ; p . opcode = id ; p . stream = s ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; return null ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; return null ; } if ( size > 1 ) p . getPayLoad ( ) . construct ( s , size - 1 ) ; p . recieved = true ; return p ; } } catch ( IOException e ) { System . out . println ( "Stream closed!" ) ; } return null ; }
va	6	public boolean loadLevel ( int i ) { if ( i > 21 ) { if ( i == 22 || i == 43 ) pageSwitch = true ; i = ( ( i % 21 ) == 0 ) ? 21 : i % 21 ; } loadLevel ( StateUtil . getGameState ( proxy ) , i ) ; GameState state = StateUtil . getGameState ( proxy ) ; while ( state != GameState . PLAYING ) { System . out . println ( " In state:   " + state + " Try reloading..." ) ; loadLevel ( state , i ) ; try { Thread . sleep ( 12000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } state = StateUtil . getGameState ( proxy ) ; } return true ; }
va	3	private void mostrarCidades ( List < Cidades > cidades ) { while ( tmCidades . getRowCount ( ) > 0 ) { tmCidades . removeRow ( 0 ) ; } if ( cidades . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Nenhuma cidade encontrada!" , "Erro de Busca" , JOptionPane . ERROR_MESSAGE , icones . getIconeErro ( ) ) ; } else { String [ ] campos = new String [ ] { null , null , null , null } ; for ( int i = 0 ; i < cidades . size ( ) ; i ++ ) { tmCidades . addRow ( campos ) ; tmCidades . setValueAt ( cidades . get ( i ) . getCodigo ( ) , i , 0 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getNome ( ) , i , 1 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getUf ( ) , i , 2 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getDdd ( ) , i , 3 ) ; } } }
va	0	public void setE ( float e ) { this . e = e ; }
va	4	public void sortColors ( int [ ] A ) { int index0 = 0 , index1 = 0 , index2 = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == 0 ) { A [ index2 ] = 2 ; index2 ++ ; A [ index1 ] = 1 ; index1 ++ ; A [ index0 ] = 0 ; index0 ++ ; } else if ( A [ i ] == 1 ) { A [ index2 ] = 2 ; index2 ++ ; A [ index1 ] = 1 ; index1 ++ ; } else if ( A [ i ] == 2 ) { A [ index2 ] = 2 ; index2 ++ ; } } }
va	7	void refreshExcludedObstacles ( List allObstacles ) { excludedObstacles . clear ( ) ; for ( int i = 0 ; i < allObstacles . size ( ) ; i ++ ) { Obstacle o = ( Obstacle ) allObstacles . get ( i ) ; o . exclude = false ; if ( o . contains ( start ) ) { if ( o . containsProper ( start ) ) o . exclude = true ; else { } } if ( o . contains ( end ) ) { if ( o . containsProper ( end ) ) o . exclude = true ; else { } } if ( o . exclude && ! excludedObstacles . contains ( o ) ) excludedObstacles . add ( o ) ; } }
va	9X	private String getIdActivities ( final ArrayList < BeanConceptos > listConceptos , final int idConcepto ) { String condition = " AND ac.id IN  (" ; String allConceptos = "" ; if ( idConcepto == - 1 ) { for ( int i = 1 ; i < listConceptos . size ( ) ; i ++ ) { allConceptos += listConceptos . get ( i ) . id + " " ; } if ( ! allConceptos . equals ( "" ) ) { allConceptos = " (" + StringUtils . BeforeLast ( allConceptos , " " ) + ")" ; condition = " AND ac.id NOT IN  (" ; } else { allConceptos = " (-1) " ; condition = "" ; } } String SQL1 = "SELECT idActividad FROM " + client . getPlusDbName ( ) + "sgd_conceptosactividades where idConcepto=" + idConcepto ; if ( idConcepto == - 1 ) { SQL1 = "SELECT idActividad FROM " + client . getPlusDbName ( ) + "sgd_conceptosactividades where idConcepto IN " + allConceptos ; } String extracond = "" ; try { Statement st = client . getPlusDb ( ) . createStatement ( ) ; ResultSet rs1 = client . getPlusDb ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { extracond += rs1 . getInt ( "idActividad" ) + " " ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ActividadesCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( ! extracond . equals ( "" ) ) { condition += StringUtils . BeforeLast ( extracond , " " ) + ") " ; } else { condition = "" ; if ( idConcepto > 0 ) condition += "-1) " ; } return condition ; }
va	7	private String genericString ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int c = 0 ; c < value . length ( ) ; c ++ ) { Character ch = value . charAt ( c ) ; if ( ch == '' ) { buffer . append ( "\\r" ) ; } else if ( ch == '' ) { buffer . append ( "\\n" ) ; } else if ( ch == " ) { buffer . append ( "\\\"" ) ; } else if ( ch == \ ) { buffer . append ( "\\\\" ) ; } else if ( 32 <= ch && ch <= 126 ) { buffer . append ( ch ) ; } else { buffer . append ( "\\x" + String . format ( "%02x" , Math . abs ( ( int ) ch ) ) ) ; } } return buffer . toString ( ) ; }
va	3	public static JSONObject toJSONObject ( java . util . Properties properties ) throws JSONException { JSONObject jo = new JSONObject ( ) ; if ( properties != null && ! properties . isEmpty ( ) ) { Enumeration enumProperties = properties . propertyNames ( ) ; while ( enumProperties . hasMoreElements ( ) ) { String name = ( String ) enumProperties . nextElement ( ) ; jo . put ( name , properties . getProperty ( name ) ) ; } } return jo ; }
va	5	@ Override public boolean equals ( Object other ) { if ( other == null ) { return false ; } else if ( this == other ) { return true ; } else if ( ! ( other instanceof RecipeIngredient ) ) { return false ; } String ownPrefix = adjustUnitsInString ( prefix , 1 ) ; String otherPrefix = adjustUnitsInString ( ( ( RecipeIngredient ) other ) . getPrefix ( ) , 1 ) ; String ownSuffix = adjustUnitsInString ( suffix , 1 ) ; String otherSuffix = adjustUnitsInString ( ( ( RecipeIngredient ) other ) . getSuffix ( ) , 1 ) ; return ownPrefix . equals ( otherPrefix ) && ownSuffix . equals ( ( otherSuffix ) ) && ingredient . equals ( ( ( RecipeIngredient ) other ) . getIngredient ( ) ) ; }
va	3	@ Override public EditorKit getEditorKitForContentType ( String type ) { if ( type . equalsIgnoreCase ( "text/html" ) || type . equalsIgnoreCase ( "application/xhtml+xml" ) || type . equalsIgnoreCase ( "text/xhtml" ) ) { return swingBoxEditorKit ; } else { return super . getEditorKitForContentType ( type ) ; } }
va	0	public Dimension getSize ( ) { return this . size ; }
va	0	@ Test public void breadthFirstEmpty ( ) { final Iterable < String > traverser = Traversals . breadthFirst ( "A" , adjacencyFor ( empty ) ) ; assertTraversalContains ( traverser , "A" ) ; }
va	7	public void writeSetEncodings ( int preferredEncoding , boolean useCopyRect ) { int nEncodings = 0 ; int [ ] encodings = new int [ Encodings . max + 2 ] ; if ( cp . supportsLocalCursor ) encodings [ nEncodings ++ ] = Encodings . pseudoEncodingCursor ; if ( cp . supportsDesktopResize ) encodings [ nEncodings ++ ] = Encodings . pseudoEncodingDesktopSize ; if ( Decoder . supported ( preferredEncoding ) ) { encodings [ nEncodings ++ ] = preferredEncoding ; } if ( useCopyRect ) { encodings [ nEncodings ++ ] = Encodings . copyRect ; } for ( int i = Encodings . max ; i >= 0 ; i -- ) { if ( i != preferredEncoding && Decoder . supported ( i ) ) { encodings [ nEncodings ++ ] = i ; } } writeSetEncodings ( nEncodings , encodings ) ; }
va	0	public void addSpecialEntity ( String identifier , String entity ) { specialEntities . put ( entity . toLowerCase ( ) , identifier ) ; }
va	4	public static void main ( String [ ] args ) { if ( args . length == 0 ) { printUsage ( ) ; return ; } if ( ! ApplicationHelper . SHOW_ERROR ) { System . err . close ( ) ; } if ( args [ 0 ] . equals ( "train" ) ) { train ( ) ; } else if ( args [ 0 ] . equals ( "eval" ) ) { evaluate ( Arrays . asList ( args ) ) ; } else { classify ( args ) ; } }
va	5	@ Override public void actionPerformed ( ActionEvent arg0 ) { String s = ( String ) categories . getSelectedItem ( ) ; DetailsPanelController pc = DetailsPanelController . getInstance ( ) ; if ( s . equals ( "" ) ) { if ( pc . getCurrentTask ( ) != null ) { pc . getCurrentTask ( ) . setCategory ( new Category ( "" , tl . getColor ( "black" ) ) ) ; pc . updateTask ( pc . getCurrentTask ( ) ) ; } } else { for ( Category c : PanicController . getInstance ( ) . getCategories ( ) ) { if ( c . getName ( ) . equals ( s ) ) { if ( pc . getCurrentTask ( ) != null ) { pc . getCurrentTask ( ) . setCategory ( c ) ; pc . updateTask ( pc . getCurrentTask ( ) ) ; } break ; } } } }
va	0	public void setVersionName ( String value ) { this . versionName = value ; }
va	1	private void go ( ) { addHeader ( ) ; for ( int a = 1 ; a < 6 ; a ++ ) { add ( "submission" + a + ".csv" ) ; } export ( ) ; }
va	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
va	3	@ Override public boolean removeHandler ( String name ) { Handler handler = handlers_ . get ( name ) ; if ( handler == null ) { return false ; } catch_all_handlers_ . remove ( handler ) ; if ( handlers_ . remove ( name ) == null ) { return false ; } if ( handlers_ . isEmpty ( ) ) { node_ . removeHandler ( virtual_handler_ . getName ( ) ) ; } return true ; }
va	3	public int removeIf ( IntPredicate test ) { int removed = 0 ; for ( int i = 0 ; i < num ; i ++ ) { int key = keys [ i ] ; if ( test . test ( key ) ) { removed ++ ; } else if ( removed > 0 ) { keys [ i - removed ] = key ; } } num -= removed ; return removed ; }
va	5	@ Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { Channel ch = ctx . channel ( ) ; if ( ! handshaker . isHandshakeComplete ( ) ) { handshaker . finishHandshake ( ch , ( FullHttpResponse ) msg ) ; LOGGER . info ( "COSM Client connected!" ) ; return ; } if ( msg instanceof FullHttpResponse ) { FullHttpResponse response = ( FullHttpResponse ) msg ; throw new Exception ( "Unexpected FullHttpResponse (status=" + response . getStatus ( ) + ) ) ; } WebSocketFrame frame = ( WebSocketFrame ) msg ; if ( frame instanceof TextWebSocketFrame ) { TextWebSocketFrame textFrame = ( TextWebSocketFrame ) frame ; LOGGER . info ( "WebSocket Client received message: {}" , textFrame . text ( ) ) ; } else if ( frame instanceof PongWebSocketFrame ) { LOGGER . info ( "WebSocket Client received pong" ) ; } else if ( frame instanceof CloseWebSocketFrame ) { LOGGER . info ( "WebSocket Client received closing" ) ; ch . close ( ) ; } }
va	5	@ Override public int [ ] select ( Population pop , int toSelect ) { int [ ] futureParents = new int [ toSelect ] ; futureParents [ 0 ] = 0 ; futureParents [ 1 ] = 1 ; int numOfParents = 2 ; double [ ] fitnessSegments = rankPopulation ( pop ) ; double entireSegment = fitnessSegments [ fitnessSegments . length - 1 ] ; while ( numOfParents < futureParents . length ) { double x = ( double ) ( Math . random ( ) * entireSegment ) ; if ( x <= fitnessSegments [ 0 ] ) { futureParents [ numOfParents ] = 0 ; numOfParents ++ ; } else for ( int i = 1 ; i < futureParents . length ; i ++ ) if ( x > fitnessSegments [ i - 1 ] && x <= fitnessSegments [ i ] ) { futureParents [ numOfParents ] = i ; numOfParents ++ ; } } return futureParents ; }
va	0	public int getEmpNo ( ) { return empNo ; }
va	8	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnReproducir ) { reproducirMedio ( ) ; } else if ( e . getSource ( ) == btnSiguiente ) { siguiente ( ) ; } else if ( e . getSource ( ) == btnAnterior ) { anterior ( ) ; } else if ( e . getSource ( ) == btnDetener ) { detener ( ) ; } else if ( e . getSource ( ) == btnRandom ) { if ( btnRandom . isSelected ( ) ) aleatorio = true ; else aleatorio = false ; } if ( e . getSource ( ) == btnMute ) { mute = ! mute ; if ( ! mute ) { establecerVolumen ( ) ; } else { btnMute . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_VOLUMEN_MUTE_30 ) ) ) ; hiloReproduccion . cambiarVolumen ( 0 ) ; } } }
va	9X	public void handleData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct" ) ; } else { updateMoveable ( data [ i + 1 ] , data [ i + 2 ] ) ; } i = j ; break ; } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { addBomb ( data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] , data [ i + 4 ] ) ; } i = j ; break ; } } } } }
va	5	public static void addEntry ( Map < String , String > data , String tag ) { JsonObjectBuilder copyInto = null ; JsonObjectBuilder returnedObject = null ; JsonObjectBuilder mainBuilder = Json . createObjectBuilder ( ) ; try { copyInto = Json . createObjectBuilder ( ) ; FileReader fr = new FileReader ( DaemonMainController . getDatabasePath ( ) ) ; JsonReader reader = Json . createReader ( fr ) ; JsonStructure jsonst = reader . read ( ) ; switch ( jsonst . getValueType ( ) ) { case OBJECT : JsonObject obj = ( JsonObject ) jsonst ; for ( String name : obj . keySet ( ) ) { returnedObject = rewriteJson ( copyInto , jsonst , null ) ; mainBuilder . add ( name , returnedObject . build ( ) ) ; } default : break ; } } catch ( FileNotFoundException e ) { } catch ( javax . json . stream . JsonParsingException e ) { e . printStackTrace ( ) ; } JsonObjectBuilder obj = Json . createObjectBuilder ( ) ; JsonObject object = mapToJsonObject ( data . keySet ( ) . iterator ( ) , obj , data ) ; mainBuilder . add ( tag , object ) ; try { FileWriter fl = new FileWriter ( DaemonMainController . getDatabasePath ( ) ) ; JsonWriter jWriter = Json . createWriter ( fl ) ; jWriter . writeObject ( mainBuilder . build ( ) ) ; fl . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } nextID ++ ; }
va	4	private List < Player > getActivePlayers ( boolean skipSelf ) { List < Player > activePlayers = new ArrayList < > ( ) ; for ( Player player : players ) { if ( player . isActive ( ) ) { if ( skipSelf && player . getId ( ) == ownPlayer . getId ( ) ) { continue ; } activePlayers . add ( player ) ; } } return activePlayers ; }
va	9X	public static void onUserTreesChanged ( ) { userTrees = new UserTrees ( UserTrees . getUserTreesData ( ) ) ; if ( userTrees . getStatus ( ) == UserTrees . LOADED ) { switch ( currentUI ) { case NewTree : case TreeCreated : case Pearled : case InTunnel : case InSettings : return ; case TreeList : case ChooseParent : if ( TreeListUI . isClosing ) { return ; } break ; } } changeUI ( currentUI , true ) ; }
va	7	public ListPanel ( CharRecord record ) { try { this . setLayout ( new BorderLayout ( ) ) ; this . setPreferredSize ( new Dimension ( 700 , 400 ) ) ; String [ ] columnNames = { "Order" , "Pinyin" , "Chinese" , "Trad" , "English" , "Book" , "Chap" } ; int [ ] widths = loadColumnWidths ( ) ; model = new RecordTableModel ( record ) ; TableSorter sorter = new TableSorter ( model ) ; table = new JTable ( sorter ) ; sorter . setTableHeader ( table . getTableHeader ( ) ) ; TableCellRenderer renderer = new MyRenderer ( ) ; for ( int i = 0 ; i < columnNames . length ; i ++ ) { TableColumn col = table . getColumnModel ( ) . getColumn ( i ) ; col . setPreferredWidth ( widths [ i ] ) ; col . setHeaderValue ( columnNames [ i ] ) ; col . setCellRenderer ( renderer ) ; } table . setRowHeight ( ROW_HEIGHT ) ; table . getTableHeader ( ) . setResizingAllowed ( true ) ; table . getTableHeader ( ) . setReorderingAllowed ( false ) ; table . getTableHeader ( ) . setBackground ( CharApp . COLOR_BG ) ; table . setRowSelectionAllowed ( true ) ; table . setAutoCreateColumnsFromModel ( false ) ; scroller = new JScrollPane ( table ) ; scroller . getVerticalScrollBar ( ) . setBackground ( CharApp . COLOR_BG ) ; scroller . getHorizontalScrollBar ( ) . setBackground ( CharApp . COLOR_BG ) ; this . add ( scroller , BorderLayout . CENTER ) ; MouseListener ml = new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 1 && e . getButton ( ) == MouseEvent . BUTTON3 ) { Point origin = e . getPoint ( ) ; int row = table . rowAtPoint ( origin ) ; if ( row > - 1 ) { } } else if ( e . getClickCount ( ) == 2 && e . getButton ( ) == MouseEvent . BUTTON1 ) { CharApp . getInstance ( ) . editRecord ( ) ; } } } ; table . addMouseListener ( ml ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
va	7	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitVcsRoot that = ( GitVcsRoot ) o ; if ( ! localPath . equals ( that . localPath ) ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( that . repositoryUrl ) : that . repositoryUrl != null ) return false ; if ( ! settings . equals ( that . settings ) ) return false ; return true ; }
va	6	public static final int method481 ( int i , int j , int k ) { if ( i == 65535 ) return 0 ; if ( ( k & 2 ) == 2 ) { if ( j < 0 ) j = 0 ; else if ( j > 127 ) j = 127 ; j = 127 - j ; return j ; } j = j * ( i & 7f ) >> 7 ; if ( j < 2 ) j = 2 ; else if ( j > 126 ) j = 126 ; return ( i & ff80 ) + j ; }
va	3	private int getUnvisitedNode ( int [ ] [ ] adjacency_matrix , int source , int [ ] visited ) { int [ ] myNeighbors = adjacency_matrix [ source ] ; for ( int i = 0 ; i < myNeighbors . length ; i ++ ) { if ( myNeighbors [ i ] == 1 && visited [ i ] == 0 ) { return i ; } } return - 1 ; }
va	6	public void setMarker ( int marker ) { if ( marker != MARKER_HIDE && marker != MARKER_FULL_CIRCLE && marker != MARKER_HOLLOW_CIRCLE && marker != MARKER_FULL_SQUARE && marker != MARKER_HOLLOW_SQUARE ) return ; if ( marker == this . marker ) return ; this . marker = marker ; this . icon = generateImageIcon ( ) ; }
va	2	@ Override public int compare ( String o1 , String o2 ) { if ( o1 . length ( ) < o2 . length ( ) ) return 1 ; else if ( o1 . length ( ) > o2 . length ( ) ) return - 1 ; return o1 . compareTo ( o2 ) ; }
va	1	@ Override public void init ( ) { qidtf = new JTextField ( ) ; label = new JLabel ( ) ; setLayout ( new BorderLayout ( ) ) ; add ( "North" , new JLabel ( "Quest ID" ) ) ; add ( "Center" , qidtf ) ; add ( "South" , label ) ; label . setForeground ( Color . RED ) ; qidtf . getDocument ( ) . addDocumentListener ( new QuestExistsListener ( getFinishButton ( ) ) { public boolean update ( DocumentEvent e ) { boolean a = super . update ( e ) ; if ( a == false ) label . setText ( "This quest doesn't exist." ) ; else label . setText ( "" ) ; return a ; } } ) ; }
va	3	public void displayWinner ( ArrayList < JavaFestivalPlayer > players , int pointsWon ) { String names = players . get ( 0 ) . getName ( ) ; if ( players . size ( ) > 1 ) { for ( int i = 1 ; i < players . size ( ) ; i ++ ) { if ( i == ( players . size ( ) - 1 ) ) { names = names + " and " + players . get ( i ) . getName ( ) ; } else { names = names + "  " + players . get ( i ) . getName ( ) ; } } JOptionPane . showMessageDialog ( null , "Congrats! Players " + names + " have won this festival" , "End of Festival" , JOptionPane . INFORMATION_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( null , "Congrats! Player " + names + " has won this festival" , "End of Festival" , JOptionPane . INFORMATION_MESSAGE ) ; } }
va	0	public String getCourseNumber ( ) { return courseNumber ; }
va	1	@ Override public void handleDiscardPhaseCompleted ( Player winningPlayer ) { for ( GameHandler gh : gameHandlers ) { gh . handleDiscardPhaseCompleted ( winningPlayer ) ; } }
va	6	public OptionsPanel getOptionsPanel ( ) { if ( mediaPanel . hasFinished ( ) ) createMedia ( ) ; if ( type . equals ( "plain" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; optionsPanel = new OptionsPanel ( text , mediaPanel ) ; } else if ( type . equals ( "mchoice" ) || type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { String [ ] split = answers . split ( ";" ) ; MultipleChoicePanel panel = new MultipleChoicePanel ( split , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; optionsPanel = new OptionsPanel ( text , panel , mediaPanel ) ; } else if ( type . equals ( "list" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; String [ ] valueArray = values . split ( ";" ) ; String [ ] answerArray = answers . split ( ";" ) ; System . out . println ( "Create Optionspanel list" ) ; optionsPanel = new OptionsPanel ( text , answerArray , valueArray ) ; } else { System . out . println ( "failed to read file" ) ; System . exit ( 0 ) ; } return optionsPanel ; }
va	0	public Object getTree ( ) { return tree ; }
va	5	TaskControlBlock run ( Packet packet ) { if ( packet != null ) { if ( packet . kind == Richards . KIND_WORK ) { v1 = packet . addTo ( v1 ) ; } else { v2 = packet . addTo ( v2 ) ; } } if ( v1 != null ) { int count = v1 . a1 ; Packet v ; if ( count < Richards . DATA_SIZE ) { if ( v2 != null ) { v = v2 ; v2 = v2 . link ; v . a1 = v1 . a2 [ count ] ; v1 . a1 = count + 1 ; return scheduler . queue ( v ) ; } } else { v = v1 ; v1 = v1 . link ; return scheduler . queue ( v ) ; } } return scheduler . suspendCurrent ( ) ; }
va	6	private String getModelName ( TransferableModel model ) { if ( model instanceof MeetingModel ) { return "MeetingModel" ; } else if ( model instanceof ActiveUserModel ) { return "ActiveUserModel" ; } else if ( model instanceof UserModel ) { return "UserModel" ; } else if ( model instanceof MeetingRoomModel ) { return "MeetingRoomModel" ; } else if ( model instanceof InvitationModel ) { return "InvitationModel" ; } else if ( model instanceof NotificationModel ) { return "NotificationModel" ; } throw new IllegalArgumentException ( "Unknown model type passed to getModelName" + " " + model . getClass ( ) . getName ( ) ) ; }
va	1	private void log ( String message ) { if ( DEBUG ) { System . out . println ( "[" + new java . util . Date ( ) + "]" + message ) ; } }
va	3	private int lexCompare ( DNSRecord . Address that ) { byte [ ] thisBytes = this . toByteArray ( ) ; byte [ ] thatBytes = that . toByteArray ( ) ; for ( int i = 0 , n = Math . min ( thisBytes . length , thatBytes . length ) ; i < n ; i ++ ) { if ( thisBytes [ i ] > thatBytes [ i ] ) { return 1 ; } else { if ( thisBytes [ i ] < thatBytes [ i ] ) { return - 1 ; } } } return thisBytes . length - thatBytes . length ; }
va	3	@ Override public void resumeTransfer ( ) { if ( isActive ( ) ) { logger . log ( Level . SEVERE , "Can't resume an active transfer. Cancel it before" ) ; return ; } logger . log ( Level . INFO , "Resume transfer" ) ; if ( socket != null ) { logger . log ( Level . SEVERE , "Can't resume transfer if socket still exists" ) ; return ; } if ( targetFilestream == null ) { logger . log ( Level . SEVERE , "target filestream doesn't exist anymore!" ) ; transferState = TransferStatus . LocalIOError ; } refreshPartnersPort = true ; self = getCreateOwnThread ( ) ; self . start ( ) ; }
va	7	@ Test public void consistency ( ) { System . out . println ( "[UNITTEST] ***** TEST: Ontology consistency checking *****" ) ; IOntologyBackend onto = new OpenRobotsOntology ( conf ) ; BaseModule oro = new BaseModule ( onto ) ; assertTrue ( "Initial ontology should be detected as consistent!" , oro . checkConsistency ( ) ) ; try { Statement s = onto . createStatement ( "cow rdf:type Plant" ) ; onto . add ( s , MemoryProfile . default , false ) ; } catch ( IllegalStatementException e ) { fail ( "Error while adding a set of statements in testConsistency!" ) ; } assertFalse ( "Ontology should be detected as inconsistent! Cows are not plants!" , oro . checkConsistency ( ) ) ; Set < String > stmtsToRemove = new HashSet < String > ( ) ; try { stmtsToRemove . add ( "cow rdf:type Plant" ) ; oro . clear ( stmtsToRemove ) ; assertTrue ( oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( ) ; } catch ( OntologyServerException e ) { e . printStackTrace ( ) ; } try { onto . add ( onto . createStatement ( "cow climbsOn banana_tree" ) , MemoryProfile . default , false ) ; assertFalse ( "Ontology should be detected as inconsistent! Cows can not climb on banana trees because they are explicitely not monkeys!" , oro . checkConsistency ( ) ) ; stmtsToRemove . clear ( ) ; stmtsToRemove . add ( "cow climbsOn banana_tree" ) ; oro . clear ( stmtsToRemove ) ; assertTrue ( "Ontology should now be back to consistency" , oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( "Error while adding a set of statements in testConsistency!" ) ; } catch ( OntologyServerException e ) { fail ( ) ; } Set < String > updatedStmts = new HashSet < String > ( ) ; try { updatedStmts . add ( "gorilla age 12" ) ; updatedStmts . add ( "gorilla weight 100.2" ) ; oro . clear ( updatedStmts ) ; assertTrue ( "The 'clear' was not successful: a functional property has now 2 values." , oro . checkConsistency ( ) ) ; updatedStmts . clear ( ) ; updatedStmts . add ( "gorilla age 21" ) ; updatedStmts . add ( "gorilla weight 99.5" ) ; oro . add ( updatedStmts ) ; assertTrue ( "'add' shouldn't cause any inconsistency  since previous statements have been cleared." , oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( ) ; } catch ( OntologyServerException e ) { fail ( ) ; } System . out . println ( "[UNITTEST] ***** Test successful *****" ) ; }
va	6	private static boolean checkCircularity ( Node node ) { Node firstPointer = node ; Node secondPointer = node != null ? node . getNext ( ) : null ; if ( firstPointer == null || secondPointer == null ) return false ; while ( firstPointer != null && secondPointer != null ) { if ( firstPointer . equals ( secondPointer ) ) return true ; firstPointer = firstPointer . getNext ( ) ; secondPointer = secondPointer . getNext ( ) . getNext ( ) ; } return false ; }
va	9X	public void distribuerMessageConversation ( MessageConversation message ) throws RemoteException { try { ArrayList < Groupe > groupes = message . getGroupesParticipants ( ) ; ArrayList < String > utilisateursDistribues = new ArrayList < String > ( ) ; if ( groupes != null ) { for ( Groupe g : groupes ) { ArrayList < Utilisateur > utilisateurs = g . getUtilisateurs ( ) ; for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( getConversations ( ) . get ( message . getIdConversation ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } ArrayList < Utilisateur > utilisateurs = message . getParticipants ( ) ; if ( utilisateurs != null ) { for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( new Conversation ( message . getIdConversation ( ) , message . getParticipants ( ) , message . getGroupesParticipants ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } }
va	3	private void initApplicationHome ( ) { String applicationHome = System . getProperty ( "application.home" ) ; if ( applicationHome != null ) { return ; } File bootstrapJar = new File ( System . getProperty ( "user.dir" ) , "bootstrap.jar" ) ; if ( bootstrapJar . exists ( ) ) { try { File parentDir = new File ( System . getProperty ( "user.dir" ) , ".." ) ; System . setProperty ( "application.home" , parentDir . getCanonicalPath ( ) ) ; } catch ( Exception e ) { System . setProperty ( "application.home" , System . getProperty ( "user.dir" ) ) ; } } else { System . setProperty ( "application.home" , System . getProperty ( "user.dir" ) ) ; } applicationHome = System . getProperty ( "application.home" ) ; }
va	8	@ Test public void advancedDiff ( ) { System . out . println ( "[UNITTEST] ***** TEST: Complex hierarchies Diff test *****" ) ; IOntologyBackend oro = new OpenRobotsOntology ( conf ) ; Set < Set < String >> diff1 = null ; Set < Set < String >> diff2 = null ; Set < Set < String >> diff3 = null ; Set < Set < String >> diff4 = null ; Set < String > sim1 = null ; Set < String > sim2 = null ; Set < String > sim3 = null ; Set < String > sim4 = null ; CategorizationModule categorizationModule = new CategorizationModule ( oro ) ; long totalTimeDiff = 0 ; long totalTimeSim = 0 ; long startTime = System . currentTimeMillis ( ) ; try { diff1 = categorizationModule . getDifferences ( "f" , "j" ) ; diff2 = categorizationModule . getDifferences ( "f" , "k" ) ; diff3 = categorizationModule . getDifferences ( "f" , "e" ) ; diff4 = categorizationModule . getDifferences ( "f" , "f" ) ; totalTimeDiff = ( System . currentTimeMillis ( ) - startTime ) ; sim1 = categorizationModule . getSimilarities ( "f" , "j" ) ; sim2 = categorizationModule . getSimilarities ( "f" , "k" ) ; sim3 = categorizationModule . getSimilarities ( "f" , "e" ) ; sim4 = categorizationModule . getSimilarities ( "f" , "f" ) ; totalTimeSim = ( System . currentTimeMillis ( ) - startTime - totalTimeDiff ) ; } catch ( NotFoundException e ) { e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; } catch ( NotComparableException e ) { fail ( ) ; } assertTrue ( "" , diff1 . size ( ) == 2 ) ; assertTrue ( "" , diff2 . size ( ) == 2 ) ; assertTrue ( "" , diff3 . size ( ) == 1 ) ; assertTrue ( "" , diff4 . isEmpty ( ) ) ; assertTrue ( "" , sim1 . size ( ) == 2 && sim1 . contains ( "? rdf:type B" ) && sim1 . contains ( "? rdf:type D" ) ) ; assertTrue ( "" , sim2 . size ( ) == 2 && sim2 . contains ( "? rdf:type B" ) && sim2 . contains ( "? rdf:type D" ) ) ; assertTrue ( "" , sim3 . size ( ) == 1 && sim3 . contains ( "? rdf:type E" ) ) ; assertTrue ( "" , sim4 . size ( ) == 1 && sim4 . contains ( "? rdf:type F" ) ) ; System . out . println ( "[UNITTEST] ***** Average time per differences comparison:" + totalTimeDiff / 4 + "ms" ) ; System . out . println ( "[UNITTEST] ***** Average time per similarities comparison:" + totalTimeSim / 4 + "ms" ) ; System . out . println ( "[UNITTEST] ***** Test successful *****" ) ; }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int p0 ; int [ ] p1 ; p0 = 6 ; p1 = new int [ ] { 2 , 2 , 2 } ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = 11 ; p1 = new int [ ] { 2 , 3 , 5 } ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = 0 ; p1 = new int [ ] { 7 , 10 , - 70 } ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = 500 ; p1 = new int [ ] { - 400 , - 3 , - 700 } ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = 2 ; p1 = new int [ ] { 2 , 2 , - 2 } ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = 5 ; p1 = new int [ ] { 5 , 2 , - 5 } ; all_right = KawigiEdit_RunTest ( 5 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	9X	public static boolean process ( Connection dbConnection , FileTypeProcessReturnInfo returnVal , java . io . File source , java . io . File workingDir , List < ImageFormat > formats , ImageMagickFormat inputFormat , ImageMagickFormat outputFormat , File file , FileType outputFileType ) { BigInteger totalSize = BigInteger . ZERO ; for ( ImageFormat f : formats ) { logger . debug ( "Executing ImageMagick to process image file for source file with width " + f . w + " and height " + f . h + "." ) ; int exitVal = ImageProcessorHelper . renderImage ( inputFormat , outputFormat , source , f . outputFile , workingDir , f . w , f . h ) ; if ( exitVal != 0 ) { logger . warn ( "ImageMagick finished processing image but returned error code " + exitVal + "." ) ; returnVal . msg = "Error processing image." ; return false ; } totalSize . add ( new BigInteger ( "" + f . outputFile . length ( ) ) ) ; if ( FileHelper . isOverQuota ( totalSize ) ) { returnVal . msg = "Ran out of space." ; return false ; } } DbHelper . updateStatus ( dbConnection , file . getId ( ) , "Finalizing." , null ) ; ArrayList < OutputFile > outputFiles = new ArrayList < OutputFile > ( ) ; try { for ( ImageFormat f : formats ) { long size = f . outputFile . length ( ) ; logger . debug ( "Creating file record for render with height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO files (in_use created_at updated_at size file_type_id source_file_id heartbeat process_state) VALUES(0 ? ? ? ? ? ? 1)" , Statement . RETURN_GENERATED_KEYS ) ; s . setTimestamp ( 1 , currentTimestamp ) ; s . setTimestamp ( 2 , currentTimestamp ) ; s . setLong ( 3 , size ) ; s . setInt ( 4 , outputFileType . getObj ( ) . getId ( ) ) ; s . setInt ( 5 , file . getId ( ) ) ; s . setTimestamp ( 6 , currentTimestamp ) ; if ( s . executeUpdate ( ) != 1 ) { s . close ( ) ; logger . warn ( "Error occurred when creating database entry for a file." ) ; return false ; } ResultSet generatedKeys = s . getGeneratedKeys ( ) ; generatedKeys . next ( ) ; int id = generatedKeys . getInt ( 1 ) ; s . close ( ) ; File newFile = new File ( id , null , size , outputFileType . getObj ( ) ) ; logger . debug ( "File record created with id " + id + " for image render with width " + f . w + " and height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; if ( ! returnVal . registerNewFile ( newFile ) ) { logger . warn ( "Error trying to register newly created file." ) ; return false ; } ImageMagickFileInfo info = ImageMagickHelper . getFileInfo ( inputFormat , f . outputFile , workingDir ) ; if ( info == null ) { logger . warn ( "Error retrieving info for file rendered from source file with id " + file . getId ( ) + "." ) ; return false ; } outputFiles . add ( new OutputFile ( id , info . getW ( ) , info . getH ( ) ) ) ; logger . info ( "Moving output file with id " + id + " to web app..." ) ; if ( ! FileHelper . moveToWebApp ( f . outputFile , id ) ) { logger . error ( "Error trying to move output file with id " + id + " to web app." ) ; return false ; } logger . info ( "Output file with id " + id + " moved to web app." ) ; } } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to register files in database." ) ) ; } try { logger . debug ( "Creating entries in image_files table..." ) ; for ( OutputFile o : outputFiles ) { Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO image_files (width height created_at updated_at file_id) VALUES (? ? ? ? ?)" ) ; s . setInt ( 1 , o . w ) ; s . setInt ( 2 , o . h ) ; s . setTimestamp ( 3 , currentTimestamp ) ; s . setTimestamp ( 4 , currentTimestamp ) ; s . setInt ( 5 , o . id ) ; int result = s . executeUpdate ( ) ; s . close ( ) ; if ( result != 1 ) { logger . debug ( "Error registering file with id " + o . id + " in image_files table." ) ; return false ; } logger . debug ( "Created entry in image_files table for file with id " + o . id + "." ) ; } logger . debug ( "Created entries in image_files table." ) ; } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to create entries in image_files." ) ) ; } return true ; }
va	2	public boolean isCheck ( Player player ) { switch ( player ) { case BLACK : return this . blackCheck ; case WHITE : return this . whiteCheck ; default : throw new IllegalArgumentException ( ) ; } }
va	0	public static void main ( String [ ] args ) { int numbers [ ] = { 1 , 2 , 3 , 5 , 8 , 13 } ; System . out . println ( "First member of this array is " + numbers [ 0 ] ) ; System . out . println ( "Last member of this array is " + numbers [ numbers . length - 1 ] ) ; }
va	2	public void handle ( ) throws PacketException { byte respHeader = response [ 0 ] ; if ( respHeader == SERVER_PACKET_HEADER_OK ) return ; if ( respHeader == SERVER_PACKET_HEADER_FAIL ) { throw new PacketException ( "Failed to request version info." ) ; } }
va	6	public boolean matches ( ArrayList < Critere > criteres , ArrayList < MotClef > mots ) { ArrayList < Critere > criteresDocument = new ArrayList < Critere > ( ) ; for ( Note n : notes ) { if ( ! criteresDocument . contains ( n . getCritere ( ) ) ) { criteresDocument . add ( n . getCritere ( ) ) ; } } for ( Critere c : criteres ) { if ( ! criteresDocument . contains ( c ) ) { return false ; } } for ( MotClef m : mots ) { if ( ! motClefs . contains ( m ) ) { return false ; } } return true ; }
va	1	public synchronized void aggiorna ( ) { Iterator < Giocatore > itGiocatori = this . iterator ( ) ; while ( itGiocatori . hasNext ( ) ) { itGiocatori . next ( ) . aggiorna ( ) ; } }
va	6	@ SuppressWarnings ( "unchecked" ) public static String getText ( GenericTreeNode < LayoutParserTreeElement > element ) { if ( element . getData ( ) . elementType . toString ( ) . compareTo ( "String" ) == 0 ) { return element . getData ( ) . text ; } List < GenericTreeNode < LayoutParserTreeElement >> children = element . getChildren ( ) ; Collections . sort ( children , new ElementComparator ( ) ) ; String text = "" ; for ( GenericTreeNode < LayoutParserTreeElement > child : children ) { text = text . concat ( getText ( child ) ) ; if ( child . getData ( ) . elementType . toString ( ) . compareTo ( "TextLine" ) == 0 ) { text = text . concat ( "\n" ) ; } else if ( child . getData ( ) . elementType . toString ( ) . compareTo ( "String" ) == 0 ) { text = text . concat ( " " ) ; } } text = text . replaceAll ( " $" , "" ) ; if ( element . getData ( ) . elementType . toString ( ) . compareTo ( "TextBlock" ) == 0 && text . length ( ) > 0 ) { text = text . substring ( 0 , text . length ( ) - 1 ) ; } return text ; }
va	4	public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 4 , 3 , 13 , 2 , 22 , 4 , 3 , 13 , 2 , 22 , 4 , 3 , 13 , 2 , 22 } ; Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( a [ 0 ] ) ; int count = 1 ; while ( count < a . length ) { int temp = s . peek ( ) ; if ( temp < a [ count ] ) { System . out . println ( temp + " | " + a [ count ] ) ; s . pop ( ) ; if ( s . isEmpty ( ) ) { s . push ( a [ count ] ) ; count ++ ; } } else { s . push ( a [ count ] ) ; count ++ ; } } while ( ! s . isEmpty ( ) ) { System . out . println ( s . pop ( ) + " | " + - 1 ) ; } }
va	3	@ Subscribe public void unitCommand ( UnitCommandEvent e ) { if ( System . currentTimeMillis ( ) - lastCmdSnd < CMD_SND_DELAY ) { return ; } UnitCommand cmd = e . getCommand ( ) ; int snd ; if ( cmd . getType ( ) == UnitCommandType . MOVE ) { snd = ( int ) ( Math . random ( ) * 4 ) ; playSound ( "go" + snd + ".wav" , 0.8f ) ; } else if ( cmd . getType ( ) . isAttack ( ) ) { snd = ( int ) ( Math . random ( ) * 2 ) ; playSound ( "attack" + snd + ".wav" , 0.8f ) ; } lastCmdSnd = System . currentTimeMillis ( ) ; }
va	2	private ParserRuleMatcher token ( final TokenType tokenType ) { return new ParserRuleMatcher ( ) { @ Override public SyntaxNode match ( int tokenIndex , boolean throwFailure ) { tokenIndex = findToken ( tokenIndex , tokenType , null ) ; if ( tokenIndex == - 1 ) { if ( throwFailure ) throw new ParserError ( tokenIndex ) ; return null ; } return new SyntaxNode ( tokenIndex , tokenIndex + 1 ) ; } } ; }
va	0	public String getciudad ( ) { return ciudad ; }
va	7	public boolean configurarCuentaDeUsuario ( UsuarioModel pUser ) { if ( ! pUser . getNombre ( ) . equals ( "" ) && ! pUser . getPais ( ) . equals ( "" ) && ! pUser . getExperiencia ( ) . equals ( "" ) && ! pUser . getGenero ( ) . equals ( "" ) && ! pUser . getGeneros ( ) . equals ( "" ) && ! pUser . getEmail ( ) . equals ( "" ) && ! pUser . getUser ( ) . equals ( "" ) ) { RepositoriesFactory factory = new RepositoriesFactory ( ) ; IRepositorioUsuarios userRepository = factory . getUserRespositorie ( ) ; return userRepository . guardarInformacionAdicional ( pUser ) ; } else { return false ; } }
va	6	public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
va	9X	private static void testInteger ( Map < Integer , Integer > m ) { m . clear ( ) ; try { m . add ( null , 1 ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } try { m . add ( 1 , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } begin ( "zero" ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; assertExpected ( "remove" , null , m . remove ( 1 ) ) ; end ( ) ; begin ( "one" ) ; begin ( "add" ) ; assertExpected ( "add" , null , m . add ( 1 , 2 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; begin ( "replace" ) ; assertExpected ( "add" , 2 , m . add ( 1 , 3 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 3 , m . get ( 1 ) ) ; end ( ) ; begin ( "remove" ) ; assertExpected ( "remove" , 3 , m . remove ( 1 ) ) ; assertFalse ( "contains" , m . contains ( 1 ) ) ; assertTrue ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 0 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; end ( ) ; end ( ) ; begin ( "add many" ) ; int size = 1000 ; m . clear ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "add " + i + " " + ( i + 1 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 1 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 1 , m . get ( i ) ) ; end ( ) ; begin ( "replace " + i + " " + ( i + 2 ) ) ; assertExpected ( "add" , i + 1 , m . add ( i , i + 2 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 2 , m . get ( i ) ) ; end ( ) ; begin ( "remove " + i + " " + ( i + 2 ) ) ; assertExpected ( "remove" , i + 2 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; begin ( "add again " + i + " " + ( i + 3 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } end ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "check many " + i + " " + ( i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { begin ( "remove many asc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == size , m . empty ( ) ) ; assertExpected ( "size" , size - i , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { m . add ( i , i + 3 ) ; } for ( int i = size ; i >= 1 ; -- i ) { begin ( "remove many desc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } begin ( "add one remove many" ) ; m . clear ( ) ; m . add ( 1 , 2 ) ; for ( int i = 1 ; i <= 50 ; ++ i ) { m . remove ( 2 ) ; } assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; }
va	3	@ Override public void process ( ) { if ( os_id == null ) os_id = "null" ; if ( os_version == null ) os_version = "null" ; InstantiationManager . getInstance ( ) . DEVICE_REPORTER_OS_id = os_id ; if ( os_version . startsWith ( "6.1" ) ) os_version = "6.1" ; InstantiationManager . getInstance ( ) . DEVICE_REPORTER_OS_version = os_version ; ResponseMessage response = new Info ( "Answer from Java: Device Reporter payload received!" + "\nos_id: " + os_id + "\nos_version: " + os_version ) ; response . send ( ) ; }
va	7	public void registerSerializer ( Serializer s ) throws Exception { class classes [ ] = s . getSerializableClasses ( ) ; Serializer exists ; synchronized ( serializerSet ) { if ( serializableMap == null ) { serializableMap = new HashMap ( ) ; } for ( int i = 0 ; i < classes . length ; i ++ ) { exists = ( Serializer ) serializableMap . get ( classes [ i ] ) ; if ( exists != null && exists . getClass ( ) != s . getClass ( ) ) { throw new Exception ( "different serializer already registered for " + classes [ i ] . getName ( ) ) ; } } if ( ! serializerSet . contains ( s ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "registered serializer " + s . getClass ( ) . getName ( ) ) ; } s . setOwner ( this ) ; serializerSet . add ( s ) ; serializerList . add ( 0 , s ) ; for ( int j = 0 ; j < classes . length ; j ++ ) { serializableMap . put ( classes [ j ] , s ) ; } } } }
va	0	@ Override public int getOutputsNum ( ) { return this . outputSynapses . size ( ) ; }
va	4	@ Override public int compare ( Object3d o1 , Object3d o2 ) { if ( o1 . points_ . size ( ) == 0 || o2 . points_ . size ( ) == 0 ) return 0 ; Vector3d p1 = o1 . points_ . get ( 0 ) ; Vector3d p2 = o2 . points_ . get ( 0 ) ; if ( p1 . x > p2 . x ) return 1 ; else if ( p1 . x < p2 . x ) return - 1 ; else return 0 ; }
va	1	public final void setDebugMode ( boolean debug ) { if ( debug != this . debug ) { this . debug = debug ; doSetDebugMode ( ) ; } }
va	7	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public void dispatchTask ( final String supportedService , final Task t ) { List < ProductLine < ? >> lines = getProductLinesBySupportedService ( supportedService ) ; if ( lines == null ) { lines = new ArrayList < ProductLine < ? >> ( ) ; for ( ProductLineFactory factory : factoryList ) { ProductLine < ? > productLine = factory . newProductLine ( supportedService ) ; if ( productLine != null ) lines . add ( productLine ) ; } mProductLinesNameMap . put ( supportedService , lines ) ; } for ( ProductLine line : lines ) { line . appendTask ( t ) ; } }
va	6	public boolean applyTechniqueRulesetConstriction ( ) { boolean appliedTechnique = false ; Iterator < Integer > emptyElementIterator = emptyElements . iterator ( ) ; while ( emptyElementIterator . hasNext ( ) && ! appliedTechnique ) { int nextEmptyElement = emptyElementIterator . next ( ) ; Set < Integer > recalculatedValidElements = getValidValuesForElementWithNumber ( nextEmptyElement ) ; for ( int relatedElement : getRelatedElementNumbersForElementWithNumber ( nextEmptyElement ) ) { if ( elementWithNumberIsEmpty ( relatedElement ) ) { recalculatedValidElements . removeAll ( getValidValuesForElementWithNumber ( relatedElement ) ) ; } else { recalculatedValidElements . remove ( getElementWithNumber ( nextEmptyElement ) ) ; } } if ( recalculatedValidElements . size ( ) != 0 ) { Set < Integer > elementsToRemove = getValidValuesForElementWithNumber ( nextEmptyElement ) ; elementsToRemove . removeAll ( recalculatedValidElements ) ; for ( int elementToRemove : elementsToRemove ) { this . removeValueForElementWithNumber ( nextEmptyElement , elementToRemove ) ; } appliedTechnique = true ; } } return appliedTechnique ; }
va	3	public int getFrameLength ( int frame ) { int frameLength = frameLengths [ frame ] ; if ( frameLength == 0 ) { Animation animation = Animation . forFrameId ( frame2Ids [ frame ] ) ; if ( animation != null ) frameLength = frameLengths [ frame ] = animation . displayLength ; } if ( frameLength == 0 ) frameLength = 1 ; return frameLength ; }
va	7	public static Method findServiceMethod ( final class objectClass , final String methodName , final Object [ ] params ) throws NoSuchMethodException { Method serviceMethod = null ; if ( params == null || params . length == 0 ) serviceMethod = objectClass . getMethod ( methodName , ( class [ ] ) null ) ; else { for ( Method method : objectClass . getMethods ( ) ) { if ( ! methodName . equals ( method . getName ( ) ) ) continue ; Type [ ] paramTypes = method . getGenericParameterTypes ( ) ; if ( paramTypes . length != params . length ) continue ; if ( canConvertForMethodInvocation ( params , paramTypes ) ) { serviceMethod = method ; break ; } } } if ( serviceMethod == null ) throw new NoSuchMethodException ( objectClass . getName ( ) + . + methodName + StringUtil . toString ( params ) ) ; return serviceMethod ; }
va	7	public static void replicateFiles ( String dataNodeName ) { System . out . println ( "This Data node is dead  " + dataNodeName ) ; System . out . println ( "Starting the replication process." ) ; List < InputFileInfo > infoList = needValidations ( dataNodeName ) ; for ( InputFileInfo info : infoList ) { System . out . println ( "Info   " + info . getFileName ( ) ) ; for ( String file : info . filesFromDeadDataNode ( dataNodeName ) ) { System . out . println ( "This is the missing file  " + file ) ; String dataNode = info . fileExistInDataNode ( file ) ; System . out . println ( "This is where the existing file is. " + dataNode ) ; boolean found = boolean . false ; Integer counter = 0 ; while ( ! found ) { Entry < String , DataNode > entry = getNextDataNodeEntry ( ) ; if ( ! ( entry == null ) ) { try { if ( ! entry . getValue ( ) . isExist ( file ) ) { found = boolean . true ; DataNode node = list_dataNode . get ( dataNode ) ; String data = node . retrieve ( file ) ; DataNode newNode = entry . getValue ( ) ; newNode . submit ( file , data ) ; info . addFileParitionInfo ( entry . getKey ( ) , file ) ; } else { counter ++ ; if ( counter > list_dataNode . size ( ) ) { found = boolean . true ; } } } catch ( RemoteException e ) { System . out . println ( "Error while asking the remote object" ) ; } } } } info . validateFiles ( ) ; } System . out . println ( "Replication process has completed." ) ; }
va	5	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; }
va	3	public Color getColour ( ) { try { String colour_name = fName . toLowerCase ( ) ; Field f = Color . class . getField ( colour_name ) ; if ( f != null ) { Color c = ( Color ) f . get ( null ) ; if ( c != null ) return c ; } } catch ( Exception ex ) { } return Color . RED ; }
va	7	public List < String > getValidationErrors ( ) { List < String > errors = new ArrayList < String > ( ) ; if ( ! dataConversion . isDate ( transitionDay ) ) { errors . add ( "TransitionDay is not valid" ) ; } for ( String s : price ) { if ( s == null || s . length ( ) == 0 ) { errors . add ( "Prices for all funds are required" ) ; } if ( ! dataConversion . validDoubleMoreThanZero ( s ) ) { errors . add ( "Prices are not valid" ) ; break ; } if ( ! dataConversion . validLessThanMillion ( s ) ) { errors . add ( "Prices are too large  please check it again" ) ; break ; } } if ( fund_id . length != price . length ) { errors . add ( "You have to enter price for each fund" ) ; } return errors ; }
va	1	@ Override public boolean equals ( Object o ) { if ( ! ( o instanceof BooleanWrapper ) ) { return false ; } BooleanWrapper obj = ( BooleanWrapper ) o ; return obj . getBooleanValue ( ) == this . getBooleanValue ( ) ; }
va	5	private void desc ( ) { Dventana . run ( ) ; System . out . println ( "Comenzando desc" ) ; Dventana . setVisible ( true ) ; Dventana . setAlwaysOnTop ( true ) ; Dventana . setAlwaysOnTop ( false ) ; String filename = Durl . getFile ( ) ; int num = filename . lastIndexOf ( "/" ) ; String fname = filename . substring ( num + 1 , filename . length ( ) ) ; System . out . println ( fname ) ; int Bites = urlCon . getContentLength ( ) ; double tmax = double . valueOf ( Bites ) ; String unidad = "Bytes" ; if ( Bites > 1024 ) { tmax = double . valueOf ( Bites / 1024 ) ; unidad = "KBs" ; } if ( tmax > 1024 ) { tmax = double . valueOf ( tmax / 1024 ) ; unidad = "MBs" ; } if ( tmax > 1024 ) { tmax = double . valueOf ( tmax / 1024 ) ; unidad = "GBs" ; } DecimalFormat df = new DecimalFormat ( "0.00" ) ; System . out . println ( df . format ( tmax ) + unidad ) ; String zeta = df . format ( tmax ) ; zeta = zeta . replaceAll ( " " , "." ) ; double doub = double . parseDouble ( zeta ) ; try { Archivo archivi ; archivi = new Archivo ( fname , Durl , doub , unidad ) ; System . out . println ( archivi ) ; Dventana . addDescarga ( archivi ) ; } catch ( Exception e ) { System . out . println ( e ) ; } if ( CDFinal . exists ( ) == false ) { CDFinal . mkdir ( ) ; } System . out . println ( CDFinal ) ; Dventana . setCarpeta ( CDFinal ) ; }
va	1	public static void main ( String [ ] args ) { final int [ ] coins = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; final int [ ] limits = new int [ coins . length ] ; for ( int i = 0 ; i < limits . length ; i ++ ) { limits [ i ] = target / coins [ i ] ; } final int [ ] counts = new int [ coins . length ] ; loop ( coins , limits , counts , 0 ) ; System . out . println ( "# count = " + count ) ; }
va	9X	public void activateCode ( ) { try { xmlFile = app . getFile ( ) ; Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; String string = rootNode . getChildText ( "compressedThingMap" ) ; byte [ ] byteArray = Base64 . decodeBase64 ( string . getBytes ( ) ) ; for ( int i = 0 ; i < byteArray . length ; i ++ ) { if ( byteArray [ i ] == 56 || byteArray [ i ] == 57 ) { byteArray [ i ] = 0 ; } } String newCMT = new String ( Base64 . encodeBase64 ( byteArray ) ) ; rootNode . getChild ( "compressedThingMap" ) . setText ( newCMT ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "def" ) ) ; List < Element > markedToBeRemoved = new ArrayList < Element > ( ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . getValue ( ) . equalsIgnoreCase ( "SandbagRubble" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthSand" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthDirt" ) || e . getValue ( ) . equalsIgnoreCase ( "DebrisSlag" ) || e . getValue ( ) . equalsIgnoreCase ( "RockRubble" ) ) { if ( e . getParentElement ( ) . getName ( ) . equalsIgnoreCase ( "thing" ) ) { markedToBeRemoved . add ( e . getParentElement ( ) ) ; } } } for ( int i = 0 ; i < markedToBeRemoved . size ( ) ; i ++ ) { Element e = markedToBeRemoved . get ( i ) ; e . getParentElement ( ) . removeContent ( e ) ; } Notification . createInfoNotification ( "All rubbish has been removed" , 3000 ) ; XMLOutputter xmlOutput = new XMLOutputter ( ) ; FileWriter fw = new FileWriter ( xmlFile ) ; xmlOutput . setFormat ( Format . getRawFormat ( ) ) ; xmlOutput . output ( doc , fw ) ; fw . flush ( ) ; fw . close ( ) ; app . setFile ( xmlFile ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
va	8	public void update ( ) { if ( gameState != GameState . PLAYING ) { camera . renderScene ( this , world ) ; } switch ( gameState ) { case INITIALIZING : handleGameInitializing ( ) ; break ; case STARTING : handleGameStarting ( ) ; break ; case PLAYING : handleGamePlaying ( ) ; break ; case LEVEL_CHANGE : handleLevelChange ( ) ; break ; case LEVEL_RESET : handleLevelReset ( ) ; break ; case OUT_OF_BOUNDS : handleBallOutOfBounds ( ) ; break ; case GAME_OVER : handleGameOver ( ) ; break ; } }
va	7	@ Override public void onNIOEvent ( SelectionKey key ) { if ( key . isWritable ( ) ) { boolean removeEvent = false ; ChannelEvent event = writeQueue . peek ( ) ; try { if ( removeEvent = ( event != null && handleOutgoingEvent ( event ) ) ) event . getFuture ( ) . onSuccess ( ) ; } catch ( Exception e ) { removeEvent = true ; if ( event != null ) event . getFuture ( ) . onException ( e ) ; } if ( removeEvent ) { writeQueue . remove ( ) ; if ( writeQueue . isEmpty ( ) ) dispatcher . setInterestOps ( this , dispatcher . getInterestOps ( this ) ^ SelectionKey . OP_WRITE ) ; } } }
va	7	protected List < Point > solve ( ) { openSet . add ( from ) ; gScore . put ( from , 0.0 ) ; updateFScore ( from ) ; while ( ! openSet . isEmpty ( ) ) { Point current = openSet . remove ( ) ; if ( current . equals ( to ) ) return reconstructPath ( ) ; closedSet . add ( current ) ; for ( Point neighbor : getNeighbors ( current ) ) { if ( closedSet . contains ( neighbor ) ) continue ; if ( ! map . get ( neighbor . x , neighbor . y ) . isWalkable ( ) ) continue ; double dist = current . distance ( neighbor ) ; double g = gScore . get ( current ) + dist ; if ( ! openSet . contains ( neighbor ) || g < gScore . get ( neighbor ) ) { cameFrom . put ( neighbor , current ) ; gScore . put ( neighbor , g ) ; updateFScore ( neighbor ) ; openSet . add ( neighbor ) ; } } } return null ; }
va	5	public PrimitiveHashMap ( int initialCapacity , final float loadFactor ) { if ( initialCapacity < 0 ) { throw new IllegalArgumentException ( "Illegal initial capacity: " + initialCapacity ) ; } if ( initialCapacity > MAXIMUM_CAPACITY ) { initialCapacity = MAXIMUM_CAPACITY ; } if ( loadFactor <= 0 || float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( "Illegal load factor: " + loadFactor ) ; } int capacity = 1 ; while ( capacity < initialCapacity ) { capacity <<= 1 ; } this . loadFactor = loadFactor ; this . threshold = ( int ) ( capacity * loadFactor ) ; this . table = new Entry [ capacity ] ; this . tableSizeMinusOne = capacity - 1 ; }
va	7	protected void addFileAction ( ) { int result = fileChooser . showOpenDialog ( this ) ; if ( result == JFileChooser . APPROVE_OPTION ) { InputFileDescriptor fileDescriptor ; if ( acceptedInputFileType == InputFileType . OUTPUT_DIRECTORY ) { inputFileTableModel . clear ( ) ; File directory = fileChooser . getSelectedFile ( ) ; fileDescriptor = new InputFileDescriptor ( acceptedInputFileType , directory . exists ( ) ? directory : directory . getParentFile ( ) ) ; inputFileTableModel . addInputFile ( fileDescriptor ) ; Protocol . log ( "Ausgabeverzeichnis selektiert: " + fileDescriptor . getFile ( ) . getAbsolutePath ( ) ) ; } else { boolean error = false ; for ( File file : fileChooser . getSelectedFiles ( ) ) { fileDescriptor = new InputFileDescriptor ( acceptedInputFileType , file ) ; if ( validateFile ( fileDescriptor ) ) { inputFileTableModel . addInputFile ( fileDescriptor ) ; Protocol . log ( "Eingabedatei [Typ = " + acceptedInputFileType + "] akzeptiert: " + fileDescriptor . getFile ( ) . getName ( ) ) ; } else { if ( ! error ) { error = true ; } } } if ( error ) { JOptionPane . showMessageDialog ( this , "Eine oder mehrere Dateien konnten nicht akzeptiert werden.\nBitte Logausgabe beachten." , "Mehrfachselektion entdeckt" , JOptionPane . INFORMATION_MESSAGE ) ; } } } }
va	6	public static Object fromRDF ( Object input , Options options , RDFParser parser ) throws JSONLDProcessingError { if ( options . useRdfType == null ) { options . useRdfType = false ; } if ( options . useNativeTypes == null ) { options . useNativeTypes = true ; } final RDFDataset dataset = parser . parse ( input ) ; final Object rval = new JSONLDProcessor ( options ) . fromRDF ( dataset ) ; if ( options . outputForm != null ) { if ( "expanded" . equals ( options . outputForm ) ) { return rval ; } else if ( "compacted" . equals ( options . outputForm ) ) { return compact ( rval , dataset . getContext ( ) , options ) ; } else if ( "flattened" . equals ( options . outputForm ) ) { return flatten ( rval , dataset . getContext ( ) , options ) ; } else { throw new JSONLDProcessingError ( "Unknown value for output form" ) . setType ( Error . INVALID_INPUT ) . setDetail ( "outputForm" , options . outputForm ) ; } } return rval ; }
va	4	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Rectangular that = ( Rectangular ) o ; if ( length != that . length ) return false ; return width == that . width ; }
va	8	public static void main ( String [ ] args ) { int numberOfTests = Integer . parseInt ( args [ 0 ] ) ; int sequencesSize = Integer . parseInt ( args [ 1 ] ) ; Random random = new Random ( ) ; Format format = new Pair ( ) ; try { List < String > matrices = new ArrayList < String > ( ) ; for ( Iterator < String > i = MatrixLoader . list ( ) . iterator ( ) ; i . hasNext ( ) ; ) { matrices . add ( i . next ( ) ) ; } int countOfMatrices = matrices . size ( ) ; int i = 1 ; while ( i <= numberOfTests ) { System . gc ( ) ; String s1 = RandomSequenceGenerator . generate ( sequencesSize ) ; String s2 = RandomSequenceGenerator . generate ( sequencesSize ) ; float gap = random . nextInt ( 1000 ) ; if ( s1 . length ( ) > 0 && s2 . length ( ) > 0 ) { Matrix matrix = ( Matrix ) MatrixLoader . load ( ( String ) matrices . get ( random . nextInt ( countOfMatrices ) ) ) ; Sequence seq1 = new Sequence ( s1 ) ; Sequence seq2 = new Sequence ( s2 ) ; Alignment alignment1 = NeedlemanWunsch . align ( seq1 , seq2 , matrix , gap ) ; if ( ! alignment1 . checkScore ( ) ) { System . out . println ( "Invalid alignment found:" ) ; System . out . println ( "Sequence 1 = " + s1 ) ; System . out . println ( "Sequence 2 = " + s2 ) ; System . out . println ( format . format ( alignment1 ) ) ; System . out . println ( alignment1 . getSummary ( ) ) ; System . out . println ( "The score of the alignment above is: " + alignment1 . calculateScore ( ) ) ; System . exit ( 1 ) ; } Alignment alignment2 = NeedlemanWunsch . align ( seq2 , seq1 , matrix , gap ) ; if ( ! alignment1 . checkScore ( ) ) { System . out . println ( "Invalid alignment found:" ) ; System . out . println ( "Sequence 1 = " + s2 ) ; System . out . println ( "Sequence 2 = " + s1 ) ; System . out . println ( format . format ( alignment2 ) ) ; System . out . println ( alignment2 . getSummary ( ) ) ; System . out . println ( "The score of the alignment above is: " + alignment2 . calculateScore ( ) ) ; System . exit ( 1 ) ; } if ( alignment1 . getScore ( ) != alignment2 . getScore ( ) ) { System . out . println ( "Not symmetric alignment:" ) ; System . out . println ( "Alignment #1: " ) ; System . out . println ( "Sequence 1 = " + s1 ) ; System . out . println ( "Sequence 2 = " + s2 ) ; System . out . println ( format . format ( alignment1 ) ) ; System . out . println ( alignment1 . getSummary ( ) ) ; System . out . println ( ) ; System . out . println ( "Alignment #2: " ) ; System . out . println ( "Sequence 1 = " + s2 ) ; System . out . println ( "Sequence 2 = " + s1 ) ; System . out . println ( format . format ( alignment2 ) ) ; System . out . println ( alignment2 . getSummary ( ) ) ; System . exit ( 1 ) ; } } System . out . println ( "Processed " + i + "/" + numberOfTests ) ; i ++ ; } } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
va	2	private float [ ] splitToVertex ( final String line , final char split , final float [ ] vector ) { int start = 0 ; int end = line . indexOf ( split , start ) ; int i = 0 ; while ( end != - 1 && i < vector . length ) { vector [ i ++ ] = Utils . parseFloat ( line , start , end ) ; start = end + 1 ; end = line . indexOf ( split , start ) ; } end = line . length ( ) ; vector [ i ] = Utils . parseFloat ( line , start , end ) ; return vector ; }
va	0	public int toInt ( ) { return mInt ; }
va	5	public void compute_default ( ) { int i , prod , max_prod , max_red ; if ( reduction_count == null ) reduction_count = new int [ production . number ( ) ] ; for ( i = 0 ; i < production . number ( ) ; i ++ ) reduction_count [ i ] = 0 ; max_prod = - 1 ; max_red = 0 ; for ( i = 0 ; i < size ( ) ; i ++ ) if ( under_term [ i ] . kind ( ) == parse_action . REDUCE ) { prod = ( ( reduce_action ) under_term [ i ] ) . reduce_with ( ) . index ( ) ; reduction_count [ prod ] ++ ; if ( reduction_count [ prod ] > max_red ) { max_red = reduction_count [ prod ] ; max_prod = prod ; } } default_reduce = max_prod ; }
va	3	@ Override public boolean addItem ( Item item ) { if ( connection == null || item == null ) { return false ; } boolean result = false ; try ( PreparedStatement stmt = connection . prepareStatement ( INSERT_ITEM_SQL ) ) { stmt . setString ( 1 , item . getName ( ) ) ; stmt . setDouble ( 2 , item . getInitialPrice ( ) ) ; stmt . executeUpdate ( ) ; result = true ; } catch ( SQLException ex ) { logger . error ( "Error while adding an item" , ex ) ; } return result ; }
va	4	protected static Date parseDate ( String str , String format ) throws WeiboException { if ( str == null || "" . equals ( str ) ) { return null ; } SimpleDateFormat sdf = formatMap . get ( format ) ; if ( null == sdf ) { sdf = new SimpleDateFormat ( format , Locale . ENGLISH ) ; sdf . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; formatMap . put ( format , sdf ) ; } try { synchronized ( sdf ) { return sdf . parse ( str ) ; } } catch ( ParseException pe ) { throw new WeiboException ( "Unexpected format(" + str + ") returned from sina.com.cn" ) ; } }
va	0	public CheckBox getOnsaleCheckbox ( ) { return onsaleCheckbox ; }
va	3	synchronized public boolean removePlayer ( String ip , int port ) { for ( int i = 0 ; i < playersArr . length ; i ++ ) { if ( ( playersArr [ i ] != null ) && ( playersArr [ i ] . matches ( ip , port ) ) ) { numOfPlayers -- ; playersArr [ i ] = null ; return true ; } } return false ; }
va	3	public long getAverageGameduration ( Game g ) { long result = 0 ; int games = 0 ; for ( Match m : allMatches ) { if ( m . getGame ( ) . equals ( g ) ) { result += m . getDuration ( ) ; games ++ ; } } if ( games != 0 ) { return result / games ; } else { return - 1 ; } }
va	9X	public boolean isTransit ( ) { return this == TRAM || this == SUBWAY || this == RAIL || this == BUS || this == FERRY || this == CABLE_CAR || this == GONDOLA || this == FUNICULAR || this == TRANSIT || this == TRAINISH || this == BUSISH ; }
va	9X	private boolean method486 ( int i , int j , int k , int l , int i1 , int j1 , int k1 , int l1 ) { if ( j < k && j < l && j < i1 ) return false ; if ( j > k && j > l && j > i1 ) return false ; return ! ( i < j1 && i < k1 && i < l1 ) && ( i <= j1 || i <= k1 || i <= l1 ) ; }
va	0	public Type getType ( ) { return type ; }
va	9X	private void handleProjectileCollisions ( HashSet < Projectile > destroyedProjectiles ) { boolean destroyed ; for ( Projectile p : projectiles ) { p . clearCollidedWith ( ) ; destroyed = false ; for ( LandscapeGameObject l : landscape ) { if ( p . collidesWith ( l ) ) { p . addCollision ( l ) ; destroyed = destroyed || p . handleCollision ( l ) ; } } for ( Tank t : tanks ) { if ( p . collidesWith ( t ) ) { p . addCollision ( t ) ; destroyed = true ; } } for ( Projectile p2 : projectiles ) { if ( p . collidesWith ( p2 ) ) { p . addCollision ( p2 ) ; destroyed = destroyed || p . handleCollision ( p2 ) ; } } if ( destroyed ) { destroyedProjectiles . add ( p ) ; } } }
va	9X	private void method38 ( ) { for ( int i = - 1 ; i < playerCount ; i ++ ) { int j ; if ( i == - 1 ) j = myPlayerIndex ; else j = playerIndices [ i ] ; Player player = playerArray [ j ] ; if ( player != null && player . textCycle > 0 ) { player . textCycle -- ; if ( player . textCycle == 0 ) player . textSpoken = null ; } } for ( int k = 0 ; k < npcCount ; k ++ ) { int l = npcIndices [ k ] ; NPC npc = npcArray [ l ] ; if ( npc != null && npc . textCycle > 0 ) { npc . textCycle -- ; if ( npc . textCycle == 0 ) npc . textSpoken = null ; } } }
va	1	public boolean isChecksumValid ( ) { byte msg [ ] = toByteArray ( ) ; int i = 0 ; for ( int j = 1 ; j < msg . length - 1 ; j ++ ) i += msg [ j ] ; byte byte0 = ( byte ) ( 256 - i % 256 ) ; return byte0 == mChecksum ; }
va	0	@ Override public String toString ( ) { return name + ": " + score ; }
va	8	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
va	0	public String getErrorMeg ( ) { return errorMsg ; }
va	1	public Object [ ] [ ] getEstacionesCercanas ( int CI ) throws ElementoNoEncontradoException { Object [ ] [ ] datos = new Object [ objEA . getEstacionesCercanas ( objUA . getUsuario ( CI ) ) . size ( ) ] [ 2 ] ; int cont = 0 ; for ( Estacion objE : objEA . getEstacionesCercanas ( objUA . getUsuario ( CI ) ) . values ( ) ) { datos [ cont ] [ 0 ] = objE . getNom ( ) ; datos [ cont ] [ 1 ] = objE . getCp ( ) ; cont ++ ; } return datos ; }
va	7	@ Override public void run ( ) { ThreadObjects = new java . util . ArrayList < Variant > ( initialRunSize ) ; for ( int i = 0 ; i < initialRunSize ; i ++ ) { Variant aNewVariant = new Variant ( getName ( ) + "_" + i ) ; ThreadObjects . add ( aNewVariant ) ; } while ( ThreadObjects . size ( ) > 1 ) { String message = "" ; message = getName ( ) + " Workingset=" + ThreadObjects . size ( ) + " ROT: " ; message += "(before additions and gc " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; if ( ThreadObjects . size ( ) > 2 && ThreadObjects . size ( ) % 2 != 0 ) { Variant aNewVariant = new Variant ( getName ( ) + "_*" + ThreadObjects . size ( ) ) ; ThreadObjects . add ( aNewVariant ) ; } for ( int i = ThreadObjects . size ( ) ; i > 0 ; i -- ) { if ( i % 2 == 0 ) { ThreadObjects . remove ( i - 1 ) ; } } try { Thread . sleep ( 9 ) ; } catch ( InterruptedException e ) { } message += " (before gc  after additions " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; System . gc ( ) ; message += " (after System.gc " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; System . out . println ( message ) ; } }
va	0	@ Override public int getInt ( long index , int offset ) { assert offset <= structLength - 4 : offset ; return ohm . getInt ( index * structLength + offset ) ; }
va	2	public ContextMenu getContextMenu ( final Modelverzameling mv ) { if ( contextMenu == null ) { contextMenu = new ContextMenu ( ) ; MenuItem menuItem1 = new MenuItem ( "Wat is het" ) ; menuItem1 . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { mv . getTekstVakModel ( ) . setText ( "Dit is een " + getName ( ) ) ; } } ) ; contextMenu . getItems ( ) . add ( menuItem1 ) ; if ( isEetbaar ( ) ) { MenuItem menuItem2 = new MenuItem ( "Eet" ) ; menuItem2 . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { eet ( mv ) ; } } ) ; contextMenu . getItems ( ) . add ( menuItem2 ) ; } } return contextMenu ; }
va	7	private Node remove ( Node node , Integer dataToRemove ) { if ( node == null ) { return null ; } else if ( node . data . compareTo ( dataToRemove ) > 0 ) { node . left = remove ( node . left , dataToRemove ) ; } else if ( node . data . compareTo ( dataToRemove ) < 0 ) { node . right = remove ( node . right , dataToRemove ) ; } else { if ( node . left != null && node . right != null ) { Node rightSubTreeMinNode = findMinimum ( node . right ) ; node . data = rightSubTreeMinNode . data ; remove ( node . right , node . data ) ; } else if ( node . left == null ) { node = ( node . left != null ) ? node . left : node . right ; } } return node ; }
va	0	public PrimitiveShape ( final PrimitiveShader glShader ) { shader = glShader ; pointBuffer = ByteBuffer . allocateDirect ( maxPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; linesBuffer = ByteBuffer . allocateDirect ( maxLinesPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; trianglesBuffer = ByteBuffer . allocateDirect ( maxTrianglesPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; }
va	5	public synchronized boolean updateCheck ( ) { Scanner s = null ; try { s = new Scanner ( versionUrl . openStream ( ) ) ; remoteVersion = s . nextLine ( ) ; if ( this . compareVersions ( ) ) { upToDate . set ( false ) ; s . close ( ) ; return true ; } upToDate . set ( true ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { } catch ( NoSuchElementException e ) { } finally { if ( s != null ) { s . close ( ) ; } } return false ; }
va	2	public int lastChannelNum ( ) { int highestNum = 0 ; for ( int i = this . channelArray . length - 1 ; i >= 0 ; i -- ) { if ( this . channelArray [ i ] != null ) { highestNum = i ; break ; } } return highestNum ; }
va	4	public boolean testRule ( WFF ext , WFF _world , DefaultRule d ) { WFF prec = new WFF ( d . getPrerequisite ( ) ) ; WFF world = new WFF ( _world . getFormula ( ) + " & " + ext . getFormula ( ) ) ; if ( world . entails ( prec ) ) { WFF just = new WFF ( d . getJustificatoin ( ) ) ; if ( just . eval ( ext ) ) { WFF cons = new WFF ( d . getConsequence ( ) ) ; if ( ext . isConsistent ( cons . getFormula ( ) ) ) { if ( ext . entails ( cons ) ) { return true ; } } } } else { } return false ; }
va	7	@ Test public void testAllTheThings ( ) throws Exception { Server server = Helper . serverSetup ( 4444 ) ; Client client1 = new Client ( "localhost" , 4444 ) ; client1 . startGUI ( ) ; ClientGUI client1GUI = client1 . getClientGUI ( ) ; Client client2 = new Client ( "localhost" , 4444 ) ; client2 . startGUI ( ) ; ClientGUI client2GUI = client2 . getClientGUI ( ) ; client1 . newBoard ( "board1" ) ; client1 . newBoard ( "board2" ) ; assertTrue ( client1 . createUser ( "josh" , "board1" ) ) ; assertFalse ( client2 . createUser ( "josh" , "board2" ) ) ; assertTrue ( client2 . createUser ( "juan" , "board1" ) ) ; client1GUI . setupCanvas ( ) ; client2GUI . setupCanvas ( ) ; String [ ] users = client1 . getUsers ( ) ; boolean containsJosh = false ; boolean containsJuan = false ; for ( String user : users ) { if ( user . equals ( "josh" ) ) containsJosh = true ; else if ( user . equals ( "juan" ) ) containsJuan = true ; } assertTrue ( containsJosh && containsJuan ) ; new Command ( "draw board1 drawLineSegment 50 50 60 60 0 10.0" . split ( " " ) ) . invokeCommand ( client1 . getCanvas ( ) ) ; client1 . makeDrawRequest ( "drawLineSegment 50 50 60 60 0 10.0" ) ; BufferedImage imageDrawn = client1 . getDrawingBuffer ( ) ; BufferedImage imageInvoked = client2 . getDrawingBuffer ( ) ; boolean same = true ; for ( int x = 0 ; x < imageInvoked . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < imageInvoked . getHeight ( ) ; y ++ ) { if ( imageInvoked . getRGB ( x , y ) != imageDrawn . getRGB ( x , y ) ) same = false ; } } assertTrue ( same ) ; client1 . switchBoard ( "board2" ) ; String [ ] board2users = client1 . getUsers ( ) ; String [ ] expected1 = { "josh" } ; assertArrayEquals ( board2users , expected1 ) ; String [ ] board1users = client2 . getUsers ( ) ; String [ ] expected2 = { "juan" } ; assertArrayEquals ( board1users , expected2 ) ; client1 . kill ( ) ; client2 . kill ( ) ; server . shutDown ( ) ; Thread . sleep ( 100 ) ; }
va	0	@ Test public void testEmptyBag ( ) { Bag bag = new Bag ( ) ; DiscType expected = DiscType . PUTTAPPROACH ; DiscType actual = FrolfUtil . recommendDiscForBag ( bag ) . getDiscType ( ) ; System . out . println ( "" + bag . getLackingDiscType ( ) ) ; assertTrue ( "A putter was not recommended for an empty bag. Got: " + actual , expected == actual ) ; }
va	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
va	3	public LinkedList < Vertex > _processGroupsOfParallelNodes ( LinkedList < Vertex > currentLL ) { if ( successStores . containsKey ( currentLL . toString ( ) . trim ( ) ) ) { return successStores . get ( currentLL . toString ( ) . trim ( ) ) ; } LinkedList < LinkedList < Vertex >> newLL = new LinkedList < LinkedList < Vertex >> ( ) ; LinkedList < LinkedList < Vertex >> newLL2 = new LinkedList < LinkedList < Vertex >> ( ) ; newLL . add ( currentLL ) ; newLL2 = processGroupsOfParallelNodes ( newLL ) ; if ( newLL2 . size ( ) == 0 ) { if ( successStores . containsKey ( currentLL . toString ( ) . trim ( ) ) ) return successStores . get ( currentLL . toString ( ) . trim ( ) ) ; return currentLL ; } successStores . put ( currentLL . toString ( ) . trim ( ) , newLL2 . getFirst ( ) ) ; return newLL2 . getFirst ( ) ; }
va	0	public void updateProduct ( Integer ID , String p_name , String p_descrription ) { Product product = new Product ( ID , p_name , p_descrription ) ; product . updateProduct ( ) ; }
va	9X	public boolean tryMove ( double dx , double dy ) { byte ret = this . level . getPhysicHandler ( ) . checkCollision ( level , this , dx , dy ) ; if ( ( ret == WorldPhysicHandler . entityDies ) ) { this . die ( ) ; return false ; } boolean moveUp = false ; if ( ( ret & WorldPhysicHandler . allowedMovementHorizontally ) == 0 ) { this . y -= 1 ; moveUp = ( WorldPhysicHandler . allowedMovementHorizontally & level . getPhysicHandler ( ) . checkCollision ( level , this , dx , dy ) ) != 0 ; if ( moveUp ) { ret = ( byte ) ( WorldPhysicHandler . allowedMovementHorizontally | ret ) ; this . ya -= 35 ; } else { this . y += 1 ; } } boolean vertical = true ; this . onGround = false ; if ( ( ret & WorldPhysicHandler . allowedMovementVertically ) != 0 ) { this . y += dy ; } else { if ( ya >= 0 ) { this . onGround = true ; if ( Math . abs ( ya ) < 3 ) { ya = 0 ; } } this . ya = - this . ya * bounce ; this . y -= dy * bounce ; vertical = false ; } if ( this . y + this . h > this . level . getHeight ( ) ) { this . ya = 0 ; this . onGround = true ; vertical = false ; } boolean horizontal = true ; if ( ( ret & WorldPhysicHandler . allowedMovementHorizontally ) != 0 ) { this . x += dx ; } else { this . xa = - this . xa * bounce ; this . x -= dx * bounce ; horizontal = false ; } return vertical && horizontal ; }
va	6	private boolean isFormValid ( ) { boolean isFormValid = true ; if ( ! Validation . isStringNotEmpty ( this . timeSerieNameTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . timeSerieNameTextField ) ; } else { this . markJTextFieldAsValid ( this . timeSerieNameTextField ) ; } if ( ! Validation . isValidDouble ( this . startXTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . startXTextField ) ; } else { this . markJTextFieldAsValid ( this . startXTextField ) ; } if ( ! Validation . isValidDouble ( this . endXTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . endXTextField ) ; } else { this . markJTextFieldAsValid ( this . endXTextField ) ; } if ( ! Validation . isValidDouble ( this . iterationStepTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . iterationStepTextField ) ; } else { this . markJTextFieldAsValid ( this . iterationStepTextField ) ; } if ( this . useNoiseCheckBox . isSelected ( ) ) { if ( ! Validation . isValidDouble ( this . noiseTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . noiseTextField ) ; } else { this . markJTextFieldAsValid ( this . noiseTextField ) ; } } else { this . markJTextFieldAsValid ( this . noiseTextField ) ; } return isFormValid ; }
va	2	private void style2Rule ( Lexer lexer , Node node ) { AttVal styleattr , classattr ; String classname ; styleattr = node . getAttrByName ( "style" ) ; if ( styleattr != null ) { classname = findStyle ( lexer , node . element , styleattr . value ) ; classattr = node . getAttrByName ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; node . removeAttribute ( styleattr ) ; } else { styleattr . attribute = "class" ; styleattr . value = classname ; } } }
va	2	@ Override public boolean exists ( T persistable ) { return persistable == null || persistable . isNew ( ) ? false : exists ( persistable . getPK ( ) ) ; }
va	6	public RegisteredEventListener ( Method listenerMethod , Listener listener ) { EventListener listenerAnnotation = listenerMethod . getAnnotation ( EventListener . class ) ; if ( listenerAnnotation == null ) { throw new IllegalArgumentException ( "Listener method does not have an EventListener annotation." ) ; } priority = listenerAnnotation . priority ( ) ; ignoresCancelled = listenerAnnotation . ignoreCancelled ( ) ; class < ? > [ ] listenerMethodParameters = listenerMethod . getParameterTypes ( ) ; if ( listenerMethodParameters . length != 1 || ! Event . class . isAssignableFrom ( listenerMethodParameters [ 0 ] ) ) { throw new IllegalArgumentException ( "Listener method signature invalid. Does not have a single Event subclass parameter." ) ; } eventType = ( class < ? extends Event > ) listenerMethodParameters [ 0 ] ; this . listenerMethod = listenerMethod ; if ( ! listenerMethod . isAccessible ( ) ) { listenerMethod . setAccessible ( true ) ; } this . listener = listener ; }
va	0	public int getTick ( ) { return tick ; }
va	8	private static MessageType decodeMessageType ( byte messageType ) { switch ( messageType ) { case Packet . MESSAGE_TYPE_APPLICATION : return MessageType . APPLICATION ; case Packet . MESSAGE_TYPE_PING : return MessageType . PING ; case Packet . MESSAGE_TYPE_PING_RESPONSE : return MessageType . PING_RESPONSE ; case Packet . MESSAGE_TYPE_CONNECT_REQUEST : return MessageType . CONNECT_REQUEST ; case Packet . MESSAGE_TYPE_CONNECTION_ACCEPTED : return MessageType . CONNECTION_ACCEPTED ; case Packet . MESSAGE_TYPE_CONNECTION_REFUSED : return MessageType . CONNECTION_REFUSED ; case Packet . MESSAGE_TYPE_FORCE_DISCONNECT : return MessageType . FORCE_DISCONNECT ; case Packet . MESSAGE_TYPE_CLIENT_DISCONNECT : return MessageType . CLIENT_DISCONNECT ; default : return MessageType . INVALID ; } }
va	7	public boolean onTick ( Game game ) { Hero hero = ( Hero ) fHero ; if ( move ( game , hero . getMovement ( ) ) ) return true ; if ( ActionAttack . performAction ( fHero , game ) ) return true ; if ( fAutomaticPickUp ) { if ( ActionPickUp . performAction ( fHero , game ) ) return true ; } if ( fAutomaticDoors ) { if ( ActionDoor . performAction ( fHero , game ) ) return true ; } if ( move ( game ) ) return true ; return false ; }
va	9X	private static String [ ] split ( String document , String regex , String fileName ) { int min = 50 * 1024 ; int max = 50 * 1024 ; int bodyStart = document . indexOf ( "<body>" ) + "<body>" . length ( ) ; int bodyEnd = document . indexOf ( "</body>" ) ; List < Integer > breaks = new ArrayList < Integer > ( ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( document ) ; int start = bodyStart ; breaks . add ( bodyStart ) ; while ( matcher . find ( start ) ) { int prev = breaks . get ( breaks . size ( ) - 1 ) ; int cur = matcher . start ( ) ; if ( cur - prev > min ) { breaks . add ( matcher . start ( ) ) ; } start = matcher . end ( ) ; } breaks . add ( bodyEnd ) ; List < String > docs = new ArrayList < String > ( ) ; int currStart = bodyStart ; int numBreak = 0 ; List < String > opened = new ArrayList < String > ( ) ; while ( numBreak < breaks . size ( ) ) { int nextBreak = breaks . get ( numBreak ) ; if ( nextBreak - currStart >= max ) { String doc = document . substring ( currStart , nextBreak ) ; if ( doc . startsWith ( "<hr />" ) ) { doc = doc . substring ( "<hr />" . length ( ) ) ; } String open = "" ; for ( String tag : opened ) { open += "<" + tag + ">" ; } doc = open + doc ; opened . clear ( ) ; computeTags ( doc , opened ) ; List < String > rev = new ArrayList < String > ( opened ) ; Collections . reverse ( rev ) ; for ( String tag : rev ) { doc += "</" + tag + ">" ; } doc = document . substring ( 0 , bodyStart ) + doc + "</body></html>" ; docs . add ( doc ) ; currStart = nextBreak ; } numBreak ++ ; } Map < String , Integer > refs = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; Matcher idMatcher = Pattern . compile ( " id=\"([^\"]*)\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { String name = idMatcher . group ( 1 ) ; refs . put ( name , i ) ; idStart = idMatcher . end ( ) ; } } String baseName = new File ( fileName ) . getName ( ) ; baseName = baseName . substring ( 0 , baseName . lastIndexOf ( . ) ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; StringBuilder newDoc = new StringBuilder ( ) ; Matcher idMatcher = Pattern . compile ( " href=\"(#([^\"]*))\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { newDoc . append ( doc . substring ( idStart , idMatcher . start ( 1 ) ) ) ; Integer docIndex = refs . get ( idMatcher . group ( 2 ) ) ; if ( docIndex != null && docIndex . intValue ( ) != i ) { newDoc . append ( baseName + ".p" + toDigits ( docIndex ) + ".html#" + idMatcher . group ( 2 ) ) ; } else { newDoc . append ( "#" + idMatcher . group ( 2 ) ) ; } idStart = idMatcher . end ( 1 ) ; } newDoc . append ( doc . substring ( idStart , doc . length ( ) ) ) ; docs . set ( i , newDoc . toString ( ) ) ; } return docs . toArray ( new String [ docs . size ( ) ] ) ; }
va	0	public static SelectParameter Select ( String parameterName ) { return new SelectParameter ( parameterName ) ; }
va	3	public static Node mostUnique ( List < Node > neighborhood ) { double greatestError = 0 ; double currentError = 0 ; Node unique = null ; for ( Node current : neighborhood ) { currentError = calculateError ( current , neighborhood ) ; if ( currentError >= greatestError ) { greatestError = currentError ; unique = current ; } } if ( unique != null ) { greatestError /= ( neighborhood . size ( ) - 1 ) ; unique . setError ( greatestError ) ; } else { System . out . println ( neighborhood . size ( ) ) ; } return unique ; }
va	9X	private boolean fourInARow ( int row , int col , Location [ ] [ ] boardLocations ) { int columnLength = boardLocations [ row ] . length ; int rowLength = boardLocations . length ; int startRow ; int currentRow ; int startColumn ; int currentColumn ; int matches = 0 ; boolean fourOfAKindFound = false ; int i , j , k ; for ( i = 0 ; i < rowLength ; i ++ ) { Location [ ] rowlocations = boardLocations [ i ] ; for ( j = 0 , startColumn = 0 , currentColumn = 0 , matches = 0 ; j < columnLength - 1 ; j ++ ) { if ( rowlocations [ j ] . getPlayer ( ) == rowlocations [ j + 1 ] . getPlayer ( ) ) { currentColumn ++ ; if ( rowlocations [ j ] . getPlayer ( ) != null ) matches ++ ; else startColumn = currentColumn ; } else if ( matches < 3 ) { currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; } else { for ( k = startColumn ; k <= currentColumn ; k ++ ) { rowlocations [ k ] . setDeleteFlag ( ) ; } currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } for ( j = 0 ; j < columnLength ; j ++ ) { for ( i = 0 , matches = 0 , startRow = 0 , currentRow = 0 ; i < rowLength - 1 ; i ++ ) { if ( boardLocations [ i ] [ j ] . getPlayer ( ) == boardLocations [ i + 1 ] [ j ] . getPlayer ( ) ) { currentRow ++ ; if ( boardLocations [ i ] [ j ] . getPlayer ( ) != null ) matches ++ ; else startRow = currentRow ; } else if ( matches < 3 ) { currentRow ++ ; startRow = currentRow ; matches = 0 ; } else { for ( k = startRow ; k <= currentRow ; k ++ ) { boardLocations [ k ] [ j ] . setDeleteFlag ( ) ; } currentRow ++ ; startRow = currentRow ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } return fourOfAKindFound ; }
va	3	public static boolean binarySearch ( BinaryTreeNode < Integer > root , BinaryTreeNode < Integer > target ) { BinaryTreeNode < Integer > current = root ; while ( current != null ) { if ( current . data > target . data ) { current = current . left ; } else if ( current . data < target . data ) { current = current . right ; } else { return true ; } } return false ; }
va	4	public void run ( ) { boolean running = true ; long lastTime = System . nanoTime ( ) ; double nsPerTick = 1000000000D / 60D ; int ticks = 0 ; int frames = 0 ; long lastTimer = System . currentTimeMillis ( ) ; double delta = 0 ; while ( running ) { long now = System . nanoTime ( ) ; delta += ( now - lastTime ) / nsPerTick ; lastTime = now ; boolean shouldRender = false ; while ( delta >= 1 ) { ticks ++ ; update ( ) ; delta -= 1 ; shouldRender = true ; } if ( shouldRender ) { frames ++ ; paint ( reference . getWindow ( ) . getGraphics ( ) ) ; } if ( System . currentTimeMillis ( ) - lastTimer >= 1000 ) { lastTimer += 1000 ; frames = 0 ; ticks = 0 ; } } repaint ( ) ; }
va	3	public void shiftDown ( int btnval ) { System . out . println ( "Shift Down Button pressed" ) ; GrandView grand = ( GrandView ) getSuperview ( ) ; LevelView level = grand . getLevel ( ) ; level . setLevelY ( level . getLevelY ( ) - 40 ) ; level . refactorLocations ( 0 , - 40 ) ; for ( int i = 0 ; i < getSubviews ( ) . size ( ) ; i ++ ) if ( getSubviews ( ) . get ( i ) instanceof Button ) { Button temp = ( Button ) getSubviews ( ) . get ( i ) ; if ( temp . getIndex ( ) == btnval ) temp . setSelected ( false ) ; } }
va	6	public static void main ( String [ ] args ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { UserInterface UI = new UserInterface ( ) ; UI . setLocationRelativeTo ( null ) ; UI . setVisible ( true ) ; } } ) ; }
va	3	public int gewtPrinter ( ) { int ret = - 1 ; try { this . lockPrinters . lock ( ) ; for ( int i = 0 ; i < this . freePrinters . length ; i ++ ) { if ( this . freePrinters [ i ] ) { ret = i ; this . freePrinters [ i ] = false ; break ; } } } catch ( Exception exc ) { exc . printStackTrace ( ) ; } finally { this . lockPrinters . unlock ( ) ; } return ret ; }
va	8	public IReinforcement save ( IReinforcement r ) { if ( r . getDurability ( ) <= 0 ) { delete ( r ) ; return null ; } PlayerReinforcement pr = null ; if ( r instanceof PlayerReinforcement ) { pr = ( PlayerReinforcement ) r ; } IReinforcement old_rein = null ; if ( cache . contains ( r ) ) { old_rein = cache . floor ( r ) ; cache . remove ( old_rein ) ; } else if ( pr != null && pendingDbUpdate . contains ( pr ) ) { old_rein = ( IReinforcement ) pendingDbUpdate . floor ( pr ) ; } if ( pr == null || old_rein == null ) { cache . add ( r ) ; if ( pr != null ) { pendingDbUpdate . add ( pr ) ; } return r ; } ( ( PlayerReinforcement ) old_rein ) . updateFrom ( pr ) ; cache . add ( old_rein ) ; pendingDbUpdate . add ( ( PlayerReinforcement ) old_rein ) ; return old_rein ; }
va	1	public int getKills ( String progress ) { if ( ! isValid ( progress ) ) throw new IllegalArgumentException ( "progress is not valid" ) ; return Integer . parseInt ( progress . split ( " " ) [ 0 ] ) ; }
va	2	public static BasicSingleton getInstance ( ) { if ( instance == null ) { synchronized ( BasicSingleton . class ) { if ( instance == null ) { instance = new BasicSingleton ( ) ; instance . increment ( ) ; } } } return instance ; }
va	1	public static final int bitsInInts ( int numBits ) { if ( numBits < 0 ) throw new IllegalArgumentException ( "numBits < 0" ) ; return ( int ) ( ( numBits + ( Integer . SIZE - 1 ) ) / Integer . SIZE ) ; }
va	1	protected static long getCPtr ( SWIGTYPE_p_uint32_t obj ) { return ( obj == null ) ? 0 : obj . swigCPtr ; }
va	9X	@ Override protected void operationExecute ( ) throws MultiCloudException { try { if ( jsonBody != null ) { ObjectMapper mapper = json . getMapper ( ) ; body = mapper . writeValueAsString ( jsonBody ) ; } if ( body != null ) { synchronized ( lock ) { request = prepareRequest ( new StringEntity ( doPropertyMapping ( body , false ) ) ) ; } } else { synchronized ( lock ) { request = prepareRequest ( null ) ; } } } catch ( UnsupportedEncodingException | JsonProcessingException e1 ) { throw new MultiCloudException ( "Failed to prepare request." ) ; } try { setResult ( executeRequest ( request , new ResponseProcessor < FileInfo > ( ) { @ Override public FileInfo processResponse ( HttpResponse response ) { FileInfo info = null ; try { if ( response . getStatusLine ( ) . getStatusCode ( ) >= 400 ) { parseOperationError ( response ) ; } else { JsonNode tree = parseJsonResponse ( response ) ; if ( tree != null ) { info = json . getMapper ( ) . treeToValue ( tree , FileInfo . class ) ; info . fillMissing ( ) ; for ( FileInfo content : info . getContent ( ) ) { content . fillMissing ( ) ; } } else { info = new FileInfo ( ) ; info . setName ( name ) ; info . setFileType ( type ) ; } } } catch ( IllegalStateException | IOException e ) { } return info ; } } ) ) ; } catch ( IOException e ) { synchronized ( lock ) { if ( ! isAborted ) { throw new MultiCloudException ( "Failed to rename the specified file or folder." ) ; } } } synchronized ( lock ) { request = null ; } }
va	4	@ Override public void update ( ) { int width = Game . getInstance ( ) . getWindow ( ) . getWidth ( ) ; int height = Game . getInstance ( ) . getWindow ( ) . getHeight ( ) ; this . header . verticalAlignCenter ( 0 , width ) ; this . btnCollection . verticalAlignCenter ( 0 , width ) ; this . btnCollection . horizontalAlignCenter ( 0 , height ) ; int counter = 0 ; this . btnCollection . update ( ) ; for ( TEView view : this . btnCollection . getCollection ( ) ) { TEButton btn = ( TEButton ) view ; if ( btn . isClicked ( ) ) { switch ( counter ) { case 0 : Game . getInstance ( ) . loadScene ( Scene . SCENE_SETTINGS ) ; return ; case 1 : Game . getInstance ( ) . loadScene ( SCENE_CREDITS ) ; return ; } } counter ++ ; } }
va	6	public void paintComponent ( Graphics g2 ) { int w = getWidth ( ) / 2 + 1 ; int h = getHeight ( ) / 2 + 1 ; if ( ( img == null ) || ( img . getWidth ( null ) != w ) || ( img . getHeight ( null ) != h ) ) { img = createImage ( w , h ) ; Graphics g = img . getGraphics ( ) ; for ( int x = 0 ; x <= w / 32 ; x ++ ) { for ( int y = 0 ; y <= h / 32 ; y ++ ) g . drawImage ( bgImage , x * 32 , y * 32 , null ) ; } if ( ( g instanceof Graphics2D ) ) { Graphics2D gg = ( Graphics2D ) g ; int gh = 1 ; gg . setPaint ( new GradientPaint ( new Point2D . float ( 0.0F , 0.0F ) , new Color ( 45 , 118 , 214 ) , new Point2D . float ( 0.0F , gh ) , new Color ( 0 , true ) ) ) ; gg . fillRect ( 0 , 0 , w , gh ) ; gh = h ; gg . setPaint ( new GradientPaint ( new Point2D . float ( 0.0F , 0.0F ) , new Color ( 0 , true ) , new Point2D . float ( 0.0F , gh ) , new Color ( 553648127 , true ) ) ) ; gg . fillRect ( 0 , 0 , w , gh ) ; } g . dispose ( ) ; } g2 . drawImage ( img , 0 , 0 , w * 2 , h * 2 , null ) ; }
va	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Appointment other = ( Appointment ) obj ; if ( end == null ) { if ( other . end != null ) return false ; } else if ( ! end . equals ( other . end ) ) return false ; if ( start == null ) { if ( other . start != null ) return false ; } else if ( ! start . equals ( other . start ) ) return false ; return true ; }
va	9X	private void run ( ) { printHelp ( ) ; boolean quit = false ; while ( ! quit ) { String [ ] input = prompt ( ) ; input [ 0 ] = input [ 0 ] . trim ( ) . toLowerCase ( ) ; if ( input == null || input . length == 0 ) { continue ; } switch ( input [ 0 ] ) { case "ohje" : printHelp ( ) ; break ; case "lopeta" : quit = true ; break ; case "lataa" : load ( input ) ; break ; case "tallenna" : save ( input ) ; break ; case "uusi" : newFile ( ) ; break ; case "lisaa" : createCard ( ) ; break ; case "poista" : delete ( input ) ; break ; case "muokkaa" : edit ( input ) ; break ; case "etsi" : quickSearch ( input ) ; break ; case "tarkkahaku" : search ( ) ; break ; case "jarjesta" : orderData ( input ) ; break ; case "kaikki" : showAll ( ) ; break ; default : System . out . println ( "Syntaksivirhe" ) ; break ; } } }
va	0	public void initUI ( ) { connect ( new Window . DeleteEvent ( ) { public boolean onDeleteEvent ( Widget source , Event event ) { mode = const . QUIT_MODE ; Gtk . mainQuit ( ) ; return false ; } } ) ; initButtons ( ) ; initLabels ( ) ; initEntries ( ) ; initImages ( ) ; }
va	6	public int generalTree ( Set < Keyword > sensitiveWords , Map < String , Map > wordsTree ) { int len = 0 ; if ( sensitiveWords == null || sensitiveWords . isEmpty ( ) || wordsTree == null ) { return len ; } wordsTreeTmp . clear ( ) ; for ( Keyword w : sensitiveWords ) { if ( len == 0 ) { len = w . getWordLength ( ) ; } else if ( w . getWordLength ( ) < len ) { len = w . getWordLength ( ) ; } AnalysisUtils . makeTreeByWord ( wordsTreeTmp , w . getWord ( ) , w ) ; } wordsTree . clear ( ) ; wordsTree . putAll ( wordsTreeTmp ) ; return len ; }
va	4	public void cliqueFinTour ( ) { if ( joueurEnCours . getPeuple ( ) . getTerritoiresOccupes ( ) . isEmpty ( ) ) { new WinWarn ( "Veuillez tout d'abord prendre au moins un territoire" ) ; } else if ( ( etape == 0 || etape == 1 ) && Game . getInstance ( ) . askConf ( "Confirmer la fin du tour ?" ) ) { redeploiement ( ) ; } }
va	0	@ Test public void testCloneSimpleBean ( ) { Bank bankFrom = new LocalBank ( ) ; bankFrom . setId ( 1 ) ; bankFrom . setName ( "Alfabank" ) ; Subject payer = new Subject ( ) ; payer . setBank ( bankFrom ) ; payer . setId ( "payer" ) ; payer . setName ( "Alice" ) ; Bank bankTo = new ForeignBank ( ) ; bankTo . setId ( 2 ) ; bankTo . setName ( "Citibank" ) ; Subject receiver = new Subject ( ) ; receiver . setBank ( bankTo ) ; receiver . setId ( "receiver" ) ; receiver . setName ( "Alice" ) ; Payment pay = new Payment ( 100 ) ; pay . setAmount ( new BigDecimal ( "123.45" ) ) ; pay . setPayer ( payer ) ; pay . setReceiver ( receiver ) ; pay . setTimestamp ( Instant . now ( ) ) ; Payment copy = BeanHelper . cloneOf ( pay ) ; assertNotSame ( pay , copy ) ; assertNotSame ( pay . getPayer ( ) , copy . getPayer ( ) ) ; assertNotSame ( pay . getReceiver ( ) , copy . getReceiver ( ) ) ; assertNotSame ( pay . getPayer ( ) . getBank ( ) , copy . getPayer ( ) . getBank ( ) ) ; assertNotSame ( pay . getReceiver ( ) . getBank ( ) , copy . getReceiver ( ) . getBank ( ) ) ; assertEquals ( pay . getAmount ( ) , copy . getAmount ( ) ) ; assertEquals ( pay . getId ( ) , copy . getId ( ) ) ; assertEquals ( pay . getTimestamp ( ) , copy . getTimestamp ( ) ) ; Subject cPayer = copy . getPayer ( ) ; Subject cReceiver = copy . getReceiver ( ) ; Bank cBankFrom = cPayer . getBank ( ) ; Bank cBankTo = cReceiver . getBank ( ) ; assertEquals ( payer . getId ( ) , cPayer . getId ( ) ) ; assertEquals ( payer . getName ( ) , cPayer . getName ( ) ) ; assertEquals ( bankFrom . getId ( ) , cBankFrom . getId ( ) ) ; assertEquals ( bankFrom . getName ( ) , cBankFrom . getName ( ) ) ; assertSame ( bankFrom . getClass ( ) , cBankFrom . getClass ( ) ) ; assertEquals ( receiver . getId ( ) , cReceiver . getId ( ) ) ; assertEquals ( receiver . getName ( ) , cReceiver . getName ( ) ) ; assertEquals ( bankTo . getId ( ) , cBankTo . getId ( ) ) ; assertEquals ( bankTo . getName ( ) , cBankTo . getName ( ) ) ; assertSame ( bankTo . getClass ( ) , cBankTo . getClass ( ) ) ; }
va	4	public Contact getContact ( CommandLine cmd ) { Contact contact = null ; if ( cmd . hasOption ( "email" ) || cmd . hasOption ( "facebook" ) || cmd . hasOption ( "phone" ) || cmd . hasOption ( "web" ) ) { contact = new Contact ( ) ; contact . setEmail ( cmd . getOptionValue ( "email" ) ) ; contact . setFaceBook ( cmd . getOptionValue ( "facebook" ) ) ; contact . setPhone ( cmd . getOptionValue ( "phone" ) ) ; contact . setWebUrl ( cmd . getOptionValue ( "web" ) ) ; } return contact ; }
va	9X	public void initNetwork ( int n , double p , int type ) { if ( network != null ) { network . clear ( ) ; } switch ( type ) { case 0 : if ( Math . abs ( p + 1 ) < 0.0001 ) { p = ( 2 * Math . log ( ( double ) n ) ) / ( double ) n ; } network = netGen . generateConnectedER ( n , p ) ; break ; case 1 : int m = - 1 ; if ( Math . abs ( p + 1 ) < 0.0001 ) { m = ( int ) ( ( double ) ( n - 1 ) * Math . log ( n ) / ( double ) n ) ; } else { m = ( int ) p ; } System . out . println ( "N: " + n + " m: " + m ) ; network = netGen . generatePA ( n , m ) ; break ; case 2 : network = netGen . generateGrid ( n , ( int ) p ) ; break ; case 3 : network = netGen . generatePath ( n ) ; break ; case 4 : network = netGen . readFromAdjacencyMatrix ( "d:/4ntest.txt" ) ; break ; case 5 : network = netGen . generateStar ( n - 1 , 1 ) ; break ; case 6 : network = netGen . generateDoubleStart ( n , ( int ) p ) ; break ; case 7 : network = netGen . generateCompleteGraph ( n ) ; break ; case 8 : network = netGen . generateRGG ( n , p ) ; break ; case 9 : network = netGen . generateRing ( n ) ; break ; case 10 : network = netGen . generateER ( n , p ) ; break ; case 11 : network = netGen . generateConnectedERFixedAvDegree ( n , p ) ; break ; default : System . out . println ( "network type unknown" ) ; break ; } Runtime . getRuntime ( ) . gc ( ) ; }
va	9X	public static String translateImpl ( String string , String oldCharsequence , String newCharsequence ) { if ( string == null || oldCharsequence == null || oldCharsequence . length ( ) == 0 ) { return string ; } char [ ] stringChars = string . toCharArray ( ) ; char [ ] oldChars = oldCharsequence . toCharArray ( ) ; char [ ] newChars = ( newCharsequence != null ? newCharsequence : "" ) . toCharArray ( ) ; if ( newChars . length < oldChars . length ) { newChars = Arrays . copyOf ( newChars , oldChars . length ) ; } final StringBuilder result = new StringBuilder ( ) ; char copy ; for ( int i = 0 ; i < stringChars . length ; i ++ ) { copy = stringChars [ i ] ; for ( int j = 0 ; j < oldChars . length ; j ++ ) { if ( copy == oldChars [ j ] ) { if ( newCharsequence != null ) { copy = newChars [ j ] ; } else { copy =  ; } break ; } } if (  != copy ) { result . append ( copy ) ; } } return result . toString ( ) ; }
va	2	public RateLimitStatus ( Response res ) throws WeiboException { super ( res ) ; JSONObject json = res . asJSONObject ( ) ; try { JSONArray list = json . getJSONArray ( "api_rate_limits" ) ; int size = list . length ( ) ; apiRateLimit = new ArrayList < ApiRateLimits > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { apiRateLimit . add ( new ApiRateLimits ( list . getJSONObject ( i ) ) ) ; } ipLimit = json . getInt ( "ip_limit" ) ; remainingIpHits = json . getInt ( "remaining_ip_hits" ) ; remainingUserHits = json . getLong ( "remaining_user_hits" ) ; resetTime = json . getString ( "reset_time" ) ; resetTimeInSeconds = json . getInt ( "reset_time_in_seconds" ) ; userLimit = json . getLong ( "user_limit" ) ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone . getMessage ( ) + ":" + json . toString ( ) , jsone ) ; } }
va	5	public static void madMethod ( ) throws AuthorizationException , BusinessRuleViolation , DuplicateEntityViolation , SearchException , SystemError { double seed = Math . random ( ) ; if ( seed < 0.15 ) { throw new AuthorizationException ( Type . ACCESS_DENIED , new Exception ( "User crab not allowed" ) ) ; } else if ( seed < 0.3 ) { throw new DuplicateEntityViolation ( "Duplicate issue" , new NamedEntity ( ) ) ; } else if ( seed < 0.45 ) { throw new BusinessRuleViolation ( "Holy crab" , BusinessRule . FEE_TOO_SMALL , new NamedEntity ( ) ) ; } else if ( seed < 0.6 ) { throw new SearchException ( "Holy moly query" ) ; } else if ( seed < 0.75 ) { throw new SystemError ( "Gosh" , new Exception ( "Crab error" ) , visitorChallenge . exception . SystemError . Type . TRANSIENT_INSTANCE ) ; } System . out . println ( "Yupee" ) ; }
va	2	public synchronized static Result < ProductGateway > getProductsBySupplier ( int supplierID ) throws SQLException { Result < ProductGateway > result = new Result < ProductGateway > ( ) ; Connection connection = null ; PreparedStatement prepStmt = null ; try { connection = DB . getConnection ( ) ; connection . setAutoCommit ( true ) ; prepStmt = connection . prepareStatement ( "SELECT * FROM Product WHERE SupplierID = ?;" ) ; prepStmt . setInt ( 1 , supplierID ) ; prepStmt . setMaxRows ( 1 ) ; ResultSet rs = prepStmt . executeQuery ( ) ; while ( rs . next ( ) ) { ProductGateway product = new ProductGateway ( ) ; product . ProductID = rs . getInt ( "ProductID" ) ; product . SupplierID = rs . getInt ( "SupplierID" ) ; product . Price = rs . getDouble ( "Price" ) ; product . ProductName = rs . getString ( "ProductName" ) ; product . ProductDescription = rs . getString ( "ProductDescription" ) ; product . InStock = rs . getBoolean ( "InStock" ) ; result . Items . add ( product ) ; } rs . close ( ) ; prepStmt . close ( ) ; DB . closeConnection ( ) ; return result ; } catch ( Exception e ) { throw e ; } }
va	2	private boolean run ( String path ) { try { List < Token > data = Lexer . analyze ( read ( path ) ) ; if ( ! Parser . parse ( data ) ) return false ; return Checker . parse ( data ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; return false ; } }
va	5	public Point getClickedPoint ( int x , int y ) { Point p ; for ( Iterator < Point > iter = polypoints . iterator ( ) ; iter . hasNext ( ) ; ) { p = iter . next ( ) ; if ( x >= p . x - POINTSIZE2 && x <= p . x + POINTSIZE2 && y >= p . y - POINTSIZE2 && y <= p . y + POINTSIZE2 ) return p ; } return null ; }
va	7	public void createAtom ( ) { int nbSyllabes = rand . nextInt ( 4 ) ; boolean dou = dedouble ( ) ; if ( dou ) { name = name + name . charAt ( name . length ( ) - 1 ) ; createSyllabes ( nbSyllabes ) ; } else { char c = name . charAt ( name . length ( ) - 1 ) ; if ( c == a || c == e || c == i || c == o || c == u || c == y ) { name = name + chooseConsonne ( ) ; createSyllabes ( nbSyllabes ) ; } else { createSyllabes ( nbSyllabes ) ; } } }
va	1	public AccessToken getOAuthAccessToken ( String token , String tokenSecret , String oauth_verifier ) throws TBlogException { try { this . oauthToken = new OAuthToken ( token , tokenSecret ) { } ; this . oauthToken = new AccessToken ( httpRequest ( accessTokenURL , new PostParameter [ ] { new PostParameter ( "oauth_verifier" , oauth_verifier ) } , true ) ) ; } catch ( TBlogException te ) { throw new TBlogException ( "The user has not given access to the account." , te , te . getStatusCode ( ) ) ; } return ( AccessToken ) this . oauthToken ; }
va	2	@ Override public void add ( Client element ) { getList ( ) . add ( element ) ; Statement statement = null ; ResultSet result = null ; try { statement = getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( allQuery ) ; result . moveToInsertRow ( ) ; result . updateString ( "CLIENTFIO" , element . getFio ( ) ) ; result . updateString ( "CLIENTADR" , element . getAddress ( ) ) ; result . updateString ( "CLIENTPAS" , element . getPassport ( ) ) ; result . updateString ( "CLIENTIDCOD" , element . getIdCod ( ) ) ; result . updateString ( "CLIENTTEL" , element . getTel ( ) ) ; result . updateLong ( "CLIENTLEVEL" , element . getLevel ( ) ) ; result . updateString ( "CLIENTWORKINFO" , element . getWorkInfo ( ) ) ; result . updateInt ( "USERSID" , element . getUsersId ( ) ) ; result . insertRow ( ) ; } catch ( SQLException ex ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B" ) ; } finally { try { statement . close ( ) ; result . close ( ) ; } catch ( SQLException ex ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043A\u0440\u044B\u0442\u0438\u0438 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F" ) ; } } }
va	0	public void setArmour ( String armour ) { this . armour = armour ; }
va	0	int newMark ( ) { return ++ currentMark ; }
va	7	public void remove ( int i , int j ) throws BadLocationException { int k = getSelectionStart ( ) ; if ( k > 0 ) k -- ; String s = getMatch ( getText ( 0 , k ) ) ; if ( ! isStrict && s == null ) { super . remove ( i , j ) ; } else { super . remove ( 0 , getLength ( ) ) ; super . insertString ( 0 , s , null ) ; } if ( autoComboBox != null && s != null ) autoComboBox . setSelectedValue ( s ) ; try { setSelectionStart ( k ) ; setSelectionEnd ( getLength ( ) ) ; } catch ( Exception exception ) { } if ( autoComboBox != null ) { autoComboBox . fireActionEvent ( ) ; } current = s ; }
va	7	public static String getDayOfWeek ( int i ) { switch ( i ) { case 1 : return "Sunday" ; case 2 : return "Monday" ; case 3 : return "Tuesday" ; case 4 : return "Wednesday" ; case 5 : return "Thursday" ; case 6 : return "Friday" ; case 7 : return "Saturday" ; default : return ( "Invalid Day Number" ) ; } }
va	6	@ Override public void validate ( ) { Algorithm algorithm = getAlgorithm ( ) ; for ( int foldIndex = 0 ; foldIndex < k ; foldIndex ++ ) { Set < Pattern > testSet = new HashSet < Pattern > ( folds [ foldIndex ] ) ; Set < Pattern > trainingSet = new DataSet ( getDataSet ( ) ) ; for ( int fold = 0 ; fold < k ; fold ++ ) { if ( fold != foldIndex ) { trainingSet . addAll ( folds [ fold ] ) ; } } algorithm . setTrainSet ( ( DataSet ) trainingSet ) ; algorithm . train ( ) ; for ( Pattern instance : testSet ) { if ( algorithm instanceof Classifier ) { int calculated = ( ( Classifier ) algorithm ) . classify ( instance ) ; int correct = instance . getClassIndex ( ) ; super . evaluate ( calculated , correct ) ; } else if ( algorithm instanceof Recuperator ) { Pattern recuperated = ( ( Recuperator ) algorithm ) . recover ( instance ) ; super . evaluate ( recuperated , instance ) ; } } } }
va	1	@ Override public int hashCode ( ) { int hash = 3 ; hash = 83 * hash + ( this . id != null ? this . id . hashCode ( ) : 0 ) ; return hash ; }
va	2	@ Override public int compare ( Field f1 , Field f2 ) { if ( ! f1 . getName ( ) . equals ( f2 . getName ( ) ) ) { return f1 . getName ( ) . compareTo ( f2 . getName ( ) ) ; } else if ( ! f1 . getType ( ) . equals ( f2 . getType ( ) ) ) { return f1 . getType ( ) . getName ( ) . compareTo ( f2 . getType ( ) . getName ( ) ) ; } return 0 ; }
va	9X	public static String toJSONString ( Object value ) { if ( value == null ) return "null" ; if ( value instanceof String ) return "\"" + escape ( ( String ) value ) + "\"" ; if ( value instanceof double ) { if ( ( ( double ) value ) . isInfinite ( ) || ( ( double ) value ) . isNaN ( ) ) return "null" ; else return value . toString ( ) ; } if ( value instanceof float ) { if ( ( ( float ) value ) . isInfinite ( ) || ( ( float ) value ) . isNaN ( ) ) return "null" ; else return value . toString ( ) ; } if ( value instanceof Number ) return value . toString ( ) ; if ( value instanceof boolean ) return value . toString ( ) ; if ( ( value instanceof JSONAware ) ) return ( ( JSONAware ) value ) . toJSONString ( ) ; if ( value instanceof Map ) return JSONObject . toJSONString ( ( Map ) value ) ; if ( value instanceof List ) return JSONArray . toJSONString ( ( List ) value ) ; return value . toString ( ) ; }
va	6	public void checkForWin ( ) { if ( this . playerScore >= this . maxScore || this . computerScore >= this . maxScore ) { this . gameOn = false ; this . stopTimers ( ) ; if ( this . playerScore >= this . maxScore ) { if ( this . level < this . maxLevel ) { this . initNextLevel ( ) ; } else { this . gameOver = true ; this . gameWin = true ; } } else if ( this . computerScore >= this . maxScore ) { if ( -- this . lives > 0 ) { this . initLevel ( ) ; } else { this . gameOver = true ; this . gameWin = false ; } } } }
va	3	public Comparator < Mob > getComparator ( ) { switch ( targetingMode ) { case leatHealth : return LEAST_HEALTH_COMPARATOR ; case nearest : return NEAREST_COMPARATOR ; case random : return RANDOM_COMPARATOR ; default : return null ; } }
va	3	PathIterator getNormalizingPathIterator ( final RendererContext rdrCtx , final NormMode mode , final PathIterator src ) { switch ( mode ) { case ON_WITH_AA : return rdrCtx . nPCPathIterator . init ( src ) ; case ON_NO_AA : return rdrCtx . nPQPathIterator . init ( src ) ; case OFF : return src ; default : throw new InternalError ( "Unrecognized normalization mode" ) ; } }
va	8	private AANode < AnyType > remove ( AnyType x , AANode < AnyType > t ) { if ( t != nullNode ) { lastNode = t ; if ( x . compareTo ( t . element ) < 0 ) t . left = remove ( x , t . left ) ; else { deletedNode = t ; t . right = remove ( x , t . right ) ; } if ( t == lastNode ) { if ( deletedNode == nullNode || x . compareTo ( deletedNode . element ) != 0 ) return t ; deletedNode . element = t . element ; t = t . right ; } else if ( t . left . level < t . level - 1 || t . right . level < t . level - 1 ) { if ( t . right . level > -- t . level ) t . right . level = t . level ; t = skew ( t ) ; t . right = skew ( t . right ) ; t . right . right = skew ( t . right . right ) ; t = split ( t ) ; t . right = split ( t . right ) ; } } return t ; }
va	8	private void init ( ) { int run_server = JOptionPane . showConfirmDialog ( null , "Run the server ? " ) ; if ( run_server == 0 ) { server = new Server ( this ) ; client = new Client ( this , "localhost" ) ; client . start ( ) ; } else if ( run_server == 1 ) { try { client = new Client ( this , JOptionPane . showInputDialog ( null , "Enter IP: " ) ) ; client . start ( ) ; } catch ( HeadlessException e ) { e . printStackTrace ( ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } } else if ( run_server == 2 ) { System . out . println ( "Exiting at 0." ) ; System . exit ( 0 ) ; } String username = JOptionPane . showInputDialog ( null , "Enter Username:" ) ; if ( username == null ) { System . out . println ( "Exiting at 1." ) ; System . exit ( 1 ) ; } if ( username . trim ( ) . equals ( "" ) ) { username = "Player" ; } String info = "" + "<html>" + "<h3>SETTINGS:</h3>" + "<table border=1>" + "<tr>" + "<td>Walk:</td>" + "<td style='color: green'>WASD or ARROWS KEYS</td>" + "</tr>" + "<tr>" + "<td>Shoot:</td>" + "<td style='color: green'>LEFT CLICK</td>" + "</tr>" + "<tr>" + "<td>1st Weapon:</td>" + "<td style='color: green'>1</td>" + "</tr>" + "<tr>" + "<td>2nd Weapon:</td>" + "<td style='color: green'>2</td>" + "</tr>" + "<tr>" + "<td>Speed Boost:</td>" + "<td style='color: green'>SHIFT</td>" + "</tr>" + "<tr>" + "<td>Toggle invisible:</td>" + "<td style='color: green'>I</td>" + "</tr>" + "</table>" + "<h4>Good Luck !!!</h3>" + "</html>" ; JOptionPane . showMessageDialog ( null , info ) ; player = new PlayerMP ( 10 , 10 , username , key , mouse , null , - 1 , true ) ; level . addEntity ( player ) ; Packet00Login packet = new Packet00Login ( player . getUsername ( ) , player . getX ( ) , player . getY ( ) , player . getHP ( ) , player . getUniqueID ( ) ) ; packet . writeData ( client ) ; if ( server != null ) { server . addConnections ( ( PlayerMP ) player , packet ) ; server . start ( ) ; Tonny tonny = new Tonny ( 100 , 100 , 100 ) ; Packet05AddNPC packetNPC = new Packet05AddNPC ( ( int ) tonny . getX ( ) , ( int ) tonny . getY ( ) , tonny . getHP ( ) , tonny . getUniqueID ( ) , MobType . TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; BadTonny bad_tonny = new BadTonny ( 170 , 20 , 20 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; bad_tonny = new BadTonny ( 200 , 300 , 100 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; bad_tonny = new BadTonny ( 250 , 300 , 100 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; } }
va	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
va	2	private void sendResultToJobClient ( ) { try { String slaveName = SystemConstants . getConfig ( SystemConstants . NAMENODE_SLAVE_SERVICE ) ; String hostName = getJobTrackerServiceProvider ( ) . getJobOriginHostNamebyTaskID ( taskID ) ; String lookup_name = "rmi://" + hostName + ":" + 1099 + "/" + slaveName + "_" + hostName ; System . out . println ( "Building a look up make for the Slave  : " + lookup_name ) ; NameNodeSlave originSlave = ( NameNodeSlave ) Naming . lookup ( lookup_name ) ; System . out . println ( "NameNodeSlave has been looked up." ) ; for ( String filename : getCreatedFiles ( ) ) { String data = this . nameNodeSlaveReference . retrieveFromLocalDataNode ( filename ) ; originSlave . saveFileToLocalDataNode ( filename , data ) ; } } catch ( Exception e ) { System . out . println ( "Manager: Exception thrown looking up " + "NameNodeSlave" ) ; } }
va	2	private synchronized void executeReceive ( ) { try { String data = input . readLine ( ) ; if ( data != null ) notifyNewData ( data ) ; } catch ( IOException e ) { notifyReadFailure ( e ) ; } }
va	0	public Integer getAudienceId ( ) { return audienceId ; }
va	2	public long getLong ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
va	6	private static int maxProduct ( int [ ] array ) { if ( array . length == 1 ) { return array [ 0 ] ; } int negativeCount = 0 ; int largestNegative = 0 ; int max = 1 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { continue ; } if ( array [ i ] < 0 ) { negativeCount ++ ; if ( largestNegative == 0 ) { largestNegative = array [ i ] ; } else { largestNegative = Math . max ( array [ i ] , largestNegative ) ; } } max *= array [ i ] ; } if ( negativeCount % 2 != 0 ) { max /= largestNegative ; } return max ; }
va	0	@ Override public String getName ( ) { return name ; }
va	0	public JFrame getFullScreenWindow ( ) { return ( JFrame ) device . getFullScreenWindow ( ) ; }
te	0	@ Test public void answerTest2 ( ) { Recommendation rec = new Recommendation ( ) ; rec . setSelf ( false ) ; rec . setSender ( first ) ; rec . setWriter ( second ) ; rec . setSubject ( third ) ; recommendationsDao . putQuery ( rec ) ; recommendationsDao . processAnswer ( 1 , "blablabla" ) ; assert . assertEquals ( "blablabla" , ( ( Recommendation ) recommendationsDao . getInbox ( 1 ) . iterator ( ) . next ( ) ) . getMessage ( ) ) ; }
te	9X	public String toString ( ) { NumberFormat nf = NumberFormat . getCurrencyInstance ( Locale . US ) ; StringBuilder buffer = new StringBuilder ( ) ; int caracteres = 50 ; String adorno = ":_-_:" ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\t\tBALANCE DE COMPROBACI\u00D3N\t\t\n" ) ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\n" ) ; while ( balance . size ( ) > 0 ) { buffer . append ( balance . peek ( ) . codigo + "  " + balance . peek ( ) . nombre ) ; CuentaT temp = balance . pollFirst ( ) ; if ( temp . saldo > 0 ) { double debe = temp . saldo ; totalDebe += debe ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t" + nf . format ( debe ) ) ; } else if ( temp . nombre . length ( ) > 15 ) { buffer . append ( "\t" + nf . format ( debe ) ) ; } else { buffer . append ( "\t\t\t" + nf . format ( debe ) ) ; } } else { double haber = temp . saldo * - 1 ; totalHaber += haber ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) > 15 && temp . nombre . length ( ) < 25 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) >= 25 ) { buffer . append ( "\t\t\t" + nf . format ( haber ) ) ; } else { buffer . append ( "\t\t\t\t\t" + nf . format ( haber ) ) ; } } buffer . append ( "\n" ) ; } for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( "-----" ) ; } buffer . append ( "\n" ) ; buffer . append ( "\t\t\t" + nf . format ( totalDebe ) + "\t" + nf . format ( totalHaber ) ) ; return buffer . toString ( ) ; }
te	7	static int [ ] dijkstraSub ( MatrixGraph g , int s , int t , int [ ] prev ) { int [ ] dists = new int [ g . n ] ; Arrays . fill ( dists , INF ) ; dists [ s ] = 0 ; PriorityQueue < EdgeState > queue = new PriorityQueue < EdgeState > ( ) ; queue . add ( new EdgeState ( 0 , s ) ) ; while ( ! queue . isEmpty ( ) ) { EdgeState state = queue . poll ( ) ; if ( dists [ state . n ] < state . cost ) continue ; if ( state . n == t ) break ; for ( int v = 0 ; v < g . n ; v ++ ) { Edge e = g . edges [ state . n ] [ v ] ; if ( e != null && dists [ v ] > dists [ state . n ] + e . cost ) { dists [ v ] = dists [ state . n ] + e . cost ; if ( prev != null ) prev [ v ] = state . n ; queue . add ( new EdgeState ( dists [ v ] , v ) ) ; } } } return dists ; }
te	8	public static Matrix read ( BufferedReader input ) throws java . io . IOException { StreamTokenizer tokenizer = new StreamTokenizer ( input ) ; tokenizer . resetSyntax ( ) ; tokenizer . wordChars ( 0 , 255 ) ; tokenizer . whitespaceChars ( 0 ,   ) ; tokenizer . eolIsSignificant ( true ) ; java . util . Vector v = new java . util . Vector ( ) ; while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_EOL ) ; if ( tokenizer . ttype == StreamTokenizer . TT_EOF ) throw new java . io . IOException ( "Unexpected EOF on matrix read." ) ; do { v . addElement ( double . valueOf ( tokenizer . sval ) ) ; } while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) ; int n = v . size ( ) ; double row [ ] = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) row [ j ] = ( ( double ) v . elementAt ( j ) ) . doubleValue ( ) ; v . removeAllElements ( ) ; v . addElement ( row ) ; while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) { v . addElement ( row = new double [ n ] ) ; int j = 0 ; do { if ( j >= n ) throw new java . io . IOException ( "Row " + v . size ( ) + " is too long." ) ; row [ j ++ ] = double . valueOf ( tokenizer . sval ) . doubleValue ( ) ; } while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) ; if ( j < n ) throw new java . io . IOException ( "Row " + v . size ( ) + " is too short." ) ; } int m = v . size ( ) ; double [ ] [ ] A = new double [ m ] [ ] ; v . copyInto ( A ) ; return new Matrix ( A ) ; }
te	8	void selectpanel ( ) { if ( s . gettype ( ) . endsWith ( "bubble" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; bubblepanel . setVisible ( true ) ; arrowpanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "entity" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; entitypanel . setVisible ( true ) ; } else if ( s . gettype ( ) . endsWith ( "flowarrow" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( true ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "datastore" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( true ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "ctrlarrow" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( true ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "module" ) ) { modulepanel . setVisible ( true ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; dfd d = ( dfd ) Global . n . tabs . getComponentAt ( 0 ) ; for ( int i = 0 ; i < d . shapes . size ( ) ; i ++ ) { if ( d . shapes . get ( i ) . gettype ( ) . endsWith ( "bubble" ) ) { bubbles . addItem ( d . shapes . get ( i ) . name ) ; } } } }
te	3	public Animable_Sub5 ( int i , int j , int k , int l , int i1 , int j1 , int k1 , int l1 , boolean flag ) { anInt1610 = i ; anInt1611 = k ; anInt1612 = j ; anInt1603 = j1 ; anInt1604 = l ; anInt1605 = i1 ; anInt1606 = k1 ; if ( l1 != - 1 ) { aAnimation_1607 = Animation . anims [ l1 ] ; anInt1599 = 0 ; anInt1608 = client . loopCycle ; if ( flag && aAnimation_1607 . anInt356 != - 1 ) { anInt1599 = ( int ) ( Math . random ( ) * ( double ) aAnimation_1607 . anInt352 ) ; anInt1608 -= ( int ) ( Math . random ( ) * ( double ) aAnimation_1607 . method258 ( anInt1599 ) ) ; } } ObjectDef class46 = ObjectDef . forID ( anInt1610 ) ; anInt1601 = class46 . anInt774 ; anInt1602 = class46 . anInt749 ; anIntArray1600 = class46 . childrenIDs ; }
te	5	private static List < ABObject > GetSupporteeShel ( List < ABObject > left , ABObject roof ) { List < ABObject > temp = new ArrayList < ABObject > ( ) ; ABObject leftRoof = null ; for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( left . get ( i ) . id == roof . id ) { leftRoof = left . get ( i ) ; break ; } } if ( leftRoof == null ) { leftRoof = roof ; } for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( left . get ( i ) . depth < leftRoof . depth ) { temp . add ( left . get ( i ) ) ; } } return temp ; }
te	1	public int get ( long index ) { if ( ! map . containsKey ( index ) ) throw new ArrayIndexOutOfBoundsException ( "index is " + index ) ; return map . get ( index ) ; }
te	7	public void write ( int bits , int width ) throws IOException { if ( bits == 0 && width == 0 ) { return ; } if ( width <= 0 || width > 32 ) { throw new IOException ( "Bad write width." ) ; } while ( width > 0 ) { int actual = width ; if ( actual > this . vacant ) { actual = this . vacant ; } this . unwritten |= ( ( bits >>> ( width - actual ) ) & BitInputStream . mask [ actual ] ) << ( this . vacant - actual ) ; width -= actual ; nrBits += actual ; this . vacant -= actual ; if ( this . vacant == 0 ) { this . out . write ( this . unwritten ) ; this . unwritten = 0 ; this . vacant = 8 ; } } }
te	3	static public void EliminacionGaussiana ( double a [ ] [ ] , double x [ ] , double b [ ] ) { int n = a . length ; for ( int k = 0 ; k <= n - 2 ; k ++ ) { for ( int i = k + 1 ; i <= ( n - 1 ) ; i ++ ) { b [ i ] -= a [ i ] [ k ] * b [ k ] / a [ k ] [ k ] ; for ( int j = n - 1 ; j >= k ; j -- ) a [ i ] [ j ] -= a [ i ] [ k ] * a [ k ] [ j ] / a [ k ] [ k ] ; } } }
te	9X	private void outOther ( Scope scope , List < String > outerSels , NodeInfo node ) throws IOException { if ( node instanceof VariableDefinition ) { final VariableDefinition vdef = ( VariableDefinition ) node ; scope . setVariable ( vdef . getName ( ) , evalDefinition ( scope , vdef ) ) ; } else if ( node instanceof FunctionDefinition ) { final FunctionDefinition fd = ( FunctionDefinition ) node ; scope . setVariable ( fd . getName ( ) , fd ) ; } else if ( node instanceof MixinDefinition ) { final MixinDefinition fd = ( MixinDefinition ) node ; scope . setVariable ( fd . getName ( ) , fd ) ; } else if ( node instanceof IfDefinition ) { for ( NodeInfo child : node . getChildren ( ) ) { final BlockDefinition block = ( BlockDefinition ) child ; final Expression expr = block . getCondition ( ) ; if ( expr == null || isTrue ( scope , expr ) ) { outChildren ( scope , outerSels , block ) ; break ; } } } else if ( node instanceof MediaDefinition ) { write ( "@media " ) ; write ( ( ( MediaDefinition ) node ) . getRange ( ) ) ; write ( "{\n" ) ; outChildren ( scope , outerSels , node ) ; write ( "}\n" ) ; } else if ( node instanceof RawValue ) { write ( ( ( RawValue ) node ) . getValue ( ) ) ; } else { throw error ( "unknown " + node , node ) ; } }
te	7	private List < Organisation > processAgencies ( StartElement se , XMLEventReader eventReader ) throws XMLStreamException , ExternalRefrenceNotFoundException { List < Organisation > agencies = new ArrayList < Organisation > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Agency" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { Organisation o = processOrganisation ( se , eventReader , "Agency" ) ; agencies . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Agencies" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { endTagReached = true ; } } } return agencies ; }
te	8	private static void showEAGsInCanvas ( RequirementGraph req_model , int visualization ) throws ScriptException { for ( AntiGoal ag : req_model . ag_elems ) { String element_id = AppleScript . drawArbitraryRequirementElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "All" , InfoEnum . reverse_req_elem_type_map . get ( InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) ) , InfoEnum . NORMAL_SIZE , "{500 500}" , "0" , ag . getName ( ) , "0" , "1" ) ; ag . setId ( element_id ) ; if ( visualization == InfoEnum . HIGHLIGHT_VIEW && ag . isCriticality ( ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Red" , "Simple" ) ; } else if ( visualization == InfoEnum . HIGHLIGHT_VIEW && ag . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Blue" , "Simple" ) ; } } for ( RequirementLink rl : req_model . ag_links ) { String link_id = AppleScript . drawExhaustiveRefinementLink ( rl ) ; rl . setId ( link_id ) ; AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "1" , "none" , "All" ) ; if ( visualization == InfoEnum . HIGHLIGHT_VIEW && rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "3" , "Blue" , "Simple" ) ; } } }
te	7	public void doSort ( Object [ ] a , int lo , int hi ) { stackSize = 0 ; rangeCheck ( a . length , lo , hi ) ; int nRemaining = hi - lo ; if ( nRemaining < 2 ) { return ; } if ( nRemaining < MIN_MERGE ) { int initRunLen = countRunAndMakeAscending ( a , lo , hi ) ; binarySort ( a , lo , hi , lo + initRunLen ) ; return ; } this . a = a ; int minRun = minRunLength ( nRemaining ) ; do { int runLen = countRunAndMakeAscending ( a , lo , hi ) ; if ( runLen < minRun ) { int force = nRemaining <= minRun ? nRemaining : minRun ; binarySort ( a , lo , lo + force , lo + runLen ) ; runLen = force ; } pushRun ( lo , runLen ) ; mergeCollapse ( ) ; lo += runLen ; nRemaining -= runLen ; } while ( nRemaining != 0 ) ; if ( DEBUG ) { assert lo == hi ; } mergeForceCollapse ( ) ; if ( DEBUG ) { assert stackSize == 1 ; } }
te	9X	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x >= 0 ) && ( x < width ) ) && ( ( y >= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] == MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] != MapTile . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
te	2	public String doCleanLink ( String link ) { if ( link == null ) return null ; try { link = URLDecoder . decode ( link , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( "le broken JVM face" ) ; } return link ; }
te	7	public void act ( List < Actor > newActor ) { refresh ++ ; if ( refresh < 20 ) return ; refresh = 0 ; int modifier = maximumGrass - ( countRabbits ( ) / dependencies ) ; modifier = ( modifier < minimumGrass ) ? minimumGrass : modifier ; if ( amountGrass < modifier || ( countRabbits ( ) < 1000 && amountGrass < maximumGrass ) || amountGrass < minimumGrass ) { Location l = field . freeAdjacentLocation ( location ) ; if ( l != null ) { newActor . add ( new Grass ( field , l ) ) ; increase ( ) ; } } else { reduce ( ) ; this . isActive ( false ) ; } }
te	2	@ Override public void defaultTick ( ) { Mob m = getMobInRadius ( radius ) ; if ( m != null ) { lookAtInstance ( m ) ; if ( shootTimer > 0 ) { shootTimer -= 1 ; } else { isShooting = true ; shoot ( direction , 7 ) ; shootTimer = SHOOT_TIME ; } } else { isShooting = false ; } }
te	2	public boolean startsWithOK ( ) { if ( len < 2 ) return false ; return array [ 0 ] == 111 && array [ 1 ] == 107 ; }
te	3	private String parseReadabilityText ( ResultSet rs ) { try { int contractor = rs . getInt ( "contractor" ) ; String text = rs . getString ( "blurb" ) ; Readability r = new Readability ( text ) ; if ( text . contains ( "[a-z]+" ) ) { double ari = null ; try { ari = r . getARI ( ) ; } catch ( NumberFormatException e ) { System . out . println ( text ) ; System . out . println ( "Smog:" + r . getSMOG ( ) ) ; } String insertString = "('" + contractor + "' '" + r . getSMOG ( ) + "' '" + ari + "' '" + r . getColemanLiau ( ) + "' '" + r . getFleschKincaidGradeLevel ( ) + "' '" + r . getGunningFog ( ) + "' '" + r . getSMOGIndex ( ) + "' '" + r . getCharacters ( ) + "' '" + r . getWords ( ) + "' '" + r . getSentences ( ) + "' '" + r . getSyllables ( ) + "' '" + r . getComplex ( ) + "')" ; return insertString ; } else return "('" + contractor + "' '" + - 1 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "')" ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return "" ; } }
te	7	public static int commonAuto ( MatchData match ) { int two , four , six ; two = four = six = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof TwoPointAuto ) { two ++ ; } else if ( p instanceof FourPointAuto ) { four ++ ; } else if ( p instanceof SixPointAuto ) { six ++ ; } } int max = Math . max ( two , Math . max ( four , six ) ) ; return max == six ? 6 : ( max == four ? 4 : ( max == two ? 2 : 0 ) ) ; }
te	3	public BinaryTree < K , V > next ( ) { if ( queue . isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } BinaryTree < K , V > tree = queue . poll ( ) ; if ( tree . lhs != null ) { queue . add ( tree . lhs ) ; } if ( tree . rhs != null ) { queue . add ( tree . rhs ) ; } return tree ; }
te	2	public void verify ( FileInputStream ciphertext , FileInputStream cleartext ) { int bitLen = q . bitLength ( ) ; int blockLen = ( bitLen - 1 ) / 8 ; BigInteger cipher = readCipher ( ciphertext ) ; BigInteger clear = readClear ( cleartext , blockLen ) ; while ( cipher != null ) { if ( ! verifyBlock ( clear , cipher ) ) { System . out . println ( "Wrong signature!" ) ; return ; } cipher = readCipher ( ciphertext ) ; clear = readClear ( cleartext , blockLen ) ; } System . out . println ( "Correct signature!" ) ; }
te	2	public static void main ( String [ ] args ) throws Exception { rd = new BufferedReader ( new FileReader ( "d:\\programDATA\\Numbers\\C-large-practice.in" ) ) ; wr = new PrintWriter ( new FileWriter ( "d:\\programDATA\\Numbers\\C-large-practice.out" ) ) ; int num ; String line = rd . readLine ( ) ; while ( true ) { line = rd . readLine ( ) ; if ( line == null ) break ; else wr . print ( "Case #" + count ++ + ": " ) ; num = Integer . parseInt ( line ) ; calc ( num ) ; } rd . close ( ) ; wr . close ( ) ; }
te	4	public static void getNum ( ) { long n = 2 * 3 * 5 * 7 * 11 ; while ( true ) { long sq = n * n ; int count = 2 ; for ( int i = 2 ; i < n ; i ++ ) { if ( sq % i == 0 ) { count ++ ; } } if ( count > 1000 ) { System . out . println ( n + " " + count ) ; break ; } n += 2 * 3 * 5 * 7 * 11 ; } }
te	7	public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return HEAD_ITEM ; case 2 : return ITEMS ; case 3 : return BYTES ; case 4 : return JOURNAL_BYTES ; case 5 : return AGE ; case 6 : return WAITERS ; case 7 : return OPEN_TRANSACTIONS ; default : return null ; } }
te	1	private InputStream getBufferedBody ( ) { if ( this . _bufferedOutput == null ) { return null ; } return new ByteArrayInputStream ( this . _bufferedOutput ) ; }
te	3	int open_callbacks ( InputStream is , byte [ ] initial , int ibytes ) throws JOrbisException { int ret ; datasource = is ; oy . init ( ) ; if ( initial != null ) { int index = oy . buffer ( ibytes ) ; System . arraycopy ( initial , 0 , oy . data , index , ibytes ) ; oy . wrote ( ibytes ) ; } if ( is instanceof SeekableInputStream ) { ret = open_seekable ( ) ; } else { ret = open_nonseekable ( ) ; } if ( ret != 0 ) { datasource = null ; clear ( ) ; } return ret ; }
te	5	protected void drawBackground ( Graphics2D g , double x , double y , double w , double h ) { double l = box . getLeftMargin ( ) != null ? box . getLeftMargin ( ) . getValue ( Unit . PT ) : 0 ; double r = box . getRightMargin ( ) != null ? box . getRightMargin ( ) . getValue ( Unit . PT ) : 0 ; double t = box . getTopMargin ( ) != null ? box . getTopMargin ( ) . getValue ( Unit . PT ) : 0 ; double b = box . getBottomMargin ( ) != null ? box . getBottomMargin ( ) . getValue ( Unit . PT ) : 0 ; x += l ; y += t ; w -= l + r ; h -= t + b ; if ( box . getBackground ( ) != null ) { Color savedColor = g . getColor ( ) ; g . setColor ( box . getBackground ( ) ) ; g . fill ( new Rectangle2D . double ( x , y , w , h ) ) ; g . setColor ( savedColor ) ; } }
te	5	public Object readObject ( boolean blocking ) throws ConnectionLostException { if ( socket == null ) throw new ConnectionLostException ( ) ; try { return bis . available ( ) > 0 || blocking ? ois . readObject ( ) : null ; } catch ( IOException e ) { System . err . println ( "Socket Exception: Cannot read from socket." ) ; socket = null ; throw new ConnectionLostException ( "Socket Exception: Cannot write to socket." ) ; } catch ( ClassNotFoundException e ) { System . err . println ( "Network Exception: Cannot receive game object from server. Check server version." ) ; } return null ; }
te	8	private void getFriendRealQQ ( ) { HashMap < String , String > properties = new HashMap < String , String > ( ) ; properties . put ( PROPERTY_REFER , URL_REFER_GET_INFO ) ; properties . put ( PROPERTY_ACCEPT , "*/*" ) ; properties . put ( PROPERTY_ACCEPT_ENCODING , "gzip deflate sdch" ) ; properties . put ( PROPERTY_CONNECTION , "keep-alive" ) ; properties . put ( PROPERTY_HOST , "s.web2.qq.com" ) ; properties . put ( PROPERTY_ORIGIN , "http://s.web2.qq.com" ) ; Iterator < String > iterator = friends . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String key = iterator . next ( ) ; String content = String . format ( URL_FORMAT_GET_FRIEND_QQ , key , verifySession , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = sendGet ( content , properties ) ; System . out . println ( resultString ) ; try { JSONObject base = new JSONObject ( resultString ) ; if ( base . optInt ( "retcode" , - 1 ) == 0 ) { JSONObject result = base . optJSONObject ( "result" ) ; Friend friend = friends . get ( key ) ; friend . setQQ ( result . optString ( "account" , friend . getUin ( ) ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } iterator = groups . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String groupUni = iterator . next ( ) ; HashMap < String , Friend > members = groups . get ( groupUni ) . getMembers ( ) ; Iterator < String > memberIterator = members . keySet ( ) . iterator ( ) ; while ( memberIterator . hasNext ( ) ) { String key = memberIterator . next ( ) ; if ( friends . containsKey ( key ) ) { members . get ( key ) . setQQ ( friends . get ( key ) . getQQ ( ) ) ; } else { String content = String . format ( URL_FORMAT_GET_FRIEND_QQ , key , verifySession , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = sendGet ( content , properties ) ; System . out . println ( "GroupMemberQQ--" + resultString ) ; try { JSONObject base = new JSONObject ( resultString ) ; if ( base . optInt ( "retcode" , - 1 ) == 0 ) { JSONObject result = base . optJSONObject ( "result" ) ; Friend member = members . get ( key ) ; member . setQQ ( result . optString ( "account" , member . getUin ( ) ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } } }
te	8	private int InterseccionX ( double _x1 , double _w1 , double _x2 , double _w2 ) { int estado = 0 ; if ( _x1 <= _x2 + _w2 && _x2 + _w2 <= _x1 + _w1 ) { estado = 1 ; } else if ( _x1 <= _x2 && _x2 <= _x1 + _w1 ) { estado = 1 ; } else if ( _x2 <= _x1 + _w1 && _x1 + _w1 <= _x2 + _w2 ) { estado = 1 ; } else if ( _x2 <= _x1 && _x1 <= _x2 + _w2 ) { estado = 1 ; } return estado ; }
te	6	public MySmartCarTester ( ) throws Exception { super ( inputCount , outputCount , new IMyNeuronFunction < double > ( ) { @ Override public double process ( List < double > inData , List < double > weights , double threshold ) throws Exception { if ( inData . size ( ) != weights . size ( ) ) { throw new Exception ( "inData size doesnt match weights size" ) ; } if ( threshold == null ) { throw new Exception ( "threshold cannot be null" ) ; } double total = 0 ; for ( int i = 0 ; i < inData . size ( ) ; i ++ ) { total += inData . get ( i ) * weights . get ( i ) ; } double answer = 1 / ( 1 + Math . exp ( ( - total ) / threshold ) ) ; return answer ; } } ) ; init ( new IMyFitnessTestFunction < double > ( ) { @ Override public int testFitness ( List < double > list ) { try { resetWeightsAndThresholds ( list ) ; List < double > in = Arrays . asList ( new double [ ] { ( double ) targetPoint . getX ( ) , ( double ) targetPoint . getY ( ) , ( double ) carStart . getX ( ) , ( double ) carStart . getY ( ) } ) ; double sumDataIn = in . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; List < double > output = getNetworkOutput ( in ) ; double sumDataOut = output . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; System . out . println ( "in:" + sumDataIn + " out" + sumDataOut ) ; MyPoint distance = targetPoint . subtract ( carStart ) ; MyPoint guessLineShort = new MyPoint ( output . get ( 0 ) . floatValue ( ) , output . get ( 1 ) . floatValue ( ) ) ; MyPoint guessLine = guessLineShort . scale ( ( float ) ( distance . getX ( ) / guessLineShort . getX ( ) ) ) ; line = new MyCollidableLine ( new MyDrawablePoint ( carStart . getX ( ) , carStart . getY ( ) ) , new MyDrawablePoint ( guessLine . getX ( ) , guessLine . getY ( ) ) ) ; line . setColor ( Color . black ) ; List < MyPoint > c = line . isColliding ( targetRect ) ; if ( c != null && ! c . isEmpty ( ) ) { return 100 ; } else { return 0 ; } } catch ( Exception ex ) { Logger . getLogger ( MySmartCarTester . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return 0 ; } } , rf ) ; }
te	7	public String animate ( double speedmul ) { String ret = getCurrentFrame ( ) ; if ( running ) { phase += speed * speedmul ; while ( phase >= 1.0 ) { phase -= 1.0 ; framenr += increment ; if ( ! pingpong ) { if ( framenr >= frames . length ) framenr -= frames . length ; if ( framenr < 0 ) framenr += frames . length ; } else { if ( framenr >= frames . length ) { framenr -= 2 * increment ; increment = - increment ; } if ( framenr < 0 ) { framenr -= 2 * increment ; increment = - increment ; } } } } return ret ; }
te	3	@ Test public void addPayment ( ) { testAddClaim ( ) ; Claim claim = instance . getClaim ( claims . get ( claims . size ( ) == 1 ? 0 : ( random . nextInt ( claims . size ( ) - 1 ) ) ) ) ; int id = instance . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , "Nordea: 235425 648" ) ; ArrayList < Payment > payments = instance . getPayments ( ) ; Payment payment = null ; for ( Payment p : payments ) { if ( p . getId ( ) == id ) { payment = p ; break ; } } assertFalse ( payment == null ) ; assertEquals ( payment . getId ( ) , id ) ; assertEquals ( ( int ) payment . getCustomerId ( ) , ( int ) claim . getCustomerId ( ) ) ; assertEquals ( payment . getClaimId ( ) , claim . getId ( ) ) ; assertEquals ( ( int ) payment . getAmount ( ) , ( int ) claim . getDamageCost ( ) ) ; }
te	4	@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof Counter ) ) return false ; Counter < ? > c = ( Counter < ? > ) obj ; return _counts . equals ( c . _counts ) ; }
te	0	public void setInicio ( java . sql . Time inicio ) { this . inicio = inicio ; }
te	1	public static boolean isRotatedString ( String base , String rotated ) { if ( base . length ( ) != rotated . length ( ) ) { return false ; } String concatenated = rotated . concat ( rotated ) ; return concatenated . indexOf ( base ) != - 1 ; }
te	1	private void endBlock ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new TextString ( s ) ) ; } container = null ; }
te	8	public void scaleCPU ( int scaleToVal ) { String vmname = config . getvm_name ( ) ; int currentCPUCap , scaleToCPUCap ; ProcessBuilder p = new ProcessBuilder ( "/bin/bash" , "-c" , "xm sched-credit" ) ; Process proc ; try { proc = p . start ( ) ; BufferedReader output = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader error = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ; String line = "" ; while ( ( line = output . readLine ( ) ) != null ) { String parts [ ] = line . split ( "\\s+" ) ; if ( vmname . equals ( parts [ 0 ] ) ) { currentCPUCap = Integer . parseInt ( parts [ 2 ] ) ; if ( scaleToVal > 0 && scaleToVal <= 10 ) scaleToCPUCap = currentCPUCap - 64 ; else if ( scaleToVal > 85 ) scaleToCPUCap = currentCPUCap + 256 ; else scaleToCPUCap = currentCPUCap + 64 ; logger . info ( "Elastically Scaling CPU value : " + scaleToCPUCap ) ; p = new ProcessBuilder ( "/bin/bash" , "-c" , "xm sched-credit -d " + vmname + " -w " + scaleToCPUCap ) ; proc = p . start ( ) ; BufferedReader innerOutput = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader innerError = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ; while ( ( line = innerError . readLine ( ) ) != null ) { parts = line . split ( ":" ) ; if ( "Error" . equals ( parts [ 0 ] ) ) { logger . error ( "Command didn't execute successfully: xm sched-credit -d " + vmname + " -w " + scaleToCPUCap ) ; break ; } } break ; } } } catch ( Exception e ) { logger . error ( e . getMessage ( ) ) ; } }
te	5	public void applyTurn ( int player1Choice , int player2Choice ) { omnidexter . setChoice ( player1Choice ) ; opponent . setChoice ( player2Choice ) ; Team [ ] speedOrder = PokemonMath . getFasterPoke ( omnidexter , opponent ) ; Team first = speedOrder [ 0 ] ; Team second = speedOrder [ 1 ] ; if ( first . getChoice ( ) < 0 ) { first . switchActivePokemon ( first . getActivePokemon ( ) . getMove ( first . getChoice ( ) ) ) ; } if ( second . getChoice ( ) < 0 ) { second . switchActivePokemon ( second . getActivePokemon ( ) . getMove ( second . getChoice ( ) ) ) ; } if ( first . getChoice ( ) >= 0 ) { attack ( first . getTeamId ( ) , first . getChoice ( ) ) ; } if ( second . getChoice ( ) >= 0 && ! second . getActivePokemon ( ) . hasFainted ( ) ) { attack ( second . getTeamId ( ) , second . getChoice ( ) ) ; } }
te	0	public int getHeight ( ) { return render . getHeight ( ) ; }
te	3	public int getIndexOfStrength ( int strength ) { ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( Integer i : this . strength ) { list . add ( i ) ; } Collections . sort ( list ) ; int toSearch = list . get ( strength ) ; for ( int i = 0 ; i < this . strength . length ; i ++ ) { if ( toSearch == this . strength [ i ] ) { return i ; } } return - 1 ; }
te	6	private void setComponentConstraintsImpl ( Component comp , Object constr , boolean noCheck ) { Container parent = comp . getParent ( ) ; synchronized ( parent != null ? parent . getTreeLock ( ) : new Object ( ) ) { if ( noCheck == false && scrConstrMap . containsKey ( comp ) == false ) throw new IllegalArgumentException ( "Component must already be added to parent!" ) ; ComponentWrapper cw = new SwingComponentWrapper ( comp ) ; if ( constr == null || constr instanceof String ) { String cStr = ConstraintParser . prepare ( ( String ) constr ) ; scrConstrMap . put ( comp , constr ) ; ccMap . put ( cw , ConstraintParser . parseComponentConstraint ( cStr ) ) ; } else if ( constr instanceof CC ) { scrConstrMap . put ( comp , constr ) ; ccMap . put ( cw , ( CC ) constr ) ; } else { throw new IllegalArgumentException ( "Constraint must be String or ComponentConstraint: " + constr . getClass ( ) . toString ( ) ) ; } dirty = true ; } }
te	0	public Graph ( ) { this . keyToNode = new HashMap < > ( ) ; this . nodes = new HashSet < > ( ) ; }
te	0	public void setCertmapMgId ( int certmapMgId ) { this . certmapMgId = certmapMgId ; }
te	6	private void create ( InputStream input ) { if ( input != null ) { FileOutputStream output = null ; try { output = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ 8192 ] ; int length ; while ( ( length = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , length ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { input . close ( ) ; } catch ( Exception ignored ) { } try { if ( output != null ) output . close ( ) ; } catch ( Exception ignored ) { } } } }
te	9X	private static void calcAjacent ( ) { int numColumns = entries . size ( ) ; int numRows = entries . get ( 0 ) . size ( ) ; for ( int x = 0 ; x < numColumns ; x ++ ) { for ( int y = 0 ; y < numRows ; y ++ ) { if ( x == 0 ) { if ( y == 0 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else if ( y == numRows - 1 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( x == numColumns - 1 ) { if ( y == 0 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else if ( y == numRows - 1 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( y == 0 ) { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x + 1 ) . get ( y + 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( y == numRows - 1 ) { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x + 1 ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } } } }
te	4	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case ORIGNAL_TEXT : if ( value == null ) { unsetOrignalText ( ) ; } else { setOrignalText ( ( String ) value ) ; } break ; case CLEAN_TEXT : if ( value == null ) { unsetCleanText ( ) ; } else { setCleanText ( ( String ) value ) ; } break ; } }
te	7	public final JPoclASTParser . parametersDecl_return parametersDecl ( ) throws RecognitionException { JPoclASTParser . parametersDecl_return retval = new JPoclASTParser . parametersDecl_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token char_literal45 = null ; JPoclASTParser . parameterDecl_return parameterDecl44 = null ; JPoclASTParser . parameterDecl_return parameterDecl46 = null ; TypeTree char_literal45_tree = null ; RewriteRuleTokenStream stream_28 = new RewriteRuleTokenStream ( adaptor , "token 28" ) ; RewriteRuleSubtreeStream stream_parameterDecl = new RewriteRuleSubtreeStream ( adaptor , "rule parameterDecl" ) ; try { { pushFollow ( FOLLOW_parameterDecl_in_parametersDecl457 ) ; parameterDecl44 = parameterDecl ( ) ; state . _fsp -- ; stream_parameterDecl . add ( parameterDecl44 . getTree ( ) ) ; loop8 : do { int alt8 = 2 ; int LA8_0 = input . LA ( 1 ) ; if ( ( LA8_0 == 28 ) ) { alt8 = 1 ; } switch ( alt8 ) { case 1 : { char_literal45 = ( Token ) match ( input , 28 , FOLLOW_28_in_parametersDecl460 ) ; stream_28 . add ( char_literal45 ) ; pushFollow ( FOLLOW_parameterDecl_in_parametersDecl462 ) ; parameterDecl46 = parameterDecl ( ) ; state . _fsp -- ; stream_parameterDecl . add ( parameterDecl46 . getTree ( ) ) ; } break ; default : break loop8 ; } } while ( true ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( ( TypeTree ) adaptor . create ( PDECS , "PDECS" ) , root_1 ) ; if ( ! ( stream_parameterDecl . hasNext ( ) ) ) { throw new RewriteEarlyExitException ( ) ; } while ( stream_parameterDecl . hasNext ( ) ) { adaptor . addChild ( root_1 , stream_parameterDecl . nextTree ( ) ) ; } stream_parameterDecl . reset ( ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
te	4	protected int findMacroBlock ( int position ) throws BTFMatrixErrorException { if ( position < 0 ) throw new BTFMatrixErrorException ( "Trying to find macro block containing index: " + position ) ; int block = 0 ; for ( int i = 1 ; i < macro_blocks . length ; i ++ ) { if ( position >= ( macro_blocks [ i ] . getStartingRow ( ) ) ) { block ++ ; } } if ( block >= macro_blocks . length ) throw new BTFMatrixErrorException ( "Ran out of macro blocks! position = " + position ) ; return block ; }
te	1	public double mediaDia ( String mesInt , int dia ) { double result = 0.0 ; ArrayList < SensorInt > datosDia = datosDia ( mesInt , dia ) ; for ( SensorInt d : datosDia ) { result += d . getPorcentajeCO2 ( ) / 24 ; } return result ; }
te	5	private String getShipLocationDifference ( HashMap < String , List < BoardLocation >> otherShipLocations ) throws Exception { String a = "\n" ; if ( ! otherShipLocations . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : otherShipLocations . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } } for ( String k : otherShipLocations . keySet ( ) ) { if ( ! otherShipLocations . get ( k ) . equals ( playerShipLocations . get ( k ) ) ) { a = a . concat ( k + ":" + getListBoardLocationsDifference ( playerShipLocations . get ( k ) , otherShipLocations . get ( k ) ) + "\n" ) ; } } return a ; }
te	2	public GameEntity getEntityAt ( double x , double y ) { for ( GameEntity e : entities ) { if ( e . contains ( x , y ) ) { return e ; } } return null ; }
te	2	private static int findSmallest ( int remA , int remB , int remC ) { int smallest = remC ; if ( remB <= smallest ) { smallest = remB ; } if ( remA <= smallest ) { smallest = remA ; } return smallest ; }
te	1	public void processPCM ( ByteData pcm ) { try { wav . writePCM ( pcm ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	0	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( "Enter the value of n" ) ; int n = sc . nextInt ( ) ; System . out . println ( "Enter the vaue of k" ) ; int k = sc . nextInt ( ) ; System . out . println ( "The result is " + findCombination ( n , k ) ) ; }
te	7	public void give1 ( ) { while ( ! Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "50 000" ) ) { if ( Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "100 000" ) || Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "150 000" ) ) { Widgets . get ( 335 , 9 ) . click ( true ) ; } Widgets . get ( 335 ) . getChild ( 53 ) . click ( true ) ; Time . sleep ( 1000 ) ; while ( Widgets . get ( 137 , 53 ) . isOnScreen ( ) ) { Time . sleep ( 1000 ) ; Widgets . get ( 335 ) . getChild ( 53 ) . click ( true ) ; } Keyboard . sendText ( "50000" , true ) ; Time . sleep ( 1000 ) ; } Widgets . get ( 335 , 18 ) . click ( true ) ; for ( ; ! Widgets . get ( 334 ) . getChild ( 8 ) . isOnScreen ( ) ; ) { Time . sleep ( 100 ) ; } Widgets . get ( 334 , 21 ) . click ( true ) ; for ( ; Widgets . get ( 335 ) . getChild ( 9 ) . isOnScreen ( ) || Widgets . get ( 334 ) . getChild ( 8 ) . isOnScreen ( ) ; ) { Time . sleep ( 100 ) ; } play = "" ; }
te	9X	private boolean r_Step_4 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_7 , 18 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "s" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "t" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; } return true ; }
te	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; user = ( User ) session . get ( "User" ) ; Criteria ucri = myDao . getDbsession ( ) . createCriteria ( User . class ) ; ucri . add ( Restrictions . not ( Restrictions . = ( "emailId" , "admin@adzappy.com" ) ) ) ; ucri . add ( Restrictions . or ( Restrictions . like ( "emailId" , s + "%" ) , Restrictions . like ( "userName" , s + "%" ) ) ) ; ucri . setMaxResults ( 50 ) ; setAlluserlist ( ( List < User > ) ucri . list ( ) ) ; addActionMessage ( getAlluserlist ( ) . size ( ) + "\t\tResults Found" ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Try Again " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Try Agains " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Try Again " ) ; e . printStackTrace ( ) ; return "error" ; } }
te	5	@ Override public void sort ( ) { int min = provider . getMinIndex ( ) ; int max = provider . getMaxIndex ( ) ; boolean q = useQuick ( min , max ) ; if ( q == null ) { if ( Main . debug ) { System . out . println ( "choice: already sorted." ) ; } return ; } if ( q . booleanValue ( ) ) { if ( Main . debug ) { System . out . println ( "choice: use quick." ) ; } inplaceSortImpl = new DualPivotQuickSort ( provider ) ; } else { if ( Main . debug ) { System . out . println ( "choice: use heap." ) ; } inplaceSortImpl = new HeapSort ( provider ) ; } inplaceSortImpl . sort ( ) ; }
te	5	@ Override public void initResources ( ) { playfield = new PlayField ( ) ; ballGroup = new SpriteGroup ( "Balls" ) ; brickGroup = new SpriteGroup ( "Bricks" ) ; playfield . addGroup ( ballGroup ) ; playfield . addGroup ( brickGroup ) ; BufferedImage ballImage = getImage ( "img/ball.png" ) ; BufferedImage brickImage = getImage ( "img/brick.png" ) ; Sprite ball = new Sprite ( ballImage , firstPoint . x , firstPoint . y ) ; Sprite brick1 = new Sprite ( brickImage , secondPoint . x , secondPoint . y ) ; Sprite brick2 = null ; if ( thirdPoint != null ) { brick2 = new Sprite ( brickImage , thirdPoint . x , thirdPoint . y ) ; } Ball ballElement = new Ball ( table ) ; DestroyableBrick brickElement1 = new DestroyableBrick ( table ) ; DestroyableBrick brickElement2 = new DestroyableBrick ( table ) ; table . addPair ( ballElement , ball ) ; table . addPair ( brickElement1 , brick1 ) ; if ( thirdPoint != null ) { table . addPair ( brickElement2 , brick2 ) ; } field . addElement ( ballElement ) ; field . addElement ( brickElement1 ) ; if ( thirdPoint != null ) { field . addElement ( brickElement2 ) ; } ballElement . addCollisionHandleEndListener ( this ) ; ball . setSpeed ( speedVector . x ( ) , speedVector . y ( ) ) ; ballGroup . add ( ball ) ; brickGroup . add ( brick1 ) ; if ( thirdPoint != null ) { brickGroup . add ( brick2 ) ; } CollisionHandler handler = new CollisionHandler ( table ) ; handler . addHandleEndListener ( this ) ; collision = new CollisionObjectWithObject ( ) ; collision . addSpritesCollidedListener ( handler ) ; playfield . addCollisionGroup ( ballGroup , brickGroup , collision ) ; cloneBall = ballElement . clone ( ) ; cloneBrick1 = brickElement1 . clone ( ) ; if ( thirdPoint != null ) { cloneBrick2 = brickElement2 . clone ( ) ; } }
te	2	public static void main ( String [ ] args ) { DateFormat dateFormat = new SimpleDateFormat ( DateUtil . DATE_FORMAT ) ; Date birthDate = null ; try { birthDate = dateFormat . parse ( "1983-12-07" ) ; } catch ( ParseException ex ) { ex . printStackTrace ( System . err ) ; } LoginInfo loginInfo = new LoginInfo ( "shamim" , "secret" ) ; BillingInfo billingInfo = new BillingInfo ( "003-254992-001" , CreditCardType . MASTERCARD ) ; BiographicalInfo biographicalInfo = new BiographicalInfo ( "Shamim" , "Ahmed" , birthDate ) ; userCreator . setLoginInfo ( loginInfo ) ; userCreator . setBillingInfo ( billingInfo ) ; userCreator . setBiographicalInfo ( biographicalInfo ) ; boolean result = userCreator . addUser ( ) ; System . out . printf ( "User %s created successfully%n" , result ? "was" : "was not" ) ; }
te	9X	@ Override public int hashCode ( ) { Method [ ] methods = ( Method [ ] ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return annotationType . getDeclaredMethods ( ) ; } } ) ; int hashCode = 0 ; for ( Method method : methods ) { int name = 127 * method . getName ( ) . hashCode ( ) ; Object object = callMethod ( this , method ) ; int value = 0 ; if ( object . getClass ( ) . isArray ( ) ) { class < ? > type = object . getClass ( ) . getComponentType ( ) ; if ( type . isPrimitive ( ) ) { if ( long . TYPE == type ) { value = Arrays . hashCode ( ( long [ ] ) object ) ; } else if ( Integer . TYPE == type ) { value = Arrays . hashCode ( ( Integer [ ] ) object ) ; } else if ( short . TYPE == type ) { value = Arrays . hashCode ( ( short [ ] ) object ) ; } else if ( double . TYPE == type ) { value = Arrays . hashCode ( ( double [ ] ) object ) ; } else if ( float . TYPE == type ) { value = Arrays . hashCode ( ( float [ ] ) object ) ; } else if ( boolean . TYPE == type ) { value = Arrays . hashCode ( ( long [ ] ) object ) ; } else if ( byte . TYPE == type ) { value = Arrays . hashCode ( ( byte [ ] ) object ) ; } else if ( Character . TYPE == type ) { value = Arrays . hashCode ( ( Character [ ] ) object ) ; } } else { value = Arrays . hashCode ( ( Object [ ] ) object ) ; } } else { value = object . hashCode ( ) ; } hashCode += name ^ value ; } return hashCode ; }
te	1	public static void main ( String [ ] args ) throws IOException , InterruptedException { Webcam webcam = Webcam . getDefault ( ) ; webcam . setViewSize ( new Dimension ( 640 , 480 ) ) ; webcam . open ( ) ; JFrame troll = new JFrame ( ) ; JLabel boy = new JLabel ( ) ; troll . add ( boy ) ; boy . setPreferredSize ( new Dimension ( 640 , 480 ) ) ; troll . pack ( ) ; troll . setResizable ( false ) ; troll . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; troll . setVisible ( true ) ; while ( true ) { boy . setIcon ( new ImageIcon ( webcam . getImage ( ) ) ) ; } }
te	3	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) throws InvalidHandshakeException { if ( ! request . hasFieldValue ( "Sec-WebSocket-Key" ) || ! response . hasFieldValue ( "Sec-WebSocket-Accept" ) ) return HandshakeState . NOT_MATCHED ; String seckey_answere = response . getFieldValue ( "Sec-WebSocket-Accept" ) ; String seckey_challenge = request . getFieldValue ( "Sec-WebSocket-Key" ) ; seckey_challenge = generateFinalKey ( seckey_challenge ) ; if ( seckey_challenge . equals ( seckey_answere ) ) return HandshakeState . MATCHED ; return HandshakeState . NOT_MATCHED ; }
te	4	public String translate ( String text ) { StringBuilder translated = new StringBuilder ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { int pos = text . indexOf ( " " , i ) ; String word ; if ( pos >= 0 ) { word = text . substring ( i , pos ) ; if ( word . equals ( "ZEE" ) ) word = "ZED" ; translated . append ( word ) ; translated . append ( " " ) ; i = pos ; } else { word = text . substring ( i ) ; if ( word . equals ( "ZEE" ) ) word = "ZED" ; translated . append ( word ) ; break ; } } return translated . toString ( ) ; }
te	5	public void selectWall ( int node1 , int node2 ) { if ( ! this . doors . edgeExists ( node1 , node2 ) && ! this . exits . edgeExists ( node1 , node2 ) ) { if ( this . walls . edgeExists ( node1 , node2 ) ) { this . removeWall ( node1 , node2 ) ; } else if ( node1 != 0 && node2 != 0 ) { this . addWall ( node1 , node2 ) ; } } }
te	9X	public void convert ( IDChanger UI , HashMap < BlockUID , BlockUID > translations , PluginLoader pluginLoader ) { Status status = UI . status ; status . changedChest = 0 ; status . changedPlaced = 0 ; status . changedPlayer = 0 ; int count_file = 0 ; long beginTime = System . currentTimeMillis ( ) ; status . pb_file . setMaximum ( playerFiles . size ( ) - 1 ) ; ArrayList < ConverterPlugin > regionPlugins = pluginLoader . getPluginsOfType ( PluginType . REGION ) ; ArrayList < ConverterPlugin > playerPlugins = pluginLoader . getPluginsOfType ( PluginType . PLAYER ) ; for ( PlayerFile playerFile : playerFiles ) { status . pb_file . setValue ( count_file ++ ) ; status . lb_file . setText ( "Current File: " + playerFile . getName ( ) ) ; DataInputStream dis = null ; DataOutputStream dos = null ; try { dis = new DataInputStream ( new BufferedInputStream ( new GZIPInputStream ( new FileInputStream ( playerFile ) ) ) ) ; CompoundTag root = NbtIo . read ( dis ) ; for ( ConverterPlugin plugin : playerPlugins ) { plugin . convert ( status , root , translations ) ; } dos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( playerFile ) ) ) ; NbtIo . writeCompressed ( root , dos ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert player inventories" , e ) ; return ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close output stream" , e ) ; } } if ( dis != null ) { try { dis . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close input stream" , e ) ; } } } } count_file = 0 ; if ( regionFiles == null ) { return ; } status . pb_file . setValue ( 0 ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; for ( RegionFileExtended r : regionFiles ) { status . lb_file . setText ( "Current File: " + r . fileName . getName ( ) ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; status . pb_file . setValue ( count_file ++ ) ; try { r . convert ( status , translations , regionPlugins ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert placed blocks" , e ) ; return ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close region file" , e ) ; } } } } long duration = System . currentTimeMillis ( ) - beginTime ; JOptionPane . showMessageDialog ( UI , "Done in " + duration + "ms" + System . getProperty ( "line.separator" ) + status . changedPlaced + " placed blocks changed." + System . getProperty ( "line.separator" ) + status . changedPlayer + " blocks in player inventories changed." + System . getProperty ( "line.separator" ) + status . changedChest + " blocks in entity inventories changed." , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; }
te	9X	@ Override public void work ( ) { try { Vertex v = graph . getVertex ( source ) ; if ( v == null ) { print ( "Select a vertex" ) ; return ; } doFillVertex = true ; PairingHeap < Path > ph = new PairingHeap < Path > ( ) ; v . dist = 0 ; v . pos = ph . insert ( new Path ( v , v . dist ) ) ; int nodesSeen = 0 ; int nrSteps = 0 ; while ( ! ph . isEmpty ( ) && nodesSeen < graph . size ( ) ) { Path p = ph . deleteMin ( ) ; v = p . dest ; if ( v . visited ) { continue ; } v . visited = true ; nodesSeen ++ ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { nrSteps ++ ; Vertex w = e . dest ; int uwv = e . cost ; if ( w . dist > uwv + v . dist ) { e . eColor = Color . RED ; w . dist = uwv + v . dist ; w . prev = v ; Path newPath = new Path ( w , w . dist ) ; if ( w . pos == null ) { ph . insert ( newPath ) ; } else { ph . decreaseKey ( w . pos , newPath ) ; } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } } gui . console ( "Path cost: " + graph . getVertex ( dest ) . dist ) ; gui . console ( "Steps: " + nrSteps ) ; graph . resetGraphColors ( ) ; List < Vertex > shortestPath = new ArrayList < Vertex > ( ) ; Vertex vv = graph . getVertex ( dest ) ; while ( vv != null ) { shortestPath . add ( vv ) ; vv = vv . prev ; } for ( int i = shortestPath . size ( ) - 1 ; i >= 0 ; i -- ) { shortestPath . get ( i ) . vColor = Color . RED ; for ( Edge e : shortestPath . get ( i ) . adj ) { if ( i - 1 >= 0 && e . dest . equals ( shortestPath . get ( i - 1 ) ) ) { e . eColor = Color . RED ; break ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } sleep ( GUI_RESULT_PAUSE ) ; clearAll ( ) ; repaint ( ) ; } catch ( Exception e ) { } }
te	2	@ Override public void getRequirements ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Requirement > requirements ) { boolean req = ( ata . m_state == State . PLAY && ! ata . m_waiting . isEmpty ( ) ) || ata . m_state == State . CHOOSE ; requirements . add ( REQ ( req , BLANK_MESSAGE ) ) ; requirements . add ( REQ ( ! ata . m_warning , BLANK_MESSAGE ) ) ; }
te	9X	@ Override public void run ( ) { listener . started ( ) ; try { for ( String s : cmd ) System . out . print ( s + " " ) ; System . out . println ( ) ; downloader = Runtime . getRuntime ( ) . exec ( cmd ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( downloader . getErrorStream ( ) ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) { listener . update ( line ) ; if ( line . startsWith ( "INFO:" ) ) { System . out . println ( line ) ; int i = line . indexOf ( "filesize" ) ; if ( i >= 0 ) { int size = Integer . parseInt ( line . substring ( i + 8 ) . trim ( ) ) ; listener . updateSize ( size ) ; break ; } } else break ; } line = reader . readLine ( ) ; } while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) listener . update ( line ) ; line = reader . readLine ( ) ; } int c = downloader . waitFor ( ) ; downloader = null ; if ( c != 0 ) { listener . incomplete ( line + " {" + c + "}" ) ; } else { listener . finished ( ) ; } } catch ( InterruptedException | IOException | NumberFormatException ex ) { if ( downloading ) listener . incomplete ( ex . getMessage ( ) ) ; else listener . incomplete ( "Cancelled" ) ; Logger . getLogger ( RTMPTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } synchronized ( this ) { downloading = false ; } }
te	8	private void addToTable ( File [ ] file , ArrayList < String > durations , String cmd ) { DefaultTableModel defaultTableModel = ( DefaultTableModel ) PlayListjTable . getModel ( ) ; if ( cmd . equalsIgnoreCase ( "Open" ) ) { defaultTableModel . getDataVector ( ) . removeAllElements ( ) ; Object [ ] cols = new Object [ 2 ] ; if ( file != null && durations != null ) { for ( int i = 0 ; i < file . length ; i ++ ) { cols [ 0 ] = file [ i ] ; cols [ 1 ] = durations . get ( i ) ; defaultTableModel . addRow ( cols ) ; } } } else if ( cmd . equalsIgnoreCase ( "AddToList" ) ) { Object [ ] cols = new Object [ 2 ] ; if ( file != null && durations != null ) { for ( int i = 0 ; i < file . length ; i ++ ) { cols [ 0 ] = file [ i ] ; cols [ 1 ] = durations . get ( i ) ; defaultTableModel . addRow ( cols ) ; } } } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { PlayListjTable . updateUI ( ) ; } } ) ; }
te	0	public String getStoreg ( ) { return storeg ; }
te	3	public int size ( ) { return 1 + ( left == null ? 0 : left . size ( ) ) + ( center == null ? 0 : center . size ( ) ) + ( right == null ? 0 : right . size ( ) ) ; }
te	5	private boolean haveFreeRouteLine ( float x1 , float y1 , float x2 , float y2 ) { if ( Math . abs ( x1 - x2 ) <= 1 && Math . abs ( y1 - y2 ) <= 1 ) { int line = y2 >= map . getNumLines ( ) - 1 ? map . getNumLines ( ) - 1 : ( int ) y2 ; int col = x2 >= map . getNumColumns ( ) - 1 ? map . getNumColumns ( ) - 1 : ( int ) x2 ; boolean a = map . getPosition ( line , col ) == map . getFREE ( ) ; return a ; } float diff_x = Math . abs ( x1 - x2 ) ; float middle_x = ( float ) ( diff_x / 2 + Math . min ( x1 , x2 ) ) ; float diff_y = ( float ) Math . abs ( y1 - y2 ) ; float middle_y = ( float ) ( diff_y / 2 + Math . min ( y1 , y2 ) ) ; boolean b = haveFreeRouteLine ( x1 , y1 , middle_x , middle_y ) ? haveFreeRouteLine ( middle_x , middle_y , x2 , y2 ) : false ; return b ; }
te	8	public Location getFirstSquareNeighborLocation ( int row , int col , int dist , int id ) { for ( int x = row - dist ; x <= row + dist ; x ++ ) { if ( isInBounds ( x ) ) { for ( int y = col - dist ; y <= col + dist ; y ++ ) { if ( isInBounds ( y ) && thisTick [ x ] [ y ] != null && ! ( x == row && y == col ) && thisTick [ x ] [ y ] . id == id ) { return new Location ( x , y ) ; } } } } return null ; }
te	4	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || ! ( obj instanceof AccessibleField ) ) { return false ; } final AccessibleField other = ( AccessibleField ) obj ; return this . name . equals ( other . name ) && this . type . equals ( other . type ) ; }
te	1	public String getValue ( String defaultValue ) { String value = getValue ( ) ; return ( value != null ) ? value : defaultValue ; }
te	7	private int compute_qr ( double [ ] s , double [ ] e , double [ ] u , double [ ] v ) { int k ; boolean converged ; double shift , r ; double utemp , vtemp ; double f , g ; final int MAX_INTERATIONS = 10 ; final double CONVERGE_TOL = 4.89E-15 ; double c_b48 = 1. ; int first ; converged = false ; first = 1 ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; for ( k = 0 ; k < MAX_INTERATIONS && ! converged ; k ++ ) { shift = compute_shift ( s [ 1 ] , e [ 1 ] , s [ 2 ] ) ; f = ( Math . abs ( s [ 0 ] ) - shift ) * ( d_sign ( c_b48 , s [ 0 ] ) + shift / s [ 0 ] ) ; g = e [ 0 ] ; r = compute_rot ( f , g , sinr , cosr , 0 , first ) ; f = cosr [ 0 ] * s [ 0 ] + sinr [ 0 ] * e [ 0 ] ; e [ 0 ] = cosr [ 0 ] * e [ 0 ] - sinr [ 0 ] * s [ 0 ] ; g = sinr [ 0 ] * s [ 1 ] ; s [ 1 ] = cosr [ 0 ] * s [ 1 ] ; r = compute_rot ( f , g , sinl , cosl , 0 , first ) ; first = 0 ; s [ 0 ] = r ; f = cosl [ 0 ] * e [ 0 ] + sinl [ 0 ] * s [ 1 ] ; s [ 1 ] = cosl [ 0 ] * s [ 1 ] - sinl [ 0 ] * e [ 0 ] ; g = sinl [ 0 ] * e [ 1 ] ; e [ 1 ] = cosl [ 0 ] * e [ 1 ] ; r = compute_rot ( f , g , sinr , cosr , 1 , first ) ; e [ 0 ] = r ; f = cosr [ 1 ] * s [ 1 ] + sinr [ 1 ] * e [ 1 ] ; e [ 1 ] = cosr [ 1 ] * e [ 1 ] - sinr [ 1 ] * s [ 1 ] ; g = sinr [ 1 ] * s [ 2 ] ; s [ 2 ] = cosr [ 1 ] * s [ 2 ] ; r = compute_rot ( f , g , sinl , cosl , 1 , first ) ; s [ 1 ] = r ; f = cosl [ 1 ] * e [ 1 ] + sinl [ 1 ] * s [ 2 ] ; s [ 2 ] = cosl [ 1 ] * s [ 2 ] - sinl [ 1 ] * e [ 1 ] ; e [ 1 ] = f ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 8 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 8 ] ; m [ 0 ] = s [ 0 ] ; m [ 1 ] = e [ 0 ] ; m [ 2 ] = 0.0 ; m [ 3 ] = 0.0 ; m [ 4 ] = s [ 1 ] ; m [ 5 ] = e [ 1 ] ; m [ 6 ] = 0.0 ; m [ 7 ] = 0.0 ; m [ 8 ] = s [ 2 ] ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; } if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL ) { compute_2X2 ( s [ 0 ] , e [ 0 ] , s [ 1 ] , s , sinl , cosl , sinr , cosr , 0 ) ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; } else { compute_2X2 ( s [ 1 ] , e [ 1 ] , s [ 2 ] , s , sinl , cosl , sinr , cosr , 1 ) ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 8 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 8 ] ; } return ( 0 ) ; }
te	7	@ Override public Vocabulary parse ( Expression expression ) throws ExpressionParserException { Vocabulary vocabulary = new Vocabulary ( ) ; setDefaults ( vocabulary ) ; List < Expression > nested = getNested ( expression ) ; for ( Expression exp : nested ) { String identifier = exp . getIdentifier ( ) ; if ( "verbs" . equals ( identifier ) ) { parseVerbs ( vocabulary , exp ) ; } else if ( "articles" . equals ( identifier ) ) { vocabulary . addArticles ( getList ( exp ) ) ; } else if ( "prepositions" . equals ( identifier ) ) { vocabulary . addPrepositions ( getList ( exp ) ) ; } else if ( "messages" . equals ( identifier ) ) { parseMessages ( vocabulary , exp ) ; } else if ( "magicPhrases" . equals ( identifier ) ) { parseMagicPhrases ( vocabulary , exp ) ; } else if ( "specialEntities" . equals ( identifier ) ) { parseSpecialEntities ( vocabulary , exp ) ; } else { throw new ExpressionParserException ( identifier + " is not valid within expression." , exp ) ; } } return vocabulary ; }
te	6	private static StringBuilder searchAndReplace ( List searchReplace ) { int searchIndex = 0 ; String searchFor = null ; String replaceString = null ; int index = 0 ; for ( int count = 0 ; count < searchReplace . size ( ) - 1 ; count ++ ) { try { searchFor = ( String ) searchReplace . get ( count ) ; searchIndex = inputString . indexOf ( searchFor , 0 ) ; count += 1 ; replaceString = ( String ) searchReplace . get ( count ) ; } catch ( Exception ex ) { continue ; } if ( index == 0 || ! covered . containsKey ( searchIndex ) ) { inputString = inputString . replace ( searchIndex , searchIndex + replaceString . length ( ) , replaceString ) ; if ( searchFor . length ( ) > replaceString . length ( ) ) { int diffToDelete = searchFor . length ( ) - replaceString . length ( ) ; int deleteStartPosition = searchIndex + 1 ; inputString . delete ( deleteStartPosition , deleteStartPosition + diffToDelete ) ; } covered . put ( searchIndex , searchIndex + replaceString . length ( ) - 1 ) ; index += 1 ; } else { if ( advancedSearchAndReplace ( searchFor , replaceString , searchIndex ) == null ) continue ; } } return inputString ; }
te	7	private String getTextOpciones ( int i ) { int opcion = 0 ; if ( i == opcion ++ ) return "Juego..." ; if ( i == opcion ++ ) return "Graficos..." ; if ( i == opcion ++ ) return "Sonidos..." ; if ( i == opcion ++ ) return "Controles..." ; if ( i == opcion ++ ) return "Atajos del teclado..." ; if ( i == opcion ++ ) return "Directorios..." ; if ( i == opcion ++ ) return "Pantalla completa" ; return "Mostrar FPS" ; }
te	9X	public FractOutPanel ( ) { zoomListeners = new Vector < IZoomListener > ( ) ; layerPane = new JLayeredPane ( ) ; drawPanel = new JPanel ( ) { @ Override public void paint ( Graphics g ) { g . setColor ( AppManager . getInstance ( ) . getUserPrefs ( ) . getBackgroundColor ( ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; if ( fractImage != null ) { g . drawImage ( fractImage , drawOffset . x , drawOffset . y , this ) ; } } } ; drawPanel . addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { mouseMoved = false ; mouseStartPoint = e . getPoint ( ) ; } public void mouseReleased ( MouseEvent e ) { if ( moveMode == MOVE_MODE_ZOOM ) { if ( mouseMoved ) { performRubberbandZoom ( rubberBand . getX ( ) , rubberBand . getY ( ) , rubberBand . getWidth ( ) , rubberBand . getHeight ( ) ) ; } else { performClickZoom ( e . getPoint ( ) . x , e . getPoint ( ) . y ) ; } rubberBand . setVisible ( false ) ; } if ( moveMode == MOVE_MODE_DRAG ) { if ( mouseStartPoint != null ) { int dx = e . getPoint ( ) . x - mouseStartPoint . x ; int dy = e . getPoint ( ) . y - mouseStartPoint . y ; if ( dx != 0 || dy != 0 ) { performDragPan ( dx , dy ) ; } } } drawOffset . x = 0 ; drawOffset . y = 0 ; mouseMoved = false ; } } ) ; drawPanel . addMouseMotionListener ( new MouseAdapter ( ) { public void mouseDragged ( MouseEvent e ) { mouseMoved = true ; if ( mouseStartPoint != null ) { if ( moveMode == MOVE_MODE_ZOOM ) { Dimension evtBound = new Dimension ( Math . abs ( e . getPoint ( ) . x - mouseStartPoint . x ) , Math . abs ( e . getPoint ( ) . y - mouseStartPoint . y ) ) ; int left = MathLib . minInt ( mouseStartPoint . x , e . getPoint ( ) . x ) ; int top = MathLib . minInt ( mouseStartPoint . y , e . getPoint ( ) . y ) ; rubberBand . setBounds ( left , top , evtBound . width , evtBound . height ) ; rubberBand . setVisible ( true ) ; } if ( moveMode == MOVE_MODE_DRAG ) { drawOffset . x = e . getPoint ( ) . x - mouseStartPoint . x ; drawOffset . y = e . getPoint ( ) . y - mouseStartPoint . y ; drawPanel . repaint ( ) ; } } } } ) ; rubberBand = new JPanel ( ) { @ Override public void paint ( Graphics g ) { g . setColor ( Color . BLACK ) ; g . drawRect ( 1 , 1 , this . getWidth ( ) - 1 , this . getHeight ( ) - 1 ) ; g . setColor ( Color . WHITE ) ; g . drawRect ( 0 , 0 , this . getWidth ( ) - 2 , this . getHeight ( ) - 2 ) ; } } ; rubberBand . setOpaque ( false ) ; rubberBand . setVisible ( false ) ; layerPane . add ( drawPanel , JLayeredPane . DEFAULT_LAYER ) ; layerPane . add ( rubberBand , JLayeredPane . DRAG_LAYER ) ; this . setViewportView ( layerPane ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainForm ( ) . setVisible ( true ) ; } } ) ; }
te	9X	public static void main ( String argv [ ] ) throws internal_error , java . io . IOException , java . lang . Exception { boolean did_output = false ; start_time = System . currentTimeMillis ( ) ; parse_args ( argv ) ; emit . set_lr_values ( lr_values ) ; if ( print_progress ) System . err . println ( "Opening files..." ) ; input_file = new BufferedInputStream ( System . in ) ; prelim_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Parsing specification from standard input..." ) ; parse_grammar_spec ( ) ; parse_end = System . currentTimeMillis ( ) ; if ( lexer . error_count == 0 ) { if ( print_progress ) System . err . println ( "Checking specification..." ) ; check_unused ( ) ; check_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Building parse tables..." ) ; build_parser ( ) ; build_end = System . currentTimeMillis ( ) ; if ( lexer . error_count != 0 ) { opt_dump_tables = false ; } else { if ( print_progress ) System . err . println ( "Writing parser..." ) ; open_files ( ) ; emit_parser ( ) ; did_output = true ; } } emit_end = System . currentTimeMillis ( ) ; if ( opt_dump_grammar ) dump_grammar ( ) ; if ( opt_dump_states ) dump_machine ( ) ; if ( opt_dump_tables ) dump_tables ( ) ; dump_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Closing files..." ) ; close_files ( ) ; if ( ! no_summary ) emit_summary ( did_output ) ; if ( lexer . error_count != 0 ) System . exit ( 100 ) ; }
te	6	private JPopupMenu createPopupEntry ( ) { JPopupMenu popup = new JPopupMenu ( ) ; popup . add ( addAction ) ; popup . add ( editAction ) ; popup . add ( delAction ) ; popup . addSeparator ( ) ; popup . add ( cutAction ) ; popup . add ( copyAction ) ; popup . add ( pasteAction ) ; popup . addSeparator ( ) ; ActionListener al = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JMenuItem m = ( JMenuItem ) e . getSource ( ) ; ZamokView view = getTab ( ) ; PasswordEntry entry = view . getSelectedEntry ( ) ; if ( entry == null ) { return ; } String retval = "" ; if ( m . getText ( ) . equals ( "Username" ) ) { retval = entry . getLogin ( ) ; } else if ( m . getText ( ) . equals ( "Password" ) ) { retval = entry . getPassword ( false ) ; } else if ( m . getText ( ) . equals ( "URL" ) ) { retval = entry . getURL ( ) ; } else if ( m . getText ( ) . equals ( "eMail" ) ) { retval = entry . getEmail ( ) ; } if ( ! "" . equals ( retval ) ) { StringSelection selection = new StringSelection ( retval ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( selection , null ) ; } } } ; JMenuItem mi ; JMenu menuCopy = ( JMenu ) popup . add ( new JMenu ( UIHelper . getString ( "Menu.Copy" ) ) ) ; mi = createPopupCopyMenuItem ( "username.png" , "Username" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "password.png" , "Password" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "url.png" , "URL" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "mail.png" , "eMail" , al ) ; menuCopy . add ( mi ) ; return popup ; }
te	8	public static String formatName ( String name ) { if ( name . length ( ) > 0 ) { char characters [ ] = name . toCharArray ( ) ; for ( int c = 0 ; c < characters . length ; c ++ ) if ( characters [ c ] == _ ) { characters [ c ] =   ; if ( c + 1 < characters . length && characters [ c + 1 ] >= a && characters [ c + 1 ] <= z ) characters [ c + 1 ] = ( char ) ( ( characters [ c + 1 ] + 65 ) - 97 ) ; } if ( characters [ 0 ] >= a && characters [ 0 ] <= z ) characters [ 0 ] = ( char ) ( ( characters [ 0 ] + 65 ) - 97 ) ; return new String ( characters ) ; } else { return name ; } }
te	2	@ Override public boolean equals ( Object other ) { boolean result = false ; if ( other instanceof Tuple ) { Tuple that = ( Tuple ) other ; result = ( this . source . equals ( that . source ) && this . target . equals ( that . target ) ) ; } return result ; }
te	0	static public IconCache zam56 ( HttpCache hc ) { return new IconCache ( hc , 56 , 1 , "http://wow.zamimg.com/images/wow/icons/large/$.jpg|dir=56" ) ; }
te	7	private void buildVertexPath ( RoutePath inRoute , boolean randomStart ) { mPath . clear ( ) ; ListIterator ti = inRoute . getPath ( ) . listIterator ( ) ; while ( ti . hasNext ( ) ) { Trip t = ( Trip ) ti . next ( ) ; if ( ! mPath . isEmpty ( ) && mPath . get ( mPath . size ( ) - 1 ) . getRawDistance ( t . getVertices ( ) . get ( 0 ) ) == 0.0 ) { mPath . remove ( mPath . size ( ) - 1 ) ; } if ( randomStart ) { int start = ( int ) ( Math . random ( ) * t . getVertices ( ) . size ( ) ) ; ListIterator vi = t . getVertices ( ) . listIterator ( ) ; while ( start > 0 ) { vi . next ( ) ; start -- ; } while ( vi . hasNext ( ) ) { mPath . add ( ( Vertex ) vi . next ( ) ) ; Vertex v = new Vertex ( ) ; } } else { if ( ! mPath . isEmpty ( ) ) { mPath . remove ( mPath . size ( ) - 1 ) ; } mPath . addAll ( t . getVertices ( ) ) ; } } addStopsToVertexList ( mPath , inRoute . getStops ( ) ) ; }
te	2	public ArrayList < Identifier > getFreeBeds ( Identifier hostelId , Date checkIn , Date checkOut ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException , InvalidParameterException { ArrayList < Identifier > freeBedIds = new ArrayList < Identifier > ( ) ; Hostel hostelInfo = Hostels . getInstance ( ) . get ( hostelId ) ; Iterator < Identifier > bedItr = hostelInfo . getBeds ( ) . iterator ( ) ; while ( bedItr . hasNext ( ) ) { Identifier bedId = bedItr . next ( ) ; if ( Beds . getInstance ( ) . isBedAvailable ( bedId , checkIn , checkOut , false ) ) { freeBedIds . add ( bedId ) ; } } return freeBedIds ; }
te	4	public Set < State > getAcceptStates ( ) { expandSingleton ( ) ; HashSet < State > accepts = new HashSet < State > ( ) ; HashSet < State > visited = new HashSet < State > ( ) ; LinkedList < State > worklist = new LinkedList < State > ( ) ; worklist . add ( initial ) ; visited . add ( initial ) ; while ( worklist . size ( ) > 0 ) { State s = worklist . removeFirst ( ) ; if ( s . accept ) accepts . add ( s ) ; for ( Transition t : s . transitions ) if ( ! visited . contains ( t . to ) ) { visited . add ( t . to ) ; worklist . add ( t . to ) ; } } return accepts ; }
te	8	public void pondre ( ) { int naissances = 0 ; if ( this . getFourmiliere ( ) . getFecondite ( ) > 0 ) { naissances = new Random ( ) . nextInt ( this . getFourmiliere ( ) . getFecondite ( ) ) ; } if ( ConfigurationLoader . LIMIT_FOURMIS_NUMBER && this . getFourmiliere ( ) . getTotalFourmis ( ) + naissances >= this . getFourmiliere ( ) . getTaille_max ( ) ) { naissances = this . getFourmiliere ( ) . getTaille_max ( ) - this . getFourmiliere ( ) . getTotalFourmis ( ) ; } for ( int i = 0 ; i < naissances ; i ++ ) { int rand = new Random ( ) . nextInt ( 100 ) ; if ( rand >= this . getFourmiliere ( ) . get_tauxEclaireuses ( ) ) { new Ouvriere ( this . getFourmiliere ( ) ) ; } else { new Eclaireuse ( this . getFourmiliere ( ) ) ; } } if ( this . getFourmiliere ( ) . getTotalFourmis ( ) >= this . getFourmiliere ( ) . getTaille_max ( ) && ( ConfigurationLoader . MAX_FOURMILIERES > this . getFourmiliere ( ) . getMonde ( ) . getFourmilieres ( ) . size ( ) ) ) { if ( new Random ( ) . nextInt ( 100 ) < ConfigurationLoader . CHANCES_NAISSANCE_REINES ) { new Reine ( this . getFourmiliere ( ) ) . setEtat ( States . RECHERCHE_EMPLACEMENT ) ; } } }
te	8	@ Test public void test ( ) { long [ ] arr = new long [ 100 ] ; int nElems = 0 ; int j ; long searchKey ; arr [ 0 ] = 77 ; arr [ 1 ] = 99 ; arr [ 2 ] = 44 ; arr [ 3 ] = 55 ; arr [ 4 ] = 22 ; arr [ 5 ] = 88 ; arr [ 6 ] = 00 ; arr [ 7 ] = 66 ; arr [ 8 ] = 33 ; arr [ 9 ] = 10 ; nElems = 10 ; for ( j = 0 ; j < nElems ; j ++ ) { System . out . print ( arr [ j ] + " " ) ; } System . out . println ( "" ) ; searchKey = 27 ; for ( j = 0 ; j < nElems ; j ++ ) { if ( arr [ j ] == searchKey ) { break ; } } if ( j == nElems ) { System . out . println ( "Can't find " + searchKey ) ; } else { System . out . println ( "Found " + searchKey ) ; } searchKey = 55 ; for ( j = 0 ; j < nElems ; j ++ ) { if ( arr [ j ] == searchKey ) { break ; } } for ( int k = j ; k < nElems ; k ++ ) { arr [ k ] = arr [ k + 1 ] ; } nElems -- ; for ( j = 0 ; j < nElems ; j ++ ) { System . out . print ( arr [ j ] + " " ) ; } System . out . println ( " " ) ; }
te	8	@ Override public void act ( ) { this . threshold ++ ; switch ( this . mode ) { case WAIT : double part1 = Math . pow ( ( this . player . getCenterX ( ) - this . getCenterX ( ) ) , 2 ) ; double part2 = Math . pow ( ( this . player . getCenterY ( ) - this . getCenterY ( ) ) , 2 ) ; double underRadical = part1 + part2 ; if ( ( int ) Math . sqrt ( underRadical ) / YSPanel . TILE_WIDTH < 4 ) { this . targetX = player . getX ( ) ; this . targetY = player . getY ( ) ; this . threshold = 0 ; this . mode = Mode . ATTACK ; } break ; case ATTACK : if ( threshold > MAX_THRESHOLD || this . moveTowardsTarget ( this . targetX , this . targetY ) ) { this . mode = Mode . return ; threshold = 0 ; } break ; case return : if ( threshold > MAX_THRESHOLD || this . moveTowardsTarget ( homeX , homeY ) ) { this . mode = Mode . WAIT ; threshold = 0 ; } break ; } }
te	6	public MyEvent getEvent ( int key ) { if ( key == up ) return MyEvent . UP ; if ( key == down ) return MyEvent . DOWN ; if ( key == left ) return MyEvent . LEFT ; if ( key == right ) return MyEvent . RIGHT ; if ( key == bomb ) return MyEvent . BOMB ; if ( key == surrend ) return MyEvent . SURREND ; return MyEvent . NONE ; }
te	2	private void drawBoard ( int deadFields ) { GUI . totalNumberOfMoves = 49 - deadFields ; Dimension boardSize = new Dimension ( 245 , 245 ) ; layeredPane = new JLayeredPane ( ) ; getContentPane ( ) . add ( layeredPane ) ; layeredPane . setPreferredSize ( boardSize ) ; layeredPane . addMouseListener ( this ) ; pahtumBoard = new JPanel ( ) ; layeredPane . add ( pahtumBoard , JLayeredPane . DEFAULT_LAYER ) ; GridLayout gridLayout = new GridLayout ( 7 , 7 ) ; gridLayout . setVgap ( 2 ) ; gridLayout . setHgap ( 2 ) ; pahtumBoard . setLayout ( gridLayout ) ; pahtumBoard . setPreferredSize ( boardSize ) ; pahtumBoard . setBounds ( 0 , 0 , boardSize . width , boardSize . height ) ; board = new Board ( 1 , true , deadFields ) ; String [ ] [ ] b = board . getState ( ) ; for ( int i = 0 ; i < 49 ; ++ i ) { JPanel square = new JPanel ( new BorderLayout ( ) ) ; pahtumBoard . add ( square ) ; if ( b [ i / 7 ] [ i % 7 ] . equals ( "x" ) ) { JLabel deadField = new JLabel ( new ImageIcon ( "/n/student/kg687/workspace/PahTum v3/img/deadFiled.jpg" ) ) ; square . add ( deadField ) ; } else { square . setBackground ( Color . getHSBColor ( 16 , 83 , 69 ) ) ; } } }
te	5	private static int bcd ( char digit ) { if ( digit >= 0 && digit <= 9 ) { return digit - 0 ; } switch ( digit ) { case . : return 10 ; case - : return 11 ; case + : return 12 ; default : return 13 ; } }
te	6	public static int [ ] shellSort ( int [ ] arr ) { arrTemp = arr . clone ( ) ; int dis = arrTemp . length ; while ( true ) { dis = dis / 2 ; for ( int x = 0 ; x < dis ; x ++ ) { for ( int i = x + dis ; i < arrTemp . length ; i = i + dis ) { int temp = arrTemp [ i ] ; int j ; for ( j = i - dis ; j >= 0 && arrTemp [ j ] > temp ; j = j - dis ) { arrTemp [ j + dis ] = arrTemp [ j ] ; } arrTemp [ j + dis ] = temp ; } } if ( dis == 1 ) { break ; } } return arrTemp ; }
te	9X	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
te	7	public void iniciar ( ) { JPanel panel = new JPanel ( ) ; getContentPane ( ) . add ( panel ) ; panel . setLayout ( null ) ; JLabel vermelho = new JLabel ( "Vermelho:" ) ; vermelho . setBounds ( 5 , 0 , 80 , 30 ) ; vermelho . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel amarelo = new JLabel ( "Laranja:" ) ; amarelo . setBounds ( 5 , 80 , 80 , 30 ) ; amarelo . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel verde = new JLabel ( "Verde: " ) ; verde . setBounds ( 5 , 160 , 80 , 30 ) ; verde . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho ) ; panel . add ( amarelo ) ; panel . add ( verde ) ; final JLabel vermelho1 = new JLabel ( "0" ) ; vermelho1 . setBounds ( 80 , 0 , 80 , 30 ) ; vermelho1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo1 = new JLabel ( "0" ) ; amarelo1 . setBounds ( 80 , 80 , 80 , 30 ) ; amarelo1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde1 = new JLabel ( "0" ) ; verde1 . setBounds ( 80 , 160 , 80 , 30 ) ; verde1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho1 ) ; panel . add ( amarelo1 ) ; panel . add ( verde1 ) ; final JLabel vermelho2 = new JLabel ( "0" ) ; vermelho2 . setBounds ( 120 , 0 , 80 , 30 ) ; vermelho2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo2 = new JLabel ( "0" ) ; amarelo2 . setBounds ( 120 , 80 , 80 , 30 ) ; amarelo2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde2 = new JLabel ( "0" ) ; verde2 . setBounds ( 120 , 160 , 80 , 30 ) ; verde2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho2 ) ; panel . add ( amarelo2 ) ; panel . add ( verde2 ) ; final JLabel vermelho3 = new JLabel ( "0" ) ; vermelho3 . setBounds ( 160 , 0 , 80 , 30 ) ; vermelho3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo3 = new JLabel ( "0" ) ; amarelo3 . setBounds ( 160 , 80 , 80 , 30 ) ; amarelo3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde3 = new JLabel ( "0" ) ; verde3 . setBounds ( 160 , 160 , 80 , 30 ) ; verde3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho3 ) ; panel . add ( amarelo3 ) ; panel . add ( verde3 ) ; final JLabel vermelho4 = new JLabel ( "0" ) ; vermelho4 . setBounds ( 200 , 0 , 80 , 30 ) ; vermelho4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo4 = new JLabel ( "0" ) ; amarelo4 . setBounds ( 200 , 80 , 80 , 30 ) ; amarelo4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde4 = new JLabel ( "0" ) ; verde4 . setBounds ( 200 , 160 , 80 , 30 ) ; verde4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho4 ) ; panel . add ( amarelo4 ) ; panel . add ( verde4 ) ; setTitle ( "Semaforos" ) ; setSize ( 400 , 400 ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; Semaforo semaforo1 = new Semaforo ( ) ; semaforo1 . setRedText ( vermelho1 ) ; semaforo1 . setOrangeText ( amarelo1 ) ; semaforo1 . setGreenText ( verde1 ) ; semaforo1 . setStatus ( 0 ) ; semaforo1 . start ( ) ; Semaforo semaforo2 = new Semaforo ( ) ; semaforo2 . setRedText ( vermelho2 ) ; semaforo2 . setOrangeText ( amarelo2 ) ; semaforo2 . setGreenText ( verde2 ) ; semaforo2 . setStatus ( 0 ) ; semaforo2 . start ( ) ; Semaforo semaforo3 = new Semaforo ( ) ; semaforo3 . setRedText ( vermelho3 ) ; semaforo3 . setOrangeText ( amarelo3 ) ; semaforo3 . setGreenText ( verde3 ) ; semaforo3 . setStatus ( 0 ) ; semaforo3 . start ( ) ; Semaforo semaforo4 = new Semaforo ( ) ; semaforo4 . setRedText ( vermelho4 ) ; semaforo4 . setOrangeText ( amarelo4 ) ; semaforo4 . setGreenText ( verde4 ) ; semaforo4 . setStatus ( 2 ) ; semaforo4 . start ( ) ; long secondLast = 0 ; int currentSign = 1 ; while ( true ) { long secondNow = System . currentTimeMillis ( ) / 1000 ; if ( secondNow - secondLast >= 10 ) { switch ( currentSign ) { case 1 : semaforo4 . change ( ) ; semaforo1 . change ( ) ; break ; case 2 : semaforo1 . change ( ) ; semaforo2 . change ( ) ; break ; case 3 : semaforo2 . change ( ) ; semaforo3 . change ( ) ; break ; case 4 : semaforo3 . change ( ) ; semaforo4 . change ( ) ; break ; default : break ; } secondLast = secondNow ; currentSign ++ ; if ( currentSign == 5 ) currentSign = 1 ; } } }
te	9X	public static void main ( String [ ] args ) { try { if ( args . length > 0 ) { for ( String arg : args ) { arg = arg . trim ( ) ; if ( arg . matches ( "app_root_dir=\\s*\\w+\\s*" ) ) { JediORMEngine . APP_ROOT_DIR = arg ; } else { JediORMEngine . APP_ROOT_DIR = System . getProperty ( "user.dir" ) ; } if ( arg . equals ( "web_app" ) ) { JediORMEngine . WEB_APP = true ; } if ( arg . matches ( "debug=\\s*true\\s*" ) ) { JediORMEngine . DEBUG = true ; } else if ( arg . matches ( "debug=\\s*false\\s*" ) ) { JediORMEngine . DEBUG = false ; } else { } } } else { JediORMEngine . APP_ROOT_DIR = System . getProperty ( "user.dir" ) ; } if ( JediORMEngine . WEB_APP ) { JediORMEngine . APP_SRC_DIR = String . format ( "%s%sweb%sWEB-INF%ssrc" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator ) ; JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sweb%sWEB-INF%sconfig%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator , File . separator ) ; File dbConfigFile = new File ( JediORMEngine . APP_DB_CONFIG_FILE ) ; if ( ! dbConfigFile . exists ( ) ) { JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sweb%sWEB-INF%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator ) ; } } else { JediORMEngine . APP_SRC_DIR = String . format ( "%s%ssrc" , JediORMEngine . APP_ROOT_DIR , File . separator ) ; JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator ) ; } JediORMEngine . syncdb ( JediORMEngine . APP_SRC_DIR ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	0	public String getInputEncoding ( ) { return pp . getInputEncoding ( ) ; }
te	5	public static void main ( String [ ] args ) { final int limit = 100000 ; final int iterations = 100 ; final String format = "%g seconds" ; List < long > numbers = Stream . iterate ( 1 , number -> number + 1 ) . limit ( limit ) . collect ( Collectors . < long > toList ( ) ) ; { System . out . println ( "//" + "START:HABITUAL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { long primesCount = 0 ; for ( long number : numbers ) { if ( isPrime ( number ) ) { primesCount += 1 ; } } } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:HABITUAL_OUTPUT" ) ; } { System . out . println ( "//" + "START:LAMBDA_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . stream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:LAMBDA_OUTPUT" ) ; } { System . out . println ( "//" + "START:PARALLEL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . parallelStream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:PARALLEL_OUTPUT" ) ; } }
te	9X	public static void testGeneticAlgorithmInteger ( ) { IMyRandomDataFunction < Integer > rFunc = new IMyRandomDataFunction ( ) { private final Random r = new Random ( ) ; @ Override public Integer getRandom ( ) { return r . nextInt ( ) ; } } ; IMyFitnessTestFunction < Integer > tFunc = new IMyFitnessTestFunction < Integer > ( ) { @ Override public int testFitness ( List < Integer > list ) { return ( int ) list . stream ( ) . mapToInt ( i -> evaluate ( i ) ) . sum ( ) / list . size ( ) ; } private int evaluate ( int given ) { if ( given % 2 == 0 ) { return 100 ; } else { return 0 ; } } } ; IMyNeuronFunction < Integer > calcFunc = new IMyNeuronFunction < Integer > ( ) { @ Override public Integer process ( List < Integer > inData , List < Integer > weights , Integer threshold ) throws Exception { if ( inData . size ( ) != weights . size ( ) ) { throw new Exception ( "inData size doesnt match weights size" ) ; } if ( threshold == null ) { throw new Exception ( "threshold cannot be null" ) ; } double total = 0 ; for ( int i = 0 ; i < inData . size ( ) ; i ++ ) { total += mapIntegerToSpecialDouble ( inData . get ( i ) ) * mapIntegerToSpecialDouble ( weights . get ( i ) ) ; } return mapSpecialDoubleToInteger ( 1 / ( 1 + Math . exp ( ( - total ) / mapIntegerToSpecialDouble ( threshold ) ) ) ) ; } private double mapIntegerToSpecialDouble ( Integer in ) { if ( in >= 0 ) { return in / Integer . MAX_VALUE ; } else { return in / Integer . MIN_VALUE ; } } private int mapSpecialDoubleToInteger ( double in ) { if ( in >= 0 ) { return ( int ) ( Integer . MAX_VALUE * in ) ; } else { return ( int ) ( Integer . MIN_VALUE * in ) ; } } } ; try { MyDrawableGraph dg = new MyDrawableGraph ( MyDrawableGraph . SortByAxis . xAxis , MyDrawableGraph . SortDirection . asc , 800 , 600 ) ; MyCanvasWindow graphWindow = new MyCanvasWindow ( 800 , 600 , dg ) ; graphWindow . startWindow ( ) ; MyPopulation < Integer > pop = new MyPopulation ( 50 , 10 , tFunc , rFunc , false ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { try { pop . nextGeneration ( ) ; int avgFitness = pop . getAverageFitness ( ) ; List < MyGraphPoint < Integer , Integer >> graphPoints = pop . getPopulation ( ) . stream ( ) . map ( p -> new MyGraphPoint < > ( pop . getGenerationCount ( ) , avgFitness ) ) . collect ( Collectors . toList ( ) ) ; graphPoints . stream ( ) . forEach ( si -> { try { dg . addGraphItem ( si ) ; } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } ) ; System . out . println ( "Population #" + i ) ; System . out . println ( "-average fitnes:" + avgFitness ) ; if ( avgFitness >= 99 ) { break ; } } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } pop . getMostFitIndividual ( ) . getData ( ) . forEach ( i -> { System . out . println ( "" + i ) ; } ) ; } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	1	@ Override public boolean deleteGame ( IGame game ) { if ( fakeGames . contains ( game ) ) { System . out . println ( "Deleting " + game . getURIToString ( ) ) ; fakeGames . remove ( game ) ; return true ; } else { System . err . println ( "Game not in list" + game . getURIToString ( ) ) ; return false ; } }
te	5	public boolean contains ( AABB aabb ) { final Vector3f h1 = getHalfsize ( ) ; final Vector3f h2 = aabb . getHalfsize ( ) ; final Vector3f p1 , p2 ; return h1 . x >= h2 . x && h1 . y >= h2 . y && h1 . z >= h2 . z && Math . abs ( ( p2 = aabb . getPosition ( ) ) . x - ( p1 = getPosition ( ) ) . x ) <= h1 . x - h2 . x && Math . abs ( p2 . y - p1 . y ) <= h1 . y - h2 . y && Math . abs ( p2 . z - p1 . z ) <= h1 . z - h2 . z ; }
te	4	private void showBoundingBoxV1 ( ) { if ( m_geometry == null ) { return ; } hideBoundingBox ( ) ; System . out . println ( "Showing Bounding Box Variant 1" ) ; PdVector c = m_geometry . getCenterOfGravity ( ) ; PdMatrix m = new PdMatrix ( 3 , 3 ) ; for ( int v = 0 ; v < m_geometry . getNumVertices ( ) ; ++ v ) { PdVector p = m_geometry . getVertex ( v ) ; for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { double val = ( p . getEntry ( i ) - c . getEntry ( i ) ) * ( p . getEntry ( j ) - c . getEntry ( j ) ) ; m . setEntry ( i , j , m . getEntry ( i , j ) + val ) ; } } } m_boundingBox = getBoundingBox ( m ) ; m_disp . addGeometry ( m_boundingBox ) ; m_disp . update ( m_boundingBox ) ; }
te	2	public static JSONArray listById ( long [ ] aId ) { JSONArray ja = new JSONArray ( ) ; for ( long l : aId ) { User user = User . findById ( l ) ; if ( user != null ) ja . put ( user . toJson ( ) ) ; } return ja ; }
te	2	public EnumResource getTopImport ( ) { EnumResource topImport = null ; int importValue = 0 ; for ( Map . Entry < EnumResource , Integer [ ] > entry : resourceImportExport . entrySet ( ) ) { if ( entry . getValue ( ) [ 0 ] > importValue ) { importValue = entry . getValue ( ) [ 0 ] ; topImport = entry . getKey ( ) ; } } return topImport ; }
te	4	void moveDownSItem_actionPerformed ( ActionEvent e ) { if ( currentElementShape == null || currentFractalShape == null ) return ; ArrayList < ElementShape > list = currentFractalShape . elementShapes ; int index = list . indexOf ( currentElementShape ) ; if ( index == - 1 || index == list . size ( ) - 1 ) return ; list . remove ( index ) ; list . add ( index + 1 , currentElementShape ) ; updateShapes ( ) ; FractalShapeMaker . viewer . redraw ( ) ; }
te	4	public int [ ] select ( Population pop , int toSelect ) { double minimal = pop . people [ 0 ] . fitness ( ) ; if ( minimal * pop . getBest ( ) . fitness ( ) >= 0 ) minimal = 0 ; int selected [ ] = new int [ toSelect ] ; for ( int creature = 0 ; creature < toSelect ; creature ++ ) { double acc = Math . abs ( Math . random ( ) * pop . average ( ) - minimal ) * pop . people . length ; int s = pop . people . length ; while ( acc >= 0 && s > 0 ) acc -= Math . abs ( pop . people [ -- s ] . fitness ( ) - minimal ) ; selected [ creature ] = s ; } return selected ; }
te	8	@ Override public Vector3f [ ] getAllMaxAlongDirection ( Vector3f [ ] result , Vector3f dir , int count , float eps ) { if ( count > 0 ) { eps /= dir . length ( ) ; float dotmaxdir = vertices [ 0 ] . . ( dir ) ; result [ 0 ] . set ( vertices [ 0 ] ) ; int j = 1 ; for ( int i = vertices . length - 1 ; i > 0 ; i -- ) { final float dotshapedir = vertices [ i ] . . ( dir ) ; if ( dotshapedir >= dotmaxdir ) { if ( dotshapedir >= dotmaxdir + eps ) { result [ 0 ] . set ( vertices [ i ] ) ; j = 1 ; } else if ( j < count ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } dotmaxdir = dotshapedir ; } else if ( j < count && dotshapedir + eps >= dotmaxdir ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } } for ( ; j < count ; j ++ ) { result [ j ] . set ( 0 , 0 , 0 ) ; } } return result ; }
te	1	public static Object getBean ( String patternName ) { try { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = dFactory . newDocumentBuilder ( ) ; Document document ; document = builder . parse ( new File ( "config.xml" ) ) ; String findClassName = patternName + "ClassName" ; NodeList nl = document . getElementsByTagName ( findClassName ) ; Node classNode = nl . item ( 0 ) . getFirstChild ( ) ; String cName = classNode . getNodeValue ( ) ; System . out . println ( cName ) ; String className = "com.seven." + patternName . toLowerCase ( ) + "." + cName ; class c = class . forName ( className ) ; Object object = c . newInstance ( ) ; return object ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
te	0	public String getLocunit ( ) { return locunit ; }
te	2	public static final void initialize ( ) { slowSlaves = new SlaveThread [ NB_SLOWSLAVES ] ; fastSlaves = new SlaveThread [ NB_FASTSLAVES ] ; for ( int i = 0 ; i < NB_SLOWSLAVES ; i ++ ) { slowSlaves [ i ] = new SlaveThread ( ) ; slowSlaves [ i ] . start ( ) ; } for ( int i = 0 ; i < NB_FASTSLAVES ; i ++ ) { fastSlaves [ i ] = new SlaveThread ( ) ; fastSlaves [ i ] . start ( ) ; } indexSlow = 0 ; indexFast = 0 ; }
te	6	private void markForUpdate ( int posX , int posY , int radius ) { int leftX = posX - radius ; int rightX = posX + radius ; int topY = posY - radius ; int bottomY = posY + radius ; if ( leftX < 0 ) leftX = 0 ; if ( rightX >= width ) rightX = width - 1 ; if ( topY < 0 ) topY = 0 ; if ( bottomY >= height ) bottomY = height - 1 ; for ( int i = leftX ; i <= rightX ; i ++ ) { for ( int j = topY ; j <= bottomY ; j ++ ) markForUpdate ( i , j ) ; } }
te	8	@ EventHandler ( priority = EventPriority . NORMAL ) public void onChat ( final AsyncPlayerChatEvent event ) { if ( Bukkit . getServer ( ) . getPluginManager ( ) . getPlugin ( "mcMMO" ) != null ) { if ( ! Users . getProfile ( event . getPlayer ( ) . getName ( ) ) . getAdminChatMode ( ) ) { if ( event . isCancelled ( ) ) { return ; } } } else if ( event . isCancelled ( ) ) { return ; } try { final Player player = event . getPlayer ( ) ; for ( final IRCChannel c : MonsterIRC . getChannels ( ) ) { if ( c . getChatType ( ) == ChatType . MTADMINCHAT ) { continue ; } if ( c . getChatType ( ) == ChatType . TOWNYCHAT ) { continue ; } MonsterIRCListener . handleMessage ( player , c , event . getMessage ( ) ) ; } } catch ( final Exception e ) { IRC . debug ( e ) ; } }
te	0	public String getDescription ( ) { return description ; }
te	3	private void clickedChangeType ( ) { if ( cmbType . getSelectedItem ( ) . equals ( "simple" ) ) type = Phrase . Type . simple ; else if ( cmbType . getSelectedItem ( ) . equals ( "conjugation" ) ) type = Phrase . Type . conjugation ; else if ( cmbType . getSelectedItem ( ) . equals ( "number" ) ) type = Phrase . Type . number ; updateLayout ( ) ; }
te	9X	public void setProperty ( String prop , Object value ) { Map < String , class < ? extends Object >> specialProperties = null ; try { java . lang . reflect . Field f = class . forName ( new Throwable ( ) . fillInStackTrace ( ) . getStackTrace ( ) [ 1 ] . getClassName ( ) ) . getField ( "SPECIAL_PROPERTIES" ) ; if ( f . getType ( ) . getName ( ) . equals ( "java.util.Map" ) ) { specialProperties = ( Map < String , class < ? extends Object >> ) f . get ( null ) ; } } catch ( Exception e ) { } if ( ( Channel . ALLOWED_PROPERTIES . containsKey ( prop ) && value . getClass ( ) . equals ( Channel . ALLOWED_PROPERTIES . get ( prop ) ) ) || ( specialProperties != null && specialProperties . containsKey ( prop ) && value . getClass ( ) . equals ( specialProperties . get ( prop ) ) ) ) { this . properties . put ( prop , value ) ; } else { throw new IllegalArgumentException ( ) ; } }
te	5	@ Override public Spieltag loadSpieltagFromFile ( final String filename ) throws PdfGeneratorException { Logger . getInstance ( ) . logInfo ( "FileImport" , "Loading Spieltag from file: " + filename ) ; final String [ ] lines = FileIO . getLinesFromFile ( filename ) ; if ( lines . length < 4 ) { throw new ParseException ( "Wrong field count in file: " + filename ) ; } final Spieltag tag = new Spieltag ( ) ; tag . setTitle ( FileIO . cleanQuotes ( lines [ 0 ] ) ) ; tag . setDatum ( FileIO . cleanQuotes ( lines [ 1 ] ) ) ; tag . setZeit ( FileIO . cleanQuotes ( lines [ 2 ] ) ) ; tag . setOrt ( FileIO . cleanQuotes ( lines [ 3 ] ) ) ; final String [ ] halle = FileIO . getFieldsFromLine ( lines [ 4 ] ) ; if ( halle . length != 4 ) { throw new ParseException ( "Wrong field count in file: " + filename ) ; } tag . setHalle_name ( halle [ 0 ] ) ; tag . setHalle_ort ( halle [ 1 ] ) ; tag . setHalle_strasse ( halle [ 2 ] ) ; tag . setHalle_tel ( halle [ 3 ] ) ; int index = 5 ; final List < String > teams = new ArrayList < String > ( ) ; while ( ! lines [ index ] . equals ( "<Spielfolge>" ) ) { final String t = FileIO . cleanQuotes ( lines [ index ] ) ; if ( ! t . equals ( "" ) ) { teams . add ( t ) ; } index ++ ; } tag . setTeams ( teams ) ; index ++ ; final List < String [ ] > games = new ArrayList < String [ ] > ( ) ; for ( int i = index ; i < lines . length ; i ++ ) { games . add ( FileIO . getSpielFromLine ( lines [ i ] ) ) ; } tag . setGames ( games ) ; Logger . getInstance ( ) . logInfo ( "FileImport" , "Loading DONE" ) ; return tag ; }
te	7	public static int commonTele ( TeamMatch match ) { int one , two , three ; one = two = three = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof OnePointTele ) { one ++ ; } else if ( p instanceof TwoPointTele ) { two ++ ; } else if ( p instanceof ThreePointTele ) { three ++ ; } } int max = Math . max ( one , Math . max ( two , three ) ) ; return max == three ? 3 : ( max == two ? 2 : ( max == one ? 1 : 0 ) ) ; }
te	8	public static void changeLiveTuning ( ) { if ( kbPanel == null ) { return ; } if ( ( sineCombo . getSelectedIndex ( ) > 0 ) || ( jKeyStrings . getSelectedIndex ( ) > 0 ) ) try { kbPanel . setFrequencies ( tuningSchemes . getPitchShifts ( ( String ) jTunings . getSelectedItem ( ) , 2 , jNotes . getSelectedIndex ( ) , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) , jNotes . getSelectedIndex ( ) , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) ; } catch ( Exception e ) { } int program = jProgram . getSelectedIndex ( ) ; int pitchshift [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; int rootnote = jNotes . getSelectedIndex ( ) ; try { pitchshift = tuningSchemes . getPitchShifts ( ( String ) jTunings . getSelectedItem ( ) , 2 , rootnote , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) ; } catch ( Exception e ) { displayerror ( e . getMessage ( ) ) ; } kbPanel . setProgram ( program ) ; kbPanel . setPitchShifts ( pitchshift , rootnote ) ; if ( jKeyStrings . getSelectedIndex ( ) > 0 ) { updateKeyStrings ( jKeyStrings . getSelectedIndex ( ) ) ; } if ( ! ( theSequencer == null ) ) { if ( theSequencer . isRunning ( ) ) { long pos = theSequencer . getTickPosition ( ) ; startSequence ( pos ) ; } } }
te	5	public void smokeIntoFire ( ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { Point p = new Point ( x , y ) ; ThreatToken t = fireLayer . getTokenAt ( p ) ; if ( t != null && tokenLocs . get ( t ) == null ) { System . out . println ( "Item is in the fire layer but not tokenlocs: " + p ) ; System . out . println ( "FireLayer:\n" + fireLayer ) ; System . out . println ( "TokenLocs:\n" + tokenLocs ) ; } if ( t instanceof FireToken ) { smokeIntoFire ( ( FireToken ) t ) ; } } } }
te	3	public double getPrecio ( ) { if ( tipo == TipoConsola . XBOX ) { return 299 ; } else if ( tipo == TipoConsola . WII ) { return 199 ; } else if ( tipo == TipoConsola . PS3 ) { return 320 ; } else { return - 1 ; } }
te	6	String toString ( int indentFactor , int indent ) throws JSONException { int len = length ( ) ; if ( len == 0 ) { return "[]" ; } int i ; StringBuffer sb = new StringBuffer ( "[" ) ; if ( len == 1 ) { sb . append ( JSONObject . valueToString ( this . myArrayList . get ( 0 ) , indentFactor , indent ) ) ; } else { int newindent = indent + indentFactor ; sb . append ( '' ) ; for ( i = 0 ; i < len ; i += 1 ) { if ( i > 0 ) { sb . append ( " \n" ) ; } for ( int j = 0 ; j < newindent ; j += 1 ) { sb . append (   ) ; } sb . append ( JSONObject . valueToString ( this . myArrayList . get ( i ) , indentFactor , newindent ) ) ; } sb . append ( '' ) ; for ( i = 0 ; i < indent ; i += 1 ) { sb . append (   ) ; } } sb . append ( ] ) ; return sb . toString ( ) ; }
te	7	private void updateCommandCard ( ) { switch ( interactionState ) { case mapScrolling : case menu : case placeTower : case scrolling : case zooming : displayEmptyCommandCard ( ) ; break ; case normal : displayBuyCommandCard ( ) ; break ; case selected : displayTowerCommandCard ( ) ; break ; } }
te	7	public static String singleOccurance ( String s ) { char c [ ] = s . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < c . length ; i ++ ) { if ( c [ i ] !=   ) { for ( int j = i + 1 ; j < c . length ; j ++ ) { if ( c [ i ] == c [ j ] ) { count ++ ; } else { i = j - 1 ; break ; } } } } System . out . println ( count ) ; char c1 [ ] = new char [ c . length - count ] ; for ( int i = 0 , k = 0 ; i < c . length ; i ++ , k ++ ) { c1 [ k ] = c [ i ] ; for ( int j = i ; j < c . length ; j ++ ) { if ( c [ i ] != c [ j ] ) { i = j - 1 ; break ; } } } s = new String ( c1 ) ; return s ; }
te	8	public static double findMedianSortedArrays ( int A [ ] , int B [ ] ) { int m = A . length , n = B . length ; double result = 0 ; if ( m > n ) return findMedianSortedArrays ( B , A ) ; int k = ( m + n - 1 ) / 2 ; int left = 0 , right = Math . min ( m , k ) ; while ( left < right ) { int i = ( left + right ) / 2 ; int j = k - i ; if ( A [ i ] < B [ j ] ) { left = i + 1 ; } else { right = i ; } } result = Math . max ( left > 0 ? A [ left - 1 ] : Integer . MIN_VALUE , k - left >= 0 ? B [ k - left ] : Integer . MIN_VALUE ) ; if ( ( ( m + n ) & 1 ) == 1 ) return result ; else result = ( result + Math . min ( left < m ? A [ left ] : Integer . MAX_VALUE , k - left + 1 < n ? B [ k - left + 1 ] : Integer . MAX_VALUE ) ) / 2 ; return result ; }
te	5	@ Override public String toString ( ) { StringBuilder string = new StringBuilder ( game . name ) . append ( " - (" ) . append ( game . getTick ( ) ) . append ( ":" ) . append ( String . format ( "%.3f" , ( double ) game . getFrames ( ) / game . getTick ( ) ) ) . append ( "): " ) ; Alliance no1 = null ; for ( Alliance alliance : this ) { if ( no1 == null || no1 . getScore ( ) < alliance . getScore ( ) ) { no1 = alliance ; } string . append ( alliance . name ) . append ( ": " ) . append ( alliance . getScore ( ) ) . append ( "  " ) ; } return no1 == null ? string . toString ( ) : string . append ( no1 . name ) . append ( no1 . name . endsWith ( "s" ) ? " are" : " is" ) . append ( " winning" ) . toString ( ) ; }
te	0	public static String readLine ( String prompt ) { printPrompt ( prompt ) ; return readLine ( ) ; }
te	1	public CoverDetails deserialize ( JSONObject json ) throws Exception { Integer id = ( Integer ) json . get ( id_key ) ; String artist = ( String ) json . get ( artist_key ) ; String album = ( String ) json . get ( album_key ) ; Integer discNumber = ( Integer ) json . get ( disc_key ) ; boolean noImage = ( boolean ) json . get ( noImage_key ) ; JSONArray tracks = ( JSONArray ) json . get ( tracks_key ) ; int len = tracks . length ( ) ; List < TrackDetails > trackNames = new ArrayList < TrackDetails > ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { JSONObject trackJson = ( JSONObject ) tracks . get ( i ) ; String title = ( String ) trackJson . get ( title_key ) ; Integer lengthSeconds = ( Integer ) trackJson . get ( length_key ) ; trackNames . add ( new TrackDetails ( title , lengthSeconds . intValue ( ) ) ) ; } Image image = null ; CoverDetails cover = new CoverDetails ( id . intValue ( ) , artist , album , image , discNumber . intValue ( ) , noImage . booleanValue ( ) ) ; cover . setTrackNames ( trackNames ) ; return cover ; }
te	7	public RandomListNode copyRandomListII ( RandomListNode head ) { if ( head == null ) return head ; RandomListNode iter = head ; while ( iter != null ) { RandomListNode newNode = new RandomListNode ( iter . label ) ; newNode . next = iter . next ; newNode . random = iter . random ; iter . next = newNode ; iter = newNode . next ; } iter = head . next ; RandomListNode newHead = iter ; while ( iter != null ) { if ( iter . random != null ) iter . random = iter . random . next ; if ( iter . next != null ) iter = iter . next . next ; else iter = null ; } iter = head ; while ( iter != null && iter . next != null ) { RandomListNode nextIter = iter . next ; iter . next = iter . next . next ; iter = nextIter ; } return newHead ; }
te	6	public int ladderLength ( String start , String end , Set < String > dict ) { if ( null == dict || dict . size ( ) == 0 ) { return 0 ; } char [ ] startArr = start . toCharArray ( ) ; List < String > res = new ArrayList < > ( ) ; for ( char i = a ; i < z ; i ++ ) { for ( int j = 0 ; j < startArr . length ; j ++ ) { String temp = start . substring ( 0 , j ) + i + start . substring ( j + 1 ) ; if ( dict . contains ( temp ) ) { res . add ( temp ) ; dict . remove ( temp ) ; } else { continue ; } if ( temp . equals ( end ) ) { return res . size ( ) ; } } } return 0 ; }
te	3	public static boolean isOnFromOrBetween ( Calendar date , Calendar from , Calendar to ) { boolean afterFrom = isAfter ( date , from ) ; boolean beforeTo = isBefore ( date , to ) ; boolean onFrom = isSameDay ( date , from ) ; if ( ( afterFrom && beforeTo ) || onFrom ) { return true ; } else { return false ; } }
te	4	public void connect ( ) { String shortName = protocol . nameOfTheGame ( ) ; minPlayer = protocol . minPlayer ( ) ; maxPlayer = protocol . maxPlayer ( ) ; System . out . println ( "Try to connect to " + host + ":" + port ) ; log ( "Try to connect to " + host + ":" + port ) ; myGUI . printOutput ( "Versuche zu verbinden mit " + host + ":" + port ) ; try { myCom = new Communicator ( host , port , shortName , minPlayer , maxPlayer , this ) ; protocol . setCommunicator ( myCom ) ; myGUI . enableConnectToServer ( false ) ; log ( "Connected to Server  player number: " + myCom . myNumber ( ) ) ; System . out . println ( "Wait for Players!" ) ; log ( "Wait for Players!" ) ; myGUI . printOutput ( "Warte auf weitere Spieler!" ) ; boolean connected = true ; if ( myCom . waitForPlayers ( ) ) { System . out . println ( "game startet!" ) ; log ( "game startet!" ) ; myGUI . printOutput ( "Spiel wird gestartet!" ) ; myGUI . setVisible ( false ) ; if ( myCom . myNumber ( ) > 0 ) protocol . receiveFirst ( ) ; else protocol . sendFirst ( ) ; System . out . println ( "game ended!" ) ; log ( "game ended!" ) ; myGUI . printOutput ( "Spiel ist zuende!" ) ; myGUI . setVisible ( true ) ; myCom . sendTo ( - 2 , String . valueOf ( 0 ) ) ; disconnect ( ) ; myGUI . enableConnectToServer ( true ) ; } } catch ( UnknownHostException ex ) { myGUI . printOutput ( host + " nicht gefunden!" ) ; System . err . println ( ex ) ; log ( ex + " : " + host ) ; } catch ( IOException ex ) { myGUI . printOutput ( "Verbindung fehlgeschlagen!" ) ; System . err . println ( ex ) ; log ( ex + " : " + host ) ; } }
te	9X	private Set < Player > scanDiagonals ( Player [ ] [ ] board ) { HashSet < Player > winners = new HashSet < > ( ) ; int sameInRow = 0 ; int m = Board . NUM_ROWS ; int n = Board . NUM_COLUMNS ; for ( int slice = 0 ; slice < m + n - 1 ; ++ slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = slice - z2 ; j >= z1 ; -- j ) { Player currentPlayer = board [ slice - j ] [ j ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } for ( int slice = m + n - 1 ; slice > 0 ; -- slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = z1 ; j <= slice - z2 ; ++ j ) { Player currentPlayer = board [ slice - j ] [ m - j - 1 ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } return winners ; }
te	2	public JSONObject ( JSONObject jo , String [ ] names ) { this ( ) ; for ( int i = 0 ; i < names . length ; i += 1 ) { try { this . putOnce ( names [ i ] , jo . opt ( names [ i ] ) ) ; } catch ( Exception ignore ) { } } }
te	7	public int delete ( ) { String SQL1 = "DELETE FROM mensajes WHERE id=" + this . id + " LIMIT 1;" ; int nup = getSgd ( ) . executeUpdate ( SQL1 ) ; if ( nup > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "Mensajes" ) ; log . setDatos ( "id=" + this . id ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } String SQL0 = "SELECT id FROM mensajesprofesores WHERE idMensajes=" + this . id ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs = getSgd ( ) . getResultSet ( SQL0 , st ) ; while ( rs != null && rs . next ( ) ) { int idmp = rs . getInt ( 1 ) ; SQL1 = "DELETE FROM mensajesprofesores WHERE id=" + idmp + " LIMIT 1;" ; int success = getSgd ( ) . executeUpdate ( SQL1 ) ; nup += success ; if ( success > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "MensajesProfesores" ) ; log . setDatos ( "id=" + idmp ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } } if ( rs != null ) { rs . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Mensajes . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } String SQL = "DELETE FROM " + client . getPlusDbName ( ) + "sgd_mensajes_richtext WHERE idMensajes=" + this . id + " LIMIT 1" ; client . getPlusDb ( ) . executeUpdate ( SQL ) ; for ( BeanMensajesAttachment atc : attachments ) { atc . delete ( ) ; } return nup ; }
te	7	static final public int totalDiff ( final String hash1 , final String hash2 , final boolean lenDiff ) { int diff = 0 ; int [ ] iHash1 = fromHex ( hash1 ) ; int [ ] iHash2 = fromHex ( hash2 ) ; if ( lenDiff ) { int ldiff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN ] , iHash2 [ TLSH_CHECKSUM_LEN ] , RANGE_LVALUE ) ; if ( ldiff == 0 ) diff = 0 ; else if ( ldiff == 1 ) diff = 1 ; else diff += ldiff * 12 ; } int q1diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] & f , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] & f , RANGE_QRATIO ) ; if ( q1diff <= 1 ) diff += q1diff ; else diff += ( q1diff - 1 ) * 12 ; int q2diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , RANGE_QRATIO ) ; if ( q2diff <= 1 ) diff += q2diff ; else diff += ( q2diff - 1 ) * 12 ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( iHash1 [ k ] != iHash2 [ k ] ) { diff ++ ; break ; } } diff += hDistance ( Arrays . copyOfRange ( iHash1 , TLSH_CHECKSUM_LEN + 2 , iHash1 . length ) , Arrays . copyOfRange ( iHash2 , TLSH_CHECKSUM_LEN + 2 , iHash2 . length ) ) ; return diff ; }
te	2	private char getPlayerSymbol ( int symbolNum ) { switch ( symbolNum ) { case 0 : return - ; case 1 : return X ; default : return O ; } }
te	8	@ Override public int [ ] generate ( ArrayList < Function > program ) throws Exception { if ( ! program . get ( program . size ( ) - 1 ) . name . getString ( ) . equals ( "__MAIN__" ) ) { throw new Exception ( "Main not found" ) ; } emit ( DLX . assemble ( DLX . ADDI , sp , zero , 0 ) ) ; emit ( DLX . assemble ( DLX . ADD , fp , zero , sp ) ) ; boolean main = true ; for ( int i = program . size ( ) - 1 ; i >= 0 ; i -- ) { Function f = program . get ( i ) ; currentFunction = f ; makeLabel ( f . name ) ; AnalyzeRegistersUsed analysis = new AnalyzeRegistersUsed ( registersAvailable , retAddr - minAvail ) ; f . entryPoint . runPass ( analysis ) ; f . locals . allocateMemoryCells ( analysis . memNeeded ) ; regStack . clear ( ) ; if ( ! main ) { push ( fp ) ; emit ( DLX . assemble ( DLX . ADD , fp , zero , sp ) ) ; } if ( f . locals . getSize ( ) > 0 ) { emit ( DLX . assemble ( DLX . ADDI , sp , sp , f . locals . getSize ( ) ) ) ; } if ( ! main ) { for ( Integer reg : analysis . registersUsed ) { int realReg = reg + minAvail ; regStack . push ( realReg ) ; push ( realReg ) ; } } emitCode ( f . entryPoint ) ; main = false ; } if ( ! fixup . isEmpty ( ) ) { throw new Exception ( "Unresolved branch location" ) ; } int spSet = code . get ( 0 ) ; spSet = setC ( spSet , 4 * code . size ( ) ) ; code . set ( 0 , spSet ) ; int [ ] rval = new int [ code . size ( ) ] ; for ( int i = 0 ; i < code . size ( ) ; i ++ ) { rval [ i ] = code . get ( i ) ; } code . clear ( ) ; return rval ; }
te	3	private void replaceNode ( LinkSetNode oldn , LinkSetNode newn ) { if ( oldn . parent == null ) { root = newn ; } else { if ( oldn == oldn . parent . left ) { oldn . parent . left = newn ; } else { oldn . parent . right = newn ; } } if ( newn != null ) { newn . parent = oldn . parent ; } }
te	3	public case getCaseAt ( int x , int y ) throws Exception { for ( case c : this . get_cases ( ) ) { if ( c . getX ( ) == x && c . getY ( ) == y ) { return c ; } } throw new Exception ( "La case de coordonn\u00E9es (" + x + " " + y + ") n'\u00E9xiste pas" ) ; }
te	9X	public static int maxProfit4 ( int [ ] prices ) { if ( prices . length < 2 ) { return 0 ; } int [ ] left = new int [ prices . length ] ; int [ ] right = new int [ prices . length ] ; int min = prices [ 0 ] ; int max = prices [ prices . length - 1 ] ; left [ 0 ] = 0 ; right [ prices . length - 1 ] = 0 ; for ( int i = 1 ; i < prices . length ; i ++ ) { if ( prices [ i ] < min ) min = prices [ i ] ; left [ i ] = prices [ i ] - min > left [ i - 1 ] ? prices [ i ] - min : left [ i - 1 ] ; } for ( int i = prices . length - 2 ; i >= 0 ; i -- ) { if ( prices [ i ] > max ) max = prices [ i ] ; right [ i ] = max - prices [ i ] > right [ i + 1 ] ? max - prices [ i ] : right [ i + 1 ] ; } int total = 0 ; for ( int i = 0 ; i < prices . length ; i ++ ) { total = left [ i ] + right [ i ] > total ? left [ i ] + right [ i ] : total ; } return total ; }
te	9X	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Point" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isExtrudeDirty ) { change += "<extrude>" + this . extrude + "</extrude>\n" ; this . isExtrudeDirty = false ; } if ( this . isTessellateDirty ) { change += "<tessellate>" + this . tessellate + "</tessellate>\n" ; this . isTessellateDirty = false ; } if ( this . altitudeMode != null && this . isAltitudeModeDirty ) { change += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; this . isAltitudeModeDirty = false ; } if ( this . coordinates != null && this . isCoordinatesDirty ) { change += "<coordinates>" + SpecialCaseFormatter . toKMLString ( this . getCoordinates ( ) ) + "</coordinates>\n" ; this . isCoordinatesDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Point>\n" ; } setNotDirty ( ) ; return change ; }
te	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
te	7	public void countXml ( XmlPullParser xpp ) throws XmlPullParserException , IOException { int holderForStartAndLength [ ] = new int [ 2 ] ; xpp . require ( XmlPullParser . START_DOCUMENT , null , null ) ; int eventType = xpp . next ( ) ; xpp . require ( XmlPullParser . START_TAG , null , null ) ; while ( eventType != XmlPullParser . END_DOCUMENT ) { if ( eventType == XmlPullParser . START_TAG ) { ++ countSTags ; countAttribs += xpp . getAttributeCount ( ) ; if ( verbose ) { System . err . println ( "START_TAG " + xpp . getName ( ) ) ; } } else if ( eventType == XmlPullParser . TEXT ) { xpp . getTextCharacters ( holderForStartAndLength ) ; int length = holderForStartAndLength [ 1 ] ; countChars += length ; if ( verbose ) { System . err . println ( "TEXT '" + printable ( xpp . getText ( ) ) + "'" ) ; } } else if ( eventType == XmlPullParser . END_TAG ) { if ( verbose ) { System . err . println ( "END_TAG " + xpp . getName ( ) ) ; } } eventType = xpp . next ( ) ; } }
te	1	public void saveToFile ( ) throws IOException { try ( PrintWriter out = new PrintWriter ( new FileWriter ( this . name + ".hist" ) ) ) { out . println ( this . count ) ; out . println ( this . min ) ; out . println ( this . max ) ; for ( Integer b : bins ) out . println ( b ) ; } }
te	3	boolean sameValue ( DNSRecord other ) { Service s = ( Service ) other ; return ( priority == s . priority ) && ( weight == s . weight ) && ( port == s . port ) && server . equals ( s . server ) ; }
te	2	AnnotatedOption ( class clazz , Field field , Param param ) { this . clazz = clazz ; this . field = field ; this . param = param ; if ( param . option ( ) . isEmpty ( ) ) { opt = field . getName ( ) . substring ( 0 , 1 ) . toLowerCase ( ) ; } else { opt = param . option ( ) ; } if ( param . name ( ) . isEmpty ( ) ) { name = field . getName ( ) . toLowerCase ( ) ; } else { name = param . name ( ) ; } }
te	6	public static String getDescription ( int value ) { String description = "Undefined" ; switch ( value ) { case OTHER : description = "Other" ; break ; case KY_28 : description = "KY-28" ; break ; case KY_58 : description = "KY-58" ; break ; case NSVE : description = "Narrow Spectrum Secure Voice" ; break ; case WSVE : description = "Wide Spectrum Secure Voice" ; break ; case SINCGARS_ICOM : description = "SINCGARS ICOM" ; break ; } return description ; }
te	0	private static void simpleTest ( ) { List < Rule > rules = RuleFactory . create ( "1 /2 -" ) ; List < double > values = new ArrayList < double > ( ) ; values . add ( 0.5 ) ; values . add ( 0.2 ) ; values . add ( 1000. ) ; System . out . println ( RuleCompiler . compile ( rules , values ) ) ; }
te	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tela other = ( Tela ) obj ; if ( modulo == null ) { if ( other . modulo != null ) return false ; } else if ( ! modulo . equals ( other . modulo ) ) return false ; if ( nome == null ) { if ( other . nome != null ) return false ; } else if ( ! nome . equals ( other . nome ) ) return false ; if ( nro == null ) { if ( other . nro != null ) return false ; } else if ( ! nro . equals ( other . nro ) ) return false ; return true ; }
te	8	public void worldLogic ( ) { long updateFrame = 0 ; long now ; long newFrame ; boolean updateSent = false ; ByteBuffer addEntityBuffer = null ; long startTime = new Date ( ) . getTime ( ) ; worldStartTime = startTime ; System . out . println ( "StartTime:" + startTime ) ; while ( ! endOfTheWorld ) { toSpawn . clear ( ) ; now = new Date ( ) . getTime ( ) ; newFrame = ( int ) ( ( now - startTime ) / DELAY ) ; adjustSleepTime ( newFrame - frame ) ; if ( newFrame > frame ) { updateSent = false ; simulateFrames ( newFrame , toRemove ) ; } if ( updateFrame < frame ) { updateFrame = frame ; if ( playerListChanged ) { addEntityBuffer = ByteBuffer . allocate ( UPDATEBUFFER_SIZE ) ; } scheduleRefreshPackets ( addEntityBuffer ) ; } if ( updateSent == false ) { sendPendingPackets ( addEntityBuffer , now ) ; updateSent = true ; if ( addEntityBuffer != null ) { playerListChanged = false ; addEntityBuffer = null ; } updateBuffer = emptyBuffer ; } if ( sleepTime > 0 ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { } } } disconnectClients ( ) ; }
te	5	@ Override public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] == true ) s = s . concat ( "1" ) ; else s = s . concat ( "0" ) ; if ( i == 5 || i == 10 || i == 15 ) s = s . concat ( " " ) ; } return s ; }
te	4	OptionSet ( Map < String , AbstractOptionSpec < ? >> recognizedSpecs ) { detectedSpecs = new ArrayList < OptionSpec < ? >> ( ) ; detectedOptions = new HashMap < String , AbstractOptionSpec < ? >> ( ) ; optionsToArguments = new IdentityHashMap < AbstractOptionSpec < ? > , List < String >> ( ) ; defaultValues = defaultValues ( recognizedSpecs ) ; this . recognizedSpecs = recognizedSpecs ; }
te	1	public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; comboBox . setEnabled ( enabled ) ; if ( spinner != null ) { spinner . setEnabled ( enabled ) ; } }
te	7	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
te	9X	@ Test public void testDoMuoviDinosauro ( ) { aggiungiDueUtenti ( ) ; try { assertTrue ( logicaTest . doCreaRazza ( testingToken , "miaRazza1" , e ) ) ; assertTrue ( logicaTest . doAccessoPartita ( testingToken ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( NomeRazzaOccupatoException e ) { fail ( ) ; } catch ( InterruptedException e ) { fail ( ) ; } catch ( TroppiGiocatoriException e ) { fail ( ) ; } catch ( RazzaNonCreataException e ) { fail ( ) ; } Iterator < Dinosauro > itDino = null ; try { itDino = logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . iterator ( ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } assertNotNull ( itDino ) ; assertTrue ( itDino . hasNext ( ) ) ; Dinosauro tmpDino = itDino . next ( ) ; assertNotNull ( tmpDino ) ; String tmpId = tmpDino . getIdDinosauro ( ) ; assertNotNull ( tmpId ) ; assertEquals ( tmpId , tmpDino . getIdDinosauro ( ) ) ; tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; try { logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . cresciDinosauro ( tmpId ) ; logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . aggiornaRazza ( ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { fail ( ) ; } tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; String ret = null ; try { do { ret = logicaTest . doMuoviDinosauro ( testingToken , tmpId , new Coord ( tmpDino . getCoord ( ) . getX ( ) + CommonUtils . getNewRandomIntValue ( 3 ) , tmpDino . getCoord ( ) . getY ( ) + CommonUtils . getNewRandomIntValue ( 3 ) ) ) ; System . out . println ( "ret: " + ret ) ; assertNotNull ( ret ) ; } while ( ret . equals ( "destinazioneNonValida" ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { System . out . println ( "GenericDinosauroException incontrata! " + e . getMessage ( ) ) ; fail ( ) ; } try { tmpDino = logicaTest . getPlayerByIdDinosauro ( tmpId ) . getRazza ( ) . getDinosauroById ( tmpId ) ; tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; ret = logicaTest . doMuoviDinosauro ( testingToken , tmpId , new Coord ( tmpDino . getCoord ( ) . getX ( ) + 1 , tmpDino . getCoord ( ) . getY ( ) + 1 ) ) ; assertNotNull ( ret ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { System . out . println ( "[testDoMuoviDinosauro] Eccezione GenericDinosauroException gestita correttamente \"" + e . getMessage ( ) + "\"" ) ; } }
te	8	public void init ( ) { if ( el . winwidth == 0 ) { el . winwidth = getWidth ( ) ; el . winheight = getHeight ( ) ; } initCanvas ( ) ; if ( ! el . view_initialised ) { exitEngine ( "Canvas settings not initialised  use setCanvasSettings()." ) ; } if ( ! i_am_applet ) { jre . createWindow ( this , jre . win_decoration ) ; } canvas = new JGCanvas ( el . winwidth , el . winheight ) ; jre . canvas = canvas ; el . initPF ( ) ; jre . clearKeymap ( ) ; canvas . addMouseListener ( jre ) ; canvas . addMouseMotionListener ( jre ) ; canvas . addFocusListener ( jre ) ; canvas . setBackground ( getAWTColor ( el . bg_color ) ) ; if ( jre . my_win != null ) jre . my_win . setBackground ( getAWTColor ( el . bg_color ) ) ; el . msg_font = new JGFont ( "Helvetica" , 0 , ( int ) ( 16.0 / ( 640.0 / ( el . tilex * el . nrtilesx ) ) ) ) ; setLayout ( new FlowLayout ( FlowLayout . LEADING , 0 , 0 ) ) ; add ( canvas ) ; if ( ! JGObject . setEngine ( this ) ) { canvas . setInitPainter ( new ListCellRenderer ( ) { public Component getListCellRendererComponent ( JList d1 , Object value , int d2 , boolean initialise , boolean d4 ) { Graphics g = ( Graphics ) value ; setFont ( g , el . msg_font ) ; setColor ( g , el . fg_color ) ; drawString ( g , "JGame is already running in this VM" , el . viewWidth ( ) / 2 , el . viewHeight ( ) / 3 , 0 , false ) ; return null ; } } ) ; return ; } el . is_inited = true ; canvas . setInitPainter ( new ListCellRenderer ( ) { public Component getListCellRendererComponent ( JList d1 , Object value , int d2 , boolean initialise , boolean d4 ) { Graphics g = ( Graphics ) value ; setFont ( g , el . msg_font ) ; setColor ( g , el . fg_color ) ; JGImage splash = el . existsImage ( "splash_image" ) ? el . getImage ( "splash_image" ) : null ; if ( splash != null ) { JGPoint splash_size = getImageSize ( "splash_image" ) ; drawImage ( g , viewWidth ( ) / 2 - splash_size . x / 2 , viewHeight ( ) / 4 - splash_size . y / 2 , "splash_image" , false ) ; } drawString ( g , canvas . progress_message , viewWidth ( ) / 2 , viewHeight ( ) / 2 , 0 , false ) ; setColor ( g , el . bg_color ) ; drawRect ( g , ( int ) ( viewWidth ( ) * ( 0.1 + 0.8 * canvas . progress_bar ) ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 * ( 1.0 - canvas . progress_bar ) ) , ( int ) ( viewHeight ( ) * 0.05 ) , true , false , false ) ; setColor ( g , el . fg_color ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 * canvas . progress_bar ) , ( int ) ( viewHeight ( ) * 0.05 ) , true , false , false ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 ) , ( int ) ( viewHeight ( ) * 0.008 ) , true , false , false ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * ( 0.6 + 0.046 ) ) , ( int ) ( viewWidth ( ) * 0.8 ) , ( int ) ( viewHeight ( ) * 0.008 ) , true , false , false ) ; drawString ( g , canvas . author_message , viewWidth ( ) - 16 , viewHeight ( ) - getFontHeight ( g , el . msg_font ) - 10 , 1 , false ) ; return null ; } } ) ; if ( jre . my_win != null ) { jre . my_win . setVisible ( true ) ; jre . my_win . validate ( ) ; jre . setWindowSize ( jre . win_decoration ) ; } canvas . addKeyListener ( jre ) ; canvas . requestFocus ( ) ; thread = new Thread ( new JGEngineThread ( ) ) ; thread . start ( ) ; }
te	6	public static void main ( String [ ] args ) { int choice = 0 ; int select = 0 ; boolean exit = false ; Scanner input = new Scanner ( System . in ) ; System . out . println ( "Welcome  Please select your role in the resturant?" ) ; System . out . println ( "Menu Role" ) ; System . out . println ( ) ; System . out . println ( "0. Customer" ) ; System . out . println ( "1. Manager" ) ; System . out . println ( "2. Cook" ) ; System . out . println ( "3. Waitperson" ) ; System . out . println ( "4. Staff Member" ) ; System . out . println ( "5. Exit" ) ; choice = input . nextInt ( ) ; switch ( choice ) { case 0 : Customer guest = new Customer ( ) ; guest . displayMenu ( ) ; break ; case 1 : Manager m = new Manager ( ) ; m . displayMenu ( ) ; break ; case 2 : Cook c = new Cook ( ) ; c . displayMenu ( ) ; break ; case 3 : Waitperson w = new Waitperson ( ) ; w . displayMenu ( ) ; break ; case 4 : StaffMember s = new StaffMember ( ) ; s . displayMenu ( ) ; break ; case 5 : exit = true ; break ; default : System . out . println ( "Invalid Entry!" ) ; } }
te	3	@ Override public void doAction ( Player player , Grid grid ) throws InvalidActionException { if ( player . getRemainingTurns ( ) <= 0 ) throw new InvalidActionException ( "The player has no turns left!" ) ; Position currentPos = player . getPosition ( ) ; Position newPos = new Position ( currentPos . getxCoordinate ( ) + 1 , currentPos . getyCoordinate ( ) + 1 ) ; if ( ! canMoveToPosition ( player , grid , newPos ) || ! canMoveDiagonal ( grid , newPos ) ) throw new InvalidActionException ( "The player can't move to the desired position!" ) ; player . setPosition ( newPos ) ; player . getLightTrail ( ) . addPosition ( currentPos ) ; player . decrementTurn ( ) ; }
te	6	private void process_interpage_shared_properties ( ) throws Exception { Set < String > unique_urls = inter_webpage_shared_tags . keySet ( ) ; for ( String url_1 : unique_urls ) { for ( String url_2 : unique_urls ) { if ( url_1 . equals ( url_2 ) == false ) { System . out . println ( "\n\n^^^^^^^^^ " + url_1 + " : " + url_2 + "\n" ) ; float url_similarity = score_mapset ( inter_webpage_shared_tags . get ( url_1 ) , inter_webpage_shared_tags . get ( url_2 ) ) ; if ( url_similarity > 12f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/high_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/medium_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/low_similarity> <" + url_2 + "> ." ) ; } } } } }
te	2	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = 0 , cnt = 1 ; HDOJ1069 hdoj1069 = new HDOJ1069 ( ) ; while ( ( n = scanner . nextInt ( ) ) > 0 ) { hdoj1069 . init ( ) ; while ( n -- > 0 ) { hdoj1069 . handleInput ( scanner . nextInt ( ) , scanner . nextInt ( ) , scanner . nextInt ( ) ) ; } System . out . println ( String . format ( "Case %s: maximum height = %s" , cnt ++ , hdoj1069 . entrance ( ) ) ) ; } }
te	5	public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( "No file specified" ) ; System . exit ( rc ) ; } try ( FileReader input = new FileReader ( args [ 0 ] ) ) { Scanner scanner = new Scanner ( new BufferedReader ( input ) ) ; Parser parser = new Parser ( scanner ) ; package p = parser . parse ( ) ; IdTable table = new IdTable ( ) ; Analyzer analyzer = new Analyzer ( ) ; analyzer . visitPackage ( p , table ) ; if ( Reporter . error ) { System . exit ( rc ) ; } else { Encoder encoder = new Encoder ( ) ; encoder . visitPackage ( p , null ) ; int pos = args [ 0 ] . lastIndexOf ( ".java" ) ; String objectFileName = args [ 0 ] . substring ( 0 , pos ) + ".mJAM" ; ObjectFile objF = new ObjectFile ( objectFileName ) ; if ( objF . write ( ) ) { Reporter . emit ( "Object File Failed." ) ; } } System . exit ( 0 ) ; } catch ( FileNotFoundException e ) { Reporter . emit ( e . getMessage ( ) ) ; } catch ( IOException e ) { Reporter . emit ( e . getMessage ( ) ) ; } System . exit ( rc ) ; }
te	2	public double processInstruction ( Instruction toExecute ) { try { return toExecute . process ( myMap ) ; } catch ( IndexOutOfBoundsException e ) { showErrorMsg ( "IncorrectFormat" ) ; return 0 ; } catch ( IllegalArgumentException e ) { showErrorMsg ( "BlockError" ) ; return 0 ; } }
te	6	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Save" ) ) { finish ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Undo" ) ) { undoredo ( e . getActionCommand ( ) ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Redo" ) ) { undoredo ( e . getActionCommand ( ) ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Next" ) ) { wasLastInsertNext = true ; moveInsert ( 1 ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Prev" ) ) { wasLastInsertNext = false ; moveInsert ( 0 ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . contains ( "Append" ) ) { } }
te	1	public void updateMapObject ( Mappable templateObj , Object source ) { Mappable mappable = mapObjectMap . get ( templateObj . getId ( ) ) ; List < ConfigurableProperties > configurableProperties = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : configurableProperties ) { mappable . setConfiguredValue ( key , templateObj . getConfiguredValue ( key ) ) ; } }
te	4	public boolean checkVideoFile ( String loc ) { boolean returnValue = false ; try { _builder = new ProcessBuilder ( "/bin/bash" , "-c" , "echo $(file '" + loc + "')" ) ; _builder = _builder . redirectErrorStream ( true ) ; _process = _builder . start ( ) ; InputStream stdout = _process . getInputStream ( ) ; BufferedReader stdoutBuffered = new BufferedReader ( new InputStreamReader ( stdout ) ) ; String line = null ; while ( ( line = stdoutBuffered . readLine ( ) ) != null ) { if ( line . contains ( "Video" ) || line . contains ( "video" ) ) { returnValue = true ; } } _process . waitFor ( ) ; _process . destroy ( ) ; } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; } return returnValue ; }
te	2	public static void main ( String [ ] args ) { for ( int i = 1 ; i < 100 ; i ++ ) { if ( i % 2 > 0 ) { System . out . println ( i ) ; } } }
te	1	public static void main ( String [ ] args ) { Font font = new Font ( "Dialog" , Font . PLAIN , 18 ) ; UIManager . put ( "Button.font" , font ) ; UIManager . put ( "Label.font" , font ) ; int option ; do { option = JOptionPane . showConfirmDialog ( null , "Had enough?" , " A Stubborn Dialog" , JOptionPane . YES_NO_OPTION ) ; } while ( option == JOptionPane . NO_OPTION ) ; }
te	6	@ Override protected boolean PosValidEntity ( Entity entity , int newX , int newY ) { if ( this != entity && entity != null && ! entity . isDead ( ) && entity . canCollide && entity . collides ( newX , newY , width , height ) && ! ( entity instanceof Item ) ) { EntityCollision entityCol = new EntityCollision ( this , entity ) ; EntityCollision . entityCollisionList . push ( entityCol ) ; return true ; } return true ; }
te	2	@ Override public String toString ( ) { StringBuffer tempSpot = new StringBuffer ( "" ) ; for ( int counter = 1 , maxCounter = getPathCount ( ) ; counter < maxCounter ; counter ++ ) { if ( counter > 1 ) tempSpot . append ( File . separator ) ; tempSpot . append ( getPathComponent ( counter ) ) ; } return tempSpot . toString ( ) ; }
te	9X	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<BalloonStyle" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . color != null && this . isColorDirty ) { change += "<color>" + SpecialCaseFormatter . toKMLString ( this . color ) + "</color>\n" ; this . isColorDirty = false ; } if ( this . bgColor != null && this . isBgColorDirty ) { change += "<bgColor>" + SpecialCaseFormatter . toKMLString ( this . bgColor ) + "</bgColor>\n" ; this . isBgColorDirty = false ; } if ( this . textColor != null && this . isTextColorDirty ) { change += "<textColor>" + SpecialCaseFormatter . toKMLString ( this . textColor ) + "</textColor>\n" ; this . isTextColorDirty = false ; } if ( this . text != null && this . isTextDirty ) { change += "<text>" + SpecialCaseFormatter . toKMLString ( this . text ) + "</text>\n" ; this . isTextDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</BalloonStyle>\n" ; } setNotDirty ( ) ; return change ; }
te	4	public Tree parseCall ( final Tree callee ) { if ( poll ( kLParen ) ) { final Call result = init ( new Call ( callee ) ) ; if ( ! peek ( kRParen ) ) { parseArgumentList ( result . arguments ) ; } if ( ! poll ( kRParen ) ) { return expected ( kRParen ) ; } return result ; } else if ( peek ( kIdentifier ) ) { final Name name = parseName ( ) ; final Select select = init ( new Select ( callee , name ) ) ; final Call result = init ( new Call ( select ) ) ; result . arguments . add ( parseSingleArgument ( ) ) ; return result ; } else { return expected ( kLParen ) ; } }
te	9X	public void calculate ( String num , boolean [ ] result , int position ) { if ( position >= num . length ( ) - 2 ) { result [ position ] = false ; return ; } int size = num . length ( ) ; for ( int i = position ; i < size - 2 ; ++ i ) { if ( i > position && num . charAt ( position ) == 0 ) break ; for ( int j = i + 1 ; j < size - 1 ; ++ j ) { if ( j > i + 1 && num . charAt ( i + 1 ) == 0 ) break ; String tmp = String . valueOf ( long . valueOf ( num . substring ( position , i + 1 ) ) + long . valueOf ( num . substring ( i + 1 , j + 1 ) ) ) ; if ( tmp . length ( ) > size - 1 - j || ! num . substring ( j + 1 ) . startsWith ( tmp ) ) continue ; if ( tmp . length ( ) == size - 1 - j || result [ i + 1 ] ) { result [ position ] = true ; return ; } } } }
te	4	protected boolean in_grouping_b ( char [ ] s , int min , int max ) { if ( cursor <= limit_backward ) return false ; char ch = current . charAt ( cursor - 1 ) ; if ( ch > max || ch < min ) return false ; ch -= min ; if ( ( s [ ch >> 3 ] & ( 1 << ( ch & 7 ) ) ) == 0 ) return false ; cursor -- ; return true ; }
te	2	private static int posOfElement ( final byte element , final byte [ ] state ) { for ( int i = state . length - 1 ; i >= 0 ; -- i ) { if ( state [ i ] == element ) { return i ; } } return - 1 ; }
te	9X	public int deleteAllTriples ( String Index_DIR ) { Store store ; boolean continueAdd = true ; try { String idUrl = "<" + graphUri + "/ID#" + Index_DIR + ">" ; store = new Store ( storeUrl ) ; String sparqlQuery = "SELECT ?p ?o FROM <" + graphUri + "> WHERE { " + idUrl + " ?p ?o } " ; String result = store . query ( sparqlQuery , Store . OutputFormat . TAB_SEPARATED ) ; int i = 0 ; String predicate , object ; for ( String triple : result . split ( "\n" ) ) { if ( ! ( triple . indexOf ( "?p" ) == 0 || triple . indexOf ( "#" ) == 0 ) ) { int j = 1 ; predicate = "" ; object = "" ; for ( String component : triple . split ( "\t" ) ) { if ( j == 1 ) predicate = component . trim ( ) ; if ( j == 2 ) object = component . trim ( ) ; j ++ ; } i ++ ; String sqlDelete = "DELETE { GRAPH <" + graphUri + "> { " + idUrl + " " + predicate + " ?o } } WHERE { " + idUrl + " " + predicate + " ?o }" ; String response1 = store . update ( sqlDelete ) ; if ( response1 . indexOf ( "error" ) >= 0 ) { return 0 ; } } } return 1 ; } catch ( MalformedURLException e ) { message = e . getMessage ( ) ; return 0 ; } catch ( IOException e ) { message = e . getMessage ( ) ; return 0 ; } }
te	7	private String getBooleanString ( boolean booleanValue ) { switch ( format ) { case ONE_ZERO : return booleanValue ? "1" : "0" ; case TRUE_FALSE : return booleanValue ? "True" : "False" ; case YES_NO : return booleanValue ? "Yes" : "No" ; default : return booleanValue ? "Yes" : "No" ; } }
te	2	public static String decodeURIComponent ( String s ) { if ( s == null ) { return null ; } String result = null ; try { result = URLDecoder . decode ( s , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { result = s ; } return result ; }
te	8	private JScrollPane buildFieldsTablePanel ( ) { fieldsTable = new JTable ( new AbstractTableModel ( ) { private static final long serialVersionUID = 5347188337180793036 ; private String [ ] columnNames = new String [ ] { "Id" , "Type" , "Value" } ; public int getColumnCount ( ) { return 3 ; } public int getRowCount ( ) { try { return s3270 . getScreen ( ) . getFields ( ) . size ( ) ; } catch ( Exception e ) { return 0 ; } } @ Override public String getColumnName ( final int column ) { return columnNames [ column ] ; } public Object getValueAt ( final int rowIndex , final int columnIndex ) { if ( columnIndex == 0 ) { return rowIndex ; } Field f ; try { f = s3270 . getScreen ( ) . getFields ( ) . get ( rowIndex ) ; } catch ( Exception e ) { return "" ; } if ( columnIndex == 1 ) { return ( ( f instanceof InputField ) ? "in" : "out" ) + ( ( ( f instanceof InputField ) && ( ( InputField ) f ) . isChanged ( ) ) ? " *" : "" ) ; } if ( columnIndex == 2 ) { return "[" + f . getValue ( ) . replace (  ,   ) + "]" ; } throw new RuntimeException ( "unknown column index " + columnIndex ) ; } public boolean isCellEditable ( final int rowIndex , final int columnIndex ) { return columnIndex == 2 ; } } ) ; fieldsTable . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 25 ) ; fieldsTable . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 35 ) ; fieldsTable . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 600 ) ; final JScrollPane tableScroller = new JScrollPane ( fieldsTable ) ; return tableScroller ; }
te	1	protected void setRedoText ( String arg ) { if ( ! cmdRedo . getToolTipText ( ) . equals ( arg ) ) { cmdRedo . setToolTipText ( arg ) ; } }
te	1	@ Test public void testIsEmptyDirection ( ) { for ( Direction dir : Direction . values ( ) ) { assertFalse ( testTile . isEmpty ( dir ) ) ; } }
te	8	public AccountInfo accountInfo ( String accountName ) throws MultiCloudException , OAuth2SettingsException , InterruptedException { synchronized ( lock ) { if ( op != null ) { throw new MultiCloudException ( "Concurrent operation forbidden." ) ; } } AccountSettings account = accountManager . getAccountSettings ( accountName ) ; if ( account == null ) { throw new MultiCloudException ( "User account not found." ) ; } if ( ! account . isAuthorized ( ) ) { throw new MultiCloudException ( "User account not authorized." ) ; } CloudSettings settings = cloudManager . getCloudSettings ( account . getSettingsId ( ) ) ; if ( settings == null ) { throw new MultiCloudException ( "Cloud storage settings not found." ) ; } OAuth2Token token = credentialStore . retrieveCredential ( account . getTokenId ( ) ) ; if ( token == null ) { account . setTokenId ( null ) ; throw new MultiCloudException ( "Access token not found." ) ; } if ( token . isExpired ( ) ) { refreshAccount ( accountName , null ) ; } synchronized ( lock ) { op = new AccountInfoOp ( token , settings . getAccountInfoRequest ( ) ) ; } try { op . execute ( ) ; } catch ( MultiCloudException e ) { synchronized ( lock ) { op = null ; } throw e ; } lastError = op . getError ( ) ; if ( op . isAborted ( ) ) { synchronized ( lock ) { op = null ; } throw new AbortedException ( "Operation aborted." ) ; } AccountInfo result = ( ( AccountInfoOp ) op ) . getResult ( ) ; synchronized ( lock ) { op = null ; } return result ; }
te	3	public void write ( Kml kml ) throws KmlException { kml . println ( "<Orientation" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( heading != null ) kml . println ( "<heading>" + heading + "</heading>" ) ; if ( tilt != null ) kml . println ( "<tilt>" + tilt + "</tilt>" ) ; if ( roll != null ) kml . println ( "<roll>" + roll + "</roll>" ) ; kml . println ( - 1 , "</Orientation>" ) ; }
te	7	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CNonadItem myitem = new CNonadItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String datid = "Ndate" + myid ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) continue ; String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . nonadmid = this . makeNewId ( "nad" , 6 ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; this . addItem ( myitem . nonadmid , myitem ) ; } }
te	0	private void createAroundVertex ( Point p ) { addVertex ( p , getRandomName ( ) ) ; Point p1 = new Point ( p . x - 1 , p . y - 1 ) ; Point p2 = new Point ( p . x , p . y - 1 ) ; Point p3 = new Point ( p . x + 1 , p . y - 1 ) ; Point p4 = new Point ( p . x + 1 , p . y ) ; Point p5 = new Point ( p . x - 1 , p . y ) ; Point p6 = new Point ( p . x , p . y + 1 ) ; Point p7 = new Point ( p . x + 1 , p . y + 1 ) ; Point p8 = new Point ( p . x - 1 , p . y + 1 ) ; addVertex ( p1 , getRandomName ( ) ) ; addVertex ( p2 , getRandomName ( ) ) ; addVertex ( p3 , getRandomName ( ) ) ; addVertex ( p4 , getRandomName ( ) ) ; addVertex ( p5 , getRandomName ( ) ) ; addVertex ( p6 , getRandomName ( ) ) ; addVertex ( p7 , getRandomName ( ) ) ; addVertex ( p8 , getRandomName ( ) ) ; addEdge ( p , p1 , 1 ) ; addEdge ( p , p2 , 1 ) ; addEdge ( p , p3 , 1 ) ; addEdge ( p , p4 , 1 ) ; addEdge ( p , p5 , 1 ) ; addEdge ( p , p6 , 1 ) ; addEdge ( p , p7 , 1 ) ; addEdge ( p , p8 , 1 ) ; }
te	7	public static void validateMetadata ( OSGiMetaData metadata ) throws BundleException { NotNullException . assertValue ( metadata , "metadata" ) ; try { int manifestVersion = getBundleManifestVersion ( metadata ) ; if ( manifestVersion < 0 ) throw new BundleException ( "Cannot determine Bundle-ManifestVersion" ) ; if ( manifestVersion > 2 ) throw new BundleException ( "Unsupported Bundle-ManifestVersion: " + manifestVersion ) ; String symbolicName = metadata . getBundleSymbolicName ( ) ; if ( manifestVersion == 1 && symbolicName != null ) throw new BundleException ( "Invalid Bundle-ManifestVersion for: " + symbolicName ) ; if ( manifestVersion == 2 && symbolicName == null ) throw new BundleException ( "Cannot obtain Bundle-SymbolicName" ) ; } catch ( RuntimeException ex ) { throw new BundleException ( "Invalid OSGi metadata" , ex ) ; } }
te	7	public static DecodeResult decode ( byte [ ] buffer , int start , String encoding ) throws UnsupportedEncodingException { DecodeResult ret = new DecodeResult ( ) ; if ( start >= buffer . length ) return ret ; int pos = start ; byte c ; do { c = buffer [ pos ] ; if ( c == 58 ) { break ; } else if ( c < 48 || c > 57 ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } pos ++ ; } while ( pos < buffer . length ) ; if ( pos == start ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } int len = Integer . parseInt ( new String ( buffer , start , pos - start ) ) ; pos ++ ; if ( buffer . length < pos + len + 1 ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } ret . data = new String ( buffer , pos , len , encoding ) ; ret . end_pos = pos + len + 1 ; return ret ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new frmserie ( ) . setVisible ( true ) ; } } ) ; }
te	1	@ Override public E read ( Input input ) { switch ( enumIntType ) { case byte : return constants [ input . readByte ( ) ] ; default : return constants [ input . readShort ( ) ] ; } }
te	4	@ Override public void input ( Controls . Input type , boolean pressed ) { if ( type == Controls . Input . DEBUG && pressed && states [ type . ordinal ( ) ] == false ) { for ( int i = 0 ; i < states . length ; i ++ ) { System . out . print ( states [ i ] + " " ) ; } System . out . println ( ) ; } states [ type . ordinal ( ) ] = pressed ; }
te	2	public static WIBrowser getNewBrowser ( String urlStr ) { Requirements . notNull ( urlStr , "url" ) ; URL url = Utils . getURL ( urlStr ) ; if ( useEmbededSeleniumServer ) { if ( ! isSeleniumRunning ) { startEmbededSeleniumServer ( ) ; isSeleniumRunning = true ; } } URL baseUrl = Utils . getURL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , "" ) ; WIBrowser browser = new WIBrowser ( seleniumUrl . getHost ( ) , seleniumUrl . getPort ( ) , SELENIUM_BROWSER , baseUrl . toString ( ) ) ; browser . setTimeout ( SELENIUM_TIMEOUT ) ; browser . setShouldHighlightElement ( true ) ; browser . windowMaximize ( ) ; browser . open ( urlStr ) ; LocaleManager . autoDetect ( browser ) ; return browser ; }
te	2	public final CC grow ( float ... widthHeight ) { switch ( widthHeight . length ) { default : throw new IllegalArgumentException ( "Illegal argument count: " + widthHeight . length ) ; case 2 : growY ( widthHeight [ 1 ] ) ; case 1 : growX ( widthHeight [ 0 ] ) ; } return this ; }
te	4	public int getChoice ( ) { Turn turn = null ; int choice = - 1 ; synchronized ( lastSelected ) { needTurn = false ; turn = lastSelected ; view . enableOnly ( turn ) ; while ( squareSelected != 1 ) { try { lastSelected . wait ( ) ; } catch ( InterruptedException e ) { return - 1 ; } } squareSelected = 0 ; if ( turn . pos [ 1 ] . equals ( lastSelected . pos [ 0 ] ) ) choice = 1 ; else if ( turn . pos [ 0 ] . equals ( lastSelected . pos [ 0 ] ) ) choice = 0 ; view . enableSquares ( false ) ; } return choice ; }
te	4	public void moveup ( ) { if ( isJumping && jumpSpeed > 0 ) { if ( ! testForColisions ( 0 , - jumpSpeed / 5 ) ) { rect . y -= jumpSpeed / 5 ; jumpSpeed -= 2 ; } else jumpSpeed = 0 ; } else if ( jumpSpeed == 0 ) { jumpSpeed = defaultJumpSpeed ; isFalling = true ; isJumping = false ; } }
te	5	public Instruction [ ] getMnemonics ( String mnemonic ) { Instruction [ ] temp = new Instruction [ binCode . size ( ) ] ; int c = 0 ; for ( int j = 0 ; j < binCode . size ( ) ; j ++ ) { if ( binCode . get ( j ) . getMnemonic ( ) . equalsIgnoreCase ( mnemonic ) ) temp [ c ++ ] = binCode . get ( j ) ; } int s = 0 ; for ( int j = 0 ; j < temp . length ; j ++ ) { if ( temp [ j ] != null ) s ++ ; } Instruction [ ] i = new Instruction [ s ] ; for ( int j = 0 ; j < i . length ; j ++ ) { i [ j ] = temp [ j ] ; } return i ; }
te	7	public List < class < ? >> getHandlerList ( ) { List < class < ? >> handlerList = new ArrayList < class < ? >> ( ) ; for ( int i = 1 ; ; i ++ ) { String className = getProperty ( CONFIG_PROPERTY_APP_HANDLER_LIST + "." + i , "" ) . trim ( ) ; if ( className == null || className . isEmpty ( ) ) { break ; } try { handlerList . add ( class . forName ( className ) ) ; } catch ( ClassNotFoundException e ) { LOGGER . log ( Level . WARNING , "Handler class " + className + " not found in classpath" , e ) ; } } this . handlerCount = handlerList . size ( ) ; return handlerList ; }
te	5	public static synchronized void stop ( final boolean crash , final Exception e ) { if ( ! running ) { return ; } GameLog . info ( "Stopping Game..." , false ) ; WorldUtil . save ( Guis . world ) ; if ( ! crash || ( e == null ) ) { exit ( 0 ) ; } else if ( crash & ( e == null ) ) { GameLog . warn ( "I don't know why I crashed  but I crashed." ) ; exit ( 1 ) ; } else if ( e != null ) { GameLog . warn ( e . getMessage ( ) ) ; exit ( 1 ) ; } }
te	4	private void jsonObjectTableMouseClicked ( java . awt . event . MouseEvent evt ) { int targetRow = jsonObjectTable . getSelectedRow ( ) ; if ( evt . getClickCount ( ) == 2 && evt . getButton ( ) == MouseEvent . BUTTON1 ) { if ( targetRow >= 0 ) { int selectedRow = jsonObjectTable . convertRowIndexToModel ( targetRow ) ; String key = ( String ) jsonObjectTable . getModel ( ) . getValueAt ( selectedRow , 0 ) ; Object object = workingJSONObject . keyValues . get ( key ) ; JSONValueEditDialog . JSONValueDialogResponse returnValue = ( new JSONValueEditDialog ( JSONToolWindow . this , key , object ) ) . getReturnValue ( ) ; if ( returnValue . dialogResponse == JSONValueEditDialog . ReturnValue . SAVE ) { String newKey = returnValue . key ; Object newValue = returnValue . value ; workingJSONObject . keyValues . remove ( key ) ; putKeyValueAndRebuild ( newKey , newValue ) ; } } } }
te	4	public static void updateUtilisateur ( Utilisateur utilisateur ) { PreparedStatement stat ; try { stat = ConnexionDB . getConnection ( ) . prepareStatement ( "select * from utilisateur where id_utilisateur=?" , ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; stat . setInt ( 1 , utilisateur . getId_utilisateur ( ) ) ; ResultSet res = stat . executeQuery ( ) ; if ( res . next ( ) ) { res . updateString ( "prenom" , utilisateur . getPrenom ( ) ) ; res . updateString ( "nom" , utilisateur . getNom ( ) ) ; res . updateString ( "dateNaissance" , utilisateur . getDateNaissance ( ) ) ; res . updateString ( "adresse" , utilisateur . getAdresse ( ) ) ; res . updateString ( "codePostal" , utilisateur . getCodePostal ( ) ) ; res . updateString ( "ville" , utilisateur . getVille ( ) ) ; res . updateString ( "carteBancaire" , utilisateur . getCarteBancaire ( ) ) ; res . updateString ( "dateValiditeCarteBancaire" , utilisateur . getDateValiditeCarteBancaire ( ) ) ; res . updateString ( "rib" , utilisateur . getRib ( ) ) ; res . updateString ( "iban" , utilisateur . getIban ( ) ) ; res . updateString ( "dateCreation" , utilisateur . getDateCreation ( ) ) ; res . updateString ( "login" , utilisateur . getLogin ( ) ) ; res . updateString ( "password" , utilisateur . getPassword ( ) ) ; res . updateInt ( "fk_id_carte" , utilisateur . getFk_id_carte ( ) ) ; if ( utilisateur . getFk_id_velo ( ) == - 1 ) { res . updateNull ( "fk_id_velo" ) ; } else { res . updateInt ( "fk_id_velo" , utilisateur . getFk_id_velo ( ) ) ; } res . updateRow ( ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } }
te	5	public static int getAge ( Date f ) { Date today = new Date ( ) ; if ( today . compareTo ( f ) < 0 ) { return - 1 ; } if ( today . get ( YEAR ) == f . get ( YEAR ) ) { return 0 ; } if ( today . get ( MONTH ) > f . get ( MONTH ) ) { return today . get ( YEAR ) - f . get ( YEAR ) ; } if ( today . get ( MONTH ) == f . get ( MONTH ) && today . get ( DAYOFMONTH ) >= f . get ( DAYOFMONTH ) ) { return today . get ( YEAR ) - f . get ( YEAR ) ; } return today . get ( YEAR ) - f . get ( YEAR ) - 1 ; }
te	1	public RecordArticleStatAllTimeModel save ( RecordArticleStatAllTimeModel model ) { if ( model . getId ( ) != null ) { return updateRecordArticleStatAllTime ( model ) ; } else { return addRecordArticleStatAllTimeModel ( model ) ; } }
te	4	@ Override public int hashCode ( ) { int hash = 5 ; hash = 73 * hash + ( this . state != null ? this . state . hashCode ( ) : 0 ) ; hash = 73 * hash + ( this . city != null ? this . city . hashCode ( ) : 0 ) ; hash = 73 * hash + ( this . street != null ? this . street . hashCode ( ) : 0 ) ; hash = 73 * hash + this . house ; hash = 73 * hash + this . flat ; hash = 73 * hash + ( this . info != null ? this . info . hashCode ( ) : 0 ) ; return hash ; }
te	8	public void map ( Object key , Text value , Context context ) throws IOException , InterruptedException { Vector3d u01 = new Vector3d ( ) ; Vector3d diff02 = new Vector3d ( ) ; Vector3d nrml = new Vector3d ( ) ; Vector3d xprod = new Vector3d ( ) ; Vertex vtx0 = new Vertex ( ) ; Vertex vtx1 = new Vertex ( ) ; Vertex vtx2 = new Vertex ( ) ; double maxSqr = 0 ; Configuration conf = context . getConfiguration ( ) ; String [ ] u01S = conf . get ( "u01S" ) . split ( " " ) ; String [ ] vtx0S = conf . get ( "vtx0S" ) . split ( " " ) ; String [ ] vtx1S = conf . get ( "vtx1S" ) . split ( " " ) ; u01 . x = double . valueOf ( u01S [ 0 ] ) ; u01 . y = double . valueOf ( u01S [ 1 ] ) ; u01 . z = double . valueOf ( u01S [ 2 ] ) ; vtx0 . pnt . x = double . valueOf ( vtx0S [ 0 ] ) ; vtx0 . pnt . y = double . valueOf ( vtx0S [ 1 ] ) ; vtx0 . pnt . z = double . valueOf ( vtx0S [ 2 ] ) ; vtx1 . pnt . x = double . valueOf ( vtx1S [ 0 ] ) ; vtx1 . pnt . y = double . valueOf ( vtx1S [ 1 ] ) ; vtx1 . pnt . z = double . valueOf ( vtx1S [ 2 ] ) ; ArrayList < Vertex > PointsArr = new ArrayList < Vertex > ( ) ; String line = value . toString ( ) ; if ( line . length ( ) > 1 ) { String [ ] linesArr = line . split ( "\n" ) ; for ( int i = 0 ; i < linesArr . length ; i ++ ) { String [ ] S = linesArr [ i ] . split ( " " ) ; if ( S . length >= 3 ) { Vertex TVertex = new Vertex ( ) ; TVertex . pnt . x = double . valueOf ( S [ 0 ] ) ; TVertex . pnt . y = double . valueOf ( S [ 1 ] ) ; TVertex . pnt . z = double . valueOf ( S [ 2 ] ) ; PointsArr . add ( TVertex ) ; } } } if ( PointsArr . size ( ) > 1 ) { for ( int i = 0 ; i < PointsArr . size ( ) ; i ++ ) { diff02 . - ( PointsArr . get ( i ) . pnt , vtx0 . pnt ) ; xprod . cross ( u01 , diff02 ) ; double lenSqr = xprod . normSquared ( ) ; if ( lenSqr > maxSqr && PointsArr . get ( i ) != vtx0 && PointsArr . get ( i ) != vtx1 ) { maxSqr = lenSqr ; vtx2 = PointsArr . get ( i ) ; nrml . set ( xprod ) ; } } TKey . set ( "Reducer1" ) ; context . write ( TKey , new Text ( vtx2 . pnt . x + " " + vtx2 . pnt . y + " " + vtx2 . pnt . z ) ) ; } else { context . write ( TKey , new Text ( PointsArr . get ( 0 ) . pnt . toString ( ) ) ) ; } }
te	4	public Problem get ( final AlgorithmType type , final Puzzle puzzle ) { ColumnNode head = PuzzleConvertor . INSTANCE . convertToNetwork ( puzzle ) . head ( ) ; switch ( type ) { case NAIVE : return new NaiveDancingLinks ( head ) ; case BASIC : return new BasicDancingLinks ( head ) ; case MIN_COLUMN : return new MinColumnDancingLinks ( head ) ; case DEGREE : return new DegreeDancingLinks ( head ) ; default : throw new IllegalArgumentException ( "Algorithm type: " + type + " is unsupported." ) ; } }
te	1	@ Override public InetSocketAddress getLocalSocketAddress ( WebSocket conn ) { if ( socket != null ) return ( InetSocketAddress ) socket . getLocalSocketAddress ( ) ; return null ; }
te	0	public void setMinMwt ( float value ) { this . minMwt = value ; }
te	1	private void flushMemoryTable ( ) { changeTablesLock . lock ( ) ; try { memoryTableAccessor . useAuxiliary ( ) ; } finally { changeTablesLock . unlock ( ) ; } DiskTable diskTable ; try { MemoryTable memoryTable = memoryTableAccessor . getMainDataTable ( ) ; Path newTableFile = diskTableAccessor . newPathForTable ( ) ; Flusher flusher = new Flusher ( newTableFile , diskTableAccessor . blockSize ( ) ) ; System . out . println ( "NODE: INFO: Flushing memory table to " + newTableFile ) ; diskTable = flusher . flush ( memoryTable , memoryTable . timestamp ( ) ) ; } catch ( IOException e ) { System . out . println ( "NODE: EXCEPTION: " + e ) ; throw new RuntimeException ( e ) ; } changeTablesLock . lock ( ) ; try { diskTableAccessor . addDisk ( diskTable ) ; memoryTableAccessor . stopUsingAuxiliary ( ) ; commitLog . reset ( ) ; } finally { changeTablesLock . unlock ( ) ; } }
te	6	private void getArguments ( IGraph g ) throws Exception { Object o ; nargs = 0 ; for ( int i = 0 ; i < g . size ( ) ; i ++ ) { o = Evaluate . toScalar ( g . get ( i ) ) ; if ( o instanceof double ) argClass [ i ] = double . class ; else if ( o instanceof long ) argClass [ i ] = long . class ; else if ( o instanceof boolean ) argClass [ i ] = boolean . class ; else if ( o instanceof IGraph ) argClass [ i ] = ogdl . IGraph . class ; else argClass [ i ] = o . getClass ( ) ; argObject [ i ] = o ; nargs ++ ; } aC = new class [ nargs ] ; aO = new Object [ nargs ] ; for ( int i = 0 ; i < nargs ; i ++ ) { aC [ i ] = argClass [ i ] ; aO [ i ] = argObject [ i ] ; } }
te	5	private final ImmutableSet < ChessMovement > getPossibleMovements ( final ChessBoard board , final ChessColor turn ) { final ImmutableSet . Builder < ChessMovement > moves = ImmutableSet . builder ( ) ; for ( final ChessPiece piece : board . getAllPieces ( ) ) { if ( ! currentTurn . equals ( piece . getColor ( ) ) ) continue ; final Position from = board . getPositionFor ( piece ) ; if ( piece instanceof ChessBishop ) { for ( final Position to : ( ( ChessBishop ) piece ) . getMiniMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } else { for ( final Position to : piece . getStandardMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } } return moves . build ( ) ; }
te	3	boolean isOnBoard ( Position position ) { return 0 <= position . x && position . x < width && 0 <= position . y && position . y < height ; }
te	5	public ArrayList < long > getProblemCorrect ( long questId , long submissionId ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; ArrayList < long > questList = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Obtendo problemas corretos do questionario a partir da submiss\u00E3o: " + submissionId + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUEST_PROBLEMS ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUEST_PROBLEMS ) ; statement . setLong ( 1 , questId ) ; statement . setLong ( 2 , submissionId ) ; rs = statement . executeQuery ( ) ; while ( rs . next ( ) ) { if ( questList == null ) { questList = new ArrayList < long > ( ) ; } questList . add ( rs . getLong ( "correct_problem_id" ) ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questList ; }
te	9X	private String createExporterIDQuery ( String exporterID , String colName ) { String [ ] splitString ; int lowerBound ; int upperBound ; int expNum ; if ( exporterID == null || colName == null || exporterID . equalsIgnoreCase ( "" ) || exporterID . equalsIgnoreCase ( "*" ) ) return "" ; if ( ( splitString = exporterID . split ( "-" ) ) . length > 1 ) { if ( splitString . length == 2 ) { try { lowerBound = Integer . parseInt ( splitString [ 0 ] ) ; if ( lowerBound > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } upperBound = Integer . parseInt ( splitString [ 1 ] ) ; if ( upperBound > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } catch ( NumberFormatException e ) { output += "<p>Entered exporter Id was invalid and therefore omitted.</p><br>" ; return "" ; } return colName + " BETWEEN " + lowerBound + " AND " + upperBound ; } else { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } else { splitString = exporterID . split ( " " ) ; for ( int i = 0 ; i < splitString . length ; i ++ ) { try { expNum = Integer . parseInt ( splitString [ i ] ) ; } catch ( NumberFormatException e ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } if ( expNum > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } if ( splitString . length > 0 ) { while ( exporterID . endsWith ( " " ) ) exporterID = exporterID . substring ( 0 , exporterID . length ( ) - 1 ) ; return colName + " IN (" + exporterID + ")" ; } else { return colName + "=" + exporterID ; } } }
te	5	public void dfsIter ( String label , Function < Vertex , Vertex > action ) { boolean foundUnVisted = false ; Vertex v = getVertex ( label ) ; while ( v != null ) { foundUnVisted = false ; if ( ! v . wasVisited ( ) ) { action . apply ( v ) ; v . setVisited ( true ) ; stackVertices . push ( v ) ; } JList < Vertex > listOfAdjacent = getEdges ( mapOfVerticeIndex . get ( v . getLabel ( ) ) ) ; for ( Vertex t : listOfAdjacent ) { if ( ! t . wasVisited ( ) ) { foundUnVisted = true ; v = t ; break ; } } if ( ! foundUnVisted ) { v = stackVertices . pop ( ) ; } } }
te	5	private void generateElemXMLFile ( Document doc , Element elem ) { Element elements = doc . createElement ( "Elements" ) ; elem . appendChild ( elements ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; for ( Edge e : edges ) { Element element = doc . createElement ( "Element" ) ; elements . appendChild ( element ) ; Attr attr = doc . createAttribute ( "id" ) ; attr . setValue ( e . getNumber ( ) + "" ) ; element . setAttributeNode ( attr ) ; Element nodes = doc . createElement ( "Nodes" ) ; element . appendChild ( nodes ) ; Element node1 = doc . createElement ( "Node1" ) ; node1 . appendChild ( doc . createTextNode ( e . getNode1 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node1 ) ; Element node2 = doc . createElement ( "Node2" ) ; node2 . appendChild ( doc . createTextNode ( e . getNode2 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node2 ) ; if ( e . getPressureValue ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element pressure = doc . createElement ( "Pressure" ) ; element . appendChild ( pressure ) ; Element value = doc . createElement ( "Value" ) ; value . appendChild ( doc . createTextNode ( e . getPressureValue ( ) + "" ) ) ; element . appendChild ( value ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; pressure . appendChild ( unit ) ; i ++ ; } } if ( e . getFlowVelocity ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element fluid = doc . createElement ( "Fluid" ) ; element . appendChild ( fluid ) ; Element flow = doc . createElement ( "Velocity" ) ; flow . appendChild ( doc . createTextNode ( e . getFlowVelocity ( ) + "" ) ) ; element . appendChild ( flow ) ; Element density = doc . createElement ( "Density" ) ; density . appendChild ( doc . createTextNode ( e . getFluidDensity ( ) + "" ) ) ; element . appendChild ( density ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; fluid . appendChild ( unit ) ; i ++ ; } } } }
te	3	public void xf ( Matrix m , double x , double y , double z , double w , double v [ ] ) { if ( w == 0 ) for ( int j = 0 ; j < 3 ; j ++ ) v [ j ] = m . get ( j , 0 ) * x + m . get ( j , 1 ) * y + m . get ( j , 2 ) * z ; else for ( int j = 0 ; j < 3 ; j ++ ) v [ j ] = m . get ( j , 0 ) * x + m . get ( j , 1 ) * y + m . get ( j , 2 ) * z + m . get ( j , 3 ) ; double W = m . get ( 3 , 0 ) * x + m . get ( 3 , 1 ) * y + m . get ( 3 , 2 ) * z + m . get ( 3 , 3 ) ; v [ 0 ] /= W ; v [ 1 ] /= W ; v [ 2 ] /= W ; }
te	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
te	3	public static void main ( String [ ] args ) { BufferedReader buffer = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = 0 ; try { N = Integer . parseInt ( buffer . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "\u5B66\u4E60\u6210\u7EE9\u4E3A\uFF1A" + ( ( N < 60 ) ? "C" : ( N < 90 ) ? "B" : "A" ) ) ; }
te	6	static public String numberToString ( Number n ) throws JSONException { if ( n == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( n ) ; String s = n . toString ( ) ; if ( s . indexOf ( . ) > 0 && s . indexOf ( e ) < 0 && s . indexOf ( E ) < 0 ) { while ( s . endsWith ( "0" ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } if ( s . endsWith ( "." ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } } return s ; }
te	1	@ Override public MyDatabase getMysql ( ) { if ( client == null ) { return SgdBase . getMysql ( ) ; } else { return client . getMysql ( ) ; } }
te	5	public static int silog2Wide ( long v ) { while ( true ) { if ( v == 0 ) return 0 ; if ( v > 0 ) { int l = 0 ; while ( v != 0 ) { l ++ ; v >>= 1 ; } return l + 1 ; } if ( v == - 1 ) return 2 ; v ++ ; v = - v ; } }
te	2	private static byte [ ] constructorValueHelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
te	4	private ProgramMenuBar findMenuBar ( ) { for ( Component comp = console ; comp != null ; comp = comp . getParent ( ) ) { if ( comp instanceof Program ) { return ( ( Program ) comp ) . getMenuBar ( ) ; } else if ( comp instanceof JFrame ) { Object mbar = ( ( JFrame ) comp ) . getJMenuBar ( ) ; return ( mbar instanceof ProgramMenuBar ) ? ( ProgramMenuBar ) mbar : null ; } } return null ; }
te	6	public static void main ( String [ ] args ) { File file ; Scanner scan = null ; try { file = new File ( "workAreas.wrk" ) ; scan = new Scanner ( file ) ; HashMap < String , String > workAreaList = new HashMap < String , String > ( ) ; String area = null ; while ( scan . hasNext ( ) ) { String line = scan . nextLine ( ) ; if ( line . equals ( "" ) ) { area = null ; } else { if ( area == null ) { area = line ; } else { String [ ] split = line . replaceAll ( "[() ]" , "" ) . split ( " " ) ; for ( int i = 1 ; i < split . length ; i ++ ) { workAreaList . put ( "" + split [ 0 ] + split [ i ] , area ) ; } } } } System . out . print ( workAreaList ) ; } catch ( IOException e ) { } finally { if ( scan != null ) { scan . close ( ) ; } } }
te	4	public String exec ( String command_string , String [ ] env , byte [ ] requestBuf ) { StringBuffer display_text = new StringBuffer ( ) ; String out = "" ; try { String shell = defaultShellField . getText ( ) ; Process proc = null ; command_string = apply_macros ( command_string ) ; if ( System . getProperty ( "os.name" ) . toUpperCase ( ) . contains ( "WINDOWS" ) ) { String [ ] args = translateCommandline ( shell + " " + command_string ) ; proc = Runtime . getRuntime ( ) . exec ( args , env ) ; } else { String [ ] shell_pieces = shell . split ( "\\s+" ) ; String args [ ] = new String [ shell_pieces . length + 1 ] ; System . arraycopy ( shell_pieces , 0 , args , 0 , shell_pieces . length ) ; args [ args . length - 1 ] = command_string ; proc = Runtime . getRuntime ( ) . exec ( args , env ) ; } out = readOutput ( proc ) ; String err = readError ( proc ) ; proc . waitFor ( ) ; proc . destroy ( ) ; display_text . append ( "\n\n" + out + err ) ; appendToOutputArea ( display_text . toString ( ) ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( FourthIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( FourthIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( Exception e ) { GizmoView . log ( e . toString ( ) ) ; } return out ; }
te	5	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; }
te	5	private T createTerminalWithFeatures ( List < String > featureList ) { T result = new T ( ) ; if ( featureList == null ) return result ; String featureName , featureValue ; int namelessFeatureCounter = 1 ; String [ ] featureParts ; for ( String item : featureList ) { if ( item . equals ( "" ) ) continue ; featureParts = item . split ( FEATS_PART_SPLIT_EXPRESSION ) ; if ( featureParts . length > 1 ) { featureName = featureParts [ 0 ] ; featureValue = featureParts [ 1 ] ; } else { featureName = "other" + ( namelessFeatureCounter ++ > 1 ? "_" + namelessFeatureCounter : "" ) ; featureValue = item ; } result . setFeature ( featureName , featureValue ) ; registerFeaturevalueToFeature ( featureValue , featureName , TERMINAL_FEATURE_DOMAIN ) ; } return result ; }
te	7	public int [ ] plusOne ( int [ ] digits ) { if ( digits == null ) return null ; int carry = 0 ; for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { if ( i == digits . length - 1 ) { digits [ i ] += 1 ; } else { digits [ i ] += carry ; } if ( digits [ i ] >= 10 ) { carry = 1 ; } else { carry = 0 ; } digits [ i ] = digits [ i ] % 10 ; if ( i == 0 && carry == 1 ) { int [ ] results = new int [ digits . length + 1 ] ; results [ 0 ] = 1 ; for ( int j = 1 ; j < results . length ; j ++ ) { results [ j ] = digits [ j - 1 ] ; } return results ; } } return digits ; }
te	7	public String getPreparedContent ( String content , String inputArea ) throws InvalidInput { currentInputArea = inputArea ; String withComputed = content ; if ( content . contains ( "#[" ) ) withComputed = replaceComputed ( content ) ; String withEnumerated = withComputed ; if ( content . contains ( "#{" ) || content . contains ( "{#" ) || content . contains ( "#}" ) ) withEnumerated = replaceEnumerated ( withComputed ) ; if ( withEnumerated . contains ( "#{" ) || withEnumerated . contains ( "{#" ) || withEnumerated . contains ( "#}" ) ) Logger . warning ( "Looks like You want to have changeable values in \"" + currentInputArea + "\". " + "If it's true You use wrong syntax." ) ; return withEnumerated ; }
te	5	public void disconnected ( int id ) { String name = null ; for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == id ) { name = clients . get ( i ) . getName ( ) + " (" + id + ")" ; clients . remove ( i ) ; break ; } } if ( name == null ) { System . out . println ( "Client was not removed" ) ; return ; } for ( int i = 0 ; i < clientListModel . getSize ( ) ; i ++ ) { if ( clientListModel . elementAt ( i ) . equals ( name ) ) { clientListModel . remove ( i ) ; break ; } } }
te	7	private String convertContinentToName ( String continent ) { switch ( continent ) { case "AF" : return "Africa" ; case "AS" : return "Asia" ; case "NA" : return "North America" ; case "SA" : return "South America" ; case "OC" : return "Oceania" ; case "AN" : return "Antarctica" ; case "EU" : return "Europe" ; default : return continent ; } }
te	5	public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) System . exit ( 0 ) ; else if ( e . getKeyCode ( ) == KeyEvent . VK_UP ) { yacc = - acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) { yacc = acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) { xacc = acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) { xacc = - acc ; } }
te	4	public static int checkDuplicatesBruteForce ( int [ ] a ) { int n = a . length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { count ++ ; if ( a [ i ] == a [ j ] && i != j ) { System . out . println ( "No.of comparisons BruteForce" + count ) ; return a [ i ] ; } } } System . out . println ( "No.of comparisons BruteForce" + count ) ; return - 1 ; }
te	2	private static Object next ( Object prev , String ref ) throws JSONException { if ( prev == null ) { throw new JSONException ( "cannot traverse- missing object encountered" ) ; } if ( prev instanceof JSONObject ) { return ( ( JSONObject ) prev ) . get ( ref ) ; } throw new JSONException ( "not an object" ) ; }
te	6	private void init1 ( byte [ ] data ) throws Exception { int CRLFIndex = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == HTTP . CR && data [ i + 1 ] == HTTP . LF ) { byte temp [ ] = Arrays . copyOfRange ( data , CRLFIndex , i ) ; if ( CRLFIndex == 0 ) { parseRequestLine ( new String ( temp ) ) ; } else { parseRequestHeaderLine ( new String ( temp ) ) ; } CRLFIndex = i += 2 ; if ( data [ i ] == HTTP . CR && data [ i + 1 ] == HTTP . LF ) { int len = getContentLength ( ) ; CRLFIndex += 2 ; body = Arrays . copyOfRange ( data , CRLFIndex , CRLFIndex + len ) ; parseRequestBody ( body ) ; break ; } } } }
te	2	public String getLongVersion ( ) { if ( false == "UNKNOWN" . equals ( getName ( ) ) && false == "UNKNOWN" . equals ( getVersion ( ) ) ) { return String . format ( "<info>%s</info> version <comment>%s</comment>" , getName ( ) , getVersion ( ) ) ; } return "<info>Console Tool</info>" ; }
te	9X	public void runForecastService ( String fcserv , String fcUrl ) { Connection locconn = locconnman . getConnection ( ) ; System . out . println ( "IN RunForecastService" ) ; CTestList testlist = new CTestList ( ) ; if ( testid . equals ( CAppConsts . TagNoValue ) ) { testlist . dbReadList ( locconn , testgrpid , fc1 , fc2 ) ; } else { CTestItem otestitem = new CTestItem ( ) ; otestitem . dbReadItem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . addItem ( otestitem . makeKey ( ) , otestitem ) ; } Service service = Service . getService ( fcserv ) ; Software software = new Software ( ) ; software . setServiceUrl ( fcUrl ) ; software . setService ( service ) ; System . out . println ( "IN RunForecastService part2" ) ; try { ConnectorInterface connector = ConnectFactory . createConnecter ( software , ForecastItem . getForecastItemList ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem atestitem = ( CTestItem ) testlist . getItem ( idx ) ; atestitem . dbReadDetail ( locconn ) ; TestCase testCase = new TestCase ( ) ; System . out . println ( "IN RunForecastService part3" ) ; testCase . setEvalDate ( atestitem . basedate ) ; testCase . setPatientSex ( atestitem . gendercd ) ; testCase . setTestCaseId ( childid ) ; testCase . setPatientDob ( atestitem . birthdate ) ; List < TestEvent > testEventList = new ArrayList < TestEvent > ( ) ; CShotList shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getCount ( ) ; j ++ ) { CShotItem shot = ( CShotItem ) shotlst . getItem ( j ) ; TestEvent vac = new TestEvent ( ) ; vac . setEventDate ( shot . shotdate ) ; int vacid = Integer . parseInt ( shot . vaccinecd ) ; vac . setEvent ( Event . getEvent ( vacid ) ) ; System . out . println ( "vac= " + Event . getEvent ( vacid ) . getLabel ( ) + " " + Event . getEvent ( vacid ) . getVaccineCvx ( ) ) ; Event . getEvent ( vacid ) . setVaccineMvx ( shot . mfrcd ) ; testEventList . add ( vac ) ; } testCase . setTestEventList ( testEventList ) ; System . out . println ( "QUERY FOR FORECASTER" ) ; List < ForecastActual > forecastActualList = connector . queryForForecast ( testCase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } atestitem . dbWriteItem ( locconn ) ; if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC1 ( ) ; atestitem . dbWriteResult1 ( locconn ) ; } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC2 ( ) ; atestitem . dbWriteResult2 ( locconn ) ; } System . out . println ( ) ; if ( forecastActualList . size ( ) > 0 ) { System . out . print ( forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "runForecastService error: " , ex ) ; } locconnman . returnConnection ( locconn ) ; }
te	9X	private boolean processCommand ( StringTokenizer iData ) { char cmdSymbol = iData . nextToken ( ) . charAt ( 0 ) ; if ( ! Command . isValidCommand ( cmdSymbol ) ) { return false ; } Command cmd = Command . getCommand ( cmdSymbol ) ; switch ( cmd ) { case CREATE : int cols = Integer . parseInt ( iData . nextToken ( ) ) ; int rows = Integer . parseInt ( iData . nextToken ( ) ) ; doCreate ( rows , cols ) ; break ; case CLEAR : doClear ( ) ; break ; case COLOR : int c = Integer . parseInt ( iData . nextToken ( ) ) ; int r = Integer . parseInt ( iData . nextToken ( ) ) ; char colour = iData . nextToken ( ) . charAt ( 0 ) ; doColor ( r - 1 , c - 1 , colour ) ; break ; case VDRAW : c = Integer . parseInt ( iData . nextToken ( ) ) ; int r1 = Integer . parseInt ( iData . nextToken ( ) ) ; int r2 = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; if ( r1 > r2 ) { int t = r1 ; r1 = r2 ; r2 = t ; } doVerticalDraw ( c - 1 , r1 - 1 , r2 - 1 , colour ) ; break ; case HDRAW : int c1 = Integer . parseInt ( iData . nextToken ( ) ) ; int c2 = Integer . parseInt ( iData . nextToken ( ) ) ; r = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; if ( c1 > c2 ) { int t = c1 ; c1 = c2 ; c2 = t ; } doHorizontalDraw ( r - 1 , c1 - 1 , c2 - 1 , colour ) ; break ; case FILLRECT : c1 = Integer . parseInt ( iData . nextToken ( ) ) ; r1 = Integer . parseInt ( iData . nextToken ( ) ) ; c2 = Integer . parseInt ( iData . nextToken ( ) ) ; r2 = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; doFillRect ( r1 - 1 , c1 - 1 , r2 - 1 , c2 - 1 , colour ) ; break ; case FILLREG : c = Integer . parseInt ( iData . nextToken ( ) ) ; r = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; doFillRegion ( c - 1 , r - 1 , colour ) ; break ; case SAVE : StringBuilder name = new StringBuilder ( iData . nextToken ( ) ) ; while ( iData . hasMoreTokens ( ) ) { name . append ( iData . nextToken ( ) ) ; } doSave ( name . toString ( ) ) ; break ; case TERMINATE : { return true ; } } return false ; }
te	7	private int getCantidadFecha ( Correo correo , Date fecha ) { if ( correo . getIzquierda ( ) == null && correo . getDerecha ( ) == null ) { if ( correo . getFecha ( ) . equals ( fecha ) ) { return 1 ; } else { return 0 ; } } int n = 0 , m = 0 ; if ( correo . getDerecha ( ) != null ) { if ( correo . getDerecha ( ) . getFecha ( ) . equals ( fecha ) ) n ++ ; getCantidadFecha ( correo . getDerecha ( ) , fecha ) ; } if ( correo . getIzquierda ( ) != null ) { if ( correo . getIzquierda ( ) . getFecha ( ) . equals ( fecha ) ) m ++ ; getCantidadFecha ( correo . getIzquierda ( ) , fecha ) ; } return n + m ; }
te	1	public static RepositoryContato getInstance ( ) { if ( instance == null ) { instance = new RepositoryContato ( ) ; } return instance ; }
te	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
te	8	private ItemStack createStack ( Objective o , QuestProgress qd ) { Material m = Material . getMaterial ( o . getItemIconId ( ) ) ; if ( m == null || m == Material . AIR ) m = Material . getMaterial ( o . getType ( ) . getItemIcon ( ) ) ; if ( m == null || m == Material . AIR ) m = Material . WRITTEN_BOOK ; ItemStack ostack = new ItemStack ( m ) ; ItemMeta im = player . getServer ( ) . getItemFactory ( ) . getItemMeta ( m ) ; boolean complete = qd . isComplete ( o . getID ( ) ) ; ArrayList < String > lore = new ArrayList < String > ( ) ; String [ ] desc = o . getDescription ( ) ; for ( String s : desc ) lore . add ( s ) ; if ( o . isOptional ( ) ) { if ( desc . length > 0 ) lore . add ( "" ) ; lore . add ( ChatColor . GOLD + "" + ChatColor . ITALIC + "Optional" ) ; } if ( complete ) { String ps = o . getType ( ) . getProgressString ( o . getTarget ( ) , o . getTarget ( ) ) ; im . setDisplayName ( ChatColor . GREEN + o . getName ( ) + " " + ps ) ; lore . add ( ChatColor . YELLOW + "" + ChatColor . ITALIC + "Completed" ) ; } else { String ps = o . getType ( ) . getProgressString ( o . getTarget ( ) , qd . getProgress ( o . getID ( ) ) ) ; im . setDisplayName ( ChatColor . YELLOW + o . getName ( ) + " " + ps ) ; } im . setLore ( lore ) ; ostack . setItemMeta ( im ) ; return ostack ; }
te	9X	public AbstractHttpData ( String name , Charset charset , long size ) throws NullPointerException , IllegalArgumentException { if ( name == null ) { throw new NullPointerException ( "name" ) ; } name = name . trim ( ) ; if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "empty name" ) ; } for ( int i = 0 ; i < name . length ( ) ; i ++ ) { char c = name . charAt ( i ) ; if ( c > 127 ) { throw new IllegalArgumentException ( "name contains non-ascii character: " + name ) ; } switch ( c ) { case = : case   : case ; : case   : case 	 : case '' : case '' : case  : case 0b : throw new IllegalArgumentException ( "name contains one of the following prohibited characters: " + "= ; \\t\\r\\n\\v\\f: " + name ) ; } } this . name = name ; if ( charset != null ) { setCharset ( charset ) ; } definedSize = size ; }
te	6	private void printUpgradeTowerDef ( Graphics g ) { gui . print ( g , selectedTowerDef . name , TEXT_HEIGHT_1 ) ; gui . print ( g , "upgrade cost: " + selectedTowerDef . cost , TEXT_HEIGHT_1 ) ; gui . print ( g , "level  : " + selectedTowerDef . level , TEXT_HEIGHT_1 ) ; gui . print ( g , "damage : " + getComparingString ( selectedTowerDef . damage , selectedTower . def . damage ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "area   : " + getComparingString ( selectedTowerDef . damageRadius , selectedTower . def . damageRadius ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "range  : " + getComparingString ( selectedTowerDef . range , selectedTower . def . range ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "reload : " + getComparingString ( selectedTowerDef . reloadTime , selectedTower . def . reloadTime ) , TEXT_HEIGHT_1 ) ; if ( selectedTower . def . instantEffects . length + selectedTower . def . timedEffects . length > 0 ) { gui . print ( g , "old effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTower . def . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTower . def . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } if ( selectedTowerDef . instantEffects . length + selectedTowerDef . timedEffects . length > 0 ) { gui . print ( g , "new effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTowerDef . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTowerDef . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } }
te	4	@ Override public String toString ( ) { switch ( type ) { case BLANK_ENGLISH : return "blank english" ; case BLANK_LOCAL : return "blank local" ; case EQUAL : return "equal" ; case DIFFERENT : default : return "different" ; } }
te	9X	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; if ( this . iconStyle != null && this . iconStyle . isDirty ( ) ) { this . iconStyle . setRecursiveNotDirty ( ) ; } if ( this . labelStyle != null && this . labelStyle . isDirty ( ) ) { this . labelStyle . setRecursiveNotDirty ( ) ; } if ( this . lineStyle != null && this . lineStyle . isDirty ( ) ) { this . lineStyle . setRecursiveNotDirty ( ) ; } if ( this . polyStyle != null && this . polyStyle . isDirty ( ) ) { this . polyStyle . setRecursiveNotDirty ( ) ; } if ( this . balloonStyle != null && this . balloonStyle . isDirty ( ) ) { this . balloonStyle . setRecursiveNotDirty ( ) ; } if ( this . listStyle != null && this . listStyle . isDirty ( ) ) { this . listStyle . setRecursiveNotDirty ( ) ; } }
te	5	private void init ( PipedWriter inputStart ) throws IOException { logger . info ( "init pipe" ) ; if ( ! stages . isEmpty ( ) ) { stages . removeAll ( stages ) ; } stages . add ( new Filter ( new PipedReader ( inputStart ) , new PipedWriter ( ) ) ) ; stages . add ( new CaseFolding ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; if ( ApplicationSetup . getInstance ( ) . getUseStopwords ( ) ) { stages . add ( new StopWordRemoval ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } if ( ApplicationSetup . getInstance ( ) . getUseStemmer ( ) ) { stages . add ( new Stemming ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } pool = Executors . newFixedThreadPool ( stages . size ( ) + 1 ) ; AbstractPipeStage stage ; for ( int i = 0 ; i < stages . size ( ) ; i ++ ) { stage = stages . get ( i ) ; if ( i == 0 ) { stage . setWaitingFor ( stages . get ( stages . size ( ) - 1 ) ) ; } else { stage . setWaitingFor ( stages . get ( i - 1 ) ) ; } pool . execute ( stage ) ; } }
te	0	@ Override public void mouseMoved ( MouseEvent e ) { updateWidgets ( e ) ; }
te	1	private void jButton4ActionPerformed ( java . awt . event . ActionEvent evt ) { ReporteEncuestas r = new ReporteEncuestas ( ) ; try { r . mostrarReporte ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "Ocurrio un error.. " + e . getMessage ( ) ) ; } }
te	2	public void buildExampleTexProject ( File dir , String packageName ) throws IOException { if ( packageName == null ) packageName = mFamilyName ; Map < TexFontBuilder , String > nameMap = doBuildTypefacePackage ( dir , packageName ) ; File texFile = new File ( dir , "example.tex" ) ; PrintWriter out = new PrintWriter ( texFile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packageName ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{Gulliver's Travels}" ) ; out . println ( "\\author{Jonathan Swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "The first request I made  after I had obtained my liberty  was  that I might have license " + "to see Mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. The people had notice  by " + "proclamation  of my design to visit the town. The wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. I stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. I walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. The garret windows and tops of houses were so crowded with spectators  that I thought " + "in all my travels I had not seen a more populous place. The city is an exact square  each side of the " + "wall being five hundred feet long. The two great streets  which run across and divide it into four " + "quarters  are five feet wide. The lanes and alleys  which I could not enter  but only view them as " + "I passed  are from twelve to eighteen inches. The town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{The emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " It is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. I had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  I could easily view it on every side. The outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which I was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. Now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. At the same time the emperor had a great desire that I should see the magnificence of his " + "palace; but this I was not able to do till three days after  which I spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "Of these trees I made two stools  each about three feet high  and strong enough to bear my weight. " + "The people having received notice a second time  I went again through the city to the palace with " + "my two stools in my hands. When I came to the side of the outer court  I stood upon one stool  and " + "took the other in my hand; this I lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. I then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "By this contrivance I got into the inmost court; and  lying down upon my side  I applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. There I saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. Her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( String name : nameMap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
te	2	public static synchronized Singleton getInstance ( ) { if ( uniqueInstance == null ) { synchronized ( Singleton . class ) { if ( uniqueInstance == null ) { uniqueInstance = new Singleton ( ) ; } } } return uniqueInstance ; }
te	3	@ Override public void mouseClicked ( MouseEvent e ) { JTable table = ( JTable ) e . getSource ( ) ; Point pt = e . getPoint ( ) ; int ccol = table . columnAtPoint ( pt ) ; if ( isURLColumn ( table , ccol ) ) { int crow = table . rowAtPoint ( pt ) ; URL url = ( URL ) table . getValueAt ( crow , ccol ) ; System . out . println ( url ) ; try { if ( Desktop . isDesktopSupported ( ) ) { Desktop . getDesktop ( ) . browse ( url . toURI ( ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }
te	9X	@ SuppressWarnings ( "deprecation" ) @ Override public void run ( ) { while ( areAnyThreadsAlive ( threadGroup ) ) { if ( ! firstExceptionThrown . isEmpty ( ) ) { for ( Thread t : getThreads ( threadGroup ) ) { if ( t . isAlive ( ) ) t . stop ( ) ; } } else if ( areAnyThreadsRunning ( threadGroup ) ) { if ( System . currentTimeMillis ( ) - lastProgress > 1000 * maxRunTime ) timeout ( ) ; } else if ( clock . isAnyThreadWaitingForABeat ( ) ) { clock . advance ( ) ; deadlockCount = 0 ; lastProgress = System . currentTimeMillis ( ) ; } else if ( ! areAnyThreadsInTimedWaiting ( threadGroup ) ) { detectDeadlock ( ) ; } try { Thread . sleep ( clockPeriod ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
te	4	@ Override public boolean isEmpty ( ) { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . lock ( ) ; } try { for ( MapSegment < K , V > mapSegment : mapSegments ) { if ( ! mapSegment . isEmpty ( ) ) return false ; } return true ; } finally { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . unlock ( ) ; } } }
te	7	public Integer getFeriadosOrdinarios ( Integer mes , Integer ano ) { Integer diaSemanaComecaMes = this . diasDaSemana ( mes , ano ) ; Map < Integer , Integer > dias = new HashMap < Integer , Integer > ( ) ; dias . put ( 1 , 9 ) ; dias . put ( 2 , 8 ) ; dias . put ( 3 , 8 ) ; dias . put ( 4 , 8 ) ; dias . put ( 5 , 9 ) ; dias . put ( 6 , 10 ) ; dias . put ( 7 , 10 ) ; Integer qtdeFeriadosOrdinarios = dias . get ( diaSemanaComecaMes ) ; if ( ( diaSemanaComecaMes == 5 ) || ( diaSemanaComecaMes == 6 ) ) qtdeFeriadosOrdinarios = qtdeFeriadosOrdinarios - 1 ; if ( ( mes == 2 ) ) { qtdeFeriadosOrdinarios = 8 ; } else if ( ( mes == 2 ) && ( this . RetornarBisexto ( ano ) == true ) ) { if ( ( dias . get ( diaSemanaComecaMes ) == 1 ) || ( dias . get ( diaSemanaComecaMes ) == 7 ) ) { qtdeFeriadosOrdinarios = qtdeFeriadosOrdinarios + 1 ; } } return qtdeFeriadosOrdinarios ; }
te	9X	@ Override public Object instantiate ( class < ? > clazz , CreationMode mode ) { Objects . requireNonNull ( clazz ) ; switch ( clazz . toString ( ) ) { case "byte" : return ( byte ) ( RND . nextInt ( byte . MAX_VALUE ) & FF ) ; case "short" : return ( short ) ( RND . nextInt ( short . MAX_VALUE ) & FFFF ) ; case "int" : return RND . nextInt ( MAX_INT ) ; case "long" : return RND . nextLong ( ) ; case "float" : return RND . nextFloat ( ) ; case "double" : return RND . nextDouble ( ) ; case "char" : char ch = 0 ; do { ch = ( char ) ( A + RND . nextInt ( z - A + 1 ) ) ; } while ( ch > Z && ch < a ) ; return ch ; case "boolean" : return RND . nextBoolean ( ) ; default : System . err . println ( "Unknown primitive type. Please check" ) ; return null ; } }
te	0	public boolean hasStart ( ) { return ( ( bitField0_ & 00000001 ) == 00000001 ) ; }
te	1	public Color getTabUnselectedColor ( ) { return ( blackTabbedPaneUI . colorUnSel == null ) ? new Color ( 192 , 192 , 192 ) : blackTabbedPaneUI . colorUnSel ; }
te	9X	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { int rpp ; if ( request . getParameter ( "rpp" ) == null ) { rpp = 10 ; } else { rpp = Integer . parseInt ( request . getParameter ( "rpp" ) ) ; } ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } HashMap < String , String > hmOrder = new HashMap < > ( ) ; if ( request . getParameter ( "order" ) != null ) { if ( request . getParameter ( "ordervalue" ) != null ) { hmOrder . put ( request . getParameter ( "order" ) , request . getParameter ( "ordervalue" ) ) ; } else { hmOrder = null ; } } else { hmOrder = null ; } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getPages ( rpp , alFilter , hmOrder ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetpagesJson: View Error: " + e . getMessage ( ) ) ; } }
te	8	@ Override public LayoutManager convertLayoutElement ( Element elm ) { double [ ] [ ] args = new double [ 2 ] [ 0 ] ; if ( elm . hasAttribute ( "cols" ) ) { String cols = elm . getAttribute ( "cols" ) . toLowerCase ( ) . trim ( ) ; cols = cols . replaceAll ( "(tablelayout\\.)?fill" , String . valueOf ( TableLayout . FILL ) ) ; cols = cols . replaceAll ( "(tablelayout\\.)?preferred" , String . valueOf ( TableLayout . PREFERRED ) ) ; if ( cols . matches ( "\\{.*\\}" ) ) { cols = cols . substring ( 1 , cols . length ( ) - 1 ) ; } String [ ] x ; if ( cols . matches ( numberRegex + "(\\s* \\s*" + numberRegex + ")*" ) ) { x = cols . split ( "\\s* \\s*" ) ; } else { x = cols . split ( "\\s+" ) ; } args [ 0 ] = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { args [ 0 ] [ i ] = double . valueOf ( x [ i ] ) ; } } if ( elm . hasAttribute ( "rows" ) ) { String rows = elm . getAttribute ( "rows" ) . toLowerCase ( ) . trim ( ) ; rows = rows . replaceAll ( "(tablelayout\\.)?fill" , String . valueOf ( TableLayout . FILL ) ) ; rows = rows . replaceAll ( "(tablelayout\\.)?preferred" , String . valueOf ( TableLayout . PREFERRED ) ) ; if ( rows . matches ( "\\{.*\\}" ) ) { rows = rows . substring ( 1 , rows . length ( ) - 1 ) ; } String [ ] y ; if ( rows . matches ( numberRegex + "(\\s* \\s*" + numberRegex + ")*" ) ) { y = rows . split ( "\\s* \\s*" ) ; } else { y = rows . split ( "\\s+" ) ; } args [ 1 ] = new double [ y . length ] ; for ( int i = 0 ; i < y . length ; i ++ ) { args [ 1 ] [ i ] = double . valueOf ( y [ i ] ) ; } } return new TableLayout ( args ) ; }
te	0	public Kill ( Point killed , int prio ) { super ( prio ) ; killedEntity = killed ; }
te	6	List < Constraint > removePropagateFrom ( Variable out ) { out . determinedBy = null ; out . walkStrength = WEAKEST ; out . stay = true ; List < Constraint > unsatisfied = new ArrayList < Constraint > ( ) ; List < Variable > todo = new ArrayList < Variable > ( ) ; todo . add ( out ) ; while ( todo . size ( ) > 0 ) { Variable v = todo . remove ( todo . size ( ) - 1 ) ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint c = v . constraints . get ( i ) ; if ( ! c . isSatisfied ( ) ) unsatisfied . add ( c ) ; } Constraint determining = v . determinedBy ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint next = v . constraints . get ( i ) ; if ( next != determining && next . isSatisfied ( ) ) { next . recalculate ( ) ; todo . add ( next . output ( ) ) ; } } } return unsatisfied ; }
te	0	public void setDescompte ( float descompte ) { this . descompte = descompte ; }
te	9X	private void generateProblems ( StringBuilder builder , BookSettings settings , Map < String , List < String >> cached ) { int maxProblemColumns = settings . getProblemColumns ( ) ; int maxProblemRows = settings . getProblemRows ( ) ; int maxAnswerColumns = settings . getAnswerColumns ( ) ; int maxAnswerRows = settings . getAnswerRows ( ) ; for ( BookSettings . BookSection section : settings . getSections ( ) ) { StringBuilder problemPage = new StringBuilder ( ) ; StringBuilder problemRow = new StringBuilder ( ) ; StringBuilder problemRowComments = new StringBuilder ( ) ; StringBuilder answerPagesBuffer = new StringBuilder ( ) ; StringBuilder answerPage = new StringBuilder ( ) ; StringBuilder answerRow = new StringBuilder ( ) ; StringBuilder answerRowComments = new StringBuilder ( ) ; if ( section . getHeader ( ) != null ) { problemPage . append ( generateSubHeader ( section . getHeader ( ) ) ) ; answerPage . append ( generateSubHeader ( "Answers" , true ) ) ; } startPage ( problemPage , maxProblemColumns ) ; startPage ( answerPage , maxAnswerColumns ) ; int curProblemColumn = 0 ; int curProblemRow = 0 ; int curAnswerColumn = 0 ; int curAnswerRow = 0 ; int numAnswers = 0 ; int numProblems = 0 ; int totalNumProblems = 1 ; for ( String sgf : section . getProblems ( ) ) { List < String > generated = cached . get ( sgf ) ; String problem = generated . get ( 0 ) ; includeGraphics ( problemRow , problem ) ; addTableCell ( problemRow , curProblemColumn , maxProblemColumns ) ; includeComments ( problemRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( problem ) , totalNumProblems ) ) ; addTableCell ( problemRowComments , curProblemColumn , maxProblemColumns ) ; if ( curProblemColumn == maxProblemColumns - 1 ) { problemPage . append ( problemRow ) . append ( problemRowComments ) ; problemRow = new StringBuilder ( ) ; problemRowComments = new StringBuilder ( ) ; } curProblemColumn = ( curProblemColumn + 1 ) % maxProblemColumns ; numProblems ++ ; for ( int i = 1 ; i <= settings . getVarsPerProblem ( ) && i < generated . size ( ) ; i ++ ) { String answer = generated . get ( i ) ; includeGraphics ( answerRow , answer ) ; addTableCell ( answerRow , curAnswerColumn , maxAnswerColumns ) ; includeComments ( answerRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( answer ) , totalNumProblems ) ) ; addTableCell ( answerRowComments , curAnswerColumn , maxAnswerColumns ) ; if ( curAnswerColumn == maxAnswerColumns - 1 ) { answerPage . append ( answerRow ) . append ( answerRowComments ) ; answerRow = new StringBuilder ( ) ; answerRowComments = new StringBuilder ( ) ; } curAnswerColumn = ( curAnswerColumn + 1 ) % maxAnswerColumns ; numAnswers ++ ; if ( numAnswers == maxAnswerRows * maxAnswerColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; answerPage = startNewPage ( maxAnswerColumns ) ; numAnswers = 0 ; } } totalNumProblems ++ ; if ( numProblems == maxProblemRows * maxProblemColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; finishPageWithTrailer ( builder , problemPage ) ; finishPage ( builder , answerPagesBuffer ) ; answerPage = startNewPage ( maxAnswerColumns ) ; problemPage = startNewPage ( maxProblemColumns ) ; answerPagesBuffer = new StringBuilder ( ) ; numProblems = 0 ; numAnswers = 0 ; } } if ( answerPage . length ( ) != 0 ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; } if ( problemPage . length ( ) != 0 ) { finishPageWithTrailer ( builder , problemPage ) ; } finishPage ( builder , answerPagesBuffer ) ; } }
te	6	public String getPosition ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "line " ) . append ( lineNumber ) . append ( "  char " ) . append ( charNumber ) ; buffer . append ( ": ..." ) ; StringBuffer line = new StringBuffer ( ) ; int count = 0 ; int start = index ; while ( count ++ < charNumber ) { if ( start -- == 0 ) { start = BUFFER_SIZE - 1 ; } if ( ( history [ start ] == '' ) || ( start == index ) ) { break ; } line . append ( ( char ) history [ start ] ) ; } buffer . append ( line . reverse ( ) ) ; buffer . append ( " next char: " ) ; try { if ( ! eof ( ) ) { buffer . append ( "'" + ( char ) peek ( ) + "'" ) ; } else { buffer . append ( "EOF" ) ; } } catch ( IOException ioe ) { buffer . append ( "ERROR: " + ioe . getMessage ( ) ) ; } return buffer . toString ( ) ; }
te	0	public AcademyFacadeDB ( ) { emf = Persistence . createEntityManagerFactory ( "ServerSidePU" ) ; em = emf . createEntityManager ( ) ; addToDatabase ( ) ; }
te	3	@ Override public PoolEntry < T > borrowEntry ( boolean createNew , long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException , PoolException { try { if ( config . isWaitUnlimitOnBorrow ( ) ) { borrowingSemaphore . acquire ( ) ; } else { boolean acquireSuccess = borrowingSemaphore . tryAcquire ( timeout , unit ) ; if ( ! acquireSuccess ) { throw new TimeoutException ( "borrowEntry timed out." ) ; } } } catch ( InterruptedException e ) { throw e ; } return innerBorrowEntry ( createNew ) ; }
te	7	protected String [ ] [ ] create_matrix ( String plain ) { ArrayList < String > s = new ArrayList < String > ( ) ; boolean dig ; if ( di_begin ) { dig = true ; } else { dig = false ; } int string_index = 0 ; int plain_size = plain . length ( ) ; while ( string_index < plain_size ) { if ( dig ) { if ( string_index == plain_size - 1 ) { s . add ( plain . substring ( string_index , string_index + 1 ) ) ; string_index ++ ; } else { s . add ( plain . substring ( string_index , string_index + 2 ) ) ; string_index += 2 ; } dig = false ; } else { s . add ( plain . substring ( string_index , string_index + 1 ) ) ; string_index ++ ; dig = true ; } } int col = period ; int row = s . size ( ) / col ; if ( s . size ( ) % col != 0 ) { row ++ ; } String [ ] [ ] matrix = new String [ row ] [ col ] ; int s_index = 0 ; int cur_row = 0 ; int cur_col = 0 ; while ( s_index < s . size ( ) ) { matrix [ cur_row ] [ cur_col ] = s . get ( s_index ) ; s_index ++ ; if ( cur_col < period - 1 ) { cur_col ++ ; } else { cur_row ++ ; cur_col = 0 ; } } return matrix ; }
te	5	public void handlePorterCommand ( Command command ) { System . out . println ( "handlePorterCommand" ) ; if ( command instanceof CreateGame ) { handlePorterCommand ( ( CreateGame ) command ) ; } if ( command instanceof JoinGame ) { handlePorterCommand ( ( JoinGame ) command ) ; } if ( command instanceof LeaveGame ) { handlePorterCommand ( ( LeaveGame ) command ) ; } if ( command instanceof GetGames ) { handlePorterCommand ( ( GetGames ) command ) ; } if ( command instanceof PlaceDisc ) { handlePorterCommand ( ( PlaceDisc ) command ) ; } }
te	2	private byte [ ] toBytes ( int v , int length ) { assert length % 4 == 0 ; assert length > 0 ; byte [ ] result = new byte [ length ] ; result [ 0 ] = ( byte ) ( v & FF ) ; result [ 1 ] = ( byte ) ( v >>> 8 & FF ) ; result [ 2 ] = ( byte ) ( v >>> 16 & FF ) ; result [ 3 ] = ( byte ) ( v >>> 24 & FF ) ; for ( int i = 4 ; i < length ; ) { int copyLength = i <= length / 2 ? i : length - i ; System . arraycopy ( result , 0 , result , i , copyLength ) ; i += copyLength ; } return result ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { ClientController client = new ClientController ( ) ; new FishMainFrame ( ) . setVisible ( true ) ; } } ) ; }
te	5	private ActionListener createInviteListener ( ) { return new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { PeerStatus status = LocalInfo . getPeerStatus ( ) ; if ( ! ( status == PeerStatus . STARTER || status == PeerStatus . INVITEE ) ) { JOptionPane . showMessageDialog ( frame , "You have no authority to do that" ) ; return ; } String ipPort = JOptionPane . showInputDialog ( "Please input ip:port" ) ; if ( ipPort == null ) return ; String [ ] strs = ipPort . split ( ":" ) ; if ( strs . length != 2 ) { JOptionPane . showMessageDialog ( null , "Invalid Format of Ip and Port" , "Error!" , JOptionPane . ERROR_MESSAGE ) ; return ; } try { LocalSender . sendInvitationMsg ( strs [ 0 ] , Integer . parseInt ( strs [ 1 ] ) , Event . INVITATION ) ; System . out . println ( "Invite server to network: " + strs [ 0 ] + ":" + strs [ 1 ] ) ; } catch ( Exception exception ) { exception . printStackTrace ( ) ; } } } ; }
te	9X	public static void sprstp ( int [ ] sa , int [ ] ija , double [ ] sb , int [ ] ijb ) throws NRException { int j , jl , jm , jp , ju , k , m , n2 , noff , inc , iv ; double v ; n2 = ija [ 0 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) sb [ j ] = sa [ j ] ; int [ ] ija_vec = nfill ( ija [ n2 ] , ija [ n2 - 1 ] - ija [ 0 ] ) ; int [ ] ijb_vec = new int [ ija [ n2 - 1 ] - ija [ 0 ] ] ; indexx ( ija_vec , ijb_vec ) ; for ( j = n2 , k = 0 ; j < ija [ n2 - 1 ] ; j ++ , k ++ ) { ijb [ j ] = ijb_vec [ k ] ; } jp = 0 ; for ( k = ija [ 0 ] ; k < ija [ n2 - 1 ] ; k ++ ) { m = ijb [ k ] + n2 ; sb [ k ] = sa [ m ] ; for ( j = jp ; j < ija [ m ] + 1 ; j ++ ) ijb [ j ] = k ; jp = ija [ m ] + 1 ; jl = 0 ; ju = n2 - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) / 2 ; if ( ija [ jm ] > m ) ju = jm ; else jl = jm ; } ijb [ k ] = jl ; } for ( j = jp ; j < n2 ; j ++ ) ijb [ j ] = ija [ n2 - 1 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) { jl = ijb [ j + 1 ] - ijb [ j ] ; noff = ijb [ j ] ; inc = 1 ; do { inc *= 3 ; inc ++ ; } while ( inc <= jl ) ; do { inc /= 3 ; for ( k = noff + inc ; k < noff + jl ; k ++ ) { iv = ijb [ k ] ; v = sb [ k ] ; m = k ; while ( ijb [ m - inc ] > iv ) { ijb [ m ] = ijb [ m - inc ] ; sb [ m ] = sb [ m - inc ] ; m -= inc ; if ( m - noff + 1 <= inc ) break ; } ijb [ m ] = iv ; sb [ m ] = v ; } } while ( inc > 1 ) ; } }
te	2	public void seek_notify ( ) { frame_start = 0 ; for ( int ch = 0 ; ch < 2 ; ch ++ ) for ( int j = 0 ; j < 576 ; j ++ ) prevblck [ ch ] [ j ] = 0.0f ; br = new BitReserve ( ) ; }
te	6	protected Node parseRest ( boolean first ) { Token t = scanner . getNextToken ( ) ; Node exp = null ; if ( t == null ) { exp = null ; } else if ( t . getType ( ) == TokenType . ) ) { if ( first ) return nil ; else return null ; } else if ( t . getType ( ) == TokenType . . ) { t = scanner . getNextToken ( ) ; if ( t . getType ( ) != TokenType . ) ) { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , null ) ; if ( scanner . getNextToken ( ) . getType ( ) != TokenType . ) ) System . out . println ( "Invalid use of ." ) ; else ( ( Cons ) exp ) . setVararg ( ) ; } else { System . out . println ( "unexpected: ')'" ) ; exp = parseExp ( ) ; } } else { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , parseRest ( false ) ) ; } return exp ; }
te	9X	public final void keyReleased ( KeyEvent keyevent ) { idleTime = 0 ; int i = keyevent . getKeyCode ( ) ; char c = keyevent . getKeyChar ( ) ; if ( c <  ) c =  ; if ( i == 37 ) c =  ; if ( i == 39 ) c =  ; if ( i == 38 ) c =  ; if ( i == 40 ) c =  ; if ( i == 17 ) c =  ; if ( i == 8 ) c =  ; if ( i == 127 ) c =  ; if ( i == 9 ) c = 	 ; if ( i == 10 ) c = '' ; if ( c > 0 && c <  ) keyArray [ c ] = 0 ; }
te	4	private static State atLeast ( String x , int n , Collection < State > initials , boolean zeros ) { State s = new State ( ) ; if ( x . length ( ) == n ) s . setAccept ( true ) ; else { if ( zeros ) initials . add ( s ) ; char c = x . charAt ( n ) ; s . addTransition ( new Transition ( c , atLeast ( x , n + 1 , initials , zeros && c == 0 ) ) ) ; if ( c < 9 ) s . addTransition ( new Transition ( ( char ) ( c + 1 ) , 9 , anyOfRightLength ( x , n + 1 ) ) ) ; } return s ; }
te	0	@ Override public < S , T > T visit ( SMPLVisitor < S , T > visitor , S state ) { return visitor . visitCarExp ( this , state ) ; }
te	7	public static void readHash3 ( String type_map , HashMap < String , double > hashMap ) { ArrayList < String > types = new ArrayList < String > ( ) ; ArrayList < String > tokens = new ArrayList < String > ( ) ; if ( type_map != null ) { FileUtil . readLines ( type_map , types ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { if ( ! types . get ( i ) . isEmpty ( ) ) { ComUtil . tokenize ( types . get ( i ) , tokens ) ; if ( tokens . size ( ) != 0 ) { if ( tokens . size ( ) != 2 ) { for ( int j = 0 ; j < tokens . size ( ) ; j ++ ) { System . out . print ( tokens . get ( j ) + " " ) ; } System . err . println ( type_map + " Error ! Not two elements in one line !" ) ; return ; } if ( ! hashMap . containsKey ( tokens . get ( 0 ) ) ) hashMap . put ( tokens . get ( 0 ) , new double ( tokens . get ( 1 ) ) ) ; else { System . out . println ( tokens . get ( 0 ) + " " + tokens . get ( 1 ) ) ; System . err . println ( type_map + " Error ! Same type in first column !" ) ; return ; } } tokens . clear ( ) ; } } } }
te	3	@ Override public int corpusTermFrequency ( String term ) { int count = 0 ; HashMap < Integer , ArrayList < Integer >> docMap = null ; if ( term . contains ( " " ) ) { docMap = getPhraseDocMap ( term ) ; } else { if ( ! _dictionary . containsKey ( term ) ) return 0 ; int idx = _dictionary . get ( term ) ; docMap = getDocMap ( idx ) ; } Set < Integer > keySet = docMap . keySet ( ) ; for ( Integer key : keySet ) { count += docMap . get ( key ) . size ( ) ; } return count ; }
te	2	private static boolean canPut ( Pos pos , List < Pos > queens ) { for ( Pos queen : queens ) { if ( ! canPut ( pos , queen ) ) { return false ; } } return true ; }
te	6	void portNumberKeyReleased ( KeyEvent e ) { if ( client . getCommunicator ( ) != null ) { popUpWindow dialog = new popUpWindow ( this , "Wollen Sie sich wirklich vom Server abmelden ?" ) ; if ( dialog . getResult ( ) ) { client . disconnect ( ) ; } } if ( client . getCommunicator ( ) == null ) { isPortOk = ( portNumber . getText ( ) . length ( ) > 0 ) ; if ( isGameLoaded && isServerOk && isPortOk ) { connectToServer . setEnabled ( true ) ; } else { connectToServer . setEnabled ( false ) ; } } else { portNumber . setText ( client . getPort ( ) + "" ) ; } }
te	3	public Item useItem ( ) { if ( objectType [ selectedItem ] . isPlacable ( ) ) { if ( objectNumber [ selectedItem ] >= 1 ) { objectNumber [ selectedItem ] -- ; if ( objectNumber [ selectedItem ] == 0 ) { Item tmp = objectType [ selectedItem ] ; objectType [ selectedItem ] = noItem ; return tmp ; } } return objectType [ selectedItem ] ; } return noItem ; }
te	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Demo other = ( Demo ) obj ; if ( ! getOuterType ( ) . equals ( other . getOuterType ( ) ) ) return false ; if ( method == null ) { if ( other . method != null ) return false ; } else if ( ! method . equals ( other . method ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; return true ; }
te	5	public static double [ ] decode ( String geohash ) { StringBuilder buffer = new StringBuilder ( ) ; for ( char c : geohash . toCharArray ( ) ) { int i = lookup . get ( c ) + 32 ; buffer . append ( Integer . toString ( i , 2 ) . substring ( 1 ) ) ; } BitSet lonset = new BitSet ( ) ; BitSet latset = new BitSet ( ) ; int j = 0 ; for ( int i = 0 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; lonset . set ( j ++ , isSet ) ; } j = 0 ; for ( int i = 1 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; latset . set ( j ++ , isSet ) ; } double lon = decode ( lonset , - 180 , 180 ) ; double lat = decode ( latset , - 90 , 90 ) ; return new double [ ] { lat , lon } ; }
te	4	public static Chromosome [ ] cross ( Chromosome parent1 , Chromosome parent2 , float mutationRate , int crossOverIndex ) { Chromosome p [ ] = new Chromosome [ ] { parent1 , parent2 } ; final int c1 = Math . abs ( rnd . nextInt ( ) ) % 2 ; final int c2 = ( c1 + 1 ) % 2 ; Chromosome c [ ] = new Chromosome [ ] { new Chromosome ( p [ 0 ] . useDivisor ) , new Chromosome ( p [ 0 ] . useDivisor ) } ; c [ c1 ] . score = p [ c1 ] . score * ( double ) crossOverIndex / ( double ) c [ c1 ] . g . length + p [ c2 ] . score * ( double ) ( c [ c1 ] . g . length - crossOverIndex ) / ( double ) c [ c1 ] . g . length ; c [ c2 ] . score = p [ c2 ] . score * ( double ) crossOverIndex / ( double ) c [ c1 ] . g . length + p [ c1 ] . score * ( double ) ( c [ c1 ] . g . length - crossOverIndex ) / ( double ) c [ c1 ] . g . length ; int p1 = c1 , p2 = c2 ; for ( int i = 0 ; i < p [ c1 ] . g . length ; i ++ ) { if ( i == crossOverIndex ) { p1 = c2 ; p2 = c1 ; } if ( rnd . nextFloat ( ) < mutationRate ) { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] * ( 1f + ( float ) rnd . nextGaussian ( ) ) ; } else { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] ; } if ( rnd . nextFloat ( ) < mutationRate ) { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] * ( 1f + ( float ) rnd . nextGaussian ( ) ) ; } else { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] ; } } return c ; }
te	4	public void mouseDragged ( MouseEvent e ) { if ( e . getX ( ) < 0 || e . getY ( ) < 0 || e . getX ( ) > this . getWidth ( ) || e . getY ( ) > this . getHeight ( ) ) return ; previousMouseCoords = currentMouseCoords ; currentMouseCoords = convertMouseToCoords ( e . getX ( ) , e . getY ( ) ) ; double xPos , yPos ; xPos = center . x ( ) - ( currentMouseCoords . x ( ) - previousMouseCoords . x ( ) ) ; yPos = center . y ( ) - ( currentMouseCoords . y ( ) - previousMouseCoords . y ( ) ) ; center = correctOutOfBounds ( new Coord ( xPos , yPos ) ) ; currentMouseCoords = convertMouseToCoords ( e . getX ( ) , e . getY ( ) ) ; updateObservers ( center , currentMouseCoords , RANGE , MAX_RANGE , this . getWidth ( ) , this . getHeight ( ) ) ; this . repaint ( ) ; }
te	7	public static Packet read ( ByteBuffer buffer ) { byte packetId = buffer . get ( ) ; if ( packetId == ID_HELLO_PACKET ) return new HelloPacket ( buffer ) ; if ( packetId == ID_WORLD_UPDATE_PACKET ) return new WorldUpdatesPacket ( buffer ) ; if ( packetId == ID_WINDOW_PACKET ) return new WindowPacket ( buffer ) ; if ( packetId == ID_WORLD_REGION_PACKET ) return new WorldRegionPacket ( buffer ) ; if ( packetId == ID_ENTITIES_PACKET ) return new EntitiesPacket ( buffer ) ; if ( packetId == ID_DWARF_REQUEST_PACKET ) return new DwarfRequestPacket ( buffer ) ; if ( packetId == ID_PLAYER_UPDATE_PACKET ) return new PlayerUpdatePacket ( buffer ) ; throw new RuntimeException ( "Unknown packet id: " + packetId ) ; }
te	6	@ Subscribe public void handle ( Event ev ) { boolean sortedOut = false ; if ( ev instanceof AbstractTickEvent ) { sortedOut = true ; } else if ( ev instanceof InputEvent ) { InputEvent e = ( InputEvent ) ev ; if ( e . isMouseMovedEvent ( ) || e . isMouseDraggedEvent ( ) ) { sortedOut = true ; } } else if ( ev instanceof UnitEvent ) { sortedOut = true ; } if ( ! sortedOut ) { System . out . println ( "# " + ev . toString ( ) ) ; } }
te	0	public PackedWorld ( PackedWorld prev ) { super ( prev ) ; cells = 0 ; }
te	3	public List < ScheduleDTO > getScheduleForStation ( ScheduleDTO userRequirements ) throws GetScheduleException { log . debug ( "Start: getScheduleForStation()" ) ; EntityManager entityManager = entityManagerFactory . createEntityManager ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < Station > stationBuf = entityManager . createQuery ( "select s from Station s where s.name = ?1" ) . setParameter ( 1 , userRequirements . getFromStation ( ) ) . getResultList ( ) ; if ( stationBuf . isEmpty ( ) ) { log . warn ( "given station is absent in DB" ) ; throw new GetScheduleException ( "\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u0430\u044F \u0441\u0442\u0430\u043D\u0446\u0438\u044F \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } List < Object [ ] > resultList = entityManager . createQuery ( "select sir1.train.number  sir1.station.name  sir2.station.name  " + "       sir3.departureTime  sir3.arrivalTime  sir1.train.vacancies " + "from StationInRoute sir1  StationInRoute sir2  StationInRoute sir3 " + "where sir1.train.id = sir2.train.id and sir1.train.id = sir3.train.id and " + "      sir1.departureTime = (select min(sir4.departureTime) " + "                            from StationInRoute sir4 " + "                            where sir4.train.id = sir1.train.id) and " + "      sir2.arrivalTime = (select max(sir5.arrivalTime) " + "                          from StationInRoute sir5 " + "                          where sir5.train.id = sir2.train.id) and " + "      sir3.station.name = ?1" ) . setParameter ( 1 , userRequirements . getFromStation ( ) ) . getResultList ( ) ; int size = resultList . size ( ) ; if ( size == 0 ) { log . warn ( "No schedule for requested station" ) ; throw new GetScheduleException ( "\u0414\u043B\u044F \u0437\u0430\u043F\u0440\u043E\u0448\u0435\u043D\u043D\u043E\u0439 \u0441\u0442\u0430\u043D\u0446\u0438\u0438 \u043D\u0435\u0442 \u0440\u0430\u0441\u043F\u0438\u0441\u0430\u043D\u0438\u044F" ) ; } ArrayList < ScheduleDTO > scheduleList = new ArrayList < ScheduleDTO > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { Object [ ] arr = resultList . get ( i ) ; scheduleList . add ( new ScheduleDTO ( ( Integer ) arr [ 0 ] , ( String ) arr [ 1 ] , ( String ) arr [ 2 ] , ( Time ) arr [ 3 ] , ( Time ) arr [ 4 ] , ( Integer ) arr [ 5 ] ) ) ; } return scheduleList ; }
te	4	@ Override protected ArrayList < PossibleTile > getLazyTiles ( Board b ) { ArrayList < PossibleTile > possibleTiles = new ArrayList < PossibleTile > ( ) ; int i = 1 ; boolean canSearch = true ; Rook clone = this . clone ( ) ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) - i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) + i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) - i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) + i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } return possibleTiles ; }
te	7	public String testPST ( CmdOptions parser , Option vlmc , boolean force , boolean read , boolean oblig ) { String vlmcValue = ( String ) parser . getOptionValue ( vlmc ) ; if ( vlmcValue == null ) { if ( oblig ) { System . err . println ( "BAD USAGE. pst file must be defined: {-p | --pst} file" ) ; System . exit ( 0 ) ; } else { return null ; } } boolean cpok = true ; File cpfile = new File ( vlmcValue ) ; if ( ! cpfile . exists ( ) ) { cpok = false ; } if ( read ) { if ( ! cpok ) { System . err . println ( "BAD USAGE. vlmc file must be an existing file [" + vlmcValue + "]" ) ; System . exit ( 0 ) ; } } else { if ( cpok && ! force ) { vlmcValue = null ; } } return vlmcValue ; }
te	8	public int longestValidParentheses ( String s ) { int a [ ] = new int [ s . length ( ) ] ; int last = - 1 ; int max = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ( ) { a [ i ] = last ; last = i ; } else { a [ i ] = last ; if ( last != - 1 ) { int len = i - last + 1 ; int temp = last - 1 ; while ( temp >= 0 && s . charAt ( temp ) == ) && a [ temp ] >= 0 ) { len += temp - a [ temp ] + 1 ; temp = a [ temp ] - 1 ; } if ( len > max ) { max = len ; } } if ( last >= 0 ) last = a [ last ] ; else last = - 1 ; } } return max ; }
te	1	public TouristDetector ( Listener listener , MetricsDetector . Metrics ... metricses ) { detectors = new MetricsDetector [ metricses . length ] ; for ( int i = 0 ; i < metricses . length ; i ++ ) { detectors [ i ] = new MetricsDetector ( this , metricses [ i ] ) ; } this . listener = listener ; this . tourists = new HashSet < String > ( ) ; this . workers = new HashSet < String > ( ) ; }
te	7	@ Override public void visit ( Identifiable thing ) { if ( thing . isBullet ( ) ) { this . health -= player . getPower ( ) ; if ( health < 1 ) { this . dead = true ; this . panel . removeSprite ( this ) ; } } else if ( thing . isPlayer ( ) ) { GameDir toMove = GameDir . UP ; switch ( player . getDirection ( ) ) { case UP : toMove = GameDir . DOWN ; break ; case DOWN : toMove = GameDir . UP ; break ; case RIGHT : toMove = GameDir . LEFT ; break ; case LEFT : toMove = GameDir . RIGHT ; break ; } this . player . damage ( this . power , toMove ) ; } }
te	5	public static Trajectory generate ( Config config , Strategy strategy , double start_vel , double start_heading , double goal_pos , double goal_vel , double goal_heading ) { if ( strategy == AutomaticStrategy ) { strategy = chooseStrategy ( start_vel , goal_vel , config . max_vel ) ; } Trajectory traj ; if ( strategy == StepStrategy ) { double impulse = ( goal_pos / config . max_vel ) / config . dt ; int time = ( int ) ( Math . floor ( impulse ) ) ; traj = secondOrderFilter ( 1 , 1 , config . dt , config . max_vel , config . max_vel , impulse , time , TrapezoidalIntegration ) ; } else if ( strategy == TrapezoidalStrategy ) { double start_discount = .5 * start_vel * start_vel / config . max_acc ; double end_discount = .5 * goal_vel * goal_vel / config . max_acc ; double adjusted_max_vel = Math . min ( config . max_vel , Math . sqrt ( config . max_acc * goal_pos - start_discount - end_discount ) ) ; double t_rampup = ( adjusted_max_vel - start_vel ) / config . max_acc ; double x_rampup = start_vel * t_rampup + .5 * config . max_acc * t_rampup * t_rampup ; double t_rampdown = ( adjusted_max_vel - goal_vel ) / config . max_acc ; double x_rampdown = adjusted_max_vel * t_rampdown - .5 * config . max_acc * t_rampdown * t_rampdown ; double x_cruise = goal_pos - x_rampdown - x_rampup ; int time = ( int ) ( ( t_rampup + t_rampdown + x_cruise / adjusted_max_vel ) / config . dt + .5 ) ; int f1_length = ( int ) Math . ceil ( ( adjusted_max_vel / config . max_acc ) / config . dt ) ; double impulse = ( goal_pos / adjusted_max_vel ) / config . dt - start_vel / config . max_acc / config . dt + start_discount + end_discount ; traj = secondOrderFilter ( f1_length , 1 , config . dt , start_vel , adjusted_max_vel , impulse , time , TrapezoidalIntegration ) ; } else if ( strategy == SCurvesStrategy ) { double adjusted_max_vel = Math . min ( config . max_vel , ( - config . max_acc * config . max_acc + Math . sqrt ( config . max_acc * config . max_acc * config . max_acc * config . max_acc + 4 * config . max_jerk * config . max_jerk * config . max_acc * goal_pos ) ) / ( 2 * config . max_jerk ) ) ; int f1_length = ( int ) Math . ceil ( ( adjusted_max_vel / config . max_acc ) / config . dt ) ; int f2_length = ( int ) Math . ceil ( ( config . max_acc / config . max_jerk ) / config . dt ) ; double impulse = ( goal_pos / adjusted_max_vel ) / config . dt ; int time = ( int ) ( Math . ceil ( f1_length + f2_length + impulse ) ) ; traj = secondOrderFilter ( f1_length , f2_length , config . dt , 0 , adjusted_max_vel , impulse , time , TrapezoidalIntegration ) ; } else { return null ; } double total_heading_change = goal_heading - start_heading ; for ( int i = 0 ; i < traj . getNumSegments ( ) ; ++ i ) { traj . segments_ [ i ] . heading = start_heading + total_heading_change * ( traj . segments_ [ i ] . pos ) / traj . segments_ [ traj . getNumSegments ( ) - 1 ] . pos ; } return traj ; }
te	8	private String [ ] splitMultipartHeader ( String sb ) { ArrayList < String > headers = new ArrayList < String > ( 1 ) ; int nameStart ; int nameEnd ; int colonEnd ; int valueStart ; int valueEnd ; nameStart = HttpPostBodyUtil . findNonWhitespace ( sb , 0 ) ; for ( nameEnd = nameStart ; nameEnd < sb . length ( ) ; nameEnd ++ ) { char ch = sb . charAt ( nameEnd ) ; if ( ch == : || Character . isWhitespace ( ch ) ) { break ; } } for ( colonEnd = nameEnd ; colonEnd < sb . length ( ) ; colonEnd ++ ) { if ( sb . charAt ( colonEnd ) == : ) { colonEnd ++ ; break ; } } valueStart = HttpPostBodyUtil . findNonWhitespace ( sb , colonEnd ) ; valueEnd = HttpPostBodyUtil . findEndOfString ( sb ) ; headers . add ( sb . substring ( nameStart , nameEnd ) ) ; String svalue = sb . substring ( valueStart , valueEnd ) ; String [ ] values = null ; if ( svalue . indexOf ( ";" ) >= 0 ) { values = svalue . split ( ";" ) ; } else { values = svalue . split ( " " ) ; } for ( String value : values ) { headers . add ( value . trim ( ) ) ; } String [ ] array = new String [ headers . size ( ) ] ; for ( int i = 0 ; i < headers . size ( ) ; i ++ ) { array [ i ] = headers . get ( i ) ; } return array ; }
te	5	private final static boolean stringAt ( String string , int start , int length , String [ ] list ) { if ( ( start < 0 ) || ( start >= string . length ( ) ) || list . length == 0 ) return false ; String substr = string . substring ( start , start + length ) ; for ( int i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] . equals ( substr ) ) return true ; } return false ; }
te	6	private synchronized void setNewSoundSource ( SoundSource newSource ) { switch ( state ) { case PLAYING : resetFadeOut ( ) ; state = State . CHANGING ; case STOPPING : case CHANGING : nextSound = newSource ; break ; case EMPTY : case STOPPED : state = newSource == null ? State . EMPTY : State . STOPPED ; currentSound = newSource ; break ; default : break ; } }
te	0	public String getTopDownCenterIntersection ( ) { return topDownCenterIntersection ; }
te	3	@ Override public void setValue ( final Map < String , Value < ? >> value ) { if ( value == null ) { throw new NullPointerException ( ) ; } this . value = new TreeMap < String , Value < ? >> ( value ) ; }
te	5	public void update ( Observable o , Object arg ) { final String line = ( String ) arg ; final String thisLine = line . substring ( line . indexOf ( "Text [" ) + "Text [" . length ( ) , line . indexOf ( "]" , line . indexOf ( "Text [" ) ) ) ; if ( thisLine . contains ( "CLP" ) ) { int clp_start = thisLine . indexOf ( ClustersPrefix ) + ClustersPrefix . length ( ) ; int clp_end = thisLine . lastIndexOf ( ";" ) ; String clpevent = thisLine . substring ( clp_start , clp_end ) ; String [ ] a = clpevent . split ( ";" ) ; int type = Integer . parseInt ( a [ 2 ] ) ; int nodeid = Integer . parseInt ( a [ 1 ] . substring ( 2 ) , 16 ) ; if ( type == 2 ) { set_head ( nodeid ) ; log . info ( "added head" ) ; } else if ( type != 0 ) { set_simple ( nodeid ) ; log . info ( "added simple" ) ; } final Millisecond now = new Millisecond ( new Date ( ) ) ; try { Thread . sleep ( 1 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } log . info ( "head:" + heads ( ) + " simple:" + simples ( ) ) ; if ( heads ( ) > 0 ) { clusters_series . add ( now , heads ( ) ) ; cluster_size_series . add ( now , total ( ) / heads ( ) ) ; } else { clusters_series . add ( now , 0 ) ; cluster_size_series . add ( now , 0 ) ; } } }
te	3	@ Override public ElapsedTimeInterval ping ( JSONObject header , String hostIP , int port , int timeout , int nTrials ) throws Exception { for ( int i = 0 ; i < nTrials ; i ++ ) { try { ElapsedTime . start ( "PingRPCTotal" ) ; doRcpPing ( header , hostIP , port , timeout ) ; ElapsedTime . stop ( "PingRPCTotal" ) ; } catch ( SocketTimeoutException e ) { ElapsedTime . abort ( "PingRPCTotal" ) ; System . out . println ( "PingRPCTotal timed out: " + e . getMessage ( ) ) ; } catch ( Exception e ) { ElapsedTime . abort ( "PingRPCTotal" ) ; System . out . println ( "PingRPCTotal Exception: " + e . getMessage ( ) ) ; } } return ElapsedTime . get ( "PingRPCTotal" ) ; }
te	5	public List < Dimension > getAllIndicatorDimensions ( String keyFamilyId ) { List < Dimension > dimensions = new ArrayList < Dimension > ( ) ; List < String > addedDimensions = new ArrayList < String > ( ) ; for ( LocalizedString indicatorName : getIndicatorNames ( keyFamilyId ) ) { List < DimensionWrapper > dimensionHierarchy = getDimensionHierarchy ( indicatorName . getDefaultStr ( ) , keyFamilyId ) ; if ( dimensionHierarchy != null ) { for ( DimensionWrapper dw : dimensionHierarchy ) { List < Dimension > hierarchyDimensions = dw . getAllDimensions ( ) ; for ( Dimension d : hierarchyDimensions ) { if ( ! addedDimensions . contains ( d . getConceptRef ( ) ) ) { dimensions . add ( d ) ; addedDimensions . add ( d . getConceptRef ( ) ) ; } } } } } return dimensions ; }
te	1	public int [ ] getProxyPort ( ) { IProxyService proxy = StartupPlugin . getDefault ( ) . getProxyService ( ) ; IProxyData [ ] proxyData = proxy . getProxyData ( ) ; int [ ] proxyPort = new int [ proxyData . length ] ; for ( int i = 0 ; i < proxyData . length ; i ++ ) proxyPort [ i ] = proxyData [ i ] . getPort ( ) ; return proxyPort ; }
te	1	public static Integer castInt ( Object obj ) { try { return ( Integer ) obj ; } catch ( ClassCastException e ) { return 0 ; } }
te	5	public NewLevelSetup ( String caption , Menu newMenu ) { this . setTitle ( caption ) ; this . setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; this . setModalityType ( Dialog . ModalityType . DOCUMENT_MODAL ) ; this . menu = newMenu ; this . fieldSizeX = new JFormattedTextField ( this . menu . getSizeX ( ) ) ; this . fieldSizeY = new JFormattedTextField ( this . menu . getSizeY ( ) ) ; this . fieldSizeX . setColumns ( 3 ) ; this . fieldSizeY . setColumns ( 3 ) ; this . labelSize . setHorizontalAlignment ( JLabel . CENTER ) ; this . labelSizeX . setHorizontalAlignment ( JLabel . CENTER ) ; this . labelSizeY . setHorizontalAlignment ( JLabel . CENTER ) ; String [ ] tilesetList = Data . getTilesetList ( new File ( Data . getDataDirectory ( ) + "/data/gfx/tileset" ) ) ; if ( tilesetList != null ) this . comboTileset = new JComboBox < String > ( tilesetList ) ; else this . comboTileset = new JComboBox < String > ( ) ; fieldSizeX . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { int value = ( ( Number ) fieldSizeX . getValue ( ) ) . intValue ( ) ; if ( value < 20 ) { value = 20 ; fieldSizeX . setValue ( value ) ; } else if ( value > 500 ) { value = 500 ; fieldSizeX . setValue ( value ) ; } } } ) ; fieldSizeY . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { int value = ( ( Number ) fieldSizeY . getValue ( ) ) . intValue ( ) ; if ( value < 20 ) { value = 20 ; fieldSizeY . setValue ( value ) ; } else if ( value > 500 ) { value = 500 ; fieldSizeY . setValue ( value ) ; } } } ) ; buttonCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { choice = false ; setVisible ( false ) ; dispose ( ) ; } } ) ; buttonCreate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { menu . setSizeX ( ( ( Number ) fieldSizeX . getValue ( ) ) . intValue ( ) ) ; menu . setSizeY ( ( ( Number ) fieldSizeY . getValue ( ) ) . intValue ( ) ) ; menu . setTilesetName ( String . valueOf ( comboTileset . getSelectedItem ( ) ) ) ; choice = true ; setVisible ( false ) ; dispose ( ) ; } } ) ; fieldContainer . add ( labelSizeX ) ; fieldContainer . add ( fieldSizeX ) ; fieldContainer . add ( labelSizeY ) ; fieldContainer . add ( fieldSizeY ) ; buttonContainer . add ( buttonCancel ) ; buttonContainer . add ( buttonCreate ) ; windowLayout . setVgap ( 5 ) ; windowContainer . add ( labelSize ) ; windowContainer . add ( fieldContainer ) ; windowContainer . add ( comboTileset ) ; windowContainer . add ( buttonContainer ) ; this . add ( windowContainer ) ; }
te	6	public void upsert ( Data [ ] toUpdate ) throws IOException { try { int actualChunkIdx = 0 , lastChunkIdx = - 1 ; long actualChunkOffset = 0 , oldChunkOffset = - 1 ; int indexInChunk = 0 ; for ( int i = 0 ; i < toUpdate . length ; i ++ ) { actualChunkIdx = header . getChunkId ( toUpdate [ i ] . getKey ( ) ) ; actualChunkOffset = header . getStartOffsetOfChunk ( actualChunkIdx ) ; if ( actualChunkOffset > dataFile . getFilledUpFromContentStart ( ) ) { log . warn ( "Element with key {} was not found. Chunk {} does not exist." , actualChunkIdx , toUpdate [ i ] . getKey ( ) ) ; continue ; } if ( actualChunkIdx != lastChunkIdx ) { if ( oldChunkOffset > - 1 ) { dataFile . write ( oldChunkOffset , workingBuffer ) ; indexInChunk = 0 ; } dataFile . read ( actualChunkOffset , workingBuffer ) ; } int oldIndexInChunk = indexInChunk ; indexInChunk = updateElementInReadBuffer ( toUpdate [ i ] , indexInChunk ) ; if ( indexInChunk == - 1 ) { log . warn ( "Element with key {} was not found and therefore not updated. File: {}  Chunk: {}  Index for searching in buffer: {}  Index after update: {}" , new Object [ ] { toUpdate [ i ] . getKey ( ) , this . dataFilename , actualChunkIdx , oldIndexInChunk , indexInChunk } ) ; indexInChunk = 0 ; } lastChunkIdx = actualChunkIdx ; oldChunkOffset = actualChunkOffset ; } if ( oldChunkOffset > - 1 ) { dataFile . write ( oldChunkOffset , workingBuffer ) ; } } finally { dataFile . close ( ) ; } }
te	9X	public static String toString ( JSONArray ja ) throws JSONException { Object e ; int i ; JSONObject jo ; String k ; Iterator keys ; int length ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String v ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; e = ja . opt ( 1 ) ; if ( e instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) e ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { k = keys . next ( ) . toString ( ) ; XML . noSpace ( k ) ; v = jo . optString ( k ) ; if ( v != null ) { sb . append (   ) ; sb . append ( XML . escape ( k ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( v ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { e = ja . get ( i ) ; i += 1 ; if ( e != null ) { if ( e instanceof String ) { sb . append ( XML . escape ( e . toString ( ) ) ) ; } else if ( e instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) e ) ) ; } else if ( e instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) e ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
te	1	public Session ( String user , String docName , boolean start ) { this . requestQueue = new LinkedList < Request > ( ) ; this . requestLog = new HashMap < String , List < Request >> ( ) ; this . docMod = new HashSet < Request > ( ) ; this . docName = docName ; this . currentState = new StateVector ( ) ; this . userName = user ; this . docText = "" ; running = false ; listeners = new Vector < ChangeListener > ( ) ; sessionThread = new Thread ( this ) ; if ( start ) start ( ) ; }
te	9X	private int getPlayerSize ( int index ) { int iPlayerFactorIndex = 0 ; if ( index == 0 ) iPlayerFactorIndex = getRegister ( NUSIZ0 ) & 07 ; else if ( index == 1 ) iPlayerFactorIndex = getRegister ( NUSIZ1 ) & 07 ; else return 1 ; switch ( iPlayerFactorIndex ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 6 : return PLAYER_SINGLE_SIZE ; case 5 : return PLAYER_DOUBLE_SIZE ; case 7 : return PLAYER_QUAD_SIZE ; } return 1 ; }
te	0	@ EventHandler ( priority = EventPriority . LOWEST ) public void paintingPlaceblock ( PaintingPlaceEvent event ) { prevent ( event , event . getPlayer ( ) , "placeblock." + Material . PAINTING . getId ( ) + " build." + Material . PAINTING . getId ( ) ) ; }
te	4	private void doTag ( Element element ) { String tagAttribute = element . getAttribute ( "tag" ) ; if ( tagAttribute == null || ! MetaHeaders . ATTRIBUTE_LIST . contains ( tagAttribute ) ) { return ; } NodeList childNodeList = element . getChildNodes ( ) ; if ( childNodeList == null || childNodeList . getLength ( ) == 0 ) { return ; } this . doSubtTag ( tagAttribute , childNodeList ) ; }
te	2	public void paint ( Graphics g , int width ) { int xpos = ( width - 251 ) / 2 ; g . setColor ( Color . black ) ; g . draw3DRect ( xpos , 420 , 251 , 20 , true ) ; for ( int tmp = 0 ; tmp < this . points ; tmp = tmp + 10 ) { if ( tmp < 100 ) { g . setColor ( new Color ( 60 + ( tmp + 10 ) / 2 , 26 , 26 ) ) ; } else { g . setColor ( new Color ( 110 , 26 + ( tmp - 90 ) / 2 , 26 ) ) ; } g . fillRect ( xpos + 1 + tmp / 2 , 421 , 5 , 19 ) ; } }
te	8	public Object getAttribute ( String fieldName ) throws RemoteException { if ( ! isInitialized ( ) ) throw new RemoteException ( "object not initialized." ) ; if ( fieldName == null ) return null ; Object o = properties . get ( fieldName ) ; if ( o == null ) { if ( fieldName . equalsIgnoreCase ( getIDField ( ) ) ) return getID ( ) ; return null ; } if ( o instanceof DBObject ) return o ; class foreign = getForeignObject ( fieldName ) ; if ( foreign != null ) { String id = o . toString ( ) ; DBObject cachedObject = ( DBObject ) foreignObjectCache . get ( foreign . getName ( ) + fieldName ) ; if ( cachedObject != null ) { if ( ! id . equals ( cachedObject . getID ( ) ) ) cachedObject . load ( id ) ; } else { cachedObject = service . createObject ( foreign , id ) ; foreignObjectCache . put ( foreign . getName ( ) + fieldName , cachedObject ) ; } return cachedObject ; } return o ; }
te	8	@ Override public Iterable < MatchResult < T >> matchFromStart ( final CharSequence string ) { return new Iterable < MatchResult < T >> ( ) { public Iterator < MatchResult < T >> iterator ( ) { return new Iterator < MatchResult < T >> ( ) { TailMatchIterator tailSequence = new TailMatchIterator ( 0 , string ) ; List < MatchResult < ? >> next = null ; boolean returnNull = getMin ( ) == 0 ; public boolean hasNext ( ) { if ( returnNull ) return true ; updateNext ( ) ; return null != next ; } public MatchResult < T > next ( ) { if ( returnNull ) { returnNull = false ; return new MatchResult < T > ( ChainGrammar . this , string , 0 , 0 , getNullResult ( ) ) ; } updateNext ( ) ; T result = getResult ( next ) ; int startIndex = 0 ; int endIndex = 0 ; for ( MatchResult < ? > r : next ) { assert ( 0 == r . start ) ; endIndex += r . end ; } MatchResult < T > matchResult = new MatchResult < T > ( ChainGrammar . this , string , startIndex , endIndex , result ) ; next = null ; return matchResult ; } private void updateNext ( ) { while ( null == next || next . size ( ) < getMin ( ) ) { if ( ! tailSequence . hasNext ( ) ) { next = null ; break ; } next = tailSequence . next ( ) ; } } public void remove ( ) { throw new RuntimeException ( "Operation not supported" ) ; } } ; } } ; }
te	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } TipoproductoDao oTipoproductoDAO = new TipoproductoDao ( ) ; int pages = oTipoproductoDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "TipoproductoGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
te	1	public static boolean isUnix ( ) { return isLinux ( ) || isMac ( ) ; }
te	4	@ Override protected void done ( ) { String errorMsg = "" ; final SolverTask st = solverTask ; if ( this == st ) { solverTask = null ; try { setSolution ( this . get ( ) ) ; } catch ( CancellationException e ) { System . err . println ( e . toString ( ) ) ; } catch ( Exception e ) { errorMsg = e . toString ( ) ; e . printStackTrace ( ) ; } } if ( ! errorMsg . isEmpty ( ) ) { appendSolutionText ( "error:\n" + errorMsg + "\n" , null ) ; } }
te	4	public static void Print ( String Text ) { if ( verbose_level >= 2 ) { StackTraceElement [ ] ste = Thread . currentThread ( ) . getStackTrace ( ) ; System . out . println ( ">>>>> " + ste [ 2 ] + ": " + Text ) ; if ( verbose_level >= 4 ) { System . out . print ( "Stacktrace: " ) ; for ( int i = 2 ; i < ste . length ; i ++ ) { System . out . print ( ste [ i ] ) ; if ( ! ( i == ste . length - 1 ) ) System . out . print ( " -> " ) ; } System . out . println ( "" ) ; } } }
te	8	@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) public static void staticMerge ( List < String > files , JZSequenceFile file , Comparator comparator ) { final Comparator tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { JZSequenceFile infile = new JZSequenceFile ( JZFile . JZFileSystem , files . get ( i ) , 0 , 0 ) ; inFiles . add ( infile ) ; JZSequenceFile . Reader < Object , List < Object >> reader = new JZSequenceFile . Reader < Object , List < Object >> ( infile ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } JZSequenceFile . Writer < Object , List < Object >> writer = new JZSequenceFile . Writer < Object , List < Object >> ( file ) ; List < Object > list = new ArrayList < Object > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; Object preKey = ( Object ) firstEntry [ 0 ] ; JZSequenceFile . Reader < Object , List < Object >> reader = ( JZSequenceFile . Reader < Object , List < Object >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; Object key = ( Object ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < Object , List < Object >> ) entry [ 1 ] ; List < Object > value = ( List < Object > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writer . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < Object > ( value ) ; } if ( reader . nextKeyValue ( ) ) { Object newKey = ( Object ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writer . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } writer . close ( ) ; }
te	5	protected DRUMS ( AbstractHashFunction hashFunction , AccessMode accessMode , DRUMSParameterSet < Data > gp ) throws IOException { this . prototype = gp . getPrototype ( ) ; this . hashFunction = hashFunction ; this . gp = gp ; DynamicMemoryAllocater . instantiate ( gp ) ; gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC = ( int ) ( ( gp . BUCKET_MEMORY - gp . BUCKET_MEMORY % gp . MEMORY_CHUNK ) / hashFunction . getNumberOfBuckets ( ) / prototype . getSize ( ) / 2 ) ; logger . info ( "Setted MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC to {}" , gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC ) ; if ( accessMode == AccessMode . READ_WRITE ) { @ SuppressWarnings ( "unchecked" ) Bucket < Data > [ ] tmp = new Bucket [ hashFunction . getNumberOfBuckets ( ) ] ; buckets = tmp ; for ( int i = 0 ; i < hashFunction . getNumberOfBuckets ( ) ; i ++ ) { buckets [ i ] = new Bucket < Data > ( i , gp ) ; String tmpFileName = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( i ) ; if ( ! new File ( tmpFileName ) . exists ( ) ) { HeaderIndexFile < Data > tmpFile ; try { tmpFile = new HeaderIndexFile < Data > ( tmpFileName , HeaderIndexFile . AccessMode . READ_WRITE , 1 , gp ) ; tmpFile . close ( ) ; } catch ( FileLockException e ) { logger . error ( "Can't create file {}  because file is locked by another process." , tmpFileName ) ; } catch ( IOException e ) { logger . error ( "Can't create file {}. {}" , tmpFileName , e ) ; throw e ; } } } bucketContainer = new BucketContainer < Data > ( buckets , hashFunction ) ; synchronizerFactory = new SynchronizerFactory < Data > ( ) ; syncManager = new SyncManager < Data > ( bucketContainer , synchronizerFactory , gp ) ; syncManager . start ( ) ; } }
te	2	public static String getDate ( String content ) { String header = getHeader ( content ) ; String str [ ] = header . split ( "\n" ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . startsWith ( "Date" ) ) { String str2 [ ] = str [ i ] . split ( ":" , 2 ) ; return str2 [ 1 ] . trim ( ) ; } } return null ; }
te	4	@ Override public boolean doCommand ( final CommandSender sender , final Command command , final String cmd , final String [ ] args ) { if ( ! canUseCommand ( sender , cmd , false , true ) ) { return true ; } String players = null ; synchronized ( AllAdmin . getUserList ( ) ) { final TreeMap < String , IUser > onlinePlayers = new TreeMap < String , IUser > ( ) ; onlinePlayers . putAll ( AllAdmin . getUserList ( ) ) ; for ( final String player : onlinePlayers . keySet ( ) ) { if ( players == null ) { players = "There are " + onlinePlayers . size ( ) + " player online: " + player + "  " ; continue ; } players += player + "  " ; } if ( players == null ) { sender . sendMessage ( AllAdmin . getMessages ( "noPlayersOn" ) ) ; return true ; } sender . sendMessage ( ChatColor . AQUA + players ) ; } return true ; }
te	9X	@ Override protected boolean inLineOfSight ( Point x , Point Abs ) { dx = ( x . x == 0 ) ? 0 : ( x . x > 0 ) ? 1 : - 1 ; dy = ( x . y == 0 ) ? 0 : ( x . y > 0 ) ? 1 : - 1 ; if ( x . x == 1 && x . y == 0 || x . y == 1 && x . x == 0 || x . x == - 1 && x . y == 0 || x . y == - 1 && x . x == 0 ) return true ; if ( C . isFigure ( new Point ( Abs . x - dx , Abs . y - dy ) ) ) return false ; return inLineOfSight ( new Point ( x . x - dx , x . y - dy ) , new Point ( Abs . x - dx , Abs . y - dy ) ) ; }
te	2	public DefaultNeuron ( int weightNumber , double [ ] maxWeight , ActivationFunctionModel activationFunction ) { if ( weightNumber == maxWeight . length ) { Random rand = new Random ( ) ; weight = new double [ weightNumber ] ; for ( int i = 0 ; i < weightNumber ; i ++ ) { weight [ i ] = rand . nextDouble ( ) * maxWeight [ i ] ; } } this . activationFunction = activationFunction ; }
te	1	@ Override public Set < Type > getConnectedTypes ( ) { Set < Type > t = new HashSet < Type > ( ) ; for ( Link l : links ) { t . addAll ( l . getDestinationNode ( ) . getConnectedTypes ( ) ) ; } return t ; }
te	4	public boolean checkTerminationForValueIteration ( double prevVal [ ] , double curVal [ ] ) { if ( prevVal == null ) { return false ; } double limit = epsilon * ( 1 - mdpData . getGamma ( ) ) / mdpData . getGamma ( ) ; for ( int i = 0 ; i < mdpData . getNoOfStates ( ) ; i ++ ) { double diff = curVal [ i ] - prevVal [ i ] ; if ( diff < 0 ) { diff = - 1 * diff ; } if ( diff >= limit ) { return false ; } } return true ; }
te	0	public void doPassaTurno ( ) { turnoConfermato = false ; }
te	3	public boolean intersects ( Rect2 rect ) { return ! ( x - w / 2 > rect . x + rect . w / 2 || x + w / 2 < rect . x - rect . w / 2 || y + h / 2 < rect . y - rect . h / 2 || y - h / 2 > rect . y + rect . h / 2 ) ; }
te	5	private boolean isOk ( ) { if ( jTextField1 . toString ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , Constant . NAME_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; jTextField1 . grabFocus ( ) ; return false ; } if ( jComboBox3 . getSelectedIndex ( ) == 0 ) { JOptionPane . showMessageDialog ( this , Constant . TYPE_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( jFormattedTextField1 . toString ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , Constant . VALUE_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; jFormattedTextField1 . grabFocus ( ) ; return false ; } if ( jComboBox2 . getSelectedIndex ( ) == 0 ) { if ( process == 2 ) { JOptionPane . showMessageDialog ( this , Constant . PRIORITY_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } return true ; }
te	8	public Tree parseModule ( ) { if ( ! poll ( kModule ) ) { return expected ( kModule ) ; } final Name name = parseName ( ) ; if ( ! poll ( kLBrace ) ) { return expected ( kLBrace ) ; } if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } final Module module = init ( new Module ( name ) ) ; final List < Tree > dependencies = module . dependencies ; final List < Tree > declarations = module . declarations ; do { if ( peek ( kRequire ) ) { dependencies . add ( parseModuleDependency ( ) ) ; } else { final Tree declaration = parseDeclarationOpt ( ) ; if ( declaration == null ) { declarations . add ( parseExpression ( ) ) ; } else { declarations . add ( declaration ) ; } } if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } } while ( ! peek ( kRBrace ) ) ; if ( ! poll ( kRBrace ) ) { return expected ( kRBrace ) ; } return module ; }
te	6	public void actionPerformed ( ActionEvent ae ) { Automaton aut = Automaton . makeEmpty ( ) ; Iterator < String > lines = Util . readLinesFromString ( regTextPane . getText ( ) ) ; while ( lines . hasNext ( ) ) { try { String s = lines . next ( ) ; RegExp re = new RegExp ( s ) ; Automaton a = re . toAutomaton ( ) ; aut = aut . union ( a ) ; } catch ( IllegalArgumentException e ) { } aut . minimize ( ) ; } if ( aut . isEmpty ( ) || aut . isEmptyString ( ) ) { ErrorFrame . spawnError ( "Your regular expression" + " does not match any string." ) ; } else if ( ! Util . isPossible4chanAutomaton ( aut ) ) { ErrorFrame . spawnError ( "Your regular expression does not " + "match any 4chan trip codes" ) ; } else { this . setEnabled ( false ) ; int threads = 0 ; try { String val = ( String ) coreDropDown . getSelectedItem ( ) ; threads = Integer . parseInt ( val ) ; } catch ( NumberFormatException nfe ) { threads = 8 ; } stopAction . setEnabled ( true ) ; RunAutomaton ra = new RunAutomaton ( aut ) ; HashDispatcher . dispatch ( ra , threads ) ; updateTps ( ) ; } }
te	9X	@ Override protected boolean handleEvent ( Event evt ) { if ( super . handleEvent ( evt ) ) { return true ; } if ( state != null ) { switch ( evt . getType ( ) ) { case KEY_PRESSED : state . keyPressed ( evt . getKeyCode ( ) , evt . getKeyChar ( ) ) ; break ; case KEY_RELEASED : state . keyReleased ( evt . getKeyCode ( ) , evt . getKeyChar ( ) ) ; break ; case MOUSE_BTNDOWN : state . mousePressed ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_BTNUP : state . mouseReleased ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_CLICKED : state . mouseClicked ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) , evt . getMouseClickCount ( ) ) ; break ; case MOUSE_ENTERED : case MOUSE_MOVED : state . mouseMoved ( oldMouseX , oldMouseY , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_DRAGGED : state . mouseDragged ( oldMouseX , oldMouseY , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_WHEEL : state . mouseWheelMoved ( evt . getMouseWheelDelta ( ) ) ; break ; default : break ; } } if ( evt . isMouseEvent ( ) ) { oldMouseX = evt . getMouseX ( ) ; oldMouseY = evt . getMouseY ( ) ; } return true ; }
te	4	public void setVolume ( int channel , int volume ) { if ( channel < 0 || channel >= channelCount ) throw new IllegalArgumentException ( "Channel must be in legal range!" ) ; if ( volume < 0 || volume > short . MAX_VALUE ) throw new IllegalArgumentException ( "Volume must be in legal range!" ) ; vol [ channel ] = ( short ) volume ; }
te	9X	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; char c = x . nextClean ( ) ; char q ; if ( c == [ ) { q = ] ; } else if ( c == ( ) { q = ) ; } else { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } c = x . nextClean ( ) ; switch ( c ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : case ) : if ( q != c ) { throw x . syntaxError ( "Expected a '" + new Character ( q ) + "'" ) ; } return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } }
te	7	@ Override protected void doReload ( ) { String doc = web . getDoc ( url , referer ) ; if ( doc == null ) { status = web . getStatus ( ) ; return ; } int count = 0 ; String link = web . findFirst ( linkBegin , linkEnd ) ; while ( link != null ) { web . skipLastPostfix ( ) ; link = urlPrefix + link ; String name = web . findNext ( ">" , "<" ) ; if ( name == null ) break ; web . skipLastPostfix ( ) ; if ( name . length ( ) > 0 ) { name = name . replaceAll ( "&nbsp;" , " " ) . trim ( ) ; if ( ! ids . contains ( link ) ) { add ( new Show ( model , name , link , url ) ) ; ids . add ( link ) ; count ++ ; } } link = web . findNext ( linkBegin , linkEnd ) ; } if ( count == 9 ) { int i = url . indexOf ( "page=" ) + 5 ; int j = url . indexOf ( & , i ) ; int page = Integer . parseInt ( url . substring ( i , j ) ) + 1 ; link = url . substring ( 0 , url . indexOf ( ? ) ) + "?page=" + page + "&orderBy=created" ; if ( ! ids . contains ( link ) ) { add ( new Category ( model , "Page " + page , link , url ) ) ; ids . add ( link ) ; } } status = null ; }
te	0	public int getHpBase ( ) { return hpBase ; }
te	4	public static String getDescription ( int value ) { String description = "Large" ; switch ( value ) { case LARGE : description = "Large" ; break ; case MEDIUM : description = "Medium" ; break ; case SMALL : description = "Small" ; break ; case NONE : description = "None" ; break ; } return description ; }
te	2	private void initializeClusterFactors ( BayesNet net , final List < List < Integer >> clusters , int [ ] homeClusters ) { nodePotentials = new AbstractFactor [ clusters . size ( ) ] ; Map < Integer , List < AbstractFactor >> multiplicationPartners = findMultiplicationPartners ( net , homeClusters ) ; for ( final ListIterator < List < Integer >> cliqueIt = clusters . listIterator ( ) ; cliqueIt . hasNext ( ) ; ) { final List < Integer > cluster = cliqueIt . next ( ) ; int current = cliqueIt . nextIndex ( ) - 1 ; List < AbstractFactor > multiplicationPartnerList = multiplicationPartners . get ( current ) ; final AbstractFactor cliqueFactor = factory . create ( cluster , multiplicationPartnerList == null ? Collections . < AbstractFactor > emptyList ( ) : multiplicationPartnerList ) ; nodePotentials [ current ] = cliqueFactor ; } }
te	5	public T get ( Id idArg ) throws VariavelNaoDeclaradaException { try { T result = null ; Stack < HashMap < Id , T >> auxStack = new Stack < HashMap < Id , T >> ( ) ; while ( result == null && ! pilha . empty ( ) ) { HashMap < Id , T > aux = pilha . pop ( ) ; auxStack . push ( aux ) ; result = aux . get ( idArg ) ; } while ( ! auxStack . empty ( ) ) { pilha . push ( auxStack . pop ( ) ) ; } if ( result == null ) { throw new IdentificadorNaoDeclaradoException ( ) ; } return result ; } catch ( IdentificadorNaoDeclaradoException e ) { throw new VariavelNaoDeclaradaException ( idArg ) ; } }
te	4	public ListNode partition ( ListNode head , int x ) { ListNode p1 = null , p2 = head , p2Prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2Prev ) { p1 = p2 ; p2 = p2 . next ; p2Prev = p1 ; } else { p2Prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2Prev . next ; } } else { p2Prev = p2 ; p2 = p2 . next ; } } return head ; }
te	8	public static File createFile ( File file ) throws Exception { File parent = file . getParentFile ( ) ; if ( ! parent . exists ( ) ) { List < File > dirs = new ArrayList < File > ( ) ; dirs . add ( parent ) ; while ( true ) { parent = parent . getParentFile ( ) ; if ( parent == null ) { break ; } if ( parent . exists ( ) ) { break ; } dirs . add ( parent ) ; } Collections . reverse ( dirs ) ; for ( File dir : dirs ) { if ( ! dir . mkdir ( ) ) { throw new Exception ( "Unable to create directory: " + dir ) ; } dir . setReadable ( true , true ) ; dir . setWritable ( true , true ) ; dir . setExecutable ( true , true ) ; } } if ( ! file . exists ( ) ) { if ( ! file . createNewFile ( ) ) { throw new Exception ( "Unable to create file: " + file ) ; } } file . setWritable ( true , true ) ; file . setReadable ( true , true ) ; return file ; }
te	5	public static void main ( String [ ] args ) { Figura [ ] figuras = generaArrayFiguras ( 0.5 , 100 , 4 ) ; try { ObjectOutputStream writer = new ObjectOutputStream ( new FileOutputStream ( "test.dat" ) ) ; for ( Figura fig : figuras ) writer . writeObject ( fig ) ; writer . close ( ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } List < Figura > nuevaFiguras = new ArrayList < > ( ) ; ObjectInputStream reader = null ; try { reader = new ObjectInputStream ( new FileInputStream ( "test.dat" ) ) ; while ( true ) nuevaFiguras . add ( ( Figura ) reader . readObject ( ) ) ; } catch ( IOException | ClassNotFoundException ex ) { } System . out . println ( "Figuras:" ) ; for ( Figura fig : nuevaFiguras ) System . out . println ( fig ) ; }
te	6	public void run ( ) { for ( int i = 0 ; i <= wdh ; i ++ ) { if ( isInterrupted ( ) ) { i = 0 ; break ; } aktor . einschalten ( ) ; try { sleep ( pulse_ein ) ; } catch ( InterruptedException ie ) { interrupt ( ) ; } if ( isInterrupted ( ) ) { i = 0 ; break ; } aktor . ausschalten ( ) ; try { sleep ( pulse_aus ) ; } catch ( InterruptedException ie ) { interrupt ( ) ; } } if ( endbehavior ) { aktor . einschalten ( ) ; } else { aktor . ausschalten ( ) ; } }
te	9X	@ Override public int hashCode ( ) { int result ; long temp ; result = ( int ) ( id ^ ( id >>> 32 ) ) ; result = 31 * result + ( int ) ( version ^ ( version >>> 32 ) ) ; result = 31 * result + ( int ) ( problemId ^ ( problemId >>> 32 ) ) ; result = 31 * result + ( submission != null ? submission . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) evaluation ; result = 31 * result + ( submissionDate != null ? submissionDate . hashCode ( ) : 0 ) ; result = 31 * result + ( detailedLog ? 1 : 0 ) ; result = 31 * result + ( diffFile != null ? diffFile . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( languageId ^ ( languageId >>> 32 ) ) ; result = 31 * result + tries ; result = 31 * result + ( output != null ? output . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( userId ^ ( userId >>> 32 ) ) ; temp = double . doubleToLongBits ( time ) ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; result = 31 * result + ( problem != null ? problem . hashCode ( ) : 0 ) ; result = 31 * result + ( language != null ? language . hashCode ( ) : 0 ) ; result = 31 * result + ( inputTestCase != null ? inputTestCase . hashCode ( ) : 0 ) ; result = 31 * result + ( errorMsg != null ? errorMsg . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( idTestCase ^ ( idTestCase >>> 32 ) ) ; return result ; }
te	2	protected int lastDocId ( ArrayList < Integer > prevSkipInfo ) { if ( prevSkipInfo == null || prevSkipInfo . isEmpty ( ) ) return 0 ; else { return prevSkipInfo . get ( prevSkipInfo . size ( ) - 2 ) ; } }
te	7	private double niceNum ( double range , boolean round ) { double exponent ; double fraction ; double niceFraction ; exponent = Math . floor ( Math . log10 ( range ) ) ; fraction = range / Math . pow ( 10 , exponent ) ; if ( round ) { if ( fraction < 1.5 ) niceFraction = 1 ; else if ( fraction < 3 ) niceFraction = 2 ; else if ( fraction < 7 ) niceFraction = 5 ; else niceFraction = 10 ; } else { if ( fraction <= 1 ) niceFraction = 1 ; else if ( fraction <= 2 ) niceFraction = 2 ; else if ( fraction <= 5 ) niceFraction = 5 ; else niceFraction = 10 ; } return niceFraction * Math . pow ( 10 , exponent ) ; }
te	2	public < T > boolean checkExpect ( T actual , T expected , String testname ) { this . testname = testname ; return this . report ( this . inspector . exactTest ( ) && this . inspector . isSame ( actual , expected ) && ! this . inspector . inexactViolation ( ) , testname , "actual:                                 expected:\n" + Printer . combineActualExpected ( Printer . produceString ( actual ) , Printer . produceString ( expected ) ) + "\n" ) ; }
te	7	public void trackFile ( String str ) { Path path = Paths . get ( str ) ; WatchService watchService = null ; try { watchService = path . getFileSystem ( ) . newWatchService ( ) ; path . register ( watchService , StandardWatchEventKinds . ENTRY_MODIFY ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( ; ; ) { WatchKey key = null ; try { key = watchService . take ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { switch ( event . kind ( ) . name ( ) ) { case "OVERFLOW" : System . out . println ( "We lost some events!" ) ; break ; case "ENTRY_MODIFY" : System . out . println ( "File " + event . context ( ) + " is changed." ) ; break ; } } key . reset ( ) ; } }
te	4	private static int toIndex ( Direction dir ) { switch ( dir ) { case SOUTH : return 0 ; case NORTH : return 1 ; case WEST : return 2 ; case EAST : return 3 ; } return 0 ; }
te	1	public OutputStream ( java . io . OutputStream out , int options ) { super ( out ) ; this . breakLines = ( options & DO_BREAK_LINES ) != 0 ; this . encode = ( options & ENCODE ) != 0 ; this . bufferLength = encode ? 3 : 4 ; this . buffer = new byte [ bufferLength ] ; this . position = 0 ; this . lineLength = 0 ; this . suspendEncoding = false ; this . b4 = new byte [ 4 ] ; this . options = options ; this . decodabet = getDecodabet ( options ) ; }
te	0	public int getDoubleInJail ( ) { return this . doubleInWormhole ; }
te	3	public void run ( ) { Update ( ) ; while ( ! mDisconnected ) { if ( System . currentTimeMillis ( ) > mTimer ) { System . out . println ( "disconnected" ) ; mDisconnected = true ; } try { Thread . sleep ( 100 ) ; } catch ( Exception e ) { } } }
te	3	@ SuppressWarnings ( "unchecked" ) public static Map < String , Object > parseMap ( String json ) { ObjectMapper mapper = new ObjectMapper ( ) ; JsonFactory factory = mapper . getFactory ( ) ; JsonParser jp = null ; Map < String , Object > result = null ; try { jp = factory . createParser ( json ) ; result = jp . readValueAs ( HashMap . class ) ; } catch ( JsonParseException e ) { _logger . error ( "JsonParseException: " + e . getMessage ( ) ) ; } catch ( JsonProcessingException e ) { _logger . error ( "JsonProcessingException: " + e . getMessage ( ) ) ; } catch ( IOException e ) { _logger . error ( "IOException: " + e . getMessage ( ) ) ; } return result ; }
te	5	private static boolean includeNode ( IEclipsePreferences node ) { if ( node == null ) return false ; String nodeName = node . absolutePath ( ) ; String [ ] nodeParts = nodeName . split ( "/" , 5 ) ; if ( nodeParts . length < 2 ) return false ; if ( nodeParts . length == 2 ) if ( nodeParts [ 1 ] . compareTo ( "instance" ) == 0 || nodeParts [ 1 ] . compareTo ( "" ) == 0 ) return false ; return true ; }
te	2	public static List < Field > getFieldsByType ( Object object , class type ) { List < Field > list = new ArrayList < Field > ( ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getType ( ) . isAssignableFrom ( type ) ) { list . add ( field ) ; } } return list ; }
te	7	private void auswahl ( JButton b ) { b . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae ) { int isChecked = 0 ; int position = 0 ; for ( int i = 0 ; i < checkBoxen . size ( ) ; i ++ ) { if ( checkBoxen . get ( i ) . isSelected ( ) ) { isChecked = isChecked + 1 ; position = i ; } } if ( isChecked != 1 ) { System . out . println ( "nur eine Box markieren bitte" ) ; } else { System . out . println ( "Markiert: " + checkBoxen . get ( position ) . getText ( ) ) ; for ( Schoolclass s : schoolclasses ) { if ( s . getName ( ) . equals ( checkBoxen . get ( position ) . getText ( ) ) ) { final SchoolclassFrame schoolclassFrame = new SchoolclassFrame ( s ) ; schoolclassFrame . setLocation ( 275 , 225 ) ; break ; } } for ( Teacher t : teacher ) { if ( t . getAcronym ( ) . equals ( checkBoxen . get ( position ) . getText ( ) ) ) { final TeacherFrame teacherFrame = new TeacherFrame ( t ) ; teacherFrame . setLocation ( 275 , 225 ) ; break ; } } } } } ) ; }
te	7	private void calculateScores ( ) { resetScores ( ) ; Champion [ ] champions = getChampions ( ) ; Strategy [ ] strategies = Strategy . values ( ) ; for ( int i = 0 ; i < strategies . length ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( champions [ j ] != null && ( Initialiser . getMainFrame ( ) . getButtonPanel ( ) . isTacticEnabled ( i ) || j > 4 ) ) { float score = champions [ j ] . getScoreForStrategy ( strategies [ i ] ) ; if ( score > 0 ) scores [ ( j < 5 ) ? i : i + 5 ] += score ; } } } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainBoard ( ) . setVisible ( true ) ; } } ) ; }
te	0	public void addValue ( Object value ) { values_ . add ( value ) ; }
te	2	public static int nextPosition ( int startPosition , ArrayList < short > list ) { int offset = 1 ; int tempP = startPosition ; for ( ; tempP < list . size ( ) ; tempP ++ ) { if ( ( list . get ( tempP ) & 00000080 ) == 0 ) { offset ++ ; } else { break ; } } return startPosition + offset ; }
te	7	@ Override public Iterator < Color > iterator ( ) { return new Iterator < Color > ( ) { private int [ ] cs = null ; private boolean finalized = false ; private int [ ] next_coordinates ( int [ ] cs ) { if ( finalized ) return null ; if ( cs == null ) { cs = new int [ ] { 0 , 0 } ; } else { cs = cs . clone ( ) ; if ( cs [ 1 ] < ks [ cs [ 0 ] ] - 1 ) { cs [ 1 ] ++ ; return cs ; } else { cs [ 1 ] = 0 ; cs [ 0 ] ++ ; } } while ( cs [ 0 ] < Color . all . length && ks [ cs [ 0 ] ] == 0 ) cs [ 0 ] ++ ; if ( cs [ 0 ] >= Color . all . length ) { finalized = true ; return null ; } return cs ; } @ Override public boolean hasNext ( ) { return next_coordinates ( cs ) != null ; } @ Override public Color next ( ) { cs = next_coordinates ( cs ) ; if ( cs == null ) throw new NoSuchElementException ( ) ; return Color . all [ cs [ 0 ] ] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
te	6	public void findAllChildrenByName ( ArrayList < Tag > result , String name , boolean recursive ) { if ( result == null ) { result = new ArrayList < Tag > ( ) ; } if ( list != null ) { for ( Tag t : list ) { if ( t . getName ( ) != null ) { if ( t . getName ( ) . equals ( name ) ) { result . add ( t ) ; } } if ( recursive ) { t . findAllChildrenByName ( result , name , true ) ; } } } }
te	2	public double windowQueryExt ( double [ ] lowk , double [ ] uppk , boolean printWindow , int optLevel ) { double [ ] lowEff = new double [ 2 ] ; double [ ] uppEff = new double [ 2 ] ; double [ ] spaceBound = GPSLib . getSpaceBound ( lowk , uppk ) ; lowEff [ 0 ] = spaceBound [ 0 ] ; uppEff [ 0 ] = spaceBound [ 1 ] ; lowEff [ 1 ] = spaceBound [ 2 ] ; uppEff [ 1 ] = spaceBound [ 3 ] ; Object [ ] objs = ( Object [ ] ) this . range ( lowEff , uppEff ) ; List < Temporal > points = new ArrayList < Temporal > ( ) ; for ( int i = 0 ; i < objs . length ; ++ i ) { points . add ( ( Temporal ) objs [ i ] ) ; } CoverageWindow wc = new CoverageWindow ( lowk , uppk , points ) ; if ( optLevel == 1 ) return wc . calcWindowOpt ( printWindow ) ; else return wc . calcWindow ( printWindow ) ; }
te	2	public void addPrefix ( String s ) { if ( prefix != null ) { this . prefix = s + this . prefix ; } else { for ( HuffmanNode n : children ) { n . addPrefix ( s ) ; } } }
te	7	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) . equals ( back ) ) { Window . current . toPane ( Window . current . menuPane ) ; } else if ( e . getSource ( ) . equals ( soundToggle ) ) { SettingsManager . put ( "sound" , new boolean ( soundToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; soundToggle . setText ( soundToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; } else if ( e . getSource ( ) . equals ( fsToggle ) ) { SettingsManager . put ( "fullscreen" , new boolean ( fsToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; fsToggle . setText ( fsToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; Window . current . setFullscreen ( SettingsManager . get ( "fullscreen" ) . equals ( "true" ) ) ; } else if ( e . getSource ( ) . equals ( beginToggle ) ) { SettingsManager . put ( "beginner" , new boolean ( beginToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; beginToggle . setText ( beginToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; } }
te	7	@ Override public ServerPacket getResponse ( ) { if ( data . length != 4 ) return new BadPacket ( ) ; byte flavor1 = data [ 1 ] ; byte flavor2 = data [ 2 ] ; byte rating = data [ 3 ] ; try { if ( flavor1 == flavor2 ) return new ErrorMessagePacket ( "Flavors are the same." ) ; if ( rating < 0 || rating > 5 ) return new ErrorMessagePacket ( "Rating must be from 0 to 5." ) ; Map < Integer , String > flavors = CookOutAppServer . getDatabase ( ) . getFlavors ( ) ; if ( flavors . get ( Integer . valueOf ( flavor1 ) ) == null || flavors . get ( Integer . valueOf ( flavor2 ) ) == null ) return new ErrorMessagePacket ( "Flavors don't exist." ) ; CookOutAppServer . getDatabase ( ) . rateCombo ( new ComboRating ( flavor1 , flavor2 , 1 , rating ) ) ; } catch ( SQLException e ) { return new ErrorMessagePacket ( "Server SQL error" ) ; } return new OKPacket ( ) ; }
te	7	public String columnsToGraphviz ( Network network ) { beginHeader ( ) ; { int pos = 0 ; for ( ColumnNode column : network . columnNodes ( ) ) { addHead ( column . base , column . size , pos ) ; for ( Node node = column . base . top ; node != column . base ; node = node . top ) { addNode ( node , pos ) ; } pos ++ ; } for ( ColumnNode column : network . columnNodes ( ) ) { addEdge ( column . base , "B" , column . base . top , "L" ) ; for ( Node node = column . base . top ; node != column . base ; node = node . top ) { if ( getColumn ( node . left ) < getColumn ( node ) ) { addEdge ( node , "L" , node . left , "T" ) ; } if ( getColumn ( node ) < getColumn ( node . right ) ) { addEdge ( node , "R" , node . right , "B" ) ; } addEdge ( node , "T" , node . bottom , "R" ) ; if ( node . top != column . base ) { addEdge ( node , "B" , node . top , "L" ) ; } } } } endHeader ( ) ; return sb . toString ( ) ; }
te	7	public void AnalyseDirectory ( String dir ) { File F = new File ( dir ) ; String [ ] fi = F . list ( ) ; String of ; File fil = new File ( dir + "/dist/" ) ; if ( ! fil . exists ( ) ) { fil . mkdir ( ) ; } for ( String f : fi ) { if ( new File ( f ) . isDirectory ( ) ) continue ; if ( ! f . endsWith ( ".res" ) ) continue ; of = dir + "/dist/" + f . substring ( 0 , f . length ( ) - 4 ) + "_dist.txt" ; StreamedLinkSet L = new StreamedLinkSet ( dir + "/" + f ) ; LinkSetNode n ; L . initTreeTraversal ( ) ; Frequency Fr = new Frequency ( ) ; Set < Integer > S = new HashSet < Integer > ( ) ; System . out . println ( "Processing " + f ) ; while ( ( n = L . getNextInOrder ( ) ) != null ) { Fr . addValue ( n . w ) ; S . add ( n . w ) ; } List < Integer > k = General . asSortedList ( S ) ; try { FileWriter out = new FileWriter ( of ) ; System . out . println ( "Writing to: " + of ) ; for ( int i : k ) { out . write ( i + " " + Fr . getCumPct ( i ) + " " + Fr . getPct ( i ) + " " + Fr . getCount ( i ) + " \n" ) ; } out . flush ( ) ; out . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( LinkSetAnalyser . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
te	1	public String optString ( int index , String defaultValue ) { Object object = this . opt ( index ) ; return JSONObject . null . equals ( object ) ? defaultValue : object . toString ( ) ; }
te	9X	private boolean check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { double [ ] x = primal ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { double [ ] y = dual ( ) ; for ( int j = 0 ; j < N ; j ++ ) { double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
te	1	private int initialize ( ) { int noOfIntReg = IntRegC . values ( ) . length ; for ( int index = 0 ; index < noOfIntReg ; index ++ ) { IntegerRegister intReg = new IntegerRegister ( "0" , IntRegC . values ( ) [ index ] . toString ( ) ) ; intRegBank . add ( intReg ) ; } return 0 ; }
te	8	public void update ( GameContainer gc , StateBasedGame sbg , int delta ) throws SlickException { this . inputCounter -= delta ; Input input = gc . getInput ( ) ; mouse . x = input . getMouseX ( ) ; mouse . y = input . getMouseY ( ) ; boolean click = input . isMouseButtonDown ( Input . MOUSE_LEFT_BUTTON ) ; if ( inputCounter < 0 ) { this . etatEditor = GestionClavier . gererClavier ( input , coordCarte , etatEditor , map , sbg ) ; switch ( etatEditor ) { case EDITOR : effetsCarteME . selection ( mouse , click , map , coordCarte , selec ) ; break ; case BLOCKS : etatEditor = listeBlocksME . selection ( mouse , click , effetsCarteME , etatEditor , selec ) ; break ; case OBJETS : etatEditor = listeObjetsME . selection ( mouse , click , effetsCarteME , etatEditor , selec ) ; break ; } if ( coordCarte . x > tailleMap . x || coordCarte . y < - tailleMap . x ) coordCarte . x = MathPerso . mod ( coordCarte . x , tailleMap . x ) ; if ( coordCarte . y > tailleMap . y || coordCarte . y < - tailleMap . y ) coordCarte . y = MathPerso . mod ( coordCarte . y , tailleMap . y ) ; inputCounter = 70 ; } }
te	3	@ Override public AuthorizationRequest authorize ( ) { if ( ready ) { ready = false ; if ( tokenRequest != null ) { try { tokenRequest . join ( THREAD_JOIN_TIMEOUT ) ; } catch ( InterruptedException e ) { } } tokenRequest = new Thread ( ) { @ Override public void run ( ) { obtainAccessToken ( ) ; } } ; } String queryString = URLEncodedUtils . format ( Utils . mapToList ( authorizeParams ) , "UTF-8" ) ; return new AuthorizationRequest ( authorizeServer + "?" + queryString ) ; }
te	3	@ Test public void testDBit ( ) throws Exception { final File dir = File . createTempFile ( "SQLScrewdriverJUnitTest_" , ".db" ) ; dir . delete ( ) ; dir . mkdir ( ) ; final String dbName = new File ( dir , "H2DB" ) . getAbsolutePath ( ) ; final String comment = "JunitTestDB" ; final String dbUserName = "JunitTestDB" ; final String dbPassword = "JunitTestDB" ; final String dbURL = "jdbc:h2:" + dbName ; final String driver = "org.h2.Driver" ; final String colQuote = "\"" ; final boolean readOnly = false ; final DBHandle dbhandle = DBUtil . buildConnection ( comment , dbUserName , dbPassword , dbURL , driver , readOnly , colQuote ) ; Exception ex = null ; try { final Statement stmt = dbhandle . conn . createStatement ( ) ; stmt . executeUpdate ( "CREATE TABLE TESTTAB (IARG INT  SARG VARCHAR(128)  BIARG NUMERIC(30)  BNARG NUMERIC(30 20)  DARG DOUBLE PRECISION)" ) ; final PreparedStatement pstmt = dbhandle . conn . prepareStatement ( "INSERT INTO TESTTAB (IARG  SARG  BIARG  BNARG  DARG) VALUES (?  ?  ?  ?  ?)" ) ; pstmt . setInt ( 1 , 7 ) ; pstmt . setString ( 2 , "hi there" ) ; pstmt . setBigDecimal ( 3 , new BigDecimal ( BigInteger . TEN ) ) ; pstmt . setBigDecimal ( 4 , new BigDecimal ( new BigInteger ( "123" ) , 2 ) ) ; pstmt . setDouble ( 5 , 1.7 ) ; pstmt . executeUpdate ( ) ; pstmt . close ( ) ; final DBIterable it = new DBIterable ( stmt , "SELECT * FROM TESTTAB" ) ; long n = 0 ; for ( final BurstMap row : it ) { final long vIARG = row . getAsLong ( "IARG" ) ; final String vSARG = row . getAsString ( "SARG" ) ; final long vBIARG = row . getAsLong ( "BIARG" ) ; final double vBNARG = row . getAsDouble ( "BNARG" ) ; final double vDARG = row . getAsDouble ( "DARG" ) ; assertEquals ( 7 , vIARG ) ; assertEquals ( "hi there" , vSARG ) ; assertEquals ( 10 , vBIARG ) ; assertTrue ( Math . abs ( 1.23 - vBNARG ) < 1.0e-10 ) ; assertTrue ( Math . abs ( 1.7 - vDARG ) < 1.0e-10 ) ; ++ n ; } assertEquals ( 1 , n ) ; stmt . close ( ) ; } catch ( Exception e ) { ex = e ; } finally { dbhandle . conn . close ( ) ; rmDir ( dir ) ; } if ( null != ex ) { throw ex ; } }
te	9X	public V put ( int key , V value ) { if ( key == 0 ) { V oldValue = zeroValue ; zeroValue = value ; if ( ! hasZeroValue ) { hasZeroValue = true ; size ++ ; } return oldValue ; } int [ ] keyTable = this . keyTable ; int index1 = key & mask ; int key1 = keyTable [ index1 ] ; if ( key1 == key ) { V oldValue = valueTable [ index1 ] ; valueTable [ index1 ] = value ; return oldValue ; } int index2 = hash2 ( key ) ; int key2 = keyTable [ index2 ] ; if ( key2 == key ) { V oldValue = valueTable [ index2 ] ; valueTable [ index2 ] = value ; return oldValue ; } int index3 = hash3 ( key ) ; int key3 = keyTable [ index3 ] ; if ( key3 == key ) { V oldValue = valueTable [ index3 ] ; valueTable [ index3 ] = value ; return oldValue ; } for ( int i = capacity , n = i + stashSize ; i < n ; i ++ ) { if ( keyTable [ i ] == key ) { V oldValue = valueTable [ i ] ; valueTable [ i ] = value ; return oldValue ; } } if ( key1 == EMPTY ) { keyTable [ index1 ] = key ; valueTable [ index1 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } if ( key2 == EMPTY ) { keyTable [ index2 ] = key ; valueTable [ index2 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } if ( key3 == EMPTY ) { keyTable [ index3 ] = key ; valueTable [ index3 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } push ( key , value , index1 , key1 , index2 , key2 , index3 , key3 ) ; return null ; }
te	5	void totalize ( ) { State s = new State ( ) ; s . transitions . add ( new Transition ( Character . MIN_VALUE , Character . MAX_VALUE , s ) ) ; for ( State p : getStates ( ) ) { int maxi = Character . MIN_VALUE ; for ( Transition t : p . getSortedTransitions ( false ) ) { if ( t . min > maxi ) p . transitions . add ( new Transition ( ( char ) maxi , ( char ) ( t . min - 1 ) , s ) ) ; if ( t . max + 1 > maxi ) maxi = t . max + 1 ; } if ( maxi <= Character . MAX_VALUE ) p . transitions . add ( new Transition ( ( char ) maxi , Character . MAX_VALUE , s ) ) ; } }
te	5	private static void method340 ( int i , int j , int k , int l , int i1 ) { if ( k < topY || k >= bottomY ) return ; if ( i1 < topX ) { j -= topX - i1 ; i1 = topX ; } if ( i1 + j > bottomX ) j = bottomX - i1 ; int j1 = 256 - l ; int k1 = ( i >> 16 & ff ) * l ; int l1 = ( i >> 8 & ff ) * l ; int i2 = ( i & ff ) * l ; int i3 = i1 + k * width ; for ( int j3 = 0 ; j3 < j ; j3 ++ ) { int j2 = ( pixels [ i3 ] >> 16 & ff ) * j1 ; int k2 = ( pixels [ i3 ] >> 8 & ff ) * j1 ; int l2 = ( pixels [ i3 ] & ff ) * j1 ; int k3 = ( ( k1 + j2 >> 8 ) << 16 ) + ( ( l1 + k2 >> 8 ) << 8 ) + ( i2 + l2 >> 8 ) ; pixels [ i3 ++ ] = k3 ; } }
te	1	void addObject ( JGObject obj ) { int idx = objects . get ( obj . getName ( ) ) ; if ( idx >= 0 ) { JGObject old_obj = ( JGObject ) objects . values [ idx ] ; old_obj . removeDone ( ) ; old_obj . remove ( ) ; } objects . put ( obj . getName ( ) , obj ) ; }
te	2	public SchemeObject doWhile ( SchemeObject exp , SchemeObject env ) { SchemeObject predicate = whilePredicate ( exp ) ; SchemeObject body = whileBody ( exp ) ; SchemeObject result = SchemeObject . THE_EMPTY_LIST ; while ( SchemeObject . isTrue ( eval ( predicate , env ) ) ) { SchemeObject exps = body ; while ( ! isLastExp ( exps ) ) { eval ( firstExp ( exps ) , env ) ; exps = exps . getCdr ( ) ; } result = eval ( firstExp ( exps ) , env ) ; } return result ; }
te	7	public void run ( ) { final String methodName = "run" ; MqttToken token = null ; while ( running && ( in != null ) ) { try { log . fine ( className , methodName , "852" ) ; MqttWireMessage message = in . readMqttWireMessage ( ) ; if ( message instanceof MqttAck ) { token = tokenStore . getToken ( message ) ; if ( token != null ) { synchronized ( token ) { clientState . notifyReceivedAck ( ( MqttAck ) message ) ; } } else { throw new MqttException ( MqttException . REASON_CODE_UNEXPECTED_ERROR ) ; } } else { clientState . notifyReceivedMsg ( message ) ; } } catch ( MqttException ex ) { log . fine ( className , methodName , "856" , null , ex ) ; running = false ; clientComms . shutdownConnection ( token , ex ) ; } catch ( IOException ioe ) { log . fine ( className , methodName , "853" ) ; running = false ; if ( ! clientComms . isDisconnecting ( ) ) { clientComms . shutdownConnection ( token , new MqttException ( MqttException . REASON_CODE_CONNECTION_LOST , ioe ) ) ; } } } log . fine ( className , methodName , "854" ) ; }
te	5	private static Set < String > parenthesis ( int i ) { if ( i == 0 ) { Set < String > list = new HashSet < > ( ) ; list . add ( "" ) ; return list ; } Set < String > list = parenthesis ( i - 1 ) ; Set < String > compList = new HashSet < > ( ) ; for ( String paren : list ) { for ( int index = 0 ; index < paren . length ( ) ; index ++ ) { if ( paren . charAt ( index ) == ( ) { String str = insertChar ( paren , index ) ; compList . add ( str ) ; } } if ( ! compList . contains ( "()" + paren ) ) { compList . add ( "()" + paren ) ; } } return compList ; }
te	0	public static void resetCounter ( ) { counter = 0 ; }
te	0	private OrderManager ( ) { }
te	2	public List < MultiplicitiesVector > findMulVectorsSummingExactlyTo ( int level ) { if ( vecsOfLevelEndAt . containsKey ( level ) ) { int startFrom ; if ( level > 0 ) { startFrom = vecsOfLevelEndAt . get ( level - 1 ) ; } else { startFrom = 0 ; } return storedVectors . subList ( startFrom , vecsOfLevelEndAt . get ( level ) ) ; } else { findMulVectorsSummingUpTo ( level ) ; List < MultiplicitiesVector > toRet = findMulVectorsSummingExactlyTo ( level ) ; return toRet ; } }
te	2	public synchronized static int insert ( Integer supplierID , double price , String productName , String productDescription , boolean inStock ) throws SQLException { Connection connection = null ; PreparedStatement prepStmt = null ; try { connection = DB . getConnection ( ) ; connection . setAutoCommit ( true ) ; int insertedID = - 1 ; String sql = "INSERT INTO Product (SupplierID  Price  ProductName  ProductDescription  InStock) VALUES (? ? ? ? ?);" ; prepStmt = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; prepStmt . setInt ( 1 , supplierID ) ; prepStmt . setDouble ( 2 , price ) ; prepStmt . setString ( 3 , productName ) ; prepStmt . setString ( 4 , productDescription ) ; prepStmt . setBoolean ( 5 , inStock ) ; prepStmt . executeUpdate ( ) ; ResultSet rs = prepStmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { insertedID = rs . getInt ( 1 ) ; } prepStmt . close ( ) ; DB . closeConnection ( ) ; return insertedID ; } catch ( Exception e ) { throw e ; } }
te	1	public static void main ( String [ ] args ) { kmpNext ( "ABCDABD" ) ; if ( kmp ( "ABC ABCDAB ABCDABCDABDE" , "ABCDABD" ) ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
te	4	public Main ( ) { lf = new LinkFilter ( ) ; knnc = new KNNControl ( lf ) ; knnc . setVisible ( true ) ; Datasource loggin = new Datasource ( lf , null ) ; int [ ] motes = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; for ( int i : motes ) { for ( int j = 0 ; j < 10 ; j ++ ) { loggin . sendConfig ( i , 50 , 31 ) ; } for ( int j : motes ) { if ( i != j ) { addLink ( i , j ) ; } } } }
te	4	public static String [ ] mergeStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( ObjectUtils . isEmpty ( array1 ) ) { return array2 ; } if ( ObjectUtils . isEmpty ( array2 ) ) { return array1 ; } List < String > result = new ArrayList < String > ( ) ; result . addAll ( Arrays . asList ( array1 ) ) ; for ( String str : array2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return toStringArray ( result ) ; }
te	0	@ Override public void setTileHeight ( float tileHeight ) { this . tileHeight = tileHeight ; }
te	0	public JSTableDialog ( String title , String [ ] headings , int rows ) { this ( title , headings , getDefaultButtonArray ( ) , rows ) ; }
te	1	public Type isFieldDefined ( String id , Type type ) { if ( ! ( type instanceof StructType ) ) return null ; StructType structType = ( StructType ) type ; return structType . getType ( id ) ; }
te	3	public void testShortUrlGenerationWithMRUCache ( ) { MRUHashtable < String , String > mruCache = new MRUHashtable < String , String > ( 1000 ) ; ShortUrl min = ShortUrl . getMinShortUrl ( ) ; ShortUrlGenerator . instance ( ) . initialize ( min ) ; try { for ( int i = 0 ; i < 10000 ; ++ i ) { String key = "Key" + i ; String s = ShortUrlGenerator . instance ( ) . getNextShortUrl ( ) . getUrlString ( ) ; System . out . println ( "\nGenerated " + i + " short url:" + s ) ; mruCache . put ( key , s ) ; } } catch ( ShortUrlGeneratorNotInitialized e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( ShortUrlGenerationFailed e ) { System . out . println ( e . getMessage ( ) ) ; } }
te	4	@ Override public synchronized void log ( Object message , Throwable t , Level level ) { if ( level . isGreaterOrEqualThan ( logLevel ) ) { if ( message != null ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , message . toString ( ) ) ) ; } if ( t != null ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , t . toString ( ) ) ) ; for ( StackTraceElement elemet : t . getStackTrace ( ) ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , elemet . toString ( ) ) ) ; } } } }
te	6	public String nextString ( char quote ) throws JSONException { StringBuilder builder = null ; int start = pos ; while ( pos < in . length ( ) ) { int c = in . charAt ( pos ++ ) ; if ( c == quote ) { if ( builder == null ) { return new String ( in . substring ( start , pos - 1 ) ) ; } else { builder . append ( in , start , pos - 1 ) ; return builder . toString ( ) ; } } if ( c == \ ) { if ( pos == in . length ( ) ) { throw syntaxError ( "Unterminated escape sequence" ) ; } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( in , start , pos - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } throw syntaxError ( "Unterminated string" ) ; }
te	5	public ArimaaMove ( String move_text ) { clear ( ) ; this . steps = 4 ; int stepNumber = 0 ; StringTokenizer tokenizer = new StringTokenizer ( move_text ) ; while ( tokenizer . hasMoreTokens ( ) ) { String move = tokenizer . nextToken ( ) ; if ( move . equals ( "pass" ) ) { break ; } int piece_type = piece_type_from_text ( move . substring ( 0 , 1 ) ) ; assert ( piece_type >= 0 && piece_type <= 11 ) ; String col_text = "abcdefgh" ; int col = col_text . indexOf ( move . substring ( 1 , 2 ) ) ; int row = Integer . parseInt ( move . substring ( 2 , 3 ) ) - 1 ; String dir_text = "nsewx" ; int direction = dir_text . indexOf ( move . substring ( 3 , 4 ) ) ; if ( direction == 4 ) { int index = row * 8 + col ; this . piece_bb [ piece_type ] ^= 1 << index ; } if ( direction != 4 ) { int from_index = row * 8 + col ; int dir_offset [ ] = { 8 , - 8 , 1 , - 1 , 0 } ; int to_index = from_index + dir_offset [ direction ] ; this . piece_bb [ piece_type ] ^= 1 << from_index ; this . piece_bb [ piece_type ] ^= 1 << to_index ; stepSources [ stepNumber ++ ] = ( byte ) from_index ; } } }
te	6	private void process_interpage_shared_properties ( ) throws Exception { Set < String > unique_urls = interpage_shared_properties . keySet ( ) ; for ( String url_1 : unique_urls ) { for ( String url_2 : unique_urls ) { if ( url_1 . equals ( url_2 ) == false ) { System . out . println ( "\n\n^^^^^^^^^ " + url_1 + " : " + url_2 + "\n" ) ; float url_similarity = score_mapset ( interpage_shared_properties . get ( url_1 ) , interpage_shared_properties . get ( url_2 ) ) ; if ( url_similarity > 12f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/high_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/medium_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/low_similarity> <" + url_2 + "> ." ) ; } } } } }
te	7	private static void load ( String workloadFile ) throws IOException , ParseException { DateFormat sdf = new SimpleDateFormat ( "d HH:mm:ss" ) ; int currentStep = 0 ; Date lastTimeGrain = null ; double max = 0 ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( WorkloadGenerator . class . getResourceAsStream ( workloadFile ) ) ) ; String line = reader . readLine ( ) ; double tracesHour = 0 ; double currentWorkload = 0 ; while ( line != null && currentStep < basePercentage . length ) { StringTokenizer tokens = new StringTokenizer ( line ) ; tokens . nextToken ( ) ; tracesHour ++ ; currentWorkload += long . parseLong ( tokens . nextToken ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { tokens . nextToken ( ) ; } Date currentTimeGrain = sdf . parse ( tokens . nextToken ( ) + " " + tokens . nextToken ( ) ) ; if ( lastTimeGrain == null ) { lastTimeGrain = currentTimeGrain ; } if ( currentTimeGrain . getTime ( ) - lastTimeGrain . getTime ( ) >= WL_GRANULARITY_MS ) { currentWorkload /= tracesHour ; basePercentage [ currentStep ++ ] = currentWorkload ; if ( currentWorkload > max ) { max = currentWorkload ; } currentWorkload = 0 ; tracesHour = 0 ; lastTimeGrain = currentTimeGrain ; } line = reader . readLine ( ) ; } for ( int i = 0 ; i < basePercentage . length ; i ++ ) { basePercentage [ i ] /= max ; } }
te	6	public boolean isSubsetSum ( int [ ] nums , int sum ) { boolean [ ] [ ] cache = new boolean [ nums . length + 1 ] [ sum + 1 ] ; Arrays . sort ( nums ) ; System . out . println ( ) ; for ( int i = 1 ; i <= nums . length && nums [ i - 1 ] <= sum ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( cache [ i - 1 ] [ j ] == true ) { cache [ i ] [ j ] = true ; } else if ( nums [ i - 1 ] == j ) { cache [ i ] [ j ] = true ; } else if ( j > nums [ i - 1 ] ) { int remainder = j - nums [ i - 1 ] ; cache [ i ] [ j ] = cache [ i - 1 ] [ remainder ] ; } } } print2dArray ( cache , nums , sum ) ; return cache [ nums . length ] [ sum ] ; }
te	8	public static File getRelativeFile ( File target , File base ) throws IOException { String [ ] baseComponents = base . getCanonicalPath ( ) . split ( Pattern . quote ( File . separator ) ) ; String [ ] targetComponents = target . getCanonicalPath ( ) . split ( Pattern . quote ( File . separator ) ) ; int index = 0 ; for ( ; index < targetComponents . length && index < baseComponents . length ; ++ index ) { if ( ! targetComponents [ index ] . equals ( baseComponents [ index ] ) ) break ; } StringBuilder result = new StringBuilder ( ) ; if ( index != baseComponents . length ) { for ( int i = index ; i < baseComponents . length ; ++ i ) result . append ( ".." + File . separator ) ; } for ( ; index < targetComponents . length ; ++ index ) result . append ( targetComponents [ index ] + File . separator ) ; if ( ! target . getPath ( ) . endsWith ( "/" ) && ! target . getPath ( ) . endsWith ( "\\" ) ) { result . delete ( result . length ( ) - File . separator . length ( ) , result . length ( ) ) ; } return new File ( result . toString ( ) ) ; }
te	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } ReferenceProperty < ? > other = ( ReferenceProperty < ? > ) obj ; if ( reference == null ) { if ( other . reference != null ) { return false ; } } else if ( ! reference . equals ( other . reference ) ) { return false ; } return true ; }
te	3	static Window getWindowForComponent ( Component parentComponent ) throws HeadlessException { if ( parentComponent == null ) return JOptionPane . getRootFrame ( ) ; if ( parentComponent instanceof Frame || parentComponent instanceof Dialog ) return ( Window ) parentComponent ; return getWindowForComponent ( parentComponent . getParent ( ) ) ; }
te	3	public RoutePath ( String inLine , HashMap < String , Trip > tripMap ) { mID = sNextID ; sNextID ++ ; sRoutePathMap . put ( mID , this ) ; mPath = new ArrayList < > ( ) ; String [ ] f = CSVParser . parseLine ( inLine ) ; for ( String s : f ) { s = s . replaceAll ( "\"" , "" ) ; if ( tripMap . get ( s ) != null ) { mPath . add ( tripMap . get ( s ) ) ; } } if ( mPath . size ( ) > 0 ) { mRoute = mPath . get ( 0 ) . getRoute ( ) ; } else { mRoute = null ; } mStartTimecode = - 1 ; mEndTimecode = Integer . MIN_VALUE ; buildStopList ( ) ; }
te	6	public Result ValidarEdicionRol ( Rol pRol ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ( Common . IsMinorOrEqualsZero ( pRol . getCodigoRol ( ) ) ) ? ".C\u00F3digo inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pRol . getNombreRol ( ) ) ) ? ".Nombre inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pRol . getDescripcionRol ( ) ) ) ? ".Descripci\u00F3n inv\u00E1lida\n" : "" ) ; sb . append ( ( pRol . getModulos ( ) == null || Common . IsMinorOrEqualsZero ( pRol . getModulos ( ) . size ( ) ) ) ? ".El rol no tiene m\u00F3dulos asignados\n" : "" ) ; if ( ! Common . IsMinorOrEqualsZero ( sb . length ( ) ) ) return new Result ( ResultType . Error , "Valide los campos antes de modificar." , sb . toString ( ) ) ; else return new Result ( ResultType . Ok , "La validaci\u00F3n pas\u00F3 sin errores." , null ) ; }
te	3	@ Override public boolean rotateRight ( Token [ ] [ ] tokens , int [ ] [ ] currentTokens , int rotateCount ) { if ( rotateCount % 4 == 0 ) { x0 = currentTokens [ 0 ] [ 0 ] + 2 ; y0 = currentTokens [ 0 ] [ 1 ] - 1 ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] + 1 ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 2 ; } else if ( rotateCount % 4 == 1 ) { x0 = currentTokens [ 0 ] [ 0 ] - 2 ; y0 = currentTokens [ 0 ] [ 1 ] + 2 ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else if ( rotateCount % 4 == 2 ) { x0 = currentTokens [ 0 ] [ 0 ] + 1 ; y0 = currentTokens [ 0 ] [ 1 ] - 2 ; x1 = currentTokens [ 1 ] [ 0 ] ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] - 1 ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 2 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else { x0 = currentTokens [ 0 ] [ 0 ] - 1 ; y0 = currentTokens [ 0 ] [ 1 ] + 1 ; x1 = currentTokens [ 1 ] [ 0 ] ; y1 = currentTokens [ 1 ] [ 1 ] ; x2 = currentTokens [ 2 ] [ 0 ] + 1 ; y2 = currentTokens [ 2 ] [ 1 ] - 1 ; x3 = currentTokens [ 3 ] [ 0 ] + 2 ; y3 = currentTokens [ 3 ] [ 1 ] - 2 ; } return setCurrentTokens ( currentTokens ) ; }
te	1	private boolean test ( String text ) { try { Integer . parseInt ( text ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }
te	4	@ Override public int compareTo ( JTimePicker B ) { JTimePicker A = this ; int hourA = A . getHour ( ) ; int minA = A . getMinute ( ) ; int hourB = B . getHour ( ) ; int minB = B . getMinute ( ) ; if ( hourA < hourB ) { return - 1 ; } else if ( hourA > hourB ) { return 1 ; } if ( minA < minB ) { return - 1 ; } else if ( minA > minB ) { return 1 ; } return 0 ; }
te	0	public Browser ( TreeBrowser br , int x , int y ) { super ( "CLASBrowser" ) ; this . setSize ( 1000 , 700 ) ; this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; this . initComponents ( x , y ) ; this . setTreeBrowser ( br ) ; this . pack ( ) ; this . setVisible ( true ) ; }
te	5	@ Override public void gameChanged ( final GameControllerEvent event ) { switch ( event . currentState ) { case GAME_STATE_RUNNING : for ( final Cell cell : event . changes ) { final int x = cell . x - 1 ; final int y = cell . y - 1 ; elements [ y ] [ x ] . setIcon ( event . map . get ( cell ) . getGraphics ( ) ) ; } break ; default : if ( event . currentState != state ) { System . out . println ( event . currentScore ) ; } } if ( state == null || state != event . currentState ) { state = event . currentState ; } }
te	0	@ Override public List < POS [ ] > getPOSPairs ( ) { return posPairs ; }
te	0	public int getRadius ( ) { return radius ; }
te	7	public void withdraw ( ) { String number = currentAccountNumber ( ) ; if ( number != null ) { String s = JOptionPane . showInputDialog ( this , "Enter amount to draw:" , "Draw Money" , JOptionPane . QUESTION_MESSAGE ) ; if ( s != null ) { try { double amount = double . parseDouble ( s ) ; Account a = accounts . get ( number ) ; a . withdraw ( amount ) ; fld_balance . setText ( currencyFormat ( a . getBalance ( ) ) ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Illegal Value" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IllegalArgumentException e ) { JOptionPane . showMessageDialog ( this , "Illegal Argument" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InactiveException e ) { JOptionPane . showMessageDialog ( this , "Account is inactive" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( OverdrawException e ) { JOptionPane . showMessageDialog ( this , "Account must not be overdrawn" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( Exception e ) { error ( e ) ; } } } }
te	2	public boolean wordExists ( String s ) { TrieNode node = root ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; Map < Character , TrieNode > characters = node . getCharacters ( ) ; if ( ! characters . containsKey ( c ) ) { return false ; } else { node = characters . get ( c ) ; } } return node . isWord ( ) ; }
te	0	@ Override public boolean esProducto ( ) { return false ; }
te	2	public PluginLoader ( ) throws FileNotFoundException { pluginDirectory = new File ( "plugins/" ) ; if ( ! pluginDirectory . exists ( ) ) { throw new FileNotFoundException ( "Unable to find the plugins directory" ) ; } if ( ! pluginDirectory . isDirectory ( ) ) { throw new FileNotFoundException ( "Unable to find the plugins directory" ) ; } }
te	1	private ArgListCodeFragment convertParamList ( ArgListCodeFragment paramList , Function f , CodePosition p ) { ArgListCodeFragment code = new ArgListCodeFragment ( ) ; code . appendCodeFragment ( paramList ) ; for ( int i = 0 ; i < paramList . getArgs ( ) . size ( ) ; i ++ ) { Variable v = paramList . getArgs ( ) . get ( i ) ; Type t = f . getParams ( ) . get ( i ) . getType ( ) ; code . appendCodeFragment ( variableTypeConvert ( v , t , p ) ) ; code . addArg ( new Variable ( code . getInfo ( ) , code . getRegister ( ) , code . getType ( ) ) ) ; } return code ; }
te	4	public static boolean canWriteLetterFromMagazine5 ( String letter , String magazine ) { int [ ] magazineCharCounts = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { magazineCharCounts [ i ] = 0 ; } char [ ] letterCharArray = letter . toCharArray ( ) ; char [ ] magazineCharArray = magazine . toCharArray ( ) ; for ( int i = 0 ; i < magazineCharArray . length ; i ++ ) { char chr = magazineCharArray [ i ] ; magazineCharCounts [ chr - a ] ++ ; } for ( int i = 0 ; i < letterCharArray . length ; i ++ ) { char chr = letterCharArray [ i ] ; if ( -- magazineCharCounts [ chr - a ] < 0 ) return false ; } return true ; }
te	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof MsgType ) ) { return false ; } final MsgType _cast = ( MsgType ) _other ; if ( msgType == null ? _cast . msgType != msgType : ! msgType . equals ( _cast . msgType ) ) { return false ; } return true ; }
te	7	public static void main ( String [ ] args ) { if ( ! ApplicationHelper . SHOW_ERROR ) { System . err . close ( ) ; } boolean color = false ; if ( args . length > 0 && args [ 0 ] . equals ( "-color" ) ) { color = true ; } BufferedReader br = null ; List < String > questions = new ArrayList < String > ( ) ; List < String > answers = new ArrayList < String > ( ) ; try { String line ; br = new BufferedReader ( new FileReader ( new File ( Settings . get ( "TEST_PATH" ) ) ) ) ; while ( ( line = br . readLine ( ) ) != null ) { questions . add ( ApplicationHelper . stripPunctuation ( line ) ) ; } br = new BufferedReader ( new FileReader ( new File ( Settings . get ( "TEST_RESULT_PATH" ) ) ) ) ; Integer i = 1 ; while ( ( line = br . readLine ( ) ) != null ) { if ( line . startsWith ( i . toString ( ) ) ) { answers . add ( line ) ; i ++ ; } else { answers . set ( i - 2 , answers . get ( i - 2 ) . concat ( " / " + line ) ) ; } } br . close ( ) ; String [ ] appArgs = new String [ questions . size ( ) ] ; questions . toArray ( appArgs ) ; System . out . printf ( "Test data: %d questions\n" , appArgs . length ) ; Application . answer ( appArgs , answers , color ) ; } catch ( IOException e ) { ApplicationHelper . printError ( "Unable to load test file" , e ) ; } }
te	0	public int getBlackTime ( ) { return this . blackTime ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { CadCurso dialog = new CadCurso ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	1	public Object [ ] getData ( int index ) { Object [ ] data = new Object [ model . getColumnCount ( ) ] ; for ( int i = 0 ; i < model . getColumnCount ( ) ; i ++ ) { data [ i ] = model . getValueAt ( index , i ) ; } return data ; }
te	3	static private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 71 : return jjMoveStringLiteralDfa5_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 ) ; }
te	7	protected void encodeEntityReference ( String entityreference ) throws IOException { alignToOctet ( ) ; current_octet |= FastInfosetConstants . UNEXPANDED_ENTITY_IDENTIFICATION ; String systemid = null ; String publicid = null ; UnparsedEntity entity = UnParsedEntites . get ( entityreference ) ; if ( entity != null ) { systemid = entity . systemIdentifier ; publicid = entity . publicIdentifier ; } boolean encodesystemid = ( systemid != null ) && ! systemid . isEmpty ( ) ; boolean encodepublicid = ( publicid != null ) && ! publicid . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; encodeIdentifyingStringOrIndex ( entityreference , vocabulary . other_ncnames ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( systemid , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( publicid , vocabulary . other_uris ) ; } }
te	3	public String fromServer ( ) { String buf = null ; try { while ( ! myInput . ready ( ) ) ; try { buf = myInput . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return buf ; }
te	5	public void updateItem ( PosListaPrecio itemOracle , int idPos ) { if ( itemOracle . getPcaIdElemento ( ) != null ) { PhpposItemsEntity itemPos = getItemPos ( itemOracle . getPcaIdElemento ( ) ) ; if ( itemPos != null ) { Session hbSession = getSession ( ) ; Transaction ts = hbSession . beginTransaction ( ) ; itemPos . setName ( itemOracle . getPcaDescripcion ( ) ) ; itemPos . setDescription ( itemOracle . getPcaDescripcion ( ) ) ; itemPos . setQuantity ( itemPos . getQuantity ( ) + itemOracle . getPcaCantidad ( ) ) ; itemPos . setCostPrice ( itemOracle . getPcaPrecioVenta ( ) ) ; itemPos . setUnitPrice ( itemOracle . getPcaPrecioVenta ( ) ) ; getHibernateTemplate ( ) . update ( itemPos ) ; boolean successMySQL = false ; boolean successOracle = false ; try { successOracle = facOracleDAO . updatePosListaPrecioCeroA ( itemOracle ) ; successMySQL = true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( successMySQL && successOracle ) { ts . commit ( ) ; hbSession . flush ( ) ; hbSession . close ( ) ; saveLogEntrada ( itemOracle , "U" , idPos ) ; logger . info ( " " ) ; logger . info ( " ========  ITEM ACTUALIZADO  =========================== " ) ; logger . info ( "itemPos.getItemId() = " + itemPos . getItemId ( ) ) ; logger . info ( "itemPos.getDescription() = " + itemPos . getDescription ( ) ) ; logger . info ( "itemPos.getUnitPrice() = " + itemPos . getUnitPrice ( ) ) ; logger . info ( "itemPos.getQuantity() = " + itemPos . getQuantity ( ) ) ; logger . info ( " ======================================================= " ) ; logger . info ( " " ) ; } else { ts . rollback ( ) ; hbSession . flush ( ) ; hbSession . close ( ) ; } } } else { logger . info ( " ========  ITEM CON PROBLEMAS DE UPDATE  =============== " ) ; logger . info ( " ========  NO EXISTE ITEM EN EL POS CON: =============== " ) ; logger . info ( "itemOracle.getPcaIdElemento() = " + itemOracle . getPcaIdElemento ( ) ) ; logger . info ( "itemOracle.getPcaDescripcion() = " + itemOracle . getPcaDescripcion ( ) ) ; logger . info ( "itemOracle.getPcaPosId() = " + itemOracle . getPcaPosId ( ) ) ; logger . info ( "idPos = " + idPos ) ; logger . info ( " ======================================================= " ) ; } } else { logger . info ( " ========  ITEM CON getPcaIdElemento NULL  ============= " ) ; logger . info ( "itemOracle.getPcaIdElemento() = " + itemOracle . getPcaIdElemento ( ) ) ; logger . info ( "itemOracle.getPcaDescripcion() = " + itemOracle . getPcaDescripcion ( ) ) ; logger . info ( "itemOracle.getPcaPosId() = " + itemOracle . getPcaPosId ( ) ) ; logger . info ( "idPos = " + idPos ) ; logger . info ( " ======================================================= " ) ; } }
te	8	public boolean equals ( flush_queue_args that ) { if ( that == null ) return false ; boolean this_present_queue_name = true && this . is_set_queue_name ( ) ; boolean that_present_queue_name = true && that . is_set_queue_name ( ) ; if ( this_present_queue_name || that_present_queue_name ) { if ( ! ( this_present_queue_name && that_present_queue_name ) ) return false ; if ( ! this . queue_name . equals ( that . queue_name ) ) return false ; } return true ; }
te	3	@ EventHandler ( priority = EventPriority . MONITOR ) public void join ( PlayerJoinEvent event ) { String name = event . getPlayer ( ) . getName ( ) ; if ( qm . getQuestLog ( name ) == null ) { PlayerQuestLog log = new PlayerQuestLog ( name ) ; qm . addQuestLog ( log ) ; for ( Quest q : qm . getQuests ( ) ) { if ( q . isFirstAssigned ( ) ) log . assign ( q ) ; } } }
te	1	private void haeButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( otaTalteen ( ) ) { hae ( ) ; tyhjenna ( ) ; } }
te	0	public void setContext ( String value ) { this . context = value ; }
te	0	public FunctionalRequirement ( BigDecimal idFunctionalRequirement ) { this . idFunctionalRequirement = idFunctionalRequirement ; }
te	0	public MenuRetornarPartida ( ) { super ( "Menu Partida" , new ArrayList < ItemMenu > ( ) { private static final long serialVersionUID = - 2202065529317389240 ; { add ( new ItemMenu ( "REINICIAR" , "Retorna uma partida" ) ) ; add ( new ItemMenu ( "APAGAR" , "Apagar uma partida" ) ) ; add ( new ItemMenu ( "RETORNAR" , "Retornar ao menu principal" ) ) ; } } ) ; }
te	1	private void listSolicitudesMouseClicked ( java . awt . event . MouseEvent evt ) { int no ; no = listSolicitudes . getSelectedIndex ( ) ; int reply = JOptionPane . showConfirmDialog ( null , "Desea agregara a " + listaS . get ( no - 1 ) . nombre + "(" + listaS . get ( no - 1 ) . usuario + ")" , "Solicitud de Amistad" , JOptionPane . YES_NO_OPTION ) ; String resp = "<solicitud_amistad>\n" ; if ( reply == JOptionPane . YES_OPTION ) { resp += "<respuesta> Si </respuesta>\n" ; } else { resp += "<respuesta> No </respuesta>\n" ; } usuario usuario = servidor . getUsuario ( txtUser . getText ( ) ) ; resp += "<destinatario>" + listaS . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + txtUser . getText ( ) + "</usuario>\n" + "<nombre> " + usuario . getNombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listaS . remove ( no - 1 ) ; listSolicitudes . updateUI ( ) ; servidor . actualizarSolicitudes2 ( listaS , usuario . getUsername ( ) ) ; writeUTF ( resp ) ; listSolicitudes . repaint ( ) ; System . err . println ( resp ) ; }
te	4	private static void printLine ( String s , int level ) { if ( level >= logLevel ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( new Date ( ) . toString ( ) ) ; sb . append ( ": " ) ; switch ( level ) { case 0 : sb . append ( "INFO" ) ; break ; case 1 : sb . append ( "WARNING" ) ; break ; case 2 : sb . append ( "CRITICAL" ) ; break ; } sb . append ( ": " ) ; sb . append ( s ) ; System . out . println ( sb . toString ( ) ) ; out . println ( sb . toString ( ) ) ; out . flush ( ) ; } }
te	1	@ Test public void InsertToAttachmentTest ( ) { AttachmentModel attachmentModel = new AttachmentModel ( ) ; File file = new File ( "F:\\updata.txt" ) ; byte [ ] bFile = new byte [ ( int ) file . length ( ) ] ; try { FileInputStream fis = new FileInputStream ( file ) ; fis . read ( bFile ) ; fis . close ( ) ; attachmentModel . setATTACHMENT_DATA ( bFile ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } attachmentModel . setATTACHMENT_TYPE ( "\u56FE\u7247" ) ; attachmentManageService . InsertToAttachment ( attachmentModel ) ; }
te	9X	public ModelEnvelope ( BufferedReader reader , boolean server ) throws IOException { modelBuff = new HashMap < String , TransferableModel > ( ) ; this . server = server ; String line = reader . readLine ( ) ; if ( line == null ) throw new EOFException ( "Expected envelope header got EOF" ) ; if ( ! line . equals ( ENVELOPE_HEADER ) ) throw new IOException ( "Expected envelope header  found " + line ) ; int numModels = Integer . parseInt ( reader . readLine ( ) ) ; countModels = Integer . parseInt ( reader . readLine ( ) ) ; TransferableModel [ ] list = new TransferableModel [ numModels ] ; newFlags = new boolean [ countModels ] ; try { for ( int i = 0 ; i < numModels ; i ++ ) { String name = reader . readLine ( ) , umid = reader . readLine ( ) ; list [ i ] = createModel ( name , reader , server ) ; if ( ! umid . equals ( "" ) ) { modelBuff . put ( umid , list [ i ] ) ; } } } catch ( IOException e ) { while ( ! reader . readLine ( ) . equals ( ENVELOPE_FOOTER ) ) ; throw new IOException ( "Exception reading model" , e ) ; } if ( ! ( line = reader . readLine ( ) ) . equals ( ENVELOPE_FOOTER ) ) { throw new IOException ( "Expected envelope footer line  got " + line ) ; } for ( int i = 0 ; i < list . length ; i ++ ) { list [ i ] . registerSubModels ( this ) ; if ( ( numModels - i ) <= countModels ) newFlags [ countModels - ( numModels - i ) ] = ModelCacher . containsKey ( list [ i ] . getUMID ( ) ) ; list [ i ] = ModelCacher . cache ( list [ i ] ) ; } models = new Stack < TransferableModel > ( ) ; modelUMIDs = new HashSet < String > ( ) ; for ( int i = list . length - 1 ; i >= list . length - countModels ; i -- ) { models . push ( list [ i ] ) ; modelUMIDs . add ( list [ i ] . getUMID ( ) ) ; } }
te	8	public ArrayList < SearchBean < FreeBedDetailBean >> searchForFreeBeds ( Hostel info , Date checkIn , Date checkOut , int numberOfBeds ) { ArrayList < SearchBean < FreeBedDetailBean >> result = new ArrayList < SearchBean < FreeBedDetailBean >> ( ) ; write ( result ) ; if ( info == null ) { return null ; } try { ArrayList < Identifier > hostelIds = Hostels . getInstance ( ) . search ( info ) ; if ( hostelIds . size ( ) == 0 ) { return null ; } for ( Identifier hostelId : hostelIds ) { ArrayList < Identifier > bedIds = Hostels . getInstance ( ) . getFreeBeds ( hostelId , checkIn , checkOut ) ; if ( bedIds . size ( ) < numberOfBeds ) { continue ; } if ( numberOfBeds == 1 ) { for ( int i = 0 ; i < bedIds . size ( ) ; i ++ ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedIds . get ( i ) ) ; FreeBedDetailBean bedDetail = new FreeBedDetailBean ( ) ; bedDetail . setCheckIn ( checkIn ) ; bedDetail . setCheckOut ( checkOut ) ; bedDetail . setTotalPrice ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; ArrayList < Identifier > topBedIds = new ArrayList < Identifier > ( ) ; ArrayList < Integer > price = new ArrayList < Integer > ( ) ; topBedIds . add ( bedIds . get ( i ) ) ; price . add ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; bedDetail . setBedIds ( topBedIds ) ; bedDetail . setPrice ( price ) ; SearchBean < FreeBedDetailBean > bean = new SearchBean < FreeBedDetailBean > ( getNextSearchId ( ) , hostelId , bedDetail ) ; result . add ( bean ) ; } } else { FreeBedDetailBean bedDetail = new FreeBedDetailBean ( ) ; bedDetail . setTotalPrice ( 0 ) ; ArrayList < Identifier > topBedIds = new ArrayList < Identifier > ( ) ; ArrayList < Integer > price = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < numberOfBeds ; i ++ ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedIds . get ( i ) ) ; bedDetail . setCheckIn ( checkIn ) ; bedDetail . setCheckOut ( checkOut ) ; bedDetail . setTotalPrice ( bedDetail . getTotalPrice ( ) + bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; topBedIds . add ( bedIds . get ( i ) ) ; price . add ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; } bedDetail . setBedIds ( topBedIds ) ; bedDetail . setPrice ( price ) ; SearchBean < FreeBedDetailBean > bean = new SearchBean < FreeBedDetailBean > ( getNextSearchId ( ) , hostelId , bedDetail ) ; result . add ( bean ) ; } } } catch ( DataBaseReadWriteException | IdentifierNotFoundException | InvalidIdentifierException | InvalidParameterException e ) { e . printStackTrace ( ) ; } write ( result ) ; return result ; }
te	5	public void update ( final String data ) { int j = this . dataLen % SLIDING_WND_SIZE ; int fedLen = this . dataLen ; if ( this . aBucket == null ) { this . aBucket = new int [ BUCKETS ] ; } for ( int i = 0 ; i < data . length ( ) ; i ++ ) { slideWindow [ j ] = ( int ) ( data . charAt ( i ) & ff ) ; if ( fedLen >= 4 ) { int j1 = ( j + SLIDING_WND_SIZE - 1 ) % SLIDING_WND_SIZE ; int j2 = ( j + SLIDING_WND_SIZE - 2 ) % SLIDING_WND_SIZE ; int j3 = ( j + SLIDING_WND_SIZE - 3 ) % SLIDING_WND_SIZE ; int j4 = ( j + SLIDING_WND_SIZE - 4 ) % SLIDING_WND_SIZE ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( k == 0 ) { this . lshBin . checksum [ k ] = bMapping ( ( int ) 0 , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } else { this . lshBin . checksum [ k ] = bMapping ( this . lshBin . checksum [ k - 1 ] , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } } int r ; r = bMapping ( ( int ) 2 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j2 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 3 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 5 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 7 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 11 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 13 , slideWindow [ j ] , slideWindow [ j3 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; } fedLen ++ ; j = ( j + SLIDING_WND_SIZE + 1 ) % SLIDING_WND_SIZE ; } this . dataLen += data . length ( ) ; }
te	3	public static boolean isBase64 ( byte octet ) { return octet == PAD || ( octet >= 0 && octet < base64ToInt . length && base64ToInt [ octet ] != - 1 ) ; }
te	0	public JsonRegistry add ( Map < String , Object > json ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( file , true ) ) ; JsonGenerator jgen = JsonOutput . FACTORY . createJsonGenerator ( writer ) ; JsonOutput . MAPPER . writeValue ( jgen , json ) ; jgen . writeRawValue ( "\n" ) ; jgen . flush ( ) ; jgen . close ( ) ; writer . close ( ) ; return this ; }
te	0	@ Override public String toString ( ) { return "Autonomous Points : " + getPoints ( ) ; }
te	6	public static String unescape ( String string ) { int length = string . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; ++ i ) { char c = string . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < length ) { int d = JSONTokener . dehexchar ( string . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( string . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } sb . append ( c ) ; } return sb . toString ( ) ; }
te	7	public static void printB ( String str ) { double num = double . parseDouble ( str ) ; if ( num == 0 ) System . out . println ( "0" ) ; else { int left = ( int ) num ; double right = num - left ; StringBuilder sb = new StringBuilder ( ) ; while ( left > 0 ) { sb . insert ( 0 , left % 2 ) ; left /= 2 ; } if ( right > 0 ) { sb . append ( "." ) ; int count = 0 ; while ( count < 32 ) { if ( right * 2 > 1 ) { sb . append ( 1 ) ; right = right * 2 - 1 ; } else if ( right * 2 == 1 ) { sb . append ( 1 ) ; break ; } else { sb . append ( 0 ) ; right *= 2 ; } count ++ ; } if ( count == 32 ) { System . out . println ( "ERROR" ) ; return ; } } System . out . println ( sb ) ; } }
te	6	public boolean isSymmetricHelper ( TreeNode node1 , TreeNode node2 ) { if ( node1 == null && node2 == null ) return true ; if ( node1 == null || node2 == null ) return false ; if ( node1 . val != node2 . val ) return false ; return isSymmetricHelper ( node1 . left , node2 . right ) && isSymmetricHelper ( node1 . right , node2 . left ) ; }
te	2	private static final long [ ] mk_tokenSet_1 ( ) { long [ ] data = new long [ 260 ] ; data [ 0 ] = - 9224 ; for ( int i = 1 ; i <= 3 ; i ++ ) { data [ i ] = - 1 ; } for ( int i = 64 ; i <= 127 ; i ++ ) { data [ i ] = - 1 ; } return data ; }
te	8	@ Override public void expand ( int grabber , Point endMove , int canvasWidth , int canvasHeight ) { if ( ( ( endMove . getX ( ) ) > 0 ) && ( ( endMove . getY ( ) ) > 0 ) && ( ( endMove . getX ( ) ) < canvasWidth ) && ( ( endMove . getY ( ) ) < canvasHeight ) ) { Point startMove = new Point ( ) ; switch ( grabber ) { case 0 : startMove = new Point ( ( int ) x , ( int ) y ) ; width += ( startMove . getX ( ) - endMove . getX ( ) ) ; height += ( startMove . getY ( ) - endMove . getY ( ) ) ; x = endMove . getX ( ) ; y = endMove . getY ( ) ; break ; case 1 : startMove = new Point ( ( int ) ( x + width ) , ( int ) y ) ; width += ( endMove . getX ( ) - startMove . getX ( ) ) ; height += ( startMove . getY ( ) - endMove . getY ( ) ) ; x = endMove . getX ( ) - width ; y = endMove . getY ( ) ; break ; case 2 : startMove = new Point ( ( int ) x , ( int ) ( y + height ) ) ; width += ( startMove . getX ( ) - endMove . getX ( ) ) ; height += ( endMove . getY ( ) - startMove . getY ( ) ) ; x = endMove . getX ( ) ; y = endMove . getY ( ) - height ; break ; case 3 : { startMove = new Point ( ( int ) ( x + width ) , ( int ) ( y + height ) ) ; width += ( endMove . getX ( ) - startMove . getX ( ) ) ; height += ( endMove . getY ( ) - startMove . getY ( ) ) ; x = endMove . getX ( ) - width ; y = endMove . getY ( ) - height ; break ; } } } }
te	8	DlgAddBooks ( Library lib ) { this . library = lib ; this . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; this . setTitle ( "Add book" ) ; choosePic = new JButton ( "Choose picture" ) ; choosePic . setBounds ( 300 , 50 , 150 , 50 ) ; add = new JButton ( "Add" ) ; add . setBounds ( 75 , 500 , 100 , 30 ) ; close = new JButton ( "Cancel" ) ; close . setBounds ( 325 , 500 , 100 , 30 ) ; picturePanel = new JPanel ( ) ; picturePanel . setBackground ( Color . BLACK ) ; picturePanel . setBounds ( 50 , 20 , 210 , 280 ) ; picLabel = new JLabel ( ) ; picLabel . setSize ( 210 , 280 ) ; picturePanel . add ( picLabel ) ; jtf_isbn = new JTextField ( ) ; jtf_isbn . setBounds ( 120 , 330 , 300 , 25 ) ; jl_isbn = new JLabel ( "ISBN" ) ; jl_isbn . setBounds ( 40 , 330 , 100 , 25 ) ; jtf_name = new JTextField ( ) ; jtf_name . setBounds ( 120 , 370 , 300 , 25 ) ; jl_name = new JLabel ( "Name" ) ; jl_name . setBounds ( 40 , 370 , 100 , 25 ) ; jtf_author = new JTextField ( ) ; jtf_author . setBounds ( 120 , 410 , 300 , 25 ) ; jl_author = new JLabel ( "Author" ) ; jl_author . setBounds ( 40 , 410 , 100 , 25 ) ; String [ ] categoryStrings = { "Children" , "Cooking" , "History" , "Travel" } ; cb_category = new JComboBox ( categoryStrings ) ; cb_category . setBounds ( 120 , 450 , 300 , 25 ) ; jl_category = new JLabel ( "Category" ) ; jl_category . setBounds ( 40 , 450 , 100 , 25 ) ; this . add ( choosePic ) ; this . add ( add ) ; this . add ( close ) ; this . add ( picturePanel ) ; this . add ( jtf_isbn ) ; this . add ( jtf_name ) ; this . add ( jtf_author ) ; this . add ( jl_isbn ) ; this . add ( jl_name ) ; this . add ( jl_author ) ; this . add ( cb_category ) ; this . add ( jl_category ) ; this . setSize ( 500 , 600 ) ; this . setLayout ( null ) ; choosePic . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { FileDialog readFD = new FileDialog ( new Frame ( ) , "Choose a file" , FileDialog . LOAD ) ; readFD . setVisible ( true ) ; picDirectory = readFD . getDirectory ( ) ; picFileName = readFD . getFile ( ) ; picPath = picDirectory + picFileName ; ImageIcon bookImgIcon = CreateStretchImageIcon ( picPath , picturePanel . getWidth ( ) , picturePanel . getHeight ( ) ) ; DlgAddBooks . this . picLabel . setIcon ( bookImgIcon ) ; } } ) ; add . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Validator test = new Validator ( ) ; String currentISBN = jtf_isbn . getText ( ) ; String currentBookName = jtf_name . getText ( ) ; String currentAuthor = jtf_author . getText ( ) ; String currentCategoryString = ( String ) cb_category . getSelectedItem ( ) ; Category currentCategory ; switch ( currentCategoryString ) { case "Children" : { currentCategory = Category . CHILDREN ; break ; } case "Cooking" : { currentCategory = Category . COOKING ; break ; } case "History" : { currentCategory = Category . HISTORY ; break ; } case "Travel" : { currentCategory = Category . TRAVEL ; break ; } default : currentCategory = null ; } if ( test . isBookIsbnValid ( currentISBN ) && test . isContentValid ( currentBookName ) && test . isContentValid ( currentAuthor ) ) { Book currentNewBook = new Book ( ) ; currentNewBook . setBookName ( currentBookName ) ; currentNewBook . setAuthor ( currentAuthor ) ; currentNewBook . setIsbn ( currentISBN ) ; currentNewBook . setLastRented ( null ) ; currentNewBook . setAddedDate ( new Date ( ) ) ; currentNewBook . setRented ( false ) ; currentNewBook . setOwnerId ( Library . LIBRARY_OWNER_ID ) ; currentNewBook . setCategory ( currentCategory ) ; library . addBook ( currentNewBook ) ; try { library . copyBookImage ( picDirectory , picFileName , currentISBN ) ; } catch ( Exception ex ) { System . out . println ( "No picture selected." ) ; } finally { JOptionPane . showMessageDialog ( DlgAddBooks . this , "New book added." , "OK" , JOptionPane . PLAIN_MESSAGE ) ; DlgAddBooks . this . dispose ( ) ; } } else { JOptionPane . showMessageDialog ( DlgAddBooks . this , "Invaild book information!" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; close . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DlgAddBooks . this . dispose ( ) ; } } ) ; }
te	3	private void mergeGapSizes ( int [ ] sizes , boolean isHor , boolean isTL ) { if ( gaps == null ) gaps = new int [ ] [ ] { null , null , null , null } ; if ( sizes == null ) return ; int gapIX = getGapIx ( isHor , isTL ) ; int [ ] oldGaps = gaps [ gapIX ] ; if ( oldGaps == null ) { oldGaps = new int [ ] { 0 , 0 , LayoutUtil . INF } ; gaps [ gapIX ] = oldGaps ; } oldGaps [ LayoutUtil . MIN ] = Math . max ( sizes [ LayoutUtil . MIN ] , oldGaps [ LayoutUtil . MIN ] ) ; oldGaps [ LayoutUtil . PREF ] = Math . max ( sizes [ LayoutUtil . PREF ] , oldGaps [ LayoutUtil . PREF ] ) ; oldGaps [ LayoutUtil . MAX ] = Math . min ( sizes [ LayoutUtil . MAX ] , oldGaps [ LayoutUtil . MAX ] ) ; }
te	1	public String toString ( ) { try { return [ + join ( " " ) + ] ; } catch ( Exception e ) { return null ; } }
te	1	@ Override public int compareTo ( Correo c ) { String remitente = c . getRemitente ( ) ; Date fecha = c . getFecha ( ) ; if ( this . remitente . equalsIgnoreCase ( remitente ) ) return this . fecha . compareTo ( fecha ) ; else return this . remitente . compareToIgnoreCase ( remitente ) ; }
te	0	public void setUserPhoto ( String userPhoto ) { this . userPhoto = userPhoto ; }
te	3	public static MarketBuilder getQuotes ( ResponseFormat format , String [ ] symbols , MarketQuotesResponseField [ ] fields ) { StringBuilder sb = new StringBuilder ( ) ; for ( String sym : symbols ) { sb . append ( sym + " " ) ; } StringBuilder fids = new StringBuilder ( ) ; for ( MarketQuotesResponseField f : fields ) { fids . append ( f . toString ( ) + " " ) ; } MarketBuilder b = new MarketBuilder ( Verb . POST ) ; b . params . put ( MarketQuotesField . SYMBOLS . toString ( ) , sb . toString ( ) . trim ( ) . replace ( " " , " " ) ) ; b . resourceURL = APICall . getQuote ( ResponseFormat . XML ) ; if ( ! fids . toString ( ) . isEmpty ( ) ) { b . params . put ( MarketQuotesField . FIDS . toString ( ) , fids . toString ( ) . trim ( ) . replace ( " " , " " ) ) ; } return b ; }
te	9X	private void parseUserAgent ( ) { final String ua = _request . getHeader ( "user-agent" ) . toLowerCase ( ) ; if ( ua != null ) { Matcher m = _rwebkit . matcher ( ua ) ; if ( m . matches ( ) ) { final double version = getVersion ( m ) ; _vars . put ( "webkit" , version ) ; _vars . put ( "safari" , version ) ; return ; } m = _ropera . matcher ( ua ) ; if ( m . matches ( ) ) { _vars . put ( "opera" , getVersion ( m ) ) ; return ; } m = _rmsie . matcher ( ua ) ; if ( m . matches ( ) ) { final double version = getVersion ( m ) ; _vars . put ( "msie" , version ) ; _vars . put ( "ie" , version ) ; return ; } if ( ua . indexOf ( "compatible" ) < 0 ) { m = _rmozilla . matcher ( ua ) ; if ( m . matches ( ) ) { double version = getVersion ( m ) ; if ( version < 5 ) { int j = ua . indexOf ( "firefox/" ) ; if ( j >= 0 ) { int k = ua . indexOf ( . , j += 8 ) ; if ( k >= 0 ) { for ( int len = ua . length ( ) ; ++ k < len ; ) { final char cc = ua . charAt ( k ) ; if ( cc < 0 || cc > 9 ) { break ; } } try { version = double . parseDouble ( ua . substring ( j , k ) ) ; } catch ( Throwable ex ) { } } } } _vars . put ( "mozilla" , version ) ; _vars . put ( "gecko" , version ) ; _vars . put ( "ff" , version ) ; return ; } } } }
te	1	public PermutationIterator ( Iterable < T > elementsA , Iterable < T > elementsB ) { _iteratorA = elementsA . iterator ( ) ; _iteratorB = elementsB . iterator ( ) ; _elementsB = elementsB ; if ( _iteratorA . hasNext ( ) ) _elementA = _iteratorA . next ( ) ; }
te	5	public State nextStateTraining ( String tag ) { State next = null ; State st = null ; int numTrans = 0 ; int otherTrans = 0 ; int totalTrans = 0 ; double ratio = 0 ; current . addTransition ( tag ) ; next = current . next ( tag ) ; numTrans = current . getTransitions ( tag ) ; totalTrans = next . getAllTransitions ( ) ; otherTrans = totalTrans - numTrans ; if ( ( numTrans > condition1 ) && ( otherTrans > condition2 ) ) { st = new State ( next . getCloneName ( ) ) ; current . addConnection ( tag , st , true ) ; st . addMasterConnection ( next . getMasterConnection ( ) . getTo ( ) ) ; for ( Connection cn : next . allConnections ( ) ) { st . addConnection ( cn . getTag ( ) , cn . getTo ( ) ) ; } ratio = ( double ) ( ( ( double ) numTrans ) / ( ( double ) totalTrans ) ) ; st . copyCounters ( next , ratio ) ; estats . add ( st ) ; hashstats . put ( st . getName ( ) , st ) ; next = st ; } if ( this . backoff && ! current . hasConnection ( tag ) ) next = current . next ( tag ) . next ( tag ) ; return next ; }
te	8	public GTFSPlugin getPlugin ( ) { if ( plugin == null ) { synchronized ( this ) { String pluginName = properties . getProperty ( "plugin" ) ; if ( pluginName == null ) { plugin = new DefaultPlugin ( ) ; } else { try { class < ? > pluginClass = class . forName ( pluginName ) ; boolean validPlugin = false ; for ( class < ? > c : pluginClass . getInterfaces ( ) ) { if ( c . equals ( GTFSPlugin . class ) ) { validPlugin = true ; } } if ( validPlugin ) plugin = ( GTFSPlugin ) pluginClass . newInstance ( ) ; else throw new IllegalArgumentException ( "The specified plugin is not found or not valid" ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "The specified plugin is not found or not valid" ) ; } } } } return plugin ; }
te	3	private int compareTo ( Object tree1 , Object tree2 ) { if ( tree1 == tree2 ) return 0 ; else { int size1 = treeSize ( tree1 ) , size2 = treeSize ( tree2 ) ; if ( size1 < size2 ) return - 1 ; else if ( size1 > size2 ) return 1 ; else return compareTo ( tree1 , 0 , tree2 , 0 , 0 , size1 ) ; } }
te	0	public final String readPropertyValue ( final String propertyName , final String defaultValue ) { return PROPERTIES . getProperty ( propertyName , defaultValue ) ; }
te	8	public static IntPair calculateMove ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { for ( Tuple item : movesToMake ) { if ( item . getWeight ( ) == 2 ) { AIDebuggingOutput . println ( "I'm smart  so I'm winning at " + item . getLocation ( ) . getX ( ) + " " + item . getLocation ( ) . getY ( ) ) ; return item . getLocation ( ) ; } } for ( Tuple item : movesToBlock ) { if ( item . getWeight ( ) == 2 ) { AIDebuggingOutput . println ( "I'm smart  so I'm blocking you at " + item . getLocation ( ) . getX ( ) + " " + item . getLocation ( ) . getY ( ) ) ; return item . getLocation ( ) ; } } Random rand = new Random ( ) ; int xIndex = rand . nextInt ( 7 ) ; int yIndex = 0 ; while ( b . getGameGridCircle ( xIndex , yIndex ) . getState ( ) != 0 ) { xIndex = ( xIndex + 1 ) % 7 ; } while ( ( yIndex != Board . numRows - 1 ) && ( b . getGameGridCircle ( xIndex , yIndex + 1 ) . getState ( ) == 0 ) ) { yIndex ++ ; if ( yIndex == Board . numRows - 1 ) { break ; } } AIDebuggingOutput . println ( "Hmm  I'm not sure so I'm guessing " + xIndex + " " + yIndex ) ; return new IntPair ( xIndex , yIndex ) ; }
te	2	public void mousePressed ( Graphics g , MouseEvent e ) { int x = e . getX ( ) ; int y = e . getY ( ) ; current = MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . findState ( x , y , g ) ; if ( current != null ) { current . expose ( g ) ; current . move ( x , y ) ; current . expose ( g ) ; } else { current = MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . addState ( ) . move ( x , y ) ; if ( MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . getInitialStates ( ) . size ( ) == 0 ) { current . setInitial ( true ) ; } current . expose ( g ) ; } MainFrame . getCurrentCanvas ( ) . commitTransaction ( true ) ; }
te	0	public void setDocumentTable ( Hashtable < String , ArrayList < String >> documentTable ) { this . documentTable = documentTable ; }
te	8	private void constructJson ( JSONObject json ) throws WeiboException { try { createdAt = parseDate ( json . getString ( "created_at" ) , "EEE MMM dd HH:mm:ss z yyyy" ) ; id = json . getString ( "id" ) ; mid = json . getString ( "mid" ) ; idstr = json . getLong ( "idstr" ) ; text = json . getString ( "text" ) ; if ( ! json . getString ( "source" ) . isEmpty ( ) ) { source = new Source ( json . getString ( "source" ) ) ; } inReplyToStatusId = getLong ( "in_reply_to_status_id" , json ) ; inReplyToUserId = getLong ( "in_reply_to_user_id" , json ) ; inReplyToScreenName = json . getString ( "in_reply_toS_screenName" ) ; favorited = getBoolean ( "favorited" , json ) ; truncated = getBoolean ( "truncated" , json ) ; thumbnailPic = json . getString ( "thumbnail_pic" ) ; bmiddlePic = json . getString ( "bmiddle_pic" ) ; originalPic = json . getString ( "original_pic" ) ; repostsCount = json . getInt ( "reposts_count" ) ; commentsCount = json . getInt ( "comments_count" ) ; annotations = json . getString ( "annotations" ) ; if ( ! json . isNull ( "user" ) ) user = new User ( json . getJSONObject ( "user" ) ) ; if ( ! json . isNull ( "retweeted_status" ) ) { retweetedStatus = new Status ( json . getJSONObject ( "retweeted_status" ) ) ; } mlevel = json . getInt ( "mlevel" ) ; geo = json . getString ( "geo" ) ; if ( geo != null && ! "" . equals ( geo ) && ! "null" . equals ( geo ) ) { getGeoInfo ( geo ) ; } if ( ! json . isNull ( "visible" ) ) { visible = new Visible ( json . getJSONObject ( "visible" ) ) ; } } catch ( JSONException je ) { throw new WeiboException ( je . getMessage ( ) + ":" + json . toString ( ) , je ) ; } }
te	4	public StringLargeArray ( long length , int maxStringLength , boolean zeroNativeMemory ) { this . type = LargeArrayType . STRING ; this . sizeof = 1 ; if ( length <= 0 ) { throw new IllegalArgumentException ( length + " is not a positive long value." ) ; } if ( maxStringLength <= 0 ) { throw new IllegalArgumentException ( maxStringLength + " is not a positive int value." ) ; } this . length = length ; this . size = length * ( long ) maxStringLength * ( long ) CHARSET_SIZE ; this . maxStringLength = maxStringLength ; if ( length > LARGEST_32BIT_INDEX ) { System . gc ( ) ; this . ptr = Utilities . UNSAFE . allocateMemory ( this . size * this . sizeof ) ; if ( zeroNativeMemory ) { zeroNativeMemory ( this . size ) ; } Cleaner . create ( this , new Deallocator ( this . ptr , this . size , this . sizeof ) ) ; MemoryCounter . increaseCounter ( this . size * this . sizeof ) ; stringLengths = new ShortLargeArray ( length ) ; byteArray = new byte [ maxStringLength * CHARSET_SIZE ] ; } else { data = new String [ ( int ) length ] ; } }
te	1	public String getFile ( ) { if ( file == null ) return null ; else return file . getName ( ) ; }
te	7	private String constructHttpHeader ( int code , int fileType ) { String s = "HTTP/1.0 " ; switch ( code ) { case 200 : s = s + "200 OK" ; break ; case 400 : s = s + "400 Bad Request" ; break ; case 403 : s = s + "403 Forbidden" ; break ; case 404 : s = s + "404 Not Found" ; break ; case 500 : s = s + "500 Internal Server Error" ; break ; case 501 : s = s + "501 Not Implemented" ; break ; } s = s + "\r\n" ; s = s + "Connection: close\r\n" ; s = s + "Server: WTBBackend GPS Input\r\n" ; switch ( fileType ) { case 0 : break ; default : s = s + "Content-Type: text/html\r\n" ; break ; } s = s + "\r\n" ; return s ; }
te	9X	public static final String unescape ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; ) { ch = str . charAt ( i ++ ) ; if ( ch != \ ) retval . append ( ch ) ; else { ch = str . charAt ( i ++ ) ; switch ( ch ) { case 0 : continue ; case b : retval . append ( "\b" ) ; continue ; case t : retval . append ( "\t" ) ; continue ; case n : retval . append ( "\n" ) ; continue ; case f : retval . append ( "\f" ) ; continue ; case r : retval . append ( "\r" ) ; continue ; case " : retval . append ( "\"" ) ; continue ; case ' : retval . append ( "'" ) ; continue ; case \ : retval . append ( "\\" ) ; continue ; default : retval . append ( "\\" ) ; retval . append ( ch ) ; continue ; } } } return retval . toString ( ) ; }
te	6	public Environment ( Node node ) throws MalformedURLException , XPathExpressionException { this . methods = new HashMap < String , ServiceMethod > ( ) ; this . properties = new HashMap < String , String > ( ) ; this . setRawEndpoint ( Utilities . selectSingleText ( node , "./@c:url" , XMLLabels . STANDARD_NAMESPACES ) ) ; this . name = Utilities . selectSingleText ( node , "./@c:name" , XMLLabels . STANDARD_NAMESPACES ) ; try { logger . info ( "Searching for properties." ) ; NodeList nodes = Utilities . selectNodes ( node , "./c:properties/c:property" , XMLLabels . STANDARD_NAMESPACES ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node propertyNode = nodes . item ( i ) ; if ( propertyNode != null ) { String propVal = propertyNode . getTextContent ( ) ; String propName = Utilities . selectSingleText ( propertyNode , "./@c:name" , XMLLabels . STANDARD_NAMESPACES ) ; if ( ! Utilities . isNullOrWhitespace ( propName ) ) { this . properties . put ( propName , propVal ) ; } } } } catch ( Exception e ) { logger . error ( "Error searching for methods." , e ) ; } try { logger . info ( "Searching for methods." ) ; NodeList nodes = Utilities . selectNodes ( node , "./c:methods/c:method" , XMLLabels . STANDARD_NAMESPACES ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node methodNode = nodes . item ( i ) ; ServiceMethod method = new ServiceMethod ( methodNode ) ; this . methods . put ( method . getDisplayName ( ) , method ) ; } } catch ( Exception e ) { logger . error ( "Error searching for methods." , e ) ; } }
te	0	private void prepararNOAplicarCategoriaANDProductoANDMarcaANDDiaOferta ( ) { List < DiaSemana > diaSemana = new ArrayList < DiaSemana > ( ) ; diaSemana . add ( DiaSemana . HOY ) ; ofertas . add ( new OfertaCategoria ( new CategoriaProducto ( CATEGORIA3 ) , 0.0 ) ) ; ofertas . add ( new OfertaDia ( 0.0 , diaSemana ) ) ; ofertas . add ( new OfertaMarca ( new MarcaProducto ( MARCA3 ) , 0.0 ) ) ; ofertas . add ( new OfertaProducto ( regProd3 , 0.0 ) ) ; porcentajeDescuento = 50.0 ; oferta = new OfertaCompuestaAND ( ofertas , porcentajeDescuento ) ; productos . add ( new Producto ( regProd3 ) ) ; }
te	7	@ Test public void deletingOneOfManyWorks ( ) { String [ ] [ ] inputData = new String [ 10 ] [ cardData . length ] ; for ( int i = 0 ; i < 10 ; i ++ ) { inputData [ i ] [ 0 ] = "input" + i ; for ( int j = 1 ; j < cardData . length ; j ++ ) { inputData [ i ] [ j ] = cardData [ j ] ; } } for ( int i = 0 ; i < 10 ; i ++ ) { try { register . createCard ( inputData [ i ] ) ; } catch ( Exception ex ) { fail ( ) ; } } String [ ] [ ] del = new String [ 2 ] [ cardData . length ] ; del [ 0 ] = inputData [ 2 ] ; del [ 1 ] = inputData [ 5 ] ; register . deleteCards ( del ) ; assertEquals ( 8 , register . getCardData ( ) . length ) ; boolean containsFirst = false ; boolean containsSecond = false ; String [ ] [ ] retrievedData = register . getCardData ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( retrievedData [ i ] [ 0 ] . equals ( del [ 0 ] [ 0 ] ) ) { containsFirst = true ; } if ( retrievedData [ i ] [ 0 ] . equals ( del [ 1 ] [ 0 ] ) ) { containsSecond = true ; } } assertFalse ( containsFirst ) ; assertFalse ( containsSecond ) ; }
te	7	public static Vertex convertNode ( org . yaoqiang . bpmn . model . elements . core . common . FlowNode inputNode ) { Vertex outputNode = null ; String type = inputNode . getClass ( ) . getCanonicalName ( ) ; if ( outputNode == null ) { if ( type . toLowerCase ( ) . contains ( "gateway" ) ) { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . ExclusiveGateway ) ; if ( type . toLowerCase ( ) . contains ( "exclusivegateway" ) ) { outputNode . isXOR = true ; } if ( type . toLowerCase ( ) . contains ( "parallelgateway" ) ) { outputNode . isAND = true ; } if ( type . toLowerCase ( ) . contains ( "inclusivegateway" ) ) { outputNode . isOR = true ; } if ( inputNode . getOutgoingSequenceFlows ( ) . size ( ) > 1 ) outputNode . isSplit = true ; else outputNode . isJoin = true ; } else if ( type . toLowerCase ( ) . contains ( "event" ) ) { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . IntermediateThrowEvent ) ; } else { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . Task ) ; } } outputNode . id = UUID . randomUUID ( ) . toString ( ) ; return outputNode ; }
te	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
te	8	public boolean equals ( Date that ) { if ( that == null ) return false ; boolean this_present_cratedAt = true && this . isSetCratedAt ( ) ; boolean that_present_cratedAt = true && that . isSetCratedAt ( ) ; if ( this_present_cratedAt || that_present_cratedAt ) { if ( ! ( this_present_cratedAt && that_present_cratedAt ) ) return false ; if ( ! this . cratedAt . equals ( that . cratedAt ) ) return false ; } return true ; }
te	2	public synchronized void togglePause ( ) { if ( pause == 0 ) { pause = 999999 ; } else { pause = 0 ; if ( inpause ) { gcodepainter . interrupt ( ) ; } } }
te	4	private boolean isTranEnabled ( ArrayList < Automaton > disTA , HashMap < Integer , Set < Guard >> guard , ArrayList < State > state ) { if ( guard != null ) { for ( int i = 0 ; i < disTA . size ( ) ; i ++ ) { if ( guard . get ( i ) != null ) { Zone zone = state . get ( i ) . getZone ( ) ; zone = zone . and ( guard . get ( i ) , disTA . get ( i ) . getClocks ( ) ) ; if ( zone . getZoneDataStruct ( ) [ 0 ] [ 0 ] [ 0 ] == - 1 ) return false ; } } } return true ; }
te	6	public void doSample ( File baseFreqFile , File sampleFreqDir , File sizeFile , File outFile , double rate , byte mode ) throws IOException { TreeMap < String , Integer > sizes = this . readSizeFile ( sizeFile ) ; SampleComposition composition = null ; if ( mode == RANDOM_SAMPLE ) { composition = new RandomSampleComposition ( ) ; } else if ( mode == GREEDY_SAMPLE ) { composition = new GreedySampleComposition ( ) ; } else { } MLEDistribution mleBase = new MLEDistribution ( ) ; mleBase . readFreqFile ( baseFreqFile ) ; File [ ] samples = sampleFreqDir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File pathname ) { return pathname . getName ( ) . endsWith ( "-freq.txt.zip" ) ; } } ) ; for ( File sample : samples ) { String name = sample . getName ( ) . substring ( 0 , sample . getName ( ) . indexOf ( ".gz" ) ) ; if ( sizes . containsKey ( name ) ) { MLEDistribution sampleDist = new MLEDistribution ( ) ; sampleDist . readFreqFile ( sample ) ; int sampleSize = sizes . get ( name ) ; composition . addSample ( name , sampleDist , sampleSize ) ; } else { System . err . println ( "Size for file " + name + " not known!" ) ; } } int maxSize = ( int ) ( rate * sizes . get ( "base" ) ) ; System . out . println ( "Sampling using " + ( mode == RANDOM_SAMPLE ? "RANDOM" : "GREEDY" ) + " mode and maxsize of" + maxSize ) ; Set < String > selection = composition . composeSample ( mleBase , maxSize ) ; PrintStream out = new PrintStream ( outFile ) ; for ( String selected : selection ) { out . println ( selected ) ; } out . close ( ) ; }
te	0	public void showMinorCard ( ) { showCard ( 1 ) ; }
te	6	public static void vander ( final double [ ] x , final double [ ] w , final double [ ] q ) { int i , j , k , n = q . length ; double b , s , t , xx ; double [ ] c = new double [ n ] ; if ( n == 1 ) w [ 0 ] = q [ 0 ] ; else { for ( i = 0 ; i < n ; i ++ ) c [ i ] = 0.0 ; c [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { xx = - x [ i ] ; for ( j = ( n - 1 - i ) ; j < ( n - 1 ) ; j ++ ) c [ j ] += xx * c [ j + 1 ] ; c [ n - 1 ] += xx ; } for ( i = 0 ; i < n ; i ++ ) { xx = x [ i ] ; t = b = 1.0 ; s = q [ n - 1 ] ; for ( k = n - 1 ; k > 0 ; k -- ) { b = c [ k ] + xx * b ; s += q [ k - 1 ] * b ; t = xx * t + b ; } w [ i ] = s / t ; } } }
te	9X	public void testXmlRoundtrip ( ) throws Exception { XmlPullParser xpp = factory . newPullParser ( ) ; assertEquals ( true , xpp . getFeature ( XmlPullParser . FEATURE_PROCESS_NAMESPACES ) ) ; xpp . setInput ( null ) ; try { xpp . setFeature ( FEATURE_XML_ROUNDTRIP , true ) ; } catch ( Exception ex ) { } boolean roundtripSupported = xpp . getFeature ( FEATURE_XML_ROUNDTRIP ) ; if ( ! roundtripSupported ) { return ; } PackageTests . addNote ( "* optional feature  " + FEATURE_XML_ROUNDTRIP + " is supported\n" ) ; StringWriter sw = new StringWriter ( ) ; String s ; xpp . setInput ( new StringReader ( MISC_XML ) ) ; int [ ] holderForStartAndLength = new int [ 2 ] ; char [ ] buf ; while ( xpp . nextToken ( ) != XmlPullParser . END_DOCUMENT ) { switch ( xpp . getEventType ( ) ) { case XmlPullParser . START_TAG : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip START_TAG" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . END_TAG : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip END_TAG" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . TEXT : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip TEXT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . IGNORABLE_WHITESPACE : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip IGNORABLE_WHITESPACE" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . CDSECT : sw . write ( "<![CDATA[" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip CDSECT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "]]>" ) ; break ; case XmlPullParser . PROCESSING_INSTRUCTION : sw . write ( "<?" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip PROCESSING_INSTRUCTION" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "?>" ) ; break ; case XmlPullParser . COMMENT : sw . write ( "<!--" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip COMMENT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "-->" ) ; break ; case XmlPullParser . ENTITY_REF : sw . write ( "&" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip ENTITY_REF" , xpp . getName ( ) , s ) ; sw . write ( s ) ; sw . write ( ";" ) ; break ; case XmlPullParser . DOCDECL : sw . write ( "<!DOCTYPE" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip DOCDECL" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( ">" ) ; break ; default : throw new RuntimeException ( "unknown token type" ) ; } } sw . close ( ) ; String RESULT_XML_BUF = sw . toString ( ) ; assertEquals ( "rountrip XML" , printable ( MISC_XML ) , printable ( RESULT_XML_BUF ) ) ; }
te	1	@ Override public void mouseReleased ( MouseEvent e ) { try { onMouseReleased ( e ) ; } catch ( Throwable t ) { throwableGenerated ( "onMouseReleased" , t ) ; } }
te	6	@ SuppressWarnings ( "unchecked" ) private Set < WFF > makeCorrectDepthResults ( WFF source ) { HashSet < WFF > results = new HashSet < WFF > ( ) ; try { Logic logic = new ClassicalLogicS ( ) ; if ( source . getFormula ( ) . length ( ) < 1 ) { return results ; } ; formula = ( Formula ) logic . createExpression ( source . getFormula ( ) ) ; Formula result = ClassicalLogicS . Utilities . conjunctiveForm ( formula , true ) ; DefaultClausalFactory myFacts = new DefaultClausalFactory ( ) ; ClausalSet myClauses = myFacts . asClausalSet ( result ) ; PartitionListElement < Clause > reducedWFF = new PartitionListElement < Clause > ( ) ; for ( Clause cls : ( Set < Clause > ) myClauses ) { reducedWFF . add ( cls ) ; } int [ ] indices ; CombinationGenerator x = new CombinationGenerator ( reducedWFF . size ( ) , currentDepth ) ; StringBuffer combination ; HashSet < String > myWFF = new HashSet < String > ( ) ; while ( x . hasMore ( ) ) { combination = new StringBuffer ( ) ; indices = x . getNext ( ) ; for ( int i = 0 ; i < indices . length ; i ++ ) { combination . append ( reducedWFF . get ( indices [ i ] ) ) ; } String mynewWFF = combination . toString ( ) ; myWFF . add ( mynewWFF . replaceAll ( "\\]\\[" , "\\] \\[" ) ) ; } for ( String formString : myWFF ) { String newForm = formString ; newForm = newForm . replaceAll ( "\\[" , "(" ) ; newForm = newForm . replaceAll ( "\\] " , ") & " ) ; newForm = newForm . replaceAll ( "\\]" , ")" ) ; newForm = newForm . replaceAll ( " " , " |" ) ; results . add ( new WFF ( newForm ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return results ; }
te	2	public Values < V > values ( ) { if ( values1 == null ) { values1 = new Values ( this ) ; values2 = new Values ( this ) ; } if ( ! values1 . valid ) { values1 . reset ( ) ; values1 . valid = true ; values2 . valid = false ; return values1 ; } values2 . reset ( ) ; values2 . valid = true ; values1 . valid = false ; return values2 ; }
te	1	public SubjectID addSubject ( String organization , String id ) { Contributor contributor = Contributor . findContributor ( organization ) ; SubjectID sid = null ; if ( contributor != null ) { sid = this . addSubject ( contributor , id ) ; } else { logger . warn ( "Unknown contributor: " + organization ) ; } return sid ; }
te	5	public void createIndex ( ) { Segmenter seg = new Segmenter ( ) ; WordsFilter filter = new WordsFilter ( ) ; List < CoreLabel > words ; ResultSet resultSet = null ; String query = "select distinct indexid from dblpcitation union select distinct citationid from dblpcitation;" ; ResultSet rs = sqLconnection . Query ( query ) ; try { String insert = "insert into TermInfos(term indexid pos) values(? ? ?)" ; int count = 0 ; PreparedStatement statement = sqLconnection . conn . prepareStatement ( insert ) ; while ( rs . next ( ) ) { int index = rs . getInt ( "indexid" ) ; query = "select title abstract from dblpbase where indexid=" + index ; resultSet = sqLconnection . Query ( query ) ; resultSet . next ( ) ; String content = resultSet . getString ( "title" ) ; content += " " + resultSet . getString ( "abstract" ) ; words = seg . TokenAPI ( content ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { String word = words . get ( i ) . toString ( ) . toLowerCase ( ) ; if ( ! filter . result ( word ) . equals ( "" ) ) { statement . setString ( 1 , word ) ; statement . setInt ( 2 , index ) ; statement . setInt ( 3 , i ) ; statement . addBatch ( ) ; } } if ( count % 10000 == 0 ) { System . out . println ( "current number: " + count ) ; statement . executeBatch ( ) ; statement . clearBatch ( ) ; resultSet = null ; words . clear ( ) ; query = null ; } count ++ ; } statement . executeBatch ( ) ; sqLconnection . disconnectMySQL ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
te	5	public void addListaElevi ( Clasa cl , Node node ) { NodeList childNodes = node . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node cNode = childNodes . item ( i ) ; if ( cNode instanceof Element ) { String content = cNode . getTextContent ( ) . trim ( ) ; if ( cNode . getNodeName ( ) . equals ( "elev" ) ) { for ( Elev e : elevi ) { if ( e . getCNP ( ) . equals ( content ) ) { cl . addElev ( e ) ; } } } } } }
te	1	public Human ( Game game , InetAddress ip , int port ) { super ( game , ip , port ) ; try { this . setPlayerSpriteSheet ( ImageIO . read ( new File ( "res/img/human_male.png" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } this . setPlayerSprite ( getPlayerSpriteSheet ( ) . getSubimage ( getSpriteX ( ) * 32 , getSpriteY ( ) * 32 , getSpriteWidth ( ) , getSpriteHeight ( ) ) ) ; this . setHeight ( 47 ) ; this . setStandingLeftHandX ( 14 ) ; this . setStandingLeftHandY ( 35 ) ; this . setWalkingLeftHandX ( 11 ) ; this . setWalkingLeftHandY ( 33 ) ; this . setStandingRightHandX ( 18 ) ; this . setStandingRightHandY ( 35 ) ; this . setWalkingRightHandX ( 22 ) ; this . setWalkingRightHandY ( 33 ) ; this . setWeaponXTweak ( getStandingLeftHandX ( ) ) ; this . setWeaponYTweak ( getStandingLeftHandY ( ) ) ; }
te	0	@ Test public void testMaxPriorityQueueWithSmallSetOfInts ( ) { MaxPriorityQueue < Integer > pq = new MaxPriorityQueue < Integer > ( 20 ) ; pq . insert ( 9 ) ; pq . insert ( 11 ) ; pq . insert ( 2 ) ; pq . insert ( 9 ) ; pq . insert ( 19 ) ; pq . insert ( 2 ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 19 ) ) ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 11 ) ) ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 9 ) ) ) ; }
te	1	public static boolean isPointsEnoughToBuyToolWithNumber ( int points , Tool tool ) { if ( points < tool . getBuyPoints ( ) ) { return false ; } return true ; }
te	6	public boolean dropLink ( String name ) throws GlobalException , NoDataException { try { conectar ( user , pass , ip , port , db ) ; } catch ( ClassNotFoundException ex ) { throw new GlobalException ( "No se ha localizado el Driver" ) ; } catch ( SQLException e ) { throw new NoDataException ( "La base de datos no se encuentra disponible" ) ; } ResultSet rs = null ; Statement stmt = null ; try { stmt = conexion . createStatement ( ) ; String ss = "DROP DATABASE LINK " + name ; System . out . println ( ss ) ; rs = stmt . executeQuery ( ss ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; throw new GlobalException ( "Sentencia no valida" ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( stmt != null ) { stmt . close ( ) ; } desconectar ( ) ; return true ; } catch ( SQLException e ) { throw new GlobalException ( "Estatutos invalidos o nulos" ) ; } } }
te	1	private Invite [ ] fetchMultiResults ( ResultSet rs ) throws SQLException { Collection resultList = new ArrayList ( ) ; while ( rs . next ( ) ) { Invite dto = new Invite ( ) ; populateDto ( dto , rs ) ; resultList . add ( dto ) ; } Invite ret [ ] = new Invite [ resultList . size ( ) ] ; resultList . toArray ( ret ) ; return ret ; }
te	1	@ Override public Log getLogger ( ) { if ( client == null ) { return new Log ( ) ; } else { return client . getLogger ( ) ; } }
te	9X	private List < List < String >> find ( String end , Set < String > dict , List < List < String >> nowLists ) { List < List < String >> ansLists = new ArrayList < List < String >> ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; if ( checkValid ( nowStr , end ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( end ) ; ansLists . add ( temp ) ; } } if ( ansLists . size ( ) > 0 ) return ansLists ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : almostList ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; ansLists . add ( temp ) ; } } } if ( ansLists . size ( ) > 0 ) return find ( end , dict , ansLists ) ; List < String > removeList = new ArrayList < String > ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : dict ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; removeList . add ( s ) ; ansLists . add ( temp ) ; } } } for ( String s : removeList ) { dict . remove ( s ) ; } if ( ansLists . size ( ) == 0 ) return ansLists ; return find ( end , dict , ansLists ) ; }
te	5	public static BigInteger check ( ) { for ( BigInteger a : primes ) { for ( BigInteger b : primes ) { for ( int i = 0 ; i < 80 ; i ++ ) { int sum = i * i + a . intValue ( ) * i + b . intValue ( ) ; BigInteger test = new BigInteger ( String . valueOf ( sum ) ) ; if ( ! sprimes . contains ( test ) ) { if ( i > max ) { max = i ; result = a . multiply ( b ) ; System . out . println ( max ) ; } break ; } } } } return result ; }
te	9X	private static boolean method523 ( char ac [ ] ) { boolean flag = true ; for ( int i = 0 ; i < ac . length ; i ++ ) if ( ! isDigit ( ac [ i ] ) && ac [ i ] != 0 ) flag = false ; if ( flag ) return true ; int j = method524 ( ac ) ; int k = 0 ; int l = fragments . length - 1 ; if ( j == fragments [ k ] || j == fragments [ l ] ) return true ; do { int i1 = ( k + l ) / 2 ; if ( j == fragments [ i1 ] ) return true ; if ( j < fragments [ i1 ] ) l = i1 ; else k = i1 ; } while ( k != l && k + 1 != l ) ; return false ; }
te	1	public static void addClass ( Node node , String classname ) { AttVal classattr = node . getAttrByName ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; } else node . addAttribute ( "class" , classname ) ; }
te	3	public String [ ] getDisclosedSensitiveColumnNames ( ) { List < String > tmpList = new ArrayList < String > ( ) ; for ( int i = 0 ; i < this . MY_COLUMNS . size ( ) ; i ++ ) { if ( ! this . MY_COLUMNS . get ( i ) . getIsHide ( ) && this . MY_COLUMNS . get ( i ) . getColumnType ( ) == ColumnType . SENSITIVE ) { tmpList . add ( this . MY_COLUMNS . get ( i ) . getName ( ) ) ; } } return ( String [ ] ) tmpList . toArray ( new String [ tmpList . size ( ) ] ) ; }
te	8	public boolean showEventMessage ( final List < CalendarEventData > calendarEventList ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { StringBuilder message = new StringBuilder ( ) ; boolean warning = false ; for ( CalendarEventData calendarEvent : calendarEventList ) { message . append ( calendarEvent . getTitle ( ) ) ; if ( calendarEvent . getLocation ( ) . length ( ) != 0 ) { message . append ( "@" ) ; message . append ( calendarEvent . getLocation ( ) ) ; } message . append ( "\u304C\n" ) ; message . append ( TIME_FORMAT . format ( calendarEvent . getStartDate ( ) ) ) ; message . append ( "\u306B\u958B\u59CB\u3067\u3059\u3002" ) ; if ( calendarEvent . isWarning ( ) ) { message . append ( "\n" ) ; message . append ( "\u3059\u3067\u306B\u958B\u59CB\u6642\u523B\u3092\u904E\u304E\u3066\u3044\u307E\u3059\uFF01" ) ; warning = true ; } } if ( warning ) { trayIcon . displayMessage ( null , message . toString ( ) , TrayIcon . MessageType . WARNING ) ; System . out . println ( "\u30A2\u30A4\u30B3\u30F3\u30E1\u30C3\u30BB\u30FC\u30B8\u8868\u793A" ) ; } else { trayIcon . displayMessage ( null , message . toString ( ) , TrayIcon . MessageType . INFO ) ; System . out . println ( "\u30A2\u30A4\u30B3\u30F3\u30E1\u30C3\u30BB\u30FC\u30B8\u8868\u793A" ) ; } boolean ret = super . showEventMessage ( calendarEventList ) ; return ret ; } else { final List < boolean > result = new ArrayList < boolean > ( ) ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { result . add ( showEventMessage ( calendarEventList ) ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } if ( result . size ( ) != 0 ) { return result . get ( 0 ) ; } return true ; } }
te	6	@ Override public void widgetSelected ( SelectionEvent e ) { boolean everythingworked = true ; if ( removechecked ) { everythingworked = user . Remove ( ) ; } else { String newpass = pass_tbox . getText ( ) ; String newname = name_tbox . getText ( ) ; if ( pass_chkbx . getSelection ( ) && Sanitizer . isCleanInput ( newpass ) ) { everythingworked = user . Changepass ( newpass ) ; } if ( name_chkbx . getSelection ( ) && Sanitizer . isCleanInput ( newname ) ) { everythingworked = user . Changename ( newname ) ; } } if ( ! everythingworked ) { System . out . println ( "Did not work----- sorry" ) ; } throwaway ( ) ; }
te	9X	@ Override public void stateChanged ( ChangeEvent e ) { switch ( ( ( JTabbedPane ) e . getSource ( ) ) . getSelectedIndex ( ) ) { case MY_HISTORY : if ( ! changed [ MY_HISTORY ] ) { changed [ MY_HISTORY ] = true ; } break ; case MY_STEPS : if ( ! changed [ MY_STEPS ] ) { changed [ MY_STEPS ] = true ; steps . renewChart ( ) ; } break ; case MY_ACHIEVEMENT : if ( ! changed [ MY_ACHIEVEMENT ] ) { changed [ MY_ACHIEVEMENT ] = true ; achievement . update ( ) ; } break ; case OUR_DIFFERENCE : if ( difference . getOppID ( ) == null ) difference . askForUserID ( ) ; break ; case SUBONLINE : submit . askForProID ( ) ; break ; default : break ; } }
te	8	@ Override public void actionPerformed ( ActionEvent actionEvent ) { Object source = actionEvent . getSource ( ) ; if ( source == jButtonExtendPanel ) { isExtended = ! isExtended ; displayExtendedPanel ( ) ; } else if ( source == jComponentBegin ) { if ( ( ( JButton ) jComponentBegin ) . getIcon ( ) == ConfigIcon . COLUMN_NOT_ALL_SELECTED ) { for ( int i_idFilter = 0 ; i_idFilter < tabModel . getListFilter ( ) . length ; i_idFilter ++ ) { tabModel . getColumnHider ( ) . show ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } for ( Filter filterTmp : tabModel . getListFilter ( ) ) { filterTmp . setColumnVisible ( true ) ; } updateButtonColumn ( ) ; updateCheckBoxColumn ( ) ; } } else { for ( int i_idFilter = 0 ; i_idFilter < tabModel . getListFilter ( ) . length ; i_idFilter ++ ) { if ( source == listComponent [ i_idFilter ] ) { tabModel . getListFilter ( ) [ i_idFilter ] . setColumnVisible ( ! tabModel . getListFilter ( ) [ i_idFilter ] . isColumnVisible ( ) ) ; updateButtonColumn ( ) ; if ( tabModel . getListFilter ( ) [ i_idFilter ] . isColumnVisible ( ) ) { tabModel . getColumnHider ( ) . show ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } else { tabModel . getColumnHider ( ) . hide ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } break ; } } } }
te	8	private void scoreRound ( ) { HashMap < String , ArrayList < Integer >> theScores = new HashMap < String , ArrayList < Integer >> ( ) ; ArrayList < Integer > pars = new ArrayList < Integer > ( ) ; ArrayList < Integer > score = new ArrayList < Integer > ( ) ; for ( int column = 1 ; column < tblScorecard . getColumnCount ( ) ; column ++ ) { score = new ArrayList < Integer > ( ) ; for ( int row = 0 ; row < currentCourse . getNumberOfHoles ( ) ; row ++ ) { Object obj = tblScorecard . getModel ( ) . getValueAt ( row , column ) ; int cell = 0 ; if ( obj instanceof Integer ) { cell = ( int ) obj ; } else { cell = Integer . parseInt ( ( String ) obj ) ; } if ( column == 1 ) { pars . add ( cell ) ; } else { score . add ( cell ) ; } } String username = ( String ) tblScorecard . getColumnModel ( ) . getColumn ( column ) . getHeaderValue ( ) ; if ( column != 1 ) { theScores . put ( username , score ) ; } } Scorecard scorecard = new Scorecard ( currentCourse . getName ( ) , theScores , pars ) ; HashMap < String , ScorecardSummary > summaries = scorecard . getSummaries ( ) ; for ( String player : summaries . keySet ( ) ) { if ( Manager . getInstance ( ) . getProfiles ( ) . containsKey ( player ) ) { Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . updateFromScorecard ( summaries . get ( player ) ) ; System . out . println ( Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . getProfileSummary ( ) ) ; } else { int reply = JOptionPane . showConfirmDialog ( null , "No profile was found for " + player + "  would you like to create one?" , "Profile not found" , JOptionPane . YES_NO_OPTION ) ; if ( reply == JOptionPane . YES_OPTION ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new NewProfile ( ) . setVisible ( true ) ; } } ) ; } } } clearScorecard ( ) ; }
te	9X	protected TextIDPair readNextDocText ( BufferedReader docIn ) throws IOException { String line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".I" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { String [ ] parts = line . split ( "\\s+" ) ; if ( parts . length != 2 ) { throw new RuntimeException ( "CranfieldReader::Problems finding docID: " + line ) ; } int docID = Integer . parseInt ( parts [ 1 ] ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".W" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { StringBuffer buffer = new StringBuffer ( ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . equals ( "<END_DOC>" ) ) { buffer . append ( " " + line ) ; line = docIn . readLine ( ) ; } return new TextIDPair ( buffer . toString ( ) , docID ) ; } } }
te	0	public void setDeliverTypeId ( long deliverTypeId ) { this . deliverTypeId = deliverTypeId ; }
te	2	public synchronized boolean doLogin ( String nomeGiocatore , String suppliedPassword ) throws UserAuthenticationFailedException { if ( getPMan ( ) . exists ( nomeGiocatore ) ) { Giocatore tempGiocatore = getPMan ( ) . getPlayer ( nomeGiocatore ) ; if ( tempGiocatore . passwordIsValid ( suppliedPassword ) ) { getCMan ( ) . collega ( nomeGiocatore , CommonUtils . getNewToken ( ) ) ; return true ; } else throw new UserAuthenticationFailedException ( ) ; } else return false ; }
te	3	public static Node findCycle ( List list ) { if ( list == null ) return null ; Node current = list . getHead ( ) ; Map < Node , boolean > seen = new HashMap < Node , boolean > ( ) ; while ( current != null ) { if ( seen . get ( current ) != null ) { return current ; } seen . put ( current , true ) ; current = current . getNext ( ) ; } return null ; }
te	5	@ Override public List < Article > findAll ( ) { List < Article > list = new ArrayList < Article > ( ) ; String sql = "SELECT * FROM T_ARTICLE" ; Statement statement = null ; ResultSet resultSet = null ; try { statement = connection . createStatement ( ) ; resultSet = statement . executeQuery ( sql ) ; System . out . println ( sql ) ; while ( resultSet . next ( ) ) { Article found = new Article ( ) ; found . setId ( resultSet . getInt ( "ID" ) ) ; found . setQuantite ( resultSet . getInt ( "quantite" ) ) ; found . setClient ( new ClientDAO ( ) . find ( resultSet . getInt ( "FK_ID_CLIENT" ) ) ) ; found . setStock ( new StockDAO ( ) . find ( resultSet . getInt ( "FK_ID_STOCK" ) ) ) ; list . add ( found ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "find all articles failed" , ex ) ; } finally { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "free resourses failed" , ex ) ; } } return list ; }
te	8	public void plug ( Context plug ) { context = plug ; config = plug . getConfigurator ( ) ; shell = plug . getShell ( ) ; prompt = plug . getPrompt ( ) ; input = ( input = ( InputStream ) context . getValue ( Context . KEY_INPUT_STREAM ) ) != null ? input : System . in ; output = ( output = ( OutputStream ) context . getValue ( Context . KEY_OUTPUT_STREAM ) ) != null ? output : System . out ; inputHints = new HashMap < String , String [ ] > ( ) ; try { console = new ConsoleReader ( input , new OutputStreamWriter ( output ) ) ; } catch ( IOException ex ) { throw new RuntimeException ( "Unable to initialize the console. " + " Program will stop now." , ex ) ; } controllers = plug . getPluginsByType ( InputController . class ) ; if ( controllers . size ( ) > 0 ) { for ( InputController ctrl : controllers ) { ctrl . plug ( plug ) ; } aggregateExpectedInputs ( ) ; console . setCompletionHandler ( new CandidateListCompletionHandler ( ) ) ; } else { throw new RuntimeException ( "Unable to initialize Clamshell-Cli. " + " No InputController instances found on classpath. Exiting..." ) ; } List < SplashScreen > screens = plug . getPluginsByType ( SplashScreen . class ) ; if ( screens != null && screens . size ( ) > 0 ) { for ( SplashScreen sc : screens ) { sc . plug ( plug ) ; sc . render ( plug ) ; } } consoleThread = createConsoleThread ( ) ; consoleThread . start ( ) ; }
te	3	private void arrangeOptions ( Collection < String > unarranged ) { if ( unarranged . size ( ) == 1 ) { options . addAll ( unarranged ) ; return ; } List < String > shortOptions = new ArrayList < String > ( ) ; List < String > longOptions = new ArrayList < String > ( ) ; for ( String each : unarranged ) { if ( each . length ( ) == 1 ) shortOptions . add ( each ) ; else longOptions . add ( each ) ; } sort ( shortOptions ) ; sort ( longOptions ) ; options . addAll ( shortOptions ) ; options . addAll ( longOptions ) ; }
te	9X	private static boolean parseInvBool ( String s , String option ) { boolean b = false ; if ( s != null && s . length ( ) > 0 ) { char c = s . charAt ( 0 ) ; if ( ( c == t ) || ( c == T ) || ( c == Y ) || ( c == y ) ) b = true ; else if ( ( c == f ) || ( c == F ) || ( c == N ) || ( c == n ) ) b = false ; else Report . badArgument ( option ) ; } return ! b ; }
te	2	public void test_GetRevisionInfo ( ) { FileHistory fileHist = new FileHistory ( path . resolve ( "README.txt" ) ) ; fileHist . storeRevision ( path . resolve ( "README.txt" ) , null , 100 , 200 ) ; fileHist . storeRevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; fileHist . storeRevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; DataRetriever dataRetriever = new DataRetriever ( path . resolve ( "README.txt" ) ) ; Vector < Vector < String >> tableData = dataRetriever . getRevisionInfoTable ( ) ; System . out . println ( "Please check time-depend result:" ) ; for ( Vector < String > rows : tableData ) { for ( String data : rows ) { System . out . println ( data ) ; } } }
te	7	private final boolean cvc ( int i ) { if ( i < 2 || ! cons ( i ) || cons ( i - 1 ) || ! cons ( i - 2 ) ) return false ; { int ch = b [ i ] ; if ( ch == w || ch == x || ch == y ) return false ; } return true ; }
te	0	public WorldMap ( MapBaggage baggage ) { planet = new Planet ( baggage . polarCircumferenceInKilometers ) ; mesh = new IcosahedralMesh ( baggage . meshSize ) ; int numCells = mesh . countCells ( ) ; terrain = Porter . stringsToTerrain ( baggage . terrainStrings , numCells ) ; bonuses = Porter . stringToBits ( baggage . bonusString , numCells ) ; roads = Porter . stringToBits ( baggage . roadString , numCells ) ; railroads = Porter . stringToBits ( baggage . railroadString , numCells ) ; irrigation = Porter . stringToBits ( baggage . irrigationString , numCells ) ; villages = Porter . stringToBits ( baggage . villageString , numCells ) ; cities = Porter . stringToBits ( baggage . cityString , numCells ) ; }
te	0	public void setMonth ( Date month ) { this . month = month ; }
te	0	public Sprite ( int i , int j ) { pixels = new int [ i * j ] ; width = maxWidth = i ; height = maxHeight = j ; offsetX = offsetY = 0 ; }
te	0	public MultiList ( ) { recommendedModel = new DefaultListModel < Champion > ( ) ; goodModel = new DefaultListModel < Champion > ( ) ; viableModel = new DefaultListModel < Champion > ( ) ; allModel = new DefaultListModel < Champion > ( ) ; instance = this ; submit ( ) ; EventHandler . addSlotLockListener ( new SlotLockListener ( ) { @ Override public void onSlotLock ( ) { submit ( ) ; } } ) ; EventHandler . addResetListener ( new ResetListener ( ) { @ Override public void onReset ( ) { reset ( ) ; submit ( ) ; } } ) ; }
te	6	public static boolean setupTables ( ) throws SQLException { boolean retVal = false ; if ( ! ( dbm . isTable ( "titles" ) || dbm . isTable ( "players" ) ) ) { try { dbm . query ( "CREATE TABLE IF NOT EXISTS titles (titleid VARCHAR(20) PRIMARY KEY  titlename VARCHAR(20));" ) ; dbm . query ( "CREATE TABLE IF NOT EXISTS players (playerid Integer PRIMARY KEY AUTO_INCREMENT  playername VARCHAR(20)  titleid VARCHAR(20));" ) ; dbm . query ( "ALTER TABLE players ADD CONSTRAINT FK_TITLES_ID FOREIGN KEY (titleid) REFERENCES titles(titleid);" ) ; retVal = true ; } catch ( SQLException ex ) { dbm . writeError ( "Error creating tables for DonorTitles database.\n" + ex . getMessage ( ) , true ) ; ex . printStackTrace ( ) ; try { if ( dbm . isTable ( "titles" ) ) { dbm . query ( "DROP TABLE titles;" ) ; } if ( dbm . isTable ( "players" ) ) { dbm . query ( "DROP TABLE players;" ) ; } } catch ( SQLException exs ) { throw new SQLException ( "Error dropping tables." , exs ) ; } } } return retVal ; }
te	8	public static long [ ] setup ( String moves_text ) { LogFile . message ( moves_text ) ; ArrayList < long > banned_positions = new ArrayList < long > ( ) ; moves_text = moves_text . replaceAll ( "%13" , "@" ) ; StringTokenizer tokenizer = new StringTokenizer ( moves_text , "@" ) ; if ( tokenizer . countTokens ( ) < 2 ) { return new long [ 0 ] ; } GameState gs = new GameState ( tokenizer . nextToken ( ) , tokenizer . nextToken ( ) ) ; ArrayList < long > hash_codes = new ArrayList < long > ( ) ; hash_codes . add ( new long ( gs . getPositionHash ( ) ) ) ; while ( tokenizer . hasMoreTokens ( ) ) { String move_token = tokenizer . nextToken ( ) ; StringTokenizer temp = new StringTokenizer ( move_token ) ; temp . nextToken ( ) ; String move = "" ; int steps = 0 ; while ( temp . hasMoreTokens ( ) ) { String step_token = temp . nextToken ( ) ; move += step_token + " " ; steps ++ ; } if ( steps == 0 ) { continue ; } if ( steps < 4 ) { move += "pass" ; } ArimaaMove temp_move = new ArimaaMove ( move ) ; gs . play ( temp_move , gs ) ; hash_codes . add ( new long ( gs . getPositionHash ( ) ) ) ; } while ( ! hash_codes . isEmpty ( ) ) { long test = ( long ) hash_codes . get ( hash_codes . size ( ) - 1 ) ; hash_codes . remove ( hash_codes . size ( ) - 1 ) ; if ( hash_codes . contains ( test ) ) { banned_positions . add ( test ) ; LogFile . message ( "Duplicate hash value: " + test ) ; } } long result [ ] = new long [ banned_positions . size ( ) ] ; for ( int i = 0 ; i < banned_positions . size ( ) ; i ++ ) { result [ i ] = banned_positions . get ( i ) . longValue ( ) ; } return result ; }
te	1	@ Override public void Eliminar ( ) throws SQLException { try { Conexion . GetInstancia ( ) . Conectar ( ) ; Conexion . GetInstancia ( ) . Ejecutar ( "DELETE FROM Cliente WHERE CedRuc_Cliente =" + ObCliente . getCedRuc_Persona ( ) ) ; } catch ( SQLException ex ) { throw ex ; } finally { Conexion . GetInstancia ( ) . Desconectar ( ) ; } }
te	6	private void processScore ( ) { int youngest = Integer . MAX_VALUE ; EPlayer player = EPlayer . None ; for ( Integer oldest : gr . oldestsP1 ) { if ( oldest < youngest ) { youngest = oldest ; player = EPlayer . P1 ; } } for ( Integer oldest : gr . oldestsP2 ) { if ( oldest < youngest ) { youngest = oldest ; player = EPlayer . P2 ; } } gr . scoreP1 = gr . oldestsP1 . size ( ) / 2f ; gr . scoreP2 = gr . oldestsP2 . size ( ) / 2f ; if ( player == EPlayer . P1 ) gr . scoreP1 += 1 / 2f ; else if ( player == EPlayer . P2 ) gr . scoreP2 += 1 / 2f ; }
te	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
te	4	private void completeCommand ( Command c , Agent a ) { if ( c != null ) { if ( c . cmd . equals ( "Move" ) ) completeMove ( c , a ) ; else if ( c . cmd . equals ( "Pull" ) ) completePull ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir2 . ordinal ( ) ] . object ) ; else if ( c . cmd . equals ( "Push" ) ) completePush ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir1 . ordinal ( ) ] . object ) ; } }
te	9X	public void parseSetting ( String arg ) { if ( arg . equals ( "-h" ) || arg . equals ( "--help" ) ) { System . out . println ( "Usage: RubixToDIMACS -r=RANDOMS [-verbose] [n=MAXMOVES] [e=ENCODING] [OUTPUT] [MAPPING]" ) ; System . out . println ( "   or: RubixToDIMACS -m=SEQUENCE [-verbose] [n=MAXMOVES] [e=ENCODING] [OUTPUT] [MAPPING]" ) ; System . out . println ( "   or: RubixToDIMACS [OUTPUT]" ) ; System . out . println ( "\nWrite the DIMACS encoding of a rubix cube " ) ; System . out . println ( "specified either by a sequence of moves or" ) ; System . out . println ( "an amount of random moves  to OUTPUT or stdout." ) ; System . out . println ( "\nThe arguments are:" ) ; System . out . println ( "-r=RANDOMS \t\tset the amount of random moves" ) ; System . out . println ( "-m=SEQUENCE\t\ta sequence of characters describing rubix cube moves:" ) ; System . out . println ( "           \t\tF = Clockwise Front Turn  F2 = Double Front Turn " ) ; System . out . println ( "           \t\tF' = Counter-clockwise Front Turn" ) ; System . out . println ( "           \t\tSimilar: B(ack)  L(eft)  R(ight)  U(p) and D(own)" ) ; System . out . println ( "           \t\tExample: The `sune` move would have the sequence:" ) ; System . out . println ( "           \t\t      -m=L'U'RULU'R'U" ) ; System . out . println ( "-verbose   \t\tIf set  print the move sequence to stderr" ) ; System . out . println ( "-n=MAXMOVES\t\tset the limit of moves to MAXMOVES" ) ; System . out . println ( "           \t\tThe default value is 50" ) ; System . out . println ( "-e=ENCODING\t\tDefines the class file that is used to encode the cube" ) ; System . out . println ( "           \t\tThe default is rubix.RubixSAT" ) ; System . out . println ( "OUTPUT     \t\tSpecifies the output file" ) ; System . out . println ( "MAPPING    \t\tSpecifies the mapping file" ) ; System . exit ( 0 ) ; } else if ( arg . startsWith ( "-r=" ) && moves . equals ( "" ) ) { random = Integer . parseInt ( arg . substring ( 3 ) ) ; } else if ( arg . startsWith ( "-m=" ) && random == - 1 ) { moves = arg . substring ( 3 ) ; } else if ( arg . startsWith ( "-e=" ) ) { encoding = arg . substring ( 3 ) ; } else if ( arg . charAt ( 0 ) != - && output . length ( ) == 0 ) { output = arg ; } else if ( arg . charAt ( 0 ) != - ) { mapping = arg ; } else if ( arg . startsWith ( "-n=" ) ) { max = Integer . parseInt ( arg . substring ( 3 ) ) ; } else if ( arg . equals ( "-verbose" ) ) { verbose = true ; } else { System . err . println ( "Illegal argument: " + arg ) ; System . exit ( 0 ) ; } }
te	0	public void setAddress ( Address address ) { this . address = address ; }
te	8	public void parseJson ( String fileName ) { try { InputStream is = new FileInputStream ( fileName ) ; JsonParser parser = Json . createParser ( is ) ; while ( parser . hasNext ( ) ) { Event event = parser . next ( ) ; switch ( event ) { case KEY_NAME : parser . getString ( ) ; break ; case VALUE_STRING : break ; case VALUE_NUMBER : break ; case VALUE_FALSE : break ; case VALUE_TRUE : break ; case VALUE_NULL : break ; default : } } } catch ( FileNotFoundException ex ) { System . out . println ( ex ) ; } }
te	5	public void loadLinearGradient ( String infile ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( infile ) ) ; String line ; String [ ] tmp ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && line . startsWith ( "start_gradient" ) ) { tmp = line . split ( "=" ) [ 1 ] . split ( " " ) ; this . lcTimes . add ( 0 , float . parseFloat ( tmp [ 0 ] ) ) ; this . percB . add ( 0 , float . parseFloat ( tmp [ 1 ] ) ) ; } if ( ! line . startsWith ( "#" ) && line . startsWith ( "end_gradient" ) ) { tmp = line . split ( "=" ) [ 1 ] . split ( " " ) ; this . lcTimes . add ( float . parseFloat ( tmp [ 0 ] ) ) ; this . percB . add ( float . parseFloat ( tmp [ 1 ] ) ) ; } } br . close ( ) ; }
te	5	static String getCallerInfo ( String className ) { String sourceClassName = null ; String sourceMethodName = null ; JavaLangAccess access = SharedSecrets . getJavaLangAccess ( ) ; Throwable throwable = new Throwable ( ) ; int depth = access . getStackTraceDepth ( throwable ) ; boolean lookingForClassName = true ; for ( int ix = 0 ; ix < depth ; ix ++ ) { StackTraceElement frame = access . getStackTraceElement ( throwable , ix ) ; String cname = frame . getClassName ( ) ; if ( lookingForClassName ) { if ( cname . equals ( className ) ) { lookingForClassName = false ; } } else { if ( ! cname . equals ( className ) ) { sourceClassName = cname ; sourceMethodName = frame . getMethodName ( ) ; break ; } } } if ( sourceClassName != null ) { return sourceClassName + " " + sourceMethodName ; } else { return "unknown" ; } }
te	7	@ Override public void actionPerformed ( ActionEvent e ) { Labyrinthe laby = new Labyrinthe ( tab ) ; if ( this != null ) { JFileChooser filechooser = new JFileChooser ( "." ) { public void approveSelection ( ) { fileSelected = getSelectedFile ( ) ; if ( fileSelected . exists ( ) ) { int result = JOptionPane . showConfirmDialog ( this , "Ecraser le fichier?" , "Confirmation" , JOptionPane . YES_NO_CANCEL_OPTION ) ; switch ( result ) { case JOptionPane . YES_OPTION : super . approveSelection ( ) ; return ; default : super . cancelSelection ( ) ; } } else super . approveSelection ( ) ; } } ; if ( filechooser . showSaveDialog ( null ) == JFileChooser . APPROVE_OPTION ) { for ( int i = 0 ; i < tab . length ; i ++ ) { for ( int j = 0 ; j < tab [ i ] . length ; j ++ ) { System . out . println ( "Valeur du tableau " + tab [ i ] [ j ] . etat ) ; } } } } else { JOptionPane . showMessageDialog ( InterfaceEditeur . this , "veuillez creer un nouveau labyrinthe ou charger un labyrinthe existant" , "Erreur" , JOptionPane . ERROR_MESSAGE ) ; } try { laby . addToFile ( laby , fileSelected ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } getContentPane ( ) . revalidate ( ) ; }
te	4	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	9X	public double evaluate ( FunctionArguments args ) throws IllegalArgumentException , MalformedFunctionException { if ( ( args == null && variables != 0 ) || ( args != null && args . getArgCount ( ) != variables ) ) { throw new IllegalArgumentException ( "Wrong argument count" ) ; } ArrayList < double > stack = new ArrayList < double > ( ) ; Iterator < Token > iter = tokens . iterator ( ) ; do { Token next = iter . next ( ) ; if ( next instanceof ConstantToken ) { stack . add ( ( ( ConstantToken ) next ) . getValue ( ) ) ; } else if ( next instanceof VariableToken ) { stack . add ( args . getArg ( ( ( VariableToken ) next ) . getID ( ) ) ) ; } else if ( next instanceof FunctionToken ) { Function f = ( ( FunctionToken ) next ) . getFunction ( ) ; if ( stack . size ( ) < f . getArgCount ( ) ) { throw new MalformedFunctionException ( "Improper argument count" ) ; } double [ ] d = new double [ f . getArgCount ( ) ] ; for ( int i = 0 ; i < f . getArgCount ( ) ; i ++ ) { d [ d . length - i - 1 ] = stack . remove ( stack . size ( ) - 1 ) ; } stack . add ( f . evaluate ( new FunctionArguments ( d ) ) ) ; } else { throw new MalformedFunctionException ( "Unkown token type" ) ; } } while ( iter . hasNext ( ) ) ; if ( stack . size ( ) != 1 ) { throw new MalformedFunctionException ( "Function was not properly formed" ) ; } return stack . get ( 0 ) ; }
te	1	private static List < ABObject > GetSupporteeShel ( HashMap < ABObject , List < ABObject >> supportee , ABObject roof ) { List < ABObject > temp = new ArrayList < ABObject > ( ) ; for ( ABObject ab : supportee . keySet ( ) ) { temp . addAll ( GetSupporteeShel ( supportee . get ( ab ) , roof ) ) ; } return temp ; }
te	6	public boolean configure ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { if ( player instanceof Processor ) ( ( Processor ) player ) . configure ( ) ; else if ( player instanceof Player ) ( ( Processor ) player ) . configure ( ) ; else return false ; while ( ! configured && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return configured ; }
te	5	ComplexNumberNode parseComplex ( SeekableStringReader sr ) { if ( sr . peek ( ) == ( ) { sr . read ( ) ; String numberstr ; if ( sr . peek ( ) == - || sr . peek ( ) == + ) { numberstr = sr . read ( 1 ) + sr . readUntil ( "+-" ) ; } else numberstr = sr . readUntil ( "+-" ) ; double real ; try { real = double . parseDouble ( numberstr ) ; } catch ( NumberFormatException x ) { throw new ParseException ( "invalid float format" , x ) ; } sr . rewind ( 1 ) ; double imaginarypart = parseImaginaryPart ( sr ) ; if ( sr . read ( ) != ) ) throw new ParseException ( "expected ) to end a complex number" ) ; ComplexNumberNode c = new ComplexNumberNode ( ) ; c . real = real ; c . imaginary = imaginarypart ; return c ; } else { double imag = parseImaginaryPart ( sr ) ; ComplexNumberNode c = new ComplexNumberNode ( ) ; c . real = 0 ; c . imaginary = imag ; return c ; } }
te	2	public void printGlossary ( ) { String title = String . format ( "\nGlossary\n" ) ; logger . write ( title ) ; String body = null ; for ( int i = 0 ; i < allComponents . size ( ) ; i ++ ) { if ( null != allComponents . get ( i ) ) body = String . format ( "\t" + allComponents . get ( i ) . getGlossary ( ) + "\n" ) ; logger . write ( body ) ; } }
te	8	private void readBuffer ( long timeout , long startTime , SelectionKey readKey , ByteBuffer buffer ) throws IOException { boolean firstTime = true ; while ( currentTime ( ) - startTime < timeout && buffer . position ( ) != buffer . capacity ( ) ) { if ( ! firstTime ) { long waitDuration = startTime + timeout - currentTime ( ) ; if ( waitDuration > 0 ) { selector . select ( waitDuration ) ; } } if ( firstTime || selector . selectedKeys ( ) . size ( ) > 0 ) { int read ; do { read = socketChannel . read ( buffer ) ; } while ( read > 0 ) ; if ( firstTime ) { firstTime = false ; } else { selector . selectedKeys ( ) . remove ( readKey ) ; } } } }
te	3	public void setup ( ) { String host = "206.87.3.136" ; int port = 9999 ; try { skt = new Socket ( host , port ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { myInput = new BufferedReader ( new InputStreamReader ( skt . getInputStream ( ) ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { myOutput = new PrintStream ( skt . getOutputStream ( ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } }
te	8	@ Override public byte [ ] toBytes ( Object value ) { Date date = ( Date ) value ; Calendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( date ) ; long result ; switch ( precision ) { case DATETIME : result = calendar . getTimeInMillis ( ) ; break ; case DATETIME_NOMILLIS : calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case DATE : calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case TIME : case TIME_NOMILLIS : int hours = calendar . get ( Calendar . HOUR_OF_DAY ) ; int minutes = calendar . get ( Calendar . MINUTE ) ; int seconds = calendar . get ( Calendar . SECOND ) ; int millis = precision == Precision . TIME ? calendar . get ( Calendar . MILLISECOND ) : 0 ; result = ( hours * 60 * 60 * 1000 ) + ( minutes * 60 * 1000 ) + ( seconds * 1000 ) + millis ; break ; default : throw new RuntimeException ( "Unexpected precision: " + precision ) ; } byte [ ] bytes = new byte [ getLength ( ) ] ; switch ( precision ) { case TIME : case TIME_NOMILLIS : Bytes . putInt ( bytes , 0 , ( int ) result ) ; break ; default : Bytes . putLong ( bytes , 0 , result ) ; } bytes [ 0 ] = ( byte ) ( bytes [ 0 ] ^ 80 ) ; return bytes ; }
te	9X	public static void main ( String [ ] args ) { long [ ] lastRow = new long [ 1 ] ; lastRow [ 0 ] = 1 ; for ( int i = 1 ; i <= SIZE ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < lastRow . length ; j ++ ) nextRow [ j ] = ( lastRow [ j - 1 ] + lastRow [ j ] ) % 1000000000000 ; lastRow = nextRow ; } int count = 0 ; long [ ] currentRow = new long [ 1 ] ; currentRow [ 0 ] = 1 ; for ( int i = 1 ; i < lastRow . length ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < currentRow . length ; j ++ ) nextRow [ j ] = ( currentRow [ j - 1 ] + currentRow [ j ] ) % 1000000000000 ; currentRow = nextRow ; long multiplier = lastRow [ i - 1 ] ; int initialTwos = numTwos ( multiplier ) ; int initialFives = numFives ( multiplier ) ; for ( int j = 0 ; j < nextRow . length ; j ++ ) { int twos = numTwos ( nextRow [ j ] ) ; int fives = numFives ( nextRow [ j ] ) ; if ( initialTwos + twos >= 12 && initialFives + fives >= 12 ) count ++ ; } } System . out . print ( count ) ; }
te	0	@ Override protected double getDefault ( ) { return 0d ; }
te	6	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if ( ( request . getParameter ( "contenido" ) != null ) ) { oEntrada . setContenido ( request . getParameter ( "contenido" ) ) ; } if ( ( request . getParameter ( "id_hilo" ) != null ) ) { oEntrada . getHilo ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_hilo" ) ) ) ; } if ( ( request . getParameter ( "id_usuario" ) != null ) ) { oEntrada . getUsuario ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_usuario" ) ) ) ; } if ( ( request . getParameter ( "fecha" ) != null ) ) { oEntrada . setFecha ( new SimpleDateFormat ( "dd-MM-yyyy" ) . parse ( request . getParameter ( "fecha" ) ) ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
te	4	private static String toJavaQuantifier ( String cacheQuantifier ) { if ( cacheQuantifier . equals ( "." ) ) { return "*" ; } if ( cacheQuantifier . contains ( "." ) ) { String [ ] partes = cacheQuantifier . split ( "\\." ) ; String min = partes [ 0 ] ; if ( min . length ( ) == 0 ) { min = "0" ; } String max = "" ; if ( partes . length > 1 ) { max = partes [ 1 ] ; } return "{" . concat ( min ) . concat ( " " ) . concat ( max ) . concat ( "}" ) ; } return "{" . concat ( cacheQuantifier ) . concat ( "}" ) ; }
te	8	private void parseRow ( String [ ] header , String [ ] row , int rowNumber ) throws InvalidInput { if ( ! GenotypeHelper . isGenotype ( row [ 0 ] ) ) throw new NotGenotype ( row [ 0 ] , INPUT_AREA , rowNumber , 1 ) ; if ( ! GenotypeHelper . isGenotype ( row [ 1 ] ) ) throw new NotGenotype ( row [ 1 ] , INPUT_AREA , rowNumber , 2 ) ; String mother , father ; if ( GenotypeHelper . isFemale ( row [ 0 ] ) ) { mother = row [ 0 ] ; if ( ! GenotypeHelper . isMale ( row [ 1 ] ) ) throw new WrongParentsPair ( row [ 0 ] , row [ 1 ] , INPUT_AREA , rowNumber , 1 ) ; father = row [ 1 ] ; } else { father = row [ 0 ] ; if ( ! GenotypeHelper . isFemale ( row [ 1 ] ) ) throw new WrongParentsPair ( row [ 0 ] , row [ 1 ] , INPUT_AREA , rowNumber , 1 ) ; mother = row [ 1 ] ; } Map < String , double > composition = new LinkedHashMap < > ( ) ; for ( int i = 2 ; i < row . length ; i ++ ) { double percentage ; try { percentage = double . parseDouble ( row [ i ] ) ; } catch ( NumberFormatException e ) { throw new NotDouble ( row [ i ] , INPUT_AREA , rowNumber , i + 1 ) ; } if ( percentage > 0.0 ) composition . put ( header [ i ] , percentage ) ; } posterity . addCompositionFor ( mother , father , composition ) ; }
te	7	int [ ] getRowGaps ( ContainerWrapper parent , BoundSize defGap , int refSize , boolean before ) { BoundSize gap = before ? gapBefore : gapAfter ; if ( gap == null || gap . isUnset ( ) ) gap = defGap ; if ( gap == null || gap . isUnset ( ) ) return null ; int [ ] ret = new int [ 3 ] ; for ( int i = LayoutUtil . MIN ; i <= LayoutUtil . MAX ; i ++ ) { UnitValue uv = gap . getSize ( i ) ; ret [ i ] = uv != null ? uv . getPixels ( refSize , parent , null ) : LayoutUtil . NOT_SET ; } return ret ; }
te	1	public static String createJquery ( Chart < ? > chart , String divId ) { return createJquery ( chart , divId , null ) ; }
te	4	private String unquoteString ( String value ) { if ( value . startsWith ( "\"\"\"" ) || value . startsWith ( "'''" ) ) { return value . substring ( 3 , value . length ( ) - 3 ) ; } else if ( value . startsWith ( "\"" ) || value . startsWith ( "'" ) ) { return value . substring ( 1 , value . length ( ) - 1 ) ; } return value ; }
te	6	public void keyTyped ( KeyEvent e ) { if ( curIndex < 0 ) curIndex = 0 ; if ( curIndex > currentText . length ( ) ) curIndex = currentText . length ( ) - 1 ; currentText = new StringBuffer ( currentText ) . replace ( curIndex , curIndex + 1 , "" ) . toString ( ) ; switch ( e . getKeyChar ( ) ) { case KeyEvent . VK_BACK_SPACE : if ( curIndex > 0 ) { removeChar ( curIndex - 1 ) ; } curIndex -- ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; case KeyEvent . VK_LEFT : removeChar ( curIndex ) ; curIndex -- ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; case KeyEvent . VK_RIGHT : removeChar ( curIndex ) ; curIndex ++ ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; default : addChar ( e . getKeyChar ( ) , curIndex ) ; curIndex ++ ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; } }
te	2	public static boolean isPalindrome ( String s , int l , int r ) { while ( l < r ) { if ( s . charAt ( l ) != s . charAt ( r ) ) { return false ; } l ++ ; r -- ; } return true ; }
te	8	public ListNode rotateRight ( ListNode head , int n ) { ListNode front = head ; ListNode end = head ; if ( n == 0 || head == null ) return head ; while ( n > 0 ) { if ( end == null ) end = head ; end = end . next ; n -- ; } if ( end == null ) { return head ; } while ( true ) { if ( end . next == null ) { end . next = head ; ListNode newHead = front . next ; front . next = null ; return newHead ; } if ( front == end ) { return null ; } front = front . next ; end = end . next ; } }
te	1	public void delete ( Users persistentInstance ) { log . debug ( "deleting " + entitySimpleName + " instance" ) ; try { super . delete ( persistentInstance ) ; log . debug ( entitySimpleName + " delete successful" ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " delete failed" , re ) ; throw re ; } }
te	0	public static byte [ ] getValues ( ) { byte [ ] values = { ENCODED_VOICE , RAW_BINARY_DATA , APPLICATION_SPECIFIC_DATA , DATABASE_INDEX } ; return values ; }
te	1	void removeAll ( ) { for ( int i = 0 ; i < MAX_TILES ; i ++ ) { removeTile ( i , true ) ; } }
te	0	java . lang . Integer getKey ( String value ) { java . lang . Integer key ; key = Integer . valueOf ( value ) ; return key ; }
te	1	public CertificatesPane ( ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; for ( int i = 0 ; i < labels . length ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; add ( new JLabel ( labels [ i ] + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; pathFields [ i ] = new JTextField ( 40 ) ; pathFields [ i ] . setFont ( MainGUI . FONT ) ; pathFields [ i ] . setInputVerifier ( pathInputVerifier ) ; pathFields [ i ] . getCaret ( ) . addChangeListener ( new CaretChangeListener ( pathFields [ i ] , pathInputVerifier ) ) ; components . add ( pathFields [ i ] ) ; add ( pathFields [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Choose file..." ) ; button . setActionCommand ( "choose" + i ) ; button . addActionListener ( this ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcert" + i ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Default" ) ; button . setActionCommand ( "restorecert" + i ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } setBorder ( BorderFactory . createTitledBorder ( "Certificates" ) ) ; }
te	6	private static < AnyType extends Comparable < ? super AnyType >> void quicksort ( AnyType [ ] a , int left , int right ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; quicksort ( a , left , i - 1 ) ; quicksort ( a , i + 1 , right ) ; } else insertionSort ( a , left , right ) ; }
te	0	public double getPickUpPuckBaseChance ( ) { return pickUpPuckBaseChance ; }
te	4	public static List < StringChange > replaceAll ( F1 < Matcher , String > f1 , Pattern ptn , String text , int from , int to ) { Matcher matcher = ptn . matcher ( text ) ; ArrayList < StringChange > changes = new ArrayList < > ( ) ; if ( matcher . find ( from ) ) { do { changes . add ( StringChange . replace ( matcher . start ( ) , matcher . end ( ) , f1 . e ( matcher ) ) ) ; } while ( matcher . find ( ) && ( to == - 1 || matcher . start ( ) < to ) ) ; } return changes ; }
te	0	public ProjectUser ( ) { }
te	1	boolean isGapAfterPush ( ) { return gapAfter != null && gapAfter . getGapPush ( ) ; }
te	0	public int score ( String input ) { return Integer . parseInt ( input ) ; }
te	2	@ Override public void addProjectileToServer ( ) { int id ; do { id = ( int ) ( Math . random ( ) * 10000 ) ; } while ( getPlayer ( ) . getGame ( ) . getProjectileIDs ( ) . contains ( id ) ) ; Packet13SendNewProjectile packet ; if ( getPlayer ( ) . isFacingRight ( ) ) packet = new Packet13SendNewProjectile ( "arrow" , - Math . cos ( getrAngle ( ) ) * 28 + getPlayer ( ) . getxPosition ( ) , - Math . sin ( getrAngle ( ) ) * 28 + getPlayer ( ) . getyPosition ( ) - 32 , getrAngle ( ) , getPlayer ( ) . getName ( ) , id ) ; else packet = new Packet13SendNewProjectile ( "arrow" , Math . cos ( getrAngle ( ) ) * 28 + getPlayer ( ) . getxPosition ( ) - 16 , Math . sin ( getrAngle ( ) ) * 28 + getPlayer ( ) . getyPosition ( ) - 32 , getrAngle ( ) , getPlayer ( ) . getName ( ) , id ) ; packet . writeData ( getPlayer ( ) . getGame ( ) . getSocketClient ( ) ) ; }
te	6	@ SuppressWarnings ( "static-access" ) public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JLabel label = ( JLabel ) super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; label . setIcon ( null ) ; if ( table . getColumnName ( column ) . equals ( "Nom" ) || table . getColumnName ( column ) . equals ( "Ville" ) || table . getColumnName ( column ) . equals ( "Province" ) || table . getColumnName ( column ) . equals ( "Proprietaire" ) ) { label . setText ( value . toString ( ) ) ; } else if ( table . getColumnName ( column ) . equals ( "Vente R\u00E9serv\u00E9e" ) ) { label . setText ( "" ) ; if ( value . toString ( ) . equals ( "true" ) ) { label . setIcon ( ConfigIcon . getInstance ( ) . RESERVED ) ; } else { label . setIcon ( ConfigIcon . getInstance ( ) . EMPTY_16 ) ; } } label . setOpaque ( true ) ; label . setHorizontalAlignment ( CENTER ) ; return label ; }
te	1	public boolean isDecoupler ( ) { return getModule ( "ModuleDecouple" ) != null || getModule ( "ModuleAnchoredDecoupler" ) != null ; }
te	9X	int sendIncrementalRLE ( int [ ] data , int [ ] prevData , DataOutputStream out ) { try { int bytesSent = 0 ; int i = 0 ; int equalCount = 0 , dataValue = 0 , dataCount = 0 ; while ( i < data . length ) { while ( prevData != null && i < data . length && data [ i ] == prevData [ i ] ) { equalCount ++ ; i ++ ; } if ( equalCount > 0 ) { out . writeInt ( equalCount | 80000000 ) ; bytesSent += 4 ; equalCount = 0 ; } if ( i >= data . length ) break ; dataValue = data [ i ] ; dataCount = 1 ; i ++ ; while ( i < data . length && data [ i ] == dataValue && dataCount < 127 ) { dataCount ++ ; i ++ ; } out . writeInt ( ( dataValue & 00FFFFFF ) | ( dataCount << 24 ) ) ; bytesSent += 4 ; } return bytesSent ; } catch ( IOException e ) { return - 1 ; } }
te	7	@ Override public void evaluate ( ) { int [ ] [ ] confusionMatrix = getConfusionMatrix ( ) . getMatrix ( ) ; int length = confusionMatrix . length ; specificity = new double [ length ] ; accuracy = new double [ length ] ; fpr = new double [ length ] ; tpr = new double [ length ] ; ppv = new double [ length ] ; npv = new double [ length ] ; fdr = new double [ length ] ; mcc = new double [ length ] ; f1s = new double [ length ] ; for ( int clazz = 0 ; clazz < length ; clazz ++ ) { double tp = confusionMatrix [ clazz ] [ clazz ] ; double fp = 0d ; double fn = 0d ; double tn = 0d ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != clazz ) { for ( int j = 0 ; j < length ; j ++ ) { if ( j == clazz ) { fp += confusionMatrix [ i ] [ j ] ; } else { tn += confusionMatrix [ i ] [ j ] ; } } } else { for ( int j = 0 ; j < length ; j ++ ) { if ( j != clazz ) { fn += confusionMatrix [ i ] [ j ] ; } } } } specificity [ clazz ] = tn / ( fp + tn ) ; accuracy [ clazz ] = ( tp + tn ) / ( tp + fp + fn + tn ) ; tpr [ clazz ] = tp / ( tp + fn ) ; fpr [ clazz ] = fp / ( fp + tn ) ; ppv [ clazz ] = tp / ( tp + fp ) ; npv [ clazz ] = tn / ( tn + fn ) ; fdr [ clazz ] = 1 - ppv [ clazz ] ; mcc [ clazz ] = ( tp * tn - fp * fn ) / Math . sqrt ( ( tp + fp ) * ( tp + fn ) * ( tn + fp ) * ( tn + fn ) ) ; f1s [ clazz ] = 2 * tp / ( 2 * tp + fp + fn ) ; performance += tp / ( tp + fp + fn + tn ) ; } }
te	0	public Layer ( float zPosition ) { this . zPosition = zPosition ; }
te	6	public E fromXmlValue ( String xmlValue ) { if ( xmlValue == null ) { return null ; } for ( E enumValue : this . enumClass . getEnumConstants ( ) ) { XmlEnumValue xmlEnumValue = getXmlEnumValueAnnotation ( enumValue ) ; if ( xmlEnumValue == null && enumValue . name ( ) . equals ( xmlValue ) ) { return enumValue ; } else if ( xmlEnumValue != null && xmlEnumValue . value ( ) . equals ( xmlValue ) ) { return enumValue ; } } throw new IllegalArgumentException ( "No Enum value found with an XML value of " + xmlValue ) ; }
te	3	public static boolean areAnagrams ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } else { char [ ] b1 = s1 . toCharArray ( ) ; char [ ] b2 = s2 . toCharArray ( ) ; Arrays . sort ( b1 ) ; Arrays . sort ( b2 ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( b1 [ i ] != b2 [ i ] ) { return false ; } } } return true ; }
te	8	public void updateEntities ( ) { ArrayList < Entity > changed = new ArrayList < Entity > ( ) ; for ( Entity e : toRegister ) { registerEntity ( e ) ; } for ( Entity e : toCreate ) { Body body = this . createBody ( e . getBd ( ) ) ; FixtureDef fd = e . getFd ( ) ; body . createFixture ( fd ) ; e . setBody ( body ) ; body . setUserData ( e ) ; System . out . println ( body ) ; } toCreate . clear ( ) ; toRegister . clear ( ) ; for ( String s : es . keySet ( ) ) { for ( int x = 0 ; x < es . get ( s ) . size ( ) ; x ++ ) { Entity e = es . get ( s ) . get ( x ) ; e . update ( ) ; if ( ! e . getLocation ( ) . getId ( ) . equals ( s ) ) { changed . add ( e ) ; es . get ( s ) . remove ( x ) ; } } } for ( int x = 0 ; x < changed . size ( ) ; x ++ ) { Entity e = changed . get ( x ) ; String id = e . getLocation ( ) . getId ( ) ; if ( ! es . containsKey ( id ) ) es . put ( id , new ArrayList < Entity > ( ) ) ; es . get ( e . getLocation ( ) . getId ( ) ) . add ( e ) ; } for ( Entity e : removeQueue ) { removeEntity ( e ) ; } removeQueue . clear ( ) ; }
te	3	public static List < Integer > parseIntList ( String list ) { if ( list == null ) { return null ; } String [ ] parts = list . split ( " " ) ; ArrayList < Integer > intList = new ArrayList < Integer > ( ) ; for ( String part : parts ) { try { intList . add ( Integer . parseInt ( part ) ) ; } catch ( NumberFormatException e ) { } } return intList ; }
te	3	@ Override public void print ( String pages , String extension , String fileName ) { if ( extension . equals ( "doc" ) ) { System . out . println ( "Printing documento doc with " + pages ) ; } else if ( extension . equals ( "pdf" ) || extension . equals ( "mdi" ) ) { printerAdapter = new PrinterWorkAdapter ( extension ) ; printerAdapter . print ( pages , extension , fileName ) ; } else { System . out . println ( "Extension not compatible" ) ; } }
te	3	private String getReadMeContents ( ) { InputStream is = null ; is = Loader . class . getResourceAsStream ( "/info/usmans/QuranProject/resources/infos/README.md" ) ; if ( is == null ) { JOptionPane . showMessageDialog ( this , "Unable to acquire InputStream for reading README file" , "null InputStream" , JOptionPane . ERROR_MESSAGE ) ; return "" ; } java . util . Scanner s = new java . util . Scanner ( is ) ; s . useDelimiter ( "\\A" ) ; String data = s . hasNext ( ) ? s . next ( ) : "" ; try { s . close ( ) ; is . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , "Unable to close InputStream for README file" , "Error InputStream close" , JOptionPane . ERROR_MESSAGE ) ; } return data ; }
te	2	public static void printList ( final List < ? > list ) { for ( final Object i : list ) System . out . println ( i ) ; }
te	5	public void setTextFieldValues ( ) { List < User > theUsers = users . getUsers ( ) ; tasks = new AccessTasks ( ) ; tasks . getTasks ( ) ; theTask = null ; if ( tasks != null && item != null ) { theTask = tasks . getTask ( Integer . parseInt ( item . getText ( ) ) ) ; } if ( theTask != null ) { StaticWindowMethods . populateAssignedToDropDown ( cboxAssignedTo , theUsers ) ; cboxAssignedTo . select ( cboxAssignedTo . indexOf ( theTask . getAssignedTo ( ) . getUserName ( ) ) ) ; if ( StatusCode . values ( ) . length > 0 ) { StaticWindowMethods . populateStatusDropDown ( cboxStatus ) ; theTask . getStatus ( ) ; cboxStatus . select ( cboxStatus . indexOf ( StatusCode . valueOf ( theTask . getStatus ( ) . toString ( ) ) . toString ( ) ) ) ; } if ( PriorityCode . values ( ) . length > 0 ) { StaticWindowMethods . populatePriorityDropDown ( cboxPriority ) ; cboxPriority . select ( cboxPriority . indexOf ( PriorityCode . valueOf ( theTask . getPriority ( ) . toString ( ) ) . toString ( ) ) ) ; } lblCreatedByField . setText ( theTask . getCreator ( ) . getUserName ( ) ) ; lblCreatedDateField . setText ( FormatDate . formatDate ( theTask . getCreatedDate ( ) ) ) ; txtTitle . setText ( theTask . getTitle ( ) ) ; txtTimeEstimate . setText ( "" + theTask . getTimeEstimate ( ) ) ; txtTimeSpent . setText ( "" + theTask . getTimeSpent ( ) ) ; txtDescription . setText ( theTask . getDescription ( ) ) ; txtComments . setText ( theTask . getComments ( ) ) ; dueDate . setDay ( theTask . getDueDate ( ) . get ( Calendar . DAY_OF_MONTH ) ) ; dueDate . setMonth ( theTask . getDueDate ( ) . get ( Calendar . MONTH ) ) ; dueDate . setYear ( theTask . getDueDate ( ) . get ( Calendar . YEAR ) ) ; } }
te	5	public double coerce ( String s ) { try { Date date = format . parse ( s ) ; calendar . setTime ( date ) ; long timeInMillis = calendar . getTimeInMillis ( ) ; switch ( timeUnit ) { case SECONDS : return timeInMillis / 1000d ; case MINUTES : return timeInMillis / 1000d / 60d ; case HOURS : return timeInMillis / 1000d / 60d / 60d ; case DAYS : return timeInMillis / 1000d / 60d / 60d / 24d ; } throw new RuntimeException ( "Unsupported TimeUnit '" + timeUnit + "'. Use one of: SECONDS  MINUTES  HOURS  DAYS." ) ; } catch ( ParseException e ) { throw new RuntimeException ( "Couldn't coerce '" + s + "' to date using '" + pattern + "' format pattern." , e ) ; } }
te	3	public CalendarModel add ( MeetingModel meeting ) { if ( meetings . contains ( meeting ) ) return this ; meetings . add ( meeting ) ; if ( ! meetingsFrom . containsKey ( meeting . getTimeFrom ( ) ) ) meetingsFrom . put ( meeting . getTimeFrom ( ) , new HashSet < MeetingModel > ( ) ) ; if ( ! meetingsTo . containsKey ( meeting . getTimeTo ( ) ) ) meetingsTo . put ( meeting . getTimeTo ( ) , new HashSet < MeetingModel > ( ) ) ; meetingsFrom . get ( meeting . getTimeFrom ( ) ) . add ( meeting ) ; meetingsTo . get ( meeting . getTimeTo ( ) ) . add ( meeting ) ; meeting . addPropertyChangeListener ( this ) ; pcs . firePropertyChange ( MEETING_ADDED , null , meeting ) ; return this ; }
te	8	public Integer Alfa ( Integer x , Integer y ) { int z = 0 ; if ( x == 0 && y == 0 ) { z = 1 ; } else if ( x == 0 && y == 1 ) { z = 0 ; } else if ( x == 1 && y == 0 ) { z = 2 ; } else if ( x == 1 && y == 1 ) { z = 1 ; } return z ; }
te	3	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; g . drawImage ( backgroundImage , 0 , 0 , null ) ; g . drawImage ( st . getFlag ( ) . getTexture ( ) , ( int ) GameObject . boxToSwingX ( ( st . getFlag ( ) . getPos ( ) ) . x ) , ( int ) GameObject . boxToSwingY ( ( st . getFlag ( ) . getPos ( ) ) . y ) , null ) ; if ( st . haveLauncher ( ) != null ) g . drawImage ( st . haveLauncher ( ) . getTexture ( ) , ( int ) GameObject . boxToSwingX ( ( st . haveLauncher ( ) . getPos ( ) ) . x ) , ( int ) GameObject . boxToSwingY ( ( st . haveLauncher ( ) . getPos ( ) ) . y ) , null ) ; Graphics2D g2 = ( ( Graphics2D ) g ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; for ( GameObject obj : st . getWorldController ( ) . getObjects ( ) ) { g2 . setPaint ( obj . getColour ( ) ) ; g2 . fill ( obj . gShape ( ) ) ; } if ( shp != null ) { g2 . setPaint ( Color . RED ) ; g2 . fill ( shp ) ; } }
te	3	private boolean promptShiftRight ( ) { String spriteTypeName = null ; String selectedState = null ; PoseurGUI gui = Poseur . getPoseur ( ) . getGUI ( ) ; AnimatedSpriteViewer view = gui . getAnimametedViewerPanel ( ) ; try { spriteTypeName = view . getJlist ( ) . getSelectedValue ( ) . toString ( ) ; selectedState = view . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; if ( view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "NULL" ) || view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { throw new NullPointerException ( ) ; } } catch ( NullPointerException e ) { JOptionPane . showMessageDialog ( view , "You did not select either state or sprite type" ) ; return false ; } currentSpriteName = spriteTypeName ; currentFileName = spriteTypeName + SPRITE_FILE_EXTENSION ; currentFile = new File ( SPRITES_PATH + currentFileName ) ; String path = "./data/sprite_types/" + spriteTypeName ; File currentFile3 = new File ( path + "/" + currentFileName ) ; spriteIO . poseShiftRight ( gui . getID ( ) ) ; saved = true ; String appName = gui . getAppName ( ) ; gui . setTitle ( appName + APP_NAME_FILE_NAME_SEPARATOR + currentFile ) ; Poseur singleton = Poseur . getPoseur ( ) ; return false ; }
te	6	private void printComment ( Out fout , int indent , Node node ) { if ( indent + linelen < this . configuration . wraplen ) wraphere = linelen ; addC ( < , linelen ++ ) ; addC ( ! , linelen ++ ) ; addC ( - , linelen ++ ) ; addC ( - , linelen ++ ) ; if ( false ) { if ( linelen < this . configuration . wraplen ) wraphere = linelen ; } printText ( fout , COMMENT , indent , node . textarray , node . start , node . end ) ; if ( false ) { if ( indent + linelen < this . configuration . wraplen ) wraphere = linelen ; } addC ( - , linelen ++ ) ; addC ( - , linelen ++ ) ; addC ( > , linelen ++ ) ; if ( node . linebreak ) flushLine ( fout , indent ) ; }
te	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
te	5	public static String newMetaClass ( class < ? > clazz , String metaPackageName ) { String className = classNameHelper ( clazz ) ; StringBuilder b = new StringBuilder ( ) ; b . append ( "// generated in " ) . append ( ClassMetaUtil . class . getCanonicalName ( ) ) . append ( "\n" ) ; b . append ( "package " ) . append ( packageNameHelper ( clazz , metaPackageName ) ) . append ( ";\n" ) ; b . append ( "public class " ) . append ( className ) ; class < ? > superClazz = clazz . getSuperclass ( ) ; if ( ! superClazz . equals ( Object . class ) ) { b . append ( " extends " ) . append ( packageNameHelper ( superClazz , metaPackageName ) ) . append ( "." ) . append ( superClazz . getSimpleName ( ) ) . append ( "_" ) ; } b . append ( " {\n" ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( Modifier . isStatic ( f . getModifiers ( ) ) ) continue ; b . append ( "public static String " ) . append ( f . getName ( ) ) . append ( " = " ) . append ( "\"" ) . append ( fieldNameHelper ( f ) ) . append ( "\";\n" ) ; } b . append ( "}" ) ; return b . toString ( ) ; }
te	4	public void act ( int delta ) { for ( Method action : actions ) { try { action . invoke ( this , delta ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } }
te	6	public PodBuyerBehaviour ( Agent a ) { super ( a ) ; msg . setOntology ( "buyer_seller" ) ; ParallelBehaviour enquiry = new ParallelBehaviour ( ParallelBehaviour . WHEN_ALL ) ; for ( int i = 0 ; i < stationList . size ( ) ; i ++ ) { if ( ! myAgent . getAID ( ) . equals ( stationList . get ( i ) ) ) { msg . addReceiver ( stationList . get ( i ) ) ; enquiry . addSubBehaviour ( new MyReceiver ( myAgent , - 1 , template ) { @ Override public void handle ( ACLMessage msg ) { if ( msg != null ) { double offer = double . parseDouble ( msg . getUserDefinedParameter ( "price" ) ) ; if ( offer < bestPrice ) { bestPrice = offer ; bestOffer = msg ; } offers . add ( msg ) ; } } } ) ; } } addSubBehaviour ( enquiry ) ; addSubBehaviour ( new OneShotBehaviour ( myAgent ) { @ Override public void action ( ) { for ( ACLMessage offer : offers ) { ACLMessage reply = offer . createReply ( ) ; if ( offer == bestOffer ) { reply . setPerformative ( ACLMessage . REQUEST ) ; reply . setContent ( "" ) ; } else { reply . setPerformative ( ACLMessage . REFUSE ) ; } myAgent . send ( reply ) ; } } } ) ; myAgent . send ( msg ) ; }
te	7	public String getPlayerClass ( Player p ) { if ( perm == null ) { RegisteredServiceProvider < Permission > permissionProvider = getServer ( ) . getServicesManager ( ) . getRegistration ( net . milkbowl . vault . permission . Permission . class ) ; if ( permissionProvider == null ) { System . out . println ( "Vault plugin was not detected. Please install it or else we can not properly format chat." ) ; } else { perm = permissionProvider . getProvider ( ) ; } } if ( perm != null ) { String [ ] groups ; try { groups = perm . getPlayerGroups ( p ) ; } catch ( UnsupportedOperationException e ) { getLogger ( ) . info ( "Valut Exception: " + e . getMessage ( ) ) ; groups = new String [ 0 ] ; } List < String > classes = getConfig ( ) . getStringList ( "classes" ) ; if ( groups . length > 1 ) for ( String grp : groups ) { if ( classes . contains ( grp . toLowerCase ( ) ) ) { return grp ; } } } return getConfig ( ) . getString ( "global.defaultClass" , "Awakened" ) ; }
te	6	@ Override public void onPaint ( DrawingInterface g , int width , int height ) { if ( state == STATE_TEMP_ONCE || state == STATE_TEMP_ALWAYS ) { g . gSetColor ( Skin . LINE ) ; g . gDrawLine ( Dim . X ( 6 ) , Dim . Y ( 53 ) , Dim . X ( 6 ) + Dim . W ( 88 ) , Dim . Y ( 53 ) ) ; } else if ( ( state == STATE_PICK_COLORS || state == STATE_DETECT_COLORS ) && digitInput . colors != null ) { int i = 0 ; for ( Integer col : digitInput . colors ) { i += 4 ; g . gSetColor ( col ) ; g . gFillRectangle ( Dim . X ( 5 + i ) , img . getY ( ) + Dim . H ( img . h + 3 ) , Dim . W ( 3 ) , Dim . H ( 5 ) ) ; } } }
te	4	private QueryMapHelper ( ) { Properties p = new Properties ( ) ; URL url = null ; String filePath = "dq.properties" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { url = file . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return ; } } else { url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; } if ( url == null ) { throw new RuntimeException ( "can not find the file " + filePath ) ; } try { p . load ( url . openStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } loadFiles ( p ) ; }
te	6	@ Override public void keyPressed ( KeyEvent k ) { if ( k . getKeyCode ( ) == k . VK_A ) changeX = - 0.5 ; else if ( k . getKeyCode ( ) == k . VK_D ) changeX = 0.5 ; else if ( k . getKeyCode ( ) == k . VK_W ) changeY = - 0.5 ; else if ( k . getKeyCode ( ) == k . VK_S ) changeY = 0.5 ; else if ( k . getKeyCode ( ) == k . VK_Q ) allowPlayerCollide = true ; else if ( k . getKeyCode ( ) == k . VK_E ) destroyPlayer = true ; }
te	8	public static void main ( String [ ] args ) { String traceFile , ignoreFile , knownFile , tmp ; int stackLimit = 50 ; CommandLine cmd = null ; Options options = new Options ( ) ; options . addOption ( "f" , "trace_file" , true , "dalvik method profiling trace file" ) ; options . addOption ( "i" , "ignore_pattern_list" , true , "file containing patterns of classes to be ignored" ) ; options . addOption ( "k" , "known_method_list" , true , "file containing methods whose details are to be hidden" ) ; options . addOption ( "s" , "stack_limit" , true , "maximum number of stacks to be printed" ) ; CommandLineParser parser = new PosixParser ( ) ; try { cmd = parser . parse ( options , args ) ; } catch ( ParseException e ) { System . out . println ( e . getMessage ( ) ) ; printHelp ( options ) ; return ; } traceFile = cmd . getOptionValue ( "f" ) ; if ( traceFile == null ) { System . out . println ( "please specify trace file" ) ; printHelp ( options ) ; return ; } ignoreFile = cmd . getOptionValue ( "i" ) ; knownFile = cmd . getOptionValue ( "k" ) ; tmp = cmd . getOptionValue ( "s" ) ; if ( tmp != null ) { stackLimit = Integer . parseInt ( tmp ) ; } tracedump d = new tracedump ( ) ; if ( ignoreFile != null ) { if ( ! d . parseIgnore ( ignoreFile ) ) { System . out . println ( "failed to parse " + ignoreFile ) ; return ; } } if ( knownFile != null ) { if ( ! d . parseKnown ( ( knownFile ) ) ) { System . out . println ( "failed to parse " + knownFile ) ; return ; } } if ( ! d . parseTrace ( traceFile ) ) { System . out . println ( "failed to parse " + traceFile ) ; return ; } d . dump ( stackLimit ) ; }
te	6	public String nextTo ( char d ) { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
te	2	public boolean weakensSEHits ( ) { switch ( this ) { case FILTER : case SOLID_ROCK : return true ; default : return false ; } }
te	7	private final void step6 ( ) { j = k ; if ( b [ k ] == e ) { int a = m ( ) ; if ( a > 1 || a == 1 && ! cvc ( k - 1 ) ) k -- ; } if ( b [ k ] == l && doublec ( k ) && m ( ) > 1 ) k -- ; }
te	0	public void setCreatedDate ( Date createdDate ) { this . createdDate = createdDate ; }
te	7	void removeDev ( DeviceImpl dev ) { synchronized ( devices ) { DeviceImpl d = devices [ dev . getAddress ( ) - 1 ] ; int i ; if ( d == null || d != dev ) return ; i = d . getAddress ( ) - 1 ; devices [ i ] = null ; if ( root == i ) { root = - 1 ; if ( Linux . trace ) System . err . println ( "bus root hub removed!" ) ; if ( Linux . debug ) { for ( i = 0 ; i < 127 ; i ++ ) { if ( devices [ i ] != null ) System . err . println ( "? addr " + ( i + 1 ) + " present with no root ?" ) ; } } } } }
te	8	private static void parseCommandLine ( String [ ] args ) throws IOException , NumberFormatException { for ( String arg : args ) { String [ ] vals = arg . split ( "=" , 2 ) ; String key = vals [ 0 ] . trim ( ) ; String value = vals [ 1 ] . trim ( ) ; if ( key . equals ( "--mode" ) || key . equals ( "-mode" ) ) { try { MODE = Mode . valueOf ( value . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { } } else if ( key . equals ( "--port" ) || key . equals ( "-port" ) ) { PORT = Integer . parseInt ( value ) ; } else if ( key . equals ( "--options" ) || key . equals ( "-options" ) ) { Options . initialize ( value ) ; } } }
te	4	public static < T > List < T > select ( String query , ReadGetter < T > rg , ReadFilter < T > rf ) { List < T > container = new LinkedList < T > ( ) ; try { ResultSet result = Database . getConnection ( ) . prepareStatement ( query ) . executeQuery ( ) ; rg . takeResultSet ( result ) ; T ref ; while ( result . next ( ) ) { ref = rg . read ( ) ; if ( rf == null || rf . accept ( ref ) ) container . add ( ref ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } Database . closeConnection ( ) ; return container ; }
te	3	public static List < String > topDown ( List < Character > s ) { if ( s . size ( ) == 2 ) { String s1 = new String ( new char [ ] { s . get ( 0 ) , s . get ( 1 ) } ) ; String s2 = new String ( new char [ ] { s . get ( 1 ) , s . get ( 0 ) } ) ; ArrayList < String > al = new ArrayList < > ( ) ; al . add ( s1 ) ; al . add ( s2 ) ; return al ; } List < String > ret = new ArrayList < > ( ) ; for ( Character c : s ) { List < Character > dup = new ArrayList < > ( s ) ; dup . remove ( c ) ; List < String > l = topDown ( dup ) ; for ( String str : l ) { ret . add ( str + c ) ; } } return ret ; }
te	2	private int getTrapNumber ( GameState preCapture , GameState postCapture , int arimaaPieceType , boolean firstPiece ) { long preBB = preCapture . piece_bb [ arimaaPieceType ] ; int indexOfCap = Util . FirstOne ( preBB ) ; preBB ^= ( 1 << indexOfCap ) ; if ( firstPiece ) assert ( preBB == 0 ) ; if ( ! firstPiece ) { int indexOfCap2 = Util . FirstOne ( preBB ) ; return nearestTrap ( indexOfCap2 ) ; } return nearestTrap ( indexOfCap ) ; }
te	4	@ Override public int hashCode ( ) { int result = con != null ? con . hashCode ( ) : 0 ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; result = 31 * result + ( var != null ? var . hashCode ( ) : 0 ) ; result = 31 * result + ( proc != null ? proc . hashCode ( ) : 0 ) ; return result ; }
te	8	private void validateRange ( JsonNode node , List < ErrorMessage > results ) { if ( this . minimum != null ) { String nodeValueAsString = type . getValue ( node ) . toString ( ) ; BigDecimal value = new BigDecimal ( nodeValueAsString ) ; BigDecimal minimum = new BigDecimal ( this . minimum . toString ( ) ) ; if ( exclusiveMinimum && ( value . compareTo ( minimum ) < 1 ) ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be greater than " + minimum + " when exclusiveMinimum is true" ) ) ; } else if ( value . compareTo ( minimum ) < 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be greater or equal to " + minimum ) ) ; } } if ( this . maximum != null ) { String nodeValueAsString = type . getValue ( node ) . toString ( ) ; BigDecimal value = new BigDecimal ( nodeValueAsString ) ; BigDecimal maximum = new BigDecimal ( this . maximum . toString ( ) ) ; if ( exclusiveMaximum && value . compareTo ( maximum ) >= 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be less than " + maximum + " when exclusiveMaximum is true" ) ) ; } else if ( value . compareTo ( maximum ) > 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be less than or equal to " + maximum ) ) ; } } }
te	7	public void update ( ) { tryattack ( ) ; xa = 0 ; ya = 0 ; if ( ! attacking ) { randommovement ( ) ; } if ( anim < 40 ) anim ++ ; else { anim = 0 ; } if ( xa != 0 || ya != 0 ) { walking = true ; move ( xa , ya ) ; } else { walking = false ; } if ( hit ) { if ( anim2 < 40 ) anim2 ++ ; else { anim2 = 0 ; hit = false ; OverHead = "" ; } } if ( checkattack ) { checkattack = false ; checkattack ( this ) ; } }
te	9X	public Board checkPawnPromotion ( ) { for ( Piece p : this . gm . getBoard ( ) . getPieces ( ) ) { if ( p instanceof Pawn && p . isWhite ( ) == isWhite ) { Pawn pawn = ( Pawn ) p ; if ( pawn . canPromote ( ) && ! pawn . isPromoted ( ) ) { pawn . setHasPromoted ( true ) ; JPanel panel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; JLabel label = new JLabel ( "What would you like to promote your pawn to?" ) ; JComboBox < String > selection = new JComboBox < String > ( new String [ ] { "Queen" , "Knight" , "Bishop" , "Rook" } ) ; String [ ] options = new String [ ] { "OK" } ; panel . add ( label ) ; panel . add ( selection ) ; int hasClosed = JOptionPane . CLOSED_OPTION ; while ( hasClosed == JOptionPane . CLOSED_OPTION ) { hasClosed = JOptionPane . showOptionDialog ( null , panel , "Pawn Promotion" , JOptionPane . DEFAULT_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; } Board bClone = gm . getBoard ( ) . clone ( ) ; Piece newPiece = null ; switch ( selection . getSelectedIndex ( ) ) { case 0 : newPiece = new Queen ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 100 } ) ; break ; case 1 : newPiece = new Knight ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 200 } ) ; break ; case 2 : newPiece = new Bishop ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 300 } ) ; break ; case 3 : newPiece = new Rook ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 400 } ) ; break ; default : newPiece = p ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) } ) ; break ; } bClone . removePiece ( p ) ; bClone . addPiece ( newPiece ) ; bClone . setPrevTiles ( gm . getBoard ( ) . getPrevTiles ( ) ) ; return bClone ; } } } return null ; }
te	3	private void checkHorizontalScrollBar ( BasicComboPopup popup ) { JViewport viewport = scrollPane . getViewport ( ) ; Point p = viewport . getViewPosition ( ) ; p . x = 0 ; viewport . setViewPosition ( p ) ; if ( ! scrollBarRequired ) { scrollPane . setHorizontalScrollBar ( null ) ; return ; } JScrollBar horizontal = scrollPane . getHorizontalScrollBar ( ) ; if ( horizontal == null ) { horizontal = new JScrollBar ( JScrollBar . HORIZONTAL ) ; scrollPane . setHorizontalScrollBar ( horizontal ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; } if ( horizontalScrollBarWillBeVisible ( popup , scrollPane ) ) { Dimension scrollPaneSize = scrollPane . getPreferredSize ( ) ; scrollPaneSize . height += horizontal . getPreferredSize ( ) . height ; scrollPane . setPreferredSize ( scrollPaneSize ) ; scrollPane . setMaximumSize ( scrollPaneSize ) ; scrollPane . revalidate ( ) ; } }
te	3	public static boolean submitProjectsToDB ( String s_id , ArrayList < Integer > projects , ArrayList < float > scores ) { try { Connection conn = global . getConnection ( ) ; PreparedStatement pStmt = conn . prepareStatement ( "update takes_project set score = ? where student_id = ? and project_id = ?" ) ; pStmt . setString ( 2 , s_id ) ; for ( int i = 0 ; i < projects . size ( ) ; i ++ ) { pStmt . setInt ( 3 , projects . get ( i ) ) ; pStmt . setFloat ( 1 , scores . get ( i ) ) ; pStmt . executeUpdate ( ) ; } pStmt . close ( ) ; conn . close ( ) ; return true ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( "CNFE: " + cnfe ) ; return false ; } catch ( SQLException sqle ) { System . err . println ( "SQLE: " + sqle ) ; return false ; } }
te	4	private String readURL ( String url ) { URL myuri ; try { myuri = new URL ( url ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return null ; } BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( myuri . openStream ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } String inputLine ; String acc = "" ; try { while ( ( inputLine = in . readLine ( ) ) != null ) acc += inputLine + "\n" ; in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } return acc ; }
te	2	public List < ComboRating > getTopList ( ) throws SQLException { Statement st = null ; List < ComboRating > topList = new ArrayList < ComboRating > ( ) ; try { st = conn . createStatement ( ) ; ResultSet rs = st . executeQuery ( "SELECT ((total_rating * 1.0)/times_rated) AS rating  flavor_1  flavor_2  times_rated  total_rating FROM flavor_combo_ratings ORDER BY rating DESC LIMIT 10" ) ; while ( rs . next ( ) ) { topList . add ( new ComboRating ( rs . getInt ( "flavor_1" ) , rs . getInt ( "flavor_2" ) , rs . getInt ( "total_rating" ) , rs . getInt ( "times_rated" ) ) ) ; } } finally { if ( st != null ) st . close ( ) ; } return topList ; }
te	2	private static List < Identifier > trad65 ( TreeNode tree ) { int r = tree . getRule ( ) ; switch ( r ) { case 0 : { List < Identifier > ids = new LinkedList < Identifier > ( ) ; Identifier x0 = trad48 ( tree . getChild ( 0 ) ) ; ids . add ( x0 ) ; List < Identifier > x1 = trad66 ( tree . getChild ( 1 ) ) ; if ( x1 != null ) ids . addAll ( x1 ) ; return ids ; } default : return null ; } }
te	4	private void addTrackToDatabase ( Path path , String trackNumber , String artist , String title , String album , long milliseconds , String genre ) { AlbumBean trackAlbum = null ; TrackBean trackBean = null ; ArtistBean trackArtist = null ; for ( ArtistBean artistBean : artists ) { if ( artistBean . getName ( ) . equals ( artist ) ) { trackAlbum = artistBean . getAlbum ( album ) ; if ( trackAlbum == null ) { trackAlbum = new AlbumBean ( album ) ; } trackArtist = artistBean ; break ; } } if ( trackArtist == null ) { trackArtist = new ArtistBean ( artist ) ; artists . add ( trackArtist ) ; AllArtistsBean all = ( AllArtistsBean ) artists . get ( 0 ) ; all . setNumberOfArtists ( artists . size ( ) - 1 ) ; trackAlbum = new AlbumBean ( album ) ; } trackBean = new TrackBean ( path . toUri ( ) , trackNumber , artist , title , trackAlbum , new Duration ( milliseconds ) , genre ) ; trackArtist . addTrackToAlbum ( trackBean , trackAlbum ) ; }
te	2	public static void main ( final String args [ ] ) { if ( args . length != 0 ) { String name = args [ 0 ] ; try { QueryDefinition query = Settings . getInstance ( ) . getQuery ( name ) ; Response response = query . execute ( ) ; System . out . print ( response . getRawValue ( ) ) ; } catch ( Exception e ) { System . err . print ( e . getMessage ( ) ) ; } } else { invokeLater ( new Runnable ( ) { public void run ( ) { new MainForm ( args ) . setVisible ( true ) ; } } ) ; } }
te	4	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( elseifs == null ) ? 0 : elseifs . hashCode ( ) ) ; result = prime * result + ( ( exp1 == null ) ? 0 : exp1 . hashCode ( ) ) ; result = prime * result + ( ( stateSeq1 == null ) ? 0 : stateSeq1 . hashCode ( ) ) ; result = prime * result + ( ( stateSeq2 == null ) ? 0 : stateSeq2 . hashCode ( ) ) ; return result ; }
te	8	private boolean r_verb ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_4 , 46 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
te	6	public static void visitDirectoriesRecursively ( FileVisitor visitor , File directory , String pattern , boolean recursively ) { if ( ! directory . isDirectory ( ) ) directory = directory . getParentFile ( ) ; if ( ! directory . getName ( ) . matches ( pattern ) ) return ; visitor . visitDirectory ( directory ) ; final ArrayList < File > childDirectories = new ArrayList < File > ( ) ; for ( File file : directory . listFiles ( ) ) { if ( file . isDirectory ( ) ) { childDirectories . add ( file ) ; } } if ( recursively ) { for ( File childDirectory : childDirectories ) { visitDirectoriesRecursively ( visitor , childDirectory , pattern , recursively ) ; } } }
te	6	public double [ ] makeMeantoneRatios ( double x ) { double [ ] data = new double [ 12 ] ; double ratio = 1.0 ; int n = 0 ; for ( int i = 0 ; i <= 6 ; i ++ ) { data [ n ] = ratio ; n += 7 ; if ( n >= 12 ) n -= 12 ; ratio = ratio * x ; if ( ratio > 2.0 ) ratio /= 2.0 ; } ratio = 1.0 ; n = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { data [ n ] = ratio ; n -= 7 ; if ( n < 0 ) n += 12 ; ratio = ratio / x ; if ( ratio < 1.0 ) ratio *= 2.0 ; } return ( data ) ; }
te	9X	public void fillVarVector ( NodeList nl , Vector v ) { for ( int i = 0 ; i < nl . getLength ( ) ; ++ i ) { Element e = ( Element ) nl . item ( i ) ; String nm = e . getNodeName ( ) ; if ( nm . equals ( "Textbox" ) || nm . equals ( "ListBox" ) || nm . equals ( "Href" ) || nm . equals ( "Hidden" ) || nm . equals ( "RadioButton" ) || nm . equals ( "PasswordField" ) || nm . equals ( "FileUpload" ) || nm . equals ( "TextArea" ) || nm . equals ( "CheckBox" ) || nm . equals ( "ComboBox" ) ) { v . add ( "{" + e . getAttribute ( "Name" ) + "}" ) ; } if ( ! e . getTagName ( ) . equals ( "Connection" ) ) fillVarVector ( e . getChildNodes ( ) , v ) ; } }
te	5	private void initMenuBar ( ) { JMenuBar menuBar = new JMenuBar ( ) ; JMenu mnFile = new JMenu ( "File" ) ; { JMenuItem mntmRestart = new JMenuItem ( "Restart" ) ; mntmRestart . setEnabled ( ! clientMode ) ; mntmRestart . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . fine ( "Restarting game" ) ; initialize ( ) ; reset ( ) ; } } ) ; mnFile . add ( mntmRestart ) ; JMenuItem mntmExit = new JMenuItem ( "Exit" ) ; mntmExit . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } ) ; mnFile . add ( mntmExit ) ; } menuBar . add ( mnFile ) ; JMenu mnConfig = new JMenu ( "Config" ) ; { mnConfig . setEnabled ( ! clientMode ) ; ButtonGroup algorithmGroup = new ButtonGroup ( ) ; int idx = 0 ; for ( SortAlgorithm < ? > sort : config . getAllAlgorithms ( ) ) { final int index = idx ++ ; final JMenuItem item = new JRadioButtonMenuItem ( sort . toString ( ) ) ; item . setSelected ( config . getAlgorithm ( ) . equals ( sort ) ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Set algorithm to " + config . getAllAlgorithms ( ) . get ( index ) ) ; config = Configuration . deriveWithNewSortIdx ( config , index ) ; initCards ( ) ; reset ( ) ; } } ) ; mnConfig . add ( item ) ; algorithmGroup . add ( item ) ; } mnConfig . add ( new JSeparator ( ) ) ; JMenu mnSize = new JMenu ( "Number of cards" ) ; { ButtonGroup sizeGroup = new ButtonGroup ( ) ; for ( int i = MIN_SIZE ; i <= MAX_SIZE ; i ++ ) { final int newSize = i ; JMenuItem item = new JRadioButtonMenuItem ( Integer . toString ( newSize ) ) ; item . setSelected ( i == size ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed size to " + newSize ) ; config = Configuration . deriveWithNewSize ( config , newSize ) ; initCards ( ) ; initialize ( ) ; } } ) ; sizeGroup . add ( item ) ; mnSize . add ( item ) ; } } mnConfig . add ( mnSize ) ; JMenu mnType = new JMenu ( "Value type" ) ; { final ButtonGroup typeGroup = new ButtonGroup ( ) ; final ValueType [ ] types = ValueType . values ( ) ; for ( int i = 0 ; i < types . length ; i ++ ) { final ValueType type = types [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( type . toString ( ) ) ; item . setSelected ( type == config . type ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed type to " + type ) ; config = Configuration . deriveWithNewType ( config , type ) ; initCards ( ) ; initialize ( ) ; } } ) ; typeGroup . add ( item ) ; mnType . add ( item ) ; } } mnConfig . add ( mnType ) ; JMenu mnMode = new JMenu ( "Values" ) ; { final ButtonGroup kindGroup = new ButtonGroup ( ) ; final ValueMode [ ] modes = ValueMode . values ( ) ; for ( int i = 0 ; i < modes . length ; i ++ ) { final ValueMode mode = modes [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( mode . toString ( ) ) ; item . setSelected ( mode == config . mode ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed mode to " + mode ) ; config = Configuration . deriveWithNewMode ( config , mode ) ; initCards ( ) ; initialize ( ) ; } } ) ; kindGroup . add ( item ) ; mnMode . add ( item ) ; } } mnConfig . add ( mnMode ) ; } menuBar . add ( mnConfig ) ; frame . setJMenuBar ( menuBar ) ; }
te	5	private AttributeStatistics generateStringStat ( double coverage , String ... values ) { Multiset < String > counts = HashMultiset . create ( ) ; int totalCount = values . length ; Collections . addAll ( counts , values ) ; int max = - 1 , min = totalCount + 1 ; List < String > maxCont = new ArrayList < > ( ) , minCont = new ArrayList < > ( ) ; for ( Multiset . Entry < String > ent : counts . entrySet ( ) ) { if ( ent . getCount ( ) > max ) { max = ent . getCount ( ) ; maxCont . clear ( ) ; maxCont . add ( ent . getElement ( ) ) ; } else if ( max == ent . getCount ( ) ) { maxCont . add ( ent . getElement ( ) ) ; } if ( ent . getCount ( ) < min ) { min = ent . getCount ( ) ; minCont . clear ( ) ; minCont . add ( ent . getElement ( ) ) ; } else if ( min == ent . getCount ( ) ) { minCont . add ( ent . getElement ( ) ) ; } } final double confidence = max * 1d / totalCount ; return new AttributeStatistics ( maxCont . toArray ( new String [ maxCont . size ( ) ] ) , confidence , coverage , counts . elementSet ( ) . size ( ) , minCont . toArray ( new String [ minCont . size ( ) ] ) ) ; }
te	0	@ Override public Line getFirstLine ( ) { return this . getTitle ( ) . getLine ( ) ; }
te	8	public boolean Login ( ) throws ClassNotFoundException , SQLException { HttpSession ses ; ses = request . getSession ( false ) ; if ( ses == null || ses . getAttribute ( "username" ) == null ) { System . out . println ( "New Session Created" ) ; String username = request . getParameter ( "username" ) ; String password = request . getParameter ( "password" ) ; if ( username != null && password != null && ! username . equals ( "" ) && ! password . equals ( "" ) ) { PreparedStatement pstmt ; Connection conn = global . getConnection ( ) ; pstmt = ( PreparedStatement ) conn . prepareStatement ( "select * from student where student_id=? and password=MD5(?)" ) ; pstmt . setString ( 1 , username ) ; pstmt . setString ( 2 , password ) ; ResultSet rset = pstmt . executeQuery ( ) ; int count = 0 ; String uname = "" ; while ( rset . next ( ) ) { uname = rset . getString ( "student_id" ) ; count ++ ; } conn . close ( ) ; if ( count != 1 ) { return false ; } else { ses = request . getSession ( true ) ; ses . setAttribute ( "username" , uname ) ; return true ; } } else { return false ; } } else { return true ; } }
te	8	@ Override public void run ( ) { open = true ; System . err . println ( "Die Kasse mit Id: " + cashpointId + " soll ge\u00F6ffnet werden!" ) ; try { Thread . sleep ( 6000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } System . err . println ( "Die Kasse mit Id: " + cashpointId + " wurde ge\u00F6ffnet!" ) ; while ( ! empty ) { synchronized ( waitingQueue ) { while ( waitingQueue . size ( ) < 1 && removedOne ) { try { waitingQueue . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( waitingQueue . size ( ) >= 1 ) { Kunde kunde = waitingQueue . get ( 0 ) ; waitingQueue . remove ( 0 ) ; abgKunden ++ ; writeToBalance ( kunde ) ; removedOne = true ; System . out . println ( "Der Kunde Nr: " + kunde . getNr ( ) + " wird von Kasse mit Id: " + cashpointId + " abgearbeitet!" ) ; System . out . println ( waitingQueue . size ( ) + " Kunde(n) stehen in der Schlange der Kasse mit Id: " + cashpointId + " !" ) ; } else { empty = true ; } } if ( removedOne ) { try { Thread . sleep ( Math . round ( 6000 + Math . random ( ) * ( 10000 - 6000 ) ) ) ; removedOne = false ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } open = false ; System . err . println ( "Die Kasse mit Id: " + cashpointId + " wurde geschlossen!" ) ; }
te	9X	public void move ( ) { if ( xdir < 0 ) setGraphic ( "engineer_l" ) ; if ( xdir > 0 ) setGraphic ( "engineer_r" ) ; if ( x < 0 && xdir < 0 ) xdir = - xdir ; if ( y < 0 && ydir < 0 ) ydir = - ydir ; if ( x > game . pfWidth ( ) - 16 && xdir > 0 ) xdir = - xdir ; if ( y > game . pfHeight ( ) - 16 && ydir > 0 ) ydir = - ydir ; if ( buildingBunker == 0 ) { if ( game . countObjects ( "engineer" , 0 ) < 15 ) { if ( game . random ( 0 , 100 , 1 ) == 1 ) new Engineer ( x - 8 , y - 8 , - xspeed , yspeed - 0.05 , game ) ; } } else buildingBunker -- ; }
te	8	private static void runTourn ( String args [ ] , GameEngine engine , long seed , int n ) { Statement s ; java . net . InetAddress localMachine = null ; try { localMachine = java . net . InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } String hostname = localMachine . getHostName ( ) ; int tournament_id = - 1 ; try { s = conn . createStatement ( ) ; s . execute ( "INSERT INTO tournament (start source player board num_lights seed run_num)" + " VALUES (NOW() \"" + hostname + "\" \"" + args [ 0 ] + "\" \"" + args [ 2 ] + "\" \"" + args [ 1 ] + "\" \"" + seed + "\" \"" + n + "\")" , Statement . RETURN_GENERATED_KEYS ) ; ResultSet rszz = s . getGeneratedKeys ( ) ; rszz . next ( ) ; tournament_id = rszz . getInt ( 1 ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } Tournament t = new Tournament ( engine ) ; engine . getConfig ( ) . setSelectedBoard ( new File ( "boards/" + args [ 2 ] + ".xml" ) ) ; try { engine . getConfig ( ) . setPlayerClass ( ( class < Player > ) class . forName ( args [ 0 ] ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } engine . getConfig ( ) . setNumMosquitos ( 1000 ) ; engine . getConfig ( ) . setNumLights ( Integer . valueOf ( args [ 1 ] ) ) ; engine . getConfig ( ) . setMaxRounds ( 15000 ) ; try { t . play ( ) ; } catch ( Exception e ) { System . err . println ( "Exception in Tournament " + tournament_id + "  player " + args [ 0 ] ) ; e . printStackTrace ( ) ; } if ( t . timedOut ) { System . err . println ( "Timeout in Tournament " + tournament_id + "  player " + args [ 0 ] ) ; } if ( n == 0 ) { BoardPanel pan = new BoardPanel ( engine , false ) ; BufferedImage im = new BufferedImage ( 600 , 600 , BufferedImage . TYPE_INT_RGB ) ; pan . paint ( im . getGraphics ( ) ) ; Iterator writers = ImageIO . getImageWritersByFormatName ( "png" ) ; ImageWriter writer = ( ImageWriter ) writers . next ( ) ; File f = new File ( "output/" + args [ 0 ] + "_" + args [ 2 ] + "_" + args [ 1 ] + ".png" ) ; ImageOutputStream ios ; try { ios = ImageIO . createImageOutputStream ( f ) ; writer . setOutput ( ios ) ; writer . write ( im ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { s = conn . createStatement ( ) ; s . execute ( "UPDATE tournament SET end=NOW()  num_caught=" + t . finalN + " time=" + t . finalTime + " where id=" + tournament_id ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
te	5	public void setUser ( User newUser ) { if ( newUser == null || ( user != null && newUser . getID ( ) . equals ( user . getID ( ) ) ) ) return ; if ( ( newUser . lastLog == null ) || ( System . currentTimeMillis ( ) - newUser . lastLog . getTime ( ) ) > 600000 ) { newUser . logins ++ ; } mainFrame . setTitle ( "User: " + newUser . name + " - Logins: " + newUser . logins + " - LastLogin: " + TimeCalc . calcPrettyTime ( newUser . lastLog ) ) ; newUser . lastLog = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; newUser . saveToDB ( ) ; this . user = newUser ; updateCorePhrases ( ) ; mainFrame . updateUserBtnText ( ) ; mainFrame . nextPhrase ( ) ; }
te	3	public boolean isFuture ( AppointmentSpecification appointmentSpecification ) { AppointmentDate appDate = appointmentSpecification . getDate ( ) ; boolean isDateInFuture = isDateInFuture ( appDate ) ; boolean isToday = isDateToday ( appDate ) ; boolean isTimeSlotOver = isTimeSlotOverTime ( appointmentSpecification ) ; boolean areWeInsideTimeSlot = isInsideTimeSlotTime ( appointmentSpecification ) ; return isDateInFuture || ( isToday && ! isTimeSlotOver && ! areWeInsideTimeSlot ) ; }
te	9X	private static boolean isUnreserved ( byte b ) { return ( b >= a && b <= z ) || ( b >= A && b <= Z ) || ( b >= 0 && b <= 9 ) || b == . || b == - || b == _ || b == ~ ; }
te	5	static synchronized HashMap < Object , int [ ] > getGridPositions ( Object parComp ) { if ( PARENT_GRIDPOS_MAP == null ) return null ; LinkedHashMap < Integer , Cell > grid = PARENT_GRIDPOS_MAP . get ( parComp ) ; if ( grid == null ) return null ; HashMap < Object , int [ ] > retMap = new HashMap < Object , int [ ] > ( ) ; for ( Map . Entry < Integer , Cell > e : grid . entrySet ( ) ) { Cell cell = e . getValue ( ) ; Integer xyInt = e . getKey ( ) ; if ( xyInt != null ) { int x = xyInt & 0000ffff ; int y = xyInt >> 16 ; for ( CompWrap cw : cell . compWraps ) retMap . put ( cw . comp . getComponent ( ) , new int [ ] { x , y , cell . spanx , cell . spany } ) ; } } return retMap ; }
te	4	public void act ( List < Actor > newGorrilas ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isActive ( ) ) { giveBirth ( newGorrilas ) ; Location location = getLocation ( ) ; Location newLocation = findFood ( location ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( location ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else if ( walkOverGrass ( ) ) { } else { setDead ( ) ; } } }
te	9X	public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
te	3	private synchronized void connectTransport ( ) { if ( getState ( ) == STATE_INVALID ) return ; setState ( STATE_CONNECTING ) ; if ( protocols . contains ( WebsocketTransport . TRANSPORT_NAME ) ) transport = WebsocketTransport . create ( url , this ) ; else if ( protocols . contains ( XhrTransport . TRANSPORT_NAME ) ) transport = XhrTransport . create ( url , this ) ; else { error ( new SocketIOException ( "Server supports no available transports. You should reconfigure the server to support a available transport" ) ) ; return ; } transport . connect ( ) ; }
te	7	@ Override protected boolean evaluteBids ( ) { final List < BidData > bids = getAgent ( ) . getNewBids ( ) ; if ( bids . size ( ) == 0 ) { return false ; } else if ( bids . size ( ) == 1 ) { BidData bidData = bids . get ( 0 ) ; if ( bidData . getAmount ( ) == getAuctionData ( ) . getAmount ( ) ) { PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . setAmount ( 0 ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; getAgent ( ) . setWon ( bidData ) ; return true ; } else if ( bidData . getAmount ( ) < getAuctionData ( ) . getAmount ( ) ) { PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . setAmount ( getAuctionData ( ) . getAmount ( ) - bidData . getAmount ( ) ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; getAgent ( ) . setWon ( bidData ) ; } else { LOG . info ( "Amount too big" ) ; } getAgent ( ) . setEvaluated ( bidData ) ; return false ; } else { for ( BidData bidData : bids ) { if ( bidData . getAmount ( ) == getAuctionData ( ) . getAmount ( ) ) { getAuctionData ( ) . setAmount ( 0 ) ; getAgent ( ) . setWon ( bidData ) ; return true ; } else if ( bidData . getAmount ( ) < getAuctionData ( ) . getAmount ( ) ) { getAuctionData ( ) . setAmount ( getAuctionData ( ) . getAmount ( ) - bidData . getAmount ( ) ) ; getAgent ( ) . setWon ( bidData ) ; } else { LOG . info ( "Amount too big" ) ; } getAgent ( ) . setEvaluated ( bidData ) ; } PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; return false ; } }
te	4	public static void findX ( int [ ] [ ] a , int x ) { if ( a == null ) System . out . println ( "The input matrix is null." ) ; int [ ] b = new int [ a . length * a [ 0 ] . length ] ; int k = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) for ( int j = 0 ; j < a [ 0 ] . length ; j ++ ) { b [ k ++ ] = a [ i ] [ j ] ; } int idx = binarySearch ( b , 0 , b . length - 1 , x ) ; if ( idx == - 1 ) System . out . println ( "Can't find number " + x + " int the matix." ) ; else { int m = idx / a [ 0 ] . length ; int n = idx % a [ 0 ] . length ; System . out . println ( "The position of number " + x + " is at [" + m + "][" + n + "]." ) ; } }
te	9X	public static boolean method189 ( int i , byte [ ] is , int i_250_ ) { boolean bool = true ; Stream stream = new Stream ( is ) ; int i_252_ = - 1 ; for ( ; ; ) { int i_253_ = stream . method422 ( ) ; if ( i_253_ == 0 ) break ; i_252_ += i_253_ ; int i_254_ = 0 ; boolean bool_255_ = false ; for ( ; ; ) { if ( bool_255_ ) { int i_256_ = stream . method422 ( ) ; if ( i_256_ == 0 ) break ; stream . readUnsignedByte ( ) ; } else { int i_257_ = stream . method422 ( ) ; if ( i_257_ == 0 ) break ; i_254_ += i_257_ - 1 ; int i_258_ = i_254_ & 3f ; int i_259_ = i_254_ >> 6 & 3f ; int i_260_ = stream . readUnsignedByte ( ) >> 2 ; int i_261_ = i_259_ + i ; int i_262_ = i_258_ + i_250_ ; if ( i_261_ > 0 && i_262_ > 0 && i_261_ < 103 && i_262_ < 103 ) { ObjectDef class46 = ObjectDef . forID ( i_252_ ) ; if ( i_260_ != 22 || ! lowMem || class46 . hasActions || class46 . aBoolean736 ) { bool &= class46 . method579 ( ) ; bool_255_ = true ; } } } } } return bool ; }
te	0	@ Test ( expected = TypeException . class ) public void structValue_MismatchFieldSize ( ) throws RecognitionException , IOException { addStructProgetto ( textLines ) ; textLines . add ( "p = struct progetto{999  true  struct data {false}}" ) ; testTypeChecking ( ) ; }
te	0	public void setPhoneNum ( PhoneNumber phoneNum ) { this . phoneNum = phoneNum ; }
te	4	private static void makePartitionTable ( ) { try { String content ; File partitionTable = new File ( Disk . transDisk + "/" + String . format ( "%05d" , Disk . partitionTableAddress ) + ".txt" ) ; if ( ! partitionTable . exists ( ) ) { System . out . println ( "Partition Table Not found" ) ; } content = "11111\t" + String . format ( "%05d" , 1 ) + "\t" + String . format ( "%05d" , 10 ) ; FileWriter fw = new FileWriter ( partitionTable . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( content ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { final String fsBitmapAddress = "5678\n9" ; Block superBlock = new Block ( Disk . transDisk + "/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "rw" ) ; String content = Disk . noOfBlocks + "\n" + fsBitmapAddress ; superBlock . write ( content . getBytes ( ) ) ; superBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	3	@ Override public boolean checaTipo ( AmbienteCompilacao amb ) throws VariavelNaoDeclaradaException , VariavelJaDeclaradaException { return ( expressaoEsquerda . getTipo ( amb ) . isInteger ( ) || expressaoEsquerda . getTipo ( amb ) . isParametro ( ) ) && ( expressaoDireita . getTipo ( amb ) . isInteger ( ) || expressaoDireita . getTipo ( amb ) . isParametro ( ) ) ; }
te	9X	private boolean r_residual_suffix ( ) { int among_var ; int v_1 ; int v_2 ; ket = cursor ; among_var = find_among_b ( a_9 , 8 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : if ( ! r_RV ( ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! r_RV ( ) ) { return false ; } slice_del ( ) ; v_1 = limit - cursor ; lab0 : do { ket = cursor ; if ( ! ( eq_s_b ( 1 , "u" ) ) ) { cursor = limit - v_1 ; break lab0 ; } bra = cursor ; v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "g" ) ) ) { cursor = limit - v_1 ; break lab0 ; } cursor = limit - v_2 ; if ( ! r_RV ( ) ) { cursor = limit - v_1 ; break lab0 ; } slice_del ( ) ; } while ( false ) ; break ; } return true ; }
te	6	public final int getTexel ( double u , double v , int dx , int dy , int mult ) { if ( u >= 0 && u < 1 && v >= 0 && v < 1 ) { if ( mip && useMIP ) { double size = ( ( double ) dx / mult ) * ( ( double ) dy / mult ) ; return pyramid . get ( u , v , size ) ; } return texels [ ( int ) ( v * height ) * width + ( int ) ( u * width ) ] ; } return texels [ 0 ] ; }
te	8	public void read ( org . apache . thrift . protocol . TProtocol iprot , Location struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . double ) { struct . latitude = iprot . readDouble ( ) ; struct . setLatitudeIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . double ) { struct . longitude = iprot . readDouble ( ) ; struct . setLongitudeIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; if ( ! struct . isSetLatitude ( ) ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'latitude' was not found in serialized data! Struct: " + toString ( ) ) ; } if ( ! struct . isSetLongitude ( ) ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'longitude' was not found in serialized data! Struct: " + toString ( ) ) ; } struct . validate ( ) ; }
te	9X	public static void copy ( int [ ] source , int [ ] destination , int sourceIndex , int destinationIndex , int length ) { if ( source == null || destination == null || length < 0 ) { throw new IllegalArgumentException ( ) ; } if ( length == 0 ) { return ; } int sourceLength = source . length ; int destinationLength = destination . length ; if ( sourceIndex >= sourceLength || destinationIndex >= destinationLength ) { throw new IndexOutOfBoundsException ( ) ; } if ( sourceIndex + length > sourceLength || destinationIndex + length > destinationLength ) { throw new IllegalArgumentException ( ) ; } for ( int i = 0 ; i < length ; ++ i ) { destination [ destinationIndex + i ] = source [ sourceIndex + i ] ; } }
te	6	public void method346 ( int i , int j ) { i += anInt1442 ; j += anInt1443 ; int l = i + j * DrawingArea . width ; int i1 = 0 ; int j1 = myHeight ; int k1 = myWidth ; int l1 = DrawingArea . width - k1 ; int i2 = 0 ; if ( j < DrawingArea . topY ) { int j2 = DrawingArea . topY - j ; j1 -= j2 ; j = DrawingArea . topY ; i1 += j2 * k1 ; l += j2 * DrawingArea . width ; } if ( j + j1 > DrawingArea . bottomY ) j1 -= ( j + j1 ) - DrawingArea . bottomY ; if ( i < DrawingArea . topX ) { int k2 = DrawingArea . topX - i ; k1 -= k2 ; i = DrawingArea . topX ; i1 += k2 ; l += k2 ; i2 += k2 ; l1 += k2 ; } if ( i + k1 > DrawingArea . bottomX ) { int l2 = ( i + k1 ) - DrawingArea . bottomX ; k1 -= l2 ; i2 += l2 ; l1 += l2 ; } if ( k1 <= 0 || j1 <= 0 ) { } else { method347 ( l , k1 , j1 , i2 , i1 , l1 , myPixels , DrawingArea . pixels ) ; } }
te	6	public Solution backtrackingSearchMRV ( final PartialAssignment assign , final DomainList domainlist ) { count = count + 1 ; PartialAssignment pa = ( PartialAssignment ) assign . clone ( ) ; ArrayList < Integer > unassignedVars = pa . getUnassignedVariables ( ) ; if ( unassignedVars . size ( ) == 0 ) { if ( checkAssignment ( pa ) ) { System . out . println ( "SOLUTION:" ) ; Map < String , String > result = pa . prettyPrint ( variableNames , valueNames ) ; return new Solution ( true , result ) ; } else { return new Solution ( false , null ) ; } } else { Solution solutionFound = new Solution ( false , null ) ; int variable = unassignedVars . get ( 0 ) ; int size = Integer . MAX_VALUE ; for ( Integer v : unassignedVars ) { if ( domainlist . getValues ( v ) . size ( ) < size ) { size = domainlist . getValues ( v ) . size ( ) ; variable = v ; } } for ( Integer value : domainlist . getValues ( variable ) ) { if ( ! solutionFound . value ) { pa . set ( variable , value ) ; DomainList newdomainlist = forwardCheck ( variable , value , pa , domainlist ) ; solutionFound = backtrackingSearchMRV ( pa , newdomainlist ) ; } } return solutionFound ; } }
te	7	public String getOrder ( String first , String second ) { List < Character > ordered = new ArrayList < Character > ( ) ; int i = 0 ; int j = 0 ; while ( i < first . length ( ) && j < second . length ( ) ) { char f = first . charAt ( i ) ; char s = second . charAt ( j ) ; if ( f == s ) { ordered . add ( f ) ; i ++ ; } else { if ( f == W ) { ordered . add ( f ) ; i ++ ; } else { ordered . add ( s ) ; j ++ ; } } } while ( i < first . length ( ) ) { ordered . add ( first . charAt ( i ) ) ; i ++ ; } while ( j < second . length ( ) ) { ordered . add ( second . charAt ( j ) ) ; j ++ ; } StringBuilder stringBuilder = new StringBuilder ( ordered . size ( ) ) ; for ( int k = 0 ; k < ordered . size ( ) ; k ++ ) { stringBuilder . append ( ordered . get ( k ) ) ; } return stringBuilder . toString ( ) ; }
te	7	private List < Layer > makeLayersHierarchy ( List < Layer > layers ) { LinkedList < LinkedList < Layer >> layersStack = new LinkedList < LinkedList < Layer >> ( ) ; ArrayList < Layer > rootLayers = new ArrayList < Layer > ( ) ; for ( Layer layer : layers ) { switch ( layer . getType ( ) ) { case HIDDEN : { layersStack . addFirst ( new LinkedList < Layer > ( ) ) ; break ; } case FOLDER : { assert ( layersStack . isEmpty ( ) != true ) ; if ( ! layersStack . isEmpty ( ) ) { LinkedList < Layer > folderLayers = layersStack . removeFirst ( ) ; for ( Layer l : folderLayers ) { layer . addLayer ( l ) ; } } } case NORMAL : { if ( layersStack . isEmpty ( ) ) { rootLayers . add ( layer ) ; } else { layersStack . getFirst ( ) . add ( layer ) ; } break ; } default : assert false ; } } return rootLayers ; }
te	1	public void start ( ) { String name = getAudioFileName ( ) ; try { InputStream in = getAudioStream ( ) ; AudioDevice dev = getAudioDevice ( ) ; play ( in , dev ) ; } catch ( JavaLayerException ex ) { synchronized ( System . err ) { System . err . println ( "Unable to play " + name ) ; ex . printStackTrace ( System . err ) ; } } }
te	4	@ SuppressWarnings ( "unchecked" ) public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { String serviceName = ( String ) table . getValueAt ( row , column - 1 ) ; HashMap < String , String > userStatusAssoc ; User user = instanceGUI . getUser ( ) ; if ( user . getServiceTransfer ( serviceName ) != null ) return null ; if ( user . isEmptyServiceList ( ) || user . isEmptyService ( serviceName ) ) { JLabel label = new JLabel ( StatusMessages . inactive . toUpperCase ( ) ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; return label ; } JComboBox < String > combo = ( JComboBox < String > ) super . getTableCellEditorComponent ( table , value , isSelected , row , column ) ; userStatusAssoc = instanceGUI . getUser ( ) . getServiceProviders ( serviceName ) ; Set < String > keySet = userStatusAssoc . keySet ( ) ; Iterator < String > userNameIt = keySet . iterator ( ) ; ( ( JLabel ) combo . getRenderer ( ) ) . setHorizontalAlignment ( SwingConstants . CENTER ) ; combo . removeAllItems ( ) ; while ( userNameIt . hasNext ( ) ) { String userName = userNameIt . next ( ) ; String status = userStatusAssoc . get ( userName ) ; combo . addItem ( userName + "   " + status . toUpperCase ( ) ) ; } Object element = combo . getItemAt ( 0 ) ; combo . getModel ( ) . setSelectedItem ( element ) ; return combo ; }
te	5	public HashMap < Material , Integer > countBlocks ( Location start , Location end ) { HashMap < Material , Integer > blocks = new HashMap < Material , Integer > ( ) ; final World world = start . getWorld ( ) ; if ( world != end . getWorld ( ) ) { return blocks ; } final int startX = Math . max ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int startY = Math . max ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int startZ = Math . max ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; final int endX = Math . min ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int endY = Math . min ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int endZ = Math . min ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; for ( int x = startX ; x < endX ; x ++ ) { for ( int y = startY ; x < endY ; y ++ ) { for ( int z = startZ ; x < endZ ; z ++ ) { Material currentBlock = world . getBlockAt ( x , y , z ) . getType ( ) ; int lastAmmount = blocks . containsKey ( currentBlock ) ? blocks . get ( currentBlock ) : 0 ; blocks . put ( currentBlock , lastAmmount ) ; } } } return blocks ; }
te	1	public void testFloatLargeArrayConstant ( ) { FloatLargeArray a = new FloatLargeArray ( 1 << 33 , 2.5f ) ; assertEquals ( 2.5f , a . getFloat ( 0 ) ) ; assertEquals ( 2.5f , a . getFloat ( a . length ( ) - 1 ) ) ; Throwable e = null ; try { a . setFloat ( 0 , 3.5f ) ; } catch ( IllegalAccessError ex ) { e = ex ; } assertTrue ( e instanceof IllegalAccessError ) ; assertNull ( a . getData ( ) ) ; }
te	2	private static INDIOneElementBLOBProperty loadOneElementBLOBProperty ( INDIDriver driver , String name ) { INDIProperty prop ; try { prop = INDIProperty . loadFromFile ( driver , name ) ; } catch ( INDIException e ) { return null ; } if ( ! ( prop instanceof INDIOneElementBLOBProperty ) ) { return null ; } INDIOneElementBLOBProperty tp = ( INDIOneElementBLOBProperty ) prop ; tp . setSaveable ( true ) ; return tp ; }
te	5	private String assemblaBufferCellaSingolaPerVistaLocale ( String buffer , Cella miaCella ) { Character tipoCella = miaCella . toString ( ) . toLowerCase ( ) . charAt ( 0 ) ; if ( tipoCella . equals ( t ) || tipoCella . equals ( a ) ) return aggiungiCellaSingolaSenzaInfoAddizionali ( buffer , tipoCella ) ; else if ( tipoCella . equals ( v ) || tipoCella . equals ( c ) ) return aggiungiCellaSingolaConInfoAddizionali ( buffer , tipoCella , miaCella . getValoreAttuale ( ) ) ; else if ( tipoCella . equals ( d ) ) return aggiungiCellaSingolaConInfoAddizionali ( buffer , tipoCella , miaCella . getIdDelDinosauro ( ) ) ; return null ; }
te	7	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == < ) { return XML . < ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == < || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } }
te	6	public static Replacer getInstance ( ReplacerType type , Map < AttributeKey , Object > attributes ) { if ( type == ReplacerType . PATTERN ) { return new PatternReplacerImpl ( attributes ) ; } else if ( type == ReplacerType . ALL_LOWER_CASE ) { return new AllLowerCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . ALL_UPPER_CASE ) { return new AllUpperCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . FIRST_CHAR_UPPER_CASE ) { return new FirstCharUpperCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . SEQUENCE_NUMBER ) { return new SequenceNumberReplacerImpl ( attributes ) ; } else if ( type == ReplacerType . CHARACTERS ) { return new CharactersReplacerImpl ( attributes ) ; } else { throw new FileRenamerException ( "Invalid ReplacerType" ) ; } }
te	0	public int hashCode ( ) { return Cafe123 ; }
te	0	public double [ ] getEmissionDistribution ( ) { return EMISSION_DISTRIBUTIONS ; }
te	3	public BattleshipServer ( int port , GameManager manager ) { if ( manager == null || port < 0 ) throw new IllegalArgumentException ( ) ; this . manager = manager ; try { socket = new ServerSocket ( port ) ; this . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	1	@ Override public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { Object item = value ; if ( item instanceof TipoIngreso ) { item = ( ( TipoIngreso ) item ) . getNombre ( ) ; } return super . getListCellRendererComponent ( list , item , index , isSelected , cellHasFocus ) ; }
te	9X	public void verify ( Request . ParsedRequest parsedRequest , OAuthParams . OAuth1Params oAuth1Params ) throws MalformedRequest { if ( parsedRequest . scheme ( ) == null ) throwMalformedException ( SCHEME ) ; else if ( parsedRequest . host ( ) == null ) throwMalformedException ( HOST ) ; else if ( parsedRequest . port ( ) < 0 ) throwMalformedException ( PORT ) ; else if ( parsedRequest . verb ( ) == null ) throwMalformedException ( VERB ) ; else if ( parsedRequest . path ( ) == null ) throwMalformedException ( PATH ) ; else if ( oAuth1Params . signatureMethod ( ) == null || ! oAuth1Params . signatureMethod ( ) . equals ( OAuthParams . HMAC_SHA1 ) ) { throw new MalformedRequest ( UNSUPPORTED_METHOD + oAuth1Params . signatureMethod ( ) ) ; } else if ( oAuth1Params . version ( ) != null && ! oAuth1Params . version ( ) . equals ( OAuthParams . ONE_DOT_OH ) && ! oAuth1Params . version ( ) . toLowerCase ( ) . equals ( OAuthParams . ONE_DOT_OH_A ) ) { throw new MalformedRequest ( UNSUPPORTED_VERSION + oAuth1Params . version ( ) ) ; } else if ( oAuth1Params . token ( ) != null && ( oAuth1Params . token ( ) . indexOf (   ) > 0 || oAuth1Params . token ( ) . length ( ) > MaxTokenLength ) ) { throw new MalformedRequest ( MALFORMED_TOKEN + oAuth1Params . token ( ) ) ; } }
te	6	private static int modifyCForward ( int c , int largest , int positionMsd ) { int foundLargestIndex = - 1 ; int positionLsd = 0 ; while ( positionLsd < positionMsd && c > 0 ) { if ( ( c % 10 > largest ) ) { c = swapDigit ( c , positionLsd , positionMsd ) ; return c ; } if ( foundLargestIndex == - 1 && c % 10 == largest ) { foundLargestIndex = positionLsd ; } c = c / 10 ; positionLsd ++ ; } if ( foundLargestIndex != - 1 ) { c = swapDigit ( c , positionMsd , foundLargestIndex ) ; return c ; } else { return - 1 ; } }
te	3	@ Override public boolean isReadable ( ) { try { URL url = getURL ( ) ; if ( ResourceUtils . isFileURL ( url ) ) { File file = getFile ( ) ; return ( file . canRead ( ) && ! file . isDirectory ( ) ) ; } else { return true ; } } catch ( IOException ex ) { return false ; } }
te	0	public String getId ( ) { return id ; }
te	4	private static boolean [ ] getComponentGapPush ( ArrayList < CompWrap > compWraps , boolean isHor ) { boolean [ ] barr = new boolean [ compWraps . size ( ) + 1 ] ; for ( int i = 0 ; i < barr . length ; i ++ ) { boolean push = i > 0 && compWraps . get ( i - 1 ) . isPushGap ( isHor , false ) ; if ( push == false && i < ( barr . length - 1 ) ) push = compWraps . get ( i ) . isPushGap ( isHor , true ) ; barr [ i ] = push ; } return barr ; }
te	2	public void filterMax ( final boolean [ ] nonmatches , final int index , final double comparison ) { if ( ! double . isNaN ( comparison ) ) { final double [ ] values = this . maxFields [ index ] ; for ( int i = 0 ; i < this . size ; i ++ ) { nonmatches [ i ] |= ( values [ i ] > comparison ) ; } } }
te	4	public void moveRight ( ) { if ( freezing || ! isGameOn ) { return ; } if ( ! checkMovable ( "RIGHT" ) ) { return ; } setCurrentTokens ( 0 ) ; for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] + 1 ; int y = currentTokens [ i ] [ 1 ] ; tokens [ y ] [ x ] . setType ( currentType ) ; currentTokens [ i ] [ 0 ] = x ; } setDirectingTokens ( ) ; refresh ( ) ; }
te	7	public boolean setValueAt ( int value , int row , int column ) { if ( ( column >= 0 ) && ( column < this . tableModel . getColumnCount ( ) ) && ( row >= 0 ) && ( row < this . tableModel . getRowCount ( ) ) ) { class < ? extends Object > cell = this . table . getValueAt ( row , column ) . getClass ( ) ; if ( cell . isInstance ( new Integer ( 0 ) ) ) { this . table . setValueAt ( new Integer ( value ) , row , column ) ; return true ; } String classType = cell . toString ( ) ; try { throw new JSTableDataClassException ( "Error assigning value at cell " + row + "  " + column + ". " + "Trying to assign an Integer value of " + value + " to a cell with class " + classType . substring ( 16 , classType . length ( ) ) + "." ) ; } catch ( JSTableDataClassException e ) { e . printStackTrace ( ) ; } } return false ; }
te	3	private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } }
te	5	private int processDADDInst ( DADD dadd ) { String opCode = dadd . getOpcode ( ) . name ( ) ; int instOrder = dadd . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( dadd . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( dadd . getSrc1 ( ) , dadd ) ; boolean src2 = ! dataHaz . checkRAWHazard ( dadd . getSrc2 ( ) , dadd ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( dadd . getSrc1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( dadd . getSrc2 ( ) . getId ( ) ) ; dadd . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; dadd . getSrc2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + dadd . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + dadd . getSrc2 ( ) . getId ( ) . name ( ) ) ; dadd . clearRawHazard ( ) ; dadd . setState ( State . READ ) ; } else { dadd . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( dadd . getRawInst ( ) ) ; if ( ! src1 ) { src1n = dadd . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = dadd . getSrc2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
te	5	@ Override public final boolean equals ( @ Nullable final Object obj ) { if ( obj instanceof ChessMovement ) { final ChessMovement other = ( ChessMovement ) obj ; return from . equals ( other . from ) && to . equals ( other . to ) && sourcePiece . equals ( other . sourcePiece ) && Objects . equal ( attackedPiece , other . attackedPiece ) && special . equals ( other . special ) ; } return false ; }
te	4	public JSONObject put ( String key , Object value ) throws JSONException { String pooled ; if ( key == null ) { throw new NullPointerException ( "Null key." ) ; } if ( value != null ) { testValidity ( value ) ; pooled = ( String ) keyPool . get ( key ) ; if ( pooled == null ) { if ( keyPool . size ( ) >= keyPoolSize ) { keyPool = new HashMap ( keyPoolSize ) ; } keyPool . put ( key , key ) ; } else { key = pooled ; } this . map . put ( key , value ) ; } else { this . remove ( key ) ; } return this ; }
te	4	public static PLDictionary decodePLDictionary ( XMLFile xml ) { if ( "dict" . equals ( xml . getMe ( ) . getNodeName ( ) ) ) { PLDictionary dict = new PLDictionary ( ) ; XMLFile [ ] keys = xml . gets ( "key" ) ; if ( keys . length > 0 ) { for ( int i = 0 ; i < keys . length ; i ++ ) { XMLFile key = keys [ i ] ; Node value = ( Node ) key . getMe ( ) . getNextSibling ( ) ; if ( null == value ) { continue ; } dict . put ( key . getText ( ) , PListDecoder . decode ( new XMLFile ( ( Element ) value ) ) ) ; } return dict ; } } return null ; }
te	3	public boolean transferir ( int nc1 , int nc2 , double m ) { CuentaBancaria c1 = search ( nc1 ) ; CuentaBancaria c2 = search ( nc2 ) ; if ( c1 != null && c2 != null ) { if ( c1 . retiro ( m ) ) { c2 . deposito ( m ) ; return true ; } } return false ; }
te	9X	@ SuppressWarnings ( "ObjectEqualsNull" ) public static String valueToString ( Object value ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof JSONString ) { Object object ; try { object = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "Bad value from toJSONString: " + object ) ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; }
te	4	public static Method getMethod ( String methodName , class clazz ) { for ( Method method : clazz . getMethods ( ) ) { if ( method . getName ( ) . equals ( methodName ) ) { return method ; } } if ( ! clazz . equals ( Object . class ) ) { class superclass = clazz . getSuperclass ( ) ; if ( superclass != null ) { return getMethod ( methodName , superclass ) ; } else { return null ; } } else { return null ; } }
te	9X	@ Override public void run ( ) { while ( true ) { WatchKey watchKey ; try { watchKey = service . take ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } if ( watchKey != null ) { for ( WatchEvent < ? > p : watchKey . pollEvents ( ) ) { System . out . println ( p . context ( ) + " -> " + p . kind ( ) ) ; Path path = ( Path ) p . context ( ) ; if ( watchKey . watchable ( ) instanceof Path ) { System . out . println ( "DEBUG: watchKey.watchable = " + watchKey . watchable ( ) ) ; } Path modifiedItem = Paths . get ( watchKey . watchable ( ) . toString ( ) , path . toString ( ) ) ; System . out . println ( "DEBUG: modifiedItem = " + modifiedItem ) ; if ( Files . isDirectory ( modifiedItem ) ) { if ( p . kind ( ) == StandardWatchEventKinds . ENTRY_CREATE ) { model . addDirectory ( modifiedItem ) ; try { modifiedItem . register ( service ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } handler . handleDirectory ( model , modifiedItem , toType ( p . kind ( ) ) ) ; } else if ( Files . isRegularFile ( modifiedItem ) ) { handler . handleFile ( model , modifiedItem , toType ( p . kind ( ) ) ) ; } else { if ( Files . exists ( modifiedItem ) ) { System . err . println ( "Could not handle: " + modifiedItem . toAbsolutePath ( ) . toString ( ) ) ; try { BasicFileAttributes bfa = Files . readAttributes ( modifiedItem . toAbsolutePath ( ) , BasicFileAttributes . class ) ; System . out . println ( "    is regular " + bfa . isRegularFile ( ) ) ; System . out . println ( "    is directory " + bfa . isDirectory ( ) ) ; System . out . println ( "    is other " + bfa . isOther ( ) ) ; System . out . println ( "    is link " + bfa . isSymbolicLink ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } watchKey . reset ( ) ; } } }
te	0	protected void setIndex ( int index ) { this . index = index ; }
te	7	public long binarySearch ( long startIndex , long endIndex , byte [ ] struct ) { if ( startIndex < 0 || startIndex > endIndex || endIndex > col . size ( ) ) { throw new IllegalArgumentException ( "Illegal input  collection size: [" + col . size ( ) + "]  " + "startIndex: [" + startIndex + "]  endIndex: [" + endIndex + "]" ) ; } if ( null == struct ) throw new IllegalArgumentException ( "Provided struct is null" ) ; int compres ; long lo = startIndex ; long hi = endIndex - 1 ; while ( lo <= hi ) { long mid = ( lo + hi ) >>> 1 ; compres = comp . compare ( mid , struct ) ; if ( compres < 0 ) { lo = mid + 1 ; } else if ( compres > 0 ) { hi = mid - 1 ; } else { return mid ; } } return ~ lo ; }
te	0	public IOutputtedNeuron [ ] getOutputNeurons ( ) { return this . outputNeurons ; }
te	2	public void add ( Address address ) { if ( addressBook != null ) { addressBook . add ( address ) ; } else if ( ! localAddresses . contains ( address ) ) { localAddresses . add ( address ) ; } }
te	9X	static char type ( String s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; char c = s . charAt ( 0 ) ; if ( c == ' || c == " ) return s ; if ( Character . isDigit ( c ) ) { if ( s . indexOf ( . ) != - 1 ) return f ; else return i ; } if ( s . length ( ) > 1 && c == ! && Character . isLetter ( s . charAt ( 1 ) ) ) return y ; if ( Characters . isOperator ( c ) ) return o ; if ( s . equals ( "true" ) || s . equals ( "false" ) ) return b ; return p ; }
te	2	private void assignContent ( ) throws SAXException { try { int lastObject = buildObjects . size ( ) - 1 ; if ( lastObject >= 0 ) { Object obj = buildObjects . get ( lastObject ) ; this . setAttribute ( obj , this . setterName , content . toString ( ) ) ; } else { logger . trace ( "No objects in build queue." ) ; } } catch ( FogBugzException e ) { logger . trace ( "Throwing exception upwards." , e ) ; throw new SAXException ( e ) ; } content . delete ( 0 , content . length ( ) ) ; content . setLength ( 0 ) ; }
te	4	private static void createBlocks ( List < File > blockFiles , String fileName ) { try { int [ ] numbers = new int [ ARRAY_SIZE ] ; BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; String line = null ; int j = 0 ; while ( ( line = reader . readLine ( ) ) != null ) { numbers [ j ] = Integer . parseInt ( line ) ; j ++ ; if ( j == ARRAY_SIZE ) { quickSort ( numbers , 0 , j - 1 ) ; blockFiles . add ( writeBlock ( numbers , j - 1 ) ) ; j = 0 ; } } if ( j > 0 ) { quickSort ( numbers , 0 , j - 1 ) ; blockFiles . add ( writeBlock ( numbers , j - 1 ) ) ; } reader . close ( ) ; } catch ( Exception IOException ) { System . err . println ( "Error reading file" ) ; IOException . printStackTrace ( ) ; } }
te	7	public void trace ( int depth ) { if ( Thread . currentThread ( ) != this ) { throw new ErrorException ( "trace() can be called only by the animator thread itself" ) ; } currentDepth = depth ; switch ( animatorState ) { case RUNNING : delay ( ) ; break ; case STOPPING : case STEPPING : breakpoint ( ) ; break ; case CALLING : if ( callDepth < currentDepth ) { delay ( ) ; } else { breakpoint ( ) ; } break ; case TERMINATING : terminate ( ) ; break ; } }
te	8	@ Override public boolean equals ( Object obj ) { CouchDB4k c = ( CouchDB4k ) obj ; return ( data3 . equals ( c . data3 ) && data4 . equals ( c . data4 ) && data0 . equals ( c . data0 ) && data7 . equals ( c . data7 ) && data5 . equals ( c . data5 ) && Arrays . equals ( strings , c . strings ) && data1 . equals ( c . data1 ) && Arrays . equals ( integers2 , c . integers2 ) && moreNested . equals ( c . moreNested ) ) ; }
te	1	public static double rawToNumber ( Object value ) { if ( value instanceof double ) return ( double ) value ; return null ; }
te	8	private void draw ( Graphics2D g , Editable editable , String name , boolean drawLineBuffer , boolean drawPointBuffer ) { int n = editable . getNumberOfCoordinates ( ) ; if ( n == 0 ) { return ; } int height = getHeight ( ) - getInsets ( ) . top - getInsets ( ) . bottom ; if ( drawEpsilon ) { g . setColor ( colorEpsilon ) ; int halfHeight = heightEpsilonBar / 2 ; int ypos = height - offsetEpsilon - halfHeight ; g . drawLine ( offsetEpsilon , ypos , offsetEpsilon + epsilon , ypos ) ; g . drawLine ( offsetEpsilon , ypos - halfHeight , offsetEpsilon , ypos + halfHeight ) ; g . drawLine ( offsetEpsilon + epsilon , ypos - halfHeight , offsetEpsilon + epsilon , ypos + halfHeight ) ; } Coordinate last ; if ( drawPointBuffer ) { useAntialiasing ( g , true ) ; g . setColor ( colorBuffersPoints ) ; for ( int i = 0 ; i < n ; i ++ ) { Coordinate c = editable . getCoordinate ( i ) ; g . drawArc ( ( int ) Math . round ( c . getX ( ) - epsilon ) , ( int ) Math . round ( c . getY ( ) - epsilon ) , epsilon * 2 , epsilon * 2 , 0 , 360 ) ; } } if ( drawLineBuffer ) { GeometryFactory factory = new GeometryFactory ( ) ; useAntialiasing ( g , true ) ; g . setColor ( colorBuffersLines ) ; last = editable . getCoordinate ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; com . vividsolutions . jts . geom . Coordinate [ ] cs = new com . vividsolutions . jts . geom . Coordinate [ ] { new com . vividsolutions . jts . geom . Coordinate ( last . getX ( ) , last . getY ( ) ) , new com . vividsolutions . jts . geom . Coordinate ( current . getX ( ) , current . getY ( ) ) } ; LineString seg = factory . createLineString ( cs ) ; Geometry buffer = seg . buffer ( epsilon ) ; Area area = GeometryTransformator . toShape ( ( Polygon ) buffer , new IdentityCoordinateTransformer ( ) ) ; g . fill ( area ) ; last = current ; } } useAntialiasing ( g , true ) ; g . setColor ( colorLines ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; last = editable . getCoordinate ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; int x1 = ( int ) Math . round ( last . getX ( ) ) ; int y1 = ( int ) Math . round ( last . getY ( ) ) ; int x2 = ( int ) Math . round ( current . getX ( ) ) ; int y2 = ( int ) Math . round ( current . getY ( ) ) ; g . drawLine ( x1 , y1 , x2 , y2 ) ; last = current ; } useAntialiasing ( g , false ) ; g . setColor ( colorPoints ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; int x = ( int ) Math . round ( current . getX ( ) ) ; int y = ( int ) Math . round ( current . getY ( ) ) ; g . drawRect ( x - 2 , y - 2 , 4 , 4 ) ; } useAntialiasing ( g , true ) ; g . setColor ( colorLabels ) ; Coordinate first = editable . getFirstCoordinate ( ) ; g . drawString ( name , ( int ) Math . round ( first . getX ( ) ) - 2 , ( int ) Math . round ( first . getY ( ) ) - 4 ) ; }
te	2	private Player getPreviousPlayer ( ) { if ( players . size ( ) < 2 ) { logger . info ( "No more other players left! Finishing too!" ) ; ownPlayer . setActive ( false ) ; return null ; } else { int ownIndex = players . indexOf ( ownPlayer ) ; if ( ownIndex == 0 ) { return players . getLast ( ) ; } else { return players . get ( ownIndex - 1 ) ; } } }
te	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
te	6	public static int [ ] randomize ( int num_choices ) { int [ ] rnd = new int [ 4 ] ; rnd [ 0 ] = ( int ) ( Math . random ( ) * num_choices ) ; do { rnd [ 1 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 1 ] == rnd [ 0 ] ) ; do { rnd [ 2 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 2 ] == rnd [ 0 ] || rnd [ 2 ] == rnd [ 1 ] ) ; do { rnd [ 3 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 3 ] == rnd [ 0 ] || rnd [ 3 ] == rnd [ 1 ] || rnd [ 3 ] == rnd [ 2 ] ) ; return rnd ; }
te	6	@ Override public int send ( Message message , Actor from , String category ) { int count = 0 ; Map < String , Actor > xactors = cloneActors ( ) ; List < Actor > catMembers = new LinkedList < Actor > ( ) ; for ( String key : xactors . keySet ( ) ) { Actor to = xactors . get ( key ) ; if ( category . equals ( to . getCategory ( ) ) && ( to . getMessageCount ( ) < to . getMaxMessageCount ( ) ) ) { catMembers . add ( to ) ; } } int min = Integer . MAX_VALUE ; Actor amin = null ; for ( Actor a : catMembers ) { int mcount = a . getMessageCount ( ) ; if ( mcount < min ) { min = mcount ; amin = a ; } } if ( amin != null ) { count += send ( message , from , amin ) ; } return count ; }
te	1	public Products asProducts ( ) throws DiffbotParseException { try { return this . getFactory ( ) . createJsonParser ( super . toString ( ) ) . parse ( Products . class ) ; } catch ( IOException e ) { throw new DiffbotParseException ( "The classified object cannot be parsed as a Products." , e ) ; } }
te	4	private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; }
te	4	@ Override public void call ( ) throws IOException { boolean online = true ; while ( online ) { selector . select ( ) ; Iterator < SelectionKey > it = selector . selectedKeys ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { SelectionKey key = it . next ( ) ; it . remove ( ) ; SocketChannel channel = ( SocketChannel ) key . channel ( ) ; MessageHandler handler = handlers . get ( channel ) ; if ( key . isReadable ( ) ) { DataUnit message ; try { message = mp . read ( p , channel ) ; handler . handleMessage ( message ) ; } catch ( IOException e ) { handler . notifyDisconnect ( ) ; handlers . remove ( channel ) ; key . cancel ( ) ; } } } } return null ; }
te	6	private RenderableObject generateObject ( String next , Scanner inFile ) { RenderableObject ro = null ; switch ( next ) { case "Ellipse" : ro = generateElipse ( inFile ) ; break ; case "Rectangle" : ro = generateRectangle ( inFile ) ; break ; case "Text" : ro = generateText ( inFile ) ; break ; case "Shape" : ro = generateShape ( inFile ) ; break ; case "Image" : ro = generateImage ( inFile ) ; break ; case "Latex" : ro = generateLatex ( inFile ) ; break ; default : System . out . println ( "Error In File" ) ; System . exit ( 1 ) ; } return ro ; }
te	7	public static void findMinMax ( ) { Scanner kbd = new Scanner ( System . in ) ; ObjectInputStream inputStream ; Species low = null , high = null , test ; String file ; System . out . println ( "Enter file name:" ) ; file = kbd . next ( ) ; try { inputStream = new ObjectInputStream ( new FileInputStream ( file ) ) ; try { low = high = ( Species ) inputStream . readObject ( ) ; while ( true ) { test = ( Species ) inputStream . readObject ( ) ; if ( test . getPopulation ( ) < low . getPopulation ( ) ) low = test ; if ( test . getPopulation ( ) > high . getPopulation ( ) ) high = test ; } } catch ( EOFException e ) { System . out . println ( "End of file." ) ; } } catch ( ClassNotFoundException e ) { System . out . println ( "No class found" ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found." ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } System . out . println ( "The low population species:  " ) ; System . out . println ( low ) ; System . out . println ( ) ; System . out . println ( "The high population species:  " ) ; System . out . println ( high ) ; }
te	9X	@ Override public void trainWord ( String word , Value < State > times , HashMap < State , Value < Character >> restart ) { int len = word . length ( ) ; double wordProb ; Value < State > alpha = initial ( 1.0 ) ; Value < State > beta ; ArrayList < Value < State >> alphas = new ArrayList < Value < State >> ( ) ; alphas . add ( alpha ) ; for ( int t = 0 ; t < len ; ++ t ) { Character c = word . charAt ( t ) ; alpha = forward ( alpha , c ) ; alphas . add ( alpha ) ; } beta = initial ( 1.0 ) ; wordProb = alpha . get ( I ) ; for ( int t = len - 1 ; t >= 0 ; -- t ) { Character c = word . charAt ( t ) ; alpha = alphas . get ( t ) ; for ( State i : alpha . keySet ( ) ) { double alphai = alpha . get ( i ) ; State j = i . next ( c ) ; double restartValue = beta . containsKey ( I ) ? clip ( alphai * i . prRestart ( c ) * beta . get ( I ) / wordProb ) : 0 ; if ( j != null && beta . containsKey ( j ) ) { double nextValue = clip ( alphai * i . prNext ( c ) * beta . get ( j ) / wordProb ) ; times . addValue ( j , nextValue ) ; } restart . get ( i ) . addValue ( c , restartValue ) ; times . addValue ( I , restartValue ) ; } if ( t > 0 ) { Value < State > output = new Value < State > ( ) ; for ( State i : alpha . keySet ( ) ) { State j = i . next ( c ) ; if ( j != null ) { output . addValue ( i , beta . getValue ( j ) * i . prNext ( c ) ) ; } output . addValue ( i , beta . getValue ( I ) * i . prRestart ( c ) ) ; } beta = output ; } } }
te	1	private JTextField getIterationsTxt ( ) { if ( iterationsTxt == null ) { iterationsTxt = new JTextField ( ) ; iterationsTxt . setText ( "500" ) ; iterationsTxt . setBounds ( 167 , 66 , 90 , 22 ) ; iterationsTxt . setEditable ( false ) ; iterationsTxt . setEnabled ( false ) ; } return iterationsTxt ; }
te	9X	public void processMousePress ( int x , int y ) { if ( state == PoseurState . CREATE_SHAPE_STATE ) { selectedShape = null ; } Rectangle2D poseArea = zoomableCanvasState . getPoseArea ( ) ; float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX > poseArea . getWidth ( ) ) || ( poseSpaceY > poseArea . getHeight ( ) ) ) { return ; } if ( state == PoseurState . SELECT_SHAPE_STATE || state == PoseurState . SHAPE_SELECTED_STATE ) { Iterator < PoseurShape > it = pose . getShapesIterator ( ) ; PoseurShape sh ; while ( it . hasNext ( ) ) { sh = it . next ( ) ; if ( sh . containsPoint ( new Point ( poseSpaceX , poseSpaceY ) ) ) { selectedShape = sh ; setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } } } if ( state == PoseurState . SHAPE_SELECTED_STATE ) { if ( selectedShape . containsPoint ( new Point ( poseSpaceX , poseSpaceY ) ) ) { setState ( PoseurState . DRAG_SHAPE_STATE ) ; } } if ( state == PoseurState . CREATE_SHAPE_STATE ) { if ( shapeInProgressType == PoseurShapeType . RECTANGLE ) { shapeInProgress = PoseurRectangle . factoryBuildRectangle ( poseSpaceX , poseSpaceY ) ; } if ( shapeInProgressType == PoseurShapeType . ELLIPSE ) { shapeInProgress = PoseurEllipse . factoryBuildEllipse ( poseSpaceX , poseSpaceY ) ; } if ( shapeInProgressType == PoseurShapeType . LINE ) { shapeInProgress = PoseurLine . factoryBuildLine ( poseSpaceX , poseSpaceY ) ; } setState ( PoseurState . COMPLETE_SHAPE_STATE ) ; } }
te	1	public void copyInputStream ( InputStream in , OutputStream out ) throws IOException { byte [ ] buffer = new byte [ 1024 ] ; int len = in . read ( buffer ) ; while ( len >= 0 ) { out . write ( buffer , 0 , len ) ; len = in . read ( buffer ) ; } in . close ( ) ; out . close ( ) ; }
te	2	private void buttonColoredAction1ActionPerformed ( java . awt . event . ActionEvent evt ) { DefaultTableModel model = new DefaultTableModel ( ) ; this . jTable1 . setModel ( model ) ; model . setColumnIdentifiers ( new Object [ ] { "Id" , "Descripcion" , "Usuario" , "Estado" , "Proyecto" } ) ; Tarea tarea = new Tarea ( ) ; tarea . setIdProyecto ( Integer . parseInt ( txtIdProyecto . getText ( ) ) ) ; try { ResultSet res = QATracker . tareaBus . consultaProyecto ( tarea ) ; while ( res . next ( ) ) { model . addRow ( new Object [ ] { res . getString ( 1 ) , res . getString ( 2 ) , res . getString ( 3 ) , res . getString ( 4 ) , res . getString ( 5 ) } ) ; } } catch ( SQLException ex ) { System . out . println ( ex . getMessage ( ) ) ; } }
te	0	RenderLayer ( int x ) { }
te	3	@ Override public void solve ( BigRational [ ] rhs ) { if ( _class > current_class ) { for ( int i = 0 ; i < size . row ; i ++ ) { basis . setValue ( BigRational . ZERO , array [ i ] [ 0 ] ) ; } } else { for ( int i = 0 ; i < size . row ; i ++ ) { basis . setValue ( carryForwardValue ( i ) , array [ i ] [ 0 ] ) ; } } }
te	6	private static void parseTransitionEndPoint ( Transition . EndPoint endPoint , String expr ) { String label = encryptStereotypeDelimiters ( expr ) ; Styles . Decoration decoration = Styles . Decoration . None ; if ( expr . contains ( "<>" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "<>" , "" ) ; } else if ( expr . contains ( "++" ) ) { decoration = Styles . Decoration . Composition ; label = label . replace ( "++" , "" ) ; } else if ( expr . contains ( "+" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "+" , "" ) ; } else if ( expr . contains ( "<" ) || expr . contains ( ">" ) ) { decoration = Styles . Decoration . -> ; label = label . replace ( "<" , "" ) . replace ( ">" , "" ) ; } else if ( expr . contains ( "^" ) ) { decoration = Styles . Decoration . Inheritance ; label = label . replace ( "^" , "" ) ; } label = decryptStereotypeDelimiters ( label ) ; endPoint . usingDecoration ( decoration ) . usingLabel ( label . trim ( ) ) ; }
te	8	@ Override public String intercept ( ActionInvocation invocation ) throws Exception { ActionContext actionContext = invocation . getInvocationContext ( ) ; HttpServletRequest request = ( HttpServletRequest ) actionContext . get ( StrutsStatics . HTTP_REQUEST ) ; System . out . println ( "interceptor is invoked" ) ; Map session = actionContext . getSession ( ) ; if ( session != null && session . get ( USER_SESSION_KEY ) != null ) { return invocation . invoke ( ) ; } Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies != null ) { for ( Cookie cookie : cookies ) { if ( COOKIE_REMEMBERME_KEY . equals ( cookie . getName ( ) ) ) { String value = cookie . getValue ( ) ; if ( StringUtils . isNotBlank ( value ) ) { String [ ] split = value . split ( "==" ) ; String userName = split [ 0 ] ; String password = split [ 1 ] ; try { User user = userDao . attemptLogin ( userName , password ) ; if ( user != null ) { session . put ( USER_SESSION_KEY , user ) ; } } catch ( Exception e ) { setGoingToURL ( session , invocation ) ; return "login" ; } } else { setGoingToURL ( session , invocation ) ; return "login" ; } return invocation . invoke ( ) ; } } } setGoingToURL ( session , invocation ) ; System . out . println ( session . get ( GOING_TO_URL_KEY ) ) ; return "login" ; }
te	0	public CraftProxyGUI ( ) { pf = new MyPropertiesFile ( "CraftProxyLiteGUI.txt" ) ; pf . load ( ) ; String defaultHostname = pf . getString ( "connect_hostname" , "localhost" ) ; int defaultPort = pf . getInt ( "connect_port" , 20000 ) ; int listenPort = pf . getInt ( "listen_port" , 25565 ) ; int desired = pf . getInt ( "cache_size" , 48 ) ; int latency = pf . getInt ( "buffer_latency" , 0 ) ; setTitle ( "CraftProxyLiter Local Cache Mode - v" + VersionNumbering . version ) ; setSize ( 450 , 325 ) ; setLocation ( 40 , 150 ) ; topPanel . setLayout ( new BorderLayout ( ) ) ; topPanel . setBorder ( new TitledBorder ( "Remote Server" ) ) ; topPanel . setBackground ( Color . WHITE ) ; secondPanel . setLayout ( new BorderLayout ( ) ) ; secondPanel . setBorder ( new TitledBorder ( "Local Server" ) ) ; secondPanel . setBackground ( Color . WHITE ) ; serverName = new JTextField ( defaultHostname , 20 ) ; TitledBorder border = new TitledBorder ( "Name" ) ; serverName . setBorder ( border ) ; serverName . addActionListener ( this ) ; portNum = new JTextField ( Integer . toString ( defaultPort ) , 6 ) ; border = new TitledBorder ( "Port" ) ; portNum . setBorder ( border ) ; portNum . addActionListener ( this ) ; localServerName = new JLabel ( "localhost" ) ; localServerName . setBackground ( Color . GRAY ) ; border = new TitledBorder ( "Name" ) ; localServerName . setBorder ( border ) ; localServerPortnum = new JTextField ( Integer . toString ( listenPort ) , 6 ) ; border = new TitledBorder ( "Port" ) ; localServerPortnum . setBorder ( border ) ; localServerPortnum . addActionListener ( this ) ; topPanel . add ( serverName , BorderLayout . CENTER ) ; topPanel . add ( portNum , BorderLayout . LINE_END ) ; secondPanel . setLayout ( new BorderLayout ( ) ) ; secondPanel . add ( localServerName , BorderLayout . CENTER ) ; secondPanel . add ( localServerPortnum , BorderLayout . LINE_END ) ; combinedTop . setLayout ( new BorderLayout ( ) ) ; combinedTop . add ( topPanel , BorderLayout . CENTER ) ; combinedTop . add ( secondPanel , BorderLayout . SOUTH ) ; currentSize = new JTextField ( "Unknown" ) ; currentSize . setBorder ( new TitledBorder ( "Current Size (MB)" ) ) ; currentSize . setEditable ( false ) ; desiredSize = new JTextField ( Integer . toString ( desired ) ) ; desiredSize . setBorder ( new TitledBorder ( "Max Size (MB)" ) ) ; latencyBox = new JTextField ( Integer . toString ( latency ) ) ; latencyBox . setBorder ( new TitledBorder ( "Buffer latency (ms)" ) ) ; connect = new JButton ( buttonText ) ; connect . addActionListener ( this ) ; filePanel = new JPanel ( ) ; filePanel . setLayout ( new BorderLayout ( ) ) ; JPanel fileLinePanel = new JPanel ( ) ; fileLinePanel . setBorder ( new TitledBorder ( "Cache Size" ) ) ; fileLinePanel . setLayout ( new GridLayout ( 1 , 3 ) ) ; fileLinePanel . add ( currentSize ) ; fileLinePanel . add ( desiredSize ) ; fileLinePanel . add ( latencyBox ) ; filePanel . add ( fileLinePanel , BorderLayout . CENTER ) ; filePanel . add ( connect , BorderLayout . PAGE_END ) ; info = new JLabel ( ) ; border = new TitledBorder ( "Status" ) ; info . setBorder ( border ) ; setLayout ( new BorderLayout ( ) ) ; add ( combinedTop , BorderLayout . PAGE_START ) ; add ( info , BorderLayout . CENTER ) ; add ( filePanel , BorderLayout . PAGE_END ) ; this . setResizable ( false ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; this . addWindowListener ( this ) ; }
te	3	protected boolean isSameDouble ( double d1 , double d2 ) { if ( d1 - d2 == 0.0 ) return true ; else { INEXACT_COMPARED = true ; if ( d1 == 0.0 ) return Math . abs ( d2 ) < TOLERANCE ; if ( d2 == 0.0 ) return Math . abs ( d1 ) < TOLERANCE ; else return Math . abs ( d1 - d2 ) / ( Math . abs ( ( d1 + d2 ) / 2 ) ) < TOLERANCE ; } }
te	8	public static int uniquePaths2 ( int m , int n ) { int [ ] [ ] pathMatrix = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 && j == 0 ) { pathMatrix [ 0 ] [ 0 ] = 1 ; } else if ( i == 0 && j != 0 ) { pathMatrix [ i ] [ j ] = pathMatrix [ i ] [ j - 1 ] ; } else if ( j == 0 && i != 0 ) { pathMatrix [ i ] [ j ] = pathMatrix [ i - 1 ] [ j ] ; } else { pathMatrix [ i ] [ j ] = pathMatrix [ i - 1 ] [ j ] + pathMatrix [ i ] [ j - 1 ] ; } } } return pathMatrix [ m - 1 ] [ n - 1 ] ; }
te	6	public Curve center ( ) { for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] = 0 ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) vec [ j ] += dd [ i ] [ j ] ; for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] /= nRows ( ) ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) dd [ i ] [ j ] -= vec [ j ] ; return this ; }
te	5	public ChannelCipher ( String alg , byte [ ] secret , boolean forEncryption ) throws NoSuchAlgorithmException { int idx = getAlgId ( alg ) ; if ( idx < 0 ) throw new NoSuchAlgorithmException ( alg ) ; int keyLength = keySize [ idx ] ; byte [ ] keyData = new byte [ keyLength ] ; System . arraycopy ( secret , 0 , keyData , 0 , keyLength ) ; try { this . forEncryption = forEncryption ; worker = Cipher . getInstance ( cipherAlgs [ idx ] ) ; key = new SecretKeySpec ( keyData , keyAlgs [ idx ] ) ; AlgorithmParameterSpec spec = null ; if ( cipherAlgs [ idx ] . indexOf ( "CBC" ) != - 1 ) { int size = ivSize [ idx ] ; iv = new byte [ size ] ; for ( int n = 0 ; n < size ; n ++ ) iv [ n ] = secret [ n + keyLength ] ; spec = new IvParameterSpec ( iv ) ; } else iv = null ; int mode = forEncryption ? Cipher . ENCRYPT_MODE : Cipher . DECRYPT_MODE ; worker . init ( mode , key , spec ) ; } catch ( Exception e ) { worker = null ; iv = null ; } }
te	4	@ SuppressWarnings ( { "empty-statement" , "CallToThreadDumpStack" } ) private void miMaterialActionPerformed ( java . awt . event . ActionEvent evt ) { if ( getCadMaterial ( ) != null && ! cadMaterial . isVisible ( ) ) { deskPane . remove ( getCadMaterial ( ) ) ; setCadMaterial ( null ) ; } if ( getCadMaterial ( ) == null ) { setCadMaterial ( new FrmCadMaterial ( this ) ) ; Validacoes v = new Validacoes ( ) ; v . posicao ( this , getCadMaterial ( ) ) ; deskPane . add ( getCadMaterial ( ) ) ; try { getCadMaterial ( ) . setSelected ( true ) ; } catch ( PropertyVetoException ex ) { ex . printStackTrace ( ) ; } } else { getCadMaterial ( ) . toFront ( ) ; } }
te	8	public String getPatternFlagsAsString ( ) { if ( patternFlags == 0 ) return "" ; StringBuffer out = new StringBuffer ( ) ; if ( ( patternFlags & Pattern . CANON_EQ ) != 0 ) out . append ( "Pattern.CANON_EQ+" ) ; if ( ( patternFlags & Pattern . CASE_INSENSITIVE ) != 0 ) out . append ( "Pattern.CASE_INSENSITIVE+" ) ; if ( ( patternFlags & Pattern . COMMENTS ) != 0 ) out . append ( "Pattern.COMMENTS+" ) ; if ( ( patternFlags & Pattern . DOTALL ) != 0 ) out . append ( "Pattern.DOTALL+" ) ; if ( ( patternFlags & Pattern . MULTILINE ) != 0 ) out . append ( "Pattern.MULTILINE+" ) ; if ( ( patternFlags & Pattern . UNICODE_CASE ) != 0 ) out . append ( "Pattern.UNICODE_CASE+" ) ; if ( ( patternFlags & Pattern . UNIX_LINES ) != 0 ) out . append ( "Pattern.UNIX_LINES+" ) ; String outStr = out . toString ( ) ; return outStr . substring ( 0 , outStr . length ( ) - 1 ) ; }
te	9X	@ Test public void shouldFailIfIpv4PartExceedsBounds ( ) { try { Ipv6 . parse ( "::400.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::260.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::256.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.256.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.256.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.256.256" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::300.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.300.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.300.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.3.300" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::256.256.256.256" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } }
te	5	public void addScope ( class < ? extends Annotation > annotationType , Scope scope ) { if ( annotationType == null ) { throw new IllegalArgumentException ( "annotationType" ) ; } if ( scope == null ) { throw new IllegalArgumentException ( "scope" ) ; } Scope put = scopes . putIfAbsent ( annotationType , scope ) ; if ( put != null && put != scope ) { throw new RuntimeException ( ) ; } class < Scope > type = ( class < Scope > ) scope . getClass ( ) ; addInstance ( type , null , scope ) ; }
te	1	public void mouseDragged ( MouseEvent mouseEvent ) { if ( paintType == null ) return ; paintType . mouseDragged ( mouseEvent ) ; }
te	6	public String nextTo ( char d ) { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
te	3	@ Override public void insert ( T element ) { if ( size >= heap . length ) { heap = Arrays . copyOf ( heap , heap . length + INCREASING_FACTOR ) ; } else { int i = size ; while ( i > 0 && heap [ parent ( i ) ] . compareTo ( element ) < 0 ) { heap [ i ] = heap [ parent ( i ) ] ; i = parent ( i ) ; } heap [ i ] = element ; size ++ ; } }
te	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ConstDeclarationNode other = ( ConstDeclarationNode ) obj ; if ( expression == null ) { if ( other . expression != null ) return false ; } else if ( ! expression . equals ( other . expression ) ) return false ; if ( ident == null ) { if ( other . ident != null ) return false ; } else if ( ! ident . equals ( other . ident ) ) return false ; return true ; }
te	3	public void setContent ( ChannelBuffer content ) { if ( content == null ) { content = ChannelBuffers . EMPTY_BUFFER ; } if ( content . readable ( ) && isChunked ( ) ) { throw new IllegalArgumentException ( "non-empty content disallowed if this.chunked == true" ) ; } this . content = content ; }
te	5	public TreeNode buildTree ( int [ ] inorder , int [ ] postorder ) { if ( inorder == null || postorder == null || inorder . length == 0 || postorder . length == 0 ) return null ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < inorder . length ; i ++ ) { map . put ( inorder [ i ] , i ) ; } return buildTreeHelper ( postorder , map , 0 , postorder . length , 0 ) ; }
te	4	@ Override public void keyPressed ( KeyEvent k ) { if ( k . getKeyCode ( ) == k . VK_ENTER ) { try { model . setY ( double . parseDouble ( yLocField . getText ( ) ) ) ; if ( model instanceof EditorGravitable ) { if ( ( ( EditorGravitable ) model ) . model instanceof PathGravitable ) { ( ( PathGravitable ) ( ( EditorGravitable ) model ) . model ) . start . y = ( int ) double . parseDouble ( yLocField . getText ( ) ) ; } } } catch ( Exception e ) { yLocField . setText ( "" + model . getY ( ) ) ; } EditorWindow . pane . drawUpdate ( ) ; } }
te	2	@ Override public Rectangular getPosition ( Area a ) { if ( a . getParentArea ( ) == area && a instanceof DefaultArea ) return ( ( DefaultArea ) a ) . getGridPosition ( ) ; else return null ; }
te	8	private void generateItems ( double density ) { double candleDensity = 0.05 ; for ( int column = 0 ; column < getColumns ( ) ; column ++ ) { for ( int row = 0 ; row < getRows ( ) ; row ++ ) { if ( isPath ( column , row ) && Math . random ( ) < candleDensity ) { Candle c = new Candle ( ) ; int hPadding = ( SQUARE_SIZE - c . getWidth ( ) ) / 2 ; int vPadding = ( SQUARE_SIZE - c . getHeight ( ) ) / 2 ; c . setX ( column * SQUARE_SIZE + hPadding ) ; c . setY ( row * SQUARE_SIZE + vPadding ) ; lights . add ( c ) ; items . add ( c ) ; } } } for ( int x = SQUARE_SIZE ; x < ( columns - 1 ) * SQUARE_SIZE ; x += SQUARE_SIZE ) { for ( int y = SQUARE_SIZE ; y < ( rows - 1 ) * SQUARE_SIZE ; y += SQUARE_SIZE ) { if ( ! hasItem ( x + SQUARE_SIZE / 2 , y + SQUARE_SIZE / 2 ) && Math . random ( ) < density ) { Item item = Item . randomItem ( x , y ) ; int hPadding = ( SQUARE_SIZE - item . getWidth ( ) ) / 2 ; int vPadding = ( SQUARE_SIZE - item . getHeight ( ) ) / 2 ; item . setX ( x + hPadding ) ; item . setY ( y + vPadding ) ; items . add ( item ) ; } } } }
te	0	@ XmlElementDecl ( namespace = "com/firstdata/Merchant/gmfV3.10" , name = "OfferProvName" ) public JAXBElement < String > createOfferProvName ( String value ) { return new JAXBElement < String > ( _OfferProvName_QNAME , String . class , null , value ) ; }
te	4	public void loadSprite ( String poseFileName ) { XMLUtilities xmlUtil = new XMLUtilities ( ) ; try { Document doc = xmlUtil . loadXMLDocument ( poseFileName , POSE_SCHEMA ) ; int poseWidth = xmlUtil . getIntData ( doc , POSE_WIDTH_NODE ) ; int poseHeight = xmlUtil . getIntData ( doc , POSE_HEIGHT_NODE ) ; PoseurPose tempPose = new PoseurPose ( poseWidth , poseHeight ) ; LinkedList < PoseurShape > shapesList = tempPose . getShapesList ( ) ; NodeList shapeNodes = doc . getElementsByTagName ( POSEUR_SHAPE_NODE ) ; for ( int i = 0 ; i < shapeNodes . getLength ( ) ; i ++ ) { Node node = shapeNodes . item ( i ) ; PoseurShape shapeToAdd ; Node geometryNode = xmlUtil . getChildNodeWithName ( node , GEOMETRY_NODE ) ; NamedNodeMap attributes = geometryNode . getAttributes ( ) ; String shapeTypeText = attributes . getNamedItem ( SHAPE_TYPE_ATTRIBUTE ) . getTextContent ( ) ; PoseurShapeType shapeType = PoseurShapeType . valueOf ( shapeTypeText ) ; if ( shapeType == PoseurShapeType . RECTANGLE ) { double x = double . parseDouble ( attributes . getNamedItem ( X_ATTRIBUTE ) . getTextContent ( ) ) ; double y = double . parseDouble ( attributes . getNamedItem ( Y_ATTRIBUTE ) . getTextContent ( ) ) ; double width = double . parseDouble ( attributes . getNamedItem ( WIDTH_ATTRIBUTE ) . getTextContent ( ) ) ; double height = double . parseDouble ( attributes . getNamedItem ( HEIGHT_ATTRIBUTE ) . getTextContent ( ) ) ; Rectangle2D . double geometry = new Rectangle2D . double ( x , y , width , height ) ; shapeToAdd = new PoseurRectangle ( geometry ) ; } else if ( shapeType == PoseurShapeType . ELLIPSE ) { double x = double . parseDouble ( attributes . getNamedItem ( X_ATTRIBUTE ) . getTextContent ( ) ) ; double y = double . parseDouble ( attributes . getNamedItem ( Y_ATTRIBUTE ) . getTextContent ( ) ) ; double width = double . parseDouble ( attributes . getNamedItem ( WIDTH_ATTRIBUTE ) . getTextContent ( ) ) ; double height = double . parseDouble ( attributes . getNamedItem ( HEIGHT_ATTRIBUTE ) . getTextContent ( ) ) ; Ellipse2D . double geometry = new Ellipse2D . double ( x , y , width , height ) ; shapeToAdd = new PoseurEllipse ( geometry ) ; } else { double x1 = double . parseDouble ( attributes . getNamedItem ( X1_ATTRIBUTE ) . getTextContent ( ) ) ; double y1 = double . parseDouble ( attributes . getNamedItem ( Y1_ATTRIBUTE ) . getTextContent ( ) ) ; double x2 = double . parseDouble ( attributes . getNamedItem ( X2_ATTRIBUTE ) . getTextContent ( ) ) ; double y2 = double . parseDouble ( attributes . getNamedItem ( Y2_ATTRIBUTE ) . getTextContent ( ) ) ; Line2D . double geometry = new Line2D . double ( x1 , y1 , x2 , y2 ) ; shapeToAdd = new PoseurLine ( geometry ) ; } Node outlineNode = xmlUtil . getChildNodeWithName ( node , OUTLINE_THICKNESS_NODE ) ; int outlineThickness = Integer . parseInt ( outlineNode . getTextContent ( ) ) ; BasicStroke outlineStroke = new BasicStroke ( outlineThickness ) ; Node alphaNode = xmlUtil . getChildNodeWithName ( node , ALPHA_NODE ) ; int alpha = Integer . parseInt ( alphaNode . getTextContent ( ) ) ; shapeToAdd . setAlpha ( alpha ) ; shapeToAdd . setOutlineThickness ( outlineStroke ) ; shapesList . add ( shapeToAdd ) ; } Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager stateManager = singleton . getStateManager ( ) ; PoseurPose actualPose = stateManager . getPose ( ) ; actualPose . loadPoseData ( tempPose ) ; PoseurGUI gui = singleton . getGUI ( ) ; JOptionPane . showMessageDialog ( gui , POSE_LOADED_TEXT , POSE_LOADED_TITLE_TEXT , JOptionPane . INFORMATION_MESSAGE ) ; singleton . getStateManager ( ) . setState ( PoseurState . SELECT_SHAPE_STATE ) ; } catch ( InvalidXMLFileFormatException | DOMException | HeadlessException ex ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurGUI gui = singleton . getGUI ( ) ; JOptionPane . showMessageDialog ( gui , POSE_LOADING_ERROR_TEXT , POSE_LOADING_ERROR_TITLE_TEXT , JOptionPane . ERROR_MESSAGE ) ; } }
te	5	protected String [ ] splitBlockComment ( TokenizerProperty prop , String image ) { String [ ] images = prop . getImages ( ) ; String start = images [ 0 ] ; String end = images [ 1 ] ; boolean noCase = isFlagSet ( prop , Flags . F_NO_CASE ) ; if ( image . length ( ) - start . length ( ) >= end . length ( ) && ( ( ! noCase && end . equals ( image . substring ( image . length ( ) - end . length ( ) ) ) ) || ( noCase && end . equalsIgnoreCase ( image . substring ( image . length ( ) - end . length ( ) ) ) ) ) ) { return splitIntoLines ( image . substring ( start . length ( ) , image . length ( ) - end . length ( ) ) ) ; } else { return splitIntoLines ( image . substring ( start . length ( ) ) ) ; } }
te	8	public boolean hasRecoil ( ) { switch ( this ) { case BRAVE_BIRD : case DOUBLE_EDGE : case FLARE_BLITZ : case HEAD_SMASH : case SUBMISSION : case TAKE_DOWN : case VOLT_TACKLE : case WOOD_HAMMER : return true ; default : return false ; } }
te	9X	private static void method377 ( int ai [ ] , int i , int j , int l , int i1 ) { int k ; if ( aBoolean1462 ) { if ( i1 > DrawingArea . centerX ) i1 = DrawingArea . centerX ; if ( l < 0 ) l = 0 ; } if ( l >= i1 ) return ; i += l ; k = i1 - l >> 2 ; if ( anInt1465 == 0 ) { while ( -- k >= 0 ) { ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j ; return ; } int j1 = anInt1465 ; int k1 = 256 - anInt1465 ; j = ( ( j & ff00ff ) * k1 >> 8 & ff00ff ) + ( ( j & ff00 ) * k1 >> 8 & ff00 ) ; while ( -- k >= 0 ) { ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; }
te	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
te	2	public final Vector getOptionValues ( Option option ) { Vector result = new Vector ( ) ; while ( true ) { Object o = getOptionValue ( option , null ) ; if ( o == null ) { return result ; } else { result . addElement ( o ) ; } } }
te	2	private static void checkSort ( Integer [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] != i ) System . out . println ( "Error at " + i ) ; System . out . println ( "Finished checksort" ) ; }
te	5	public void iniciar ( ) { JPanel panel = new JPanel ( ) ; getContentPane ( ) . add ( panel ) ; panel . setLayout ( null ) ; JLabel vermelho = new JLabel ( "Vermelho:" ) ; vermelho . setBounds ( 5 , 0 , 80 , 30 ) ; vermelho . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel amarelo = new JLabel ( "Laranja:" ) ; amarelo . setBounds ( 5 , 80 , 80 , 30 ) ; amarelo . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel verde = new JLabel ( "Verde: " ) ; verde . setBounds ( 5 , 160 , 80 , 30 ) ; verde . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho ) ; panel . add ( amarelo ) ; panel . add ( verde ) ; final JLabel vermelho1 = new JLabel ( "0" ) ; vermelho1 . setBounds ( 80 , 0 , 80 , 30 ) ; vermelho1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo1 = new JLabel ( "0" ) ; amarelo1 . setBounds ( 80 , 80 , 80 , 30 ) ; amarelo1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde1 = new JLabel ( "0" ) ; verde1 . setBounds ( 80 , 160 , 80 , 30 ) ; verde1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho1 ) ; panel . add ( amarelo1 ) ; panel . add ( verde1 ) ; final JLabel vermelho2 = new JLabel ( "0" ) ; vermelho2 . setBounds ( 120 , 0 , 80 , 30 ) ; vermelho2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo2 = new JLabel ( "0" ) ; amarelo2 . setBounds ( 120 , 80 , 80 , 30 ) ; amarelo2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde2 = new JLabel ( "0" ) ; verde2 . setBounds ( 120 , 160 , 80 , 30 ) ; verde2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho2 ) ; panel . add ( amarelo2 ) ; panel . add ( verde2 ) ; final JLabel vermelho3 = new JLabel ( "0" ) ; vermelho3 . setBounds ( 160 , 0 , 80 , 30 ) ; vermelho3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo3 = new JLabel ( "0" ) ; amarelo3 . setBounds ( 160 , 80 , 80 , 30 ) ; amarelo3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde3 = new JLabel ( "0" ) ; verde3 . setBounds ( 160 , 160 , 80 , 30 ) ; verde3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho3 ) ; panel . add ( amarelo3 ) ; panel . add ( verde3 ) ; final JLabel vermelho4 = new JLabel ( "0" ) ; vermelho4 . setBounds ( 200 , 0 , 80 , 30 ) ; vermelho4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo4 = new JLabel ( "0" ) ; amarelo4 . setBounds ( 200 , 80 , 80 , 30 ) ; amarelo4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde4 = new JLabel ( "0" ) ; verde4 . setBounds ( 200 , 160 , 80 , 30 ) ; verde4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho4 ) ; panel . add ( amarelo4 ) ; panel . add ( verde4 ) ; setTitle ( "Semaforos" ) ; setSize ( 400 , 400 ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; Semaforo semaforo1 = new Semaforo ( ) ; semaforo1 . setRedText ( vermelho1 ) ; semaforo1 . setOrangeText ( amarelo1 ) ; semaforo1 . setGreenText ( verde1 ) ; semaforo1 . setStatus ( 0 ) ; semaforo1 . start ( ) ; Semaforo semaforo2 = new Semaforo ( ) ; semaforo2 . setRedText ( vermelho2 ) ; semaforo2 . setOrangeText ( amarelo2 ) ; semaforo2 . setGreenText ( verde2 ) ; semaforo2 . setStatus ( 0 ) ; semaforo2 . start ( ) ; Semaforo semaforo3 = new Semaforo ( ) ; semaforo3 . setRedText ( vermelho3 ) ; semaforo3 . setOrangeText ( amarelo3 ) ; semaforo3 . setGreenText ( verde3 ) ; semaforo3 . setStatus ( 2 ) ; semaforo3 . start ( ) ; Semaforo semaforo4 = new Semaforo ( ) ; semaforo4 . setRedText ( vermelho4 ) ; semaforo4 . setOrangeText ( amarelo4 ) ; semaforo4 . setGreenText ( verde4 ) ; semaforo4 . setStatus ( 2 ) ; semaforo4 . start ( ) ; long secondLast = 0 ; int currentSign = 1 ; while ( true ) { long secondNow = System . currentTimeMillis ( ) / 1000 ; if ( secondNow - secondLast >= 10 ) { switch ( currentSign ) { case 1 : semaforo3 . change ( ) ; semaforo4 . change ( ) ; semaforo1 . change ( ) ; semaforo2 . change ( ) ; break ; case 2 : semaforo1 . change ( ) ; semaforo2 . change ( ) ; semaforo3 . change ( ) ; semaforo4 . change ( ) ; break ; default : break ; } secondLast = secondNow ; currentSign ++ ; if ( currentSign == 3 ) currentSign = 1 ; } } }
te	2	public static void createTableCompulsoryCourses ( ) { try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "table CompulsoryCourses not created" ) ; dbConn . setAutoCommit ( false ) ; dbStmnt = dbConn . createStatement ( ) ; dbStmnt . executeUpdate ( "use phdStudent;" ) ; dbStmnt . executeUpdate ( "create table if not exists CompulsoryCourses" + "(id int auto_increment primary key " + "studentId int not null references Student(id) on delete cascade on update cascade " + "curriculumId int  not null references StudentCurriculum(id) on update cascade " + "courseName varchar(255) not null " + "courseType varchar(255) not null " + "estimate date not null " + "studentType varchar(255) not null " + "protocolId int not null references CourseProtocols(id) on update cascade);" ) ; dbConn . commit ( ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
te	6	private String compare ( String leftHandSide , String rightHandSide ) { if ( leftHandSide . equals ( "integer" ) ) { if ( rightHandSide . equals ( "integer" ) ) { return "integer" ; } else if ( rightHandSide . equals ( "real" ) ) { return "real" ; } else { SemanticWarningList . addWarning ( SemanticWarning . makeNewWarning ( "Unknown type for variable '" + rightHandSide + "'. Undeclared variable." ) ) ; } } else if ( leftHandSide . equals ( "real" ) ) { if ( rightHandSide . equals ( "integer" ) || rightHandSide . equals ( "real" ) ) { return "real" ; } } return EMPTY ; }
te	4	public boolean playersInScourge ( int [ ] pl ) { boolean found = false ; for ( int p : pl ) { found = false ; for ( int s : scourge ) { if ( s == p ) { found = true ; } } if ( ! found ) { return false ; } } return true ; }
te	9X	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! this . getClass ( ) . equals ( obj . getClass ( ) ) ) { return false ; } Struct3 < ? , ? , ? > t = ( Struct3 < ? , ? , ? > ) obj ; return Calc . areObjectsEqual ( a , t . a ) && Calc . areObjectsEqual ( b , t . b ) && Calc . areObjectsEqual ( c , t . c ) ; }
te	1	private void processTruncatedNormal ( String name , Node node ) { NamedNodeMap attrs = node . getAttributes ( ) ; Node nMean = attrs . getNamedItem ( "mean" ) ; double mean = double . parseDouble ( nMean . getNodeValue ( ) . trim ( ) ) ; Node nVariance = attrs . getNamedItem ( "variance" ) ; double variance = double . parseDouble ( nVariance . getNodeValue ( ) . trim ( ) ) ; Node nScalingFactor = attrs . getNamedItem ( "scalingFactor" ) ; double scalingFactor = 1.0 ; if ( nScalingFactor != null ) { scalingFactor = double . parseDouble ( nScalingFactor . getNodeValue ( ) . trim ( ) ) ; } else { this . vars . put ( name , Distribution . getTruncatedNormalDistribution ( mean , variance , scalingFactor ) ) ; } }
te	9X	public String to_simple_string ( ) throws internal_error { String result ; production_part part ; if ( _the_production . lhs ( ) != null && _the_production . lhs ( ) . the_symbol ( ) != null && _the_production . lhs ( ) . the_symbol ( ) . name ( ) != null ) result = _the_production . lhs ( ) . the_symbol ( ) . name ( ) ; else result = "$$NULL$$" ; result += " ::= " ; for ( int i = 0 ; i < _the_production . rhs_length ( ) ; i ++ ) { if ( i == _dot_pos ) result += "(*) " ; if ( _the_production . rhs ( i ) == null ) { result += "$$NULL$$ " ; } else { part = _the_production . rhs ( i ) ; if ( part == null ) result += "$$NULL$$ " ; else if ( part . is_action ( ) ) result += "{ACTION} " ; else if ( ( ( symbol_part ) part ) . the_symbol ( ) != null && ( ( symbol_part ) part ) . the_symbol ( ) . name ( ) != null ) result += ( ( symbol_part ) part ) . the_symbol ( ) . name ( ) + " " ; else result += "$$NULL$$ " ; } } if ( _dot_pos == _the_production . rhs_length ( ) ) result += "(*) " ; return result ; }
te	1	public static void fecharConexao ( Connection con , Statement stm ) { try { con . close ( ) ; stm . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( FabricaDeConexoes . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	2	public ListaObjetos ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; try { model = tipoLista . equals ( LISTA_CLIENTES ) ? new ClienteTableModel ( Factory . getClienteDAO ( ) . getAll ( ) ) : new ProgramaTableModel ( Factory . getProgramaDAO ( ) . getAll ( ) ) ; } catch ( DatosPaooException ex ) { mostrarException ( "Inicializar ventana" , "Ocurrio un problema al inicializar lista de objetos" ) ; } jTable1 . setModel ( model ) ; }
te	4	@ Override public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( other == null ) { return false ; } if ( other instanceof HourMinuteInDay ) { HourMinuteInDay otherDayTime = ( HourMinuteInDay ) other ; return ( this . hour == otherDayTime . hour && this . minute == otherDayTime . minute ) ; } else { return false ; } }
te	0	public void settable_employeeListener ( MouseListener l ) { this . table_employee . addMouseListener ( l ) ; }
te	0	public void setIdIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __ID_ISSET_ID , value ) ; }
te	5	private static Number appropriateParseFor ( String text , class < ? extends Number > numberFormat ) throws NumberFormatException { if ( numberFormat == long . class ) { return long . parseLong ( text ) ; } else if ( numberFormat == Integer . class ) { return Integer . parseInt ( text ) ; } else if ( numberFormat == double . class ) { return double . parseDouble ( text ) ; } else if ( numberFormat == float . class ) { return float . parseFloat ( text ) ; } else { throw new RuntimeException ( "cant figure out appropriate number format" ) ; } }
te	2	public Totals ( String [ ] measures , Map < String , List < CustomAggregateFactory < T >>> aggregateFactories ) { this . aggregates = new HashMap < String , Aggregate < T >> ( ) ; for ( String measure : measures ) { aggregates . put ( measure , new Aggregate < T > ( aggregateFactories . containsKey ( measure ) ? aggregateFactories . get ( measure ) : null ) ) ; } }
te	2	public List < Location > getFreeAdjacentLocations ( Location location ) { List < Location > free = new LinkedList < Location > ( ) ; List < Location > adjacent = adjacentLocations ( location ) ; for ( Location next : adjacent ) { if ( getObjectAt ( next ) == null ) { free . add ( next ) ; } } return free ; }
te	1	public GameController ( ) { this . level = START_LEVEL ; if ( START_LEVEL > - 1 ) { this . playerHealth = 4 ; this . playerRange = 4 ; this . playerPower = this . level ; } this . enemyFactory = new EnemyFactory ( this ) ; }
te	8	public void checkFiles ( ) { List < LeafNode > leaves = getLeaves ( ) ; if ( leaves != null ) { ListIterator < LeafNode > it = leaves . listIterator ( ) ; while ( it . hasNext ( ) ) { LeafNode node = it . next ( ) ; String filePath = UserPreferences . PREF_DOWNLOAD_TARGET ; String dirs = node . getPathDir ( ) . getDirs ( ) ; if ( dirs != null ) filePath += File . separator + dirs ; filePath += File . separator + node . getItem ( ) . getName ( ) ; File f = new File ( filePath ) ; if ( f . exists ( ) && f . length ( ) == node . getItem ( ) . getSize ( ) ) { node . setDownPerc ( 1.0f ) ; node . setStatus ( "Completed" ) ; continue ; } int i = 0 ; long dlSize = 0 ; while ( true ) { File fPart = new File ( filePath + ".pio" + i ) ; if ( ! fPart . exists ( ) ) break ; else dlSize += fPart . length ( ) ; i ++ ; } if ( i > 0 ) { node . setDownPerc ( ( float ) dlSize / ( float ) node . getItem ( ) . getSize ( ) ) ; node . setStatus ( GuiOperations . getReadableSize ( dlSize ) + " / " + GuiOperations . getReadableSize ( node . getItem ( ) . getSize ( ) ) ) ; } } } repaint ( ) ; }
te	4	public void Connect ( ) { try { mServerAddress = InetAddress . getByName ( mServerName ) ; mSocket = new DatagramSocket ( mPort + 2 , mServerAddress ) ; new Thread ( mTimer ) . start ( ) ; new Thread ( new ConnectionListener ( ) ) . start ( ) ; while ( ! mConnected && ! mDisconnected ) { Send ( "connect" ) ; try { Thread . sleep ( 250 ) ; } catch ( Exception e ) { } } } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "failed to connect" ) ; mDisconnected = true ; } }
te	6	public void write ( ) { System . out . println ( "The letters are:" ) ; for ( int i = 0 ; i < word . length ; i ++ ) { System . out . println ( word [ i ] ) ; } System . out . println ( "The occruances are:  " ) ; for ( int i = 0 ; i < letter . length ; i ++ ) { if ( letter [ i ] != 0 && i != 26 ) System . out . println ( ( char ) ( i + 97 ) + ":  " + letter [ i ] ) ; else if ( letter [ i ] != 0 && i == 26 ) System . out . println ( "Space or other :" + letter [ i ] ) ; } }
te	7	protected void loadChildren ( MergeSort sorter ) { totalSize = file . length ( ) ; children = createChildren ( null ) ; for ( int counter = children . length - 1 ; counter >= 0 ; counter -- ) { Thread . yield ( ) ; if ( ! children [ counter ] . isLeaf ( ) && ( descendLinks || ! children [ counter ] . isLink ( ) ) ) { children [ counter ] . loadChildren ( sorter ) ; } totalSize += children [ counter ] . totalSize ( ) ; if ( ! isValid ) { counter = 0 ; } } if ( isValid ) { if ( sorter != null ) { sorter . sort ( children ) ; } totalSizeValid = true ; } }
te	8	public boolean group ( int indentation ) throws IOException , SyntaxException { int c = read ( ) ; if ( c != ( ) { unread ( ) ; return false ; } int lev = level ; space ( ) ; while ( true ) { String s = null ; if ( ( s = string ( ) ) != null ) { handler . event ( s ) ; handler . level ( ++ lev ) ; lev ++ ; } else if ( space ( ) > 0 ) { } else if ( ( s = quoted ( indentation ) ) != null ) { handler . event ( s ) ; handler . level ( ++ lev ) ; lev ++ ; } else if ( , ( ) ) { lev = level ; handler . level ( lev ) ; } else if ( ! group ( indentation ) ) break ; } space ( ) ; c = read ( ) ; if ( c != ) ) throw new SyntaxException ( "missing ): " + ( char ) c ) ; level = lev ; handler . level ( level ) ; return true ; }
te	3	public Decision askDecision ( Player p , State s ) { PlayerState ps = s . currentPlayerState ( ) ; System . out . println ( "---" ) ; System . out . println ( "player: " + p . name ( ) ) ; System . out . println ( "railways: " + ps . railways ) ; System . out . println ( "missions: " + ps . missions ) ; System . out . println ( "hand: " + ps . hand ) ; System . out . println ( "open deck: " + s . openCards ( ) ) ; if ( ps . drawn_card != null ) System . out . println ( "you just drew a " + ps . drawn_card + "  you must choose from where to draw your second card" ) ; if ( ps . drawn_missions != null ) System . out . println ( "you just drew missions " + ps . drawn_missions + "  you must decide which to keep" ) ; Decision d = null ; do { System . out . print ( "? " ) ; String [ ] words = get_words ( ) ; d = interpret ( words , ps . handle ) ; } while ( d == null ) ; return d ; }
te	1	public static int valuePositive ( ) { int value = Integer . MIN_VALUE ; if ( value < 0 ) value = - value ; System . out . println ( "value: " + value ) ; assert ( value >= 0 ) : "value is negative" ; return value ; }
te	9X	public void playRecording ( File file ) { if ( slave != null ) { int amount = 0 ; try { liveData = false ; FileInputStream fis = new FileInputStream ( file ) ; ObjectInputStream inSize = new ObjectInputStream ( fis ) ; while ( true ) { inSize . readObject ( ) ; amount ++ ; } } catch ( Exception e ) { } try { System . out . println ( amount ) ; FileInputStream fis = new FileInputStream ( file ) ; ObjectInputStream in = new ObjectInputStream ( fis ) ; Packet p = null ; int count = 0 ; int start ; int border ; if ( ! ScienceTool . _SPLIT_VALUES ) { if ( ScienceTool . getParameter ( "Slittpart" ) == 1.0 ) { start = 0 ; border = amount / 2 ; } else { start = amount / 2 ; border = amount ; } } else { start = 0 ; border = amount ; } while ( true ) { p = ( Packet ) in . readObject ( ) ; count ++ ; if ( count >= start && count < border ) this . messageReceivedWithTimestamp ( p . adress , new SnoopBCMsg ( p . data , 8 ) , p . time , true ) ; } } catch ( EOFException e ) { } catch ( ClassNotFoundException ex ) { Logger . getLogger ( Datasource . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException e ) { System . out . println ( file . getPath ( ) ) ; e . printStackTrace ( ) ; } liveData = true ; } }
te	2	private void initNodes ( Object [ ] arguments ) { if ( arguments . length <= 0 || ! ( arguments [ 2 ] instanceof Map ) ) { return ; } nodeAgents = ( HashMap < AID , Coordinates > ) arguments [ 0 ] ; }
te	0	public int getArgCount ( ) { return 2 ; }
te	8	public static Object divide ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . divide ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . divide ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) / ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) / ( ( Number ) val1 ) . intValue ( ) ; } return ( val0 != null ? val0 : "" ) + "/" + ( val1 != null ? val1 : "" ) ; }
te	7	public ArrayList < BeanOutbox > getOutbox ( String codigo ) { ArrayList < BeanOutbox > list = new ArrayList < BeanOutbox > ( ) ; String SQL1 = "SELECT * from mensajes where idProfesores='" + codigo + "' order by fecha desc" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int idmensaje = rs1 . getInt ( "id" ) ; BeanOutbox bean = new BeanOutbox ( ) ; bean . setId ( idmensaje ) ; String destina = "" ; String SQL2 = "Select prof.nombre from mensajesprofesores as menp inner" + " join profesores as prof on prof.id=menp.idProfesores where " + "menp.idMensajes='" + idmensaje + "'" ; Statement st2 = getSgd ( ) . createStatement ( ) ; ResultSet rs2 = getSgd ( ) . getResultSet ( SQL2 , st2 ) ; int count = 0 ; while ( rs2 != null && rs2 . next ( ) ) { destina += rs2 . getString ( "nombre" ) + "; " ; count += 1 ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } bean . setDestinatarios ( destina ) ; bean . setDestinatariosCount ( count ) ; bean . setFechaEnviado ( rs1 . getDate ( "fecha" ) ) ; String txt = rs1 . getString ( "texto" ) ; bean . setTexto ( txt ) ; bean . setAttachments ( loadAttachments ( idmensaje ) ) ; list . add ( bean ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( MensajesCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return list ; }
te	3	@ Override public void parseFile ( ) { data = new ArrayList < > ( ) ; try { Scanner in = new Scanner ( new File ( filePath ) ) ; findClasses ( ) ; while ( in . hasNext ( ) ) { String [ ] split = in . nextLine ( ) . split ( " " ) ; List < double > featureList = new ArrayList < > ( ) ; for ( int featureIterator = 0 ; featureIterator < inputs ; featureIterator ++ ) featureList . add ( double . valueOf ( split [ featureIterator ] ) ) ; List < double > output = getOutputVector ( split [ inputs ] ) ; data . add ( new DataPoint ( featureList , output ) ) ; } in . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found for poker dataset." ) ; e . printStackTrace ( ) ; } finally { findClasses ( ) ; } }
te	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . isDouble ( ) && o2 . isDouble ( ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isDouble ( ) ) { return 1 ; } else if ( o2 . isDouble ( ) ) { return - 1 ; } else { return 0 ; } } }
te	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
te	1	private Dimension getMinimumComponentSize ( Component comp ) { if ( isScrollbar ( comp ) ) return getMinimumScrollbarSize ( comp ) ; return comp . getMinimumSize ( ) ; }
te	3	public void read ( ) throws IOException { InputStream fis ; BufferedReader br ; String line ; fis = new FileInputStream ( fileLocation ) ; br = new BufferedReader ( new InputStreamReader ( fis , Charset . forName ( "UTF-8" ) ) ) ; boolean skipLine = true ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! skipLine ) { String [ ] split = line . split ( ";" ) ; int repetitions = Integer . parseInt ( split [ split . length - 1 ] ) ; for ( int i = 0 ; i < repetitions ; i ++ ) { testParameters . add ( line ) ; } } else { skipLine = false ; } } br . close ( ) ; br = null ; fis = null ; }
te	5	public Object read ( String entityClassFullName , Integer id ) throws EntityNotFoundException { Session session = null ; Transaction transaction = null ; try { session = this . sessionFactory . getCurrentSession ( ) ; transaction = session . beginTransaction ( ) ; Object instance = session . get ( entityClassFullName , id ) ; transaction . commit ( ) ; if ( instance == null ) { throw new EntityNotFoundException ( entityClassFullName + " not found for id = " + id ) ; } return instance ; } catch ( RuntimeException re ) { if ( transaction != null ) { transaction . rollback ( ) ; } throw re ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
te	8	public boolean equals ( peek_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . is_set_success ( ) ; boolean that_present_success = true && that . is_set_success ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
te	8	public void process ( ) { output = new StringBuffer ( ) ; InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/balexp.txt" ) ) ; Stack < Character > stack = new Stack < Character > ( ) ; String infix = in . readLine ( ) ; for ( int i = 0 ; i < infix . length ( ) ; i ++ ) { char ch = infix . charAt ( i ) ; switch ( ch ) { case + : case - : getOper ( stack , ch , getPriority ( ch ) ) ; break ; case / : case * : getOper ( stack , ch , getPriority ( ch ) ) ; break ; case ( : stack . push ( ch ) ; break ; case ) : gotParen ( stack ) ; break ; default : output . append ( ch ) ; } } while ( ! stack . isEmpty ( ) ) { output . append ( stack . pop ( ) ) ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { DialogKirimPesan dialog = new DialogKirimPesan ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	1	static Point [ ] makePoints ( String representation ) { Point [ ] points = new Point [ representation . length ( ) ] ; Scanner sc = new Scanner ( representation ) ; int i = 0 ; while ( sc . hasNextDouble ( ) ) { points [ i ++ ] = p ( sc . nextDouble ( ) , sc . nextDouble ( ) ) ; } return Arrays . copyOf ( points , i ) ; }
te	7	public static List < Tile > loadMap ( String filename ) { ArrayList < String > lines = new ArrayList < String > ( ) ; int width = 0 ; InputStream is = MapLoader . class . getClassLoader ( ) . getResourceAsStream ( filename ) ; System . out . println ( is . toString ( ) ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; while ( true ) { String line ; try { line = reader . readLine ( ) ; if ( line == null ) { reader . close ( ) ; break ; } if ( ! line . startsWith ( "!" ) ) { lines . add ( line ) ; width = Math . max ( width , line . length ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; System . out . println ( e ) ; } } List < Tile > tiles = new ArrayList < Tile > ( ) ; for ( int j = 0 ; j < 12 ; j ++ ) { String line = lines . get ( j ) ; for ( int i = 0 ; i < width ; i ++ ) { if ( i < line . length ( ) ) { char ch = line . charAt ( i ) ; Tile t = new Tile ( i , j , Character . getNumericValue ( ch ) ) ; tiles . add ( t ) ; } } } return tiles ; }
te	1	@ Override public AttributeSet getAttributes ( ) { if ( refreshAttributes ) { attributes = createAttributes ( ) ; refreshAttributes = false ; refreshProperties = false ; } return attributes ; }
te	5	public void add ( Object element ) { int freeIndex = - 1 ; for ( int i = 0 ; i < set . length ; ++ i ) { if ( null == set [ i ] ) { freeIndex = i ; } else if ( set [ i ] . equals ( element ) ) { return ; } } if ( - 1 == freeIndex ) { freeIndex = set . length ; set = Arrays . copyOf ( set , 2 * set . length ) ; } if ( 0 <= freeIndex ) { set [ freeIndex ] = element ; ++ occupied ; } }
te	1	public SWIGTYPE_p_std__mapT_std__string_std__string_t getThe_map ( ) { long cPtr = otapiJNI . StringMap_the_map_get ( swigCPtr , this ) ; return ( cPtr == 0 ) ? null : new SWIGTYPE_p_std__mapT_std__string_std__string_t ( cPtr , false ) ; }
te	3	@ Override public boolean equals ( Object obj ) { if ( ! super . equals ( obj ) ) return false ; if ( ! ( obj instanceof BlockNode ) ) return false ; BlockNode other = ( BlockNode ) obj ; if ( ! - . equals ( other . - ) ) return false ; return true ; }
te	8	public RightClickMenu ( ) { super ( ) ; JMenuItem addObject = new JMenuItem ( "add object" ) ; addObject . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent actionEvent ) { PipedReader pipedReader = new PipedReader ( ) ; ObjectTypeSelectorWindow getObjectType = new ObjectTypeSelectorWindow ( pipedReader ) ; int type = 0 ; try { type = pipedReader . read ( ) ; pipedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } switch ( type ) { case OfficeObject . OFFICE_OBJECT_PC : curRoom . addObject ( new PC ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_LAPTOP : curRoom . addObject ( new Laptop ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_PRINTER : curRoom . addObject ( new Printer ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_ROUTER : curRoom . addObject ( new Router ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_MONITOR : curRoom . addObject ( new Monitor ( ) ) ; break ; } parentComponent . repaint ( ) ; if ( curRoom != null || parentComponent != null ) { setLocation ( curRoom . getX ( ) + 300 , curRoom . getY ( ) + 300 ) ; setVisible ( false ) ; } else setVisible ( false ) ; } } ) ; add ( addObject ) ; }
te	3	void prVar ( Var v , int d ) { indent ( d ) ; if ( v instanceof SimpleVar ) prVar ( ( SimpleVar ) v , d ) ; else if ( v instanceof FieldVar ) prVar ( ( FieldVar ) v , d ) ; else if ( v instanceof SubscriptVar ) prVar ( ( SubscriptVar ) v , d ) ; else throw new Error ( "Print.prVar" ) ; }
te	9X	static boolean readMessage ( DynamicObjectInputStream ips ) { Message receive = null ; String date = null ; String name = "Client" ; String message = null ; Field [ ] fields ; Method [ ] methods ; class < ? > someClass ; try { Object fromServ = ips . readObject ( ) ; if ( fromServ instanceof Message ) receive = ( Message ) fromServ ; } catch ( IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; } date = new String ( sdf . format ( receive . getCreationTime ( ) , new StringBuffer ( ) , new FieldPosition ( 0 ) ) ) ; if ( receive instanceof NewMessageType ) { ips . addClass ( ( ( NewMessageType ) receive ) . getName ( ) , ( ( NewMessageType ) receive ) . getClassData ( ) ) ; message = new String ( "New class " + ( ( NewMessageType ) receive ) . getName ( ) + " loaded." ) ; System . out . println ( date + " [" + name + "] " + message ) ; } else { if ( receive instanceof RelayMessage ) { message = ( ( RelayMessage ) receive ) . getMessage ( ) ; name = ( ( RelayMessage ) receive ) . getFrom ( ) ; System . out . println ( date + " [" + name + "] " + message ) ; } else { if ( receive instanceof StatusMessage ) { message = ( ( StatusMessage ) receive ) . getMessage ( ) ; name = "Server" ; System . out . println ( date + " [" + name + "] " + message ) ; } else { someClass = receive . getClass ( ) ; fields = someClass . getDeclaredFields ( ) ; methods = someClass . getDeclaredMethods ( ) ; message = new String ( someClass . getSimpleName ( ) + ":" ) ; try { for ( int i = 0 ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; f . setAccessible ( true ) ; message = message . concat ( new String ( " " + f . getName ( ) + "(" + f . get ( receive ) . toString ( ) + ")" ) ) ; if ( i != fields . length - 1 ) { message = message . concat ( " " ) ; } } System . out . println ( date + " [" + name + "] " + message ) ; for ( Method m : methods ) { if ( m . getParameterTypes ( ) . length == 0 && m . isAnnotationPresent ( Execute . class ) ) { m . invoke ( receive ) ; } } } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } } date = message = null ; name = "Client" ; return true ; }
te	9X	public static Graph < Vertex , Edge > convert ( String name , String json ) { Graph < Vertex , Edge > result = new Graph < Vertex , Edge > ( Edge . class ) ; Gson gson = new Gson ( ) ; Wrapper data = gson . fromJson ( json , Wrapper . class ) ; for ( ChildShapes pools : data . childShapes ) { if ( pools . childShapes . size ( ) > 0 ) { createGraph ( result , pools . childShapes , TASK_LEVEL ) ; } else { if ( pools . stencil != null && pools . stencil . id != null && pools . stencil . id . contains ( "Flow" ) ) { for ( Outgoing out : pools . outgoing ) if ( result . vertexIDRef . containsKey ( out . resourceId ) ) { TreeMap < String , Vertex > pair = new TreeMap < String , Vertex > ( ) ; pair . put ( "trg" , result . vertexRef . get ( result . vertexIDRef . get ( out . resourceId ) ) ) ; edges . put ( pools . resourceId , pair ) ; } } } } for ( String key : vedges . keySet ( ) ) { for ( String s : vedges . get ( key ) ) { if ( edges . containsKey ( s ) ) { if ( result . vertexIDRef . containsKey ( key ) ) { edges . get ( s ) . put ( "src" , result . vertexRef . get ( result . vertexIDRef . get ( key ) ) ) ; } } } } for ( String key : edges . keySet ( ) ) { if ( edges . get ( key ) . containsKey ( "src" ) && edges . get ( key ) . containsKey ( "trg" ) ) { Edge e = new Edge ( edges . get ( key ) . get ( "src" ) , edges . get ( key ) . get ( "trg" ) ) ; result . addE ( e ) ; } else { } } return result ; }
te	8	public String convert ( String s , int numRows ) { if ( s . isEmpty ( ) ) { return "" ; } if ( s . length ( ) <= numRows ) { return s ; } if ( numRows == 1 ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; int nextJ = j + numRows + ( numRows - 2 ) ; int mid = nextJ - ( i + 1 ) - ( i - 1 ) ; if ( mid < s . length ( ) && mid > j && mid < nextJ ) { sb . append ( s . charAt ( mid ) ) ; } j = nextJ ; } } return sb . toString ( ) ; }
te	5	protected void reindexFacesAndVertices ( ) { for ( int i = 0 ; i < numPoints ; i ++ ) { pointBuffer [ i ] . index = - 1 ; } numFaces = 0 ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark != Face . VISIBLE ) { it . remove ( ) ; } else { markFaceVertices ( face , 0 ) ; numFaces ++ ; } } numVertices = 0 ; for ( int i = 0 ; i < numPoints ; i ++ ) { Vertex vtx = pointBuffer [ i ] ; if ( vtx . index == 0 ) { vertexPointIndices [ numVertices ] = i ; vtx . index = numVertices ++ ; } } }
te	1	public static ApplicationContext getContext ( ) { if ( applicationContext == null ) { applicationContext = new ApplicationContext ( ) ; } return applicationContext ; }
te	6	public static void polcoe ( final double [ ] x , final double [ ] y , final double [ ] cof ) { int k , j , i , n = x . length ; double phi , ff , b ; double [ ] s = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) s [ i ] = cof [ i ] = 0.0 ; s [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { for ( j = n - 1 - i ; j < n - 1 ; j ++ ) s [ j ] -= x [ i ] * s [ j + 1 ] ; s [ n - 1 ] -= x [ i ] ; } for ( j = 0 ; j < n ; j ++ ) { phi = n ; for ( k = n - 1 ; k > 0 ; k -- ) phi = k * s [ k ] + x [ j ] * phi ; ff = y [ j ] / phi ; b = 1.0 ; for ( k = n - 1 ; k >= 0 ; k -- ) { cof [ k ] += b * ff ; b = s [ k ] + x [ j ] * b ; } } }
te	9X	public static void dutchFlagSort ( int [ ] arr , int lowValue , int highValue ) { int i = 0 ; int j = arr . length - 1 ; int lP = 0 ; int hP = arr . length - 1 ; while ( i <= j ) { if ( arr [ i ] > highValue ) { if ( arr [ j ] < lowValue ) { swap ( arr , i , j ) ; i ++ ; j -- ; } else if ( arr [ j ] > lowValue ) { j -- ; } else { swap ( arr , hP , j ) ; j -- ; hP -- ; } } else if ( arr [ i ] < lowValue ) { i ++ ; } else { swap ( arr , i , lP ) ; lP ++ ; i ++ ; } } System . out . println ( "Before paritioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } int k = 0 ; while ( k < lP ) { swap ( arr , k , j ) ; k ++ ; j -- ; } k = arr . length - 1 ; while ( k > hP ) { swap ( arr , k , i ) ; k -- ; i ++ ; } System . out . println ( "After Partioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } }
te	2	public void addToKeyedDuration ( Measures measureId , int key , double value ) { if ( ! serverImpl . getProfilingStatus ( ) ) return ; Measure m = measuresMap . get ( measureId ) ; if ( m != null ) { synchronized ( m ) { MKAveragedMeasureArgs args = new MKAveragedMeasureArgs ( ) ; args . value = value ; args . key = key ; m . addObservation ( args ) ; } } }
te	9X	private void GUI1 ( ) { panel1 = new JPanel ( ) ; jtp . addTab ( "<html><body marginwidth=15 marginheight=15><b>Step 1:</b><br>Event Details</body></html>" , null , panel1 , "Manage the event details." ) ; panel1 . setLayout ( null ) ; JLabel lbl1_EventDetails = new JLabel ( "Event Details" ) ; lbl1_EventDetails . setFont ( new Font ( "Tahoma" , Font . BOLD , 16 ) ) ; lbl1_EventDetails . setBounds ( 10 , 10 , 126 , 30 ) ; panel1 . add ( lbl1_EventDetails ) ; JLabel lbl1_EventType = new JLabel ( "Event Type:" ) ; lbl1_EventType . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventType . setBounds ( 10 , 59 , 100 , 14 ) ; panel1 . add ( lbl1_EventType ) ; comboBox1_EventType = new JComboBox < String > ( ) ; comboBox1_EventType . setBounds ( 120 , 56 , 195 , 20 ) ; panel1 . add ( comboBox1_EventType ) ; comboBox1_EventType . addItem ( "Select Event Type..." ) ; comboBox1_EventType . addItem ( "Anniversary" ) ; comboBox1_EventType . addItem ( "Award Ceremony" ) ; comboBox1_EventType . addItem ( "Birthday Party" ) ; comboBox1_EventType . addItem ( "Dinner and Dance" ) ; comboBox1_EventType . addItem ( "Festive Party" ) ; comboBox1_EventType . addItem ( "Seminar" ) ; comboBox1_EventType . addItem ( "Social Event" ) ; comboBox1_EventType . addItem ( "Talk / Speech" ) ; comboBox1_EventType . addItem ( "Wedding" ) ; comboBox1_EventType . addItem ( "Workshop" ) ; comboBox1_EventType . addActionListener ( new ComboBox1_EventType_Listener ( ) ) ; JLabel lbl1_EventName = new JLabel ( "Event Name:" ) ; lbl1_EventName . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventName . setBounds ( 10 , 100 , 100 , 14 ) ; panel1 . add ( lbl1_EventName ) ; textField1_EventName = new JTextField ( ) ; textField1_EventName . setBounds ( 120 , 97 , 435 , 20 ) ; panel1 . add ( textField1_EventName ) ; textField1_EventName . setColumns ( 10 ) ; textField1_EventName . addFocusListener ( this ) ; JLabel lbl1_EventDate = new JLabel ( "Start Date:" ) ; lbl1_EventDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventDate . setBounds ( 10 , 142 , 73 , 14 ) ; panel1 . add ( lbl1_EventDate ) ; dateChooser1_StartDate = new JDateChooser ( ) ; dateChooser1_StartDate . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( dateChooser1_StartDate . getDate ( ) != null ) { Date StartDate = dateChooser1_StartDate . getDate ( ) ; lg . setEventStartDate ( StartDate ) ; if ( lg . checkDate ( ) == false ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "Start Date cannot " + "be after End Date!" , "Start Date Error" , JOptionPane . ERROR_MESSAGE ) ; dateChooser1_StartDate . setDate ( dateChooser1_EndDate . getDate ( ) ) ; } else { if ( lg . getEventEndDate ( ) != null ) { lg . setDateList ( lg . getEventStartDate ( ) , lg . getEventEndDate ( ) ) ; lg . checkProgrammeDates ( ) ; updateStep3 ( ) ; } } } comboBox1_MealDates . removeActionListener ( comboBoxActionListener ) ; if ( ! lg . getDateList ( ) . isEmpty ( ) ) { comboBox1_MealDates . removeAllItems ( ) ; Iterator < String > itr = lg . getDateList ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { comboBox1_MealDates . addItem ( itr . next ( ) ) ; } } comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; enableMealRaidoButtons ( ) ; } } ) ; dateChooser1_StartDate . setBounds ( 120 , 142 , 117 , 20 ) ; panel1 . add ( dateChooser1_StartDate ) ; JLabel lbl1_StartTime = new JLabel ( "Start Time:" ) ; lbl1_StartTime . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTime . setBounds ( 264 , 142 , 68 , 14 ) ; panel1 . add ( lbl1_StartTime ) ; JLabel lbl1_StartTimeH = new JLabel ( "H" ) ; lbl1_StartTimeH . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTimeH . setBounds ( 342 , 142 , 14 , 14 ) ; panel1 . add ( lbl1_StartTimeH ) ; spinner1_StartTimeH = new JSpinner ( ) ; spinner1_StartTimeH . setModel ( new SpinnerNumberModel ( 0 , 0 , 23 , 1 ) ) ; spinner1_StartTimeH . setBounds ( 357 , 140 , 40 , 20 ) ; panel1 . add ( spinner1_StartTimeH ) ; spinner1_StartTimeH . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_StartTimeM = new JLabel ( "M" ) ; lbl1_StartTimeM . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTimeM . setBounds ( 401 , 143 , 14 , 14 ) ; panel1 . add ( lbl1_StartTimeM ) ; spinner1_StartTimeM = new JSpinner ( ) ; spinner1_StartTimeM . setModel ( new SpinnerNumberModel ( 0 , 0 , 59 , 1 ) ) ; spinner1_StartTimeM . setBounds ( 417 , 140 , 40 , 20 ) ; panel1 . add ( spinner1_StartTimeM ) ; spinner1_StartTimeM . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_EndDate = new JLabel ( "End Date:" ) ; lbl1_EndDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EndDate . setBounds ( 10 , 182 , 60 , 14 ) ; panel1 . add ( lbl1_EndDate ) ; dateChooser1_EndDate = new JDateChooser ( ) ; dateChooser1_EndDate . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( dateChooser1_EndDate . getDate ( ) != null ) { Date EndDate = dateChooser1_EndDate . getDate ( ) ; lg . setEventEndDate ( EndDate ) ; if ( lg . checkDate ( ) == false ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "End Date cannot " + "be before Start Date!" , "End Date Error" , JOptionPane . ERROR_MESSAGE ) ; dateChooser1_EndDate . setDate ( dateChooser1_StartDate . getDate ( ) ) ; } else { if ( lg . getEventStartDate ( ) != null ) { lg . setDateList ( lg . getEventStartDate ( ) , lg . getEventEndDate ( ) ) ; lg . checkProgrammeDates ( ) ; updateStep3 ( ) ; } } } comboBox1_MealDates . removeActionListener ( comboBoxActionListener ) ; if ( ! lg . getDateList ( ) . isEmpty ( ) ) { comboBox1_MealDates . removeAllItems ( ) ; Iterator < String > itr = lg . getDateList ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { comboBox1_MealDates . addItem ( itr . next ( ) ) ; } } comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; enableMealRaidoButtons ( ) ; } } ) ; dateChooser1_EndDate . setBounds ( 120 , 182 , 117 , 20 ) ; panel1 . add ( dateChooser1_EndDate ) ; JLabel lbl1_EndTime = new JLabel ( "End Time:" ) ; lbl1_EndTime . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EndTime . setBounds ( 264 , 183 , 60 , 14 ) ; panel1 . add ( lbl1_EndTime ) ; JLabel label1_EndTimeH = new JLabel ( "H" ) ; label1_EndTimeH . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; label1_EndTimeH . setBounds ( 342 , 184 , 14 , 14 ) ; panel1 . add ( label1_EndTimeH ) ; spinner1_EndTimeH = new JSpinner ( ) ; spinner1_EndTimeH . setModel ( new SpinnerNumberModel ( 0 , 0 , 23 , 1 ) ) ; spinner1_EndTimeH . setBounds ( 357 , 182 , 40 , 20 ) ; panel1 . add ( spinner1_EndTimeH ) ; spinner1_EndTimeH . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel label1_EndTimeM = new JLabel ( "M" ) ; label1_EndTimeM . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; label1_EndTimeM . setBounds ( 401 , 185 , 14 , 14 ) ; panel1 . add ( label1_EndTimeM ) ; spinner1_EndTimeM = new JSpinner ( ) ; spinner1_EndTimeM . setModel ( new SpinnerNumberModel ( 0 , 0 , 59 , 1 ) ) ; spinner1_EndTimeM . setBounds ( 417 , 182 , 40 , 20 ) ; panel1 . add ( spinner1_EndTimeM ) ; spinner1_EndTimeM . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_EventDescription = new JLabel ( "Event Description:" ) ; lbl1_EventDescription . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventDescription . setBounds ( 10 , 264 , 100 , 14 ) ; panel1 . add ( lbl1_EventDescription ) ; JScrollPane scrollPane1 = new JScrollPane ( ) ; scrollPane1 . setBounds ( 120 , 260 , 435 , 171 ) ; panel1 . add ( scrollPane1 ) ; textArea1_EventDescription = new JTextArea ( ) ; scrollPane1 . setViewportView ( textArea1_EventDescription ) ; textArea1_EventDescription . setDragEnabled ( true ) ; textArea1_EventDescription . setLineWrap ( true ) ; textArea1_EventDescription . setWrapStyleWord ( true ) ; textArea1_EventDescription . addFocusListener ( this ) ; JLabel lbl1_Budget = new JLabel ( "Budget:          $" ) ; lbl1_Budget . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; lbl1_Budget . setBounds ( 10 , 451 , 100 , 14 ) ; panel1 . add ( lbl1_Budget ) ; textField1_budget = new JTextField ( ) ; textField1_budget . setToolTipText ( "" ) ; textField1_budget . setColumns ( 10 ) ; textField1_budget . setBounds ( 120 , 449 , 117 , 20 ) ; panel1 . add ( textField1_budget ) ; textField1_budget . addFocusListener ( this ) ; JButton btn1_Next = new JButton ( "Next" ) ; btn1_Next . addMouseListener ( this ) ; btn1_Next . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; btn1_Next . setBounds ( 560 , 490 , 80 , 30 ) ; panel1 . add ( btn1_Next ) ; JLabel lbl1_MealDate = new JLabel ( "Meal Date:" ) ; lbl1_MealDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_MealDate . setBounds ( 10 , 224 , 70 , 14 ) ; panel1 . add ( lbl1_MealDate ) ; comboBox1_MealDates = new JComboBox < String > ( ) ; comboBox1_MealDates . setBounds ( 120 , 222 , 117 , 20 ) ; panel1 . add ( comboBox1_MealDates ) ; comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; JLabel lbl1_MealType = new JLabel ( "Meal Type:" ) ; lbl1_MealType . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_MealType . setBounds ( 264 , 224 , 68 , 14 ) ; panel1 . add ( lbl1_MealType ) ; rdbtn1_Lunch = new JRadioButton ( "Lunch" ) ; rdbtn1_Lunch . setEnabled ( false ) ; lg . setMealRadioButtons ( 0 , false ) ; rdbtn1_Lunch . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { lg . setMealType ( 0 ) ; } } ) ; buttonGroup1 . add ( rdbtn1_Lunch ) ; rdbtn1_Lunch . setBounds ( 342 , 221 , 55 , 23 ) ; panel1 . add ( rdbtn1_Lunch ) ; rdbtn1_Dinner = new JRadioButton ( "Dinner" ) ; rdbtn1_Dinner . setEnabled ( false ) ; lg . setMealRadioButtons ( 1 , false ) ; rdbtn1_Dinner . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { lg . setMealType ( 1 ) ; } } ) ; buttonGroup1 . add ( rdbtn1_Dinner ) ; rdbtn1_Dinner . setBounds ( 417 , 221 , 60 , 23 ) ; panel1 . add ( rdbtn1_Dinner ) ; }
te	8	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<LabelStyle" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isScaleDirty ) { change += "<scale>" + this . scale + "</scale>\n" ; this . isScaleDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</LabelStyle>\n" ; } setNotDirty ( ) ; return change ; }
te	5	public static void sort ( int [ ] a ) { int N = a . length ; int h = 1 ; while ( h < N / 3 ) h = 3 * h + 1 ; while ( h >= 1 ) { for ( int i = h ; i < N ; i ++ ) { for ( int j = i ; j >= h && less ( a [ j ] , a [ j - h ] ) ; j -= h ) { exchange ( a , j , j - h ) ; } } assert isHsorted ( a , h ) ; h /= 3 ; } assert isSorted ( a ) ; }
te	0	@ AfterClass public static void tearDownClass ( ) throws Exception { }
te	7	public static List < String > getPermutations2 ( String str ) { if ( str == null || str . isEmpty ( ) ) { return new ArrayList < > ( ) ; } List < String > permutations = new ArrayList < > ( ) ; if ( str . length ( ) == 1 ) { permutations . add ( str ) ; return permutations ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; String shorterString = str . substring ( 0 , i ) + ( ( i != str . length ( ) - 1 ) ? str . substring ( i + 1 , str . length ( ) ) : "" ) ; List < String > shorterPermutations = getPermutations2 ( shorterString ) ; for ( String s : shorterPermutations ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { permutations . add ( s . substring ( 0 , j ) + c + s . substring ( j , s . length ( ) ) ) ; } } } return permutations ; }
te	6	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; while ( true ) { System . out . print ( "Choose a map (1 2 3) or 0 to quit (4 at your own risk): " ) ; int which = input . nextInt ( ) ; MMap . MapSet map = MMap . MapSet . MAP1 ; switch ( which ) { case 1 : map = MMap . MapSet . MAP1 ; break ; case 2 : map = MMap . MapSet . MAP2 ; break ; case 3 : map = MMap . MapSet . MAP3 ; break ; case 4 : map = MMap . MapSet . MAP4 ; break ; default : System . out . println ( "bailing!" ) ; System . exit ( 1 ) ; } System . out . println ( "solving this map:" ) ; SenselessSolver rs = new SenselessSolver ( new MMap ( map ) ) ; for ( int i = 0 ; i < rs . map . gridSize ; i ++ ) { System . out . println ( rs . map . current_map [ i ] ) ; } rs . Solve ( ) ; } }
te	0	public NoDetallado ( String p ) { this . setPais ( p ) ; }
te	4	public void clearMap ( GameAction gameAction ) { for ( int i = 0 ; i < keyActions . length ; i ++ ) { if ( keyActions [ i ] == gameAction ) { keyActions [ i ] = null ; } } for ( int i = 0 ; i < mouseActions . length ; i ++ ) { if ( mouseActions [ i ] == gameAction ) { mouseActions [ i ] = null ; } } gameAction . reset ( ) ; }
te	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
te	0	public OutputFormatterStyle ( String foreground , String background , Collection < String > options ) { this ( foreground , background , options . toArray ( new String [ 0 ] ) ) ; }
te	0	@ Override public void reset ( ) { graphics = img . getGraphics ( ) ; graphics . setColor ( Color . RED ) ; graphics . fillRect ( 0 , 0 , width , height ) ; }
te	3	public void add ( long tmpID , double tmpPrice , int tmpVol , Time tmpTime ) { OneData tmpData = new OneData ( tmpID , tmpPrice , tmpVol , tmpTime ) ; int len = getLength ( ) ; int indexInsert = 0 ; if ( len > 1 ) { indexInsert = getPosToInsert ( tmpPrice , 0 , len - 1 ) ; } else if ( len == 1 ) { if ( tmpPrice >= myList . get ( 0 ) . getPrice ( ) ) { indexInsert = 1 ; } } myList . add ( indexInsert , tmpData ) ; allID . add ( indexInsert , tmpID ) ; }
te	1	public static String getFile ( File file ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; StringBuilder sb = new StringBuilder ( ) ; char [ ] buffer = new char [ 1024 ] ; int len = 0 ; while ( ( len = reader . read ( buffer ) ) != - 1 ) { sb . append ( buffer , 0 , len ) ; } reader . close ( ) ; return sb . toString ( ) ; }
te	6	@ SuppressWarnings ( "unchecked" ) private Map < OrderPreviewField , String > getMarketPreviewOrderPaths ( Document doc ) throws UtilityException { Map < OrderPreviewField , String > toReturn = new HashMap < OrderPreviewField , String > ( ) ; for ( OrderPreviewField f : OrderPreviewField . values ( ) ) { String path = f . getPath ( ) ; if ( f . equals ( OrderPreviewField . ERROR ) ) { if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; throw new UtilityException ( url ) ; } } } if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; toReturn . put ( f , url ) ; } } } return toReturn ; }
te	3	public void stateChanged ( ChangeEvent arg0 ) { JSpinner spinner = ( JSpinner ) arg0 . getSource ( ) ; if ( ! loading && ( spinner . equals ( heightSpinner ) || spinner . equals ( widthSpinner ) ) ) { board = new Board ( ( ( Integer ) widthSpinner . getValue ( ) ) . intValue ( ) , ( ( Integer ) heightSpinner . getValue ( ) ) . intValue ( ) ) ; boardPanel . setBoard ( board , true ) ; System . out . println ( "Changed size" ) ; this . getParent ( ) . repaint ( ) ; this . repaint ( ) ; } }
te	2	@ Override public V get ( K key ) { if ( key == null ) { throw new IllegalArgumentException ( ) ; } int index = index ( key ) ; return table [ index ] == null ? null : table [ index ] . get ( key ) ; }
