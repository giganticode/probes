tr	4	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	1	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	5	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	7	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	1	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	5	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	4	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	1	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	9X	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	2	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	4	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	3	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	9X	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	2	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	3	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	5	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	7	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	2	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	3	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	6	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	6	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	4	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	7	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	4	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	8	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	7	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	3	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	6	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	8	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	1	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	1	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	3	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	7	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	2	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	1	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	8	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	8	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	4	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	9X	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	5	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	6	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	7	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	5	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	3	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	2	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
tr	6	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
va	8	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
va	2	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
va	7	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
va	9X	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
va	6	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
va	4	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
va	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
va	4	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
va	2	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
va	7	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
va	6	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
va	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
va	1	public void isiOperan2 ( double x ) { op2 = x ; }
va	3	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
va	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
va	5	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
va	3	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
va	5	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
va	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
va	8	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
te	4	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
te	5	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
te	6	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
te	1	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
te	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
te	3	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
te	9X	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
te	4	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
te	7	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
te	7	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
te	9X	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
te	5	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
te	3	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
te	2	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
te	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
te	8	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
te	2	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
te	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
te	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } tring data = tring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
te	1	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
