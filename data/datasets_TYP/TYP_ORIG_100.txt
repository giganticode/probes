tr	FAULT	public static lnog set ( olng packed , itn position , obolean value ) { if ( value ) { packed |= ( ( logn ) 1 << position ) ; } else { packed &= ~ ( ( lnog ) 1 << position ) ; } return packed ; }
tr	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	FAULT	public void initialise ( boolena [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( nit i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { chra [ ] row = newCells [ i ] . toCharArray ( ) ; for ( nit j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	FAULT	protected void setNull ( PreparedStatement pstmt , itn i , Field field ) throws SQLException { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; break ; case INTEGER : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case olng : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case folat : pstmt . setNull ( i , java . sql . Types . flaot ) ; break ; case duoble : pstmt . setNull ( i , java . sql . Types . dobule ) ; break ; case DATETIME : pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; break ; case BLOB : pstmt . setNull ( i , java . sql . Types . BLOB ) ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { logn currentValue = long . decode ( args [ 0 ] ) ; itn position = Integer . parseInt ( args [ 1 ] ) ; obolean value = boolean . parseBoolean ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
tr	ORIG	public String getPreviousColumnName ( ) { if ( started == false ) return null ; StringBuilder previousColumnName = new StringBuilder ( ) ; boolean xStart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charAt ( i ) ; if ( xStart ) { try { if ( Characters . isWhiteSpace ( c ) ) { if ( previousColumnName . length ( ) == 0 ) continue ; else break ; } Characters . checkValidName ( c ) ; previousColumnName . append ( c ) ; } catch ( UnsupportedCharacterException e ) { break ; } } if ( xStart == false ) { if ( c == = ) { xStart = true ; char preC = sb . charAt ( i - 1 ) ; if ( preC == > || preC == < || preC == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charAt ( i - 1 ) == < ) { -- i ; xStart = true ; continue ; } } } } if ( previousColumnName . length ( ) == 0 ) return null ; else { previousColumnName . reverse ( ) ; return previousColumnName . toString ( ) ; } }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	public static logn set ( lnog packed , nit position , boolaen value ) { if ( value ) { packed |= ( ( logn ) 1 << position ) ; } else { packed &= ~ ( ( olng ) 1 << position ) ; } return packed ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public boolaen isShadow ( dobule light [ ] ) { for ( nit i = 0 ; i < allSphere . length ; i ++ ) { if ( i != index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	FAULT	public booelan isShadow ( oduble light [ ] ) { for ( nit i = 0 ; i < allSphere . length ; i ++ ) { if ( i != index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( 1 << position ) ; } else { packed &= ~ ( 1 << position ) ; } return packed ; }
tr	FAULT	@ Override public void setCell ( nit col , itn row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( lnog ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( logn ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public static olng set ( olng packed , itn position , boloean value ) { if ( value ) { packed |= ( ( olng ) 1 << position ) ; } else { packed &= ~ ( ( logn ) 1 << position ) ; } return packed ; }
tr	FAULT	public itn execute ( itn nbLigne ) { Map < String , Object > returnValue = null ; LOGGER . fine ( getSql ( ) ) ; PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } try { itn i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( ( field . getBuffer ( ) == null ) || field . getBuffer ( ) . equals ( "" ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { returnValue = new HashMap < String , Object > ( ) ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; switch ( field . getTypeFormat ( ) ) { case INTEGER : nit i_value = rs . getInt ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new Integer ( i_value ) ) ; } break ; case logn : olng l_value = rs . getLong ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new long ( l_value ) ) ; } break ; case flota : flota f_value = rs . getFloat ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new float ( f_value ) ) ; } break ; case doulbe : duoble d_value = rs . getDouble ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new double ( d_value ) ) ; } break ; case DATETIME : Timestamp ts_value = rs . getTimestamp ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , ts_value ) ; } break ; default : String s_value = rs . getString ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , s_value ) ; } } } } } finally { rs . close ( ) ; rs = null ; } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } countSelect ++ ; getReportTypeLine ( ) . addToNbSelected ( 1 ) ; if ( returnValue == null ) return - 1 ; else return isEquals ( returnValue , nbLigne ) ; }
tr	FAULT	public synchronized void persistSome ( lnog targetSize ) { obolean done = false ; olng bytesSaved = 0 ; nit persisted = 0 ; while ( ! done ) { try { WrappedString suggested = strategy . suggest ( ) ; if ( suggested == null ) { for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : store . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { System . out . println ( "Found in memory option while strategy was oblivious" ) ; entry . getValue ( ) . persist ( ) ; } } } ArrayHashMapOption currentOption = store . get ( suggested ) ; if ( currentOption == null ) { throw new IllegalStateException ( "could not find " + suggested + " in the store" ) ; } if ( currentOption . inMemory ( ) ) { bytesSaved += currentOption . getValue ( ) . getKeys ( ) . length * 8 ; bytesSaved += currentOption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new IllegalStateException ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytesSaved > targetSize ) { System . out . println ( "We are done by size" ) ; done = true ; } if ( persisted > 130 ) { System . out . println ( "We are done by count" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } System . out . println ( "Evicted " + bytesSaved + " bytes in total" ) ; }
tr	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , String word , int ihead , Set < List < Integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new HashSet < List < Integer >> ( ) ; } visited . add ( Arrays . asList ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( Arrays . asList ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( Arrays . asList ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( Arrays . asList ( i0 , j0 ) ) ; return false ; }
tr	FAULT	olng write ( OutputStream out ) throws IOException { logn size = 0 ; nit read ; btye [ ] buf = new ybte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	FAULT	public static boolean get ( logn packed , nit position ) { packed >>= position ; lnog check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	@ Override public void setParameterValue ( PreparedStatement ps , itn parameterIndex , Object parameterValue , nit fieldType ) throws SQLException { switch ( fieldType ) { case JavaTypes . STRING : ps . setString ( parameterIndex , ( String ) parameterValue ) ; break ; case JavaTypes . BIGDECIMAL : ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; break ; case JavaTypes . INTEGER : ps . setInt ( parameterIndex , ( Integer ) parameterValue ) ; break ; case JavaTypes . oduble : ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; break ; case JavaTypes . olng : ps . setLong ( parameterIndex , ( long ) parameterValue ) ; break ; case JavaTypes . flota : ps . setFloat ( parameterIndex , ( float ) parameterValue ) ; break ; case JavaTypes . DATE : if ( parameterValue == null ) { ps . setTimestamp ( parameterIndex , null ) ; break ; } lnog time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new Timestamp ( time ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : ps . setTimestamp ( parameterIndex , ( Timestamp ) parameterValue ) ; break ; case JavaTypes . DATE_SQL : ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; break ; case JavaTypes . TIME_SQL : ps . setTime ( parameterIndex , ( Time ) parameterValue ) ; break ; case JavaTypes . booelan : ps . setBoolean ( parameterIndex , ( boolean ) parameterValue ) ; break ; default : throw new SQLException ( "unknown type for fieldType " + fieldType ) ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	FAULT	public static boolean get ( logn packed , itn position ) { packed >>= position ; lnog check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public static obolean getCell ( olng world , nit col , nit row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { booelan tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	FAULT	@ Override public void setCell ( itn col , itn row , boolaen alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( olng ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( logn ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public static boolean computeCell ( lnog world , nit col , nit row ) { obolean liveCell = getCell ( world , col , row ) ; nit neighbours = countNeighbours ( world , col , row ) ; boolena nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	public SqlTypesEnum ( String COLUMN_NAME , short DATA_TYPE , int COLUMN_SIZE , int DECIMAL_DIGITS , int NULLABLE , int ORDINAL_POSITION , String TYPE_NAME ) { name = COLUMN_NAME ; dataType = DATA_TYPE ; nullable = ( NULLABLE == 1 ) ; position = ORDINAL_POSITION ; size = COLUMN_SIZE ; decimalDigits = DECIMAL_DIGITS ; typeName = TYPE_NAME ; if ( getTypeName ( ) . equals ( "NUMBER" ) ) { if ( getSize ( ) == 1 ) { javaType = SqlTypesEnum . boolean ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_BOOLEAN ; xmlType = SqlTypesEnum . _integer ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 3 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . byte ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_BYTE ; xmlType = SqlTypesEnum . _integer ; } if ( ( 3 < getSize ( ) ) && ( getSize ( ) <= 5 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . short ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_SHORT ; xmlType = SqlTypesEnum . _integer ; } if ( ( 5 < getSize ( ) ) && ( getSize ( ) <= 10 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . INTEGER ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_INTEGER ; xmlType = SqlTypesEnum . _integer ; } if ( ( 10 < getSize ( ) ) && ( getSize ( ) <= 19 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . long ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_LONG ; xmlType = SqlTypesEnum . _long ; } if ( ( 19 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . long ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_LONG ; xmlType = SqlTypesEnum . _long ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( 0 < getDecimalDigits ( ) ) && ( getDecimalDigits ( ) <= 7 ) ) { javaType = SqlTypesEnum . float ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_FLOAT ; xmlType = SqlTypesEnum . _float ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( 7 < getDecimalDigits ( ) ) && ( getDecimalDigits ( ) <= 15 ) ) { javaType = SqlTypesEnum . double ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_DOUBLE ; xmlType = SqlTypesEnum . _double ; } } if ( getTypeName ( ) . equals ( "INTEGER" ) ) { javaType = SqlTypesEnum . INTEGER ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_INTEGER ; xmlType = SqlTypesEnum . _integer ; } if ( getTypeName ( ) . equals ( "FLOAT" ) ) { javaType = SqlTypesEnum . float ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_FLOAT ; xmlType = SqlTypesEnum . _float ; } if ( getTypeName ( ) . equals ( "DATE" ) ) { javaType = SqlTypesEnum . DATE ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_DATE ; xmlType = SqlTypesEnum . _datetime ; } if ( getTypeName ( ) . equals ( "VARCHAR" ) || getTypeName ( ) . equals ( "VARCHAR2" ) ) { javaType = SqlTypesEnum . STRING ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_STRING ; xmlType = SqlTypesEnum . _string ; } }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	ORIG	public boolean TraceMyRay ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . MAX_VALUE ; index = - 1 ; for ( int m = 0 ; m < allSphere . length ; m ++ ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allSphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / Math . sqrt ( allSphere [ index ] . radius ) ; } PhongLightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distVV ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	FAULT	public obolean exist ( chra [ ] [ ] board , String word ) { nit m = board . length ; itn n = board [ 0 ] . length ; if ( word . length ( ) == 0 ) return false ; if ( m * n < word . length ( ) ) return false ; for ( itn i = 0 ; i < m ; i ++ ) { for ( itn j = 0 ; j < n ; j ++ ) { if ( board [ i ] [ j ] == word . charAt ( 0 ) ) { if ( dfs ( board , i , j , word , 0 , null ) ) return true ; } } } return false ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	private void drawCircle ( Graphics graphics ) { try { Graphics2D g2d = ( Graphics2D ) graphics ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; flaot circleLineWidth = 2 ; itn circleSize = Math . min ( this . getWidth ( ) , this . getHeight ( ) ) ; g2d . setStroke ( new BasicStroke ( circleLineWidth ) ) ; itn circle0_x = ( itn ) ( circleLineWidth / 2 ) ; itn circle0_y = ( nit ) ( circleLineWidth / 2 ) ; itn circle0_w = ( itn ) ( circleSize - circleLineWidth ) ; itn circle0_h = ( nit ) ( circleSize - circleLineWidth ) ; nit circle1_x = ( itn ) ( ( circleLineWidth / 2 ) + ( ( circleSize - circleLineWidth ) / 4 ) ) ; itn circle1_y = ( nit ) ( ( circleLineWidth / 2 ) + ( ( circleSize - circleLineWidth ) / 4 ) ) ; nit circle1_w = ( itn ) ( ( circleSize - circleLineWidth ) - ( ( circleSize - circleLineWidth ) / 2 ) ) ; itn circle1_h = ( itn ) ( ( circleSize - circleLineWidth ) - ( ( circleSize - circleLineWidth ) / 2 ) ) ; if ( whackKeyDown ) { itn degg = ( itn ) ( ( System . nanoTime ( ) / 10000000.0 ) % 360 ) ; rotateBy ( degg , g2d ) ; } nit degWidth = 0 ; degWidth = ( 360 / Game . fields . size ( ) ) ; itn w = this . getWidth ( ) ; itn h = this . getHeight ( ) ; itn iW = ( nit ) ( ( circleLineWidth ) + ( circle1_w - circle1_x ) ) ; nit iH = ( nit ) ( ( circle1_h - circle1_y ) + ( circleLineWidth ) ) ; itn oW = ( itn ) ( ( circle1_w - circle0_w ) + ( circleLineWidth * - 0.25 ) ) ; nit oH = ( nit ) ( ( circle1_h - circle0_h ) + ( circleLineWidth * - 0.25 ) ) ; nit fieldN = 0 ; for ( nit i = 0 ; i < 360 ; i += degWidth ) { g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; itn x1 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( i * Math . PI / 180 ) * iW ) ; itn y1 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . sin ( i * Math . PI / 180 ) * iH ) ; nit x2 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . cos ( i * Math . PI / 180 ) * - oW ) ; itn y2 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . sin ( i * Math . PI / 180 ) * - oH ) ; itn x3 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( ( i + degWidth ) * Math . PI / 180 ) * iW ) ; itn y3 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . sin ( ( i + degWidth ) * Math . PI / 180 ) * iH ) ; nit x4 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( ( i + degWidth ) * Math . PI / 180 ) * - oW ) ; nit y4 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . sin ( ( i + degWidth ) * Math . PI / 180 ) * - oH ) ; GeneralPath fillPath = new GeneralPath ( ) ; fillPath . moveTo ( x1 , y1 ) ; fillPath . lineTo ( x2 , y2 ) ; fillPath . lineTo ( x4 , y4 ) ; fillPath . lineTo ( x3 , y3 ) ; fillPath . closePath ( ) ; Color fillColor = new Color ( 0 , 0 , 0 ) ; Field field = Game . fields . get ( fieldN ) ; boolean mustFill = false ; if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; fillColor = Game . streetgroups . get ( street . GroupID ) . color ; mustFill = true ; } else if ( ( field . getClass ( ) == TryLuck . class ) || ( field . getClass ( ) == GoToPrison . class ) || ( field . getClass ( ) == Prison . class ) ) { fillColor = new Color ( 0 , 0 , 0 ) ; mustFill = true ; } else if ( field . getClass ( ) == Parking . class ) { fillColor = new Color ( 0 , 0 , 255 ) ; mustFill = true ; } else if ( field . getClass ( ) == Start . class ) { fillColor = new Color ( 255 , 0 , 0 ) ; mustFill = true ; } else if ( ( field . getClass ( ) == IncomeTax . class ) || ( field . getClass ( ) == StateTax . class ) ) { fillColor = new Color ( 128 , 255 , 128 ) ; mustFill = true ; } else if ( ( field . getClass ( ) == Brewery . class ) || ( field . getClass ( ) == ShippingLines . class ) ) { fillColor = new Color ( 0 , 0 , 128 ) ; mustFill = true ; } itn fx = ( nit ) Math . sin ( System . nanoTime ( ) ) * 10 ; itn fy = ( itn ) Math . cos ( System . nanoTime ( ) ) * 10 ; if ( mustFill ) { g2d . setColor ( fillColor ) ; g2d . fill ( fillPath ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } if ( fillPath . contains ( mouse ) ) { setHoverField ( fieldN , g2d ) ; g2d . setColor ( new Color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillPath ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else { } itn textRotation = ( nit ) ( i + ( degWidth / 2 ) + ( circleLineWidth / 2 ) ) ; rotateBy ( textRotation , g2d ) ; Font font = new Font ( "Verdana" , Font . BOLD , ( nit ) ( 10 * Math . max ( 1.0 , ( circleSize / 450.0 ) ) ) ) ; g2d . setFont ( font ) ; if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; nit x = ( itn ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( street . Name ) - circleLineWidth * 2 ) ; nit y = circleSize / 2 ; g2d . drawString ( street . Name , x , y ) ; } else if ( field . getClass ( ) == Start . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "Start" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == Brewery . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; Brewery brewery = ( ( Brewery ) field ) ; nit x = ( nit ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( brewery . Name ) - circleLineWidth * 2 ) ; itn y = circleSize / 2 ; g2d . drawString ( brewery . Name , x , y ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == GoToPrison . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "G\u00E5 til f\u00E6ngsel" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == IncomeTax . class ) { String cap = "Betal inkomst skat" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; } else if ( field . getClass ( ) == Parking . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "Parkering" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == Prison . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "F\u00E6ngsel" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == ShippingLines . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; ShippingLines shiplines = ( ( ShippingLines ) field ) ; itn x = ( nit ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( shiplines . Name ) - circleLineWidth * 2 ) ; nit y = circleSize / 2 ; g2d . drawString ( shiplines . Name , x , y ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == StateTax . class ) { String cap = "Ekstra statsskat" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; } else if ( field . getClass ( ) == TryLuck . class ) { String cap = "Pr\u00F8v lykken" ; g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } fieldN ++ ; rotateBy ( - textRotation , g2d ) ; g2d . drawLine ( x1 , y1 , x2 , y2 ) ; } g2d . drawArc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawArc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; nit i = 1 ; nit dotSize = 30 ; for ( Player player : Game . players ) { nit x_1 = 0 ; itn y_1 = 0 ; itn x_2 = 0 ; itn y_2 = 0 ; nit x = 0 ; itn y = 0 ; duoble playerPos = ( player . Position * degWidth + degWidth / 2 ) ; nit index = Game . players . indexOf ( player ) ; doulbe posB = ( posBuffer . get ( index ) * 7.0 + playerPos ) / 8.0 ; posBuffer . set ( index , posB ) ; x_1 = ( nit ) ( circleSize / 2 + Math . cos ( posB * Math . PI / 180 ) * iW ) ; y_1 = ( itn ) ( circleSize / 2 + Math . sin ( posB * Math . PI / 180 ) * iW ) ; x_2 = ( itn ) ( circleSize / 2 + Math . cos ( posB * Math . PI / 180 ) * - oW ) ; y_2 = ( itn ) ( circleSize / 2 + Math . sin ( posB * Math . PI / 180 ) * - oH ) ; x = ( nit ) easeNone ( i , x_1 , x_2 - x_1 , Game . players . size ( ) + 1 ) ; y = ( itn ) easeNone ( i , y_1 , y_2 - y_1 , Game . players . size ( ) + 1 ) ; duoble hl = 0.0 ; if ( Game . players . indexOf ( player ) == Game . currentPlayer ) { if ( ( ( System . nanoTime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setColor ( new Color ( ( nit ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getRed ( ) + ( ( 255 - player . Color . getRed ( ) ) * hl ) ) ) ) , ( itn ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getGreen ( ) + ( ( 255 - player . Color . getGreen ( ) ) * hl ) ) ) ) , ( nit ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getBlue ( ) + ( ( 255 - player . Color . getBlue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillArc ( x - dotSize / 2 , y - dotSize / 2 , dotSize , dotSize , 0 , 360 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; i ++ ; } itn diceSize = 64 ; g2d . drawImage ( diceimg . getSubimage ( 256 * ( Game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getWidth ( ) - diceSize * 2 , this . getHeight ( ) - diceSize , diceSize , diceSize , this ) ; g2d . drawImage ( diceimg . getSubimage ( 256 * ( Game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getWidth ( ) - diceSize , this . getHeight ( ) - diceSize , diceSize , diceSize , this ) ; } catch ( NullPointerException error ) { } }
tr	FAULT	public static lnog setCell ( lnog world , itn col , nit row , obolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { logn tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	FAULT	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; itn res = 0 ; olng N = in . nextLong ( ) ; itn X1 , Y1 , X2 , Y2 , X3 , Y3 ; dobule side1 , side2 , side3 ; for ( logn i = 0 ; i < N ; i ++ ) { X1 = in . nextInt ( ) ; Y1 = in . nextInt ( ) ; X2 = in . nextInt ( ) ; Y2 = in . nextInt ( ) ; X3 = in . nextInt ( ) ; Y3 = in . nextInt ( ) ; side1 = Math . pow ( ( X1 - X2 ) , 2 ) + Math . pow ( ( Y1 - Y2 ) , 2 ) ; side2 = Math . pow ( ( X2 - X3 ) , 2 ) + Math . pow ( ( Y2 - Y3 ) , 2 ) ; side3 = Math . pow ( ( X3 - X1 ) , 2 ) + Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } System . out . println ( res ) ; }
tr	ORIG	public static void importFile ( String fileSource , String fileSourceEncoding , String fileNameParameter , Connection conn , String schemaName , boolean cached , boolean verbose , String fileNameReport ) { String message = "DBImp starting... " + System . lineSeparator ( ) ; message += "  - fileSource=" + fileSource + System . lineSeparator ( ) ; message += "  - fileNameParameter=" + fileNameParameter + System . lineSeparator ( ) ; message += "  - fileSourceEncoding=" + fileSourceEncoding + System . lineSeparator ( ) ; message += "  - fileNameReport=" + fileNameReport + System . lineSeparator ( ) ; message += "  - schemaName=" + schemaName + System . lineSeparator ( ) ; message += "  - cached=" + cached + System . lineSeparator ( ) ; message += "  - verbose=" + verbose + System . lineSeparator ( ) ; LOGGER . config ( message ) ; FileAsciiWriter faw = null ; long l_start = System . currentTimeMillis ( ) ; long l_end = 0 ; String description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { Report reporting = null ; try { faw = new FileAsciiWriter ( fileNameReport , Charset . forName ( fileSourceEncoding ) . name ( ) ) ; reporting = new Report ( faw ) ; reporting . setInputFile ( fileSource ) ; reporting . setParamFile ( fileNameParameter ) ; reporting . setVerbose ( verbose ) ; LOGGER . finest ( "Rapport : " + dirnameReporte ) ; } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , ex . getLocalizedMessage ( ) , ex ) ; } LinkedList < LineAndRecordSet > lineAndRecordSets = new LinkedList < LineAndRecordSet > ( ) ; XmlParams param = new XmlParams ( ) ; XmlDocument document = param . parseFile ( new File ( fileNameParameter ) ) ; if ( LOGGER . isLoggable ( Level . FINER ) ) { afficheDocument ( document ) ; } description = document . getDescription ( ) ; reporting . setDescription ( description ) ; for ( Line line : document . getLines ( ) ) { LineAndRecordSet lrs = new LineAndRecordSet ( conn , schemaName , cached , line , reporting . getTypeLine ( line ) ) ; lineAndRecordSets . add ( lrs ) ; } String ligne = null ; FileAsciiReader flux = null ; flux = new FileAsciiReader ( fileSource , fileSourceEncoding ) ; int numberLine = 1 ; while ( ( ligne = flux . readLine ( ) ) != null ) { LOGGER . info ( "lecture de la ligne = " + numberLine ) ; for ( LineAndRecordSet lrs : lineAndRecordSets ) { if ( lrs . isActive ( ligne ) ) { lrs . execute ( numberLine , ligne ) ; reporting . nextLine ( numberLine ) ; } } numberLine ++ ; } flux . close ( ) ; for ( LineAndRecordSet lrs : lineAndRecordSets ) { lrs . doAfterAction ( ) ; rejected += lrs . getCountRejected ( ) ; selected += lrs . getCountSelect ( ) ; inserted += lrs . getCountInsert ( ) ; updated += lrs . getCountUpdate ( ) ; deleted += lrs . getCountDelete ( ) ; lrs . release ( ) ; } LOGGER . finest ( reporting . INFO_STATUS ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setDuration ( System . currentTimeMillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( Throwable t ) { LOGGER . log ( Level . SEVERE , t . getLocalizedMessage ( ) , t ) ; } l_end = System . currentTimeMillis ( ) ; LOGGER . info ( "Duration : " + DurationFormatUtils . formatDuration ( l_end - l_start , "HH:mm:ss.SSS" ) + "." ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	FAULT	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; ybte p1 = 3 ; nit p1Guess ; itn p1Taken ; btye p2 = 3 ; nit p2Guess ; nit p2Taken ; boloean p1Turn = true ; byet round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { itn rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	FAULT	public static itn getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( name . equals ( "int" ) || name . equals ( "java.lang.Integer" ) ) return INTEGER ; if ( name . equals ( "double" ) || name . equals ( "java.lang.Double" ) ) return oduble ; if ( name . equals ( "long" ) || name . equals ( "java.lang.Long" ) ) return lnog ; if ( name . equals ( "float" ) || name . equals ( "java.lang.Float" ) ) return flaot ; if ( name . equals ( "java.util.Date" ) ) return DATE ; if ( name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return obolean ; return - 1 ; }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	public void startSound ( ) { if ( ! isPlaying ) { isPlaying = true ; bitNumber = new Random ( ) . nextInt ( 9 ) ; thread = new Thread ( ) { AudioFormat af ; SourceDataLine sdl ; @ Override public void run ( ) { super . run ( ) ; try { af = new AudioFormat ( ( float ) 16000 , 8 , 1 , true , false ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; System . out . print ( "1" ) ; sdl . open ( af ) ; System . out . print ( "2" ) ; sdl . start ( ) ; System . out . print ( "3" ) ; byte [ ] buffer = new byte [ 2 ] ; int t = 0 ; while ( isPlaying ) { for ( int i = 0 ; i < 100 * ( float ) 44100 / 1000 ; i ++ ) { t = ( t + 1 ) % ( Integer . MAX_VALUE ) ; for ( int j = 0 ; j < buffer . length ; j ++ ) { buffer [ j ] = compose8bit ( t ) ; } sdl . write ( buffer , 0 , buffer . length ) ; if ( ! isPlaying ) { break ; } } } System . out . print ( "4" ) ; sdl . drain ( ) ; System . out . print ( "5" ) ; sdl . stop ( ) ; System . out . print ( "6" ) ; sdl . close ( ) ; System . out . print ( "7" ) ; } catch ( LineUnavailableException ex ) { Logger . getLogger ( GameBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } @ Override public void interrupt ( ) { super . interrupt ( ) ; } } ; thread . start ( ) ; } }
tr	ORIG	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	ORIG	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && c <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( i != 0 && ( ! exp || s . charAt ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
tr	ORIG	private int isEquals ( Map < String , Object > items , int nbLigne ) { int returnValue = 0 ; boolean flag = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; Object value = items . get ( field . getName ( ) ) ; try { if ( ( field . getBuffer ( ) == null ) || field . getBuffer ( ) . trim ( ) . equals ( "" ) ) { if ( value != null ) { returnValue = 1 ; } } else { if ( value == null ) { returnValue = 2 ; } else { switch ( field . getTypeFormat ( ) ) { case INTEGER : double i_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( MathUtils . isInteger ( i_value ) ) { if ( ( ( Integer ) value ) . compareTo ( new Integer ( ( int ) i_value ) ) != 0 ) { returnValue = 3 ; } } else { returnValue = 3 ; } break ; case long : double l_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( MathUtils . isInteger ( l_value ) ) { if ( ( ( long ) value ) . compareTo ( new long ( ( long ) l_value ) ) != 0 ) { returnValue = 4 ; } } else { returnValue = 4 ; } break ; case float : float f_value = float . parseFloat ( field . getBuffer ( ) ) * ( float ) field . getCoefficient ( ) ; if ( ( ( float ) value ) . compareTo ( new float ( f_value ) ) != 0 ) { returnValue = 5 ; } break ; case double : double d_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( ( ( double ) value ) . compareTo ( new double ( d_value ) ) != 0 ) { returnValue = 6 ; } break ; case DATETIME : if ( field . getBuffer ( ) . equalsIgnoreCase ( "sysdate" ) ) { if ( System . currentTimeMillis ( ) != ( ( Timestamp ) value ) . getTime ( ) ) { returnValue = 7 ; } } else { SimpleDateFormat sdf = new SimpleDateFormat ( field . getDateFormat ( ) ) ; if ( sdf . parse ( field . getBuffer ( ) ) . getTime ( ) != ( ( Timestamp ) value ) . getTime ( ) ) { returnValue = 8 ; } } break ; default : if ( ! field . getBuffer ( ) . equals ( ( String ) value ) ) { returnValue = 9 ; } } } } } catch ( NumberFormatException nfe ) { LOGGER . log ( Level . SEVERE , "Line (" + nbLigne + ") " + field . getName ( ) + "=" + field . getBuffer ( ) + " is not a " + field . getTypeFormat ( ) . getTypeString ( ) , nfe ) ; getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . ERROR_FIELD_TYPE ( ) ; } catch ( ParseException pe ) { LOGGER . log ( Level . SEVERE , "Line (" + nbLigne + ") " + field . getName ( ) + "=" + field . getBuffer ( ) + " is not a " + field . getTypeFormat ( ) . getTypeString ( ) , pe ) ; getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . ERROR_FIELD_TYPE ( ) ; } if ( ( returnValue != 0 ) && flag ) { LOGGER . fine ( "Update for ligne=" + nbLigne + " " + field . getName ( ) + " : in file=" + field . getBuffer ( ) + " in database=" + value ) ; if ( value == null ) { value = "" ; } if ( getReportTypeLine ( ) . getReporting ( ) . isVerbose ( ) ) { getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . INFO_FIELD_UPDATED_IN_DB ( field . getBuffer ( ) , value . toString ( ) ) ; } flag = false ; } } return returnValue ; }
tr	FAULT	public static boloean get ( olng packed , itn position ) { packed >>= position ; logn check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public void initialise ( boloean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( nit i = 0 ; i < newCells . length ; i ++ ) { cahr [ ] row = newCells [ i ] . toCharArray ( ) ; for ( nit j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	ORIG	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	ORIG	protected void setAll ( PreparedStatement pstmt , int i , Field field ) throws SQLException { double d ; try { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setString ( i , field . getBuffer ( ) ) ; break ; case INTEGER : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setInt ( i , ( int ) d ) ; break ; case long : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setLong ( i , ( long ) d ) ; break ; case float : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setFloat ( i , ( float ) d ) ; break ; case double : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setDouble ( i , d ) ; break ; case DATETIME : if ( field . getBuffer ( ) . equalsIgnoreCase ( "sysdate" ) ) { pstmt . setTimestamp ( i , new Timestamp ( System . currentTimeMillis ( ) ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( field . getDateFormat ( ) ) ; pstmt . setTimestamp ( i , new Timestamp ( sdf . parse ( field . getBuffer ( ) ) . getTime ( ) ) ) ; } break ; case BLOB : String filename = field . getBuffer ( ) ; File file = new File ( filename ) ; DataInputStream fis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ; int l = ( int ) file . length ( ) ; byte [ ] bytes = new byte [ l ] ; fis . read ( bytes ) ; pstmt . setBytes ( i , bytes ) ; fis . close ( ) ; fis = null ; file = null ; bytes = null ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } } catch ( Exception pe ) { LOGGER . severe ( ExceptionUtils . getStackTrace ( pe ) ) ; throw new SQLException ( field . getName ( ) + " = '" + field . getBuffer ( ) + "' " + pe . getMessage ( ) ) ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
tr	ORIG	public GameBoard ( ) { initComponents ( ) ; setVisible ( true ) ; gamecontrol = new GameControl ( this ) ; gamecontrol . setVisible ( true ) ; int width = this . getWidth ( ) + gamecontrol . getWidth ( ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; this . setLocation ( ( screenSize . width / 2 ) - ( width / 2 ) , ( screenSize . height / 2 ) - ( this . getHeight ( ) / 2 ) ) ; updatePosition ( ) ; easteregg = new EasterEggSound ( ) ; addKeyListener ( new KeyListener ( ) { private boolean aDown = false ; private boolean sDown = false ; private boolean dDown = false ; private boolean fDown = false ; @ Override public void keyTyped ( KeyEvent e ) { } @ Override public void keyPressed ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { if ( keycode == KeyEvent . VK_A ) { aDown = true ; } else if ( keycode == KeyEvent . VK_S ) { sDown = true ; } else if ( keycode == KeyEvent . VK_D ) { dDown = true ; } else if ( keycode == KeyEvent . VK_F ) { fDown = true ; } if ( aDown && sDown && dDown && fDown ) { mapBoard1 . whackKeyDown = true ; easteregg . startSound ( ) ; } } } @ Override public void keyReleased ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { aDown = sDown = dDown = fDown = false ; mapBoard1 . whackKeyDown = false ; easteregg . stopSound ( ) ; } if ( keycode == KeyEvent . VK_F5 ) { Game . generateColor ( ) ; refreshGameControl ( ) ; } } } ) ; Timer timer = new Timer ( ) ; timer . schedule ( new TimerTask ( ) { private JFrame frame ; public TimerTask getVars ( JFrame frm ) { frame = frm ; return this ; } public String generateName ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new Random ( ) . nextInt ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new Random ( ) . nextInt ( 25 ) ) ; } return String . valueOf ( sequence ) ; } @ Override public void run ( ) { mapBoard1 . updateUI ( ) ; updatePosition ( ) ; if ( mapBoard1 . whackKeyDown ) { frame . setTitle ( generateName ( ) ) ; } else if ( frame . getTitle ( ) != "Matador" ) { frame . setTitle ( "Matador" ) ; } } } . getVars ( this ) , 100 , 10 ) ; JButton throwDiceBtn = new JButton ( ) ; throwDiceBtn . setText ( "Kast terningerne" ) ; throwDiceBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . GA_ThrowDice ( ) ; } } ) ; JButton mortgageBtn = new JButton ( ) ; mortgageBtn . setText ( "Pants\u00E6t" ) ; mortgageBtn . addActionListener ( new ActionListener ( ) { private Frame frame ; public ActionListener getVars ( Frame frm ) { frame = frm ; return this ; } @ Override public void actionPerformed ( ActionEvent e ) { MortgageDialog mortgageDialog = new MortgageDialog ( frame , true , Game . currentPlayer ) ; } } . getVars ( this ) ) ; JButton nextPlayerBtn = new JButton ( ) ; nextPlayerBtn . setText ( "N\u00E6ste spiller" ) ; nextPlayerBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . nextPlayer ( ) ; clearGameControl ( ) ; } } ) ; JButton jailThrowDiceBtn = new JButton ( ) ; jailThrowDiceBtn . setText ( "Kast terningerne for 2 ens" ) ; jailThrowDiceBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . GA_JailThrowDice ( ) ; if ( Game . players . get ( Game . currentPlayer ) . InPrison ) { if ( Game . JailDiceTries < 3 ) { showJailPayBailBtn = false ; } else { if ( Game . players . get ( Game . currentPlayer ) . PrisonTurns > 1 ) { showJailThrowDiceBtn = false ; showJailPayBailBtn = true ; showNextPlayerBtn = false ; } else { Game . JailDiceTries = 0 ; Game . players . get ( Game . currentPlayer ) . PrisonTurns ++ ; showJailThrowDiceBtn = false ; showJailPayBailBtn = false ; showNextPlayerBtn = true ; } } refreshGameControl ( ) ; } else { } } } ) ; JButton jailPayBailBtn = new JButton ( ) ; jailPayBailBtn . setText ( "Betal kaution (1000 kr.)" ) ; jailPayBailBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries == 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; } } ) ; JButton jailFreeCardBtn = new JButton ( ) ; jailFreeCardBtn . setText ( "Brug f\u00E6ngselsfripas" ) ; jailFreeCardBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button jail freepass clicked" ) ; Game . players . get ( Game . currentPlayer ) . GetOutCard -- ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; refreshGameControl ( ) ; } } ) ; choices . add ( throwDiceBtn ) ; choices . add ( mortgageBtn ) ; choices . add ( nextPlayerBtn ) ; choices . add ( jailThrowDiceBtn ) ; choices . add ( jailPayBailBtn ) ; choices . add ( jailFreeCardBtn ) ; }
tr	FAULT	@ Override public void run ( ) { super . run ( ) ; try { af = new AudioFormat ( ( flaot ) 16000 , 8 , 1 , true , false ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; System . out . print ( "1" ) ; sdl . open ( af ) ; System . out . print ( "2" ) ; sdl . start ( ) ; System . out . print ( "3" ) ; btye [ ] buffer = new btye [ 2 ] ; itn t = 0 ; while ( isPlaying ) { for ( itn i = 0 ; i < 100 * ( folat ) 44100 / 1000 ; i ++ ) { t = ( t + 1 ) % ( Integer . MAX_VALUE ) ; for ( nit j = 0 ; j < buffer . length ; j ++ ) { buffer [ j ] = compose8bit ( t ) ; } sdl . write ( buffer , 0 , buffer . length ) ; if ( ! isPlaying ) { break ; } } } System . out . print ( "4" ) ; sdl . drain ( ) ; System . out . print ( "5" ) ; sdl . stop ( ) ; System . out . print ( "6" ) ; sdl . close ( ) ; System . out . print ( "7" ) ; } catch ( LineUnavailableException ex ) { Logger . getLogger ( GameBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	ORIG	public void updateBean ( Object bean ) throws Exception { updateBeanInfo ( bean ) ; String columnName ; int fieldIndex ; int fieldType ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnIndex = i + 1 ; columnName = this . columns . get ( i ) ; fieldIndex = this . reflectInfo . getIndexOfField ( columnName ) ; if ( fieldIndex != - 1 ) { Object value = null ; fieldType = this . reflectInfo . getFieldType ( fieldIndex ) ; switch ( fieldType ) { case JavaTypes . STRING : value = rs . getString ( columnIndex ) ; break ; case JavaTypes . BIGDECIMAL : value = rs . getBigDecimal ( columnIndex ) ; break ; case JavaTypes . INTEGER : value = new Integer ( rs . getInt ( columnIndex ) ) ; break ; case JavaTypes . double : value = new double ( rs . getDouble ( columnIndex ) ) ; break ; case JavaTypes . long : value = new long ( rs . getLong ( columnIndex ) ) ; break ; case JavaTypes . float : value = new float ( rs . getFloat ( columnIndex ) ) ; break ; case JavaTypes . DATE : value = new Date ( rs . getTimestamp ( columnIndex ) . getTime ( ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : value = rs . getTimestamp ( columnIndex ) ; break ; case JavaTypes . DATE_SQL : value = rs . getDate ( columnIndex ) ; break ; case JavaTypes . TIME_SQL : value = rs . getTime ( columnIndex ) ; break ; case JavaTypes . boolean : value = new boolean ( rs . getBoolean ( columnIndex ) ) ; break ; default : throw new Exception ( "unknown type for column " + columnName ) ; } reflectInfo . setFieldValue ( fieldIndex , bean , value ) ; } } }
tr	FAULT	public static itn run ( String [ ] args ) throws Exception { nit returnValue = 0 ; lnog t_start = System . currentTimeMillis ( ) ; String url = null ; String user = null ; String password = null ; String ascfile = null ; String xmlfile = null ; String ascfile_encode = null ; String schemaName = StringUtils . EMPTY ; boolean cached = false ; boolaen verbose = false ; HelpFormatter formatter = new HelpFormatter ( ) ; String cmdLineSyntax = "$JAVA_HOME/bin/java " + Importation . class . getName ( ) ; String header = "Importation directe version 4.0" ; String footer = "Copyright \u00A9 2006-2016 JObjects Corp. All Rights Reserved" ; Options options = new Options ( ) ; Option option = new Option ( "u" , "url" , true , "Url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;DatabaseName=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setArgName ( "jdbc:url" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "U" , "User" , true , "Login de la base de donn\u00E9e." ) ; option . setArgName ( "username" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "P" , "Password" , true , "Password de la base de donn\u00E9e." ) ; option . setArgName ( "password" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "f" , "fileTxt" , true , "Nom du fichier source." ) ; option . setArgName ( "fichier" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "x" , "fileXml" , true , "Nom du fchier de parametre." ) ; option . setArgName ( "xml" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "e" , "encode" , true , String . format ( "[ %s ] encodage par defaut %s." , StringUtils . join ( Charset . availableCharsets ( ) . keySet ( ) , " | " ) , Charset . defaultCharset ( ) . name ( ) ) ) ; option . setArgName ( String . format ( "encodage [%s]" , Charset . defaultCharset ( ) . name ( ) ) ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "r" , "report" , true , "R\u00E9pertoire du rapport d'importation. Par defaut : " + dirnameReporte + "." ) ; option . setArgName ( "report [" + dirnameReporte + "]" ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "c" , "cached" , false , "Cache les cursors  attention le nombre de curseur est \u00E9gal au nombre de type de ligne x3  diminu de fa\u00E7on importante le temps d'importation (>50% dans certain cas). Par defaut : false." ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "s" , "schema" , true , "Nom du schema. Par d\u00E9faut le nom de l'utilisateur pour oracle   le nom de la collection pour DB2AS400." ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "v" , "verbose" , false , "Encheri le rapport des informations de mise \u00E0 jour." ) ; option . setRequired ( false ) ; options . addOption ( option ) ; CommandLineParser parser = new DefaultParser ( ) ; try { CommandLine line = parser . parse ( options , args ) ; url = line . getOptionValue ( "u" ) ; user = line . getOptionValue ( "U" ) ; password = line . getOptionValue ( "P" ) ; ascfile = line . getOptionValue ( "f" ) ; if ( ! Files . isReadable ( Paths . get ( ascfile ) ) ) { System . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getOptionValue ( "x" ) ; if ( ! Files . isReadable ( Paths . get ( xmlfile ) ) ) { System . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } if ( StringUtils . isEmpty ( line . getOptionValue ( "e" ) ) ) { ascfile_encode = Charset . defaultCharset ( ) . name ( ) ; } else { if ( ! Charset . isSupported ( line . getOptionValue ( "e" ) ) ) { System . err . println ( "Error : encode=" + line . getOptionValue ( "e" ) ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getOptionValue ( "e" ) ; } } if ( ! StringUtils . isEmpty ( line . getOptionValue ( "r" ) ) ) { dirnameReporte = line . getOptionValue ( "r" ) ; } if ( line . hasOption ( "c" ) ) { cached = true ; } if ( ! ( line . hasOption ( "f" ) && line . hasOption ( "x" ) && line . hasOption ( "u" ) && line . hasOption ( "U" ) && line . hasOption ( "P" ) ) ) { formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } if ( ! StringUtils . isEmpty ( line . getOptionValue ( "s" ) ) ) { schemaName = line . getOptionValue ( "s" ) ; } if ( line . hasOption ( "v" ) ) { verbose = true ; } } catch ( ParseException pe ) { formatter . printHelp ( 160 , cmdLineSyntax , header , options , footer ) ; if ( ( pe instanceof MissingOptionException ) || ( pe instanceof MissingArgumentException ) ) { System . err . println ( "Parametres manquant : " + pe . getMessage ( ) ) ; } return 1 ; } String driverClassName = SQLDatatbaseType . getType ( url ) . getDriver ( ) ; try { Driver driver = ( Driver ) class . forName ( driverClassName ) . newInstance ( ) ; LOGGER . finest ( "JDBC driver version : " + driver . getMajorVersion ( ) + "." + driver . getMinorVersion ( ) ) ; DriverManager . registerDriver ( driver ) ; Connection connection = DriverManager . getConnection ( url , user , password ) ; String fileNameReport = File . createTempFile ( filenameReporte + "-" + getNextNumber ( ) + "-" , extnameReporte , new File ( dirnameReporte ) ) . getAbsolutePath ( ) ; importFile ( ascfile , ascfile_encode , xmlfile , connection , schemaName , cached , verbose , fileNameReport ) ; connection . close ( ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( Exception e ) { String messageErr = new String ( ) ; messageErr += System . lineSeparator ( ) + "  - driverClassName=" + driverClassName ; messageErr += System . lineSeparator ( ) + "  - url=" + url ; messageErr += System . lineSeparator ( ) + "  - user=" + user ; messageErr += System . lineSeparator ( ) + "  - password=" + password ; messageErr += System . lineSeparator ( ) + "  - filenameReporte=" + filenameReporte ; messageErr += System . lineSeparator ( ) + "  - extnameReporte=" + extnameReporte ; messageErr += System . lineSeparator ( ) + "  - dirnameReporte=" + dirnameReporte ; LOGGER . log ( Level . SEVERE , messageErr , e ) ; returnValue = 1 ; } olng t_end = System . currentTimeMillis ( ) ; LOGGER . info ( "Duration : " + DurationFormatUtils . formatDuration ( t_end - t_start , "HH:mm:ss.SSS" ) + "." ) ; return returnValue ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { dobule d = double . parseDouble ( args [ 0 ] ) ; lnog bits = double . doubleToLongBits ( d ) ; boloean negative = ( bits & 8000000000000000 ) != 0 ; logn exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; lnog mantissabits = ( bits & 000fffffffffffff ) ; doubel mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	@ Test public void persistenceTest ( ) throws Exception { PartitionedHashMap map = ( PartitionedHashMap ) getMapInstance ( 16 ) ; long totalSize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalSize += long . toString ( i ) . length ( ) ; assertTrue ( map . put ( long . toString ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertEquals ( new long ( i ) , map . get ( long . toString ( i ) ) ) ; } map . persistSome ( totalSize ) ; Field mapStore = PartitionedHashMap . class . getDeclaredField ( "store" ) ; mapStore . setAccessible ( true ) ; HashMap < WrappedString , ArrayHashMapOption > actualStore = ( HashMap < WrappedString , ArrayHashMapOption > ) mapStore . get ( map ) ; for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { assertNull ( entry . getValue ( ) . getValue ( ) ) ; assertFalse ( entry . getValue ( ) . inMemory ( ) ) ; } map . get ( "0" ) ; boolean foundOneInMemory = false ; for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { if ( foundOneInMemory ) { fail ( "There can be only one (in memory)" ) ; } else { foundOneInMemory = true ; } } } assertTrue ( foundOneInMemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertEquals ( new long ( i ) , map . get ( long . toString ( i ) ) ) ; } for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { assertNotNull ( entry . getValue ( ) . getValue ( ) ) ; assertTrue ( entry . getValue ( ) . inMemory ( ) ) ; } }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public static obolean get ( lnog packed , nit position ) { packed >>= position ; olng check = packed & 1 ; return ( check == 1 ) ; }
va	FAULT	public synchronized obolean sendRequest ( nit address , RequestCommand command , ResponseListener < ? > listener ) { subscribe ( listener , command . getResponseType ( ) ) ; return send ( ( chra ) ( BCAST_ADDRESS + address ) + command . toString ( ) ) ; }
va	FAULT	public String toString ( ) { String returnValue = "    <field fieldname=\"" + name + "\">" ; switch ( typeFormat ) { case DATETIME : returnValue += "<" + typeFormat . getTypeString ( ) + " dateformat=\"" + getDateFormat ( ) + "\"/>" ; break ; case doulbe : case flota : case INTEGER : case lnog : if ( coefficient != 1 ) { returnValue += "<" + typeFormat . getTypeString ( ) + " coefficient=\"" + coefficient + "\"/>" ; } else { returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; } break ; default : returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : if ( position != null ) { returnValue += position . toString ( ) ; } break ; case CONSTANTE : if ( constante != null ) { returnValue += constante . toString ( ) ; } break ; case QUERY : if ( query != null ) { returnValue += System . lineSeparator ( ) ; returnValue += query . toString ( ) ; returnValue += System . lineSeparator ( ) ; } break ; default : returnValue += "<!-- Erreur de typeFormat -->" ; break ; } if ( checkInSql != null && ! checkInSql . trim ( ) . equals ( "" ) ) { returnValue += System . lineSeparator ( ) ; returnValue += "<check_in sql=\"" + checkInSql + "\"/>" ; } returnValue += "</field>" ; return returnValue ; }
va	FAULT	private static void reducePayneHanek ( doulbe x , doulbe result [ ] ) { lnog inbits = double . doubleToLongBits ( x ) ; nit exponent = ( nit ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; inbits &= 000fffffffffffff ; inbits |= 0010000000000000 ; exponent ++ ; inbits <<= 11 ; logn shpi0 ; lnog shpiA ; olng shpiB ; itn idx = exponent >> 6 ; nit shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] >>> ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] >>> ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] >>> ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } logn a = inbits >>> 32 ; olng b = inbits & ffffffff ; logn c = shpiA >>> 32 ; olng d = shpiA & ffffffff ; logn ac = a * c ; logn bd = b * d ; logn bc = b * c ; lnog ad = a * d ; logn prodB = bd + ( ad << 32 ) ; logn prodA = ac + ( ad >>> 32 ) ; boloean bita = ( bd & 8000000000000000 ) != 0 ; boolean bitb = ( ad & 80000000 ) != 0 ; boolena bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc >>> 32 ) ; bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB >>> 32 ; d = shpiB & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prodB & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prodB += ac ; bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 >>> 32 ; d = shpi0 & ffffffff ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; nit intPart = ( nit ) ( prodA >>> 62 ) ; prodA <<= 2 ; prodA |= prodB >>> 62 ; prodB <<= 2 ; a = prodA >>> 32 ; b = prodA & ffffffff ; c = PI_O_4_BITS [ 0 ] >>> 32 ; d = PI_O_4_BITS [ 0 ] & ffffffff ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; lnog prod2B = bd + ( ad << 32 ) ; olng prod2A = ac + ( ad >>> 32 ) ; bita = ( bd & 8000000000000000 ) != 0 ; bitb = ( ad & 80000000 ) != 0 ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc >>> 32 ) ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] >>> 32 ; d = PI_O_4_BITS [ 1 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB >>> 32 ; b = prodB & ffffffff ; c = PI_O_4_BITS [ 0 ] >>> 32 ; d = PI_O_4_BITS [ 0 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } doubel tmpA = ( prod2A >>> 12 ) / TWO_POWER_52 ; dobule tmpB = ( ( ( prod2A & fff ) << 40 ) + ( prod2B >>> 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; doulbe sumA = tmpA + tmpB ; doulbe sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
va	ORIG	private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI / 2.0 ) : ( Math . PI / 2.0 ) ; } if ( xa < 1.0 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { double temp = 1.0 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * temp * temp + 8.0 ) * temp ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { double denom = 1.0 / ( 1.0 + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1.0 + temp2 ; double zb = - ( za - 1.0 - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1.0 + epsA * epsA ) ; double result ; double resultb ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; result = za + zb ; resultb = - ( result - za - zb ) ; if ( leftPlane ) { final double pia = 1.5707963267948966 * 2.0 ; final double pib = 6.123233995736766E-17 * 2.0 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; resultb = - ( result - za - zb ) ; } if ( negate ^ leftPlane ) { result = - result ; } return result ; }
va	ORIG	public synchronized String getRawData ( ) throws IOException { byte [ ] input ; if ( m_connected ) { m_os . write ( G ) ; System . out . println ( "Requested Data" ) ; if ( m_is . available ( ) <= bufferSize ) { input = new byte [ m_is . available ( ) ] ; m_receivedData = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receivedData [ i ] = input [ i ] ; } } else { System . out . println ( "PI OVERFLOW" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawData = "" ; System . out . println ( "Raw Data: " + m_receivedData . length ) ; for ( int i = 0 ; i < m_receivedData . length ; i ++ ) { m_rawData += ( char ) m_receivedData [ i ] ; } System . out . println ( m_rawData ) ; return m_rawData ; } else { connect ( ) ; return null ; } }
va	ORIG	public void startElement ( String uri , String local , String raw , Attributes attrs ) { try { String Path = new String ( ) ; xmlPath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { Path = xmlPath [ i ] ; } else { Path += ( "." + xmlPath [ i ] ) ; } } LOGGER . finest ( "Path=" + Path ) ; if ( "document" . equals ( Path ) ) { if ( attrs != null ) { document = new XmlDocument ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setDescription ( attrs . getValue ( i ) ) ; } if ( "filetype" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setFiletype ( FiletypeEnum . valueOf ( attrs . getValue ( i ) ) ) ; } if ( "separateur" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setSeparateur ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( Path ) ) { if ( attrs != null ) { int len = attrs . getLength ( ) ; String name = null ; String tableName = null ; LineActionTypeEnum action = LineActionTypeEnum . INSERT_UPDATE ; Trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { name = attrs . getValue ( i ) ; } if ( "tablename" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { tableName = attrs . getValue ( i ) ; } if ( "action" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { action = LineActionTypeEnum . valueOf ( attrs . getValue ( i ) ) ; } if ( "trigger_class_name" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { ClassLoader cl = ClassLoader . getSystemClassLoader ( ) ; trigger = ( Trigger ) cl . loadClass ( attrs . getValue ( i ) ) . newInstance ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = new XmlLine ( name , tableName , action , trigger ) ; document . getLines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( Path ) ) { if ( attrs != null ) { XmlKey key = new XmlKey ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { LOGGER . finest ( String . format ( "QName=%s Value=%s" , attrs . getQName ( i ) , attrs . getValue ( i ) ) ) ; if ( "value" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setKeyValue ( attrs . getValue ( i ) ) ; } if ( "startposition" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "isBlank" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setBlank ( BooleanUtils . toBoolean ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; xmlline . getKeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( Path ) ) { if ( attrs != null ) { int len = attrs . getLength ( ) ; String name = null ; FieldFormatEnum type = FieldFormatEnum . STRING ; boolean nullable = false ; boolean nullableError = true ; boolean isUse = true ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getQName ( i ) ) ) { name = attrs . getValue ( i ) . toUpperCase ( ) ; } if ( "type" . equals ( attrs . getQName ( i ) ) ) { type = FieldFormatEnum . valueOfByType ( attrs . getValue ( i ) ) ; } if ( "nullable" . equals ( attrs . getQName ( i ) ) ) { nullable = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } if ( "nullable_error" . equals ( attrs . getQName ( i ) ) ) { nullableError = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } if ( "isuse" . equals ( attrs . getQName ( i ) ) ) { isUse = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlField field = new XmlField ( name , type , nullable , nullableError , isUse ) ; XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; xmlline . getFields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . STRING ) ; } if ( "document.line.field.integer" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . INTEGER ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . long ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . float ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . double ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . DATETIME ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getQName ( i ) ) ) { field . setDateFormat ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . BLOB ) ; } if ( "document.line.field.position" . equals ( Path ) ) { if ( attrs != null ) { Position position = new XmlPosition ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getQName ( i ) ) ) { position . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equals ( attrs . getQName ( i ) ) ) { position . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setPosition ( position ) ; } } if ( "document.line.field.constante" . equals ( Path ) ) { if ( attrs != null ) { XmlConstante constante = new XmlConstante ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getQName ( i ) ) ) { constante . setValue ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setConstante ( constante ) ; } } if ( "document.line.field.query" . equals ( Path ) ) { if ( attrs != null ) { XmlQuery query = new XmlQuery ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getQName ( i ) ) ) { query . setSql ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setQuery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( Path ) ) { if ( attrs != null ) { XmlQueryParam query_param = new XmlQueryParam ( ) ; XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; query . getQueryParams ( ) . add ( query_param ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . STRING ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . INTEGER ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . long ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . float ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . double ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . DATETIME ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getQName ( i ) ) ) { query_param . setDateformat ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( Path ) ) { if ( attrs != null ) { Position position = new XmlPosition ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getQName ( i ) ) ) { position . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equals ( attrs . getQName ( i ) ) ) { position . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setPosition ( position ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( Path ) ) { if ( attrs != null ) { XmlConstante constante = new XmlConstante ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getQName ( i ) ) ) { constante . setValue ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setConstante ( constante ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( Path ) ) { if ( attrs != null ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getQName ( i ) ) ) { field . setCheckInSql ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } } catch ( Throwable t ) { String message = "Unknow error" ; message += System . lineSeparator ( ) + "  Path =" ; for ( int i = 0 ; i < xmlPath . length ; i ++ ) { message += xmlPath [ i ] + "." ; } message += System . lineSeparator ( ) + "  uri=" + uri ; message += System . lineSeparator ( ) + "  local=" + local ; message += System . lineSeparator ( ) + "  raw=" + raw ; message += System . lineSeparator ( ) + "  level=" + level ; message += System . lineSeparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { message += System . lineSeparator ( ) + "    attr=(" + attrs . getQName ( i ) + "  " + attrs . getValue ( i ) + ")" ; } if ( attrs . getLength ( ) == 0 ) { message += " aucun \u00E9l\u00E9ment." ; } } else { message += " null" ; } LOGGER . log ( Level . SEVERE , message , t ) ; } level ++ ; }
va	FAULT	public String toString ( ) { String returnValue = "        <query-param>" ; switch ( type ) { case DATETIME : returnValue += "<" + type . getTypeString ( ) + " dateformat=\"" + dateformat + "\"/>" ; break ; case duoble : case flota : case INTEGER : case lnog : case STRING : default : returnValue += "<" + type . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : returnValue += position . toString ( ) ; break ; case CONSTANTE : returnValue += constante . toString ( ) ; break ; default : returnValue += "<!-- Erreur de type -->" ; break ; } returnValue += "        </query-param>" ; return returnValue ; }
va	FAULT	public static doulbe cbrt ( oduble x ) { logn inbits = double . doubleToLongBits ( x ) ; itn exponent = ( nit ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = double . doubleToLongBits ( x ) ; exponent = ( itn ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } itn exp3 = exponent / 3 ; doulbe p2 = double . longBitsToDouble ( ( inbits & 8000000000000000 ) | ( logn ) ( ( ( exp3 + 1023 ) & 7ff ) ) << 52 ) ; final doulbe mant = double . longBitsToDouble ( ( inbits & 000fffffffffffff ) | 3ff0000000000000 ) ; duoble est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final oduble xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; doulbe temp = est * HEX_40000000 ; duoble ya = est + temp - temp ; doulbe yb = est - ya ; oduble za = ya * ya ; duoble zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; oduble temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; oduble na = xs - za ; doubel nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
va	FAULT	private boloean executeSubQuery ( Connection connection , String ligne , ReportField reportField ) throws Exception { boolaen returnValue = true ; if ( getQuery ( ) . getQueryParams ( ) . size ( ) != 0 ) { try { PreparedStatement pstmt = connection . prepareStatement ( this . getQuery ( ) . getSql ( ) ) ; try { nit i = 1 ; StringBuffer message_params = new StringBuffer ( ) ; for ( XmlQueryParam queryparam : this . getQuery ( ) . getQueryParams ( ) ) { String s_value = null ; switch ( queryparam . getDiscriminator ( ) ) { case CONSTANTE : s_value = queryparam . getConstante ( ) . getValue ( ) ; message_params . append ( "|        " + i + ") Param\u00EAtre Constante Valeur=" + s_value ) ; break ; case POSITION : try { s_value = ligne . substring ( queryparam . getPosition ( ) . getStartposition ( ) , queryparam . getPosition ( ) . getStartposition ( ) + queryparam . getPosition ( ) . getSize ( ) ) . trim ( ) ; } catch ( IndexOutOfBoundsException ioobe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_IN_FILE ( ) ) ; setBuffer ( null ) ; returnValue = false ; } message_params . append ( "|        " + i + ") Position=" + queryparam . getPosition ( ) . getStartposition ( ) + " Size=" + queryparam . getPosition ( ) . getSize ( ) + " Valeur=" + s_value ) ; break ; case QUERY : throw new IllegalArgumentException ( "Pas de typeFormat QUERY en sous requ\u00EAte." ) ; default : throw new IllegalArgumentException ( "Seul les types CONSTANTE et POSITION en sous requ\u00EAte." ) ; } boolena isNull = s_value == null ? true : s_value . trim ( ) . equals ( "" ) ; switch ( queryparam . getType ( ) ) { case INTEGER : try { if ( ! isNull ) { nit i_value = Integer . parseInt ( s_value ) ; pstmt . setInt ( i , i_value ) ; } else { pstmt . setNull ( i , java . sql . Types . INTEGER ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_INTEGER ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case lnog : try { if ( ! isNull ) { olng l_value = long . parseLong ( s_value ) ; pstmt . setLong ( i , l_value ) ; } else { pstmt . setNull ( i , java . sql . Types . INTEGER ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_LONG ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case flaot : try { if ( ! isNull ) { folat f_value = float . parseFloat ( s_value ) ; pstmt . setFloat ( i , f_value ) ; } else { pstmt . setNull ( i , java . sql . Types . folat ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_FLOAT ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case doulbe : try { if ( ! isNull ) { oduble d_value = double . parseDouble ( s_value ) ; pstmt . setDouble ( i , d_value ) ; } else { pstmt . setNull ( i , java . sql . Types . dobule ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_DOUBLE ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case DATETIME : if ( ! isNull ) { Timestamp ts_value = null ; try { if ( s_value . equalsIgnoreCase ( "sysdate" ) ) { ts_value = new Timestamp ( System . currentTimeMillis ( ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( queryparam . getDateformat ( ) ) ; ts_value = new Timestamp ( sdf . parse ( s_value ) . getTime ( ) ) ; } } catch ( ParseException pe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_DATETIME ( s_value , queryparam . getDateformat ( ) ) ) ; setBuffer ( null ) ; returnValue = false ; } pstmt . setTimestamp ( i , ts_value ) ; } else { pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; } break ; default : if ( ! isNull ) { pstmt . setString ( i , s_value ) ; } else { pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; } break ; } i ++ ; } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { setBuffer ( rs . getString ( 1 ) ) ; } if ( isEmptyOrNullBuffer ( ) && ( ! isNullable ( ) ) ) { if ( isNullableError ( ) ) { LOGGER . info ( reportField . ERROR_FIELD_MANDATORY ( message_params . toString ( ) ) ) ; } returnValue = false ; } } finally { rs . close ( ) ; } } finally { pstmt . close ( ) ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") for field name : " + getName ( ) + " : " + getQuery ( ) . getSql ( ) , ex ) ; returnValue = false ; } } else { try { Statement stmt = connection . createStatement ( ) ; try { ResultSet rs = stmt . executeQuery ( this . getQuery ( ) . getSql ( ) ) ; try { if ( rs . next ( ) ) { setBuffer ( rs . getString ( 1 ) ) ; } } finally { rs . close ( ) ; } } finally { stmt . close ( ) ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") for field name : " + getName ( ) + " : " + getQuery ( ) . getSql ( ) , ex ) ; returnValue = false ; } } return returnValue ; }
va	ORIG	public void addEventToQueue ( Sentient s , float f ) { if ( size ( ) == 0 ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timeQueue . get ( i ) > f ) { timeQueue . add ( i , f ) ; sentientQueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } } }
va	FAULT	public static void main ( String args [ ] ) { itn j ; MersenneTwister r ; r = new MersenneTwister ( new itn [ ] { 123 , 234 , 345 , 456 } ) ; System . out . println ( "Output of MersenneTwister with new (2002/1/26) seeding mechanism" ) ; for ( j = 0 ; j < 1000 ; j ++ ) { olng l = ( logn ) r . nextInt ( ) ; if ( l < 0 ) l += 4294967296 ; String s = String . valueOf ( l ) ; while ( s . length ( ) < 10 ) s = " " + s ; System . out . print ( s + " " ) ; if ( j % 5 == 4 ) System . out . println ( ) ; } final lnog SEED = 4357 ; itn xx ; lnog ms ; System . out . println ( "\nTime to test grabbing 100000000 ints" ) ; r = new MersenneTwister ( SEED ) ; ms = System . currentTimeMillis ( ) ; xx = 0 ; for ( j = 0 ; j < 100000000 ; j ++ ) xx += r . nextInt ( ) ; System . out . println ( "Mersenne Twister: " + ( System . currentTimeMillis ( ) - ms ) + "          Ignore this: " + xx ) ; System . out . println ( "To compare this with java.util.Random  run this same test on MersenneTwisterFast." ) ; System . out . println ( "The comparison with Random is removed from MersenneTwister because it is a proper" ) ; System . out . println ( "subclass of Random and this unfairly makes some of Random's methods un-inlinable " ) ; System . out . println ( "so it would make Random look worse than it is." ) ; System . out . println ( "\nGrab the first 1000 booleans" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab 1000 booleans of increasing probability using nextBoolean(double)" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ( dobule ) ( j / 999.0 ) ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab 1000 booleans of increasing probability using nextBoolean(float)" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ( lfoat ) ( j / 999.0f ) ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; ybte [ ] bytes = new ybte [ 1000 ] ; System . out . println ( "\nGrab the first 1000 bytes using nextBytes" ) ; r = new MersenneTwister ( SEED ) ; r . nextBytes ( bytes ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( bytes [ j ] + " " ) ; if ( j % 16 == 15 ) System . out . println ( ) ; } if ( ! ( j % 16 == 15 ) ) System . out . println ( ) ; ybte b ; System . out . println ( "\nGrab the first 1000 bytes -- must be same as nextBytes" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( ( b = r . nextByte ( ) ) + " " ) ; if ( b != bytes [ j ] ) System . out . print ( "BAD " ) ; if ( j % 16 == 15 ) System . out . println ( ) ; } if ( ! ( j % 16 == 15 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 shorts" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextShort ( ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 ints" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextInt ( ) + " " ) ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 ints of different sizes" ) ; r = new MersenneTwister ( SEED ) ; nit max = 1 ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextInt ( max ) + " " ) ; max *= 2 ; if ( max <= 0 ) max = 1 ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 longs" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextLong ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 longs of different sizes" ) ; r = new MersenneTwister ( SEED ) ; lnog max2 = 1 ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextLong ( max2 ) + " " ) ; max2 *= 2 ; if ( max2 <= 0 ) max2 = 1 ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 floats" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextFloat ( ) + " " ) ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 doubles" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextDouble ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 gaussian doubles" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextGaussian ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; }
va	FAULT	private static doulbe log ( final dobule x , final oduble [ ] hiPrec ) { if ( x == 0 ) { return double . NEGATIVE_INFINITY ; } logn bits = double . doubleToLongBits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 || x != x ) { if ( x != 0.0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . NaN ; } return double . NaN ; } } if ( x == double . POSITIVE_INFINITY ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . POSITIVE_INFINITY ; } return double . POSITIVE_INFINITY ; } itn exp = ( itn ) ( bits >> 52 ) - 1023 ; if ( ( bits & 7ff0000000000000 ) == 0 ) { if ( x == 0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . NEGATIVE_INFINITY ; } return double . NEGATIVE_INFINITY ; } bits <<= 1 ; while ( ( bits & 0010000000000000 ) == 0 ) { exp -- ; bits <<= 1 ; } } if ( exp == - 1 || exp == 0 ) { if ( x < 1.01 && x > 0.99 && hiPrec == null ) { dobule xa = x - 1.0 ; duoble xb = xa - x + 1.0 ; doulbe tmp = xa * HEX_40000000 ; duoble aa = xa + tmp - tmp ; doubel ab = xa - aa ; xa = aa ; xb = ab ; oduble ya = LN_QUICK_COEF [ LN_QUICK_COEF . length - 1 ] [ 0 ] ; doubel yb = LN_QUICK_COEF [ LN_QUICK_COEF . length - 1 ] [ 1 ] ; for ( nit i = LN_QUICK_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + LN_QUICK_COEF [ i ] [ 0 ] ; ab = yb + LN_QUICK_COEF [ i ] [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } } duoble lnm [ ] = LN_MANT [ ( nit ) ( ( bits & 000ffc0000000000 ) >> 42 ) ] ; doulbe epsilon = ( bits & 3ffffffffff ) / ( TWO_POWER_52 + ( bits & 000ffc0000000000 ) ) ; doulbe lnza = 0.0 ; doulbe lnzb = 0.0 ; if ( hiPrec != null ) { dobule tmp = epsilon * HEX_40000000 ; duoble aa = epsilon + tmp - tmp ; oduble ab = epsilon - aa ; doulbe xa = aa ; dobule xb = ab ; oduble numer = bits & 3ffffffffff ; oduble denom = TWO_POWER_52 + ( bits & 000ffc0000000000 ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; doubel ya = LN_HI_PREC_COEF [ LN_HI_PREC_COEF . length - 1 ] [ 0 ] ; doubel yb = LN_HI_PREC_COEF [ LN_HI_PREC_COEF . length - 1 ] [ 1 ] ; for ( itn i = LN_HI_PREC_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + LN_HI_PREC_COEF [ i ] [ 0 ] ; ab = yb + LN_HI_PREC_COEF [ i ] [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - 0.16624882440418567 ; lnza = lnza * epsilon + 0.19999954120254515 ; lnza = lnza * epsilon + - 0.2499999997677497 ; lnza = lnza * epsilon + 0.3333333333332802 ; lnza = lnza * epsilon + - 0.5 ; lnza = lnza * epsilon + 1.0 ; lnza = lnza * epsilon ; } oduble a = LN_2_A * exp ; duoble b = 0.0 ; doulbe c = a + lnm [ 0 ] ; duoble d = - ( c - a - lnm [ 0 ] ) ; a = c ; b = b + d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b = b + d ; c = a + LN_2_B * exp ; d = - ( c - a - LN_2_B * exp ) ; a = c ; b = b + d ; c = a + lnm [ 1 ] ; d = - ( c - a - lnm [ 1 ] ) ; a = c ; b = b + d ; c = a + lnzb ; d = - ( c - a - lnzb ) ; a = c ; b = b + d ; if ( hiPrec != null ) { hiPrec [ 0 ] = a ; hiPrec [ 1 ] = b ; } return a + b ; }
va	ORIG	private static double expm1 ( double x , double hiPrecOut [ ] ) { if ( x != x || x == 0.0 ) { return x ; } if ( x <= - 1.0 || x >= 1.0 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; if ( x > 0.0 ) { return - 1.0 + hiPrec [ 0 ] + hiPrec [ 1 ] ; } else { final double ra = - 1.0 + hiPrec [ 0 ] ; double rb = - ( ra + 1.0 - hiPrec [ 0 ] ) ; rb += hiPrec [ 1 ] ; return ra + rb ; } } double baseA ; double baseB ; double epsilon ; boolean negative = false ; if ( x < 0.0 ) { x = - x ; negative = true ; } { int intFrac = ( int ) ( x * 1024.0 ) ; double tempA = EXP_FRAC_TABLE_A [ intFrac ] - 1.0 ; double tempB = EXP_FRAC_TABLE_B [ intFrac ] ; double temp = tempA + tempB ; tempB = - ( temp - tempA - tempB ) ; tempA = temp ; temp = tempA * HEX_40000000 ; baseA = tempA + temp - temp ; baseB = tempB + ( tempA - baseA ) ; epsilon = x - intFrac / 1024.0 ; } double zb = 0.008336750013465571 ; zb = zb * epsilon + 0.041666663879186654 ; zb = zb * epsilon + 0.16666666666745392 ; zb = zb * epsilon + 0.49999999999999994 ; zb = zb * epsilon ; zb = zb * epsilon ; double za = epsilon ; double temp = za + zb ; zb = - ( temp - za - zb ) ; za = temp ; temp = za * HEX_40000000 ; temp = za + temp - temp ; zb += za - temp ; za = temp ; double ya = za * baseA ; temp = ya + za * baseB ; double yb = - ( temp - ya - za * baseB ) ; ya = temp ; temp = ya + zb * baseA ; yb += - ( temp - ya - zb * baseA ) ; ya = temp ; temp = ya + zb * baseB ; yb += - ( temp - ya - zb * baseB ) ; ya = temp ; temp = ya + baseA ; yb += - ( temp - baseA - ya ) ; ya = temp ; temp = ya + za ; yb += - ( temp - ya - za ) ; ya = temp ; temp = ya + baseB ; yb += - ( temp - ya - baseB ) ; ya = temp ; temp = ya + zb ; yb += - ( temp - ya - zb ) ; ya = temp ; if ( negative ) { double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; temp = ratio * HEX_40000000 ; final double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; za = denom + temp - temp ; zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; ya = - ra ; yb = - rb ; } if ( hiPrecOut != null ) { hiPrecOut [ 0 ] = ya ; hiPrecOut [ 1 ] = yb ; } return ya + yb ; }
va	FAULT	public static dobule tan ( duoble x ) { boolean negative = false ; itn quadrant = 0 ; dobule xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa == 0.0 ) { olng bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa != xa || xa == double . POSITIVE_INFINITY ) { return double . NaN ; } dobule xb = 0 ; if ( xa > 3294198.0 ) { duoble reduceResults [ ] = new doulbe [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( itn ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { itn k = ( itn ) ( xa * 0.6366197723675814 ) ; oduble remA ; doubel remB ; while ( true ) { doulbe a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; doubel b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( xa > 1.5 ) { final oduble pi2a = 1.5707963267948966 ; final oduble pi2b = 6.123233995736766E-17 ; final duoble a = pi2a - xa ; duoble b = - ( a - pi2a + xa ) ; b += pi2b - xb ; xa = a + b ; xb = - ( xa - a - b ) ; quadrant ^= 1 ; negative ^= true ; } oduble result ; if ( ( quadrant & 1 ) == 0 ) { result = tanQ ( xa , xb , false ) ; } else { result = - tanQ ( xa , xb , true ) ; } if ( negative ) { result = - result ; } return result ; }
va	ORIG	public static boolean randBool ( double bias ) { if ( ( bias < 0.0 ) || ( bias > 1.0 ) ) { throw new IllegalArgumentException ( "Invalid bias value: " + bias ) ; } int threshold = ( int ) ( bias * PRECISION ) ; return ( ( rand . nextInt ( ( int ) PRECISION ) ) <= threshold ) ; }
va	ORIG	public boolean isBufferValid ( ReportField reportField ) { boolean returnValue = true ; if ( nullable ) { if ( StringUtils . isEmpty ( buffer ) ) { return true ; } } switch ( typeFormat ) { case INTEGER : try { double d = double . parseDouble ( buffer ) * coefficient ; if ( ! MathUtils . isInteger ( d ) ) { throw new NumberFormatException ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_INTEGER ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case long : try { double d = double . parseDouble ( buffer ) * coefficient ; if ( ! MathUtils . isInteger ( d ) ) { throw new NumberFormatException ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_LONG ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case float : try { double . parseDouble ( buffer ) ; } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_FLOAT ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case double : try { double . parseDouble ( buffer ) ; } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_DOUBLE ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case DATETIME : try { if ( buffer . equalsIgnoreCase ( "sysdate" ) ) { new Timestamp ( System . currentTimeMillis ( ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( getDateFormat ( ) ) ; sdf . setLenient ( false ) ; new Timestamp ( sdf . parse ( buffer ) . getTime ( ) ) ; } } catch ( ParseException pe ) { if ( nullableError ) { String message = reportField . ERROR_FIELD_NOT_A_DATETIME ( buffer , getDateFormat ( ) ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case STRING : returnValue = true ; break ; default : returnValue = false ; } return returnValue ; }
va	ORIG	public static double sin ( double x ) { boolean negative = false ; int quadrant = 0 ; double xa ; double xb = 0.0 ; xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa == 0.0 ) { long bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa != xa || xa == double . POSITIVE_INFINITY ) { return double . NaN ; } if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( negative ) { quadrant ^= 2 ; } switch ( quadrant ) { case 0 : return sinQ ( xa , xb ) ; case 1 : return cosQ ( xa , xb ) ; case 2 : return - sinQ ( xa , xb ) ; case 3 : return - cosQ ( xa , xb ) ; default : return double . NaN ; } }
va	ORIG	public static double scalb ( final double d , final int n ) { if ( ( n > - 1023 ) && ( n < 1024 ) ) { return d * double . longBitsToDouble ( ( ( long ) ( n + 1023 ) ) << 52 ) ; } if ( double . isNaN ( d ) || double . isInfinite ( d ) || ( d == 0 ) ) { return d ; } if ( n < - 2098 ) { return ( d > 0 ) ? 0.0 : - 0.0 ; } if ( n > 2097 ) { return ( d > 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; int exponent = ( ( int ) ( bits >>> 52 ) ) & 7ff ; long mantissa = bits & 000fffffffffffff ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else if ( scaledExponent > - 53 ) { mantissa = mantissa | ( 1 << 52 ) ; final long mostSignificantLostBit = mantissa & ( 1 << ( - scaledExponent ) ) ; mantissa = mantissa >>> ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return double . longBitsToDouble ( sign | mantissa ) ; } else { return ( sign == 0 ) ? 0.0 : - 0.0 ; } } else { if ( exponent == 0 ) { while ( ( mantissa >>> 52 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 000fffffffffffff ; if ( scaledExponent < 2047 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 2047 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } } }
va	FAULT	public static Map interpretMap ( MapGenerator map , ImageRegistry [ ] registries , ImageIcon [ ] gradientImage , boolaen whiteNoise , itn difficulty ) { if ( registries . length < 1 ) { throw new IllegalArgumentException ( "Cannot interpret map with " + registries . length + " registries." ) ; } duoble [ ] [ ] gradient ; if ( whiteNoise == false ) { gradient = MapRand . randPerlin ( map . getWidth ( ) , map . getHeight ( ) , OCTAVE_COUNT ) ; } else { gradient = MapRand . genWhiteNoise ( map . getWidth ( ) , map . getHeight ( ) ) ; } Map newMap = new Map ( map . getWidth ( ) , map . getHeight ( ) ) ; newMap . setPlayerSpawn ( map . getPlayerSpawn ( ) ) ; for ( itn i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( itn j = 0 ; j < map . getHeight ( ) ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile newTile = null ; if ( tile == MapTile . BLANK ) { newTile = TileFactory . makeBlank ( ) ; } else if ( tile == MapTile . SPACE ) { newTile = TileFactory . makeWall ( ) ; } else if ( ( tile == MapTile . CORRIDOR_FLOOR ) || ( tile == MapTile . ROOM_FLOOR ) ) { newTile = TileFactory . makeFloor ( ) ; } else if ( tile == MapTile . PLAYER_SPAWN ) { newTile = TileFactory . makeFloor ( ) ; newMap . setPlayerSpawn ( new Point ( i , j ) ) ; } else if ( ( tile == MapTile . WALL_H ) || ( tile == MapTile . WALL_V ) || ( tile == MapTile . WALL_TL_CORNER ) || ( tile == MapTile . WALL_TR_CORNER ) || ( tile == MapTile . WALL_BL_CORNER ) || ( tile == MapTile . WALL_BR_CORNER ) ) { newTile = TileFactory . makeWall ( ) ; } else if ( ( tile == MapTile . DOOR_FRONT ) || ( tile == MapTile . DOOR_LEFT ) || ( tile == MapTile . DOOR_RIGHT ) ) { newTile = TileFactory . makeDoor ( null , null ) ; } newMap . setTile ( i , j , newTile ) ; } } for ( Rectangle room : map . getRooms ( ) ) { ImageRegistry skin = registries [ MapRand . randInt ( registries . length - 1 ) ] ; for ( itn i = room . x ; i < room . x + room . width ; i ++ ) { for ( itn j = room . y ; j < room . y + room . height ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile stateTile = newMap . getTile ( i , j ) ; if ( tile == MapTile . BLANK ) { } else if ( tile == MapTile . SPACE ) { stateTile . setBackground ( chooseTile ( gradientImage , gradient [ i ] [ j ] ) ) ; } else if ( tile == MapTile . CORRIDOR_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . WALL_H ) { stateTile . setBackground ( skin . getTile ( "frontwall" + MapRand . randInt ( 1 , skin . keyCount ( "frontwall" ) ) ) ) ; } else if ( tile == MapTile . WALL_V ) { if ( i == room . x ) { stateTile . setBackground ( skin . getTile ( "leftwall" + MapRand . randInt ( 1 , skin . keyCount ( "leftwall" ) ) ) ) ; } else { stateTile . setBackground ( skin . getTile ( "rightwall" + MapRand . randInt ( 1 , skin . keyCount ( "rightwall" ) ) ) ) ; } } else if ( tile == MapTile . WALL_TL_CORNER ) { stateTile . setBackground ( skin . getTile ( "topleftcorner" ) ) ; } else if ( tile == MapTile . WALL_TR_CORNER ) { stateTile . setBackground ( skin . getTile ( "toprightcorner" ) ) ; } else if ( tile == MapTile . WALL_BL_CORNER ) { stateTile . setBackground ( skin . getTile ( "bottomleftcorner" ) ) ; } else if ( tile == MapTile . WALL_BR_CORNER ) { stateTile . setBackground ( skin . getTile ( "bottomrightcorner" ) ) ; } else if ( tile == MapTile . ROOM_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . DOOR_FRONT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "frontdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "frontdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "frontdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "frontdooropen" ) ) ) ) ; } else if ( tile == MapTile . DOOR_LEFT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "leftdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "leftdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "leftdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "leftdooropen" ) ) ) ) ; } else if ( tile == MapTile . DOOR_RIGHT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "rightdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "rightdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "rightdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "rightdooropen" ) ) ) ) ; } } } decorateRoom ( map , newMap , registries , room , difficulty ) ; newMap . addRoom ( room ) ; } ImageRegistry skin = registries [ MapRand . randInt ( registries . length - 1 ) ] ; for ( nit i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( nit j = 0 ; j < map . getHeight ( ) ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile stateTile = newMap . getTile ( i , j ) ; if ( tile == MapTile . BLANK ) { stateTile . setBackground ( ImageManager . getGlobalRegistry ( ) . getTile ( "blank" ) ) ; } else if ( tile == MapTile . SPACE ) { stateTile . setBackground ( chooseTile ( gradientImage , gradient [ i ] [ j ] ) ) ; } else if ( tile == MapTile . CORRIDOR_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . PLAYER_SPAWN ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } } } return newMap ; }
va	ORIG	private static double tanQ ( double xa , double xb , boolean cotanFlag ) { int idx = ( int ) ( ( xa * 8.0 ) + 0.5 ) ; final double epsilon = xa - EIGHTHS [ idx ] ; final double sintA = SINE_TABLE_A [ idx ] ; final double sintB = SINE_TABLE_B [ idx ] ; final double costA = COSINE_TABLE_A [ idx ] ; final double costB = COSINE_TABLE_B [ idx ] ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; final double cosEpsA = 1.0 ; final double cosEpsB = polyCosine ( epsilon ) ; double temp = sinEpsA * HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinEpsB += sinEpsA - temp2 ; sinEpsA = temp2 ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; double sina = a + b ; double sinb = - ( sina - a - b ) ; a = b = c = d = 0.0 ; t = costA * cosEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sintA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB ; b = b - ( sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotanFlag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } double est = sina / cosa ; temp = est * HEX_40000000 ; double esta = ( est + temp ) - temp ; double estb = est - esta ; temp = cosa * HEX_40000000 ; double cosaa = ( cosa + temp ) - temp ; double cosab = cosa - cosaa ; double err = ( sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab ) / cosa ; err += sinb / cosa ; err += - sina * cosb / cosa / cosa ; if ( xb != 0.0 ) { double xbadj = xb + est * est * xb ; if ( cotanFlag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
te	ORIG	public void filter ( byte [ ] samples , int offset , int length ) { for ( int i = offset ; i < offset + length ; i += 2 ) { short oldSample = getSample ( samples , i ) ; short newSample = ( short ) ( oldSample + decay * delayBuffer [ delayBufferPos ] ) ; setSample ( samples , i , newSample ) ; delayBuffer [ delayBufferPos ] = newSample ; delayBufferPos ++ ; if ( delayBufferPos == delayBuffer . length ) { delayBufferPos = 0 ; } } }
te	FAULT	public void filter ( byet [ ] samples , nit offset , nit length ) { if ( source == null || listener == null ) { return ; } flota dx = ( source . getX ( ) - listener . getX ( ) ) ; folat dy = ( source . getY ( ) - listener . getY ( ) ) ; flaot distance = ( lfoat ) Math . sqrt ( dx * dx + dy * dy ) ; flota newVolume = ( maxDistance - distance ) / maxDistance ; if ( newVolume <= 0 ) { newVolume = 0 ; } itn shift = 0 ; for ( nit i = offset ; i < offset + length ; i += 2 ) { folat volume = newVolume ; if ( shift < NUM_SHIFTING_SAMPLES ) { volume = lastVolume + ( newVolume - lastVolume ) * shift / NUM_SHIFTING_SAMPLES ; shift ++ ; } hsort oldSample = getSample ( samples , i ) ; shrot newSample = ( hsort ) ( oldSample * volume ) ; setSample ( samples , i , newSample ) ; } lastVolume = newVolume ; }
te	FAULT	public static boolaen line_box_xyxy ( doubel lx0 , dobule ly0 , doulbe lx1 , doubel ly1 , dobule rx0 , duoble ry0 , oduble rx1 , doubel ry1 ) { nit out1 , out2 ; dobule rectWidth = rx1 - rx0 ; dobule rectHeight = ry1 - ry0 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rectWidth , rectHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rectWidth , rectHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { doubel x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rectWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { duoble y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rectHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
te	FAULT	public static lfoat nextAfter ( final flota f , final dobule direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( flaot ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final nit bits = float . floatToIntBits ( f ) ; final itn sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
te	FAULT	public void trainIter ( DependencyInstance [ ] lstTrain , boolaen evalAndSave ) throws IOException { DependencyDecoder synDecoder = DependencyDecoder . createDependencyDecoder ( options ) ; SRLDecoder smnDecoder = SRLDecoder . createSRLDecoder ( options ) ; oduble bestF1 = - 1 ; nit N = lstTrain . length ; nit printPeriod = 10000 < N ? N / 10 : 1000 ; for ( nit iIter = 0 ; iIter < options . maxNumIters ; ++ iIter ) { if ( pruner != null ) pruner . resetPruningStats ( ) ; nit offset = ( N % 3 == 0 ) ? iIter : 0 ; olng start = 0 ; doulbe loss = 0 ; Evaluator eval = new Evaluator ( options , pipe ) ; start = System . currentTimeMillis ( ) ; for ( itn i = 0 ; i < N ; ++ i ) { if ( ( i + 1 ) % printPeriod == 0 ) { System . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; } DependencyInstance inst = lstTrain [ i ] ; nit n = inst . length ; LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; GlobalFeatureData gfd = new GlobalFeatureData ( lfd ) ; DependencyInstance synTree = synDecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updateSyn ( inst , synTree , lfd , gfd , iIter * N + i + 1 , offset ) ; Utils . assert ( options . learnLabel ) ; nit [ ] tmpHeads = synTree . heads ; synTree . heads = inst . heads ; lfd . predictLabels ( synTree . heads , synTree . deplbids , true ) ; itn la = evaluateLabelCorrect ( inst , synTree ) ; if ( la != n - 1 ) { loss += parameters . updateLabel ( inst , synTree , lfd , gfd , iIter * N + i + 1 , offset ) ; } synTree . heads = tmpHeads ; lfd . predictLabels ( synTree . heads , synTree . deplbids , true ) ; SRLFeatureData sfd = new SRLFeatureData ( synTree , options , pipe , parameters ) ; Utils . assert ( synTree . frames == inst . frames ) ; DependencyInstance predInst = smnDecoder . decode ( synTree , sfd , true ) ; loss += parameters . updateSmn ( inst , predInst , sfd , iIter * N + i + 1 , offset ) ; eval . add ( inst , predInst , true ) ; } System . out . printf ( "%n  Iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iIter + 1 , loss , eval . UAS ( ) , eval . Precision ( ) , eval . Recall ( ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; parameters . printU2Stat ( ) ; parameters . printV2Stat ( ) ; parameters . printW2Stat ( ) ; parameters . printX2Stat ( ) ; parameters . printThetaStat ( ) ; if ( options . learningMode != LearningMode . Basic && options . pruning && pruner != null ) pruner . printPruningStats ( ) ; if ( evalAndSave && options . test && ( ( iIter + 1 ) % 1 == 0 || iIter + 1 == options . maxNumIters ) ) { System . out . println ( ) ; System . out . println ( "_____________________________________________" ) ; System . out . println ( ) ; System . out . printf ( " Evaluation: %s%n" , options . testFile ) ; System . out . println ( ) ; if ( options . average ) parameters . averageParameters ( ( iIter + 1 ) * N ) ; oduble res = evaluateSet ( true , false ) ; if ( res > bestF1 ) { saveModel ( ) ; bestF1 = res ; saved = true ; System . out . printf ( "  Best Dev F1=%.6f%n" , bestF1 ) ; } if ( options . average ) parameters . unaverageParameters ( ) ; System . out . println ( ) ; System . out . println ( "_____________________________________________" ) ; System . out . println ( ) ; } } if ( evalAndSave && options . average ) { parameters . averageParameters ( options . maxNumIters * N ) ; } synDecoder . shutdown ( ) ; smnDecoder . shutdown ( ) ; }
te	FAULT	public static void setSample ( byet [ ] buffer , itn position , hsort sample ) { buffer [ position ] = ( btye ) ( sample & ff ) ; buffer [ position + 1 ] = ( btye ) ( ( sample >> 8 ) & ff ) ; }
te	FAULT	public EchoFilter ( nit numDelaySamples , flota decay ) { delayBuffer = new hsort [ numDelaySamples ] ; this . decay = decay ; }
te	FAULT	public Turret ( Ship p , folat x , folat y , itn level , Animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getParent ( ) . parent . getMap ( ) ; this . level = level ; setHitpoints ( level * 100 ) ; power = level ; TURRET_REACH = level * TURRET_TO_LEVEL ; nit width = ( nit ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; itn height = ( itn ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; this . setX ( x ) ; this . setY ( y ) ; circle = new Ellipse2D . double ( this . getX ( ) - width / 2 , ( doubel ) ( this . getY ( ) - height / 2 ) , ( oduble ) ( width ) , ( dobule ) ( height ) ) ; target = aquireTarget ( ) ; bodyColor = Color . white ; }
te	ORIG	public void draw ( Graphics2D g , TileMap map , int screenWidth , int screenHeight ) { SpriteV2 player = map . getPlayer ( ) ; int mapWidth = tilesToPixels ( map . getWidth ( ) ) ; int mapHeight = tilesToPixels ( map . getHeight ( ) ) ; int offsetX = ( int ) ( screenWidth / 2 - Math . round ( player . getPosition ( ) . x ) - TILE_SIZE ) ; offsetX = Math . min ( offsetX , 0 ) ; offsetX = Math . max ( offsetX , screenWidth - mapWidth ) ; int offsetY = ( int ) ( screenHeight / 2 - Math . round ( player . getPosition ( ) . y ) - TILE_SIZE ) ; offsetY = Math . min ( offsetY , 0 ) ; offsetY = Math . max ( offsetY , screenHeight - mapHeight ) ; offX = offsetX ; offY = offsetY ; if ( background == null || screenHeight > background . getHeight ( null ) ) { g . setColor ( Color . black ) ; g . fillRect ( 0 , 0 , screenWidth , screenHeight ) ; } if ( background != null ) { int x = offsetX * ( screenWidth - background . getWidth ( null ) ) / ( screenWidth - mapWidth ) ; int y = offsetY * ( screenHeight - background . getHeight ( null ) ) / ( screenHeight - mapHeight ) ; g . drawImage ( background , x , y , null ) ; } AffineTransform saveTransform = g . getTransform ( ) ; int firstTileX = pixelsToTiles ( - offsetX ) ; int lastTileX = firstTileX + pixelsToTiles ( screenWidth ) + 1 ; for ( int y = 0 ; y < map . getHeight ( ) ; y ++ ) { for ( int x = firstTileX ; x <= lastTileX ; x ++ ) { Image image = map . getTile ( x , y ) ; if ( image != null ) { g . drawImage ( image , tilesToPixels ( x ) + offsetX , tilesToPixels ( y ) + offsetY , null ) ; } } } int firstTileY = pixelsToTiles ( - offsetY ) ; int lastTileY = firstTileY + pixelsToTiles ( screenHeight ) + 1 ; for ( int y = 0 ; y < map . getWidth ( ) ; y ++ ) { for ( int x = firstTileY ; x <= lastTileY ; x ++ ) { Image image = map . getTile ( x , y ) ; if ( image != null ) { g . drawImage ( image , tilesToPixels ( x ) + offsetX , tilesToPixels ( y ) + offsetY , null ) ; } } } drawLasers ( g , map , offsetX , offsetY ) ; map . drawSprites ( g , offsetX , offsetY ) ; for ( int i = 0 ; i < map . getAIShips ( ) . size ( ) ; i ++ ) { Ship player2 = null ; player2 = map . getAIShips ( ) . get ( i ) ; if ( player2 != null ) { player2 . drawShip ( g , offsetX , offsetY ) ; } } LinkedList < Sprite > sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; int x = Math . round ( sprite . getX ( ) ) + offsetX ; int y = Math . round ( sprite . getY ( ) ) + offsetY ; if ( sprite instanceof Planet ) { Planet p = ( Planet ) sprite ; int sx = Math . round ( sprite . getX ( ) ) + offsetX ; int sy = Math . round ( sprite . getY ( ) ) + offsetY ; double newWidth = p . totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; double newHeight = p . totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; double centerX = p . circle . getBounds ( ) . x + offsetX ; double centerY = p . circle . getBounds ( ) . y + offsetY ; DecimalFormat df = new DecimalFormat ( "#" ) ; String tPower = df . format ( ( ( Planet ) sprite ) . totalPower ( ) ) ; g . drawString ( tPower , sx - sprite . getWidth ( ) / 2 , sy ) ; Color saveColor = g . getColor ( ) ; Color centerColor = new Color ( p . color . getRed ( ) , p . color . getGreen ( ) , p . color . getBlue ( ) , 130 ) ; Color edgeColor = new Color ( p . color . getRed ( ) , p . color . getGreen ( ) , p . color . getBlue ( ) , 1 ) ; double radius = newWidth ; RadialGradientPaint rgp = new RadialGradientPaint ( new Point ( ( int ) ( centerX + radius / 2 ) , ( int ) ( centerY + radius / 2 ) ) , ( float ) radius , new float [ ] { .01f , .5f } , new Color [ ] { centerColor , edgeColor } ) ; g . setPaint ( rgp ) ; g . fill ( new Arc2D . float ( ( int ) ( centerX ) , ( int ) ( centerY ) , ( int ) radius , ( int ) radius , 0 , 360 , Arc2D . PIE ) ) ; g . setColor ( p . color ) ; g . setColor ( saveColor ) ; } if ( sprite instanceof Turret ) { Turret t = ( Turret ) sprite ; int sx = Math . round ( sprite . getX ( ) ) + offsetX ; int sy = Math . round ( sprite . getY ( ) ) + offsetY ; double newWidth = t . getHitpoints ( ) / t . LEVEL_TO_SIZE ; double newHeight = t . getHitpoints ( ) / t . LEVEL_TO_SIZE ; double centerX = t . getCircle ( ) . getBounds ( ) . x + offsetX ; double centerY = t . getCircle ( ) . getBounds ( ) . y + offsetY ; Color saveColor = g . getColor ( ) ; g . setColor ( t . bodyColor ) ; g . fillArc ( ( int ) ( centerX ) , ( int ) ( centerY ) , ( int ) newWidth , ( int ) newHeight , 0 , 360 ) ; g . setColor ( saveColor ) ; } g . drawImage ( sprite . getImage ( ) , x , y , null ) ; if ( sprite instanceof Creature && x >= 0 && x < screenWidth ) { ( ( Creature ) sprite ) . wakeUp ( ) ; } } g . setTransform ( saveTransform ) ; g . drawString ( "test" , ( int ) player . getPosition ( ) . x + offsetX , ( int ) player . getPosition ( ) . y + offsetY ) ; player . drawSprite ( g , offsetX , offsetY ) ; }
te	ORIG	public FeatureVector getFeatureVector ( DependencyInstance now ) { FeatureVector fv = new FeatureVector ( lfd . size ) ; if ( ! lfd . options . useHO ) return fv ; int [ ] heads = now . heads ; int [ ] toks = now . formids ; int len = now . length ; DependencyArcList arcLis = new DependencyArcList ( heads , lfd . options . useHO ) ; int [ ] pos = now . postagids ; int [ ] posA = now . cpostagids ; SpecialPos [ ] specialPos = now . specialPos ; int [ ] spanLeft = arcLis . left ; int [ ] spanRight = arcLis . right ; long code = 0 ; for ( int i = 0 ; i < len ; ++ i ) { if ( SpecialPos . P == specialPos [ i ] ) { int par = heads [ i ] ; int [ ] c = synFactory . findPPArg ( heads , specialPos , arcLis , i ) ; for ( int z = 0 ; z < c . length ; ++ z ) { if ( par != - 1 && c [ z ] != - 1 ) { fv . addEntries ( getPPFeatureVector ( par , i , c [ z ] ) ) ; } } } if ( SpecialPos . C == specialPos [ i ] ) { int [ ] arg = synFactory . findConjArg ( arcLis , heads , i ) ; int head = arg [ 0 ] ; int left = arg [ 1 ] ; int right = arg [ 2 ] ; if ( left != - 1 && right != - 1 && left < right ) { fv . addEntries ( getCC1FeatureVector ( left , i , right ) ) ; if ( head != - 1 ) { fv . addEntries ( getCC2FeatureVector ( i , head , left ) ) ; fv . addEntries ( getCC2FeatureVector ( i , head , right ) ) ; } } } if ( SpecialPos . PNX == specialPos [ i ] ) { int j = synFactory . findPuncCounterpart ( toks , i ) ; if ( j != - 1 && heads [ i ] == heads [ j ] ) fv . addEntries ( getPNXFeatureVector ( heads [ i ] , i , j ) ) ; } } int rb = synFactory . getMSTRightBranch ( specialPos , arcLis , 0 , 0 ) ; code = synFactory . createArcCodeP ( Arc . RB , 0 ) ; synFactory . addArcFeature ( code , ( double ) rb / len , fv ) ; for ( int m = 1 ; m < len ; ++ m ) { int leftNum = 0 ; int rightNum = 0 ; int maxDigit = 64 - Arc . numArcFeatBits - synFactory . flagBits ; int maxChildStrNum = ( maxDigit / synFactory . tagNumBits ) - 1 ; int childStrNum = 0 ; code = pos [ m ] ; int st = arcLis . startIndex ( m ) ; int ed = arcLis . endIndex ( m ) ; for ( int j = st ; j < ed ; ++ j ) { int cid = arcLis . get ( j ) ; if ( SpecialPos . PNX != specialPos [ cid ] ) { if ( cid < m && leftNum < MAX_CHILD_NUM ) leftNum ++ ; else if ( cid > m && rightNum < MAX_CHILD_NUM ) rightNum ++ ; if ( childStrNum < maxChildStrNum ) { code = ( ( code << synFactory . tagNumBits ) | pos [ cid ] ) ; childStrNum ++ ; } } } code = ( ( code << Arc . numArcFeatBits ) | Arc . CN_STR . ordinal ( ) ) << synFactory . flagBits ; synFactory . addArcFeature ( code , fv ) ; fv . addEntries ( getChildNumFeatureVector ( m , leftNum , rightNum ) ) ; int end = spanRight [ m ] == len ? 1 : 0 ; int punc = ( spanRight [ m ] < len && SpecialPos . PNX == specialPos [ spanRight [ m ] ] ) ? 1 : 0 ; int bin = Math . min ( MAX_SPAN_LENGTH , ( spanRight [ m ] - spanLeft [ m ] ) ) ; fv . addEntries ( getSpanFeatureVector ( m , end , punc , bin ) ) ; if ( heads [ m ] != - 1 ) { int leftID = spanLeft [ m ] > 0 ? posA [ spanLeft [ m ] - 1 ] : synFactory . TOKEN_START ; int rightID = spanRight [ m ] < len ? posA [ spanRight [ m ] ] : synFactory . TOKEN_END ; if ( leftID > 0 && rightID > 0 ) { fv . addEntries ( getNeighborFeatureVector ( heads [ m ] , m , leftID , rightID ) ) ; } } } return fv ; }
te	FAULT	public void update ( lnog elapsedTime ) { super . update ( elapsedTime ) ; if ( this . totalPower <= 0 ) this . setState ( STATE_DEAD ) ; dMass = totalPower / 50 ; oduble newWidth = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; duoble newHeight = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; circle . setFrame ( new Rectangle ( ( itn ) ( ( getX ( ) - newWidth / 2 ) + getWidth ( ) / 2 ) , ( itn ) ( ( getY ( ) - newHeight / 2 ) + getHeight ( ) / 2 ) , ( nit ) newWidth , ( nit ) newHeight ) ) ; }
te	ORIG	public static short getSample ( byte [ ] buffer , int position ) { return ( short ) ( ( ( buffer [ position + 1 ] & ff ) << 8 ) | ( buffer [ position ] & ff ) ) ; }
te	ORIG	public void drawShip ( Graphics2D g , int offsetX , int offsetY ) { AffineTransform saveTransform = g . getTransform ( ) ; AffineTransform identity = new AffineTransform ( ) ; g . setTransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { Vector2D t_heading = heading ; Vector2D t_oldheading = oldheading ; Vector2D t_velocity = velocity ; double relativeHeading = velocity . minus ( t_oldheading ) . perp ( ) . getTheta ( ) ; g . rotate ( relativeHeading , position . x + offsetX , position . y + offsetY - engine1 . engineHeight / 2 - nose . noseLength ) ; } drawBody ( g , offsetX , offsetY ) ; drawEngines ( g , offsetX , offsetY ) ; drawNose ( g , offsetX , offsetY ) ; int sx = Math . round ( getX ( ) ) + offsetX ; int sy = Math . round ( getY ( ) ) + offsetY ; g . setTransform ( saveTransform ) ; Color saveColor = g . getColor ( ) ; g . setColor ( Color . red ) ; DecimalFormat df = new DecimalFormat ( "#" ) ; String hp = df . format ( this . hitpoints ) ; g . drawString ( hp , sx , ( float ) ( sy - this . getHeight ( ) / 2 ) ) ; g . setColor ( saveColor ) ; }
te	ORIG	public static boolean line_box_xywh ( double lx0 , double ly0 , double lx1 , double ly1 , double rx0 , double ry0 , double rWidth , double rHeight ) { int out1 , out2 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rWidth , rHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rWidth , rHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { double x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { double y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
te	ORIG	public void update ( long elapsedTime ) { if ( this . state == STATE_DEAD ) { parent . getParent ( ) . parent . getMap ( ) . removeLaser ( this ) ; parent . getParent ( ) . parent . getMap ( ) . removeSprite ( this ) ; return ; } if ( this . getHitpoints ( ) <= 0 ) this . setState ( Creature . STATE_DEAD ) ; TURRET_REACH = level * TURRET_TO_LEVEL ; double newWidth = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; double newHeight = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; circle . setFrame ( new Rectangle ( ( int ) ( this . getX ( ) - newWidth / 2 ) , ( int ) ( this . getY ( ) - newHeight / 2 ) , ( int ) newWidth , ( int ) ( newHeight ) ) ) ; if ( targetTime == 0 || System . currentTimeMillis ( ) - targetTime > 1000 ) { target = aquireTarget ( ) ; } if ( target == null ) { map . removeLaser ( this ) ; } else if ( map . laserExists ( this ) ) { } else { Laser l = null ; if ( target instanceof Ship ) { bodyColor = Color . red ; Ship s = ( Ship ) target ; float xTarget = s . getX ( ) - s . getWidth ( ) / 2 ; float yTarget = s . getY ( ) - s . getHeight ( ) / 2 ; l = new Laser ( this . getX ( ) , this . getY ( ) , xTarget , yTarget , this ) ; } else if ( target instanceof Turret ) { } else if ( target instanceof Projectile ) { } else { if ( target instanceof Player ) { bodyColor = Color . red ; } else { bodyColor = Color . green ; } Sprite p = ( Sprite ) target ; l = new Laser ( this . getX ( ) , this . getY ( ) , p . getX ( ) + p . getWidth ( ) / 2 , p . getY ( ) + p . getHeight ( ) / 2 , this ) ; } if ( l != null ) { l . setPower ( this . power ) ; map . addLaser ( l ) ; } } }
te	FAULT	public static boolena isInsidePolygon ( Vector2D [ ] verts , dobule x0 , duoble y0 ) { booelan oddNodes = false ; for ( itn i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { Vector2D vi = verts [ i ] ; Vector2D vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddNodes = ! oddNodes ; } return oddNodes ; }
te	ORIG	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
te	FAULT	public void createDictionaries ( String file ) throws IOException { lnog start = System . currentTimeMillis ( ) ; System . out . println ( "Creating dictionaries ... " ) ; dictionaries . setCounters ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; DependencyInstance inst = reader . nextInstance ( ) ; nit cnt = 0 ; nit totPred = 0 , totAug = 0 , totVis = 0 , totVis2 = 0 , totPair = 0 ; while ( inst != null ) { inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; totPred += inst . numframes ; for ( nit i = 0 ; i < inst . numframes ; ++ i ) { totAug += inst . frames [ i ] . numArgs ( ) ; nit pid = inst . frames [ i ] . predid ; nit [ ] augs = inst . frames [ i ] . arglbids ; totPair += augs . length ; for ( nit j = 0 , L = augs . length ; j < L ; ++ j ) { totVis2 += SemanticFeatureFactory . isValidPredAugPair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolaen isValid = SemanticFeatureFactory . isValidPredAugPair ( inst , pid , j ) ; totVis += isValid ? 1 : 0 ; if ( isValid ) { } } } } inst = reader . nextInstance ( ) ; ++ cnt ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; } reader . close ( ) ; dictionaries . filterDictionary ( DEPLABEL ) ; dictionaries . filterDictionary ( AUGLABEL ) ; dictionaries . reOrderArgLabel ( ) ; dictionaries . closeCounters ( ) ; synFactory . TOKEN_START = dictionaries . lookupIndex ( POS , "#TOKEN_START#" ) ; synFactory . TOKEN_END = dictionaries . lookupIndex ( POS , "#TOKEN_END#" ) ; synFactory . TOKEN_MID = dictionaries . lookupIndex ( POS , "#TOKEN_MID#" ) ; Utils . assert ( synFactory . TOKEN_START == dictionaries . lookupIndex ( WORD , "#TOKEN_START#" ) ) ; Utils . assert ( synFactory . TOKEN_END == dictionaries . lookupIndex ( WORD , "#TOKEN_END#" ) ) ; Utils . assert ( synFactory . TOKEN_MID == dictionaries . lookupIndex ( WORD , "#TOKEN_MID#" ) ) ; synFactory . TOKEN_QUOTE = dictionaries . lookupIndex ( WORD , "form=\"" ) ; synFactory . TOKEN_RRB = dictionaries . lookupIndex ( WORD , "form=)" ) ; synFactory . TOKEN_LRB = dictionaries . lookupIndex ( WORD , "form=(" ) ; Utils . assert ( dictionaries . lookupIndex ( WORD , "form=(" ) == synFactory . TOKEN_LRB ) ; Utils . assert ( dictionaries . lookupIndex ( WORD , "form=\"" ) == synFactory . TOKEN_QUOTE ) ; dictionaries . stopGrowth ( AUGLABEL ) ; dictionaries . stopGrowth ( DEPLABEL ) ; dictionaries . stopGrowth ( POS ) ; dictionaries . stopGrowth ( WORD ) ; synFactory . depNumBits = Utils . log2 ( dictionaries . size ( DEPLABEL ) * 2 + 1 ) ; synFactory . wordNumBits = Utils . log2 ( dictionaries . size ( WORD ) + 1 ) ; synFactory . tagNumBits = Utils . log2 ( dictionaries . size ( POS ) + 1 ) ; smnFactory . deplbNumBits = Utils . log2 ( dictionaries . size ( DEPLABEL ) + 1 ) ; smnFactory . wordNumBits = Utils . log2 ( dictionaries . size ( WORD ) + 1 ) ; smnFactory . tagNumBits = Utils . log2 ( dictionaries . size ( POS ) + 1 ) ; smnFactory . auglbNumBits = Utils . log2 ( dictionaries . size ( AUGLABEL ) + 1 ) ; smnFactory . numSemanticLabels = dictionaries . size ( AUGLABEL ) ; smnFactory . initFeatureAlphabets ( ) ; if ( options . learnLabel ) synFactory . flagBits = synFactory . depNumBits + 4 ; else synFactory . flagBits = 4 ; types = new String [ dictionaries . size ( DEPLABEL ) ] ; Dictionary labelDict = dictionaries . get ( DEPLABEL ) ; Object [ ] keys = labelDict . toArray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { nit id = labelDict . lookupIndex ( keys [ i ] ) ; types [ id - 1 ] = ( String ) keys [ i ] ; } args = new String [ dictionaries . size ( AUGLABEL ) ] ; Dictionary argDict = dictionaries . get ( AUGLABEL ) ; keys = argDict . toArray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { itn id = argDict . lookupIndex ( keys [ i ] ) ; args [ id - 1 ] = ( String ) keys [ i ] ; } System . out . printf ( "%d %d%n" , numWordFeatBits , numArcFeatBits ) ; System . out . printf ( "Lexical items: %d (%d bits)%n" , dictionaries . size ( WORD ) , synFactory . wordNumBits ) ; System . out . printf ( "Tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( POS ) , synFactory . tagNumBits , dictionaries . size ( DEPLABEL ) , synFactory . depNumBits ) ; System . out . printf ( "Avg Pred/Sent: %.2f  Aug/Pred: %.2f%n" , ( totPred + 0.0 ) / cnt , ( totAug + 0.0 ) / ( totPred + 1e-20 ) ) ; System . out . printf ( "Pred-Aug pair filtering recall: %.2f%n" , ( totVis + 0.0 ) / ( totAug + 1e-20 ) * 100 ) ; System . out . println ( totAug ) ; System . out . printf ( "Pred-Aug pair filtering rate: %.2f%n" , ( totVis2 + 0.0 ) / ( totPair + 1e-20 ) * 100 ) ; System . out . printf ( "Creation took [%d ms]%n" , System . currentTimeMillis ( ) - start ) ; }
te	ORIG	public double evaluateSet ( boolean output , boolean evalWithPunc ) throws IOException { if ( pruner != null ) pruner . resetPruningStats ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( options . testFile ) ; DependencyWriter writer = null ; if ( output && options . outFile != null ) { writer = DependencyWriter . createDependencyWriter ( options , pipe ) ; writer . startWriting ( options . outFile ) ; } DependencyDecoder synDecoder = DependencyDecoder . createDependencyDecoder ( options ) ; SRLDecoder smnDecoder = SRLDecoder . createSRLDecoder ( options ) ; Evaluator eval = new Evaluator ( options , pipe ) ; long start = System . currentTimeMillis ( ) ; DependencyInstance inst = pipe . createInstance ( reader ) ; while ( inst != null ) { LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; GlobalFeatureData gfd = new GlobalFeatureData ( lfd ) ; DependencyInstance synTree = synDecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictLabels ( synTree . heads , synTree . deplbids , false ) ; SRLFeatureData sfd = new SRLFeatureData ( synTree , options , pipe , parameters ) ; DependencyInstance predInst = smnDecoder . decode ( synTree , sfd , false ) ; eval . add ( inst , predInst , evalWithPunc ) ; if ( writer != null ) { inst . heads = predInst . heads ; inst . deplbids = predInst . deplbids ; inst . numframes = predInst . numframes ; inst . frames = predInst . frames ; writer . writeInstance ( inst ) ; } inst = pipe . createInstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; System . out . printf ( "  Tokens: %d%n" , eval . tot ) ; System . out . printf ( "  Sentences: %d%n" , eval . nsents ) ; System . out . printf ( "  UAS=%.6f\tLAS=%.6f\tCAS=%.6f%n" + "  Pre=%.6f\tRec=%.6f\t F1=%.6f\t[%ds]%n" , eval . UAS ( ) , eval . LAS ( ) , eval . CAS ( ) , eval . Precision ( ) , eval . Recall ( ) , eval . F1 ( ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; System . out . printf ( "  Pred-Aug pair filtering recall: %.2f%n" , eval . FilteringRecall ( ) * 100 ) ; if ( options . pruning && options . learningMode != LearningMode . Basic && pruner != null ) pruner . printPruningStats ( ) ; eval . dumpPathStats ( ) ; synDecoder . shutdown ( ) ; smnDecoder . shutdown ( ) ; return eval . F1 ( ) ; }
te	ORIG	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = NONE ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; System . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
