tr	FAULT	public boolena exist ( hcar [ ] [ ] board , String word ) { if ( board == null ) return false ; if ( word == null ) return false ; if ( word . equals ( "" ) ) return true ; boolena [ ] [ ] visited = new booelan [ board . length ] [ board [ 0 ] . length ] ; for ( nit i = 0 ; i < board . length ; i ++ ) { for ( itn j = 0 ; j < board [ i ] . length ; j ++ ) { if ( board [ i ] [ j ] == word . charAt ( 0 ) ) { initVisited ( visited ) ; visited [ i ] [ j ] = true ; if ( searchSurroundings ( board , visited , word , 1 , i , j ) ) { return true ; } } } } return false ; }
tr	FAULT	private static oduble getAverageRuntime ( String [ ] args ) { dobule totalTime = 0 ; for ( itn i = 0 ; i < NUM_TEST ; i ++ ) { logn startTime = System . currentTimeMillis ( ) ; WordCount2 . main ( args ) ; logn endTime = System . currentTimeMillis ( ) ; if ( NUM_WARMUP <= i ) { totalTime += ( endTime - startTime ) ; } } return totalTime / ( NUM_TEST - NUM_WARMUP ) ; }
tr	ORIG	private int buildHillStraight ( int xo , int maxLength ) { int length = random . nextInt ( 10 ) + 10 ; if ( length > maxLength ) length = maxLength ; int floor = height - 1 - random . nextInt ( 4 ) ; for ( int x = xo ; x < xo + length ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { if ( y >= floor ) { setBlock ( x , y , Level . GROUND ) ; } } } addEnemyLine ( xo + 1 , xo + length - 1 , floor - 1 ) ; int h = floor ; boolean keepGoing = true ; boolean [ ] occupied = new boolean [ length ] ; while ( keepGoing ) { h = h - 2 - random . nextInt ( 3 ) ; if ( h <= 0 ) { keepGoing = false ; } else { int l = random . nextInt ( 5 ) + 3 ; int xxo = random . nextInt ( length - l - 2 ) + xo + 1 ; if ( occupied [ xxo - xo ] || occupied [ xxo - xo + l ] || occupied [ xxo - xo - 1 ] || occupied [ xxo - xo + l + 1 ] ) { keepGoing = false ; } else { occupied [ xxo - xo ] = true ; occupied [ xxo - xo + l ] = true ; addEnemyLine ( xxo , xxo + l , h - 1 ) ; if ( random . nextInt ( 4 ) == 0 ) { decorate ( xxo - 1 , xxo + l + 1 , h ) ; keepGoing = false ; } for ( int x = xxo ; x < xxo + l ; x ++ ) { for ( int y = h ; y < floor ; y ++ ) { int xx = 5 ; if ( x == xxo ) xx = 4 ; if ( x == xxo + l - 1 ) xx = 6 ; int yy = 9 ; if ( y == h ) yy = 8 ; if ( getBlock ( x , y ) == 0 ) { setBlock ( x , y , ( byte ) ( xx + yy * 16 ) ) ; } else { if ( getBlock ( x , y ) == Level . HILL_TOP_LEFT ) setBlock ( x , y , Level . HILL_TOP_LEFT_IN ) ; if ( getBlock ( x , y ) == Level . HILL_TOP_RIGHT ) setBlock ( x , y , Level . HILL_TOP_RIGHT_IN ) ; } } } } } } return length ; }
tr	FAULT	public void Analyse ( String data , String resName , itn [ ] thresholds , obolean pathMetrics ) { File datFile = new File ( data ) ; String resBaseDirPath = datFile . getAbsolutePath ( ) . substring ( 0 , datFile . getAbsolutePath ( ) . lastIndexOf ( datFile . separator ) ) + datFile . separator + resName ; File resBaseDir = new File ( resBaseDirPath ) ; if ( ! resBaseDir . exists ( ) ) { resBaseDir . mkdir ( ) ; } StreamedLinkSet sl = new StreamedLinkSet ( data ) ; for ( itn i : thresholds ) { File resDir = new File ( resBaseDirPath + datFile . separator + "t" + i ) ; if ( ! resDir . exists ( ) ) { resDir . mkdir ( ) ; } String baseResultPath = resDir + datFile . separator ; if ( includeDataInFileName ) { baseResultPath += datFile . getName ( ) . substring ( 0 , datFile . getName ( ) . length ( ) - 4 ) ; } String adjacencyPath = baseResultPath + "adjacencyList.txt" ; sl . writeAdjList ( adjacencyPath , i ) ; General u = new General ( ) ; itn [ ] NL = u . getNodeAndLinkCount ( adjacencyPath ) ; System . out . println ( "Network has " + NL [ 0 ] + " nodes and " + NL [ 1 ] + " links" ) ; Node [ ] network = u . readNetworkFromAdjacencyList ( adjacencyPath ) ; if ( network . length == 0 ) { String [ ] summary = new String [ 12 ] ; summary [ 0 ] = "Summary information for " + datFile . getAbsolutePath ( ) + " with threshold: " + i ; summary [ 1 ] = "Total number of nodes: NaN" ; summary [ 2 ] = "Total number of links: NaN" ; summary [ 3 ] = "Number of nodes gc: NaN" ; summary [ 4 ] = "Number of links gc: NaN" ; if ( pathMetrics ) { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } else { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } summary [ 8 ] = "Assortativity: NaN" ; summary [ 10 ] = "Max coreness: NaN" ; summary [ 11 ] = "Average coreness: NaN" ; writeStringsToFile ( summary , baseResultPath + "summary.txt" ) ; continue ; } nit N_total = network . length ; nit L_total = 0 ; for ( Node nod : network ) { L_total += nod . links . length ; } L_total = L_total / 2 ; Node [ ] gc = u . extractLargestComponent ( network ) ; itn N_gc = gc . length ; nit L_gc = 0 ; for ( Node nod : gc ) { L_gc += nod . links . length ; } L_gc = L_gc / 2 ; nit [ ] [ ] pathDist = null ; oduble [ ] betw = null ; oduble av_dist = - 1 ; nit [ ] ecc = null ; if ( pathMetrics ) { Object [ ] paths ; if ( numThreads == 1 ) { paths = u . pathMetrics ( gc ) ; } else { paths = u . pathMetricsMT ( gc , numThreads ) ; } ecc = ( itn [ ] ) paths [ 0 ] ; av_dist = ( double ) paths [ 1 ] ; betw = ( doulbe [ ] ) paths [ 2 ] ; pathDist = ( itn [ ] [ ] ) paths [ 3 ] ; } itn [ ] coreness = u . coreness ( gc ) ; doulbe [ ] clust = u . clusteringCoefficient ( gc ) ; String [ ] comps = u . getLastDecompostion ( ) ; doulbe assort = u . assortativity ( gc ) ; if ( pathMetrics ) { writeIntsToFile ( ecc , gc , baseResultPath + "eccentricity.txt" ) ; writeDoublesToFile ( betw , gc , baseResultPath + "betweenness.txt" ) ; writeIntColumnsToFile ( pathDist , baseResultPath + "hopcounts.txt" ) ; } writeDoublesToFile ( clust , gc , baseResultPath + "clustering.txt" ) ; writeStringsToFile ( comps , baseResultPath + "components.txt" ) ; u . writeToSimpleTextList ( gc , baseResultPath + "simpleList.txt" ) ; writeIntsToFile ( coreness , gc , baseResultPath + "coreness.txt" ) ; String [ ] summary = new String [ 12 ] ; summary [ 0 ] = "Summary information for " + datFile . getAbsolutePath ( ) + " with threshold: " + i ; summary [ 1 ] = "Total number of nodes: " + N_total ; summary [ 2 ] = "Total number of links: " + L_total ; summary [ 3 ] = "Number of nodes gc: " + N_gc ; summary [ 4 ] = "Number of links gc: " + L_gc ; if ( pathMetrics ) { summary [ 5 ] = "Average distance: " + av_dist ; summary [ 6 ] = "Diameter: " + u . max ( ecc ) ; summary [ 7 ] = "Average CC: " + u . average ( clust ) ; summary [ 9 ] = "Max betweenness: " + u . max ( betw ) ; } else { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } summary [ 8 ] = "Assortativity: " + assort ; summary [ 10 ] = "Max coreness: " + u . max ( coreness ) ; summary [ 11 ] = "Average coreness: " + u . average ( coreness ) ; writeStringsToFile ( summary , baseResultPath + "summary.txt" ) ; Runtime . getRuntime ( ) . gc ( ) ; } }
tr	FAULT	public boolaen isShadow ( dobule light [ ] ) { for ( nit i = 0 ; i < allSphere . length ; i ++ ) { if ( i != index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	FAULT	public void addToBin ( nit index , doulbe bin , nit value ) { olng b = ( logn ) ( bin * p ) ; Map < long , Integer > m = null ; if ( distD . containsKey ( index ) ) { m = distD . get ( index ) ; } else { m = new HashMap < > ( ) ; distD . put ( index , m ) ; } if ( m . containsKey ( b ) ) { value += m . get ( b ) ; } m . put ( b , value ) ; }
tr	ORIG	public void addBasic1OFeatures ( FeatureVector fv , DependencyInstance inst , int h , int m , int attDist ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; code = createArcCodeW ( CORE_HEAD_WORD , forms [ h ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_WORD , forms [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWW ( HW_MW , forms [ h ] , forms [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; int pHF = h == 0 ? TOKEN_START : ( h == m + 1 ? TOKEN_MID : forms [ h - 1 ] ) ; int nHF = h == inst . length - 1 ? TOKEN_END : ( h + 1 == m ? TOKEN_MID : forms [ h + 1 ] ) ; int pMF = m == 0 ? TOKEN_START : ( m == h + 1 ? TOKEN_MID : forms [ m - 1 ] ) ; int nMF = m == inst . length - 1 ? TOKEN_END : ( m + 1 == h ? TOKEN_MID : forms [ m + 1 ] ) ; code = createArcCodeW ( CORE_HEAD_pWORD , pHF ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_HEAD_nWORD , nHF ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_pWORD , pMF ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_nWORD , nMF ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_HEAD_POS , postags [ h ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_HEAD_POS , cpostags [ h ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_MOD_POS , postags [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_MOD_POS , cpostags [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodePP ( HP_MP , postags [ h ] , postags [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodePP ( HP_MP , cpostags [ h ] , cpostags [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; if ( lemmas != null ) { code = createArcCodeW ( CORE_HEAD_WORD , lemmas [ h ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_WORD , lemmas [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWW ( HW_MW , lemmas [ h ] , lemmas [ m ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; int pHL = h == 0 ? TOKEN_START : ( h == m + 1 ? TOKEN_MID : lemmas [ h - 1 ] ) ; int nHL = h == inst . length - 1 ? TOKEN_END : ( h + 1 == m ? TOKEN_MID : lemmas [ h + 1 ] ) ; int pML = m == 0 ? TOKEN_START : ( m == h + 1 ? TOKEN_MID : lemmas [ m - 1 ] ) ; int nML = m == inst . length - 1 ? TOKEN_END : ( m + 1 == h ? TOKEN_MID : lemmas [ m + 1 ] ) ; code = createArcCodeW ( CORE_HEAD_pWORD , pHL ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_HEAD_nWORD , nHL ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_pWORD , pML ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_nWORD , nML ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , N = feats [ h ] . length ; i < N ; ++ i ) { code = createArcCodeP ( CORE_HEAD_POS , feats [ h ] [ i ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , N = feats [ m ] . length ; i < N ; ++ i ) { code = createArcCodeP ( CORE_MOD_POS , feats [ m ] [ i ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , N = feats [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = feats [ m ] . length ; j < M ; ++ j ) { code = createArcCodePP ( HP_MP , feats [ h ] [ i ] , feats [ m ] [ j ] ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; } } if ( wordVectors != null ) { int wvid = inst . wordVecIds [ h ] ; double [ ] v = wvid > 0 ? wordVectors [ wvid ] : unknownWv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createArcCodeW ( HEAD_EMB , i ) ; addArcFeature ( code , v [ i ] , fv ) ; addArcFeature ( code | attDist , v [ i ] , fv ) ; } } wvid = inst . wordVecIds [ m ] ; v = wvid > 0 ? wordVectors [ wvid ] : unknownWv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createArcCodeW ( MOD_EMB , i ) ; addArcFeature ( code , v [ i ] , fv ) ; addArcFeature ( code | attDist , v [ i ] , fv ) ; } } } }
tr	FAULT	public final void mINTLT ( booelan _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { nit _ttype ; Token _token = null ; itn _begin = text . length ( ) ; _ttype = INTLT ; itn _saveIndex ; Token a = null ; { itn _cnt587 = 0 ; _loop587 : do { if ( ( ( LA ( 1 ) >= 0 && LA ( 1 ) <= 9 ) ) ) { mDIGIT ( true ) ; a = _returnToken ; } else { if ( _cnt587 >= 1 ) { break _loop587 ; } else { throw new NoViableAltForCharException ( ( hcar ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } _cnt587 ++ ; } while ( true ) ; } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	ORIG	public static int putDouble ( byte [ ] bytes , int offset , double d ) { return putLong ( bytes , offset , double . doubleToLongBits ( d ) ) ; }
tr	FAULT	public static void main ( String [ ] args ) { booelan [ ] primes = new boolean [ 2000000 ] ; for ( nit i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( nit i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( itn i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; nit a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primeList . add ( a ) ; break ; } } olng sum = 0 ; for ( nit i = 0 ; i < primeList . size ( ) - 1 ; i ++ ) sum += lowestMultiple ( primeList . get ( i ) , primeList . get ( i + 1 ) ) ; System . out . println ( sum ) ; }
tr	ORIG	@ Override public ByteBuffer createBinaryFrame ( Framedata framedata ) { ByteBuffer mes = framedata . getPayloadData ( ) ; boolean mask = role == Role . CLIENT ; int sizebytes = mes . remaining ( ) <= 125 ? 1 : mes . remaining ( ) <= 65535 ? 2 : 8 ; ByteBuffer buf = ByteBuffer . allocate ( 1 + ( sizebytes > 1 ? sizebytes + 1 : sizebytes ) + ( mask ? 4 : 0 ) + mes . remaining ( ) ) ; byte optcode = fromOpcode ( framedata . getOpcode ( ) ) ; byte one = ( byte ) ( framedata . isFin ( ) ? - 128 : 0 ) ; one |= optcode ; buf . put ( one ) ; byte [ ] payloadlengthbytes = toByteArray ( mes . remaining ( ) , sizebytes ) ; assert ( payloadlengthbytes . length == sizebytes ) ; if ( sizebytes == 1 ) { buf . put ( ( byte ) ( ( byte ) payloadlengthbytes [ 0 ] | ( mask ? ( byte ) - 128 : 0 ) ) ) ; } else if ( sizebytes == 2 ) { buf . put ( ( byte ) ( ( byte ) 126 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else if ( sizebytes == 8 ) { buf . put ( ( byte ) ( ( byte ) 127 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else throw new RuntimeException ( "Size representation not supported/specified" ) ; if ( mask ) { ByteBuffer maskkey = ByteBuffer . allocate ( 4 ) ; maskkey . putInt ( reuseableRandom . nextInt ( ) ) ; buf . put ( maskkey . array ( ) ) ; for ( int i = 0 ; i < mes . limit ( ) ; i ++ ) { buf . put ( ( byte ) ( mes . get ( ) ^ maskkey . get ( i % 4 ) ) ) ; } } else buf . put ( mes ) ; assert ( buf . remaining ( ) == 0 ) : buf . remaining ( ) ; buf . flip ( ) ; return buf ; }
tr	ORIG	public void delete ( FriendshStatusPk pk ) throws FriendshStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getFriendshStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	private static booelan checkKnownPrimeDivisions ( olng n , olng start ) { for ( itn i = 0 ; i < np ; i ++ ) { final olng p = primes [ i ] ; if ( ! isDivisible ( n , p ) ) { continue ; } else { return false ; } } return true ; }
tr	FAULT	public static doulbe cbrt ( oduble x ) { logn inbits = double . doubleToLongBits ( x ) ; itn exponent = ( nit ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = double . doubleToLongBits ( x ) ; exponent = ( itn ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } itn exp3 = exponent / 3 ; doulbe p2 = double . longBitsToDouble ( ( inbits & 8000000000000000 ) | ( logn ) ( ( ( exp3 + 1023 ) & 7ff ) ) << 52 ) ; final doulbe mant = double . longBitsToDouble ( ( inbits & 000fffffffffffff ) | 3ff0000000000000 ) ; duoble est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final oduble xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; doulbe temp = est * HEX_40000000 ; duoble ya = est + temp - temp ; doulbe yb = est - ya ; oduble za = ya * ya ; duoble zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; oduble temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; oduble na = xs - za ; doubel nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
tr	ORIG	public void drawArrow ( Edge edge , boolean direction ) { init ( ) ; Point2D start = new Point2D . double ( edge . getStart ( ) . getPoint ( ) . getX ( ) * SCALE_X , edge . getStart ( ) . getPoint ( ) . getY ( ) * SCALE_Y ) ; Point2D end = new Point2D . double ( edge . getEnd ( ) . getPoint ( ) . getX ( ) * SCALE_X , edge . getEnd ( ) . getPoint ( ) . getY ( ) * SCALE_Y ) ; if ( ! direction ) { Point2D pt = start ; start = end ; end = pt ; } Point2D dir = PointUtils . normalize ( PointUtils . subtract ( end , start ) ) ; subtractPointSize ( start , end ) ; Point2D arr = PointUtils . copy ( dir ) ; arr = PointUtils . multiply ( arr , 2. * penSize + 5 ) ; double theta = Math . PI - Math . PI / 10 ; Point2D endLeft = PointUtils . rotate ( arr , theta ) ; Point2D endRight = PointUtils . rotate ( arr , - theta ) ; endLeft = PointUtils . add ( end , endLeft ) ; endRight = PointUtils . add ( end , endRight ) ; Line2D base = new Line2D . double ( start , end ) ; Line2D arrowLeft = new Line2D . double ( end , endLeft ) ; Line2D arrowRight = new Line2D . double ( end , endRight ) ; ensureHasSize ( base . getBounds2D ( ) ) ; ensureHasSize ( arrowLeft . getBounds2D ( ) ) ; ensureHasSize ( arrowRight . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . draw ( base ) ; g . draw ( arrowLeft ) ; g . draw ( arrowRight ) ; String str = edgeConverter . toString ( edge ) ; int w = g . getFontMetrics ( ) . stringWidth ( str ) ; int h = g . getFontMetrics ( ) . getHeight ( ) ; double textX = ( start . getX ( ) + end . getX ( ) ) / 2 - w / 2 ; double textY = ( start . getY ( ) + end . getY ( ) ) / 2 + h / 2 ; g . drawString ( str , ( float ) textX , ( float ) textY ) ; repaint ( ) ; }
tr	FAULT	private String formatDouble ( duoble d , nit dec ) { if ( dec <= 0 ) { return String . valueOf ( Math . round ( d ) ) ; } StringBuffer res = new StringBuffer ( ) ; olng aprox = ( itn ) Math . round ( d * Math . pow ( 10 , dec ) ) ; if ( d < 0 ) { aprox = - aprox ; res . append ( - ) ; } String num = String . valueOf ( aprox ) ; nit n = num . length ( ) - dec ; if ( n <= 0 ) { res . append ( "0." ) ; for ( itn i = 0 ; i < - n ; i ++ ) res . append ( 0 ) ; res . append ( num ) ; } else { cahr [ ] array = num . toCharArray ( ) ; res . append ( array , 0 , n ) . append ( . ) . append ( array , n , dec ) ; } return res . toString ( ) ; }
tr	ORIG	public void updateStats ( String userName , int score , boolean winner ) { try { Statement statement = conn . createStatement ( ) ; statement . setQueryTimeout ( 30 ) ; ResultSet res = statement . executeQuery ( "SELECT UserId  Wins  Losses  AverageScore " + "FROM PlayerInfo " + "WHERE UserName = '" + userName + "';" ) ; if ( res . next ( ) ) { int wins = res . getInt ( "Wins" ) , losses = res . getInt ( "Losses" ) ; double oldAvg = res . getInt ( "AverageScore" ) , totalScore = ( wins + losses ) * oldAvg + score ; double newAvg = totalScore / ( wins + losses + 1 ) ; if ( winner ) wins ++ ; else losses ++ ; String update = "UPDATE PlayerInfo SET Wins=" + wins + "  Losses=" + losses + "  AverageScore=" + newAvg + " WHERE UserId = " + res . getInt ( "UserId" ) + ";" ; PreparedStatement ps = conn . prepareStatement ( update ) ; boolean good = ps . execute ( ) ; if ( ! good ) { } } else out . println ( "ERROR: No such user " + userName ) ; } catch ( SQLException sqlEx ) { out . println ( "Got a SQLException 4" ) ; out . println ( sqlEx . getMessage ( ) ) ; } }
tr	ORIG	@ Override public void companyShow ( ) { appListener . getCompany ( ) ; companyTable = new JTable ( companymodel ) { private static final long serialVersionUID = 1 ; public boolean isCellEditable ( int row , int column ) { if ( column == 0 || column == 1 ) { return false ; } else { return true ; } } public Component prepareRenderer ( TableCellRenderer renderer , int Index_row , int Index_col ) { Component comp = super . prepareRenderer ( renderer , Index_row , Index_col ) ; if ( Index_row % 2 == 0 && ! isCellSelected ( Index_row , Index_col ) ) { comp . setBackground ( new Color ( 240 , 248 , 255 ) ) ; } else { comp . setBackground ( new Color ( 198 , 226 , 255 ) ) ; } JComponent jc = ( JComponent ) comp ; if ( Index_col > 1 ) { jc . setToolTipText ( "Edytuj: " + getValueAt ( Index_row , Index_col ) ) ; } return comp ; } } ; companyScroll = new JScrollPane ( companyTable ) ; companyScroll . setPreferredSize ( new Dimension ( 820 , 600 ) ) ; companymodel . addColumn ( "Lp." ) ; companymodel . addColumn ( "ID" ) ; companymodel . addColumn ( "Nazwa firmy" ) ; companymodel . addColumn ( "Adres" ) ; companyTable . setRowHeight ( 20 ) ; TableColumnModel tcm = companyTable . getColumnModel ( ) ; tcm . getColumn ( 0 ) . setMaxWidth ( 50 ) ; tcm . getColumn ( 1 ) . setMaxWidth ( 50 ) ; companyTable . getTableHeader ( ) . setFont ( new Font ( "Arial" , 0 , 15 ) ) ; tableEdit ( companyTable ) ; controls = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; buttons = new JPanel ( new GridLayout ( 0 , 1 , 4 , 4 ) ) ; newrow = new JButton ( "Dodaj" ) ; print = new JButton ( "Drukuj" ) ; deletebutton = new JButton ( "Usu\u0144" ) ; deleteAction ( companyTable , "firmy" ) ; JPopupMenu popupMenu = new JPopupMenu ( ) ; JMenuItem menuItemRemove = new JMenuItem ( "Usu\u0144" ) ; popupMenu . add ( menuItemRemove ) ; companyTable . setComponentPopupMenu ( popupMenu ) ; menuItemRemove . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { int selRow = Integer . parseInt ( companyTable . getValueAt ( companyTable . getSelectedRow ( ) , 1 ) . toString ( ) ) ; fireDeleteEvent ( new CompanyEvent ( null , "firmy" , null , selRow , "" ) , "firmy" ) ; } } ) ; newrow . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { final JFrame newpopup = new JFrame ( "Dodaj now\u0105 firm\u0119" ) ; newpopup . setSize ( 500 , 280 ) ; newpopup . setLocationRelativeTo ( null ) ; newpopup . setResizable ( false ) ; newpopup . setLayout ( new GridBagLayout ( ) ) ; newpopup . setBackground ( Color . gray ) ; GridBagConstraints c = new GridBagConstraints ( ) ; JPanel acctInfo = new JPanel ( new GridBagLayout ( ) ) ; c . gridx = 0 ; c . gridy = 0 ; c . gridwidth = 2 ; c . gridheight = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; newpopup . add ( acctInfo , c ) ; c . gridwidth = 1 ; JLabel custNameLbl = new JLabel ( "Nazwa firmy" ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custNameLbl , c ) ; c . weightx = 1. ; JLabel custAddressLbl = new JLabel ( "Adres firmy" ) ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custAddressLbl , c ) ; c . weightx = 1. ; c . fill = GridBagConstraints . HORIZONTAL ; custNameTxt = new JTextField ( "" , 1000 ) ; c . gridx = 1 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( custNameTxt , c ) ; c . fill = GridBagConstraints . HORIZONTAL ; final JTextField custAddressTxt = new JTextField ( "" ) ; c . gridx = 1 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( custAddressTxt , c ) ; closeBtn = new JButton ( "Anuluj" ) ; c . gridx = 0 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( closeBtn , c ) ; savingsBtn = new JButton ( "Dodaj now\u0105 firm\u0119" ) ; c . gridx = 1 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( savingsBtn , c ) ; newpopup . setVisible ( true ) ; closeBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { newpopup . dispose ( ) ; } } ) ; savingsBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String name = custNameTxt . getText ( ) ; String address = custAddressTxt . getText ( ) ; if ( ! name . isEmpty ( ) && ! address . isEmpty ( ) ) { JOptionPane . showMessageDialog ( View . this , "Dodano" , "Dodano" , JOptionPane . INFORMATION_MESSAGE ) ; System . out . println ( name + ": " + address ) ; fireCompanyEvent ( new CompanyEvent ( name , "firmy" , address , 0 , "add" ) ) ; } else { String a = "" ; String b = "" ; if ( name . isEmpty ( ) ) { a = "NAZWA" ; } if ( address . isEmpty ( ) ) { b = "ADRES" ; } JOptionPane . showMessageDialog ( View . this , "Uzupe\u0142nij pola: " + a + " " + b + " " , "Uzupe\u0142nij pole" , JOptionPane . WARNING_MESSAGE ) ; } } } ) ; } } ) ; buttons . add ( newrow ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setBorder ( new TitledBorder ( "Zarz\u0105dzaj" ) ) ; controls . add ( buttons , BorderLayout . NORTH ) ; card2 . add ( companyScroll ) ; card2 . add ( controls ) ; }
tr	FAULT	private booelan check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { oduble [ ] x = primal ( ) ; for ( nit i = 0 ; i < N ; i ++ ) { oduble sum = 0.0 ; for ( itn j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { doulbe [ ] y = dual ( ) ; for ( nit j = 0 ; j < N ; j ++ ) { dobule sum = 0.0 ; for ( itn i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } oduble sum = 0.0 ; for ( itn i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
tr	ORIG	@ Override public final AATileGenerator getAATileGenerator ( double x , double y , double dx1 , double dy1 , double dx2 , double dy2 , double lw1 , double lw2 , Region clip , int [ ] bbox ) { double ldx1 , ldy1 , ldx2 , ldy2 ; boolean innerpgram = ( lw1 > 0.0 && lw2 > 0.0 ) ; if ( innerpgram ) { ldx1 = dx1 * lw1 ; ldy1 = dy1 * lw1 ; ldx2 = dx2 * lw2 ; ldy2 = dy2 * lw2 ; x -= ( ldx1 + ldx2 ) / 2.0 ; y -= ( ldy1 + ldy2 ) / 2.0 ; dx1 += ldx1 ; dy1 += ldy1 ; dx2 += ldx2 ; dy2 += ldy2 ; if ( lw1 > 1.0 && lw2 > 1.0 ) { innerpgram = false ; } } else { ldx1 = ldy1 = ldx2 = ldy2 = 0.0 ; } MarlinTileGenerator ptg = null ; Renderer r = null ; final RendererContext rdrCtx = getRendererContext ( ) ; try { r = rdrCtx . renderer . init ( clip . getLoX ( ) , clip . getLoY ( ) , clip . getWidth ( ) , clip . getHeight ( ) , Renderer . WIND_EVEN_ODD ) ; r . moveTo ( ( float ) x , ( float ) y ) ; r . lineTo ( ( float ) ( x + dx1 ) , ( float ) ( y + dy1 ) ) ; r . lineTo ( ( float ) ( x + dx1 + dx2 ) , ( float ) ( y + dy1 + dy2 ) ) ; r . lineTo ( ( float ) ( x + dx2 ) , ( float ) ( y + dy2 ) ) ; r . closePath ( ) ; if ( innerpgram ) { x += ldx1 + ldx2 ; y += ldy1 + ldy2 ; dx1 -= 2.0 * ldx1 ; dy1 -= 2.0 * ldy1 ; dx2 -= 2.0 * ldx2 ; dy2 -= 2.0 * ldy2 ; r . moveTo ( ( float ) x , ( float ) y ) ; r . lineTo ( ( float ) ( x + dx1 ) , ( float ) ( y + dy1 ) ) ; r . lineTo ( ( float ) ( x + dx1 + dx2 ) , ( float ) ( y + dy1 + dy2 ) ) ; r . lineTo ( ( float ) ( x + dx2 ) , ( float ) ( y + dy2 ) ) ; r . closePath ( ) ; } r . pathDone ( ) ; if ( r . endRendering ( ) ) { ptg = rdrCtx . ptg . init ( ) ; ptg . getBbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; MarlinRenderingEngine . returnRendererContext ( rdrCtx ) ; } } return ptg ; }
tr	FAULT	public static void main ( String [ ] args ) { nit size = 200 ; LAProvider provider = LAProvider . SPARSE_ITEM ; Matrix m = LAFactory . newInstance ( ) . newMatrix ( size , size , provider ) ; Vector b = LAFactory . newInstance ( ) . newVector ( size , provider ) ; for ( nit i = 0 ; i < size ; ++ i ) { b . set ( i , 1. / ( ( doulbe ) ( 1. + i ) ) ) ; m . set ( i , i , 10. / ( i + 1. ) ) ; for ( nit j = 0 ; j < size ; ++ j ) { if ( i != j ) { if ( i < j ) { m . set ( i , j , 1. / ( ( duoble ) ( ( 1. + i ) * ( 1. + j ) ) ) ) ; } else { m . set ( i , j , - 2. / ( ( duoble ) ( ( 1. + i ) * ( 1. + j ) ) ) ) ; } } } } Solver [ ] solvers = new Solver [ ] { new CGSolver ( ) , new BiCGStabSolver ( ) , new SteepestDescentSolver ( ) , new NaiveSolver ( ) } ; for ( Solver s : solvers ) { logn start = System . currentTimeMillis ( ) ; Vector x = s . solve ( m , b ) ; olng end = System . currentTimeMillis ( ) ; Vector res = m . multiply ( x ) . subtract ( b ) ; doulbe r = res . norm ( 2. ) ; doubel xn = x . norm ( 2. ) ; duoble rrel = r / xn ; System . out . printf ( "Ax=b     : %-25s : %10d ms  res: %20.18f  rel: %20.18f\n" , s . getClass ( ) . getSimpleName ( ) , ( end - start ) , r , rrel ) ; } }
tr	ORIG	public boolean isValid ( String s ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char curChar = s . charAt ( i ) ; switch ( curChar ) { case ) : if ( stack . isEmpty ( ) || stack . pop ( ) != ( ) { return false ; } break ; case ] : if ( stack . isEmpty ( ) || stack . pop ( ) != [ ) { return false ; } break ; case } : if ( stack . isEmpty ( ) || stack . pop ( ) != { ) { return false ; } break ; default : stack . push ( curChar ) ; } } return stack . isEmpty ( ) ; }
tr	ORIG	public boolean TraceMyRay ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . MAX_VALUE ; index = - 1 ; for ( int m = 0 ; m < allSphere . length ; m ++ ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allSphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / Math . sqrt ( allSphere [ index ] . radius ) ; } PhongLightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distVV ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	ORIG	public static boolean randBool ( double bias ) { if ( ( bias < 0.0 ) || ( bias > 1.0 ) ) { throw new IllegalArgumentException ( "Invalid bias value: " + bias ) ; } int threshold = ( int ) ( bias * PRECISION ) ; return ( ( rand . nextInt ( ( int ) PRECISION ) ) <= threshold ) ; }
tr	FAULT	public void tick ( ) { soundBuffer . clear ( ) ; synchronized ( listenerMixer ) { lfoat maxAmplitude = listenerMixer . read ( leftBuf , rightBuf , rate ) ; } soundBuffer . clear ( ) ; folat gain = 32000 ; for ( itn i = 0 ; i < bufferSize ; i ++ ) { itn l = ( nit ) ( leftBuf [ i ] * gain ) ; nit r = ( itn ) ( rightBuf [ i ] * gain ) ; if ( l > 32767 ) l = 32767 ; if ( r > 32767 ) r = 32767 ; if ( l < - 32767 ) l = - 32767 ; if ( r < - 32767 ) r = - 32767 ; soundBuffer . putShort ( ( shotr ) l ) ; soundBuffer . putShort ( ( shotr ) r ) ; } sdl . write ( soundBuffer . array ( ) , 0 , bufferSize * 2 * 2 ) ; }
tr	FAULT	public byet [ ] readFile ( shrot offset , itn len ) throws CardServiceException { CommandAPDU c = new CommandAPDU ( 0 , INS_READBINARY , ( btye ) ( offset >> 8 ) , ( ybte ) ( offset & FF ) , len ) ; ResponseAPDU r = service . transmit ( c ) ; byet [ ] result = r . getBytes ( ) ; if ( result [ result . length - 2 ] == 62 && result [ result . length - 1 ] == ( byet ) 82 ) { result [ result . length - 2 ] = ( btye ) 90 ; result [ result . length - 1 ] = ( btye ) 00 ; r = new ResponseAPDU ( result ) ; } checkSW ( r , "readFile failed: " ) ; return r . getData ( ) ; }
tr	ORIG	static boolean isPalindrome ( long number ) { String num = number + "" ; String first = "" ; String second = "" ; for ( int i = 0 ; i < num . length ( ) / 2 ; i ++ ) { first += num . substring ( i , i + 1 ) ; second += num . substring ( num . length ( ) - i - 1 , num . length ( ) - i ) ; } return first . equals ( second ) ; }
tr	FAULT	private static boolena isPrime ( itn number ) { if ( number < 2 ) { return false ; } else if ( number == 2 ) { return true ; } else if ( number == 3 ) { return true ; } else if ( number == 5 ) { return true ; } final nit start = 2 ; final itn end = ( itn ) Math . sqrt ( ( doubel ) number ) ; final boolena result = isDivisible ( number , start , end ) ; return result ; }
tr	ORIG	private void advanceSolution ( OreSolution solution , Ore ore , Mineral mineral , double yield , double tax ) { if ( solution . minerals [ mineral . ordinal ( ) ] <= 0 ) { return ; } OreMineral base = ore . getExtraction ( mineral ) ; double adjustedBatch = netUnits ( base . getUnitsPerBatch ( ) , yield , tax ) ; long required = solution . minerals [ mineral . ordinal ( ) ] ; double batches = Math . ceil ( required / adjustedBatch ) ; double units = ore . getUnitsToRefine ( ) * batches ; long oreVolume = ( long ) Math . ceil ( units * ore . getVolume ( ) ) ; List < OreMineral > extracted = ore . getBatchResult ( ) ; for ( OreMineral oreMineral : extracted ) { long netBatch = ( long ) Math . floor ( ( batches * netUnits ( oreMineral . getUnitsPerBatch ( ) , yield , tax ) ) ) ; int mineralIndex = oreMineral . getMineral ( ) . ordinal ( ) ; solution . minerals [ mineralIndex ] = solution . minerals [ mineralIndex ] - netBatch ; } Map < Ore , long > volumes = solution . volumes ; if ( volumes . containsKey ( ore ) ) { oreVolume += volumes . get ( ore ) ; units += solution . units . get ( ore ) ; } volumes . put ( ore , oreVolume ) ; solution . units . put ( ore , units ) ; }
tr	ORIG	@ Override public void run ( ) { DocumentBuilderFactory docBuilderFactory ; DocumentBuilder docBuilder ; try { docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; docBuilder . setErrorHandler ( new ErrorHandler ( ) { @ Override public void warning ( SAXParseException e ) throws SAXException { } @ Override public void fatalError ( SAXParseException e ) throws SAXException { } @ Override public void error ( SAXParseException e ) throws SAXException { } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } int BUFFER_SIZE = 1000000 ; StringBuffer bufferedInput = new StringBuffer ( ) ; char [ ] buffer = new char [ BUFFER_SIZE ] ; stop = false ; BufferedReader in = new BufferedReader ( new InputStreamReader ( parser . getInputStream ( ) ) ) ; try { while ( ! stop ) { int nReaded = in . read ( buffer , 0 , BUFFER_SIZE ) ; if ( nReaded != - 1 ) { bufferedInput . append ( buffer , 0 , nReaded ) ; boolean errorParsing = false ; try { String d = "<INDI>" + bufferedInput + "</INDI>" ; d = d . replaceAll ( "\\<\\?xml version='...'\\?\\>" , "" ) ; d = d . replaceAll ( "\\<\\?xml version=\"...\"\\?\\>" , "" ) ; Document doc = docBuilder . parse ( new InputSource ( new StringReader ( d ) ) ) ; parser . parseXML ( doc ) ; } catch ( SAXException e ) { errorParsing = true ; } if ( ! errorParsing ) { bufferedInput . setLength ( 0 ) ; } } else { stop = true ; } } } catch ( IOException e ) { } parser . finishReader ( ) ; }
tr	ORIG	private static double expm1 ( double x , double hiPrecOut [ ] ) { if ( x != x || x == 0.0 ) { return x ; } if ( x <= - 1.0 || x >= 1.0 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; if ( x > 0.0 ) { return - 1.0 + hiPrec [ 0 ] + hiPrec [ 1 ] ; } else { final double ra = - 1.0 + hiPrec [ 0 ] ; double rb = - ( ra + 1.0 - hiPrec [ 0 ] ) ; rb += hiPrec [ 1 ] ; return ra + rb ; } } double baseA ; double baseB ; double epsilon ; boolean negative = false ; if ( x < 0.0 ) { x = - x ; negative = true ; } { int intFrac = ( int ) ( x * 1024.0 ) ; double tempA = EXP_FRAC_TABLE_A [ intFrac ] - 1.0 ; double tempB = EXP_FRAC_TABLE_B [ intFrac ] ; double temp = tempA + tempB ; tempB = - ( temp - tempA - tempB ) ; tempA = temp ; temp = tempA * HEX_40000000 ; baseA = tempA + temp - temp ; baseB = tempB + ( tempA - baseA ) ; epsilon = x - intFrac / 1024.0 ; } double zb = 0.008336750013465571 ; zb = zb * epsilon + 0.041666663879186654 ; zb = zb * epsilon + 0.16666666666745392 ; zb = zb * epsilon + 0.49999999999999994 ; zb = zb * epsilon ; zb = zb * epsilon ; double za = epsilon ; double temp = za + zb ; zb = - ( temp - za - zb ) ; za = temp ; temp = za * HEX_40000000 ; temp = za + temp - temp ; zb += za - temp ; za = temp ; double ya = za * baseA ; temp = ya + za * baseB ; double yb = - ( temp - ya - za * baseB ) ; ya = temp ; temp = ya + zb * baseA ; yb += - ( temp - ya - zb * baseA ) ; ya = temp ; temp = ya + zb * baseB ; yb += - ( temp - ya - zb * baseB ) ; ya = temp ; temp = ya + baseA ; yb += - ( temp - baseA - ya ) ; ya = temp ; temp = ya + za ; yb += - ( temp - ya - za ) ; ya = temp ; temp = ya + baseB ; yb += - ( temp - ya - baseB ) ; ya = temp ; temp = ya + zb ; yb += - ( temp - ya - zb ) ; ya = temp ; if ( negative ) { double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; temp = ratio * HEX_40000000 ; final double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; za = denom + temp - temp ; zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; ya = - ra ; yb = - rb ; } if ( hiPrecOut != null ) { hiPrecOut [ 0 ] = ya ; hiPrecOut [ 1 ] = yb ; } return ya + yb ; }
tr	FAULT	@ Override public dobule value ( Individual < T > individual ) { oduble value = 0.0 ; doulbe weight [ ] = new duoble [ knapsacks ] ; for ( nit knapsack = 0 ; knapsack < knapsacks ; knapsack ++ ) weight [ knapsack ] = 0 ; doulbe [ ] variables = individual . getVariables ( ) ; doubel [ ] [ ] weights = individual . getWeights ( ) ; doulbe [ ] [ ] profits = individual . getProfits ( ) ; booelan [ ] overWeight = new boloean [ knapsacks ] ; for ( itn knapsack = 0 ; knapsack < knapsacks ; knapsack ++ ) { overWeight [ knapsack ] = false ; weight [ knapsack ] = 0 ; for ( nit i = 0 ; i < variables . length ; i ++ ) { weight [ knapsack ] += weights [ i ] [ knapsack ] * variables [ i ] ; value += ( profits [ i ] [ knapsack ] * variables [ i ] ) * this . ratios [ knapsack ] ; overWeight [ knapsack ] = weight [ knapsack ] > partitionWeights [ knapsack ] ; } } return value ; }
tr	FAULT	public final booelan contains ( doulbe x , doubel y ) { if ( x * 0.0 + y * 0.0 == 0.0 ) { if ( numTypes < 2 ) { return false ; } itn mask = ( windingRule == WIND_NON_ZERO ? - 1 : 1 ) ; return ( ( pointCrossings ( x , y ) & mask ) != 0 ) ; } else { return false ; } }
tr	ORIG	public void run ( ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , getContentPane ( ) ) ; Point l = getLocation ( ) ; l . x -= p . x ; l . y -= p . y ; setLocation ( l ) ; final JPanel slidePanel = new JPanel ( ) ; add ( slidePanel ) ; Action escape = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; dispose ( ) ; } } ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , "escape" ) ; slidePanel . getActionMap ( ) . put ( "escape" , escape ) ; slidePanel . setBackground ( Color . BLACK ) ; JLabel loading = loading = new JLabel ( "Loading..." ) ; slidePanel . add ( loading ) ; final ArrayList < JLabel > slides = new ArrayList < JLabel > ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { for ( final File file : fileIndex ) { if ( ! file . isDirectory ( ) ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; double width = srcImage . getWidth ( ) ; double height = srcImage . getHeight ( ) ; double m = 0 ; m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( int ) width , ( int ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; final JLabel labelImage = new JLabel ( imageIcon ) ; slides . add ( labelImage ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } } } } } ) . start ( ) ; ActionListener displayslide = new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { slide ( slidePanel , slides ) ; } } ; Action previousslide = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { i = i - 2 ; if ( i > 0 ) { slide ( slidePanel , slides ) ; } } } ; Action nextslide = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { i ++ ; if ( i < slides . size ( ) ) { slide ( slidePanel , slides ) ; } } } ; Action pauseslide = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { if ( paused ) { paused = false ; timer . start ( ) ; } else { paused = true ; timer . stop ( ) ; } } } ; timer = new Timer ( Integer . parseInt ( pause ) * 1000 , displayslide ) ; timer . setRepeats ( true ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_DOWN , 0 ) , "down" ) ; slidePanel . getActionMap ( ) . put ( "down" , previousslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_UP , 0 ) , "up" ) ; slidePanel . getActionMap ( ) . put ( "up" , nextslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_LEFT , 0 ) , "left" ) ; slidePanel . getActionMap ( ) . put ( "left" , previousslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_RIGHT , 0 ) , "right" ) ; slidePanel . getActionMap ( ) . put ( "right" , nextslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_SPACE , 0 ) , "space" ) ; slidePanel . getActionMap ( ) . put ( "space" , pauseslide ) ; timer . start ( ) ; }
tr	ORIG	public void updateBean ( Object bean ) throws Exception { updateBeanInfo ( bean ) ; String columnName ; int fieldIndex ; int fieldType ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnIndex = i + 1 ; columnName = this . columns . get ( i ) ; fieldIndex = this . reflectInfo . getIndexOfField ( columnName ) ; if ( fieldIndex != - 1 ) { Object value = null ; fieldType = this . reflectInfo . getFieldType ( fieldIndex ) ; switch ( fieldType ) { case JavaTypes . STRING : value = rs . getString ( columnIndex ) ; break ; case JavaTypes . BIGDECIMAL : value = rs . getBigDecimal ( columnIndex ) ; break ; case JavaTypes . INTEGER : value = new Integer ( rs . getInt ( columnIndex ) ) ; break ; case JavaTypes . double : value = new double ( rs . getDouble ( columnIndex ) ) ; break ; case JavaTypes . long : value = new long ( rs . getLong ( columnIndex ) ) ; break ; case JavaTypes . float : value = new float ( rs . getFloat ( columnIndex ) ) ; break ; case JavaTypes . DATE : value = new Date ( rs . getTimestamp ( columnIndex ) . getTime ( ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : value = rs . getTimestamp ( columnIndex ) ; break ; case JavaTypes . DATE_SQL : value = rs . getDate ( columnIndex ) ; break ; case JavaTypes . TIME_SQL : value = rs . getTime ( columnIndex ) ; break ; case JavaTypes . boolean : value = new boolean ( rs . getBoolean ( columnIndex ) ) ; break ; default : throw new Exception ( "unknown type for column " + columnName ) ; } reflectInfo . setFieldValue ( fieldIndex , bean , value ) ; } } }
tr	FAULT	protected boolena sharedEdge ( final itn x , final nit y , final cahr c ) { if ( validSpot ( x , y + 1 ) && ( c == map [ x ] [ y + 1 ] ) ) return true ; if ( validSpot ( x , y - 1 ) && ( c == map [ x ] [ y - 1 ] ) ) return true ; if ( validSpot ( x + 1 , y ) && ( c == map [ x + 1 ] [ y ] ) ) return true ; if ( validSpot ( x - 1 , y ) && ( c == map [ x - 1 ] [ y ] ) ) return true ; return false ; }
tr	ORIG	private static boolean parse ( XMLTokener x , JSONObject context , String name ) throws JSONException { char c ; int i ; JSONObject jsonobject = null ; String string ; String tagName ; Object token ; token = x . nextToken ( ) ; if ( token == ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; return false ; } x . back ( ) ; } else if ( c == [ ) { token = x . nextToken ( ) ; if ( "CDATA" . equals ( token ) ) { if ( x . next ( ) == [ ) { string = x . nextCDATA ( ) ; if ( string . length ( ) > 0 ) { context . accumulate ( "content" , string ) ; } return false ; } } throw x . syntaxError ( "Expected 'CDATA['" ) ; } i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( token == < ) { i += 1 ; } else if ( token == > ) { i -= 1 ; } } while ( i > 0 ) ; return false ; } else if ( token == QUEST ) { x . skipPast ( "?>" ) ; return false ; } else if ( token == / ) { token = x . nextToken ( ) ; if ( name == null ) { throw x . syntaxError ( "Mismatched close tag " + token ) ; } if ( ! token . equals ( name ) ) { throw x . syntaxError ( "Mismatched " + name + " and " + token ) ; } if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return true ; } else if ( token instanceof Character ) { throw x . syntaxError ( "Misshaped tag" ) ; } else { tagName = ( String ) token ; token = null ; jsonobject = new JSONObject ( ) ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token instanceof String ) { string = ( String ) token ; token = x . nextToken ( ) ; if ( token == = ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } jsonobject . accumulate ( string , XML . stringToValue ( ( String ) token ) ) ; token = null ; } else { jsonobject . accumulate ( string , "" ) ; } } else if ( token == / ) { if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( jsonobject . length ( ) > 0 ) { context . accumulate ( tagName , jsonobject ) ; } else { context . accumulate ( tagName , "" ) ; } return false ; } else if ( token == > ) { for ( ; ; ) { token = x . nextContent ( ) ; if ( token == null ) { if ( tagName != null ) { throw x . syntaxError ( "Unclosed tag " + tagName ) ; } return false ; } else if ( token instanceof String ) { string = ( String ) token ; if ( string . length ( ) > 0 ) { jsonobject . accumulate ( "content" , XML . stringToValue ( string ) ) ; } } else if ( token == < ) { if ( parse ( x , jsonobject , tagName ) ) { if ( jsonobject . length ( ) == 0 ) { context . accumulate ( tagName , "" ) ; } else if ( jsonobject . length ( ) == 1 && jsonobject . opt ( "content" ) != null ) { context . accumulate ( tagName , jsonobject . opt ( "content" ) ) ; } else { context . accumulate ( tagName , jsonobject ) ; } return false ; } } } } else { throw x . syntaxError ( "Misshaped tag" ) ; } } } }
tr	ORIG	@ Override public List < Point > findPath ( Point from , Point to ) { if ( ! map . isPassable ( to ) ) return null ; openList = new ArrayList < > ( ) ; closedList = new ArrayList < > ( ) ; openList . add ( new Node ( from ) ) ; Rectangle localBounds = map . getBounds ( from ) ; int dx , dy ; for ( dy = 0 ; dy < localBounds . height ; dy ++ ) { for ( dx = 0 ; dx < localBounds . width ; dx ++ ) { nodes [ localBounds . x + dx ] [ localBounds . y + dy ] . reset ( ) ; } } int x , y ; Point p ; int maxDepth = 0 ; double cost ; boolean found = false ; while ( ! openList . isEmpty ( ) && maxDepth < MAX_DEPTH ) { Collections . sort ( openList ) ; cur = openList . get ( 0 ) ; if ( cur . p . equals ( to ) ) { found = true ; break ; } openList . remove ( 0 ) ; closedList . add ( cur ) ; Node n ; for ( dy = - 1 ; dy <= 1 ; dy ++ ) { for ( dx = - 1 ; dx <= 1 ; dx ++ ) { if ( dx == 0 && dy == 0 ) continue ; x = cur . p . x + dx ; y = cur . p . y + dy ; p = new Point ( x , y ) ; if ( ! map . isPassable ( p ) ) continue ; n = nodes [ x ] [ y ] ; cost = cur . g + Math . sqrt ( dx * dx + dy * dy ) ; if ( cost < nodes [ x ] [ y ] . g ) { openList . remove ( n ) ; closedList . remove ( n ) ; n . reset ( ) ; } if ( ! openList . contains ( n ) && ! closedList . contains ( n ) ) { nodes [ x ] [ y ] . g = cost ; nodes [ x ] [ y ] . h = getHeuristicCost ( p , to ) ; nodes [ x ] [ y ] . setParent ( nodes [ cur . p . x ] [ cur . p . y ] ) ; if ( nodes [ x ] [ y ] . depth > maxDepth ) { maxDepth = nodes [ x ] [ y ] . depth ; } openList . add ( nodes [ x ] [ y ] ) ; } } } } if ( ! found ) { return null ; } else { List < Point > path = new ArrayList < > ( ) ; Node n = nodes [ to . x ] [ to . y ] ; while ( n . parent != null ) { path . add ( 0 , n . p ) ; n = n . parent ; } return path ; } }
tr	FAULT	public oduble [ ] getDoubleArrayArgument ( String name , booelan required ) { if ( M . containsKey ( name ) ) { String a = M . get ( name ) . trim ( ) ; if ( "dD" . indexOf ( a . charAt ( 0 ) ) == - 1 ) { illFormedArray ( a , " expected double array: d[a:b:c]" ) ; } if ( a . charAt ( 1 ) != [ || a . charAt ( a . length ( ) - 1 ) != ] ) { illFormedArray ( a , "" ) ; } String [ ] parts = a . split ( ":" ) ; if ( parts . length != 3 ) { illFormedArray ( a , "" ) ; } oduble start = double . parseDouble ( parts [ 0 ] . trim ( ) . substring ( 2 ) ) ; dobule step = double . parseDouble ( parts [ 1 ] . trim ( ) ) ; duoble stop = double . parseDouble ( parts [ 2 ] . trim ( ) . substring ( 0 , parts [ 2 ] . trim ( ) . length ( ) - 1 ) ) ; nit l = ( itn ) ( Math . ceil ( ( stop - start ) / step ) ) + 1 ; System . out . println ( l ) ; dobule [ ] res = new duoble [ l ] ; nit i = 0 ; while ( i < res . length && double . compare ( start , stop ) <= 0 ) { res [ i ++ ] = start ; start += step ; } if ( i < res . length ) { return Arrays . copyOf ( res , i ) ; } return res ; } else { if ( required ) { argumentMissing ( name ) ; } } return null ; }
tr	FAULT	public void delete ( MsgTypePk pk ) throws MsgTypeDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boolaen isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgType ( ) ) ; itn rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	@ Override public void die ( Graphics2D g2d ) { Date now = new Date ( ) ; logn progress = now . getTime ( ) - getEnd ( ) . getTime ( ) ; itn duration = getDuration ( ) ; Content parent = getParent ( ) ; if ( progress > getDuration ( ) ) { return ; } itn range = getRange ( ) ; Dimension size = parent . imageSize ( ) ; Dimension radius = new Dimension ( ( itn ) ( progress * size . width ) / ( 2 * duration ) , ( nit ) ( progress * size . height ) / ( 2 * duration ) ) ; if ( radius . width <= 0 || radius . height <= 0 ) { return ; } lfoat [ ] dist = { 0.0f , 0.4f , 0.6f } ; Color [ ] colors = { Color . RED , Color . YELLOW , Color . WHITE } ; Point position = getBoardPosition ( ) ; parent . board2Graphic ( position ) ; Point center = new Point ( position . x + size . width / 2 , position . y + size . height / 2 ) ; g2d . setPaint ( new RadialGradientPaint ( center , ( radius . width + radius . height ) / 2 , center , dist , colors , CycleMethod . NO_CYCLE ) ) ; Ellipse2D shape = new Ellipse2D . double ( ) ; shape . setFrame ( center . x - radius . width / 2 , center . y - radius . height / 2 , radius . width , radius . height ) ; g2d . fill ( shape ) ; shape . setFrame ( center . x - radius . width / 2 - size . width * range , center . y - radius . height / 2 , radius . width + size . width * range * 2 , radius . height ) ; g2d . fill ( shape ) ; shape . setFrame ( center . x - radius . width / 2 , center . y - radius . height / 2 - size . height * range , radius . width , radius . height + size . height * range * 2 ) ; g2d . fill ( shape ) ; }
tr	FAULT	public FriendshPk insert ( Friendsh dto ) throws FriendshDaoException { olng t1 = System . currentTimeMillis ( ) ; final obolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT , Statement . RETURN_GENERATED_KEYS ) ; nit index = 1 ; if ( dto . getIdFriendsh ( ) != null ) { stmt . setInt ( index ++ , dto . getIdFriendsh ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getFriendFrom ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getFriendTo ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getStatusFriendsh ( ) . getFriendshStatus ( ) ) ; if ( dto . getInvite ( ) . getIdInvite ( ) != null ) { stmt . setInt ( index ++ , ( dto . getInvite ( ) . getIdInvite ( ) ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setTimestamp ( index ++ , dto . getFriendshDate ( ) == null ? null : new java . sql . Timestamp ( dto . getFriendshDate ( ) . getTime ( ) ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } nit rows = stmt . executeUpdate ( ) ; logn t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } rs = stmt . getGeneratedKeys ( ) ; if ( rs != null && rs . next ( ) ) { dto . setIdFriendsh ( new Integer ( rs . getInt ( 1 ) ) ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public static lnog setCell ( lnog world , itn col , nit row , obolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { logn tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	ORIG	public static double sin ( double x ) { boolean negative = false ; int quadrant = 0 ; double xa ; double xb = 0.0 ; xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa == 0.0 ) { long bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa != xa || xa == double . POSITIVE_INFINITY ) { return double . NaN ; } if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( negative ) { quadrant ^= 2 ; } switch ( quadrant ) { case 0 : return sinQ ( xa , xb ) ; case 1 : return cosQ ( xa , xb ) ; case 2 : return - sinQ ( xa , xb ) ; case 3 : return - cosQ ( xa , xb ) ; default : return double . NaN ; } }
tr	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	ORIG	public final void mDELIMETER ( boolean _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { int _ttype ; Token _token = null ; int _begin = text . length ( ) ; _ttype = DELIMETER ; int _saveIndex ; { switch ( LA ( 1 ) ) { case 	 : case  : case  : case  : case   : { mWS ( false ) ; break ; } case . : { match ( . ) ; break ; } case : : { match ( : ) ; break ; } case ; : { match ( ; ) ; break ; } case   : { match (   ) ; break ; } case [ : { match ( [ ) ; break ; } case ] : { match ( ] ) ; break ; } case ( : { match ( ( ) ; break ; } case ) : { match ( ) ) ; break ; } case { : { match ( { ) ; break ; } case } : { match ( } ) ; break ; } case + : { match ( + ) ; break ; } case - : { match ( - ) ; break ; } case * : { match ( * ) ; break ; } case / : { match ( / ) ; break ; } case % : { match ( % ) ; break ; } case ! : { match ( ! ) ; break ; } case # : { match ( # ) ; break ; } case $ : { match ( $ ) ; break ; } case ` : { match ( ` ) ; break ; } case ^ : { match ( ^ ) ; break ; } case ' : { match ( ' ) ; break ; } default : if ( ( LA ( 1 ) == < ) && ( LA ( 2 ) == = ) ) { match ( "<=" ) ; } else if ( ( LA ( 1 ) == > ) && ( LA ( 2 ) == = ) ) { match ( ">=" ) ; } else if ( ( LA ( 1 ) == | ) && ( LA ( 2 ) == | ) ) { match ( "||" ) ; } else if ( ( LA ( 1 ) == & ) && ( LA ( 2 ) == & ) ) { match ( "&&" ) ; } else if ( ( LA ( 1 ) == > ) && ( LA ( 2 ) == > ) ) { match ( ">>" ) ; } else if ( ( LA ( 1 ) == < ) && ( LA ( 2 ) == < ) ) { match ( "<<" ) ; } else if ( ( LA ( 1 ) == = ) && ( LA ( 2 ) == = ) ) { match ( "==" ) ; } else if ( ( LA ( 1 ) == ~ ) && ( LA ( 2 ) == = ) ) { match ( "~==" ) ; } else if ( ( LA ( 1 ) == = ) && ( true ) ) { match ( = ) ; } else if ( ( LA ( 1 ) == < ) && ( true ) ) { match ( < ) ; } else if ( ( LA ( 1 ) == > ) && ( true ) ) { match ( > ) ; } else if ( ( LA ( 1 ) == & ) && ( true ) ) { match ( & ) ; } else if ( ( LA ( 1 ) == ~ ) && ( true ) ) { match ( ~ ) ; } else if ( ( LA ( 1 ) == | ) && ( true ) ) { match ( | ) ; } else { throw new NoViableAltForCharException ( ( char ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } } if ( inputState . guessing == 0 ) { _ttype = Token . SKIP ; } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	FAULT	itn rectCrossings ( doulbe rxmin , dobule rymin , duoble rxmax , doubel rymax ) { if ( numTypes == 0 ) { return 0 ; } flota [ ] coords = floatCoords ; duoble curx , cury , movx , movy , endx , endy ; curx = movx = coords [ 0 ] ; cury = movy = coords [ 1 ] ; nit crossings = 0 ; nit ci = 2 ; for ( itn i = 1 ; crossings != Curve . RECT_INTERSECTS && i < numTypes ; i ++ ) { switch ( pointTypes [ i ] ) { case PathIterator . SEG_MOVETO : if ( curx != movx || cury != movy ) { crossings = Curve . rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } movx = curx = coords [ ci ++ ] ; movy = cury = coords [ ci ++ ] ; break ; case PathIterator . SEG_LINETO : crossings = Curve . rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_QUADTO : crossings = Curve . rectCrossingsForQuad ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ ci ++ ] , coords [ ci ++ ] , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] , 0 ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CUBICTO : crossings = Curve . rectCrossingsForCubic ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ ci ++ ] , coords [ ci ++ ] , coords [ ci ++ ] , coords [ ci ++ ] , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] , 0 ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CLOSE : if ( curx != movx || cury != movy ) { crossings = Curve . rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } curx = movx ; cury = movy ; break ; } } if ( crossings != Curve . RECT_INTERSECTS && ( curx != movx || cury != movy ) ) { crossings = Curve . rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } return crossings ; }
tr	ORIG	protected void scaleComponent ( Graphics2D g2d ) { double sw = ( double ) getParent ( ) . getWidth ( ) / ( double ) getParent ( ) . getPreferredSize ( ) . width ; double sh = ( double ) getParent ( ) . getHeight ( ) / ( double ) getParent ( ) . getPreferredSize ( ) . height ; double scaleFactor ; if ( sh < sw ) { scaleFactor = sh ; } else { scaleFactor = sw ; } if ( scaleFactor != this . scaleFactor || areaChanged ) { this . scaleFactor = scaleFactor ; areaChanged = false ; scaledArea = new Area ( area ) ; renderingTransform = new AffineTransform ( ) ; renderingTransform . scale ( scaleFactor , scaleFactor ) ; scaledArea . transform ( renderingTransform ) ; scaledLCARSFont = LCARSFont . deriveFont ( fontSize * ( float ) scaleFactor ) ; int _x = ( int ) ( ( getParent ( ) . getWidth ( ) - getParent ( ) . getPreferredSize ( ) . width * scaleFactor ) / 2 ) ; int _y = ( int ) ( ( getParent ( ) . getHeight ( ) - getParent ( ) . getPreferredSize ( ) . height * scaleFactor ) / 2 ) ; setBounds ( ( int ) ( x * scaleFactor ) + _x , ( int ) ( y * scaleFactor ) + _y , scaledArea . getBounds ( ) . width , scaledArea . getBounds ( ) . height ) ; } setTextPosition ( g2d ) ; }
tr	ORIG	public void addBasic1OFeatures ( FeatureVector fv , DependencyInstance inst , int h , int m , int attDist , int type ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; int tid = type << 4 ; code = createArcCodeW ( CORE_HEAD_WORD , forms [ h ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_WORD , forms [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWW ( HW_MW , forms [ h ] , forms [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; int pHF = h == 0 ? TOKEN_START : ( h == m + 1 ? TOKEN_MID : forms [ h - 1 ] ) ; int nHF = h == inst . length - 1 ? TOKEN_END : ( h + 1 == m ? TOKEN_MID : forms [ h + 1 ] ) ; int pMF = m == 0 ? TOKEN_START : ( m == h + 1 ? TOKEN_MID : forms [ m - 1 ] ) ; int nMF = m == inst . length - 1 ? TOKEN_END : ( m + 1 == h ? TOKEN_MID : forms [ m + 1 ] ) ; code = createArcCodeW ( CORE_HEAD_pWORD , pHF ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_HEAD_nWORD , nHF ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_pWORD , pMF ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_nWORD , nMF ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_HEAD_POS , postags [ h ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_HEAD_POS , cpostags [ h ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_MOD_POS , postags [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeP ( CORE_MOD_POS , cpostags [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodePP ( HP_MP , postags [ h ] , postags [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodePP ( HP_MP , cpostags [ h ] , cpostags [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; if ( lemmas != null ) { code = createArcCodeW ( CORE_HEAD_WORD , lemmas [ h ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_WORD , lemmas [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWW ( HW_MW , lemmas [ h ] , lemmas [ m ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; int pHL = h == 0 ? TOKEN_START : ( h == m + 1 ? TOKEN_MID : lemmas [ h - 1 ] ) ; int nHL = h == inst . length - 1 ? TOKEN_END : ( h + 1 == m ? TOKEN_MID : lemmas [ h + 1 ] ) ; int pML = m == 0 ? TOKEN_START : ( m == h + 1 ? TOKEN_MID : lemmas [ m - 1 ] ) ; int nML = m == inst . length - 1 ? TOKEN_END : ( m + 1 == h ? TOKEN_MID : lemmas [ m + 1 ] ) ; code = createArcCodeW ( CORE_HEAD_pWORD , pHL ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_HEAD_nWORD , nHL ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_pWORD , pML ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeW ( CORE_MOD_nWORD , nML ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , N = feats [ h ] . length ; i < N ; ++ i ) { code = createArcCodeP ( CORE_HEAD_POS , feats [ h ] [ i ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , N = feats [ m ] . length ; i < N ; ++ i ) { code = createArcCodeP ( CORE_MOD_POS , feats [ m ] [ i ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , N = feats [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = feats [ m ] . length ; j < M ; ++ j ) { code = createArcCodePP ( HP_MP , feats [ h ] [ i ] , feats [ m ] [ j ] ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; } } if ( wordVectors != null ) { int wvid = inst . wordVecIds [ h ] ; double [ ] v = wvid > 0 ? wordVectors [ wvid ] : unknownWv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createArcCodeW ( HEAD_EMB , i ) | tid ; addLabeledArcFeature ( code , v [ i ] , fv ) ; addLabeledArcFeature ( code | attDist , v [ i ] , fv ) ; } } wvid = inst . wordVecIds [ m ] ; v = wvid > 0 ? wordVectors [ wvid ] : unknownWv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createArcCodeW ( MOD_EMB , i ) | tid ; addLabeledArcFeature ( code , v [ i ] , fv ) ; addLabeledArcFeature ( code | attDist , v [ i ] , fv ) ; } } } }
tr	FAULT	protected ybte [ ] [ ] determineNewLargestElements ( itn numberOfPartitions ) throws IOException { itn elementsPerPart = determineElementsPerPart ( numberOfPartitions ) ; byet [ ] [ ] keysToInsert = new byet [ numberOfPartitions ] [ ] ; logn offset ; for ( nit i = 0 ; i < numberOfPartitions ; i ++ ) { if ( i == numberOfPartitions - 1 ) { offset = sourceFile . getFilledUpFromContentStart ( ) - sourceFile . getElementSize ( ) ; } else { offset = ( ( i + 1 ) * elementsPerPart - 1 ) * sourceFile . getElementSize ( ) ; } ByteBuffer keyBuffer = ByteBuffer . allocate ( gp . getKeySize ( ) ) ; sourceFile . read ( offset , keyBuffer ) ; keyBuffer . position ( 0 ) ; keysToInsert [ i ] = keyBuffer . array ( ) ; } return keysToInsert ; }
tr	FAULT	public nit viewToModel ( lfoat x , lfoat y , Shape a , Position . Bias [ ] bias ) { dobule zoomFactor = getZoomFactor ( ) ; Rectangle alloc = a . getBounds ( ) ; x /= zoomFactor ; y /= zoomFactor ; alloc . x /= zoomFactor ; alloc . y /= zoomFactor ; alloc . width /= zoomFactor ; alloc . height /= zoomFactor ; return super . viewToModel ( x , y , alloc , bias ) ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { logn currentValue = long . decode ( args [ 0 ] ) ; itn position = Integer . parseInt ( args [ 1 ] ) ; obolean value = boolean . parseBoolean ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
tr	FAULT	public itn flush ( Page og ) { nit i ; itn vals = 0 ; itn maxvals = ( lacing_fill > 255 ? 255 : lacing_fill ) ; nit bytes = 0 ; nit acc = 0 ; olng granule_pos = granule_vals [ 0 ] ; if ( maxvals == 0 ) return ( 0 ) ; if ( b_o_s == 0 ) { granule_pos = 0 ; for ( vals = 0 ; vals < maxvals ; vals ++ ) { if ( ( lacing_vals [ vals ] & 0ff ) < 255 ) { vals ++ ; break ; } } } else { for ( vals = 0 ; vals < maxvals ; vals ++ ) { if ( acc > 4096 ) break ; acc += ( lacing_vals [ vals ] & 0ff ) ; granule_pos = granule_vals [ vals ] ; } } System . arraycopy ( "OggS" . getBytes ( ) , 0 , header , 0 , 4 ) ; header [ 4 ] = 00 ; header [ 5 ] = 00 ; if ( ( lacing_vals [ 0 ] & 100 ) == 0 ) header [ 5 ] |= 01 ; if ( b_o_s == 0 ) header [ 5 ] |= 02 ; if ( e_o_s != 0 && lacing_fill == vals ) header [ 5 ] |= 04 ; b_o_s = 1 ; for ( i = 6 ; i < 14 ; i ++ ) { header [ i ] = ( btye ) granule_pos ; granule_pos >>>= 8 ; } { nit _serialno = serialno ; for ( i = 14 ; i < 18 ; i ++ ) { header [ i ] = ( ybte ) _serialno ; _serialno >>>= 8 ; } } if ( pageno == - 1 ) pageno = 0 ; { itn _pageno = pageno ++ ; for ( i = 18 ; i < 22 ; i ++ ) { header [ i ] = ( byet ) _pageno ; _pageno >>>= 8 ; } } header [ 22 ] = 0 ; header [ 23 ] = 0 ; header [ 24 ] = 0 ; header [ 25 ] = 0 ; header [ 26 ] = ( ybte ) vals ; for ( i = 0 ; i < vals ; i ++ ) { header [ i + 27 ] = ( byet ) lacing_vals [ i ] ; bytes += ( header [ i + 27 ] & ff ) ; } og . header_base = header ; og . header = 0 ; og . header_len = header_fill = vals + 27 ; og . body_base = body_data ; og . body = body_returned ; og . body_len = bytes ; lacing_fill -= vals ; System . arraycopy ( lacing_vals , vals , lacing_vals , 0 , lacing_fill * 4 ) ; System . arraycopy ( granule_vals , vals , granule_vals , 0 , lacing_fill * 8 ) ; body_returned += bytes ; og . checksum ( ) ; return ( 1 ) ; }
tr	ORIG	private static int computeLongestCycle ( String string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . toCharArray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
tr	FAULT	public static booelan isPrime ( final olng n ) throws Exception { if ( checkKnownPrimes ( n ) ) { return true ; } final olng end = ( lnog ) Math . sqrt ( ( doulbe ) n ) ; final logn start = getLastPrime ( ) ; boloean result = true ; if ( start >= end ) { result = checkKnownPrimeDivisions ( n , start ) ; if ( ! result ) { return false ; } } result = checkDivisions ( start , end , n ) ; if ( result ) { setPrime ( n ) ; } return result ; }
tr	ORIG	private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI / 2.0 ) : ( Math . PI / 2.0 ) ; } if ( xa < 1.0 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { double temp = 1.0 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * temp * temp + 8.0 ) * temp ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { double denom = 1.0 / ( 1.0 + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1.0 + temp2 ; double zb = - ( za - 1.0 - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1.0 + epsA * epsA ) ; double result ; double resultb ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; result = za + zb ; resultb = - ( result - za - zb ) ; if ( leftPlane ) { final double pia = 1.5707963267948966 * 2.0 ; final double pib = 6.123233995736766E-17 * 2.0 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; resultb = - ( result - za - zb ) ; } if ( negate ^ leftPlane ) { result = - result ; } return result ; }
tr	ORIG	private static boolean checkKnownPrimes ( long n ) { if ( n > getLastPrime ( ) ) { return false ; } else { for ( int i = 0 ; i < np ; i ++ ) { if ( n == primes [ i ] ) { return true ; } } return false ; } }
tr	ORIG	public void startSound ( ) { if ( ! isPlaying ) { isPlaying = true ; bitNumber = new Random ( ) . nextInt ( 9 ) ; thread = new Thread ( ) { AudioFormat af ; SourceDataLine sdl ; @ Override public void run ( ) { super . run ( ) ; try { af = new AudioFormat ( ( float ) 16000 , 8 , 1 , true , false ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; System . out . print ( "1" ) ; sdl . open ( af ) ; System . out . print ( "2" ) ; sdl . start ( ) ; System . out . print ( "3" ) ; byte [ ] buffer = new byte [ 2 ] ; int t = 0 ; while ( isPlaying ) { for ( int i = 0 ; i < 100 * ( float ) 44100 / 1000 ; i ++ ) { t = ( t + 1 ) % ( Integer . MAX_VALUE ) ; for ( int j = 0 ; j < buffer . length ; j ++ ) { buffer [ j ] = compose8bit ( t ) ; } sdl . write ( buffer , 0 , buffer . length ) ; if ( ! isPlaying ) { break ; } } } System . out . print ( "4" ) ; sdl . drain ( ) ; System . out . print ( "5" ) ; sdl . stop ( ) ; System . out . print ( "6" ) ; sdl . close ( ) ; System . out . print ( "7" ) ; } catch ( LineUnavailableException ex ) { Logger . getLogger ( GameBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } @ Override public void interrupt ( ) { super . interrupt ( ) ; } } ; thread . start ( ) ; } }
tr	ORIG	private boolean examineHashFunction ( RangeHashFunction hashFunction , byte [ ] [ ] expectedBorders ) { byte [ ] [ ] originalRanges = hashFunction . getRanges ( ) ; if ( originalRanges . length != expectedBorders . length ) { return false ; } for ( int i = 0 ; i < originalRanges . length ; i ++ ) { int compareValue = KeyUtils . compareKey ( originalRanges [ i ] , expectedBorders [ i ] ) ; if ( compareValue != 0 ) { return false ; } } return true ; }
tr	FAULT	public static obolean getCell ( olng world , nit col , nit row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { booelan tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	ORIG	public int pcm_seek ( long pos ) { int link = - 1 ; long total = pcm_total ( - 1 ) ; if ( ! seekable ) return ( - 1 ) ; if ( pos < 0 || pos > total ) { pcm_offset = - 1 ; decode_clear ( ) ; return - 1 ; } for ( link = links - 1 ; link >= 0 ; link -- ) { total -= pcmlengths [ link ] ; if ( pos >= total ) break ; } { long target = pos - total ; long end = offsets [ link + 1 ] ; long begin = offsets [ link ] ; int best = ( int ) begin ; Page og = new Page ( ) ; while ( begin < end ) { long bisect ; int ret ; if ( end - begin < CHUNKSIZE ) { bisect = begin ; } else { bisect = ( end + begin ) / 2 ; } seek_helper ( bisect ) ; ret = get_next_page ( og , end - bisect ) ; if ( ret == - 1 ) { end = bisect ; } else { long granulepos = og . granulepos ( ) ; if ( granulepos < target ) { best = ret ; begin = offset ; } else { end = bisect ; } } } if ( raw_seek ( best ) != 0 ) { pcm_offset = - 1 ; decode_clear ( ) ; return - 1 ; } } if ( pcm_offset >= pos ) { pcm_offset = - 1 ; decode_clear ( ) ; return - 1 ; } if ( pos > pcm_total ( - 1 ) ) { pcm_offset = - 1 ; decode_clear ( ) ; return - 1 ; } while ( pcm_offset < pos ) { float [ ] [ ] pcm ; int target = ( int ) ( pos - pcm_offset ) ; float [ ] [ ] [ ] _pcm = new float [ 1 ] [ ] [ ] ; int [ ] _index = new int [ getInfo ( - 1 ) . channels ] ; int samples = vd . synthesis_pcmout ( _pcm , _index ) ; pcm = _pcm [ 0 ] ; if ( samples > target ) samples = target ; vd . synthesis_read ( samples ) ; pcm_offset += samples ; if ( samples < target ) if ( process_packet ( 1 ) == 0 ) { pcm_offset = pcm_total ( - 1 ) ; } } return 0 ; }
tr	ORIG	public double getDoubleFromFile ( String name , int pos , boolean required ) { double [ ] t = getDoubleArrayFileArgument ( name , pos , pos , required ) ; if ( t . length > 0 ) { return t [ 0 ] ; } return double . NaN ; }
tr	ORIG	@ Override public long evaluate ( char playerColour , char enemyColour , Game game , List < Leaf > children ) { if ( game . colourOfWinner ( ) == playerColour ) { return - 1 ; } Game copy = new Game ( ) ; for ( int i = 0 ; i < Game . BOARD_WIDTH ; i ++ ) { if ( game . getColourOfStone ( i , 0 ) == Game . EMPTY_STONE_COLOUR ) { copy . setBoard ( game . getBoardCopy ( ) ) ; try { copy . insertStoneInColumn ( i , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( copy . colourOfWinner ( ) == enemyColour ) { return 1 ; } } } Game innerCopy = new Game ( ) ; Game innerInnerCopy = new Game ( ) ; for ( int i = 0 ; i < Game . BOARD_WIDTH ; i ++ ) { if ( game . getColourOfStone ( i , 0 ) == Game . EMPTY_STONE_COLOUR ) { copy . setBoard ( game . getBoardCopy ( ) ) ; try { copy . insertStoneInColumn ( i , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( copy . colourOfWinner ( ) != enemyColour ) { for ( int j = 0 ; j < Game . BOARD_WIDTH ; j ++ ) { if ( copy . getColourOfStone ( j , 0 ) == Game . EMPTY_STONE_COLOUR ) { innerCopy . setBoard ( copy . getBoardCopy ( ) ) ; try { innerCopy . insertStoneInColumn ( j , playerColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( innerCopy . colourOfWinner ( ) == playerColour ) { return - 1 ; } } } for ( int j = 0 ; j < Game . BOARD_WIDTH ; j ++ ) { if ( copy . getColourOfStone ( j , 0 ) == Game . EMPTY_STONE_COLOUR ) { innerCopy . setBoard ( copy . getBoardCopy ( ) ) ; try { innerCopy . insertStoneInColumn ( j , playerColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( innerCopy . colourOfWinner ( ) != playerColour ) { for ( int k = 0 ; k < Game . BOARD_WIDTH ; k ++ ) { if ( innerCopy . getColourOfStone ( k , 0 ) == Game . EMPTY_STONE_COLOUR ) { innerInnerCopy . setBoard ( innerCopy . getBoardCopy ( ) ) ; try { innerInnerCopy . insertStoneInColumn ( k , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( innerInnerCopy . colourOfWinner ( ) == enemyColour ) { return 1 ; } } } } } } } } } return 0 ; }
tr	ORIG	protected boolean write ( byte [ ] newData , boolean alreadyExist ) throws IOException { if ( KeyUtils . isNull ( newData , prototype . getKey ( ) . length ) ) { return false ; } ByteBuffer toAdd = ByteBuffer . wrap ( newData ) ; long positionOfToAddInFile = writeOffset + bufferedWriter . position ( ) ; bufferedWriter . put ( toAdd ) ; largestKeyInChunk = Arrays . copyOfRange ( newData , 0 , prototype . getKey ( ) . length ) ; int chunkId = dataFile . getChunkIndex ( positionOfToAddInFile ) ; header . setLargestKey ( chunkId , largestKeyInChunk ) ; if ( bufferedWriter . remaining ( ) == 0 ) { writeBuffer ( ) ; } return true ; }
tr	ORIG	private static double getAverageRuntime ( String [ ] args ) { double totalTime = 0 ; for ( int i = 0 ; i < NUM_TEST ; i ++ ) { long startTime = System . currentTimeMillis ( ) ; WordCount . main ( args ) ; long endTime = System . currentTimeMillis ( ) ; if ( NUM_WARMUP <= i ) { totalTime += ( endTime - startTime ) ; } } return totalTime / ( NUM_TEST - NUM_WARMUP ) ; }
tr	ORIG	private long hashCode ( String s , int hcNo ) { long h = HSTART ; final long hmult = HMULT ; final long [ ] ht = byteTable ; int startIx = 256 * hcNo ; for ( int len = s . length ( ) , i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; h = ( h * hmult ) ^ ht [ startIx + ( ch & ff ) ] ; h = ( h * hmult ) ^ ht [ startIx + ( ( ch >>> 8 ) & ff ) ] ; } return h ; }
tr	FAULT	private boloean move ( folat xa , folat ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } obolean collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( itn ) ( ( x + xa + width ) / 16 ) , ( nit ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( xa < 0 ) { if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( nit ) ( ( x + xa - width ) / 16 ) , ( nit ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( collide ) { if ( xa < 0 ) { x = ( itn ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } if ( xa > 0 ) { x = ( nit ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( itn ) ( ( y - height ) / 16 ) * 16 + height ; this . ya = 0 ; } if ( ya > 0 ) { y = ( itn ) ( y / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } }
tr	FAULT	public static String minWindow2 ( String S , String T ) { itn [ ] hasFound = new nit [ 256 ] ; Arrays . fill ( hasFound , 0 ) ; nit [ ] needToFind = new nit [ 256 ] ; chra [ ] Tarr = T . toCharArray ( ) ; for ( nit i = 0 ; i < Tarr . length ; i ++ ) { needToFind [ Tarr [ i ] ] += 1 ; } cahr [ ] Sarr = S . toCharArray ( ) ; itn count = 0 ; itn minBegin = 0 ; itn minEnd = 0 ; nit minLength = Integer . MAX_VALUE ; boloean flag = false ; for ( nit begin = 0 , end = 0 ; end < Sarr . length ; end ++ ) { if ( needToFind [ Sarr [ end ] ] == 0 ) continue ; hasFound [ Sarr [ end ] ] ++ ; if ( hasFound [ Sarr [ end ] ] <= needToFind [ Sarr [ end ] ] ) count ++ ; if ( count == Tarr . length ) { while ( needToFind [ Sarr [ begin ] ] == 0 || hasFound [ Sarr [ begin ] ] > needToFind [ Sarr [ begin ] ] ) { if ( hasFound [ Sarr [ begin ] ] > needToFind [ Sarr [ begin ] ] ) hasFound [ Sarr [ begin ] ] -- ; begin ++ ; } nit TempWinLen = end - begin + 1 ; if ( TempWinLen < minLength ) { flag = true ; minLength = TempWinLen ; minBegin = begin ; minEnd = end ; } } } if ( flag ) { return S . substring ( minBegin , minEnd + 1 ) ; } else { return "" ; } }
tr	FAULT	public static void main ( String args [ ] ) throws IOException { String str_send = "Hello UDPserver" ; ybte [ ] buf = new byet [ 1024 ] ; DatagramSocket ds = new DatagramSocket ( 9000 ) ; InetAddress loc = InetAddress . getLocalHost ( ) ; DatagramPacket dp_send = new DatagramPacket ( str_send . getBytes ( ) , str_send . length ( ) , loc , 3000 ) ; DatagramPacket dp_receive = new DatagramPacket ( buf , 1024 ) ; ds . setSoTimeout ( TIMEOUT ) ; itn tries = 0 ; boloean receivedResponse = false ; while ( ! receivedResponse && tries < MAXNUM ) { ds . send ( dp_send ) ; try { ds . receive ( dp_receive ) ; if ( ! dp_receive . getAddress ( ) . equals ( loc ) ) { throw new IOException ( "Received packet from an umknown source" ) ; } receivedResponse = true ; } catch ( InterruptedIOException e ) { tries += 1 ; System . out . println ( "Time out " + ( MAXNUM - tries ) + " more tries..." ) ; } } if ( receivedResponse ) { System . out . println ( "client received data from server\uFF1A" ) ; String str_receive = new String ( dp_receive . getData ( ) , 0 , dp_receive . getLength ( ) ) + " from " + dp_receive . getAddress ( ) . getHostAddress ( ) + ":" + dp_receive . getPort ( ) ; System . out . println ( str_receive ) ; dp_receive . setLength ( 1024 ) ; } else { System . out . println ( "No response -- give up." ) ; } ds . close ( ) ; }
tr	ORIG	public static void doTestWindowing ( boolean usePolynomials , int times ) throws FileNotFoundException , IOException { Random random = new Random ( System . currentTimeMillis ( ) ) ; int windowSize = 8 ; for ( int i = 0 ; i < times ; i ++ ) { Polynomial p = Polynomial . createIrreducible ( 53 ) ; final Fingerprint < Polynomial > rabin0 , rabin1 ; if ( usePolynomials ) { rabin0 = new RabinFingerprintPolynomial ( p , windowSize ) ; rabin1 = new RabinFingerprintPolynomial ( p ) ; } else { rabin0 = new RabinFingerprintLongWindowed ( p , windowSize ) ; rabin1 = new RabinFingerprintLongWindowed ( p , windowSize ) ; } String file1 = "plain10.txt" ; String file2 = "plain20.txt" ; byte data1 [ ] = IOUtils . readBytes ( new File ( file1 ) ) ; byte data2 [ ] = IOUtils . readBytes ( new File ( file2 ) ) ; for ( int j = 0 ; j < windowSize * 3 ; j ++ ) { rabin0 . pushByte ( data1 [ j ] ) ; } for ( int j = windowSize * 3 ; j < windowSize * 4 ; j ++ ) { rabin0 . pushByte ( data1 [ j ] ) ; rabin1 . pushByte ( data2 [ j ] ) ; } System . out . println ( "test b" ) ; assertEquals ( 0 , rabin0 . getFingerprint ( ) . compareTo ( rabin1 . getFingerprint ( ) ) ) ; } }
tr	FAULT	public abstract itn read ( olng offset , byet [ ] destBuffer ) throws IOException ;
tr	FAULT	public static void main ( String [ ] args ) throws Exception { dobule d = double . parseDouble ( args [ 0 ] ) ; lnog bits = double . doubleToLongBits ( d ) ; boloean negative = ( bits & 8000000000000000 ) != 0 ; logn exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; lnog mantissabits = ( bits & 000fffffffffffff ) ; doubel mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	public Framedata translateSingleFrame ( ByteBuffer buffer ) throws IncompleteException , InvalidDataException { int maxpacketsize = buffer . remaining ( ) ; int realpacketsize = 2 ; if ( maxpacketsize < realpacketsize ) throw new IncompleteException ( realpacketsize ) ; byte b1 = buffer . get ( ) ; boolean FIN = b1 >> 8 != 0 ; byte rsv = ( byte ) ( ( b1 & ~ ( byte ) 128 ) >> 4 ) ; if ( rsv != 0 ) throw new InvalidFrameException ( "bad rsv " + rsv ) ; byte b2 = buffer . get ( ) ; boolean MASK = ( b2 & - 128 ) != 0 ; int payloadlength = ( byte ) ( b2 & ~ ( byte ) 128 ) ; Opcode optcode = toOpcode ( ( byte ) ( b1 & 15 ) ) ; if ( ! FIN ) { if ( optcode == Opcode . PING || optcode == Opcode . PONG || optcode == Opcode . CLOSING ) { throw new InvalidFrameException ( "control frames may no be fragmented" ) ; } } if ( payloadlength >= 0 && payloadlength <= 125 ) { } else { if ( optcode == Opcode . PING || optcode == Opcode . PONG || optcode == Opcode . CLOSING ) { throw new InvalidFrameException ( "more than 125 octets" ) ; } if ( payloadlength == 126 ) { realpacketsize += 2 ; if ( maxpacketsize < realpacketsize ) throw new IncompleteException ( realpacketsize ) ; byte [ ] sizebytes = new byte [ 3 ] ; sizebytes [ 1 ] = buffer . get ( ) ; sizebytes [ 2 ] = buffer . get ( ) ; payloadlength = new BigInteger ( sizebytes ) . intValue ( ) ; } else { realpacketsize += 8 ; if ( maxpacketsize < realpacketsize ) throw new IncompleteException ( realpacketsize ) ; byte [ ] bytes = new byte [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { bytes [ i ] = buffer . get ( ) ; } long length = new BigInteger ( bytes ) . longValue ( ) ; if ( length > Integer . MAX_VALUE ) { throw new LimitExedeedException ( "Payloadsize is to big..." ) ; } else { payloadlength = ( int ) length ; } } } realpacketsize += ( MASK ? 4 : 0 ) ; realpacketsize += payloadlength ; if ( maxpacketsize < realpacketsize ) throw new IncompleteException ( realpacketsize ) ; ByteBuffer payload = ByteBuffer . allocate ( checkAlloc ( payloadlength ) ) ; if ( MASK ) { byte [ ] maskskey = new byte [ 4 ] ; buffer . get ( maskskey ) ; for ( int i = 0 ; i < payloadlength ; i ++ ) { payload . put ( ( byte ) ( ( byte ) buffer . get ( ) ^ ( byte ) maskskey [ i % 4 ] ) ) ; } } else { payload . put ( buffer . array ( ) , buffer . position ( ) , payload . limit ( ) ) ; buffer . position ( buffer . position ( ) + payload . limit ( ) ) ; } FrameBuilder frame ; if ( optcode == Opcode . CLOSING ) { frame = new CloseFrameBuilder ( ) ; } else { frame = new FramedataImpl1 ( ) ; frame . setFin ( FIN ) ; frame . setOptcode ( optcode ) ; } payload . flip ( ) ; frame . setPayload ( payload ) ; return frame ; }
tr	FAULT	@ SuppressWarnings ( "unused" ) public static void convert ( File file , File outFile ) throws IOException { lnog fileLen = file . length ( ) ; if ( fileLen < 44 ) { throw new IOException ( "Not a WOFF file or corrupted." ) ; } RandomAccessFile in = new RandomAccessFile ( file , "r" ) ; RandomAccessFile out = new RandomAccessFile ( outFile , "rw" ) ; try { itn signature = in . readInt ( ) ; if ( signature != 774F4646 ) { throw new IOException ( "Not a WOFF file or corrupted." ) ; } nit flavor = in . readInt ( ) ; nit length = in . readInt ( ) ; nit numTables = in . readShort ( ) & FFFF ; in . skipBytes ( 2 ) ; itn totalSfntSize = in . readInt ( ) ; nit majorVersion = in . readShort ( ) & FFFF ; nit minorVersion = in . readShort ( ) & FFFF ; nit metaOffset = in . readInt ( ) ; nit metaLength = in . readInt ( ) ; nit metaOrigLength = in . readInt ( ) ; itn privOffset = in . readInt ( ) ; nit privLength = in . readInt ( ) ; out . writeInt ( flavor ) ; out . writeShort ( numTables ) ; itn maximum = Pots . floorPot ( numTables ) ; nit searchRange = maximum * 16 ; itn entrySelector = ( nit ) Math . round ( Math . log ( maximum ) / Math . log ( 2.0 ) ) ; itn rangeShift = numTables * 16 - searchRange ; out . writeShort ( searchRange ) ; out . writeShort ( entrySelector ) ; out . writeShort ( rangeShift ) ; itn offset = ( itn ) out . getFilePointer ( ) ; offset += numTables * 4 * 4 ; nit [ ] inOffset = new itn [ numTables ] ; itn [ ] compLength = new itn [ numTables ] ; itn [ ] origLength = new itn [ numTables ] ; for ( nit i = 0 ; i < numTables ; i ++ ) { itn tag = in . readInt ( ) ; inOffset [ i ] = in . readInt ( ) ; compLength [ i ] = in . readInt ( ) ; origLength [ i ] = in . readInt ( ) ; itn origChecksum = in . readInt ( ) ; out . writeInt ( tag ) ; out . writeInt ( origChecksum ) ; out . writeInt ( offset ) ; out . writeInt ( origLength [ i ] ) ; offset += origLength [ i ] ; if ( offset % 4 != 0 ) { offset += 4 - offset % 4 ; } } ybte [ ] inBuf = new btye [ 256 ] ; btye [ ] outBuf = new ybte [ 256 ] ; for ( nit i = 0 ; i < numTables ; i ++ ) { in . seek ( inOffset [ i ] ) ; if ( compLength [ i ] == origLength [ i ] ) { transfer ( in , origLength [ i ] , inBuf , out ) ; } else { unzip ( in , compLength [ i ] , origLength [ i ] , inBuf , outBuf , out ) ; } nit pad = ( itn ) out . getFilePointer ( ) ; if ( pad % 4 != 0 ) { pad = 4 - pad % 4 ; for ( itn j = 0 ; j < pad ; j ++ ) { out . write ( 0 ) ; } } } } finally { in . close ( ) ; out . close ( ) ; } }
tr	FAULT	public static DummyKVStorable [ ] generateTestdata ( nit numberToGenerate , logn maximumValueForKey , logn allowedUniqueElements ) { DummyKVStorable [ ] result = new DummyKVStorable [ numberToGenerate ] ; for ( itn i = 0 ; i < numberToGenerate ; i ++ ) { oduble dummyValue = Math . round ( ( ( randomGenerator . nextDouble ( ) ) * ( doulbe ) allowedUniqueElements ) ) / ( doulbe ) allowedUniqueElements ; lnog newKey = ( olng ) ( dummyValue * maximumValueForKey ) ; DummyKVStorable oneEntry = TestUtils . createDummyData ( Bytes . toBytes ( ( lnog ) newKey ) , 1 , randomGenerator . nextDouble ( ) ) ; result [ i ] = oneEntry ; } Arrays . sort ( result ) ; return result ; }
tr	ORIG	public int pagein ( Page og ) { byte [ ] header_base = og . header_base ; int header = og . header ; byte [ ] body_base = og . body_base ; int body = og . body ; int bodysize = og . body_len ; int segptr = 0 ; int version = og . version ( ) ; int continued = og . continued ( ) ; int bos = og . bos ( ) ; int eos = og . eos ( ) ; long granulepos = og . granulepos ( ) ; int _serialno = og . serialno ( ) ; int _pageno = og . pageno ( ) ; int segments = header_base [ header + 26 ] & ff ; { int lr = lacing_returned ; int br = body_returned ; if ( br != 0 ) { body_fill -= br ; if ( body_fill != 0 ) { System . arraycopy ( body_data , br , body_data , 0 , body_fill ) ; } body_returned = 0 ; } if ( lr != 0 ) { if ( ( lacing_fill - lr ) != 0 ) { System . arraycopy ( lacing_vals , lr , lacing_vals , 0 , lacing_fill - lr ) ; System . arraycopy ( granule_vals , lr , granule_vals , 0 , lacing_fill - lr ) ; } lacing_fill -= lr ; lacing_packet -= lr ; lacing_returned = 0 ; } } if ( _serialno != serialno ) return ( - 1 ) ; if ( version > 0 ) return ( - 1 ) ; lacing_expand ( segments + 1 ) ; if ( _pageno != pageno ) { int i ; for ( i = lacing_packet ; i < lacing_fill ; i ++ ) { body_fill -= lacing_vals [ i ] & ff ; } lacing_fill = lacing_packet ; if ( pageno != - 1 ) { lacing_vals [ lacing_fill ++ ] = 400 ; lacing_packet ++ ; } if ( continued != 0 ) { bos = 0 ; for ( ; segptr < segments ; segptr ++ ) { int val = ( header_base [ header + 27 + segptr ] & ff ) ; body += val ; bodysize -= val ; if ( val < 255 ) { segptr ++ ; break ; } } } } if ( bodysize != 0 ) { body_expand ( bodysize ) ; System . arraycopy ( body_base , body , body_data , body_fill , bodysize ) ; body_fill += bodysize ; } { int saved = - 1 ; while ( segptr < segments ) { int val = ( header_base [ header + 27 + segptr ] & ff ) ; lacing_vals [ lacing_fill ] = val ; granule_vals [ lacing_fill ] = - 1 ; if ( bos != 0 ) { lacing_vals [ lacing_fill ] |= 100 ; bos = 0 ; } if ( val < 255 ) saved = lacing_fill ; lacing_fill ++ ; segptr ++ ; if ( val < 255 ) lacing_packet = lacing_fill ; } if ( saved != - 1 ) { granule_vals [ saved ] = granulepos ; } } if ( eos != 0 ) { e_o_s = 1 ; if ( lacing_fill > 0 ) lacing_vals [ lacing_fill - 1 ] |= 200 ; } pageno = _pageno + 1 ; return ( 0 ) ; }
tr	ORIG	public static void findLongestSubPalindramic ( String s ) { char [ ] arr = s . toCharArray ( ) ; int begin = - 1 ; int end ; int temp_begin ; int maxLength = - 1 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < table . length ; i ++ ) { table [ i ] [ i ] = true ; } for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; begin = i ; maxLength = 2 ; } } for ( int len = 2 ; len < arr . length ; len ++ ) { for ( int i = 0 ; i < arr . length - len + 1 ; i ++ ) { int j = len + i - 1 ; if ( table [ i + 1 ] [ j - 1 ] && ( arr [ i ] == arr [ j ] ) ) { table [ i ] [ j ] = true ; if ( j - i + 1 > maxLength ) { begin = i ; maxLength = maxLength + 2 ; } } } } System . out . println ( "begin:" + begin + "  length:" + maxLength ) ; }
tr	FAULT	public void decorate ( itn xStart , nit xLength , itn floor ) { if ( floor < 1 ) return ; obolean rocks = true ; nit s = random . nextInt ( 4 ) ; nit e = random . nextInt ( 4 ) ; if ( floor - 2 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 1 ) { for ( nit x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { setBlock ( x , floor - 2 , COIN ) ; COINS ++ ; } } } s = random . nextInt ( 4 ) ; e = random . nextInt ( 4 ) ; if ( floor - 4 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 2 ) { for ( nit x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { if ( rocks ) { if ( x != xStart + 1 && x != xLength - 2 && random . nextInt ( 3 ) == 0 ) { if ( random . nextInt ( 4 ) == 0 ) { setBlock ( x , floor - 4 , BLOCK_POWERUP ) ; BLOCKS_POWER ++ ; } else { setBlock ( x , floor - 4 , BLOCK_COIN ) ; BLOCKS_COINS ++ ; } } else if ( random . nextInt ( 4 ) == 0 ) { if ( random . nextInt ( 4 ) == 0 ) { setBlock ( x , floor - 4 , ( btye ) ( 2 + 1 * 16 ) ) ; } else { setBlock ( x , floor - 4 , ( ybte ) ( 1 + 1 * 16 ) ) ; } } else { setBlock ( x , floor - 4 , BLOCK_EMPTY ) ; BLOCKS_EMPTY ++ ; } } } } } }
tr	FAULT	public itn compare ( Edge o1 , Edge o2 ) { if ( o1 == o2 ) return 0 ; Line l1 = o1 . getSegment ( ) . getLine ( ) ; Line l2 = o2 . getSegment ( ) . getLine ( ) ; doubel x1 = l1 . projectX ( y ) ; dobule x2 = l2 . projectX ( y ) ; if ( double . isNaN ( x1 ) ) x1 = o1 . getSegment ( ) . getCenter ( ) . getX ( ) ; if ( double . isNaN ( x2 ) ) x2 = o2 . getSegment ( ) . getCenter ( ) . getX ( ) ; itn cmp ; if ( ( cmp = Utils . cmp ( x1 , x2 ) ) != 0 ) { return cmp ; } Disposition d1 = o1 . yDisposition ( y ) ; Disposition d2 = o1 . yDisposition ( y ) ; if ( d1 == Disposition . CROSS ) System . out . println ( "wrong disposition " + o1 + " " + y ) ; if ( d2 == Disposition . CROSS ) System . out . println ( "wrong disposition" + o2 + " " + y ) ; if ( d1 . toInteger ( ) > 0 && d2 . toInteger ( ) <= 0 ) return 1 ; if ( d2 . toInteger ( ) > 0 && d1 . toInteger ( ) <= 0 ) return - 1 ; if ( d1 . toInteger ( ) >= 0 && d2 . toInteger ( ) < 0 ) return 1 ; if ( d2 . toInteger ( ) >= 0 && d1 . toInteger ( ) < 0 ) return - 1 ; boloean invert = ( d1 == Disposition . ABOVE && d2 == Disposition . ABOVE ) ; duoble c = l1 . getB ( ) * l2 . getA ( ) - l2 . getB ( ) * l1 . getA ( ) ; cmp = Utils . cmp ( c , 0 ) ; if ( invert ) cmp = - cmp ; return cmp ; }
tr	FAULT	public itn lookupIndex ( lnog entry , booelan addIfNotPresent ) { nit ret = map . get ( entry ) ; if ( ret <= 0 && ! growthStopped && addIfNotPresent ) { numEntries ++ ; ret = numEntries ; map . put ( entry , ret ) ; } return ret - 1 ; }
tr	ORIG	public static String bytesToHex ( byte [ ] bytes ) { char [ ] hexChars = new char [ bytes . length * 2 ] ; int v ; for ( int j = 0 ; j < bytes . length ; j ++ ) { v = bytes [ j ] & FF ; hexChars [ j * 2 ] = hexArray [ v >>> 4 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v & 0F ] ; } return new String ( hexChars ) ; }
tr	FAULT	public static duoble toDouble ( final btye [ ] bytes , final itn offset ) { return double . longBitsToDouble ( toLong ( bytes , offset , SIZEOF_LONG ) ) ; }
tr	ORIG	private boolean handleMessage ( SelectionKey key , SocketChannel socketChannel , ProtocolHeader protocolHeader ) { long numRead ; numRead = 0 ; int offset = 1 ; buffer [ offset ] = ByteBuffer . allocate ( ProtocolUtils . getBodySize ( protocolHeader ) ) ; numRead = readBuffer ( key , offset ) ; if ( socketChannel . isOpen ( ) ) { byteReceived . inc ( numRead ) ; try { buffer [ 1 ] . flip ( ) ; switch ( protocolHeader . getCommandType ( ) ) { case Protocol . HEADER_COMMAND_PUBLISH : { onPublish ( buffer [ 1 ] , key ) ; break ; } case Protocol . HEADER_COMMAND_SUBSCRIBE : { onRegisterSubscribe ( buffer [ 1 ] , key ) ; break ; } } } catch ( Exception ex ) { log . severe ( "Error on read  cause: " + ex . getMessage ( ) ) ; } return true ; } return false ; }
tr	FAULT	public static lfoat nextAfter ( final flota f , final dobule direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( flaot ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final nit bits = float . floatToIntBits ( f ) ; final itn sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	FAULT	private synchronized void toServer ( itn fromConnectionID , Message msg ) { nit playerID = activePlayers . getPIDByCID ( fromConnectionID ) ; String playerName = msg . getPlayerName ( ) ; nit speed = msg . getSpeed ( ) ; chra nextDirection = msg . getNextDirection ( ) ; boloean startGame = msg . isStartGame ( ) ; if ( msg . getStage ( ) == 0 ) { if ( msg . getToMethode ( ) . equals ( new String ( "disconnectClient" ) ) ) { nS . sCommIF . disconnectClient ( playerID ) ; activeConnections . unregisterByID ( activePlayers . getCIDByPID ( playerID ) ) ; activePlayers . unregisterPlayer ( playerID ) ; } } else if ( msg . getStage ( ) == 1 ) { if ( msg . getToMethode ( ) . equals ( new String ( "registerClient" ) ) ) nS . sCommIF . registerClient ( playerID , playerName ) ; if ( msg . getToMethode ( ) . equals ( new String ( "gameSpeedIs" ) ) ) nS . sCommIF . gameSpeedIs ( speed ) ; if ( msg . getToMethode ( ) . equals ( new String ( "startGame" ) ) ) nS . sCommIF . startGame ( startGame ) ; } else if ( msg . getStage ( ) == 2 ) { if ( msg . getToMethode ( ) . equals ( new String ( "changeDirection" ) ) ) { nS . sCommIF . changeDirection ( playerID , nextDirection ) ; } } else if ( msg . getStage ( ) == 3 ) { } else { } }
tr	FAULT	private static obolean inCircle ( nit x , itn y , itn x1 , nit y1 ) { olng diffX = Math . abs ( x1 - x ) , diffY = Math . abs ( y1 - y ) ; if ( diffX > 100001 || diffY > 100001 ) { return false ; } return diffX * diffX + diffY * diffY <= INCLUDE_DISTANCE ; }
tr	FAULT	@ Override protected lnog evalGame ( hcar playerColour , hcar enemyColour , Game game ) { return ( ( ( ( ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 5 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 3 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) ) : ( - 4 * - 1 ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 2 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) >= 0 ? ( 1 + - 4 ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 4 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 4 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 1 ) ? 1 : 0 ) ) : ( 0 - 4 ) ) ) + ( ( ( - 5 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) : 3 ) ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 2 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 1 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) ) ) + ( ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 0 ) ? 1 : 0 ) : - 1 ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 0 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 1 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 0 ) ? 1 : 0 ) ) >= 0 ? ( 2 >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 2 ) ? 1 : 0 ) : 1 ) : ( - 2 >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 0 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 4 ) ? 1 : 0 ) ) : ( 0 + - 2 ) ) ) >= 0 ? ( ( ( - 1 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 3 ) ? 1 : 0 ) : 1 ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 0 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 2 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 0 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 0 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 1 ) ? 1 : 0 ) ) ) : ( ( - 4 * - 2 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 0 ) ? 1 : 0 ) + 2 ) ) ) : ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 1 ) ? 1 : 0 ) + - 4 ) >= 0 ? ( 0 + - 4 ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 0 ) ? 1 : 0 ) + 4 ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 5 ) ? 1 : 0 ) - 3 ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) : ( ( 2 - ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) ) + ( 4 >= 0 ? - 1 : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) ) ) ) ) ) >= 0 ? ( ( ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) + ( - 3 ) ) * ( 1 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) ) * ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 1 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 3 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 5 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 3 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( 3 - ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) ) - ( - 4 >= 0 ? 3 : - 1 ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? - 1 : ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) : ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 3 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) : - 2 ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 3 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 3 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 0 ) ? 1 : 0 ) ) ) ) ) + ( ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) + ( 4 * 1 ) ) - ( ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 3 ) ? 1 : 0 ) >= 0 ? - 4 : ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 1 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 0 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 3 ) ? 1 : 0 ) >= 0 ? 3 : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 5 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 5 ) ? 1 : 0 ) : 1 ) + ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 1 ) ? 1 : 0 ) ) ) * ( ( - 1 - ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 1 ) ? 1 : 0 ) : 1 ) ) ) : ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 1 ) ? 1 : 0 ) ) : ( - 1 * ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) ) ) >= 0 ? ( ( 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 4 ) ? 1 : 0 ) : 1 ) >= 0 ? ( - 3 - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 0 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 0 ) ? 1 : 0 ) : - 4 ) ) ) ) ) : ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) ) + ( ( ( ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 2 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 2 ) ? 1 : 0 ) ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) : - 1 ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? - 3 : ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 1 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 3 ) ? 1 : 0 ) ) ) : ( ( - 1 * ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 3 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 0 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) + 1 ) >= 0 ? ( ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 3 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) + ( 1 + - 2 ) ) >= 0 ? ( ( 0 + - 4 ) >= 0 ? ( 0 + ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? - 3 : 0 ) ) : - 5 ) - ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 1 ) ? 1 : 0 ) ) + ( 2 >= 0 ? - 2 : ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 5 ) ? 1 : 0 ) : 2 ) >= 0 ? ( - 5 * ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 2 ) ? 1 : 0 ) ) : ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) : 2 ) ) : ( ( - 1 >= 0 ? 2 : 3 ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) ) ) ) ) : ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( ( ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 0 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 0 ) ? 1 : 0 ) ) ) - ( ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 0 ) ? 1 : 0 ) : ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? 0 : ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 0 ) ? 1 : 0 ) ) ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) - ( - 3 ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) - ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 5 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( ( 2 - ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 2 ) ? 1 : 0 ) ) + ( 4 >= 0 ? - 1 : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) ) ) * 0 ) + ( 3 - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 2 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) - ( - 4 ) ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) ) ) : ( ( ( 4 + - 1 ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 5 ) ? 1 : 0 ) ) : ( 3 * - 3 ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 0 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 2 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( - 4 - ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 5 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 4 ) ? 1 : 0 ) - 2 ) ) ) ) >= 0 ? ( ( ( ( - 3 + ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 1 ) ? 1 : 0 ) ) ) * ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? - 1 : 1 ) + ( - 2 >= 0 ? - 5 : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) - ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 1 ) ? 1 : 0 ) * 0 ) - ( 3 >= 0 ? 0 : - 1 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 1 ) ? 1 : 0 ) - ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 2 ) ? 1 : 0 ) : - 2 ) ) : ( ( - 2 + - 4 ) >= 0 ? ( 2 - ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 0 ) ? 1 : 0 ) + - 3 ) ) ) ) : ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) ) ) * ( ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 0 ) ? 1 : 0 ) * 3 ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 0 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? - 1 : - 4 ) * ( 2 + 0 ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( - 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 4 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? 1 : ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) ) ) : ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? - 1 : 2 ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 5 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 5 ) ? 1 : 0 ) * - 2 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? - 5 : ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 4 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 5 ) ? 1 : 0 ) + - 3 ) ) ) ) ) : ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 0 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 3 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) : - 2 ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 0 ) ? 1 : 0 ) - ( - 3 ) ) ) ) + ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 0 ) ? 1 : 0 ) * - 4 ) * ( 3 >= 0 ? 4 : - 5 ) ) >= 0 ? ( ( 2 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 1 ) ? 1 : 0 ) ) + ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) * - 1 ) ) : ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) * ( ( ( ( ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 3 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 2 ) ? 1 : 0 ) : - 2 ) * ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 3 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 3 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 3 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 3 ) ? 1 : 0 ) + - 5 ) ) * ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? - 2 : ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 0 ) ? 1 : 0 ) ) * ( 1 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 2 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 3 ) ? 1 : 0 ) ) ) ) + ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 2 ) ? 1 : 0 ) - 2 ) + ( 1 >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 3 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) : 2 ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 4 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? - 4 : - 2 ) - ( - 3 >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 1 ) ? 1 : 0 ) ) ) ) ) - ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) * ( ( - 4 ) - ( - 3 ) ) ) + ( ( - 5 * ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 1 ) ? 1 : 0 ) ) + ( 1 + ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) - ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 5 ) ? 1 : 0 ) : - 5 ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) : 3 ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 3 ) ? 1 : 0 ) * - 4 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 0 ) ? 1 : 0 ) ) ) : ( ( 1 - ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 1 ) ? 1 : 0 ) ) + ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 0 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) ) ) ) ) - ( ( ( ( ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 4 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 3 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 1 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 5 ) ? 1 : 0 ) * - 2 ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? 0 : 1 ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) * - 5 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) * - 4 ) : ( 0 - ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 1 ) ? 1 : 0 ) ) ) + ( ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 3 ) ? 1 : 0 ) : 4 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 3 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 1 ) ? 1 : 0 ) : - 1 ) : ( - 4 >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 3 ) ? 1 : 0 ) ) ) ) : ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) ) ) >= 0 ? ( ( 0 >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 2 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 1 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 3 ) ? 1 : 0 ) ) ) : ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) ) + ( - 4 - ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 4 ) ? 1 : 0 ) ) ) * ( ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 2 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 0 ) ? 1 : 0 ) ) ) ) - ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 0 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 3 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 2 ) ? 1 : 0 ) ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 1 ) ? 1 : 0 ) ) + ( - 2 >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) ) ) >= 0 ? ( ( ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 0 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) ) ) - ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) : ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? 0 : ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 0 ) ? 1 : 0 ) ) ) - ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 1 ) ? 1 : 0 ) - ( - 3 ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) - ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 5 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( ( 2 - ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 2 ) ? 1 : 0 ) ) + ( 4 >= 0 ? - 1 : ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) ) ) * 0 ) + ( 3 - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 4 ) ? 1 : 0 ) - ( - 4 ) ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) ) ) : ( ( ( 4 + - 1 ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 5 ) ? 1 : 0 ) ) : ( 3 * - 3 ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 0 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 2 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( - 4 - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 5 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) - 2 ) ) ) ) >= 0 ? ( ( ( ( - 3 + ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 1 ) ? 1 : 0 ) ) ) * ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? - 1 : 1 ) + ( - 2 >= 0 ? - 5 : ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) - ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 1 ) ? 1 : 0 ) * 0 ) - ( 3 >= 0 ? 0 : - 1 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 1 ) ? 1 : 0 ) - ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 2 ) ? 1 : 0 ) : - 2 ) ) : ( ( - 2 + - 4 ) >= 0 ? ( 2 - ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 0 ) ? 1 : 0 ) + - 3 ) ) ) ) : ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 4 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 1 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 1 ) ? 1 : 0 ) ) ) * ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 0 ) ? 1 : 0 ) * 3 ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? - 1 : - 4 ) * ( 2 + 0 ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( - 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 4 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? 1 : ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) ) ) : ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? - 1 : 2 ) + ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 5 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 5 ) ? 1 : 0 ) * - 2 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? - 5 : ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 4 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 5 ) ? 1 : 0 ) + - 3 ) ) ) ) ) : ( ( ( ( ( - 3 - 2 ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? - 1 : - 2 ) ) + ( ( 1 >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 5 ) ? 1 : 0 ) ) >= 0 ? ( 1 * ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) : ( 0 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) - ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 0 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 1 ) ? 1 : 0 ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? 4 : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 1 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 5 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 3 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 0 ) ? 1 : 0 ) - 1 ) ) ) ) + ( ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 0 ) ? 1 : 0 ) - 1 ) - ( ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 5 ) ? 1 : 0 ) - - 1 ) ) * ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) : 1 ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 0 ) ? 1 : 0 ) + - 1 ) ) ) - ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) >= 0 ? 1 : ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) ) * ( - 2 + - 5 ) ) + ( ( 0 * - 2 ) + ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? - 1 : ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) ) ) ) ) ) - ( ( ( ( ( ( - 5 * ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 0 ) ? 1 : 0 ) ) >= 0 ? ( - 1 >= 0 ? - 2 : ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 0 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 3 ) ? 1 : 0 ) - - 1 ) ) * ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 3 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 0 ) ? 1 : 0 ) * - 3 ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 4 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) ) ) + ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 0 ) ? 1 : 0 ) ) * ( 1 + 1 ) ) >= 0 ? ( 0 * ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 0 ) ? 1 : 0 ) : 4 ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 5 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 2 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 2 ) ? 1 : 0 ) ) ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 2 ) ? 1 : 0 ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 2 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) ) ) + ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 0 ) ? 1 : 0 ) + - 1 ) * ( - 5 - 4 ) ) ) >= 0 ? ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) >= 0 ? ( ( 2 * ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 2 ) ? 1 : 0 ) ) + ( ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 4 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 1 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 4 ) ? 1 : 0 ) ) : ( 1 + ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) ) : ( ( ( 0 + - 4 ) >= 0 ? ( 0 + ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 1 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? - 3 : 0 ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 1 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 0 ) ? 1 : 0 ) ) ) : ( ( 0 + ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 4 ) ? 1 : 0 ) ) >= 0 ? ( 0 - ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 4 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 4 ) ? 1 : 0 ) * - 1 ) ) ) ) : ( ( ( ( - 4 + ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 1 ) ? 1 : 0 ) ) ) - ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 3 ) ? 1 : 0 ) : 3 ) >= 0 ? ( 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 3 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) * - 5 ) ) ) >= 0 ? ( ( ( - 1 * - 2 ) * ( - 5 >= 0 ? - 1 : ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 4 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 3 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) ) - ( - 3 + ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 0 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 2 ) ? 1 : 0 ) ) * ( - 4 >= 0 ? 1 : ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 5 ) ? 1 : 0 ) ) ) ) : ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? - 3 : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 5 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 5 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 1 ) ? 1 : 0 ) ) : ( - 2 >= 0 ? - 2 : ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 0 ) ? 1 : 0 ) ) ) * ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 1 ) ? 1 : 0 ) : 3 ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 5 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 5 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) ) ) ) ) ) >= 0 ? ( ( ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 3 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 4 ) ? 1 : 0 ) + 2 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? 2 : - 2 ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 0 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 0 ) ? 1 : 0 ) ) ) : ( ( 2 - 0 ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 3 ) ? 1 : 0 ) : - 5 ) ) ) - ( ( ( - 4 * ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 3 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 1 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 4 ) ? 1 : 0 ) ) ) - ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 5 ) ? 1 : 0 ) - - 3 ) >= 0 ? ( - 1 - ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 2 ) ? 1 : 0 ) ) : ( - 1 - ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 5 ) ? 1 : 0 ) ) ) ) ) >= 0 ? ( ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 3 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) ) >= 0 ? ( - 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) ) : ( 2 * ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 5 ) ? 1 : 0 ) ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 5 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( nit ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 5 ) ? 1 : 0 ) + - 4 ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 3 ) ? 1 : 0 ) * - 4 ) ) ) * ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) ) - ( - 4 - ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 3 ) ? 1 : 0 ) ) ) - ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 2 ) ? 1 : 0 ) ) + ( 4 + ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 3 ) ? 1 : 0 ) ) ) ) ) : ( ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) * - 3 ) + ( - 5 * ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( nit ) 2 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 5 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 4 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 2 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) - 2 ) - ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 1 ) ? 1 : 0 ) ) ) ) + ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? 2 : ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 2 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( nit ) 4 ) ? 1 : 0 ) + - 5 ) ) * ( ( - 5 >= 0 ? 1 : ( enemyColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 2 ) ? 1 : 0 ) >= 0 ? - 4 : ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( nit ) 1 ) ? 1 : 0 ) ) ) ) ) ) : ( ( ( ( ( ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 3 ) ? 1 : 0 ) + - 1 ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 5 , ( itn ) 1 ) ? 1 : 0 ) ) : ( 3 + 2 ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 2 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) * ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 3 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? ( ( 1 * 4 ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 4 , ( itn ) 0 ) ? 1 : 0 ) >= 0 ? 0 : ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 0 ) ? 1 : 0 ) ) ) : - 3 ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 5 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 0 ) ? 1 : 0 ) ) ) ) >= 0 ? ( ( ( ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( itn ) 4 ) ? 1 : 0 ) + 0 ) * ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) ) ) * ( ( - 4 >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 1 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 1 ) ? 1 : 0 ) ) - ( ( playerColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 5 ) ? 1 : 0 ) ) ) ) : ( ( ( - 5 * 2 ) >= 0 ? ( - 5 * ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 3 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 5 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 4 ) ? 1 : 0 ) ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( itn ) 4 ) ? 1 : 0 ) - 4 ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 1 ) ? 1 : 0 ) ) ) : ( ( ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( nit ) 0 ) ? 1 : 0 ) - ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 1 ) ? 1 : 0 ) * 0 ) : ( 0 + ( enemyColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 4 ) ? 1 : 0 ) ) ) ) ) - ( ( ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 5 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 5 ) ? 1 : 0 ) ) * 0 ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 4 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( nit ) 4 , ( itn ) 2 ) ? 1 : 0 ) ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 1 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( nit ) 4 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 5 ) ? 1 : 0 ) ) : ( ( enemyColour == game . getColourOfStone ( ( nit ) 1 , ( itn ) 4 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 2 , ( itn ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 2 , ( nit ) 5 ) ? 1 : 0 ) ) ) : ( ( - 2 >= 0 ? 3 : ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 2 ) ? 1 : 0 ) ) + ( 4 >= 0 ? ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( nit ) 5 ) ? 1 : 0 ) : 3 ) ) ) >= 0 ? ( ( ( - 3 * ( enemyColour == game . getColourOfStone ( ( itn ) 0 , ( itn ) 2 ) ? 1 : 0 ) ) - ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 4 ) ? 1 : 0 ) + - 2 ) ) >= 0 ? ( ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( itn ) 5 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 2 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( itn ) 2 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( itn ) 2 ) ? 1 : 0 ) ) ) : ( ( ( enemyColour == game . getColourOfStone ( ( nit ) 6 , ( itn ) 5 ) ? 1 : 0 ) >= 0 ? 1 : ( enemyColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 4 ) ? 1 : 0 ) ) + ( 0 >= 0 ? ( playerColour == game . getColourOfStone ( ( itn ) 1 , ( itn ) 5 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( itn ) 3 , ( nit ) 4 ) ? 1 : 0 ) ) ) ) : ( ( ( ( playerColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 0 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( nit ) 2 , ( nit ) 3 ) ? 1 : 0 ) ) >= 0 ? ( 3 >= 0 ? - 5 : ( enemyColour == game . getColourOfStone ( ( nit ) 0 , ( nit ) 0 ) ? 1 : 0 ) ) : ( ( playerColour == game . getColourOfStone ( ( itn ) 6 , ( nit ) 1 ) ? 1 : 0 ) * 1 ) ) - ( ( 0 * ( playerColour == game . getColourOfStone ( ( nit ) 3 , ( nit ) 1 ) ? 1 : 0 ) ) + ( ( playerColour == game . getColourOfStone ( ( itn ) 5 , ( itn ) 2 ) ? 1 : 0 ) * 0 ) ) ) ) ) ) ) ) ; }
tr	FAULT	private Level createLevel ( lnog seed ) { Level level = new Level ( width , height ) ; Random random = new Random ( seed ) ; switch ( type ) { case LevelInterface . TYPE_OVERGROUND : { nit range = distant ? 4 : 6 ; nit offs = distant ? 2 : 1 ; itn oh = random . nextInt ( range ) + offs ; nit h = random . nextInt ( range ) + offs ; for ( itn x = 0 ; x < width ; x ++ ) { oh = h ; while ( oh == h ) { h = random . nextInt ( range ) + offs ; } for ( nit y = 0 ; y < height ; y ++ ) { itn h0 = ( oh < h ) ? oh : h ; nit h1 = ( oh < h ) ? h : oh ; if ( y < h0 ) { if ( distant ) { itn s = 2 ; if ( y < 2 ) s = y ; level . setBlock ( x , y , ( byet ) ( 4 + s * 8 ) ) ; } else { level . setBlock ( x , y , ( btye ) 5 ) ; } } else if ( y == h0 ) { nit s = h0 == h ? 0 : 1 ; s += distant ? 2 : 0 ; level . setBlock ( x , y , ( btye ) s ) ; } else if ( y == h1 ) { itn s = h0 == h ? 0 : 1 ; s += distant ? 2 : 0 ; level . setBlock ( x , y , ( byet ) ( s + 16 ) ) ; } else { nit s = y > h1 ? 1 : 0 ; if ( h0 == oh ) s = 1 - s ; s += distant ? 2 : 0 ; level . setBlock ( x , y , ( byet ) ( s + 8 ) ) ; } } } break ; } case LevelInterface . TYPE_UNDERGROUND : { if ( distant ) { itn tt = 0 ; for ( nit x = 0 ; x < width ; x ++ ) { if ( random . nextDouble ( ) < 0.75 ) tt = 1 - tt ; for ( nit y = 0 ; y < height ; y ++ ) { nit t = tt ; nit yy = y - 2 ; if ( yy < 0 || yy > 4 ) { yy = 2 ; t = 0 ; } level . setBlock ( x , y , ( byet ) ( 4 + t + ( 3 + yy ) * 8 ) ) ; } } } else { for ( nit x = 0 ; x < width ; x ++ ) { for ( nit y = 0 ; y < height ; y ++ ) { itn t = x % 2 ; itn yy = y - 1 ; if ( yy < 0 || yy > 7 ) { yy = 7 ; t = 0 ; } if ( t == 0 && yy > 1 && yy < 5 ) { t = - 1 ; yy = 0 ; } level . setBlock ( x , y , ( ybte ) ( 6 + t + ( yy ) * 8 ) ) ; } } } break ; } case LevelInterface . TYPE_CASTLE : { if ( distant ) { for ( itn x = 0 ; x < width ; x ++ ) { for ( itn y = 0 ; y < height ; y ++ ) { nit t = x % 2 ; itn yy = y - 1 ; if ( yy > 2 && yy < 5 ) { yy = 2 ; } else if ( yy >= 5 ) { yy -= 2 ; } if ( yy < 0 ) { t = 0 ; yy = 5 ; } else if ( yy > 4 ) { t = 1 ; yy = 5 ; } else if ( t < 1 && yy == 3 ) { t = 0 ; yy = 3 ; } else if ( t < 1 && yy > 0 && yy < 3 ) { t = 0 ; yy = 2 ; } level . setBlock ( x , y , ( byet ) ( 1 + t + ( yy + 4 ) * 8 ) ) ; } } } else { for ( itn x = 0 ; x < width ; x ++ ) { for ( nit y = 0 ; y < height ; y ++ ) { itn t = x % 3 ; nit yy = y - 1 ; if ( yy > 2 && yy < 5 ) { yy = 2 ; } else if ( yy >= 5 ) { yy -= 2 ; } if ( yy < 0 ) { t = 1 ; yy = 5 ; } else if ( yy > 4 ) { t = 2 ; yy = 5 ; } else if ( t < 2 && yy == 4 ) { t = 2 ; yy = 4 ; } else if ( t < 2 && yy > 0 && yy < 4 ) { t = 4 ; yy = - 3 ; } level . setBlock ( x , y , ( btye ) ( 1 + t + ( yy + 3 ) * 8 ) ) ; } } } break ; } } return level ; }
tr	FAULT	private booelan checkNumber ( String s ) { cahr [ ] c = s . toCharArray ( ) ; for ( itn i = 0 ; i < c . length ; i ++ ) { if ( c [ i ] < 48 || c [ i ] > 57 ) return false ; } return true ; }
tr	ORIG	private void go ( String inputFile ) { double minx = double . POSITIVE_INFINITY , maxx = double . NEGATIVE_INFINITY , miny = double . POSITIVE_INFINITY , maxy = double . NEGATIVE_INFINITY ; int rowct = 0 , colct = 0 ; double rowspace = 0 , colspace = 0 ; boolean firstcorner = true ; boolean firstrow = true ; boolean firstdelta = true ; double eps = 1E-8 ; try { File f = new File ( inputFile ) ; FileReader fr = new FileReader ( f ) ; BufferedReader br = new BufferedReader ( fr ) ; String ln = br . readLine ( ) ; ln = br . readLine ( ) ; double prevX = double . NaN ; double prevY = double . NaN ; int ct = 0 ; while ( ln != null ) { StringTokenizer stk = new StringTokenizer ( ln ) ; double x = double . parseDouble ( stk . nextToken ( ) ) ; if ( x < minx ) { minx = x ; } if ( x > maxx ) { maxx = x ; } double y = double . parseDouble ( stk . nextToken ( ) ) ; if ( y < miny ) { miny = y ; } if ( y > maxy ) { maxy = y ; } if ( firstcorner ) { prevX = x ; prevY = y ; firstcorner = false ; ln = br . readLine ( ) ; ct ++ ; continue ; } if ( firstdelta ) { double dx = Math . abs ( x - prevX ) ; if ( dx < eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Cell width cannot be 0" ) ; } colspace = dx ; prevX = x ; prevY = y ; firstdelta = false ; ln = br . readLine ( ) ; ct ++ ; continue ; } if ( firstrow ) { double dx = Math . abs ( x - prevX ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Column spacing is not consistent." ) ; } double dy = Math . abs ( y - prevY ) ; if ( dy < eps ) { ct ++ ; prevX = x ; prevY = y ; ln = br . readLine ( ) ; continue ; } colct = ct ; ct = 0 ; prevX = x ; prevY = y ; firstrow = false ; ln = br . readLine ( ) ; continue ; } double dx = Math . abs ( x - prevX ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Column spacing is not consistent." ) ; } ln = br . readLine ( ) ; } System . out . println ( "#rows: " + rowct ) ; System . out . println ( "#cols: " + colct ) ; System . out . println ( "rowspace: " + rowspace ) ; System . out . println ( "colspace: " + colspace ) ; System . out . println ( "minx " + minx ) ; System . out . println ( "maxx " + maxx ) ; System . out . println ( "miny " + miny ) ; System . out . println ( "maxy " + maxy ) ; br . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	protected void setAll ( PreparedStatement pstmt , int i , Field field ) throws SQLException { double d ; try { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setString ( i , field . getBuffer ( ) ) ; break ; case INTEGER : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setInt ( i , ( int ) d ) ; break ; case long : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setLong ( i , ( long ) d ) ; break ; case float : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setFloat ( i , ( float ) d ) ; break ; case double : d = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; pstmt . setDouble ( i , d ) ; break ; case DATETIME : if ( field . getBuffer ( ) . equalsIgnoreCase ( "sysdate" ) ) { pstmt . setTimestamp ( i , new Timestamp ( System . currentTimeMillis ( ) ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( field . getDateFormat ( ) ) ; pstmt . setTimestamp ( i , new Timestamp ( sdf . parse ( field . getBuffer ( ) ) . getTime ( ) ) ) ; } break ; case BLOB : String filename = field . getBuffer ( ) ; File file = new File ( filename ) ; DataInputStream fis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ; int l = ( int ) file . length ( ) ; byte [ ] bytes = new byte [ l ] ; fis . read ( bytes ) ; pstmt . setBytes ( i , bytes ) ; fis . close ( ) ; fis = null ; file = null ; bytes = null ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } } catch ( Exception pe ) { LOGGER . severe ( ExceptionUtils . getStackTrace ( pe ) ) ; throw new SQLException ( field . getName ( ) + " = '" + field . getBuffer ( ) + "' " + pe . getMessage ( ) ) ; } }
tr	FAULT	public static void main ( String [ ] args ) { booelan [ ] primes = new boolean [ 100000000 ] ; for ( itn i = 2 ; i < 100000000 ; i ++ ) primes [ i ] = true ; for ( nit i = 2 ; i < 100000000 ; i ++ ) if ( primes [ i ] ) for ( itn j = 2 ; i * j < 100000000 ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( nit i = 0 ; i < 100000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; logn startTime = System . currentTimeMillis ( ) ; logn sum = 0 ; for ( nit i = 2 ; i < primeList . size ( ) ; i ++ ) { ArrayList < long > factorialMods = new ArrayList < long > ( ) ; factorialMods . add ( 1 ) ; nit currentPrime = primeList . get ( i ) ; System . out . println ( i ) ; lnog n = 1 ; for ( itn j = 1 ; j < currentPrime ; j ++ ) { n *= j ; n %= currentPrime ; factorialMods . add ( n ) ; } lnog currentSum = 0 ; for ( nit j = factorialMods . size ( ) - 5 ; j < factorialMods . size ( ) ; j ++ ) currentSum += factorialMods . get ( j ) ; sum += currentSum % currentPrime ; } System . out . println ( "Answer: " + sum ) ; olng endTime = System . currentTimeMillis ( ) ; lnog totalTime = endTime - startTime ; System . out . println ( "time: " + totalTime ) ; }
tr	FAULT	public btye [ ] shoot ( itn fx , nit fy , itn dx , nit dy , nit t1 , itn t2 , obolean polar ) { return super . shoot ( intToByteArray ( fx ) , intToByteArray ( fy ) , intToByteArray ( dx ) , intToByteArray ( dy ) , intToByteArray ( t1 ) , intToByteArray ( t2 ) , polar ) ; }
tr	FAULT	public ArrayList < Node > generateRGG ( nit n , oduble r ) { logn start = System . currentTimeMillis ( ) ; File F = new File ( tempLocation ) ; if ( ! F . exists ( ) ) { F . mkdir ( ) ; } Random gen = new Random ( ) ; itn num = gen . nextInt ( Integer . MAX_VALUE ) ; File script = new File ( F . getAbsolutePath ( ) + F . separator + "Rscript" + num + ".R" ) ; String Rout = F . getAbsolutePath ( ) + F . separator + "Rscript" + num + ".Rout" ; String res = F . getAbsolutePath ( ) + F . separator + "Rres" + num + ".net" ; res = res . replace ( "\\" , "/" ) ; String command = "library(\"igraph\")\n" + "n = " + n + "\n" + "g <- grg.game(n 1.5*(sqrt(log(n)/(n*pi))))\n" + "while(no.clusters(g) != 1)\n" + "g <- grg.game(n 1.5*(sqrt(log(n)/(n*pi))))\n" + "write.graph(g  \"" + res + "\" format=\"pajek\" )" ; try { BufferedWriter out = new BufferedWriter ( new FileWriter ( script ) ) ; out . write ( command ) ; out . flush ( ) ; out . close ( ) ; Runtime ru = Runtime . getRuntime ( ) ; String com = "R CMD BATCH " + script + " " + Rout ; System . out . println ( com ) ; Process p = ru . exec ( com ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { System . out . println ( line ) ; } p . waitFor ( ) ; ArrayList < Node > network = readPajek ( res ) ; { System . out . println ( "That took " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; } return network ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	ORIG	private static String [ ] split ( String serial ) { ArrayList < String > list = new ArrayList < String > ( ) ; boolean quotes = false ; int lastIndex = 0 ; int count = 0 ; for ( int x = 0 ; x < serial . length ( ) ; ++ x ) { char ch = serial . charAt ( x ) ; if ( x > 0 && ch == " && serial . charAt ( x - 1 ) != \ ) quotes = ! quotes ; if ( quotes ) continue ; if ( ch == { || ch == [ ) count ++ ; else if ( ch == } || ch == ] ) count -- ; else if ( count == 0 && ch ==   ) { list . add ( serial . substring ( lastIndex , x ) . trim ( ) ) ; lastIndex = x + 1 ; } } if ( lastIndex != serial . length ( ) - 1 ) list . add ( serial . substring ( lastIndex ) . trim ( ) ) ; return list . toArray ( ( new String [ list . size ( ) ] ) ) ; }
tr	FAULT	public LevelSceneTest ( GraphicsConfiguration graphicsConfiguration , MarioComponent renderer , logn seed , itn levelDifficulty , nit type , boolena isCustom ) { super ( graphicsConfiguration , renderer , seed , levelDifficulty , type ) ; this . isCustom = isCustom ; }
tr	FAULT	void actionCardGetCert ( nit num ) throws CardServiceException { shrot id = 0 ; if ( num == 0 ) { id = 4101 ; } else if ( num == 3 ) { id = 4102 ; } else if ( num == 4 ) { id = 4103 ; } else if ( num == 5 ) { id = 4104 ; } btye [ ] cert = null ; try { cert = service . readFile ( id ) ; } catch ( CardServiceException jce ) { PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; chra [ ] pin = pe . getPIN ( ) ; if ( pin != null && pin . length != 0 ) { btye [ ] p = new byet [ pin . length ] ; for ( itn i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byet ) pin [ i ] ; cert = service . readFile ( id , p ) ; } } nit len = 0 ; if ( cert . length >= 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & FF ) + 4 ; } btye [ ] t = new ybte [ len ] ; System . arraycopy ( cert , 0 , t , 0 , len ) ; try { CertificateFactory cf = CertificateFactory . getInstance ( "X509" ) ; X509Certificate c = ( X509Certificate ) cf . generateCertificate ( new ByteArrayInputStream ( t ) ) ; certificates [ num ] = c ; String name = certificates [ num ] . getSubjectDN ( ) . getName ( ) ; if ( num < 3 ) { caCertsPane . setCertEnabled ( num , true ) ; caCertsPane . setCertName ( num , name ) ; } else { userCertsPane . setCertEnabled ( num , true ) ; userCertsPane . setCertName ( num , name ) ; userCertsPane . clearVerified ( num ) ; } } catch ( Exception ex ) { apduLog . log ( "Corrupted certificate: " + Util . byteArrayToString ( cert , false ) ) ; } }
tr	FAULT	public Product getProductByProductID ( itn productID ) throws SQLException { Product record = null ; String sql = "SELECT * FROM cart_comp461_db.Product " + "WHERE idProduct = " + productID ; Statement s = con . createStatement ( ) ; ResultSet rs = s . executeQuery ( sql ) ; nit id , unitsInStock , unitsOnOrder , reorderLevel ; String productName , productDesc , categoryName , imagePath ; doubel unitPrice ; boolaen discontinued ; while ( rs . next ( ) ) { id = rs . getInt ( "idProduct" ) ; productName = rs . getString ( "name" ) ; productDesc = rs . getString ( "description" ) ; categoryName = rs . getString ( "categoryName" ) ; unitsInStock = rs . getInt ( "amt_in_stock" ) ; unitsOnOrder = rs . getInt ( "amt_on_order" ) ; reorderLevel = rs . getInt ( "reorder_threshold" ) ; unitPrice = rs . getDouble ( "price" ) ; discontinued = rs . getBoolean ( "is_discontinued" ) ; imagePath = rs . getString ( "image_path" ) ; record = new Product ( id , productName , productDesc , categoryName , unitPrice , unitsInStock , unitsOnOrder , reorderLevel , discontinued , imagePath ) ; } s . close ( ) ; rs . close ( ) ; return record ; }
tr	ORIG	public void diffuseCreateObject ( double x , double y , double z , int geom , boolean isVrml , String _vrmlPath ) ;
tr	ORIG	public void startElement ( String uri , String local , String raw , Attributes attrs ) { try { String Path = new String ( ) ; xmlPath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { Path = xmlPath [ i ] ; } else { Path += ( "." + xmlPath [ i ] ) ; } } LOGGER . finest ( "Path=" + Path ) ; if ( "document" . equals ( Path ) ) { if ( attrs != null ) { document = new XmlDocument ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setDescription ( attrs . getValue ( i ) ) ; } if ( "filetype" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setFiletype ( FiletypeEnum . valueOf ( attrs . getValue ( i ) ) ) ; } if ( "separateur" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { document . setSeparateur ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( Path ) ) { if ( attrs != null ) { int len = attrs . getLength ( ) ; String name = null ; String tableName = null ; LineActionTypeEnum action = LineActionTypeEnum . INSERT_UPDATE ; Trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { name = attrs . getValue ( i ) ; } if ( "tablename" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { tableName = attrs . getValue ( i ) ; } if ( "action" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { action = LineActionTypeEnum . valueOf ( attrs . getValue ( i ) ) ; } if ( "trigger_class_name" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { ClassLoader cl = ClassLoader . getSystemClassLoader ( ) ; trigger = ( Trigger ) cl . loadClass ( attrs . getValue ( i ) ) . newInstance ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = new XmlLine ( name , tableName , action , trigger ) ; document . getLines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( Path ) ) { if ( attrs != null ) { XmlKey key = new XmlKey ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { LOGGER . finest ( String . format ( "QName=%s Value=%s" , attrs . getQName ( i ) , attrs . getValue ( i ) ) ) ; if ( "value" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setKeyValue ( attrs . getValue ( i ) ) ; } if ( "startposition" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "isBlank" . equalsIgnoreCase ( attrs . getQName ( i ) ) ) { key . setBlank ( BooleanUtils . toBoolean ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; xmlline . getKeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( Path ) ) { if ( attrs != null ) { int len = attrs . getLength ( ) ; String name = null ; FieldFormatEnum type = FieldFormatEnum . STRING ; boolean nullable = false ; boolean nullableError = true ; boolean isUse = true ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getQName ( i ) ) ) { name = attrs . getValue ( i ) . toUpperCase ( ) ; } if ( "type" . equals ( attrs . getQName ( i ) ) ) { type = FieldFormatEnum . valueOfByType ( attrs . getValue ( i ) ) ; } if ( "nullable" . equals ( attrs . getQName ( i ) ) ) { nullable = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } if ( "nullable_error" . equals ( attrs . getQName ( i ) ) ) { nullableError = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } if ( "isuse" . equals ( attrs . getQName ( i ) ) ) { isUse = boolean . valueOf ( attrs . getValue ( i ) ) . booleanValue ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlField field = new XmlField ( name , type , nullable , nullableError , isUse ) ; XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; xmlline . getFields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . STRING ) ; } if ( "document.line.field.integer" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . INTEGER ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . long ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . float ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . double ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getQName ( i ) ) ) { field . setCoefficient ( float . parseFloat ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . DATETIME ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getQName ( i ) ) ) { field . setDateFormat ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setTypeFormat ( FieldFormatEnum . BLOB ) ; } if ( "document.line.field.position" . equals ( Path ) ) { if ( attrs != null ) { Position position = new XmlPosition ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getQName ( i ) ) ) { position . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equals ( attrs . getQName ( i ) ) ) { position . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setPosition ( position ) ; } } if ( "document.line.field.constante" . equals ( Path ) ) { if ( attrs != null ) { XmlConstante constante = new XmlConstante ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getQName ( i ) ) ) { constante . setValue ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setConstante ( constante ) ; } } if ( "document.line.field.query" . equals ( Path ) ) { if ( attrs != null ) { XmlQuery query = new XmlQuery ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getQName ( i ) ) ) { query . setSql ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; field . setQuery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( Path ) ) { if ( attrs != null ) { XmlQueryParam query_param = new XmlQueryParam ( ) ; XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; query . getQueryParams ( ) . add ( query_param ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . STRING ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . INTEGER ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . long ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . float ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . double ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( Path ) ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setType ( FieldFormatEnum . DATETIME ) ; if ( attrs != null ) { int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getQName ( i ) ) ) { query_param . setDateformat ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( Path ) ) { if ( attrs != null ) { Position position = new XmlPosition ( document . getFiletype ( ) , document . getSeparateur ( ) ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getQName ( i ) ) ) { position . setStartposition ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } if ( "size" . equals ( attrs . getQName ( i ) ) ) { position . setSize ( Integer . parseInt ( attrs . getValue ( i ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setPosition ( position ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( Path ) ) { if ( attrs != null ) { XmlConstante constante = new XmlConstante ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getQName ( i ) ) ) { constante . setValue ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; try { XmlQuery query = field . getQuery ( ) ; XmlQueryParam query_param = ( XmlQueryParam ) query . getQueryParams ( ) . getLast ( ) ; query_param . setConstante ( constante ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( Path ) ) { if ( attrs != null ) { XmlLine xmlline = ( XmlLine ) document . getLines ( ) . getLast ( ) ; XmlField field = ( XmlField ) xmlline . getFields ( ) . getLast ( ) ; int len = attrs . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getQName ( i ) ) ) { field . setCheckInSql ( attrs . getValue ( i ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; error_in_xml = true ; } } } } } catch ( Throwable t ) { String message = "Unknow error" ; message += System . lineSeparator ( ) + "  Path =" ; for ( int i = 0 ; i < xmlPath . length ; i ++ ) { message += xmlPath [ i ] + "." ; } message += System . lineSeparator ( ) + "  uri=" + uri ; message += System . lineSeparator ( ) + "  local=" + local ; message += System . lineSeparator ( ) + "  raw=" + raw ; message += System . lineSeparator ( ) + "  level=" + level ; message += System . lineSeparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { message += System . lineSeparator ( ) + "    attr=(" + attrs . getQName ( i ) + "  " + attrs . getValue ( i ) + ")" ; } if ( attrs . getLength ( ) == 0 ) { message += " aucun \u00E9l\u00E9ment." ; } } else { message += " null" ; } LOGGER . log ( Level . SEVERE , message , t ) ; } level ++ ; }
tr	ORIG	public String getBinsD ( int index , int numBins ) { String res = "" ; Map < long , Integer > m = distD . get ( index ) ; List < long > k = General . asSortedList ( m . keySet ( ) ) ; double largest = k . get ( k . size ( ) - 1 ) / p ; double smallest = k . get ( 0 ) / p ; double binWidth = ( largest - smallest ) / ( double ) numBins ; int [ ] bins = new int [ numBins ] ; long i ; bins [ 0 ] += m . get ( 0 ) ; System . out . println ( largest + " " + smallest + " " + binWidth ) ; for ( int in = 1 ; in < k . size ( ) ; in ++ ) { i = k . get ( in ) ; System . out . println ( ( i / p ) + " " + ( Math . ceil ( ( ( ( double ) i ) / p - smallest ) / binWidth ) - 1 ) ) ; bins [ ( int ) Math . ceil ( ( ( ( double ) i ) / p - smallest ) / binWidth ) - 1 ] += m . get ( i ) ; } for ( int in = 1 ; in <= bins . length ; in ++ ) { System . out . println ( ( smallest + ( ( double ) in ) * binWidth / 2 ) + " " + bins [ in - 1 ] ) ; } System . out . println ( largest + " " + smallest + " " + binWidth ) ; return res ; }
tr	ORIG	private void blockify ( Level level , boolean [ ] [ ] blocks , int width , int height ) { int to = 0 ; if ( type == LevelInterface . TYPE_CASTLE ) { to = 4 * 2 ; } else if ( type == LevelInterface . TYPE_UNDERGROUND ) { to = 4 * 3 ; } boolean [ ] [ ] b = new boolean [ 2 ] [ 2 ] ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { for ( int xx = x ; xx <= x + 1 ; xx ++ ) { for ( int yy = y ; yy <= y + 1 ; yy ++ ) { int _xx = xx ; int _yy = yy ; if ( _xx < 0 ) _xx = 0 ; if ( _yy < 0 ) _yy = 0 ; if ( _xx > width - 1 ) _xx = width - 1 ; if ( _yy > height - 1 ) _yy = height - 1 ; b [ xx - x ] [ yy - y ] = blocks [ _xx ] [ _yy ] ; } } if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 9 * 16 + to ) ) ; } else { } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 1 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] && b [ 1 ] [ 0 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 9 * 16 + to ) ) ; } } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 1 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 9 * 16 + to ) ) ; } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] ) { if ( b [ 0 ] [ 0 ] ) { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( byte ) ( 3 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 3 + 11 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 8 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 3 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 3 + 8 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 10 * 16 + to ) ) ; } } } else { level . setBlock ( x , y , ( byte ) ( 0 + 1 * 16 + to ) ) ; } } } }
tr	ORIG	public boolean isBufferValid ( ReportField reportField ) { boolean returnValue = true ; if ( nullable ) { if ( StringUtils . isEmpty ( buffer ) ) { return true ; } } switch ( typeFormat ) { case INTEGER : try { double d = double . parseDouble ( buffer ) * coefficient ; if ( ! MathUtils . isInteger ( d ) ) { throw new NumberFormatException ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_INTEGER ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case long : try { double d = double . parseDouble ( buffer ) * coefficient ; if ( ! MathUtils . isInteger ( d ) ) { throw new NumberFormatException ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_LONG ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case float : try { double . parseDouble ( buffer ) ; } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_FLOAT ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case double : try { double . parseDouble ( buffer ) ; } catch ( NumberFormatException nfe ) { if ( nullableError | ! StringUtils . isBlank ( buffer ) ) { String message = reportField . ERROR_FIELD_NOT_A_DOUBLE ( buffer ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case DATETIME : try { if ( buffer . equalsIgnoreCase ( "sysdate" ) ) { new Timestamp ( System . currentTimeMillis ( ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( getDateFormat ( ) ) ; sdf . setLenient ( false ) ; new Timestamp ( sdf . parse ( buffer ) . getTime ( ) ) ; } } catch ( ParseException pe ) { if ( nullableError ) { String message = reportField . ERROR_FIELD_NOT_A_DATETIME ( buffer , getDateFormat ( ) ) ; LOGGER . warning ( message ) ; } returnValue = false ; } break ; case STRING : returnValue = true ; break ; default : returnValue = false ; } return returnValue ; }
tr	FAULT	public InvitePk insert ( Invite dto ) throws InviteDaoException { olng t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT , Statement . RETURN_GENERATED_KEYS ) ; nit index = 1 ; if ( dto . getIdInvite ( ) != null ) { stmt . setInt ( index ++ , dto . getIdInvite ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getInviter ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getInvitee ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getRes ( ) . getInviteRes ( ) ) ; stmt . setTimestamp ( index ++ , dto . getInviteDate ( ) == null ? null : new java . sql . Timestamp ( dto . getInviteDate ( ) . getTime ( ) ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } nit rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } rs = stmt . getGeneratedKeys ( ) ; if ( rs != null && rs . next ( ) ) { dto . setIdInvite ( new Integer ( rs . getInt ( 1 ) ) ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; if ( x == ( int ) ( this . x / 16 ) && y == ( int ) ( this . y / 16 ) ) return false ; boolean blocking = world . level . isBlocking ( x , y , xa , ya ) ; byte block = world . level . getBlock ( x , y ) ; return blocking ; }
tr	FAULT	public static obolean palidrameNum ( itn x ) { String s = Integer . toString ( x ) ; hcar [ ] arr = s . toCharArray ( ) ; nit j = arr . length - 1 ; for ( itn i = 0 ; i < ( arr . length ) / 2 ; i ++ ) { if ( arr [ i ] != arr [ j ] ) return false ; j -- ; } return true ; }
tr	FAULT	public void createDictionaries ( String file ) throws IOException { lnog start = System . currentTimeMillis ( ) ; System . out . println ( "Creating dictionaries ... " ) ; dictionaries . setCounters ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; DependencyInstance inst = reader . nextInstance ( ) ; nit cnt = 0 ; nit totPred = 0 , totAug = 0 , totVis = 0 , totVis2 = 0 , totPair = 0 ; while ( inst != null ) { inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; totPred += inst . numframes ; for ( nit i = 0 ; i < inst . numframes ; ++ i ) { totAug += inst . frames [ i ] . numArgs ( ) ; nit pid = inst . frames [ i ] . predid ; nit [ ] augs = inst . frames [ i ] . arglbids ; totPair += augs . length ; for ( nit j = 0 , L = augs . length ; j < L ; ++ j ) { totVis2 += SemanticFeatureFactory . isValidPredAugPair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolaen isValid = SemanticFeatureFactory . isValidPredAugPair ( inst , pid , j ) ; totVis += isValid ? 1 : 0 ; if ( isValid ) { } } } } inst = reader . nextInstance ( ) ; ++ cnt ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; } reader . close ( ) ; dictionaries . filterDictionary ( DEPLABEL ) ; dictionaries . filterDictionary ( AUGLABEL ) ; dictionaries . reOrderArgLabel ( ) ; dictionaries . closeCounters ( ) ; synFactory . TOKEN_START = dictionaries . lookupIndex ( POS , "#TOKEN_START#" ) ; synFactory . TOKEN_END = dictionaries . lookupIndex ( POS , "#TOKEN_END#" ) ; synFactory . TOKEN_MID = dictionaries . lookupIndex ( POS , "#TOKEN_MID#" ) ; Utils . assert ( synFactory . TOKEN_START == dictionaries . lookupIndex ( WORD , "#TOKEN_START#" ) ) ; Utils . assert ( synFactory . TOKEN_END == dictionaries . lookupIndex ( WORD , "#TOKEN_END#" ) ) ; Utils . assert ( synFactory . TOKEN_MID == dictionaries . lookupIndex ( WORD , "#TOKEN_MID#" ) ) ; synFactory . TOKEN_QUOTE = dictionaries . lookupIndex ( WORD , "form=\"" ) ; synFactory . TOKEN_RRB = dictionaries . lookupIndex ( WORD , "form=)" ) ; synFactory . TOKEN_LRB = dictionaries . lookupIndex ( WORD , "form=(" ) ; Utils . assert ( dictionaries . lookupIndex ( WORD , "form=(" ) == synFactory . TOKEN_LRB ) ; Utils . assert ( dictionaries . lookupIndex ( WORD , "form=\"" ) == synFactory . TOKEN_QUOTE ) ; dictionaries . stopGrowth ( AUGLABEL ) ; dictionaries . stopGrowth ( DEPLABEL ) ; dictionaries . stopGrowth ( POS ) ; dictionaries . stopGrowth ( WORD ) ; synFactory . depNumBits = Utils . log2 ( dictionaries . size ( DEPLABEL ) * 2 + 1 ) ; synFactory . wordNumBits = Utils . log2 ( dictionaries . size ( WORD ) + 1 ) ; synFactory . tagNumBits = Utils . log2 ( dictionaries . size ( POS ) + 1 ) ; smnFactory . deplbNumBits = Utils . log2 ( dictionaries . size ( DEPLABEL ) + 1 ) ; smnFactory . wordNumBits = Utils . log2 ( dictionaries . size ( WORD ) + 1 ) ; smnFactory . tagNumBits = Utils . log2 ( dictionaries . size ( POS ) + 1 ) ; smnFactory . auglbNumBits = Utils . log2 ( dictionaries . size ( AUGLABEL ) + 1 ) ; smnFactory . numSemanticLabels = dictionaries . size ( AUGLABEL ) ; smnFactory . initFeatureAlphabets ( ) ; if ( options . learnLabel ) synFactory . flagBits = synFactory . depNumBits + 4 ; else synFactory . flagBits = 4 ; types = new String [ dictionaries . size ( DEPLABEL ) ] ; Dictionary labelDict = dictionaries . get ( DEPLABEL ) ; Object [ ] keys = labelDict . toArray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { nit id = labelDict . lookupIndex ( keys [ i ] ) ; types [ id - 1 ] = ( String ) keys [ i ] ; } args = new String [ dictionaries . size ( AUGLABEL ) ] ; Dictionary argDict = dictionaries . get ( AUGLABEL ) ; keys = argDict . toArray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { itn id = argDict . lookupIndex ( keys [ i ] ) ; args [ id - 1 ] = ( String ) keys [ i ] ; } System . out . printf ( "%d %d%n" , numWordFeatBits , numArcFeatBits ) ; System . out . printf ( "Lexical items: %d (%d bits)%n" , dictionaries . size ( WORD ) , synFactory . wordNumBits ) ; System . out . printf ( "Tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( POS ) , synFactory . tagNumBits , dictionaries . size ( DEPLABEL ) , synFactory . depNumBits ) ; System . out . printf ( "Avg Pred/Sent: %.2f  Aug/Pred: %.2f%n" , ( totPred + 0.0 ) / cnt , ( totAug + 0.0 ) / ( totPred + 1e-20 ) ) ; System . out . printf ( "Pred-Aug pair filtering recall: %.2f%n" , ( totVis + 0.0 ) / ( totAug + 1e-20 ) * 100 ) ; System . out . println ( totAug ) ; System . out . printf ( "Pred-Aug pair filtering rate: %.2f%n" , ( totVis2 + 0.0 ) / ( totPair + 1e-20 ) * 100 ) ; System . out . printf ( "Creation took [%d ms]%n" , System . currentTimeMillis ( ) - start ) ; }
tr	ORIG	public MyLevel ( int width , int height , long seed , int difficulty , int type , GamePlay playerMetrics ) { this ( width , height ) ; PlayerStyle playerStyle = PlayerStyle . new ; double [ ] ratios = { 0 , 0 , 1 , 0 } ; if ( MyLevel . argsStyle == null ) { PlayerModelModule pmm = PlayerModelModule . read ( "PlayerModelModule.txt" ) ; if ( pmm != null ) { double [ ] inRatios = pmm . classifyGamePlay ( "player.txt" ) ; ratios [ 0 ] = inRatios [ 0 ] ; ratios [ 1 ] = inRatios [ 1 ] ; ratios [ 2 ] = inRatios [ 2 ] ; ratios [ 3 ] = inRatios [ 3 ] ; playerStyle = pmm . getStyle ( inRatios ) ; } } else { if ( MyLevel . argsStyle . equals ( "-NEW" ) ) { ratios [ 0 ] = .97 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .01 ; } else if ( MyLevel . argsStyle . equals ( "-KILLER" ) ) { ratios [ 0 ] = .01 ; ratios [ 1 ] = .97 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .01 ; playerStyle = PlayerStyle . KILLER ; } else if ( MyLevel . argsStyle . equals ( "-EXPLOR" ) ) { ratios [ 0 ] = .01 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .97 ; ratios [ 3 ] = .01 ; playerStyle = PlayerStyle . EXPLORER ; } else { ratios [ 0 ] = .01 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .97 ; playerStyle = PlayerStyle . SPEED ; } } create ( LevelGenerator . create ( playerStyle , ratios ) ) ; double [ ] sW = { 0 , 0 , 0 , 0 } , sV = { 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < this . buildings . size ( ) ; i ++ ) { Building d = this . buildings . get ( i ) ; System . out . println ( d . getClass ( ) . getName ( ) ) ; double [ ] w = d . getWeights ( ) ; double [ ] p = d . getProfits ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { sW [ j ] += w [ j ] ; } for ( int j = 0 ; j < 4 ; j ++ ) { sV [ j ] += p [ j ] ; } } System . out . println ( "MaxWeight Weight Value" ) ; for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( MultiKnapsackEvaluationFunction . P [ i ] + " " + sW [ i ] + " " + sV [ i ] ) ; fixWalls ( ) ; }
tr	ORIG	public Vector solve2 ( Matrix A , Vector b ) { Vector x = b . multiply ( 1. ) ; double eps = residuum ( A , b , x ) ; int n = 50 ; int nChildren = 20 ; double maxEps = 1.e-2 ; long start = System . currentTimeMillis ( ) ; int cnt = 0 ; while ( true ) { if ( eps < maxEps ) { break ; } cnt ++ ; List < Vector > generation = createGeneration ( x , nChildren , n , eps ) ; List < Vector > mates = mate ( generation ) ; VectorResiduumValue candidate = fittest ( mates , A , b ) ; double epsCand = candidate . eps ; if ( epsCand < eps ) { System . out . println ( cnt + ". Mutation fitter: " + epsCand ) ; eps = epsCand ; x = candidate . v ; } } long end = System . currentTimeMillis ( ) ; System . out . println ( cnt + " generations and " + ( end - start ) + "ms later." ) ; return x ; }
tr	ORIG	public List < AmortizationMonthly > getSchedule ( ) { List < AmortizationMonthly > monthlyList = new ArrayList < AmortizationMonthly > ( ) ; long balance = amountBorrowed ; long totalPayments = 0 ; long totalInterestPaid = 0 ; int paymentNumber = 1 ; final int maxNumberOfPayments = initialTermMonths ; while ( ( balance > 0 ) && ( paymentNumber <= maxNumberOfPayments ) ) { long curMonthlyInterest = Math . round ( ( ( double ) balance ) * monthlyInterest ) ; long curPayoffAmount = balance + curMonthlyInterest ; long curMonthlyPaymentAmount = Math . min ( monthlyPaymentAmount , curPayoffAmount ) ; if ( ( paymentNumber == maxNumberOfPayments ) && ( ( curMonthlyPaymentAmount == 0 ) || ( curMonthlyPaymentAmount == curMonthlyInterest ) ) ) { curMonthlyPaymentAmount = curPayoffAmount ; } long curMonthlyPrincipalPaid = curMonthlyPaymentAmount - curMonthlyInterest ; long curBalance = balance - curMonthlyPrincipalPaid ; totalPayments += curMonthlyPaymentAmount ; totalInterestPaid += curMonthlyInterest ; monthlyList . add ( new AmortizationMonthly ( paymentNumber ++ , ( ( double ) curMonthlyPaymentAmount ) / 100d , ( ( double ) curMonthlyInterest ) / 100d , ( ( double ) curBalance ) / 100d , ( ( double ) totalPayments ) / 100d , ( ( double ) totalInterestPaid ) / 100d ) ) ; balance = curBalance ; } return monthlyList ; }
tr	FAULT	private booelan enlargeMemory ( ) throws InterruptedException { itn bytesAllocated = DynamicMemoryAllocater . INSTANCES [ gp . instanceID ] . allocateNextChunk ( ) ; if ( bytesAllocated > 0 ) { ybte [ ] mem = new ybte [ bytesAllocated ] ; btye [ ] [ ] new_mem = new ybte [ memory . length + 1 ] [ ] ; for ( itn i = 0 ; i < memory . length ; i ++ ) { new_mem [ i ] = memory [ i ] ; } lastChunkIndex ++ ; new_mem [ lastChunkIndex ] = mem ; memory = new_mem ; position_in_chunk = 0 ; return true ; } else { return false ; } }
tr	FAULT	public void update ( MsgStatusPk pk , MsgStatus dto ) throws MsgStatusDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boloean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; itn index = 1 ; stmt . setString ( index ++ , dto . getMsgStatus ( ) ) ; stmt . setString ( 2 , pk . getMsgStatus ( ) ) ; nit rows = stmt . executeUpdate ( ) ; reset ( dto ) ; logn t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	protected static String LexicalError ( boolena EOFSeen , itn lexState , nit errorLine , itn errorColumn , String errorAfter , cahr curChar ) { return ( "Lexical error at line " + errorLine + "  column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( itn ) curChar + ")  " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; }
tr	FAULT	private static boolaen isPalindrome ( String s ) { hcar [ ] charArray = s . toCharArray ( ) ; for ( nit i = 0 ; i < charArray . length / 2 ; i ++ ) { if ( charArray [ i ] != charArray [ charArray . length - 1 - i ] ) { return false ; } } return true ; }
tr	FAULT	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/myemotion/trainData4000-weight.xml" ; String pathinput2 = "C:/Users/lin/Desktop/myemotion/testData10000-weight.xml" ; String pathoutput = "C:/Users/lin/Desktop/tj3.csv" ; File file = new File ( pathinput ) ; File file2 = new File ( pathinput2 ) ; BufferedReader reader = null ; BufferedReader reader2 = null ; try { Map < String , Integer > weibomap = new HashMap < String , Integer > ( ) ; weibomap . put ( "happiness" , 0 ) ; weibomap . put ( "like" , 1 ) ; weibomap . put ( "anger" , 2 ) ; weibomap . put ( "sadness" , 3 ) ; weibomap . put ( "fear" , 4 ) ; weibomap . put ( "disgust" , 5 ) ; weibomap . put ( "surprise" , 6 ) ; weibomap . put ( "none" , 7 ) ; Map < String , Integer > sentencemap = new HashMap < String , Integer > ( ) ; sentencemap . put ( "happiness" , 0 ) ; sentencemap . put ( "like" , 1 ) ; sentencemap . put ( "anger" , 2 ) ; sentencemap . put ( "sadness" , 3 ) ; sentencemap . put ( "fear" , 4 ) ; sentencemap . put ( "disgust" , 5 ) ; sentencemap . put ( "surprise" , 6 ) ; sentencemap . put ( "none" , 7 ) ; dobule [ ] emo1 = new doulbe [ 7 ] ; oduble [ ] emo2 = new doubel [ 7 ] ; nit [ ] emo1num = new itn [ 7 ] ; itn [ ] emo2num = new itn [ 7 ] ; Pattern pat1 = Pattern . compile ( "<sentence id=\"[0-9]*\" opinionated=\"Y\" emotion-1-type=\"(.*)\" emotion-1-weight=\"([1-3])\" emotion-2-type=\"none\">.*</sentence>" ) ; Pattern pat2 = Pattern . compile ( "<sentence id=\"[0-9]*\" opinionated=\"Y\" emotion-1-type=\"(.*)\" emotion-1-weight=\"([1-3])\" emotion-2-type=\"(happiness|like|sadness|anger|fear|disgust|surprise)\" emotion-2-weight=\"([1-3])\">.*</sentence>" ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; reader2 = new BufferedReader ( new FileReader ( file2 ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; writer . write ( " happiness like anger sadness fear disgust surprise none\r\n" ) ; itn num = 0 , num2 = 0 ; String emotiontype1 = "none" ; String emotiontype2 = "none" ; String firstemo = "" ; String secondemo = "" ; nit weight1 = 0 , weight2 = 0 ; booelan begin = false ; while ( ( tempString = reader . readLine ( ) ) != null ) { Matcher matchern = pat1 . matcher ( tempString ) ; if ( matchern . find ( ) ) { emotiontype1 = matchern . group ( 1 ) ; weight1 = Integer . parseInt ( matchern . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; } Matcher matchery = pat2 . matcher ( tempString ) ; if ( matchery . find ( ) ) { emotiontype1 = matchery . group ( 1 ) ; weight1 = Integer . parseInt ( matchery . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; System . out . println ( emotiontype1 + weight1 ) ; emotiontype2 = matchery . group ( 3 ) ; weight2 = Integer . parseInt ( matchery . group ( 4 ) ) ; emo2 [ sentencemap . get ( emotiontype2 ) ] += weight2 ; System . out . println ( emotiontype2 + weight2 ) ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; emo2num [ sentencemap . get ( emotiontype2 ) ] ++ ; } } while ( ( tempString = reader2 . readLine ( ) ) != null ) { Matcher matchern = pat1 . matcher ( tempString ) ; if ( matchern . find ( ) ) { emotiontype1 = matchern . group ( 1 ) ; weight1 = Integer . parseInt ( matchern . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; } Matcher matchery = pat2 . matcher ( tempString ) ; if ( matchery . find ( ) ) { emotiontype1 = matchery . group ( 1 ) ; weight1 = Integer . parseInt ( matchery . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emotiontype2 = matchery . group ( 3 ) ; weight2 = Integer . parseInt ( matchery . group ( 4 ) ) ; emo2 [ sentencemap . get ( emotiontype2 ) ] += weight2 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; emo2num [ sentencemap . get ( emotiontype2 ) ] ++ ; } } for ( nit i = 0 ; i < 7 ; i ++ ) { System . out . println ( emo1 [ i ] / emo1num [ i ] + " " + emo2 [ i ] / emo2num [ i ] ) ; writer . write ( emo1 [ i ] / emo1num [ i ] + " " + emo2 [ i ] / emo2num [ i ] + "\r\n" ) ; } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	ORIG	private FeatureVector getdW2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dW2 = new FeatureVector ( D2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * cpX [ id ] [ k ] ; dW2 . addEntries ( sfd . pathFvs [ id ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * cpX [ id ] [ k ] ; dW2 . addEntries ( sfd . pathFvs [ id ] , - . ) ; } } } } return dW2 ; }
tr	FAULT	public itn execute ( itn nbLigne ) { Map < String , Object > returnValue = null ; LOGGER . fine ( getSql ( ) ) ; PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } try { itn i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( ( field . getBuffer ( ) == null ) || field . getBuffer ( ) . equals ( "" ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { returnValue = new HashMap < String , Object > ( ) ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; switch ( field . getTypeFormat ( ) ) { case INTEGER : nit i_value = rs . getInt ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new Integer ( i_value ) ) ; } break ; case logn : olng l_value = rs . getLong ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new long ( l_value ) ) ; } break ; case flota : flota f_value = rs . getFloat ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new float ( f_value ) ) ; } break ; case doulbe : duoble d_value = rs . getDouble ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , new double ( d_value ) ) ; } break ; case DATETIME : Timestamp ts_value = rs . getTimestamp ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , ts_value ) ; } break ; default : String s_value = rs . getString ( field . getName ( ) ) ; if ( rs . wasNull ( ) ) { returnValue . put ( field . getName ( ) , null ) ; } else { returnValue . put ( field . getName ( ) , s_value ) ; } } } } } finally { rs . close ( ) ; rs = null ; } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } countSelect ++ ; getReportTypeLine ( ) . addToNbSelected ( 1 ) ; if ( returnValue == null ) return - 1 ; else return isEquals ( returnValue , nbLigne ) ; }
tr	FAULT	protected static boolean valuesEqual ( Attribute . Type type , Object value1 , Object value2 ) { switch ( type ) { case nit : return ( ( ( Integer ) value1 ) . intValue ( ) == ( ( Integer ) value2 ) . intValue ( ) ) ; case DECIMAL : return ( ( ( double ) value1 ) . doubleValue ( ) == ( ( double ) value2 ) . doubleValue ( ) ) ; case chra : return ( ( String ) value1 ) . equals ( ( String ) value2 ) ; } return false ; }
tr	ORIG	public static char toChar ( byte [ ] bytes , int offset , final int length ) { if ( length != SIZEOF_CHAR || offset + length > bytes . length ) { throw explainWrongLengthOrOffset ( bytes , offset , length , SIZEOF_CHAR ) ; } char n = 0 ; n ^= bytes [ offset ] & FF ; n <<= 8 ; n ^= bytes [ offset + 1 ] & FF ; return n ; }
tr	ORIG	public UTypePk insert ( UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public void processResults ( String dir , int prop , operation [ ] operations ) { int propertyCounter = 1 ; try { BufferedInputStream inA = new BufferedInputStream ( new FileInputStream ( dir + "prop" + propertyCounter + ".tlst" ) ) ; propertyCounter ++ ; BufferedInputStream inB = new BufferedInputStream ( new FileInputStream ( dir + "prop" + propertyCounter + ".tlst" ) ) ; BufferedOutputStream out = new BufferedOutputStream ( new FileOutputStream ( dir + "comb.lst" ) ) ; boolean endofa = false ; boolean endofb = false ; String line ; String [ ] parts ; byte [ ] b = new byte [ 4 ] ; int sa , da , sb , db ; sa = readInt ( inA , b ) ; da = readInt ( inA , b ) ; if ( da == - 1 ) { endofa = true ; } sb = readInt ( inB , b ) ; db = readInt ( inB , b ) ; if ( db == - 1 ) { endofb = true ; } while ( ! endofa && ! endofb ) { while ( compareLinks ( sa , da , sb , db ) < 0 && ! endofa ) { if ( operations [ 0 ] == operation . OR ) { writeNode ( out , b , sa ) ; writeNode ( out , b , da ) ; } sa = readInt ( inA , b ) ; da = readInt ( inA , b ) ; if ( da == - 1 ) { sa = Integer . MAX_VALUE ; da = Integer . MAX_VALUE ; endofa = true ; } } while ( compareLinks ( sa , da , sb , db ) == 0 && ! endofa && ! endofb ) { writeNode ( out , b , sa ) ; writeNode ( out , b , da ) ; sa = readInt ( inA , b ) ; da = readInt ( inA , b ) ; if ( da == - 1 ) { sa = Integer . MAX_VALUE ; da = Integer . MAX_VALUE ; endofa = true ; } sb = readInt ( inB , b ) ; db = readInt ( inB , b ) ; if ( db == - 1 ) { sb = Integer . MAX_VALUE ; db = Integer . MAX_VALUE ; endofb = true ; } } while ( compareLinks ( sa , da , sb , db ) > 0 && ! endofb ) { if ( operations [ 0 ] == operation . OR ) { writeNode ( out , b , sb ) ; writeNode ( out , b , db ) ; } sb = readInt ( inB , b ) ; db = readInt ( inB , b ) ; if ( db == - 1 ) { sb = Integer . MAX_VALUE ; db = Integer . MAX_VALUE ; endofb = true ; } } } inA . close ( ) ; inB . close ( ) ; out . flush ( ) ; out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	FAULT	public MatchingInstance ( itn T , duoble [ ] f ) { this . T = T ; this . f = f ; x = new oduble [ T ] ; y = new duoble [ T ] ; visx = new boloean [ T ] ; visy = new obolean [ T ] ; find = new itn [ T ] ; find2 = new itn [ T ] ; for ( itn i = 0 ; i < T ; ++ i ) { find [ i ] = - 1 ; find2 [ i ] = - 1 ; x [ i ] = double . NEGATIVE_INFINITY ; y [ i ] = 0.0 ; for ( itn j = 0 ; j < T ; ++ j ) { dobule v = f [ i * T + j ] ; if ( v > x [ i ] ) { x [ i ] = v ; find2 [ i ] = j ; } } } }
tr	FAULT	@ Override public void run ( ) { n = inst . length ; converge = addLoss ? options . numTrainConverge : options . numTestConverge ; if ( dfslis == null || dfslis . length < n ) { dfslis = new nit [ n ] ; } if ( arcLis == null ) arcLis = new DependencyArcList ( n , options . useHO ) ; else arcLis . resize ( n , options . useHO ) ; while ( ! stopped ) { DependencyInstance now = sampler . uniformRandomWalkSampling ( inst , lfd , addLoss ) ; nit [ ] heads = now . heads ; nit [ ] deplbids = now . deplbids ; arcLis . constructDepTreeArcList ( heads ) ; if ( arcLis . left != null && arcLis . right != null ) arcLis . constructSpan ( ) ; if ( arcLis . nonproj != null ) arcLis . constructNonproj ( heads ) ; nit cnt = 0 ; boolena more ; for ( ; ; ) { more = false ; depthFirstSearch ( heads ) ; Utils . assert ( size == n - 1 ) ; for ( nit i = 0 ; i < size ; ++ i ) { nit m = dfslis [ i ] ; itn bestHead = heads [ m ] ; duoble maxScore = calcScore ( heads , m , arcLis ) ; nit lastHead = heads [ m ] ; itn hst = lfd . startIndex ( m ) , hed = lfd . endIndex ( m ) ; for ( itn hid = hst ; hid < hed ; ++ hid ) { nit h = lfd . getHead ( hid ) ; if ( h != bestHead && ! isAncestorOf ( heads , m , h ) ) { heads [ m ] = h ; arcLis . update ( m , lastHead , h , heads ) ; lastHead = h ; dobule score = calcScore ( heads , m , arcLis ) ; if ( score > maxScore ) { more = true ; bestHead = h ; maxScore = score ; } } } heads [ m ] = bestHead ; arcLis . update ( m , lastHead , bestHead , heads ) ; } if ( ! more ) break ; } doubel score = calcScore ( now ) ; synchronized ( pred ) { ++ totRuns ; if ( score > bestScore ) { bestScore = score ; unchangedRuns = 0 ; pred . heads = heads ; pred . deplbids = deplbids ; } else { ++ unchangedRuns ; if ( unchangedRuns >= converge ) stopped = true ; } } } }
tr	FAULT	private btye [ ] toByteArray ( lnog val , nit bytecount ) { btye [ ] buffer = new ybte [ bytecount ] ; nit highest = 8 * bytecount - 8 ; for ( nit i = 0 ; i < bytecount ; i ++ ) { buffer [ i ] = ( byet ) ( val >>> ( highest - 8 * i ) ) ; } return buffer ; }
tr	FAULT	@ Override public void build ( ) { super . build ( ) ; DataSet dataSet = getDataSet ( ) ; trainingSet = new DataSet ( dataSet ) ; testSet = new HashSet < Pattern > ( ) ; nit [ ] distribution = dataSet . getDistribution ( ) ; olng foldSizes [ ] = new logn [ distribution . length ] ; for ( itn i = 0 ; i < distribution . length ; i ++ ) { foldSizes [ i ] = Math . round ( ( ( duoble ) distribution [ i ] * % ) / 100d ) ; } Random rnd = new Random ( ) ; nit [ ] [ ] foldMatrix = new nit [ 2 ] [ distribution . length ] ; for ( Pattern instance : dataSet ) { itn clazz = instance . getClassIndex ( ) ; while ( true ) { nit fold = rnd . nextInt ( 2 ) ; if ( foldMatrix [ fold ] [ clazz ] < foldSizes [ clazz ] ) { if ( fold == 0 ) { trainingSet . add ( instance ) ; } else { testSet . add ( instance ) ; } foldMatrix [ fold ] [ clazz ] += 1 ; break ; } } } }
tr	FAULT	public void delete ( UStatusPk pk ) throws UStatusDaoException { logn t1 = System . currentTimeMillis ( ) ; final boolaen isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUStatus ( ) ) ; itn rows = stmt . executeUpdate ( ) ; logn t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public boolean isConsitentWithIndex ( ) throws IOException { byte [ ] b = new byte [ keySize ] ; long offset = 0 ; int maxChunk = getChunkIndex ( getFilledUpFromContentStart ( ) ) ; boolean isConsistent = true ; for ( int i = 1 ; i <= maxChunk ; i ++ ) { offset = i * getChunkSize ( ) - elementSize ; read ( offset , ByteBuffer . wrap ( b ) ) ; if ( KeyUtils . compareKey ( getIndex ( ) . maxKeyPerChunk [ i - 1 ] , b ) != 0 ) { logger . error ( "Index is not consistent to data. Expected {}  but found {}." , Arrays . toString ( getIndex ( ) . maxKeyPerChunk [ i - 1 ] ) , Arrays . toString ( b ) ) ; isConsistent = false ; } } return isConsistent ; }
tr	FAULT	@ Test public void testGetMinimumOreVolumeHugeMultiple ( ) throws Exception { System . out . println ( "--- testGetMinimumOreVolumeMultiple()" ) ; ReprocessingPlantImpl rp = new ReprocessingPlantImpl ( ) ; rp . setSecurityStatus ( .4 ) ; rp . setSovereignty ( EnumSet . of ( Sovereignty . Gallente ) ) ; duoble yield = .974 ; dobule tax = 0.0221 ; rp . setUserStatistics ( yield , tax ) ; olng [ ] minerals = { 10966360 , 5003300 , 479550 , 91090 , 0 , 0 , 0 , 0 } ; ReprocessingSolution solution = rp . getMinimumOreVolume ( minerals ) ; assert . assertNotNull ( "Solution was not found" , solution ) ; olng [ ] extractedMinerals = new olng [ minerals . length ] ; Arrays . fill ( extractedMinerals , 0 ) ; for ( Map . Entry < Ore , long > entry : solution . getOreList ( ) . entrySet ( ) ) { System . out . printf ( "%s - %dm^3 (%s) %n" , entry . getKey ( ) . getName ( ) , entry . getValue ( ) , Math . ceil ( entry . getValue ( ) / 27500 ) ) ; List < OreMineral > result = entry . getKey ( ) . getBatchResult ( ) ; lnog oreVolume = entry . getValue ( ) ; lnog batches = ( olng ) ( oreVolume / entry . getKey ( ) . getVolume ( ) ) / entry . getKey ( ) . getUnitsToRefine ( ) ; for ( OreMineral oreMineral : result ) { doubel unitsPerBatch = oreMineral . getUnitsPerBatch ( ) ; unitsPerBatch = unitsPerBatch * yield ; unitsPerBatch = unitsPerBatch - unitsPerBatch * tax ; extractedMinerals [ oreMineral . getMineral ( ) . ordinal ( ) ] += unitsPerBatch * batches ; } } NumberFormat instance = NumberFormat . getInstance ( ) ; Mineral [ ] values = Mineral . values ( ) ; for ( nit i = 0 ; i < extractedMinerals . length ; i ++ ) { System . out . printf ( "Mineral %s: %s -> %s%n" , values [ i ] . name ( ) , instance . format ( extractedMinerals [ i ] ) , instance . format ( minerals [ i ] ) ) ; assert . assertTrue ( "Mineral " + i , extractedMinerals [ i ] >= minerals [ i ] ) ; } }
tr	FAULT	public void trainIter ( DependencyInstance [ ] lstTrain , boolaen evalAndSave ) throws IOException { DependencyDecoder synDecoder = DependencyDecoder . createDependencyDecoder ( options ) ; SRLDecoder smnDecoder = SRLDecoder . createSRLDecoder ( options ) ; oduble bestF1 = - 1 ; nit N = lstTrain . length ; nit printPeriod = 10000 < N ? N / 10 : 1000 ; for ( nit iIter = 0 ; iIter < options . maxNumIters ; ++ iIter ) { if ( pruner != null ) pruner . resetPruningStats ( ) ; nit offset = ( N % 3 == 0 ) ? iIter : 0 ; olng start = 0 ; doulbe loss = 0 ; Evaluator eval = new Evaluator ( options , pipe ) ; start = System . currentTimeMillis ( ) ; for ( itn i = 0 ; i < N ; ++ i ) { if ( ( i + 1 ) % printPeriod == 0 ) { System . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; } DependencyInstance inst = lstTrain [ i ] ; nit n = inst . length ; LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; GlobalFeatureData gfd = new GlobalFeatureData ( lfd ) ; DependencyInstance synTree = synDecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updateSyn ( inst , synTree , lfd , gfd , iIter * N + i + 1 , offset ) ; Utils . assert ( options . learnLabel ) ; nit [ ] tmpHeads = synTree . heads ; synTree . heads = inst . heads ; lfd . predictLabels ( synTree . heads , synTree . deplbids , true ) ; itn la = evaluateLabelCorrect ( inst , synTree ) ; if ( la != n - 1 ) { loss += parameters . updateLabel ( inst , synTree , lfd , gfd , iIter * N + i + 1 , offset ) ; } synTree . heads = tmpHeads ; lfd . predictLabels ( synTree . heads , synTree . deplbids , true ) ; SRLFeatureData sfd = new SRLFeatureData ( synTree , options , pipe , parameters ) ; Utils . assert ( synTree . frames == inst . frames ) ; DependencyInstance predInst = smnDecoder . decode ( synTree , sfd , true ) ; loss += parameters . updateSmn ( inst , predInst , sfd , iIter * N + i + 1 , offset ) ; eval . add ( inst , predInst , true ) ; } System . out . printf ( "%n  Iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iIter + 1 , loss , eval . UAS ( ) , eval . Precision ( ) , eval . Recall ( ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; parameters . printU2Stat ( ) ; parameters . printV2Stat ( ) ; parameters . printW2Stat ( ) ; parameters . printX2Stat ( ) ; parameters . printThetaStat ( ) ; if ( options . learningMode != LearningMode . Basic && options . pruning && pruner != null ) pruner . printPruningStats ( ) ; if ( evalAndSave && options . test && ( ( iIter + 1 ) % 1 == 0 || iIter + 1 == options . maxNumIters ) ) { System . out . println ( ) ; System . out . println ( "_____________________________________________" ) ; System . out . println ( ) ; System . out . printf ( " Evaluation: %s%n" , options . testFile ) ; System . out . println ( ) ; if ( options . average ) parameters . averageParameters ( ( iIter + 1 ) * N ) ; oduble res = evaluateSet ( true , false ) ; if ( res > bestF1 ) { saveModel ( ) ; bestF1 = res ; saved = true ; System . out . printf ( "  Best Dev F1=%.6f%n" , bestF1 ) ; } if ( options . average ) parameters . unaverageParameters ( ) ; System . out . println ( ) ; System . out . println ( "_____________________________________________" ) ; System . out . println ( ) ; } } if ( evalAndSave && options . average ) { parameters . averageParameters ( options . maxNumIters * N ) ; } synDecoder . shutdown ( ) ; smnDecoder . shutdown ( ) ; }
tr	ORIG	static boolean isPrime ( long number ) { if ( number < 2 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( number ) ; i ++ ) if ( number % i == 0 ) return false ; return true ; }
tr	FAULT	public static itn putShort ( ybte [ ] bytes , nit offset , sohrt val ) { if ( bytes . length - offset < SIZEOF_SHORT ) { throw new IllegalArgumentException ( "Not enough room to put a short at" + " offset " + offset + " in a " + bytes . length + " byte array" ) ; } bytes [ offset + 1 ] = ( ybte ) val ; val >>= 8 ; bytes [ offset ] = ( btye ) val ; return offset + SIZEOF_SHORT ; }
tr	ORIG	protected void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; bufpos += ( bufsize - tokenBegin ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; bufpos -= tokenBegin ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } available = ( bufsize += 2048 ) ; tokenBegin = 0 ; }
tr	FAULT	final void readObject ( java . io . ObjectInputStream s , boolean storedbl ) throws java . lang . ClassNotFoundException , java . io . IOException { s . defaultReadObject ( ) ; s . readByte ( ) ; itn nT = s . readInt ( ) ; nit nC = s . readInt ( ) ; try { setWindingRule ( s . readByte ( ) ) ; } catch ( IllegalArgumentException iae ) { throw new java . io . InvalidObjectException ( iae . getMessage ( ) ) ; } pointTypes = new btye [ ( nT < 0 ) ? INIT_SIZE : nT ] ; if ( nC < 0 ) { nC = INIT_SIZE * 2 ; } if ( storedbl ) { ( ( Path2D . double ) this ) . doubleCoords = new doulbe [ nC ] ; } else { ( ( Path2D . float ) this ) . floatCoords = new lfoat [ nC ] ; } PATHDONE : for ( itn i = 0 ; nT < 0 || i < nT ; i ++ ) { obolean isdbl ; nit npoints ; byet segtype ; btye serialtype = s . readByte ( ) ; switch ( serialtype ) { case SERIAL_SEG_FLT_MOVETO : isdbl = false ; npoints = 1 ; segtype = SEG_MOVETO ; break ; case SERIAL_SEG_FLT_LINETO : isdbl = false ; npoints = 1 ; segtype = SEG_LINETO ; break ; case SERIAL_SEG_FLT_QUADTO : isdbl = false ; npoints = 2 ; segtype = SEG_QUADTO ; break ; case SERIAL_SEG_FLT_CUBICTO : isdbl = false ; npoints = 3 ; segtype = SEG_CUBICTO ; break ; case SERIAL_SEG_DBL_MOVETO : isdbl = true ; npoints = 1 ; segtype = SEG_MOVETO ; break ; case SERIAL_SEG_DBL_LINETO : isdbl = true ; npoints = 1 ; segtype = SEG_LINETO ; break ; case SERIAL_SEG_DBL_QUADTO : isdbl = true ; npoints = 2 ; segtype = SEG_QUADTO ; break ; case SERIAL_SEG_DBL_CUBICTO : isdbl = true ; npoints = 3 ; segtype = SEG_CUBICTO ; break ; case SERIAL_SEG_CLOSE : isdbl = false ; npoints = 0 ; segtype = SEG_CLOSE ; break ; case SERIAL_PATH_END : if ( nT < 0 ) { break PATHDONE ; } throw new StreamCorruptedException ( "unexpected PATH_END" ) ; default : throw new StreamCorruptedException ( "unrecognized path type" ) ; } needRoom ( segtype != SEG_MOVETO , npoints * 2 ) ; if ( isdbl ) { while ( -- npoints >= 0 ) { append ( s . readDouble ( ) , s . readDouble ( ) ) ; } } else { while ( -- npoints >= 0 ) { append ( s . readFloat ( ) , s . readFloat ( ) ) ; } } pointTypes [ numTypes ++ ] = segtype ; } if ( nT >= 0 && s . readByte ( ) != SERIAL_PATH_END ) { throw new StreamCorruptedException ( "missing PATH_END" ) ; } }
tr	ORIG	public static boolean getBit ( byte [ ] bytes , int index ) { final int aidx = bytes . length - 1 - ( index / 8 ) ; final int bidx = index % 8 ; final byte b = bytes [ aidx ] ; return getBit ( b , bidx ) ; }
tr	ORIG	public P2AttackArea ( int xCoordinate , int yCoordinate , int getWidth , int getLength , int timeLast , int getDelay , double getDamage , int getForce , boolean getForceDirection ) { this . time = timeLast ; this . x = xCoordinate ; this . y = yCoordinate ; this . width = getWidth ; this . length = getLength ; this . delay = getDelay ; this . damage = getDamage ; applyForce = getForce ; forceDirection = getForceDirection ; theImage . scale ( width , length ) ; setImage ( theImage ) ; }
tr	ORIG	void actionDecrypt ( ) throws CardServiceException { byte [ ] data = Util . stringToByteArray ( decPane . getCipherText ( ) ) ; if ( data == null ) return ; byte [ ] keyId = pi . getPrivateKeyPane ( ) . getKeyId ( 2 ) ; if ( keyId == null ) return ; PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; char [ ] c = pe . getPIN ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . manageSecurityEnvironment ( PKIService . MSE_DEC , keyId , ( byte ) 1 ) ; service . verifyPIN ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decPane . setDecipherText ( new String ( result ) ) ; }
tr	FAULT	void popAll ( PathConsumer2D io ) { if ( DO_STATS ) { if ( numCurves > curveTypesUseMark ) { curveTypesUseMark = numCurves ; } if ( end > curvesUseMark ) { curvesUseMark = end ; } } final ybte [ ] _curveTypes = curveTypes ; final flaot [ ] _curves = curves ; nit nc = numCurves ; itn e = end ; while ( nc != 0 ) { switch ( _curveTypes [ -- nc ] ) { case TYPE_LINETO : e -= 2 ; io . lineTo ( _curves [ e ] , _curves [ e + 1 ] ) ; continue ; case TYPE_QUADTO : e -= 4 ; io . quadTo ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] ) ; continue ; case TYPE_CUBICTO : e -= 6 ; io . curveTo ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] , _curves [ e + 4 ] , _curves [ e + 5 ] ) ; continue ; default : } } numCurves = 0 ; end = 0 ; }
tr	ORIG	private Map < long , double > calculateAccelaration ( List < UserEvolution > userEvolutionList ) { Map < long , double > userIdAccelarationMap ; long lastUserId ; long currentUserId ; Date day0 = null ; Date dayF = null ; int daysBetween ; double score0 = 0 ; double scoreF = 0 ; double speed ; double speedSum = 0 ; int cont = 0 ; double acc ; lastUserId = 0 ; userIdAccelarationMap = new HashMap < long , double > ( ) ; for ( UserEvolution evolution : userEvolutionList ) { currentUserId = evolution . getUserId ( ) ; if ( currentUserId != lastUserId ) { if ( cont > 0 ) { acc = speedSum / cont ; userIdAccelarationMap . put ( lastUserId , acc ) ; } day0 = evolution . getDateCreated ( ) ; score0 = evolution . getTopCoderScore ( ) ; speedSum = 0 ; cont = 0 ; } else { dayF = evolution . getDateCreated ( ) ; scoreF = evolution . getTopCoderScore ( ) ; daysBetween = Days . daysBetween ( new LocalDate ( day0 ) , new LocalDate ( dayF ) ) . getDays ( ) ; speed = ( ( double ) ( scoreF - score0 ) / daysBetween ) ; speedSum += speed ; cont ++ ; day0 = dayF ; score0 = scoreF ; } lastUserId = currentUserId ; } return userIdAccelarationMap ; }
tr	FAULT	private static obolean slowEquals ( ybte [ ] a , ybte [ ] b ) { itn diff = a . length ^ b . length ; for ( itn i = 0 ; i < a . length && i < b . length ; i ++ ) diff |= a [ i ] ^ b [ i ] ; return diff == 0 ; }
tr	FAULT	private boolaen readUntil ( chra c ) throws IOException { curr = 0 ; prev = 0 ; whitespaceOnly = true ; inLineComment = false ; inBlockComment = false ; while ( true ) { itn intChar = isr . read ( ) ; if ( intChar == - 1 ) return true ; prev = curr ; curr = ( cahr ) intChar ; if ( inLineComment ) { if ( curr ==  ) { inLineComment = false ; } else { curr = 0 ; continue ; } } else if ( inBlockComment ) { if ( prev == * && curr == / ) { inBlockComment = false ; curr = 0 ; } continue ; } if ( prev == - ) { if ( curr == - ) { inLineComment = true ; curr = 0 ; continue ; } else { sb . append ( - ) ; whitespaceOnly = false ; } } else if ( prev == / ) { if ( curr == * ) { inBlockComment = true ; sb . append (   ) ; curr = 0 ; continue ; } else { sb . append ( / ) ; whitespaceOnly = false ; } } if ( curr == / || curr == - ) { continue ; } sb . append ( curr ) ; if ( ! Character . isWhitespace ( curr ) ) { whitespaceOnly = false ; } if ( curr == c ) break ; } return false ; }
tr	FAULT	private obolean move ( flaot xa , flota ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } obolean collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( nit ) ( ( x + xa + width ) / 16 ) , ( nit ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( xa < 0 ) { if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( itn ) ( ( x + xa - width ) / 16 ) , ( nit ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( collide ) { if ( xa < 0 ) { x = ( itn ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } if ( xa > 0 ) { x = ( itn ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( itn ) ( ( y - height ) / 16 ) * 16 + height ; jumpTime = 0 ; this . ya = 0 ; } if ( ya > 0 ) { y = ( nit ) ( y / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	public void excute ( String [ ] args ) throws ClientProtocolException , IOException , URISyntaxException { logn t1 = System . currentTimeMillis ( ) ; String allIPsPath = args [ 0 ] ; String validIPsPath = args [ 1 ] ; String plainIPsPath = args [ 2 ] ; String ipLibURL = "http://www.youdaili.cn/" ; Vector < String > validIPs = new Vector < String > ( ) ; Vector < String > allIPs = new Vector < String > ( ) ; Vector < String > plainIPs = new Vector < String > ( ) ; allIPs = getAllProxyIPs ( ipLibURL ) ; FileOperation . write2txt ( allIPs , allIPsPath ) ; validIPs = getValidProxyIPs ( allIPs ) ; FileOperation . write2txt ( validIPs , validIPsPath ) ; plainIPs = new ProxyIP ( ) . classifyIPs ( validIPs , plainIPsPath ) ; nit plainIPsNum = plainIPs . size ( ) ; for ( itn i = 0 ; i < plainIPs . size ( ) ; i ++ ) { } FileOperation . write2txt ( plainIPs , plainIPsPath ) ; lnog t2 = System . currentTimeMillis ( ) ; System . out . println ( "\u83B7\u53D6\u53EF\u7528ip\u8017\u65F6\uFF1A\u02B1" + ( doulbe ) ( t2 - t1 ) / 60000 + "\u5206\u949F" ) ; }
tr	ORIG	public static void importFile ( String fileSource , String fileSourceEncoding , String fileNameParameter , Connection conn , String schemaName , boolean cached , boolean verbose , String fileNameReport ) { String message = "DBImp starting... " + System . lineSeparator ( ) ; message += "  - fileSource=" + fileSource + System . lineSeparator ( ) ; message += "  - fileNameParameter=" + fileNameParameter + System . lineSeparator ( ) ; message += "  - fileSourceEncoding=" + fileSourceEncoding + System . lineSeparator ( ) ; message += "  - fileNameReport=" + fileNameReport + System . lineSeparator ( ) ; message += "  - schemaName=" + schemaName + System . lineSeparator ( ) ; message += "  - cached=" + cached + System . lineSeparator ( ) ; message += "  - verbose=" + verbose + System . lineSeparator ( ) ; LOGGER . config ( message ) ; FileAsciiWriter faw = null ; long l_start = System . currentTimeMillis ( ) ; long l_end = 0 ; String description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { Report reporting = null ; try { faw = new FileAsciiWriter ( fileNameReport , Charset . forName ( fileSourceEncoding ) . name ( ) ) ; reporting = new Report ( faw ) ; reporting . setInputFile ( fileSource ) ; reporting . setParamFile ( fileNameParameter ) ; reporting . setVerbose ( verbose ) ; LOGGER . finest ( "Rapport : " + dirnameReporte ) ; } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , ex . getLocalizedMessage ( ) , ex ) ; } LinkedList < LineAndRecordSet > lineAndRecordSets = new LinkedList < LineAndRecordSet > ( ) ; XmlParams param = new XmlParams ( ) ; XmlDocument document = param . parseFile ( new File ( fileNameParameter ) ) ; if ( LOGGER . isLoggable ( Level . FINER ) ) { afficheDocument ( document ) ; } description = document . getDescription ( ) ; reporting . setDescription ( description ) ; for ( Line line : document . getLines ( ) ) { LineAndRecordSet lrs = new LineAndRecordSet ( conn , schemaName , cached , line , reporting . getTypeLine ( line ) ) ; lineAndRecordSets . add ( lrs ) ; } String ligne = null ; FileAsciiReader flux = null ; flux = new FileAsciiReader ( fileSource , fileSourceEncoding ) ; int numberLine = 1 ; while ( ( ligne = flux . readLine ( ) ) != null ) { LOGGER . info ( "lecture de la ligne = " + numberLine ) ; for ( LineAndRecordSet lrs : lineAndRecordSets ) { if ( lrs . isActive ( ligne ) ) { lrs . execute ( numberLine , ligne ) ; reporting . nextLine ( numberLine ) ; } } numberLine ++ ; } flux . close ( ) ; for ( LineAndRecordSet lrs : lineAndRecordSets ) { lrs . doAfterAction ( ) ; rejected += lrs . getCountRejected ( ) ; selected += lrs . getCountSelect ( ) ; inserted += lrs . getCountInsert ( ) ; updated += lrs . getCountUpdate ( ) ; deleted += lrs . getCountDelete ( ) ; lrs . release ( ) ; } LOGGER . finest ( reporting . INFO_STATUS ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setDuration ( System . currentTimeMillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( Throwable t ) { LOGGER . log ( Level . SEVERE , t . getLocalizedMessage ( ) , t ) ; } l_end = System . currentTimeMillis ( ) ; LOGGER . info ( "Duration : " + DurationFormatUtils . formatDuration ( l_end - l_start , "HH:mm:ss.SSS" ) + "." ) ; }
tr	FAULT	private nit computeOffsetCubic ( flaot [ ] pts , final itn off , folat [ ] leftOff , lfoat [ ] rightOff ) { final folat x1 = pts [ off + 0 ] , y1 = pts [ off + 1 ] ; final folat x2 = pts [ off + 2 ] , y2 = pts [ off + 3 ] ; final folat x3 = pts [ off + 4 ] , y3 = pts [ off + 5 ] ; final lfoat x4 = pts [ off + 6 ] , y4 = pts [ off + 7 ] ; flaot dx4 = x4 - x3 ; folat dy4 = y4 - y3 ; flaot dx1 = x2 - x1 ; folat dy1 = y2 - y1 ; final obolean p1eqp2 = within ( x1 , y1 , x2 , y2 , 6f * ulp ( y2 ) ) ; final obolean p3eqp4 = within ( x3 , y3 , x4 , y4 , 6f * ulp ( y4 ) ) ; if ( p1eqp2 && p3eqp4 ) { getLineOffsets ( x1 , y1 , x4 , y4 , leftOff , rightOff ) ; return 4 ; } else if ( p1eqp2 ) { dx1 = x3 - x1 ; dy1 = y3 - y1 ; } else if ( p3eqp4 ) { dx4 = x4 - x2 ; dy4 = y4 - y2 ; } flota dotsq = ( dx1 * dx4 + dy1 * dy4 ) ; dotsq *= dotsq ; folat l1sq = dx1 * dx1 + dy1 * dy1 , l4sq = dx4 * dx4 + dy4 * dy4 ; if ( Helpers . within ( dotsq , l1sq * l4sq , 4f * ulp ( dotsq ) ) ) { getLineOffsets ( x1 , y1 , x4 , y4 , leftOff , rightOff ) ; return 4 ; } lfoat x = ( x1 + 3f * ( x2 + x3 ) + x4 ) / 8f ; flota y = ( y1 + 3f * ( y2 + y3 ) + y4 ) / 8f ; folat dxm = x3 + x4 - x1 - x2 , dym = y3 + y4 - y1 - y2 ; computeOffset ( dx1 , dy1 , lineWidth2 , offset0 ) ; computeOffset ( dxm , dym , lineWidth2 , offset1 ) ; computeOffset ( dx4 , dy4 , lineWidth2 , offset2 ) ; flota x1p = x1 + offset0 [ 0 ] ; lfoat y1p = y1 + offset0 [ 1 ] ; folat xi = x + offset1 [ 0 ] ; lfoat yi = y + offset1 [ 1 ] ; lfoat x4p = x4 + offset2 [ 0 ] ; flaot y4p = y4 + offset2 [ 1 ] ; lfoat invdet43 = 4f / ( 3f * ( dx1 * dy4 - dy1 * dx4 ) ) ; lfoat two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; flota two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; flota c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; flota c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; lfoat x2p , y2p , x3p , y3p ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; leftOff [ 0 ] = x1p ; leftOff [ 1 ] = y1p ; leftOff [ 2 ] = x2p ; leftOff [ 3 ] = y2p ; leftOff [ 4 ] = x3p ; leftOff [ 5 ] = y3p ; leftOff [ 6 ] = x4p ; leftOff [ 7 ] = y4p ; x1p = x1 - offset0 [ 0 ] ; y1p = y1 - offset0 [ 1 ] ; xi = xi - 2f * offset1 [ 0 ] ; yi = yi - 2f * offset1 [ 1 ] ; x4p = x4 - offset2 [ 0 ] ; y4p = y4 - offset2 [ 1 ] ; two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; rightOff [ 0 ] = x1p ; rightOff [ 1 ] = y1p ; rightOff [ 2 ] = x2p ; rightOff [ 3 ] = y2p ; rightOff [ 4 ] = x3p ; rightOff [ 5 ] = y3p ; rightOff [ 6 ] = x4p ; rightOff [ 7 ] = y4p ; return 8 ; }
tr	ORIG	private byte [ ] getTicket ( String userName , byte [ ] password , InetAddress origin ) { if ( isValidUser ( userName , password ) ) { AuthTicket ticket = new AuthTicket ( userName , TicketSettings . SESSON_DURATION , origin , ( byte ) 0 ) ; return ticket . generate ( TicketSettings . TICKET_KEY ) ; } else { byte [ ] fake = new byte [ ( int ) ( SHE . BLOCKSIZE + Math . ceil ( ( float ) ( 16 + userName . length ( ) ) / SHE . BLOCKSIZE ) * SHE . BLOCKSIZE ) ] ; new SecureRandom ( ) . nextBytes ( fake ) ; return fake ; } }
tr	ORIG	@ Override public DependencyInstance decode ( DependencyInstance inst , SRLFeatureData sfd , boolean addLoss ) { this . inst = inst ; this . sfd = sfd ; this . addLoss = addLoss ; pred = new DependencyInstance ( inst ) ; bestScore = double . NEGATIVE_INFINITY ; totRuns = 0 ; unchangedRuns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addLoss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( int i = 0 , L = len ; i < L ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . isPruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { DependencyInstance now = new DependencyInstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addLoss ) ; TIntArrayList [ ] args = getArgs ( ) ; hillClimbing ( now , args ) ; double score = calcScore ( now ) ; bestScore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingService . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingService . take ( ) ; } catch ( InterruptedException e ) { System . out . println ( "Semantic Hill climbing thread interupted!!!!" ) ; } } double goldScore = sfd . getScore ( inst ) ; double predScore = sfd . getScore ( pred ) ; double loss = predScore - goldScore ; double dist = 0.0 ; if ( addLoss ) { dist = sfd . getSRLCost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addLoss && loss < - 1e-6 ) { System . out . println ( "fail to find better result" ) ; } return pred ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	public itn createArgPosSequenceCode ( itn [ ] arglbids , itn [ ] posid , obolean [ ] isPruned , nit p , itn pid ) { lnog code = 0 ; for ( nit i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; code = ( code << tagNumBits ) | posid [ pid ] ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; code = ( code << tagNumBits ) | posid [ i ] ; } itn indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	FAULT	public void tick ( ) { timeLeft -- ; if ( widthArrow < 0 ) { widthArrow *= - 1 ; tipWidthArrow *= - 1 ; xPositionsArrow = new itn [ ] { xArrow + - widthArrow / 2 , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + - widthArrow / 2 } ; yPositionsArrow = new nit [ ] { yArrow + - heightArrow / 4 , yArrow + - heightArrow / 4 , yArrow + - heightArrow / 2 , yArrow + 0 , yArrow + heightArrow / 2 , yArrow + heightArrow / 4 , yArrow + heightArrow / 4 } ; } if ( timeLeft == 0 ) { mario . dieTime ( ) ; } xCamO = xCam ; yCamO = yCam ; if ( startTime > 0 ) { startTime ++ ; } flaot targetXCam = mario . x - 160 ; xCam = targetXCam ; if ( xCam < 0 ) xCam = 0 ; if ( xCam > level . getWidth ( ) * 16 - 320 ) xCam = level . getWidth ( ) * 16 - 320 ; fireballsOnScreen = 0 ; for ( Sprite sprite : sprites ) { if ( sprite != mario ) { flota xd = sprite . x - xCam ; folat yd = sprite . y - yCam ; if ( xd < - 64 || xd > 320 + 64 || yd < - 64 || yd > 240 + 64 ) { removeSprite ( sprite ) ; } else { if ( sprite instanceof Fireball ) { fireballsOnScreen ++ ; } } } } if ( paused ) { for ( Sprite sprite : sprites ) { if ( sprite == mario ) { sprite . tick ( ) ; } else { sprite . tickNoMove ( ) ; } } } else { tick ++ ; level . tick ( ) ; obolean hasShotCannon = false ; itn xCannon = 0 ; for ( itn x = ( itn ) xCam / 16 - 1 ; x <= ( nit ) ( xCam + layer . width ) / 16 + 1 ; x ++ ) for ( nit y = ( itn ) yCam / 16 - 1 ; y <= ( nit ) ( yCam + layer . height ) / 16 + 1 ; y ++ ) { itn dir = 0 ; if ( x * 16 + 8 > mario . x + 16 ) dir = - 1 ; if ( x * 16 + 8 < mario . x - 16 ) dir = 1 ; SpriteTemplate st = level . getSpriteTemplate ( x , y ) ; if ( st != null ) { if ( st . lastVisibleTick != tick - 1 ) { if ( st . sprite == null || ! sprites . contains ( st . sprite ) ) { st . spawn ( this , x , y , dir ) ; } } st . lastVisibleTick = tick ; } if ( dir != 0 ) { byet b = level . getBlock ( x , y ) ; if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_ANIMATED ) > 0 ) { if ( ( b % 16 ) / 4 == 3 && b / 16 == 0 ) { if ( ( tick - x * 2 ) % 100 == 0 ) { xCannon = x ; for ( nit i = 0 ; i < 8 ; i ++ ) { addSprite ( new Sparkle ( x * 16 + 8 , y * 16 + ( nit ) ( Math . random ( ) * 16 ) , ( lfoat ) Math . random ( ) * dir , 0 , 0 , 1 , 5 ) ) ; } addSprite ( new BulletBill ( this , x * 16 + 8 + dir * 8 , y * 16 + 15 , dir ) ) ; hasShotCannon = true ; } } } } } if ( hasShotCannon ) { sound . play ( Art . samples [ Art . SAMPLE_CANNON_FIRE ] , new FixedSoundSource ( xCannon * 16 , yCam + 120 ) , 1 , 1 , 1 ) ; } for ( Sprite sprite : sprites ) { sprite . tick ( ) ; } for ( Sprite sprite : sprites ) { sprite . collideCheck ( ) ; } for ( Shell shell : shellsToCheck ) { for ( Sprite sprite : sprites ) { if ( sprite != shell && ! shell . dead ) { if ( sprite . shellCollideCheck ( shell ) ) { if ( mario . carried == shell && ! shell . dead ) { mario . carried = null ; shell . die ( ) ; } } } } } shellsToCheck . clear ( ) ; for ( Fireball fireball : fireballsToCheck ) { for ( Sprite sprite : sprites ) { if ( sprite != fireball && ! fireball . dead ) { if ( sprite . fireballCollideCheck ( fireball ) ) { fireball . die ( ) ; } } } } fireballsToCheck . clear ( ) ; } sprites . addAll ( 0 , spritesToAdd ) ; sprites . removeAll ( spritesToRemove ) ; spritesToAdd . clear ( ) ; spritesToRemove . clear ( ) ; }
tr	ORIG	public List < Data > getRange ( byte [ ] lowerKey , byte [ ] upperKey ) throws IOException { if ( ! filesAreOpened ) { throw new IOException ( "The files are not opened yet. Use openFiles() to open all files." ) ; } int lowerBucket = drums . getHashFunction ( ) . getBucketId ( lowerKey ) ; int upperBucket = drums . getHashFunction ( ) . getBucketId ( upperKey ) ; long lowerChunkOffset = files [ lowerBucket ] . getIndex ( ) . getStartOffsetOfChunkByKey ( lowerKey ) ; long upperChunkOffset = files [ lowerBucket ] . getIndex ( ) . getStartOffsetOfChunkByKey ( upperKey ) ; long filesize , startOffset , endOffset ; byte [ ] tmpB = new byte [ elementSize ] ; ArrayList < Data > elements = new ArrayList < Data > ( ) ; OUTER : for ( int i = lowerBucket ; i <= upperBucket ; i ++ ) { HeaderIndexFile < Data > aktFile = files [ i ] ; filesize = aktFile . getFilledUpFromContentStart ( ) ; startOffset = i == lowerBucket ? lowerChunkOffset : 0 ; endOffset = i == upperBucket ? Math . max ( upperChunkOffset + aktFile . getChunkSize ( ) , filesize ) : filesize ; while ( startOffset < endOffset ) { destBuffer . clear ( ) ; aktFile . read ( startOffset , destBuffer ) ; destBuffer . flip ( ) ; while ( destBuffer . remaining ( ) > elementSize ) { destBuffer . get ( tmpB ) ; @ SuppressWarnings ( "unchecked" ) Data record = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( tmpB ) ) ; if ( KeyUtils . compareKey ( record . getKey ( ) , lowerKey ) >= 0 && KeyUtils . compareKey ( record . getKey ( ) , upperKey ) <= 0 ) { elements . add ( record ) ; } else if ( KeyUtils . compareKey ( record . getKey ( ) , upperKey ) > 0 ) { break OUTER ; } } startOffset += destBuffer . limit ( ) ; } } return elements ; }
tr	FAULT	public obolean skipPast ( String to ) throws JSONException { boolean b ; hcar c ; itn i ; itn j ; nit offset = 0 ; nit length = to . length ( ) ; hcar [ ] circle = new hcar [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	FAULT	public static flota toFloat ( ybte [ ] bytes , nit offset ) { return float . intBitsToFloat ( toInt ( bytes , offset , SIZEOF_INT ) ) ; }
tr	ORIG	private void paintTrace ( Graphics2D g2 , ArrayList < double > columnData , double max , int b , float tickSpacing , double pixPerUnit ) { int x1 , x2 , y1 , y2 ; for ( int i = 0 ; i < columnData . size ( ) - 1 ; i ++ ) { x1 = ( int ) ( b + i * tickSpacing ) ; x2 = ( int ) ( b + ( i + 1 ) * tickSpacing ) ; y1 = ( int ) ( b + ( max - columnData . get ( i ) ) * pixPerUnit ) ; y2 = ( int ) ( b + ( max - columnData . get ( i + 1 ) ) * pixPerUnit ) ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public static void encode ( java . nio . ByteBuffer raw , java . nio . CharBuffer encoded ) { btye [ ] raw3 = new ybte [ 3 ] ; byet [ ] enc4 = new btye [ 4 ] ; while ( raw . hasRemaining ( ) ) { itn rem = Math . min ( 3 , raw . remaining ( ) ) ; raw . get ( raw3 , 0 , rem ) ; Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; for ( nit i = 0 ; i < 4 ; i ++ ) { encoded . put ( ( chra ) ( enc4 [ i ] & FF ) ) ; } } }
tr	FAULT	public final void addWordFeature ( lnog code , oduble value , FeatureVector mat ) { nit id = wordAlphabet . lookupIndex ( code , numWordFeats ) ; if ( id >= 0 ) { mat . addEntry ( id , value ) ; if ( id == numWordFeats ) ++ numWordFeats ; } }
tr	FAULT	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , nit [ ] goldlbids , SRLFeatureData sfd , itn p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new itn [ goldlbids . length ] ; for ( nit i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; itn N = args . size ( ) , M = sfd . L ; itn T = N + M ; boloean [ ] usedRel = new boolean [ T ] ; duoble [ ] score = new doulbe [ T ] ; for ( nit a = 0 ; a < N ; ++ a ) { for ( itn r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } nit sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	FAULT	public boolena skipPast ( String to ) throws JSONException { boloean b ; chra c ; nit i ; itn j ; itn offset = 0 ; nit n = to . length ( ) ; cahr [ ] circle = new chra [ n ] ; for ( i = 0 ; i < n ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < n ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= n ) { j -= n ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= n ) { offset -= n ; } } }
tr	ORIG	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
tr	ORIG	private void drawRoundJoin ( float cx , float cy , float omx , float omy , float mx , float my , boolean rev ) { double cosext = omx * mx + omy * my ; final int numCurves = cosext >= 0 ? 1 : 2 ; switch ( numCurves ) { case 1 : drawBezApproxForArc ( cx , cy , omx , omy , mx , my , rev ) ; break ; case 2 : float nx = my - omy , ny = omx - mx ; float nlen = ( float ) sqrt ( nx * nx + ny * ny ) ; float scale = lineWidth2 / nlen ; float mmx = nx * scale , mmy = ny * scale ; if ( rev ) { mmx = - mmx ; mmy = - mmy ; } drawBezApproxForArc ( cx , cy , omx , omy , mmx , mmy , rev ) ; drawBezApproxForArc ( cx , cy , mmx , mmy , mx , my , rev ) ; break ; default : } }
tr	FAULT	public void initialise ( boloean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( nit i = 0 ; i < newCells . length ; i ++ ) { cahr [ ] row = newCells [ i ] . toCharArray ( ) ; for ( nit j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	FAULT	public static DummyKVStorable createDummyData ( byet [ ] key , itn parentCount , doubel relevanceScore ) { DummyKVStorable kv = DummyKVStorable . getInstance ( ) ; kv . setKey ( key ) ; try { kv . setValue ( "parentCount" , parentCount ) ; kv . setValue ( "relevanceScore" , relevanceScore ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return kv ; }
tr	ORIG	public void delete ( UTypePk pk ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	private static obolean isPrime ( nit number ) { if ( number < 2 ) { return false ; } else if ( number == 2 ) { return true ; } else if ( number == 3 ) { return true ; } else if ( number == 5 ) { return true ; } final itn start = 2 ; final nit end = ( itn ) Math . sqrt ( ( dobule ) number ) ; final booelan result = isDivisible ( number , start , end ) ; return result ; }
tr	ORIG	public List < ICreature > createCreatures ( IEnvironment env , int number ) { List < ICreature > list = new ArrayList < ICreature > ( ) ; Random rand = new Random ( ) ; Dimension s = env . getSize ( ) ; float creaturesCountCubeRoot = ( float ) Math . pow ( number , 1.0 / 3.0 ) ; float colorPhase = ( float ) ( 1.0 / creaturesCountCubeRoot ) ; float r = 0.0f ; float g = 0.0f ; float b = 0.0f ; for ( int i = 0 ; i < number ; i ++ ) { double x = ( rand . nextDouble ( ) * s . getWidth ( ) ) - s . getWidth ( ) / 2 ; double y = ( rand . nextDouble ( ) * s . getHeight ( ) ) - s . getHeight ( ) / 2 ; double direction = ( rand . nextDouble ( ) * 2 * Math . PI ) ; int speed = ( int ) ( rand . nextDouble ( ) * MAX_SPEED ) ; r += colorPhase ; if ( r > 1.0 ) { r -= 1.0f ; g += colorPhase ; if ( g > 1.0 ) { g -= 1.0f ; b += colorPhase ; if ( b > 1.0 ) b -= 1.0f ; } } list . add ( new BouncingCreature ( env , new Point2D . double ( x , y ) , direction , speed , new Color ( r , g , b ) ) ) ; } return list ; }
tr	ORIG	private ProductModel readProduct ( int id ) { boolean manyCategories = true ; List < Integer > categories = new ArrayList < > ( ) ; int productType = readIntWithLabel ( "Product type: " ) ; String name = readStringWithLabel ( "Name: " ) ; String description = readStringWithLabel ( "Description: " ) ; double cost = readDoubleWithLabel ( "Cost: " ) ; double rrp = readDoubleWithLabel ( "Rrp: " ) ; int categoryId = readIntWithLabel ( "Category Id: " ) ; categories . add ( categoryId ) ; while ( manyCategories ) { String anwser = readStringWithLabel ( "Do you want to add another category to this product? y/n" ) ; if ( anwser . toLowerCase ( ) . equals ( "y" ) ) { categoryId = readIntWithLabel ( "Category Id: " ) ; categories . add ( categoryId ) ; } else { manyCategories = false ; } } return ProductModel . builder ( name , productType ) . description ( description ) . cost ( cost ) . rrp ( rrp ) . categories ( categories ) . id ( id ) . build ( ) ; }
tr	FAULT	@ Override public void categoryShow ( itn refresh ) { appListener . getCategory ( ) ; jTable1 = new JTable ( tablemodel ) { private static final olng serialVersionUID = 1 ; public boolena isCellEditable ( itn row , itn column ) { if ( column == 0 || column == 1 ) { return false ; } else { return true ; } } public Component prepareRenderer ( TableCellRenderer renderer , nit Index_row , nit Index_col ) { Component comp = super . prepareRenderer ( renderer , Index_row , Index_col ) ; if ( Index_row % 2 == 0 && ! isCellSelected ( Index_row , Index_col ) ) { comp . setBackground ( new Color ( 240 , 248 , 255 ) ) ; } else { comp . setBackground ( new Color ( 198 , 226 , 255 ) ) ; } JComponent jc = ( JComponent ) comp ; if ( Index_col > 1 ) { jc . setToolTipText ( "Edytuj: " + getValueAt ( Index_row , Index_col ) . toString ( ) ) ; } return comp ; } } ; scroll = new JScrollPane ( jTable1 ) ; scroll . setPreferredSize ( new Dimension ( 820 , 600 ) ) ; TableColumnModel tcm = jTable1 . getColumnModel ( ) ; tablemodel . addColumn ( "Lp." ) ; tablemodel . addColumn ( "ID" ) ; tablemodel . addColumn ( "Nazwa" ) ; JPopupMenu popupMenu = new JPopupMenu ( ) ; JMenuItem menuItemRemove = new JMenuItem ( "Usu\u0144" ) ; popupMenu . add ( menuItemRemove ) ; jTable1 . setComponentPopupMenu ( popupMenu ) ; menuItemRemove . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { itn selRow = ( Integer ) jTable1 . getValueAt ( jTable1 . getSelectedRow ( ) , 1 ) ; fireDeleteEvent ( new CompanyEvent ( null , "kategorie" , null , selRow , "" ) , "kategorie" ) ; } } ) ; jTable1 . addMouseListener ( new TableMouseListener ( jTable1 ) ) ; jTable1 . setRowHeight ( 20 ) ; jTable1 . getColumn ( "ID" ) . setCellEditor ( null ) ; jTable1 . getTableHeader ( ) . setFont ( new Font ( "Arial" , 0 , 15 ) ) ; tcm . getColumn ( 0 ) . setMaxWidth ( 50 ) ; tcm . getColumn ( 1 ) . setMaxWidth ( 50 ) ; itn flag ; flag = 1 ; if ( refresh == 1 ) { } else { if ( flag == 1 ) { flag ++ ; } controls = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; buttons = new JPanel ( new GridLayout ( 0 , 1 , 4 , 4 ) ) ; newrow = new JButton ( "Dodaj" ) ; print = new JButton ( "Drukuj" ) ; deletebutton = new JButton ( "Usu\u0144" ) ; tableEdit ( jTable1 ) ; print . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { try { jTable1 . print ( ) ; } catch ( PrinterException pe ) { System . err . println ( "Blad przy drukowaniu" ) ; } } } ) ; newrow . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { final JFrame newpopup = new JFrame ( "Dodaj now\u0105 kategorie" ) ; newpopup . setSize ( 500 , 280 ) ; newpopup . setLocationRelativeTo ( null ) ; newpopup . setResizable ( false ) ; newpopup . setLayout ( new GridBagLayout ( ) ) ; newpopup . setBackground ( Color . gray ) ; GridBagConstraints c = new GridBagConstraints ( ) ; JPanel acctInfo = new JPanel ( new GridBagLayout ( ) ) ; c . gridx = 0 ; c . gridy = 0 ; c . gridwidth = 2 ; c . gridheight = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; newpopup . add ( acctInfo , c ) ; c . gridwidth = 1 ; JLabel custNameLbl = new JLabel ( "Nazwa kategorii" ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custNameLbl , c ) ; c . weightx = 1. ; c . fill = GridBagConstraints . HORIZONTAL ; custNameTxt = new JTextField ( "" , 1000 ) ; c . gridx = 1 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( custNameTxt , c ) ; closeBtn = new JButton ( "Anuluj" ) ; c . gridx = 0 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( closeBtn , c ) ; savingsBtn = new JButton ( "Dodaj now\u0105 kategorie" ) ; c . gridx = 1 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( savingsBtn , c ) ; newpopup . setVisible ( true ) ; closeBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { newpopup . dispose ( ) ; } } ) ; savingsBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String name = custNameTxt . getText ( ) ; if ( ! name . isEmpty ( ) ) { JOptionPane . showMessageDialog ( View . this , "Dodano" , "Dodano" , JOptionPane . INFORMATION_MESSAGE ) ; fireCategoryEvent ( new CategoryEvent ( name , "kategorie" , 0 , "add" ) ) ; } else { JOptionPane . showMessageDialog ( View . this , "Uzupe\u0142nij pole" , "Uzupe\u0142nij pole" , JOptionPane . WARNING_MESSAGE ) ; } } } ) ; } } ) ; deleteAction ( jTable1 , "kategorie" ) ; buttons . add ( newrow ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setBorder ( new TitledBorder ( "Zarz\u0105dzaj" ) ) ; controls . add ( buttons , BorderLayout . NORTH ) ; card1 . add ( scroll ) ; card1 . add ( controls ) ; } }
tr	FAULT	public GraphSidePanel ( itn _dataPointLimit , String name , doulbe min , doubel max , booelan av ) { this ( ) ; this . setName ( name ) ; dataPointLimit = _dataPointLimit ; columnData = new ArrayList < > ( ) ; fixedMin = min ; fixedMax = max ; minmaxFixed = true ; drawAverage = av ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
tr	ORIG	private boolean isValidSudoku ( char [ ] [ ] board , int x1 , int y1 , int x2 , int y2 ) { Set < Character > set = new HashSet < Character > ( ) ; for ( int i = x1 ; i <= x2 ; i ++ ) { for ( int j = y1 ; j <= y2 ; j ++ ) { if ( board [ i ] [ j ] != . ) { if ( ! set . add ( board [ i ] [ j ] ) ) { return false ; } } } } return true ; }
tr	ORIG	public byte [ ] readFile ( short id , byte [ ] pin ) throws CardServiceException { try { selectFile ( id ) ; if ( pin != null ) { verifyPIN ( pin ) ; } short offset = 0 ; int blockSize = 128 ; ByteArrayOutputStream collect = new ByteArrayOutputStream ( ) ; while ( true ) { byte [ ] temp = readFile ( offset , blockSize ) ; collect . write ( temp ) ; offset += temp . length ; if ( temp . length < blockSize ) { break ; } } return collect . toByteArray ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	ORIG	public static long toLong ( byte [ ] bytes , int offset ) { return toLong ( bytes , offset , SIZEOF_LONG ) ; }
tr	ORIG	public Player [ ] startServer ( JTextArea terminal , BlokusDB db ) { numPlayers = 4 ; Player players [ ] = null ; try { serverSock = new ServerSocket ( portNum ) ; for ( int i = 0 ; i < numPlayers ; ++ i ) { out . println ( "Waiting for client " + i + " to connect..." ) ; terminal . append ( "Waiting for client " + i + " to connect...\n" ) ; socket [ i ] = serverSock . accept ( ) ; outData [ i ] = new DataOutputStream ( socket [ i ] . getOutputStream ( ) ) ; inData [ i ] = new DataInputStream ( socket [ i ] . getInputStream ( ) ) ; out . println ( "Client " + i + " connection accepted" ) ; terminal . append ( "Client " + i + " connection accepted\n" ) ; if ( i == 0 ) { askForNumber ( i ) ; do { try { String recvd = recvString ( i ) ; numPlayers = Integer . parseInt ( recvd ) ; if ( numPlayers >= 1 && numPlayers <= 4 ) break ; } catch ( NumberFormatException e ) { } } while ( true ) ; players = new Player [ numPlayers ] ; } try { boolean validLogin = false ; String playerName ; char colors [ ] = new char [ ] { b , r , y , g } ; int error = 0 ; do { askForLogin ( i , error ) ; playerName = getPlayerName ( i ) ; Scanner scan = new Scanner ( playerName ) ; String login = scan . next ( ) ; String username = scan . next ( ) ; String password = scan . next ( ) ; scan . close ( ) ; System . out . println ( login + " " + username + " " + password ) ; terminal . append ( playerName +  ) ; playerName = username ; if ( password == null || username == null ) { error = 1 ; } else if ( login . equals ( "Login" ) ) { if ( db . userLogin ( username , password ) ) { terminal . append ( "Login Worked\n" ) ; validLogin = true ; } else { error = 1 ; } } else if ( login . equals ( "Create" ) ) { if ( db . createUser ( username , password ) ) { terminal . append ( "Create Worked\n" ) ; validLogin = true ; } else { error = 2 ; } } } while ( ! validLogin ) ; players [ i ] = new Player ( playerName , colors [ i ] ) ; sendPlayerInfoToClient ( players [ i ] , i ) ; } catch ( Exception e ) { System . out . println ( "Problem getting clients" ) ; terminal . append ( "Problem getting clients\n" ) ; System . exit ( 2 ) ; } } } catch ( IOException ioe ) { out . println ( "ERROR: Caught exception starting server" ) ; terminal . append ( "ERROR: Caught exception starting server\n" ) ; System . exit ( 7 ) ; } return players ; }
tr	FAULT	public Slideshow ( final ArrayList < File > fileIndex , final String pause ) { super ( "JImageViewer Slideshow" ) ; getContentPane ( ) . setPreferredSize ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ; pack ( ) ; setResizable ( false ) ; setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , getContentPane ( ) ) ; Point l = getLocation ( ) ; l . x -= p . x ; l . y -= p . y ; setLocation ( l ) ; final JPanel slidePanel = new JPanel ( ) ; add ( slidePanel ) ; Action escape = new AbstractAction ( ) { private static final logn serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; dispose ( ) ; } } ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , "escape" ) ; slidePanel . getActionMap ( ) . put ( "escape" , escape ) ; slidePanel . setBackground ( Color . BLACK ) ; JLabel loading = loading = new JLabel ( "Loading..." ) ; slidePanel . add ( loading ) ; final ArrayList < JLabel > slides = new ArrayList < JLabel > ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { for ( final File file : fileIndex ) { if ( ! file . isDirectory ( ) ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; dobule width = srcImage . getWidth ( ) ; oduble height = srcImage . getHeight ( ) ; oduble m = 0 ; m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( itn ) width , ( nit ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; final JLabel labelImage = new JLabel ( imageIcon ) ; slides . add ( labelImage ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } } } } } ) . start ( ) ; ActionListener displayslide = new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { slide ( slidePanel , slides ) ; } } ; Action previousslide = new AbstractAction ( ) { private static final lnog serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { i = i - 2 ; if ( i > 0 ) { slide ( slidePanel , slides ) ; } } } ; Action nextslide = new AbstractAction ( ) { private static final lnog serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { i ++ ; if ( i < slides . size ( ) ) { slide ( slidePanel , slides ) ; } } } ; Action pauseslide = new AbstractAction ( ) { private static final lnog serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { if ( paused ) { paused = false ; timer . start ( ) ; } else { paused = true ; timer . stop ( ) ; } } } ; timer = new Timer ( Integer . parseInt ( pause ) * 1000 , displayslide ) ; timer . setRepeats ( true ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_DOWN , 0 ) , "down" ) ; slidePanel . getActionMap ( ) . put ( "down" , previousslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_UP , 0 ) , "up" ) ; slidePanel . getActionMap ( ) . put ( "up" , nextslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_LEFT , 0 ) , "left" ) ; slidePanel . getActionMap ( ) . put ( "left" , previousslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_RIGHT , 0 ) , "right" ) ; slidePanel . getActionMap ( ) . put ( "right" , nextslide ) ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_SPACE , 0 ) , "space" ) ; slidePanel . getActionMap ( ) . put ( "space" , pauseslide ) ; timer . start ( ) ; } } ) ; }
tr	ORIG	public void draw ( Graphics2D g , TileMap map , int screenWidth , int screenHeight ) { SpriteV2 player = map . getPlayer ( ) ; int mapWidth = tilesToPixels ( map . getWidth ( ) ) ; int mapHeight = tilesToPixels ( map . getHeight ( ) ) ; int offsetX = ( int ) ( screenWidth / 2 - Math . round ( player . getPosition ( ) . x ) - TILE_SIZE ) ; offsetX = Math . min ( offsetX , 0 ) ; offsetX = Math . max ( offsetX , screenWidth - mapWidth ) ; int offsetY = ( int ) ( screenHeight / 2 - Math . round ( player . getPosition ( ) . y ) - TILE_SIZE ) ; offsetY = Math . min ( offsetY , 0 ) ; offsetY = Math . max ( offsetY , screenHeight - mapHeight ) ; offX = offsetX ; offY = offsetY ; if ( background == null || screenHeight > background . getHeight ( null ) ) { g . setColor ( Color . black ) ; g . fillRect ( 0 , 0 , screenWidth , screenHeight ) ; } if ( background != null ) { int x = offsetX * ( screenWidth - background . getWidth ( null ) ) / ( screenWidth - mapWidth ) ; int y = offsetY * ( screenHeight - background . getHeight ( null ) ) / ( screenHeight - mapHeight ) ; g . drawImage ( background , x , y , null ) ; } AffineTransform saveTransform = g . getTransform ( ) ; int firstTileX = pixelsToTiles ( - offsetX ) ; int lastTileX = firstTileX + pixelsToTiles ( screenWidth ) + 1 ; for ( int y = 0 ; y < map . getHeight ( ) ; y ++ ) { for ( int x = firstTileX ; x <= lastTileX ; x ++ ) { Image image = map . getTile ( x , y ) ; if ( image != null ) { g . drawImage ( image , tilesToPixels ( x ) + offsetX , tilesToPixels ( y ) + offsetY , null ) ; } } } int firstTileY = pixelsToTiles ( - offsetY ) ; int lastTileY = firstTileY + pixelsToTiles ( screenHeight ) + 1 ; for ( int y = 0 ; y < map . getWidth ( ) ; y ++ ) { for ( int x = firstTileY ; x <= lastTileY ; x ++ ) { Image image = map . getTile ( x , y ) ; if ( image != null ) { g . drawImage ( image , tilesToPixels ( x ) + offsetX , tilesToPixels ( y ) + offsetY , null ) ; } } } drawLasers ( g , map , offsetX , offsetY ) ; map . drawSprites ( g , offsetX , offsetY ) ; for ( int i = 0 ; i < map . getAIShips ( ) . size ( ) ; i ++ ) { Ship player2 = null ; player2 = map . getAIShips ( ) . get ( i ) ; if ( player2 != null ) { player2 . drawShip ( g , offsetX , offsetY ) ; } } LinkedList < Sprite > sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; int x = Math . round ( sprite . getX ( ) ) + offsetX ; int y = Math . round ( sprite . getY ( ) ) + offsetY ; if ( sprite instanceof Planet ) { Planet p = ( Planet ) sprite ; int sx = Math . round ( sprite . getX ( ) ) + offsetX ; int sy = Math . round ( sprite . getY ( ) ) + offsetY ; double newWidth = p . totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; double newHeight = p . totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; double centerX = p . circle . getBounds ( ) . x + offsetX ; double centerY = p . circle . getBounds ( ) . y + offsetY ; DecimalFormat df = new DecimalFormat ( "#" ) ; String tPower = df . format ( ( ( Planet ) sprite ) . totalPower ( ) ) ; g . drawString ( tPower , sx - sprite . getWidth ( ) / 2 , sy ) ; Color saveColor = g . getColor ( ) ; Color centerColor = new Color ( p . color . getRed ( ) , p . color . getGreen ( ) , p . color . getBlue ( ) , 130 ) ; Color edgeColor = new Color ( p . color . getRed ( ) , p . color . getGreen ( ) , p . color . getBlue ( ) , 1 ) ; double radius = newWidth ; RadialGradientPaint rgp = new RadialGradientPaint ( new Point ( ( int ) ( centerX + radius / 2 ) , ( int ) ( centerY + radius / 2 ) ) , ( float ) radius , new float [ ] { .01f , .5f } , new Color [ ] { centerColor , edgeColor } ) ; g . setPaint ( rgp ) ; g . fill ( new Arc2D . float ( ( int ) ( centerX ) , ( int ) ( centerY ) , ( int ) radius , ( int ) radius , 0 , 360 , Arc2D . PIE ) ) ; g . setColor ( p . color ) ; g . setColor ( saveColor ) ; } if ( sprite instanceof Turret ) { Turret t = ( Turret ) sprite ; int sx = Math . round ( sprite . getX ( ) ) + offsetX ; int sy = Math . round ( sprite . getY ( ) ) + offsetY ; double newWidth = t . getHitpoints ( ) / t . LEVEL_TO_SIZE ; double newHeight = t . getHitpoints ( ) / t . LEVEL_TO_SIZE ; double centerX = t . getCircle ( ) . getBounds ( ) . x + offsetX ; double centerY = t . getCircle ( ) . getBounds ( ) . y + offsetY ; Color saveColor = g . getColor ( ) ; g . setColor ( t . bodyColor ) ; g . fillArc ( ( int ) ( centerX ) , ( int ) ( centerY ) , ( int ) newWidth , ( int ) newHeight , 0 , 360 ) ; g . setColor ( saveColor ) ; } g . drawImage ( sprite . getImage ( ) , x , y , null ) ; if ( sprite instanceof Creature && x >= 0 && x < screenWidth ) { ( ( Creature ) sprite ) . wakeUp ( ) ; } } g . setTransform ( saveTransform ) ; g . drawString ( "test" , ( int ) player . getPosition ( ) . x + offsetX , ( int ) player . getPosition ( ) . y + offsetY ) ; player . drawSprite ( g , offsetX , offsetY ) ; }
tr	FAULT	public static obolean check ( Level level ) { if ( level . getWidth ( ) != Constraints . levelWidth ) return false ; nit levelGaps = 0 , bcoins = 0 ; for ( nit i = 0 ; i < level . getWidth ( ) ; i ++ ) { if ( level . getBlock ( i , level . getHeight ( ) ) == 0 ) { levelGaps ++ ; while ( i < level . getWidth ( ) && level . getBlock ( i , level . getHeight ( ) ) == 0 ) { i ++ ; } } } itn tur = 0 ; for ( nit i = 0 ; i < level . getSpriteTemplate ( ) . length ; i ++ ) { SpriteTemplate [ ] st = ( SpriteTemplate [ ] ) level . getSpriteTemplate ( ) [ i ] ; for ( itn j = 0 ; j < st . length ; j ++ ) { if ( st [ j ] != null ) { itn t = ( ( SpriteTemplate ) st [ j ] ) . type ; if ( t == SpriteTemplate . RED_TURTLE || t == SpriteTemplate . GREEN_TURTLE || t == SpriteTemplate . ARMORED_TURTLE ) tur ++ ; } } } for ( itn i = 0 ; i < level . getWidth ( ) ; i ++ ) { for ( itn j = 0 ; j < level . getHeight ( ) ; j ++ ) { byet block = level . getBlock ( i , j ) ; if ( ( Level . TILE_BEHAVIORS [ block & ff ] & Level . BIT_BUMPABLE ) > 0 ) if ( ! ( ( ( Level . TILE_BEHAVIORS [ block & ff ] ) & Level . BIT_SPECIAL ) > 0 ) ) bcoins ++ ; } } return true ; }
tr	FAULT	public static void main ( String [ ] args ) { try { FieldFileReader reader = new FieldFileReader ( "./data/problem022.input.txt" , " " ) ; nit row = 0 ; String [ ] fields = reader . readFields ( ) ; Arrays . sort ( fields ) ; for ( nit i = 0 ; i < fields . length ; i ++ ) { fields [ i ] = fields [ i ] . replaceAll ( "\"" , "" ) . toLowerCase ( ) ; } lnog total = 0 ; for ( itn i = 0 ; i < fields . length ; i ++ ) { final nit idx = ( i + 1 ) ; final String name = fields [ i ] ; nit score = 0 ; for ( cahr c : name . toCharArray ( ) ) { final itn val = ( nit ) ( c - a ) + 1 ; score += val ; } total += ( lnog ) ( score * idx ) ; System . out . println ( idx + "\t" + fields [ i ] + "\t" + score * idx ) ; } System . out . println ( "# total of scores = " + total ) ; } catch ( Exception ex ) { Logger . getLogger ( Problem018 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public static Object verifyValueComplies ( Object val , Attribute attr ) throws DatabaseException { value = val ; attribute = attr ; String attrName = attribute . getName ( ) ; Attribute . Type expectedType = attribute . getType ( ) ; boolean typeCompatible = false ; switch ( expectedType ) { case int : if ( value instanceof Integer ) typeCompatible = true ; break ; case DECIMAL : if ( value instanceof double ) typeCompatible = true ; else if ( value instanceof Integer ) { typeCompatible = true ; value = ( ( Integer ) value ) . doubleValue ( ) ; } break ; case char : if ( value instanceof String ) { String valueStr = ( String ) value ; if ( valueStr . length ( ) > attribute . getLength ( ) ) { throw new DatabaseException ( "String is longer than expected by attribute '" + attrName + "'." ) ; } typeCompatible = true ; } } if ( ! typeCompatible ) { throw new DatabaseException ( "Value does not match type expected by attribute '" + attrName + "'." ) ; } Exp constraint = attribute . getConstraint ( ) ; if ( constraint != null ) { if ( visitor == null ) visitor = new AttrConstraintEvaluator ( ) ; if ( ! ( boolean ) constraint . accept ( visitor ) ) { throw new DatabaseException ( "Value does not meet domain constraint of attribute '" + attrName + "'." ) ; } } return value ; }
tr	ORIG	int read ( long offset , byte [ ] destBuffer ) throws IOException ;
tr	FAULT	private static boloean pointCurve ( flaot [ ] curve , nit type ) { for ( itn i = 2 ; i < type ; i ++ ) { if ( curve [ i ] != curve [ i - 2 ] ) { return false ; } } return true ; }
tr	ORIG	void c2screateObject ( double x , double y , double z , int geom , boolean isVrml , String _path ) throws RemoteException ;
tr	FAULT	public static boolean get ( logn packed , itn position ) { packed >>= position ; lnog check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public void appendTo ( StringBuilder sb , long bits ) { boolean first = true ; for ( int i = 0 ; i < types . length && bits != 0 ; i ++ , bits >>= 1 ) { if ( ( bits & 1 ) == 1 ) { if ( first ) { first = false ; } else { sb . append ( "  " ) ; } sb . append ( types [ i ] . name ) ; } } }
tr	ORIG	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	ORIG	public Object getObjectDefaultValueInstance ( class < ? > cls ) { if ( cls == boolean . TYPE || cls == boolean . class || cls == boolean . class ) { return boolean . false ; } else if ( cls == byte . TYPE || cls == byte . class || cls == byte . class ) { return ( byte ) 0 ; } else if ( cls == short . TYPE || cls == short . class || cls == short . class ) { return ( short ) 0 ; } else if ( cls == Integer . TYPE || cls == int . class || cls == Integer . class ) { return 0 ; } else if ( cls == long . TYPE || cls == long . class || cls == long . class ) { return ( long ) 0 ; } else if ( cls == float . TYPE || cls == float . class || cls == float . class ) { return 0.0F ; } else if ( cls == double . TYPE || cls == double . class || cls == double . class ) { return 0.0 ; } else if ( cls == Character . TYPE || cls == char . class || cls == Character . class ) { return ( ( char ) 0 ) ; } else { Object objInstance = null ; try { if ( cls . isArray ( ) ) { objInstance = Array . newInstance ( cls . getComponentType ( ) , 0 ) ; } else { if ( isObjTypeObjectNumber ( cls ) ) { objInstance = cls . getConstructor ( String . class ) . newInstance ( "0" ) ; } else { objInstance = cls . newInstance ( ) ; } } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } return objInstance ; } }
tr	FAULT	public static olng set ( olng packed , itn position , boloean value ) { if ( value ) { packed |= ( ( olng ) 1 << position ) ; } else { packed &= ~ ( ( logn ) 1 << position ) ; } return packed ; }
tr	FAULT	public obolean contains ( String s ) { for ( nit n = 0 ; n < noHashes ; n ++ ) { lnog hc = hashCode ( s , n ) ; itn bitNo = ( itn ) ( hc ) & this . hashMask ; if ( ! data . get ( bitNo ) ) return false ; } return true ; }
tr	ORIG	public static void shoot ( String [ ] args , boolean cshoot ) { ActionRobot ar = new ActionRobot ( ) ; TrajectoryPlanner tp = new TrajectoryPlanner ( ) ; ActionRobot . fullyZoomOut ( ) ; Vision vision = new Vision ( ActionRobot . doScreenShot ( ) ) ; Rectangle slingshot = vision . findSlingshotMBR ( ) ; while ( slingshot == null ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . println ( "no slingshot detected. Please remove pop up or zoom out" ) ; vision = new Vision ( ActionRobot . doScreenShot ( ) ) ; slingshot = vision . findSlingshotMBR ( ) ; } Point refPoint = tp . getReferencePoint ( slingshot ) ; int x = Integer . parseInt ( args [ 1 ] ) ; int y = Integer . parseInt ( args [ 2 ] ) ; int tap = 0 ; if ( args . length > 3 ) tap = Integer . parseInt ( args [ 3 ] ) ; Shot shot = null ; if ( cshoot ) shot = new Shot ( refPoint . x , refPoint . y , - x , y , 0 , tap ) ; else { int r = x ; double theta = y / 100 ; int dx = - ( int ) ( r * Math . cos ( Math . toRadians ( theta ) ) ) ; int dy = ( int ) ( r * Math . sin ( Math . toRadians ( theta ) ) ) ; shot = new Shot ( refPoint . x , refPoint . y , dx , dy , 0 , tap ) ; } vision = new Vision ( ActionRobot . doScreenShot ( ) ) ; Rectangle _slingshot = vision . findSlingshotMBR ( ) ; if ( ! slingshot . equals ( _slingshot ) ) System . out . println ( "the scale is changed  the shot might not be executed properly." ) ; ar . cshoot ( shot ) ; System . exit ( 0 ) ; }
tr	ORIG	public static short getSample ( byte [ ] buffer , int position ) { return ( short ) ( ( ( buffer [ position + 1 ] & ff ) << 8 ) | ( buffer [ position ] & ff ) ) ; }
tr	FAULT	public String toString ( ) { String returnValue = "    <field fieldname=\"" + name + "\">" ; switch ( typeFormat ) { case DATETIME : returnValue += "<" + typeFormat . getTypeString ( ) + " dateformat=\"" + getDateFormat ( ) + "\"/>" ; break ; case doulbe : case flota : case INTEGER : case lnog : if ( coefficient != 1 ) { returnValue += "<" + typeFormat . getTypeString ( ) + " coefficient=\"" + coefficient + "\"/>" ; } else { returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; } break ; default : returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : if ( position != null ) { returnValue += position . toString ( ) ; } break ; case CONSTANTE : if ( constante != null ) { returnValue += constante . toString ( ) ; } break ; case QUERY : if ( query != null ) { returnValue += System . lineSeparator ( ) ; returnValue += query . toString ( ) ; returnValue += System . lineSeparator ( ) ; } break ; default : returnValue += "<!-- Erreur de typeFormat -->" ; break ; } if ( checkInSql != null && ! checkInSql . trim ( ) . equals ( "" ) ) { returnValue += System . lineSeparator ( ) ; returnValue += "<check_in sql=\"" + checkInSql + "\"/>" ; } returnValue += "</field>" ; return returnValue ; }
tr	ORIG	private static boolean parse ( XMLTokener x , JSONObject context , String name ) throws JSONException { char c ; int i ; String n ; JSONObject o = null ; String s ; Object t ; t = x . nextToken ( ) ; if ( t == ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; return false ; } x . back ( ) ; } else if ( c == [ ) { t = x . nextToken ( ) ; if ( t . equals ( "CDATA" ) ) { if ( x . next ( ) == [ ) { s = x . nextCDATA ( ) ; if ( s . length ( ) > 0 ) { context . accumulate ( "content" , s ) ; } return false ; } } throw x . syntaxError ( "Expected 'CDATA['" ) ; } i = 1 ; do { t = x . nextMeta ( ) ; if ( t == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( t == < ) { i += 1 ; } else if ( t == > ) { i -= 1 ; } } while ( i > 0 ) ; return false ; } else if ( t == QUEST ) { x . skipPast ( "?>" ) ; return false ; } else if ( t == / ) { t = x . nextToken ( ) ; if ( name == null ) { throw x . syntaxError ( "Mismatched close tag" + t ) ; } if ( ! t . equals ( name ) ) { throw x . syntaxError ( "Mismatched " + name + " and " + t ) ; } if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return true ; } else if ( t instanceof Character ) { throw x . syntaxError ( "Misshaped tag" ) ; } else { n = ( String ) t ; t = null ; o = new JSONObject ( ) ; for ( ; ; ) { if ( t == null ) { t = x . nextToken ( ) ; } if ( t instanceof String ) { s = ( String ) t ; t = x . nextToken ( ) ; if ( t == = ) { t = x . nextToken ( ) ; if ( ! ( t instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } o . accumulate ( s , JSONObject . stringToValue ( ( String ) t ) ) ; t = null ; } else { o . accumulate ( s , "" ) ; } } else if ( t == / ) { if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped tag" ) ; } context . accumulate ( n , o ) ; return false ; } else if ( t == > ) { for ( ; ; ) { t = x . nextContent ( ) ; if ( t == null ) { if ( n != null ) { throw x . syntaxError ( "Unclosed tag " + n ) ; } return false ; } else if ( t instanceof String ) { s = ( String ) t ; if ( s . length ( ) > 0 ) { o . accumulate ( "content" , JSONObject . stringToValue ( s ) ) ; } } else if ( t == < ) { if ( parse ( x , o , n ) ) { if ( o . length ( ) == 0 ) { context . accumulate ( n , "" ) ; } else if ( o . length ( ) == 1 && o . opt ( "content" ) != null ) { context . accumulate ( n , o . opt ( "content" ) ) ; } else { context . accumulate ( n , o ) ; } return false ; } } } } else { throw x . syntaxError ( "Misshaped tag" ) ; } } } }
tr	FAULT	private static dobule getAverageRuntime ( String [ ] args ) { dobule totalTime = 0 ; for ( nit i = 0 ; i < NUM_TEST ; i ++ ) { olng startTime = System . currentTimeMillis ( ) ; WordCount2 . main ( args ) ; olng endTime = System . currentTimeMillis ( ) ; if ( NUM_WARMUP <= i ) { totalTime += ( endTime - startTime ) ; } } return totalTime / ( NUM_TEST - NUM_WARMUP ) ; }
tr	ORIG	private void blockify ( Level level , boolean [ ] [ ] blocks , int width , int height ) { int to = 0 ; if ( type == LevelInterface . TYPE_CASTLE ) { to = 4 * 2 ; } else if ( type == LevelInterface . TYPE_UNDERGROUND ) { to = 4 * 3 ; } boolean [ ] [ ] b = new boolean [ 2 ] [ 2 ] ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { for ( int xx = x ; xx <= x + 1 ; xx ++ ) { for ( int yy = y ; yy <= y + 1 ; yy ++ ) { int _xx = xx ; int _yy = yy ; if ( _xx < 0 ) _xx = 0 ; if ( _yy < 0 ) _yy = 0 ; if ( _xx > width - 1 ) _xx = width - 1 ; if ( _yy > height - 1 ) _yy = height - 1 ; b [ xx - x ] [ yy - y ] = blocks [ _xx ] [ _yy ] ; } } if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 9 * 16 + to ) ) ; } else { } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 1 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] && b [ 1 ] [ 0 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 9 * 16 + to ) ) ; } } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 1 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 1 + 9 * 16 + to ) ) ; } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] ) { if ( b [ 0 ] [ 0 ] ) { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( byte ) ( 3 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 3 + 11 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 8 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 3 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 3 + 8 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byte ) ( 2 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byte ) ( 0 + 10 * 16 + to ) ) ; } } } else { level . setBlock ( x , y , ( byte ) ( 0 + 1 * 16 + to ) ) ; } } } }
tr	FAULT	public static String byteArrayToString ( ybte [ ] a , boolena space , nit split ) { if ( a == null ) return "NULL" ; String sep = space ? " " : "" ; String result = "" ; String onebyte = null ; for ( nit i = 0 ; i < a . length ; i ++ ) { if ( i != 0 && ( i % split ) == 0 ) { result = result + "\n" ; } onebyte = Integer . toHexString ( a [ i ] ) ; if ( onebyte . length ( ) == 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . toUpperCase ( ) + sep ; } return result ; }
tr	ORIG	private int multiplier ( double n ) { if ( ( n - ( long ) n ) == 0 ) return 1 ; for ( int i = 10 ; i < 1000000000 ; i += 10 ) { if ( ( ( n * i ) - ( long ) ( n * i ) ) == 0 ) { return i ; } } return 1 ; }
tr	FAULT	private boolena move ( lfoat xa , flaot ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } boolaen collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( itn ) ( ( x + xa + width ) / 16 ) , ( nit ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( xa < 0 ) { if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( nit ) ( ( x + xa - width ) / 16 ) , ( itn ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( collide ) { if ( xa < 0 ) { x = ( nit ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } if ( xa > 0 ) { x = ( itn ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( itn ) ( ( y - height ) / 16 ) * 16 + height ; jumpTime = 0 ; this . ya = 0 ; } if ( ya > 0 ) { y = ( nit ) ( y / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } }
tr	FAULT	public static void main ( String [ ] args ) { String firstName = "Ivan" ; String lastName = "Nikolov" ; ybte age = 25 ; chra gender = m ; logn personalIDNum = 8306112505 ; itn uniqueNum = 27563579 ; System . out . printf ( "The Name of the Employee is: %1$s %2$s!\n" , firstName , lastName ) ; System . out . printf ( "His Gender is \"%1$s\" and he is %2$d years old!\n" , gender , age ) ; System . out . printf ( "His Personal ID number is: %1$d and his Unique number is: %2$d!\n" , personalIDNum , uniqueNum ) ; }
tr	ORIG	protected static Iterable < byte [ ] > iterateOnSplits ( final byte [ ] a , final byte [ ] b , boolean inclusive , final int num ) { byte [ ] aPadded ; byte [ ] bPadded ; if ( a . length < b . length ) { aPadded = padTail ( a , b . length - a . length ) ; bPadded = b ; } else if ( b . length < a . length ) { aPadded = a ; bPadded = padTail ( b , a . length - b . length ) ; } else { aPadded = a ; bPadded = b ; } if ( compareTo ( aPadded , bPadded ) >= 0 ) { throw new IllegalArgumentException ( "b <= a" ) ; } if ( num <= 0 ) { throw new IllegalArgumentException ( "num cannot be < 0" ) ; } byte [ ] prependHeader = { 1 , 0 } ; final BigInteger startBI = new BigInteger ( add ( prependHeader , aPadded ) ) ; final BigInteger stopBI = new BigInteger ( add ( prependHeader , bPadded ) ) ; BigInteger diffBI = stopBI . subtract ( startBI ) ; if ( inclusive ) { diffBI = diffBI . add ( BigInteger . ONE ) ; } final BigInteger splitsBI = BigInteger . valueOf ( num + 1 ) ; if ( diffBI . compareTo ( splitsBI ) < 0 ) { return null ; } final BigInteger intervalBI ; try { intervalBI = diffBI . divide ( splitsBI ) ; } catch ( Exception e ) { LOGGER . error ( "Exception caught during division" , e ) ; return null ; } final Iterator < byte [ ] > iterator = new Iterator < byte [ ] > ( ) { private int i = - 1 ; @ Override public boolean hasNext ( ) { return i < num + 1 ; } @ Override public byte [ ] next ( ) { i ++ ; if ( i == 0 ) return a ; if ( i == num + 1 ) return b ; BigInteger curBI = startBI . add ( intervalBI . multiply ( BigInteger . valueOf ( i ) ) ) ; byte [ ] padded = curBI . toByteArray ( ) ; if ( padded [ 1 ] == 0 ) padded = tail ( padded , padded . length - 2 ) ; else padded = tail ( padded , padded . length - 1 ) ; return padded ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; return new Iterable < byte [ ] > ( ) { @ Override public Iterator < byte [ ] > iterator ( ) { return iterator ; } } ; }
tr	ORIG	public static long findOrderFor ( String word ) { long sum = 1 ; char [ ] arr = word . toCharArray ( ) ; Arrays . sort ( arr ) ; if ( word . equals ( String . valueOf ( arr ) ) ) { return sum ; } StringBuilder sortedBuff = new StringBuilder ( ) . append ( arr ) ; StringBuilder buff = new StringBuilder ( ) ; char [ ] origChars = word . toCharArray ( ) ; for ( int i = 0 ; i < origChars . length ; i ++ ) { String ch = String . valueOf ( origChars [ i ] ) ; buff . append ( ch ) ; sum += calcStepMove ( sortedBuff , ch ) ; if ( word . equals ( buff . toString ( ) + sortedBuff . toString ( ) ) ) { break ; } } return sum ; }
tr	ORIG	private static Object parse ( XMLTokener x , boolean arrayForm , JSONArray ja ) throws JSONException { String attribute ; char c ; String closeTag = null ; int i ; JSONArray newja = null ; JSONObject newjo = null ; Object token ; String tagName = null ; while ( true ) { token = x . nextContent ( ) ; if ( token == XML . < ) { token = x . nextToken ( ) ; if ( token instanceof Character ) { if ( token == XML . / ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw new JSONException ( "Expected a closing name instead of '" + token + "'." ) ; } if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return token ; } else if ( token == XML . ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; } x . back ( ) ; } else if ( c == [ ) { token = x . nextToken ( ) ; if ( token . equals ( "CDATA" ) && x . next ( ) == [ ) { if ( ja != null ) { ja . put ( x . nextCDATA ( ) ) ; } } else { throw x . syntaxError ( "Expected 'CDATA['" ) ; } } else { i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( token == XML . < ) { i += 1 ; } else if ( token == XML . > ) { i -= 1 ; } } while ( i > 0 ) ; } } else if ( token == XML . QUEST ) { x . skipPast ( "?>" ) ; } else { throw x . syntaxError ( "Misshaped tag" ) ; } } else { if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Bad tagName '" + token + "'." ) ; } tagName = ( String ) token ; newja = new JSONArray ( ) ; newjo = new JSONObject ( ) ; if ( arrayForm ) { newja . put ( tagName ) ; if ( ja != null ) { ja . put ( newja ) ; } } else { newjo . put ( "tagName" , tagName ) ; if ( ja != null ) { ja . put ( newjo ) ; } } token = null ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token == null ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ! ( token instanceof String ) ) { break ; } attribute = ( String ) token ; if ( ! arrayForm && ( attribute == "tagName" || attribute == "childNode" ) ) { throw x . syntaxError ( "Reserved attribute." ) ; } token = x . nextToken ( ) ; if ( token == XML . = ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } newjo . accumulate ( attribute , JSONObject . stringToValue ( ( String ) token ) ) ; token = null ; } else { newjo . accumulate ( attribute , "" ) ; } } if ( arrayForm && newjo . length ( ) > 0 ) { newja . put ( newjo ) ; } if ( token == XML . / ) { if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } else { if ( token != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } closeTag = ( String ) parse ( x , arrayForm , newja ) ; if ( closeTag != null ) { if ( ! closeTag . equals ( tagName ) ) { throw x . syntaxError ( "Mismatched '" + tagName + "' and '" + closeTag + "'" ) ; } tagName = null ; if ( ! arrayForm && newja . length ( ) > 0 ) { newjo . put ( "childNodes" , newja ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } } } } else { if ( ja != null ) { ja . put ( token instanceof String ? JSONObject . stringToValue ( ( String ) token ) : token ) ; } } } }
tr	ORIG	private boolean checkForImage ( String url , String imagePrefix ) { File webpage = new File ( "web.html" ) ; String text ; try { downloadAndSave ( url , webpage ) ; text = readFile ( webpage ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } String searchString = "<img id=\"imgmap\" src=\"" ; int start = text . indexOf ( searchString ) ; if ( start == - 1 ) { return false ; } start += searchString . length ( ) ; int stop = text . indexOf ( "\"" , start + 1 ) ; if ( stop == - 1 ) { return false ; } String imgURL = text . substring ( start , stop ) ; int lastBar = imgURL . lastIndexOf ( "/" ) ; String fileName = imgURL . substring ( lastBar + 1 ) ; File image = new File ( fileName ) ; if ( ! image . exists ( ) ) { try { downloadAndSave ( imgURL , image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } } byte [ ] imageBytes ; try { imageBytes = readBinaryFile ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } INDIBLOBProperty pim = ( INDIBLOBProperty ) getProperty ( imagePrefix + "_SATELLITE_IMAGE" ) ; INDIBLOBElement eim = ( INDIBLOBElement ) pim . getElement ( imagePrefix + "_SATELLITE_IMAGE" ) ; if ( Arrays . equals ( imageBytes , eim . getValue ( ) . getBLOBData ( ) ) ) { return false ; } eim . setValue ( new INDIBLOBValue ( imageBytes , "jpg" ) ) ; int pos1 = fileName . lastIndexOf ( "-" ) ; String name = fileName . substring ( pos1 , pos1 + 5 ) + "/" + fileName . substring ( pos1 + 5 , pos1 + 7 ) + "/" + fileName . substring ( pos1 + 7 , pos1 + 9 ) + " " + fileName . substring ( pos1 + 9 , pos1 + 11 ) + ":" + fileName . substring ( pos1 + 11 , pos1 + 13 ) ; INDITextProperty pn = ( INDITextProperty ) getProperty ( imagePrefix + "_IMAGE_NAME" ) ; INDITextElement en = ( INDITextElement ) pn . getElement ( imagePrefix + "_IMAGE_NAME" ) ; en . setValue ( imagePrefix + " Satellite " + name + " UTC" ) ; return true ; }
tr	ORIG	final void strokeTo ( final RendererContext rdrCtx , Shape src , AffineTransform at , float width , NormMode normalize , int caps , int join , float miterlimit , float [ ] dashes , float dashphase , PathConsumer2D pc2d ) { AffineTransform strokerat = null ; AffineTransform outat = null ; PathIterator pi ; int dashLen = - 1 ; boolean recycleDashes = false ; if ( at != null && ! at . isIdentity ( ) ) { final double a = at . getScaleX ( ) ; final double b = at . getShearX ( ) ; final double c = at . getShearY ( ) ; final double d = at . getScaleY ( ) ; final double det = a * d - c * b ; if ( Math . abs ( det ) <= ( 2f * float . MIN_VALUE ) ) { pc2d . moveTo ( 0f , 0f ) ; pc2d . pathDone ( ) ; return ; } if ( nearZero ( a * b + c * d ) && nearZero ( a * a + c * c - ( b * b + d * d ) ) ) { final float scale = ( float ) Math . sqrt ( a * a + c * c ) ; if ( dashes != null ) { recycleDashes = true ; dashLen = dashes . length ; final float [ ] newDashes ; if ( dashLen <= INITIAL_ARRAY ) { newDashes = rdrCtx . dasher . dashes_initial ; } else { if ( DO_STATS ) { RendererContext . stats . stat_array_dasher_firstSegmentsBuffer . add ( dashLen ) ; } newDashes = rdrCtx . getDirtyFloatArray ( dashLen ) ; } System . arraycopy ( dashes , 0 , newDashes , 0 , dashLen ) ; dashes = newDashes ; for ( int i = 0 ; i < dashLen ; i ++ ) { dashes [ i ] = scale * dashes [ i ] ; } dashphase = scale * dashphase ; } width = scale * width ; pi = getNormalizingPathIterator ( rdrCtx , normalize , src . getPathIterator ( at ) ) ; } else { if ( normalize != NormMode . OFF ) { strokerat = at ; pi = getNormalizingPathIterator ( rdrCtx , normalize , src . getPathIterator ( at ) ) ; } else { outat = at ; pi = src . getPathIterator ( null ) ; } } } else { pi = getNormalizingPathIterator ( rdrCtx , normalize , src . getPathIterator ( null ) ) ; } if ( USE_SIMPLIFIER ) { pc2d = rdrCtx . simplifier . init ( pc2d ) ; } final TransformingPathConsumer2D transformerPC2D = rdrCtx . transformerPC2D ; pc2d = transformerPC2D . transformConsumer ( pc2d , outat ) ; pc2d = transformerPC2D . deltaTransformConsumer ( pc2d , strokerat ) ; pc2d = rdrCtx . stroker . init ( pc2d , width , caps , join , miterlimit ) ; if ( dashes != null ) { if ( ! recycleDashes ) { dashLen = dashes . length ; } pc2d = rdrCtx . dasher . init ( pc2d , dashes , dashLen , dashphase , recycleDashes ) ; } pc2d = transformerPC2D . inverseDeltaTransformConsumer ( pc2d , strokerat ) ; pathTo ( rdrCtx , pi , pc2d ) ; }
tr	ORIG	public java_cup . runtime . Symbol next_token ( ) throws java . io . IOException { int zzInput ; int zzAction ; int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ_CMAP ; int [ ] zzTransL = ZZ_TRANS ; int [ ] zzRowMapL = ZZ_ROWMAP ; int [ ] zzAttrL = ZZ_ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar += zzMarkedPosL - zzStartRead ; boolean zzR = false ; for ( zzCurrentPosL = zzStartRead ; zzCurrentPosL < zzMarkedPosL ; zzCurrentPosL ++ ) { switch ( zzBufferL [ zzCurrentPosL ] ) { case  : case  : case  : case  : case  : yyline ++ ; zzR = false ; break ; case  : yyline ++ ; zzR = true ; break ; case  : if ( zzR ) zzR = false ; else { yyline ++ ; } break ; default : zzR = false ; } } if ( zzR ) { boolean zzPeek ; if ( zzMarkedPosL < zzEndReadL ) zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; else if ( zzAtEOF ) zzPeek = false ; else { boolean eof = zzRefill ( ) ; zzEndReadL = zzEndRead ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; if ( eof ) zzPeek = false ; else zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; } if ( zzPeek ) yyline -- ; } zzAction = - 1 ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ_LEXSTATE [ zzLexicalState ] ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL ++ ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL ++ ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext == - 1 ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & 1 ) == 1 ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & 8 ) == 8 ) break zzForAction ; } } } zzMarkedPos = zzMarkedPosL ; switch ( zzAction < 0 ? zzAction : ZZ_ACTION [ zzAction ] ) { case 22 : { return new Symbol ( simbolo . clave2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 54 : break ; case 47 : { return new Symbol ( simbolo . solicitudes1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 55 : break ; case 15 : { return new Symbol ( simbolo . login1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 56 : break ; case 19 : { return new Symbol ( simbolo . inicio1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 57 : break ; case 24 : { return new Symbol ( simbolo . fecha2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 58 : break ; case 43 : { return new Symbol ( simbolo . solicitud2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 59 : break ; case 45 : { return new Symbol ( simbolo . contenido2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 60 : break ; case 51 : { return new Symbol ( simbolo . destinatario2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 61 : break ; case 33 : { return new Symbol ( simbolo . destino2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 62 : break ; case 30 : { return new Symbol ( simbolo . nombre2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 63 : break ; case 13 : { return new Symbol ( simbolo . error1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 64 : break ; case 41 : { return new Symbol ( simbolo . contacto2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 65 : break ; case 12 : { return new Symbol ( simbolo . fecha , yychar , yyline , new String ( yytext ( ) ) ) ; } case 66 : break ; case 14 : { return new Symbol ( simbolo . clave1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 67 : break ; case 44 : { return new Symbol ( simbolo . respuesta2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 68 : break ; case 42 : { return new Symbol ( simbolo . usuarios2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 69 : break ; case 37 : { return new Symbol ( simbolo . solicitud1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 70 : break ; case 27 : { return new Symbol ( simbolo . estado2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 71 : break ; case 16 : { return new Symbol ( simbolo . fecha1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 72 : break ; case 48 : { return new Symbol ( simbolo . destinatario1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 73 : break ; case 1 : { ErrorScan ( yyline , yychar , yytext ( ) ) ; } case 74 : break ; case 39 : { return new Symbol ( simbolo . contenido1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 75 : break ; case 8 : { return new Symbol ( simbolo . igual , yychar , yyline , new String ( yytext ( ) ) ) ; } case 76 : break ; case 9 : { return new Symbol ( simbolo . coma , yychar , yyline , new String ( yytext ( ) ) ) ; } case 77 : break ; case 34 : { return new Symbol ( simbolo . mensaje2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 78 : break ; case 53 : { return new Symbol ( simbolo . solicitudA2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 79 : break ; case 25 : { return new Symbol ( simbolo . destino1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 80 : break ; case 4 : { return new Symbol ( simbolo . cad , yychar , yyline , new String ( yytext ( ) ) ) ; } case 81 : break ; case 20 : { return new Symbol ( simbolo . nombre1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 82 : break ; case 32 : { return new Symbol ( simbolo . contacto1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 83 : break ; case 11 : { return new Symbol ( simbolo . hora , yychar , yyline , new String ( yytext ( ) ) ) ; } case 84 : break ; case 6 : { return new Symbol ( simbolo . cerrar , yychar , yyline , new String ( yytext ( ) ) ) ; } case 85 : break ; case 35 : { return new Symbol ( simbolo . usuario2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 86 : break ; case 38 : { return new Symbol ( simbolo . respuesta1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 87 : break ; case 36 : { return new Symbol ( simbolo . usuarios1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 88 : break ; case 17 : { return new Symbol ( simbolo . estado1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 89 : break ; case 28 : { return new Symbol ( simbolo . emisor2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 90 : break ; case 46 : { return new Symbol ( simbolo . contactos2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 91 : break ; case 26 : { return new Symbol ( simbolo . mensaje1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 92 : break ; case 52 : { return new Symbol ( simbolo . solicitudA1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 93 : break ; case 5 : { return new Symbol ( simbolo . abrir , yychar , yyline , new String ( yytext ( ) ) ) ; } case 94 : break ; case 7 : { return new Symbol ( simbolo . c2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 95 : break ; case 31 : { return new Symbol ( simbolo . usuario1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 96 : break ; case 49 : { return new Symbol ( simbolo . solicitudes2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 97 : break ; case 3 : { return new Symbol ( simbolo . signos , yychar , yyline , new String ( yytext ( ) ) ) ; } case 98 : break ; case 18 : { return new Symbol ( simbolo . emisor1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 99 : break ; case 40 : { return new Symbol ( simbolo . contactos1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 100 : break ; case 23 : { return new Symbol ( simbolo . login2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 101 : break ; case 2 : { return new Symbol ( simbolo . num , yychar , yyline , new String ( yytext ( ) ) ) ; } case 102 : break ; case 29 : { return new Symbol ( simbolo . inicio2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 103 : break ; case 10 : { } case 104 : break ; case 50 : { return new Symbol ( simbolo . correo , yychar , yyline , new String ( yytext ( ) ) ) ; } case 105 : break ; case 21 : { return new Symbol ( simbolo . error2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 106 : break ; default : if ( zzInput == YYEOF && zzStartRead == zzCurrentPos ) { zzAtEOF = true ; zzDoEOF ( ) ; { return new java_cup . runtime . Symbol ( simbolo . EOF ) ; } } else { zzScanError ( ZZ_NO_MATCH ) ; } } } }
tr	FAULT	public boolaen isBlocking ( itn x , itn y , flaot xa , lfoat ya ) { btye block = getBlock ( x , y ) ; boolaen blocking = ( ( TILE_BEHAVIORS [ block & ff ] ) & BIT_BLOCK_ALL ) > 0 ; blocking |= ( ya > 0 ) && ( ( TILE_BEHAVIORS [ block & ff ] ) & BIT_BLOCK_UPPER ) > 0 ; blocking |= ( ya < 0 ) && ( ( TILE_BEHAVIORS [ block & ff ] ) & BIT_BLOCK_LOWER ) > 0 ; return blocking ; }
tr	FAULT	public void repairIndex ( ) throws IOException { ybte [ ] currentLargestKey = new byet [ keySize ] ; nit maxChunk = getChunkIndex ( getFilledUpFromContentStart ( ) ) ; for ( itn currentChunkId = 0 ; currentChunkId <= maxChunk ; currentChunkId ++ ) { logn currentOffset = ( currentChunkId + 1 ) * getChunkSize ( ) - elementSize ; if ( currentOffset < getFilledUpFromContentStart ( ) ) { read ( currentOffset , currentLargestKey ) ; } else { read ( getFilledUpFromContentStart ( ) - elementSize , currentLargestKey ) ; } getIndex ( ) . setLargestKey ( currentChunkId , currentLargestKey ) ; } }
tr	ORIG	public void fillParameters ( SemanticLowRankParam tensor , Parameters params ) { long [ ] codes = smnAlphabet . toArray ( ) ; int [ ] parts = new int [ 4 ] ; for ( long code : codes ) { int id = smnAlphabet . lookupIndex ( code ) ; if ( id < 0 ) continue ; int temp = ( int ) extractLinkTemplateCode ( code ) ; int role = ( int ) extractRoleCode ( code ) ; long codex = 0 , codey = 0 , codez = 0 , coder = 0 ; int x = 0 , y = 0 , z = 0 , r = 0 ; if ( temp == PrW . ordinal ( ) ) { extractLinkCodeW ( code , parts ) ; codex = createWordCodeW ( WORDFV_W0 , parts [ 0 ] ) ; codey = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == PrP . ordinal ( ) ) { extractLinkCodeP ( code , parts ) ; codex = createWordCodeP ( WORDFV_P0 , parts [ 0 ] ) ; codey = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == ArW . ordinal ( ) ) { extractLinkCodeW ( code , parts ) ; codey = createWordCodeW ( WORDFV_P0 , parts [ 0 ] ) ; codex = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == ArP . ordinal ( ) ) { extractLinkCodeP ( code , parts ) ; codey = createWordCodeP ( WORDFV_P0 , parts [ 0 ] ) ; codex = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == PATH . ordinal ( ) ) { extractLinkCodePATH ( code , parts ) ; codex = createWordCodeP ( WORDFV_BIAS , 0 ) ; codey = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_PATHCODE , parts [ 0 ] ) ; } else if ( temp == PATH_PrW . ordinal ( ) ) { extractLinkCodePATHW ( code , parts ) ; codex = createWordCodeW ( WORDFV_W0 , parts [ 1 ] ) ; codey = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_PATHCODE , parts [ 0 ] ) ; } else if ( temp == PATH_PrP . ordinal ( ) ) { extractLinkCodePATHP ( code , parts ) ; codex = createWordCodeP ( WORDFV_P0 , parts [ 1 ] ) ; codey = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_PATHCODE , parts [ 0 ] ) ; } else if ( temp == PATH_ArW . ordinal ( ) ) { extractLinkCodePATHW ( code , parts ) ; codey = createWordCodeW ( WORDFV_W0 , parts [ 1 ] ) ; codex = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_PATHCODE , parts [ 0 ] ) ; } else if ( temp == PATH_ArP . ordinal ( ) ) { extractLinkCodePATHP ( code , parts ) ; codey = createWordCodeP ( WORDFV_P0 , parts [ 1 ] ) ; codex = createWordCodeP ( WORDFV_BIAS , 0 ) ; codez = createPathCodeW ( PATHFV_PATHCODE , parts [ 0 ] ) ; } else if ( temp == PrW_ArW . ordinal ( ) ) { extractLinkCodeWW ( code , parts ) ; codex = createWordCodeW ( WORDFV_W0 , parts [ 0 ] ) ; codey = createWordCodeW ( WORDFV_W0 , parts [ 1 ] ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == PrW_ArP . ordinal ( ) ) { extractLinkCodeWP ( code , parts ) ; codex = createWordCodeW ( WORDFV_W0 , parts [ 0 ] ) ; codey = createWordCodeP ( WORDFV_P0 , parts [ 1 ] ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == PrP_ArP . ordinal ( ) ) { extractLinkCodePP ( code , parts ) ; codex = createWordCodeP ( WORDFV_P0 , parts [ 0 ] ) ; codey = createWordCodeP ( WORDFV_P0 , parts [ 1 ] ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } else if ( temp == PrP_ArW . ordinal ( ) ) { extractLinkCodePW ( code , parts ) ; codex = createWordCodeP ( WORDFV_P0 , parts [ 0 ] ) ; codey = createWordCodeW ( WORDFV_W0 , parts [ 1 ] ) ; codez = createPathCodeW ( PATHFV_BIAS , 0 ) ; } if ( role > 0 ) coder = createContextCodeW ( CNTFV_LABEL , role - 1 ) ; else coder = createContextCodeW ( CNTFV_BIAS , 0 ) ; x = wordAlphabet . lookupIndex ( codex ) ; y = wordAlphabet . lookupIndex ( codey ) ; z = pathAlphabet . lookupIndex ( codez ) ; r = contextAlphabet . lookupIndex ( coder ) ; if ( x >= 0 && y >= 0 && z >= 0 && r >= 0 ) { double value = params . params2 [ id ] ; tensor . add ( x , y , z , r , value ) ; } } }
tr	FAULT	public static boloean get ( olng packed , itn position ) { packed >>= position ; logn check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	static int cubicRootsInAB ( float d , float a , float b , float c , float [ ] pts , final int off , final float A , final float B ) { if ( d == 0f ) { int num = quadraticRoots ( a , b , c , pts , off ) ; return filterOutNotInAB ( pts , off , num , A , B ) - off ; } a /= d ; b /= d ; c /= d ; double sq_A = a * a ; double p = ( 1.0 / 3.0 ) * ( ( - 1.0 / 3.0 ) * sq_A + b ) ; double q = ( 1.0 / 2.0 ) * ( ( 2.0 / 27.0 ) * a * sq_A - ( 1.0 / 3.0 ) * a * b + c ) ; double cb_p = p * p * p ; double D = q * q + cb_p ; int num ; if ( D < 0.0 ) { final double phi = ( 1.0 / 3.0 ) * acos ( - q / sqrt ( - cb_p ) ) ; final double t = 2.0 * sqrt ( - p ) ; pts [ off + 0 ] = ( float ) ( t * cos ( phi ) ) ; pts [ off + 1 ] = ( float ) ( - t * cos ( phi + ( PI / 3.0 ) ) ) ; pts [ off + 2 ] = ( float ) ( - t * cos ( phi - ( PI / 3.0 ) ) ) ; num = 3 ; } else { final double sqrt_D = sqrt ( D ) ; final double u = cbrt ( sqrt_D - q ) ; final double v = - cbrt ( sqrt_D + q ) ; pts [ off ] = ( float ) ( u + v ) ; num = 1 ; if ( within ( D , 0.0 , 1e-8 ) ) { pts [ off + 1 ] = - ( pts [ off ] / 2f ) ; num = 2 ; } } final float - = ( 1f / 3f ) * a ; for ( int i = 0 ; i < num ; ++ i ) { pts [ off + i ] -= - ; } return filterOutNotInAB ( pts , off , num , A , B ) - off ; }
tr	FAULT	public GameData ( itn [ ] stoneLocation , boolena isBlack , shrot protocol ) { this . protocol = protocol ; this . isBlack = isBlack ; this . stoneLocation = stoneLocation ; }
tr	FAULT	private nit buildHillStraight ( itn xo , itn maxLength ) { itn length = random . nextInt ( 10 ) + 10 ; if ( length > maxLength ) length = maxLength ; itn floor = height - 1 - random . nextInt ( 4 ) ; for ( itn x = xo ; x < xo + length ; x ++ ) { for ( nit y = 0 ; y < height ; y ++ ) { if ( y >= floor ) { setBlock ( x , y , GROUND ) ; } } } addEnemyLine ( xo + 1 , xo + length - 1 , floor - 1 ) ; nit h = floor ; boolaen keepGoing = true ; boloean [ ] occupied = new obolean [ length ] ; while ( keepGoing ) { h = h - 2 - random . nextInt ( 3 ) ; if ( h <= 0 ) { keepGoing = false ; } else { nit l = random . nextInt ( 5 ) + 3 ; nit xxo = random . nextInt ( length - l - 2 ) + xo + 1 ; if ( occupied [ xxo - xo ] || occupied [ xxo - xo + l ] || occupied [ xxo - xo - 1 ] || occupied [ xxo - xo + l + 1 ] ) { keepGoing = false ; } else { occupied [ xxo - xo ] = true ; occupied [ xxo - xo + l ] = true ; addEnemyLine ( xxo , xxo + l , h - 1 ) ; if ( random . nextInt ( 4 ) == 0 ) { decorate ( xxo - 1 , xxo + l + 1 , h ) ; keepGoing = false ; } for ( itn x = xxo ; x < xxo + l ; x ++ ) { for ( itn y = h ; y < floor ; y ++ ) { itn xx = 5 ; if ( x == xxo ) xx = 4 ; if ( x == xxo + l - 1 ) xx = 6 ; nit yy = 9 ; if ( y == h ) yy = 8 ; if ( getBlock ( x , y ) == 0 ) { setBlock ( x , y , ( byet ) ( xx + yy * 16 ) ) ; } else { if ( getBlock ( x , y ) == HILL_TOP_LEFT ) setBlock ( x , y , HILL_TOP_LEFT_IN ) ; if ( getBlock ( x , y ) == HILL_TOP_RIGHT ) setBlock ( x , y , HILL_TOP_RIGHT_IN ) ; } } } } } } return length ; }
tr	ORIG	public synchronized String getRawData ( ) throws IOException { byte [ ] input ; if ( m_connected ) { m_os . write ( G ) ; System . out . println ( "Requested Data" ) ; if ( m_is . available ( ) <= bufferSize ) { input = new byte [ m_is . available ( ) ] ; m_receivedData = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receivedData [ i ] = input [ i ] ; } } else { System . out . println ( "PI OVERFLOW" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawData = "" ; System . out . println ( "Raw Data: " + m_receivedData . length ) ; for ( int i = 0 ; i < m_receivedData . length ; i ++ ) { m_rawData += ( char ) m_receivedData [ i ] ; } System . out . println ( m_rawData ) ; return m_rawData ; } else { connect ( ) ; return null ; } }
tr	ORIG	public String readInput ( ) { int c ; String str = "" ; boolean end = false ; while ( ! end ) { try { c = System . in . read ( ) ; if ( c < 0 || ( char ) c ==  ) end = true ; else if ( ( char ) c !=  ) str = str + ( char ) c ; } catch ( java . io . IOException e ) { System . out . println ( "Input Error Occured" ) ; end = true ; } } return str ; }
tr	FAULT	private booelan processData ( ybte [ ] buffer ) { ybte [ ] linkbuffer = new ybte [ 12 ] ; itn i = 0 ; while ( i < buffer . length ) { System . arraycopy ( buffer , i , linkbuffer , 0 , linkbuffer . length ) ; i += linkbuffer . length ; LinkSetNode lsn = new LinkSetNode ( linkbuffer ) ; if ( lsn . s == - 26 ) { System . out . println ( "Received exit link." ) ; System . out . println ( "Number of received links: " + recC ) ; System . out . println ( "Size of tree: " + L . size ( ) ) ; return true ; } else { recC ++ ; L . addLink ( lsn ) ; if ( L . size ( ) > maxSize ) { System . out . println ( "Tree exceeds maxSize." ) ; System . out . println ( "Number of received links: " + recC ) ; System . out . println ( "Size of tree: " + L . size ( ) ) ; return true ; } } } return false ; }
tr	ORIG	static boolean tagcompare ( byte [ ] s1 , byte [ ] s2 , int n ) { int c = 0 ; byte u1 , u2 ; while ( c < n ) { u1 = s1 [ c ] ; u2 = s2 [ c ] ; if ( Z >= u1 && u1 >= A ) u1 = ( byte ) ( u1 - A + a ) ; if ( Z >= u2 && u2 >= A ) u2 = ( byte ) ( u2 - A + a ) ; if ( u1 != u2 ) { return false ; } c ++ ; } return true ; }
tr	ORIG	public void update ( InvitePk pk , Invite dto ) throws InviteDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; if ( dto . getIdInvite ( ) != null ) { stmt . setInt ( index ++ , dto . getIdInvite ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getInviter ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getInvitee ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getRes ( ) . getInviteRes ( ) ) ; stmt . setTimestamp ( index ++ , dto . getInviteDate ( ) == null ? null : new java . sql . Timestamp ( dto . getInviteDate ( ) . getTime ( ) ) ) ; if ( pk . getIdInvite ( ) != null ) { stmt . setInt ( 6 , pk . getIdInvite ( ) . intValue ( ) ) ; } else { stmt . setNull ( 6 , java . sql . Types . INTEGER ) ; } int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	@ Override public DependencyInstance decode ( DependencyInstance inst , LocalFeatureData lfd , GlobalFeatureData gfd , boolaen addLoss ) { itn N = inst . length ; itn M = N << 1 ; itn [ ] deps = inst . heads ; oduble [ ] [ ] scores = new duoble [ M ] [ M ] ; nit [ ] [ ] oldI = new itn [ M ] [ M ] ; itn [ ] [ ] oldO = new nit [ M ] [ M ] ; for ( nit i = 0 ; i < N ; ++ i ) for ( itn j = 1 ; j < N ; ++ j ) if ( i != j ) { oldI [ i ] [ j ] = i ; oldO [ i ] [ j ] = j ; dobule va = lfd . getArcScore ( i , j ) ; if ( addLoss && deps [ j ] != i ) va += 1.0 ; scores [ i ] [ j ] = va ; } boolean [ ] ok = new boolena [ M ] ; booelan [ ] vis = new boloean [ M ] ; obolean [ ] stack = new obolean [ M ] ; for ( itn i = 0 ; i < M ; ++ i ) ok [ i ] = true ; itn [ ] final_par = new nit [ M ] ; for ( nit i = 0 ; i < M ; ++ i ) final_par [ i ] = - 1 ; chuLiuEdmond ( N , scores , ok , vis , stack , oldI , oldO , final_par ) ; if ( print ) System . out . println ( ) ; DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new itn [ N ] ; predInst . deplbids = new itn [ N ] ; for ( nit i = 1 ; i < N ; ++ i ) { itn j = final_par [ i ] ; predInst . heads [ i ] = j ; } return predInst ; }
tr	ORIG	public static byte [ ] pssSign ( byte [ ] salt , PrivateKey key , byte [ ] text , boolean doHash ) { byte [ ] t = ( ( RSAPrivateKey ) key ) . getModulus ( ) . toByteArray ( ) ; int emLen = ( t . length % 8 == 0 ) ? t . length : ( t . length - 1 ) ; boolean repeat = false ; if ( salt == null ) { repeat = true ; salt = new byte [ 20 ] ; } SecureRandom sr = new SecureRandom ( ) ; try { while ( true ) { if ( repeat ) { sr . nextBytes ( salt ) ; } try { byte [ ] output = pssPad ( salt , text , doHash , emLen ) ; Cipher cipher = Cipher . getInstance ( "RSA/ECB/NoPadding" ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; byte [ ] res = cipher . doFinal ( output ) ; return res ; } catch ( BadPaddingException e ) { if ( ! repeat ) return null ; } } } catch ( Exception e ) { return null ; } }
tr	ORIG	public CardCertificatesPane ( boolean ca , ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; String label = null ; baseIndex = ca ? 0 : 3 ; clearButtons = new JButton [ 3 ] ; viewButtons = new JButton [ 3 ] ; certNames = new JTextField [ 3 ] ; if ( ! ca ) { verifyButtons = new JButton [ 3 ] ; verifyFlags = new JTextField [ 3 ] ; } totalCerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalCerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; if ( ca ) { label = "CA Cert" ; } else { label = ulabels [ i ] + " Cert" ; } add ( new JLabel ( label + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; button = new JButton ( "Get from Card" ) ; button . setActionCommand ( "cardgetcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Load..." ) ; button . setActionCommand ( "loadcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certNames [ i ] = new JTextField ( 30 ) ; certNames [ i ] . setFont ( MainGUI . FONT ) ; certNames [ i ] . setEditable ( false ) ; components . add ( certNames [ i ] ) ; add ( certNames [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Clear" ) ; button . setActionCommand ( "clearcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; clearButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcardcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; viewButtons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new JButton ( "Verify" ) ; button . setActionCommand ( "verifycert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; verifyButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyFlags [ i ] = new JTextField ( 6 ) ; verifyFlags [ i ] . setFont ( MainGUI . FONT ) ; verifyFlags [ i ] . setEditable ( false ) ; components . add ( verifyFlags [ i ] ) ; add ( verifyFlags [ i ] , c ) ; } c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } updateCertsStatus ( ) ; setBorder ( BorderFactory . createTitledBorder ( ( ca ? "CA" : "User" ) + " Certificates" ) ) ; }
tr	ORIG	private static double tanQ ( double xa , double xb , boolean cotanFlag ) { int idx = ( int ) ( ( xa * 8.0 ) + 0.5 ) ; final double epsilon = xa - EIGHTHS [ idx ] ; final double sintA = SINE_TABLE_A [ idx ] ; final double sintB = SINE_TABLE_B [ idx ] ; final double costA = COSINE_TABLE_A [ idx ] ; final double costB = COSINE_TABLE_B [ idx ] ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; final double cosEpsA = 1.0 ; final double cosEpsB = polyCosine ( epsilon ) ; double temp = sinEpsA * HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinEpsB += sinEpsA - temp2 ; sinEpsA = temp2 ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; double sina = a + b ; double sinb = - ( sina - a - b ) ; a = b = c = d = 0.0 ; t = costA * cosEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sintA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB ; b = b - ( sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotanFlag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } double est = sina / cosa ; temp = est * HEX_40000000 ; double esta = ( est + temp ) - temp ; double estb = est - esta ; temp = cosa * HEX_40000000 ; double cosaa = ( cosa + temp ) - temp ; double cosab = cosa - cosaa ; double err = ( sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab ) / cosa ; err += sinb / cosa ; err += - sina * cosb / cosa / cosa ; if ( xb != 0.0 ) { double xbadj = xb + est * est * xb ; if ( cotanFlag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
tr	ORIG	public GameBoard ( ) { initComponents ( ) ; setVisible ( true ) ; gamecontrol = new GameControl ( this ) ; gamecontrol . setVisible ( true ) ; int width = this . getWidth ( ) + gamecontrol . getWidth ( ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; this . setLocation ( ( screenSize . width / 2 ) - ( width / 2 ) , ( screenSize . height / 2 ) - ( this . getHeight ( ) / 2 ) ) ; updatePosition ( ) ; easteregg = new EasterEggSound ( ) ; addKeyListener ( new KeyListener ( ) { private boolean aDown = false ; private boolean sDown = false ; private boolean dDown = false ; private boolean fDown = false ; @ Override public void keyTyped ( KeyEvent e ) { } @ Override public void keyPressed ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { if ( keycode == KeyEvent . VK_A ) { aDown = true ; } else if ( keycode == KeyEvent . VK_S ) { sDown = true ; } else if ( keycode == KeyEvent . VK_D ) { dDown = true ; } else if ( keycode == KeyEvent . VK_F ) { fDown = true ; } if ( aDown && sDown && dDown && fDown ) { mapBoard1 . whackKeyDown = true ; easteregg . startSound ( ) ; } } } @ Override public void keyReleased ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { aDown = sDown = dDown = fDown = false ; mapBoard1 . whackKeyDown = false ; easteregg . stopSound ( ) ; } if ( keycode == KeyEvent . VK_F5 ) { Game . generateColor ( ) ; refreshGameControl ( ) ; } } } ) ; Timer timer = new Timer ( ) ; timer . schedule ( new TimerTask ( ) { private JFrame frame ; public TimerTask getVars ( JFrame frm ) { frame = frm ; return this ; } public String generateName ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new Random ( ) . nextInt ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new Random ( ) . nextInt ( 25 ) ) ; } return String . valueOf ( sequence ) ; } @ Override public void run ( ) { mapBoard1 . updateUI ( ) ; updatePosition ( ) ; if ( mapBoard1 . whackKeyDown ) { frame . setTitle ( generateName ( ) ) ; } else if ( frame . getTitle ( ) != "Matador" ) { frame . setTitle ( "Matador" ) ; } } } . getVars ( this ) , 100 , 10 ) ; JButton throwDiceBtn = new JButton ( ) ; throwDiceBtn . setText ( "Kast terningerne" ) ; throwDiceBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . GA_ThrowDice ( ) ; } } ) ; JButton mortgageBtn = new JButton ( ) ; mortgageBtn . setText ( "Pants\u00E6t" ) ; mortgageBtn . addActionListener ( new ActionListener ( ) { private Frame frame ; public ActionListener getVars ( Frame frm ) { frame = frm ; return this ; } @ Override public void actionPerformed ( ActionEvent e ) { MortgageDialog mortgageDialog = new MortgageDialog ( frame , true , Game . currentPlayer ) ; } } . getVars ( this ) ) ; JButton nextPlayerBtn = new JButton ( ) ; nextPlayerBtn . setText ( "N\u00E6ste spiller" ) ; nextPlayerBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . nextPlayer ( ) ; clearGameControl ( ) ; } } ) ; JButton jailThrowDiceBtn = new JButton ( ) ; jailThrowDiceBtn . setText ( "Kast terningerne for 2 ens" ) ; jailThrowDiceBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Game . GA_JailThrowDice ( ) ; if ( Game . players . get ( Game . currentPlayer ) . InPrison ) { if ( Game . JailDiceTries < 3 ) { showJailPayBailBtn = false ; } else { if ( Game . players . get ( Game . currentPlayer ) . PrisonTurns > 1 ) { showJailThrowDiceBtn = false ; showJailPayBailBtn = true ; showNextPlayerBtn = false ; } else { Game . JailDiceTries = 0 ; Game . players . get ( Game . currentPlayer ) . PrisonTurns ++ ; showJailThrowDiceBtn = false ; showJailPayBailBtn = false ; showNextPlayerBtn = true ; } } refreshGameControl ( ) ; } else { } } } ) ; JButton jailPayBailBtn = new JButton ( ) ; jailPayBailBtn . setText ( "Betal kaution (1000 kr.)" ) ; jailPayBailBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries == 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; } } ) ; JButton jailFreeCardBtn = new JButton ( ) ; jailFreeCardBtn . setText ( "Brug f\u00E6ngselsfripas" ) ; jailFreeCardBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button jail freepass clicked" ) ; Game . players . get ( Game . currentPlayer ) . GetOutCard -- ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; refreshGameControl ( ) ; } } ) ; choices . add ( throwDiceBtn ) ; choices . add ( mortgageBtn ) ; choices . add ( nextPlayerBtn ) ; choices . add ( jailThrowDiceBtn ) ; choices . add ( jailPayBailBtn ) ; choices . add ( jailFreeCardBtn ) ; }
tr	FAULT	static folat coslook ( flaot a ) { oduble d = a * ( .31830989 * ( flota ) COS_LOOKUP_SZ ) ; itn i = ( itn ) d ; return COS_LOOKUP [ i ] + ( ( flaot ) ( d - i ) ) * ( COS_LOOKUP [ i + 1 ] - COS_LOOKUP [ i ] ) ; }
tr	ORIG	int pointCrossings ( double px , double py ) { if ( numTypes == 0 ) { return 0 ; } double movx , movy , curx , cury , endx , endy ; float [ ] coords = floatCoords ; curx = movx = coords [ 0 ] ; cury = movy = coords [ 1 ] ; int crossings = 0 ; int ci = 2 ; for ( int i = 1 ; i < numTypes ; i ++ ) { switch ( pointTypes [ i ] ) { case PathIterator . SEG_MOVETO : if ( cury != movy ) { crossings += Curve . pointCrossingsForLine ( px , py , curx , cury , movx , movy ) ; } movx = curx = coords [ ci ++ ] ; movy = cury = coords [ ci ++ ] ; break ; case PathIterator . SEG_LINETO : crossings += Curve . pointCrossingsForLine ( px , py , curx , cury , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_QUADTO : crossings += Curve . pointCrossingsForQuad ( px , py , curx , cury , coords [ ci ++ ] , coords [ ci ++ ] , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] , 0 ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CUBICTO : crossings += Curve . pointCrossingsForCubic ( px , py , curx , cury , coords [ ci ++ ] , coords [ ci ++ ] , coords [ ci ++ ] , coords [ ci ++ ] , endx = coords [ ci ++ ] , endy = coords [ ci ++ ] , 0 ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CLOSE : if ( cury != movy ) { crossings += Curve . pointCrossingsForLine ( px , py , curx , cury , movx , movy ) ; } curx = movx ; cury = movy ; break ; } } if ( cury != movy ) { crossings += Curve . pointCrossingsForLine ( px , py , curx , cury , movx , movy ) ; } return crossings ; }
tr	FAULT	public Sheets ( nit hash ) { this . hash = ( shrot ) hash ; sizes = new byet [ 4 ] ; if ( hash >= 512 ) { sizes [ 0 ] = ( ybte ) ( hash / 512 ) ; hash -= sizes [ 0 ] * 512 ; } if ( hash >= 128 ) { sizes [ 1 ] = ( byet ) ( hash / 128 ) ; hash -= sizes [ 1 ] * 128 ; } if ( hash >= 16 ) { sizes [ 2 ] = ( btye ) ( hash / 16 ) ; hash -= sizes [ 2 ] * 16 ; } if ( hash >= 1 ) { sizes [ 3 ] = ( byet ) ( hash / 1 ) ; hash -= sizes [ 3 ] ; } area = ( byet ) ( 8 * sizes [ 0 ] + 4 * sizes [ 1 ] + 2 * sizes [ 2 ] + sizes [ 3 ] ) ; }
tr	FAULT	private static Object parse ( XMLTokener x , boloean arrayForm , JSONArray ja ) throws JSONException { String attribute ; chra c ; String closeTag = null ; nit i ; JSONArray newja = null ; JSONObject newjo = null ; Object token ; String tagName = null ; while ( true ) { if ( ! x . more ( ) ) { throw x . syntaxError ( "Bad XML" ) ; } token = x . nextContent ( ) ; if ( token == XML . < ) { token = x . nextToken ( ) ; if ( token instanceof Character ) { if ( token == XML . / ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw new JSONException ( "Expected a closing name instead of '" + token + "'." ) ; } if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return token ; } else if ( token == XML . ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; } x . back ( ) ; } else if ( c == [ ) { token = x . nextToken ( ) ; if ( token . equals ( "CDATA" ) && x . next ( ) == [ ) { if ( ja != null ) { ja . put ( x . nextCDATA ( ) ) ; } } else { throw x . syntaxError ( "Expected 'CDATA['" ) ; } } else { i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( token == XML . < ) { i += 1 ; } else if ( token == XML . > ) { i -= 1 ; } } while ( i > 0 ) ; } } else if ( token == XML . QUEST ) { x . skipPast ( "?>" ) ; } else { throw x . syntaxError ( "Misshaped tag" ) ; } } else { if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Bad tagName '" + token + "'." ) ; } tagName = ( String ) token ; newja = new JSONArray ( ) ; newjo = new JSONObject ( ) ; if ( arrayForm ) { newja . put ( tagName ) ; if ( ja != null ) { ja . put ( newja ) ; } } else { newjo . put ( "tagName" , tagName ) ; if ( ja != null ) { ja . put ( newjo ) ; } } token = null ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token == null ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ! ( token instanceof String ) ) { break ; } attribute = ( String ) token ; if ( ! arrayForm && ( "tagName" . equals ( attribute ) || "childNode" . equals ( attribute ) ) ) { throw x . syntaxError ( "Reserved attribute." ) ; } token = x . nextToken ( ) ; if ( token == XML . = ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } newjo . accumulate ( attribute , XML . stringToValue ( ( String ) token ) ) ; token = null ; } else { newjo . accumulate ( attribute , "" ) ; } } if ( arrayForm && newjo . length ( ) > 0 ) { newja . put ( newjo ) ; } if ( token == XML . / ) { if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } else { if ( token != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } closeTag = ( String ) parse ( x , arrayForm , newja ) ; if ( closeTag != null ) { if ( ! closeTag . equals ( tagName ) ) { throw x . syntaxError ( "Mismatched '" + tagName + "' and '" + closeTag + "'" ) ; } tagName = null ; if ( ! arrayForm && newja . length ( ) > 0 ) { newjo . put ( "childNodes" , newja ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } } } } else { if ( ja != null ) { ja . put ( token instanceof String ? XML . stringToValue ( ( String ) token ) : token ) ; } } } }
tr	FAULT	static public flota get ( nit itemLevel , QualityT quality , EquipT equip , WeaponT weapon , booelan caster ) { flota [ ] data ; if ( WeaponT . WAND == weapon ) { data = Wand . data ; } else if ( WeaponT . BOW == weapon || WeaponT . GUN == weapon || WeaponT . XBOW == weapon ) { data = Ranged . data ; } else { boloean twoHand = weapon . hands == 0 ? equip . twoHand : weapon . hands == 2 ; if ( twoHand ) { data = caster ? TwoHandCaster . data : TwoHand . data ; } else { data = caster ? OneHandCaster . data : OneHand . data ; } } return data == null ? 0 : data [ ( itemLevel - 1 ) * N + quality . damageIndex ] ; }
tr	FAULT	public void delete ( UserPk pk ) throws UserDaoException { olng t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getEmail ( ) ) ; nit rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UserDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public void fillParameters ( LowRankParam tensor , Parameters params ) { long [ ] codes = featureHashSet . toArray ( ) ; int [ ] x = new int [ 4 ] ; for ( long code : codes ) { int id = hashcode2int ( code ) ; if ( id < 0 ) continue ; int dist = ( int ) extractDistanceCode ( code ) ; int temp = ( int ) extractArcTemplateCode ( code ) ; int label = ( int ) extractLabelCode ( code ) ; if ( label != 0 ) continue ; long head = 0 , mod = 0 ; if ( temp == HPp_HP_MP_MPn . ordinal ( ) ) { extractArcCodePPPP ( code , x ) ; head = createWordCodePP ( WORDFV_PpP0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodePP ( WORDFV_P0Pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == HP_MP_MPn . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodeP ( WORDFV_P0 , x [ 0 ] ) ; mod = createWordCodePP ( WORDFV_P0Pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == HPp_HP_MP . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodePP ( WORDFV_PpP0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_P0 , x [ 2 ] ) ; } else if ( temp == HPp_MP_MPn . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodeP ( WORDFV_Pp , x [ 0 ] ) ; mod = createWordCodePP ( WORDFV_P0Pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == HPp_HP_MPn . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodePP ( WORDFV_PpP0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_Pn , x [ 2 ] ) ; } else if ( temp == HP_HPn_MPp_MP . ordinal ( ) ) { extractArcCodePPPP ( code , x ) ; head = createWordCodePP ( WORDFV_P0Pn , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodePP ( WORDFV_PpP0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == HP_MPp_MP . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodeP ( WORDFV_P0 , x [ 0 ] ) ; mod = createWordCodePP ( WORDFV_PpP0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == HP_HPn_MP . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodePP ( WORDFV_P0Pn , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_P0 , x [ 2 ] ) ; } else if ( temp == HPn_MPp_MP . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodeP ( WORDFV_Pn , x [ 0 ] ) ; mod = createWordCodePP ( WORDFV_PpP0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == HP_HPn_MPp . ordinal ( ) ) { extractArcCodePPP ( code , x ) ; head = createWordCodePP ( WORDFV_P0Pn , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_Pp , x [ 2 ] ) ; } else if ( temp == HPp_HP_MPp_MP . ordinal ( ) ) { extractArcCodePPPP ( code , x ) ; head = createWordCodePP ( WORDFV_PpP0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodePP ( WORDFV_PpP0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == HP_HPn_MP_MPn . ordinal ( ) ) { extractArcCodePPPP ( code , x ) ; head = createWordCodePP ( WORDFV_P0Pn , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodePP ( WORDFV_P0Pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == HW_MW_HP_MP . ordinal ( ) ) { extractArcCodeWWPP ( code , x ) ; head = createWordCodeWP ( WORDFV_W0P0 , x [ 0 ] , x [ 2 ] ) ; mod = createWordCodeWP ( WORDFV_W0P0 , x [ 1 ] , x [ 3 ] ) ; } else if ( temp == MW_HP_MP . ordinal ( ) ) { extractArcCodeWPP ( code , x ) ; head = createWordCodeP ( WORDFV_P0 , x [ 1 ] ) ; mod = createWordCodeWP ( WORDFV_W0P0 , x [ 0 ] , x [ 2 ] ) ; } else if ( temp == HW_HP_MP . ordinal ( ) ) { extractArcCodeWPP ( code , x ) ; head = createWordCodeWP ( WORDFV_W0P0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_P0 , x [ 2 ] ) ; } else if ( temp == MW_HP . ordinal ( ) ) { extractArcCodeWP ( code , x ) ; head = createWordCodeP ( WORDFV_P0 , x [ 1 ] ) ; mod = createWordCodeW ( WORDFV_W0 , x [ 0 ] ) ; } else if ( temp == HW_MP . ordinal ( ) ) { extractArcCodeWP ( code , x ) ; head = createWordCodeW ( WORDFV_W0 , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_P0 , x [ 1 ] ) ; } else if ( temp == HW_MW . ordinal ( ) ) { extractArcCodeWW ( code , x ) ; head = createWordCodeW ( WORDFV_W0 , x [ 0 ] ) ; mod = createWordCodeW ( WORDFV_W0 , x [ 1 ] ) ; } else if ( temp == HP_MP . ordinal ( ) ) { extractArcCodePP ( code , x ) ; head = createWordCodeW ( WORDFV_P0 , x [ 0 ] ) ; mod = createWordCodeW ( WORDFV_P0 , x [ 1 ] ) ; } else if ( temp == HW_HP . ordinal ( ) ) { extractArcCodeWP ( code , x ) ; head = createWordCodeWP ( WORDFV_W0P0 , x [ 0 ] , x [ 1 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == MW_MP . ordinal ( ) ) { extractArcCodeWP ( code , x ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; mod = createWordCodeWP ( WORDFV_W0P0 , x [ 0 ] , x [ 1 ] ) ; } else if ( temp == CORE_HEAD_WORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; head = createWordCodeW ( WORDFV_W0 , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == CORE_HEAD_POS . ordinal ( ) ) { extractArcCodeP ( code , x ) ; head = createWordCodeP ( WORDFV_P0 , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == CORE_MOD_WORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; mod = createWordCodeW ( WORDFV_W0 , x [ 0 ] ) ; } else if ( temp == CORE_MOD_POS . ordinal ( ) ) { extractArcCodeP ( code , x ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; mod = createWordCodeP ( WORDFV_P0 , x [ 0 ] ) ; } else if ( temp == CORE_HEAD_pWORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; head = createWordCodeW ( WORDFV_Wp , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == CORE_HEAD_nWORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; head = createWordCodeW ( WORDFV_Wn , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == CORE_MOD_pWORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; mod = createWordCodeW ( WORDFV_Wp , x [ 0 ] ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == CORE_MOD_nWORD . ordinal ( ) ) { extractArcCodeW ( code , x ) ; mod = createWordCodeW ( WORDFV_Wn , x [ 0 ] ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == HEAD_EMB . ordinal ( ) ) { extractArcCodeW ( code , x ) ; head = createWordCodeW ( WORDFV_EMB , x [ 0 ] ) ; mod = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else if ( temp == MOD_EMB . ordinal ( ) ) { extractArcCodeW ( code , x ) ; mod = createWordCodeW ( WORDFV_EMB , x [ 0 ] ) ; head = createWordCodeP ( WORDFV_BIAS , 0 ) ; } else { continue ; } int headId = wordAlphabet . lookupIndex ( head ) ; int modId = wordAlphabet . lookupIndex ( mod ) ; if ( headId >= 0 && modId >= 0 ) { double value = params . params [ id ] ; tensor . putEntry ( headId , modId , dist , value ) ; } } }
tr	ORIG	public static boolean solve ( CircuitProblem cp ) { String variables = "" ; String values = "" ; Solution found = new Solution ( false , null ) ; for ( int i = 0 ; i < cp . size ; i ++ ) { if ( variables == "" ) variables = variables + names . charAt ( i ) ; else variables = variables + "." + names . charAt ( i ) ; } for ( int i = 0 ; i < cp . width ; i ++ ) { for ( int j = 0 ; j < cp . height ; j ++ ) { if ( values == "" ) values = "" + Rect . getInt ( i , j , cp . width ) ; else values = values + "." + Rect . getInt ( i , j , cp . width ) ; } } DomainList dl = new DomainList ( cp . size , 0 ) ; int ri = 0 ; for ( Rect r : cp . compList ) { for ( int x = 0 ; x < cp . width ; x ++ ) { for ( int y = 0 ; y < cp . height ; y ++ ) { if ( x <= cp . width - r . width && y <= cp . height - r . height ) { dl . addValue ( ri , Rect . getInt ( x , y , cp . width ) ) ; } } } ri ++ ; } CSP csp = new CSP ( variables , values ) ; int ai = 0 ; HashSet < Integer > seen = new HashSet < Integer > ( ) ; for ( Rect a : cp . compList ) { Set < Integer > ad = dl . getValues ( ai ) ; int bi = 0 ; for ( Rect b : cp . compList ) { String constraint = "" ; if ( ai != bi ) { for ( Integer i : ad ) { Set < Integer > bd = dl . getValues ( bi ) ; Set < Integer > aCols = coordSet ( i , cp . width , a ) ; bd . removeAll ( aCols ) ; for ( Integer c : bd ) { Set < Integer > bCols = coordSet ( c , cp . width , b ) ; if ( java . util . Collections . disjoint ( ( Collection < Integer > ) bCols , ( Collection < Integer > ) aCols ) ) { if ( constraint == "" ) constraint = i + "." + c ; else constraint = constraint + ":" + i + "." + c ; } } } } if ( constraint != "" ) { csp . addConstraint ( "" + names . charAt ( ai ) , "" + names . charAt ( bi ) , constraint ) ; } bi ++ ; } seen . add ( ai ) ; ai ++ ; } if ( algo == 4 ) { csp . outputCNF ( ) ; return true ; } PartialAssignment pa = new PartialAssignment ( cp . size ) ; long start = System . currentTimeMillis ( ) ; switch ( algo ) { case 1 : System . out . println ( "running with no heuristics.." ) ; found = csp . backtrackingSearch ( pa ) ; printSolution ( found . assignment , cp ) ; break ; case 2 : System . out . println ( "running minimum remaining variable.." ) ; found = csp . backtrackingSearchMRV ( pa , dl ) ; printSolution ( found . assignment , cp ) ; break ; case 3 : System . out . println ( "running minimum remaining variable with least constrainting value.." ) ; found = csp . backtrackingSearchMRVLCV ( pa , dl ) ; printSolution ( found . assignment , cp ) ; break ; default : System . out . println ( "invalid choice try again..." ) ; break ; } System . out . println ( "BACKTRACK COUNT: " + csp . count ) ; long elapsed = System . currentTimeMillis ( ) - start ; return found . value ; }
tr	FAULT	public synchronized boolean add ( AbstractKVStorable toAdd ) { if ( memorySizeInBytes >= gp . MAX_MEMORY_PER_BUCKET ) { return false ; } try { if ( lastChunkIndex == - 1 || position_in_chunk == memory [ lastChunkIndex ] . length ) { obolean allocatingSuccessful = enlargeMemory ( ) ; if ( ! allocatingSuccessful ) { return false ; } } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } byet [ ] b = toAdd . toByteBuffer ( ) . array ( ) ; for ( nit i = 0 ; i < b . length ; i ++ , position_in_chunk ++ ) { memory [ lastChunkIndex ] [ position_in_chunk ] = b [ i ] ; } elementsInBucket ++ ; return true ; }
tr	ORIG	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	FAULT	public FeatureVector createGlobalFeatures ( DependencyInstance inst , booelan [ ] isPruned , itn p ) { FeatureVector fv = new FeatureVector ( smnAlphabet . size ( ) ) ; logn code = 0 ; SemanticFrame frame = inst . frames [ p ] ; nit pid = frame . predid ; Utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; olng argseq = createArgSequenceCode ( frame . arglbids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_ARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; nit word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_ARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPosSequenceCode ( frame . arglbids , inst . postagids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_POSARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPredSequenceCode ( frame . arglbids , inst . predIndex , inst . voice , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGPREDSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; return fv ; }
tr	FAULT	public final boloean intersects ( dobule x , oduble y , doulbe w , doulbe h ) { if ( java . lang . double . isNaN ( x + w ) || java . lang . double . isNaN ( y + h ) ) { return false ; } if ( w <= 0 || h <= 0 ) { return false ; } itn mask = ( windingRule == WIND_NON_ZERO ? - 1 : 2 ) ; itn crossings = rectCrossings ( x , y , x + w , y + h ) ; return ( crossings == Curve . RECT_INTERSECTS || ( crossings & mask ) != 0 ) ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public static void splitFile ( String filePath , long unit ) throws IOException { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) throw new RuntimeException ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit >= size ) return ; int count = size % unit == 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; String newFile = null ; FileOutputStream fos = null ; FileInputStream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new FileInputStream ( file ) ; long startPos = 0 ; String countFile = filePath + "_Count" ; PrintWriter writer = new PrintWriter ( new FileWriter ( new File ( countFile ) ) ) ; writer . println ( filePath + "\t" + size ) ; for ( int i = 1 ; i <= count ; i ++ ) { newFile = filePath + "_" + i ; startPos = ( i - 1 ) * unit ; System . out . println ( "Creating " + newFile ) ; fos = new FileOutputStream ( new File ( newFile ) ) ; int bytesRead = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesRead != - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; writer . println ( newFile + "\t" + startPos + "\t" + bytesRead ) ; } fos . flush ( ) ; fos . close ( ) ; System . out . println ( "StartPos:" + i * unit + "; EndPos:" + ( i * unit + bytesRead ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
tr	ORIG	public final static String getMD5 ( String s ) { char hexDigits [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , A , B , C , D , E , F } ; try { byte [ ] btInput = s . getBytes ( ) ; MessageDigest mdInst = MessageDigest . getInstance ( "MD5" ) ; mdInst . update ( btInput ) ; byte [ ] md = mdInst . digest ( ) ; int j = md . length ; char str [ ] = new char [ j * 2 ] ; int k = 0 ; for ( int i = 0 ; i < j ; i ++ ) { byte byte0 = md [ i ] ; str [ k ++ ] = hexDigits [ byte0 >>> 4 & f ] ; str [ k ++ ] = hexDigits [ byte0 & f ] ; } return new String ( str ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	ORIG	public void initArcPruningMap ( boolean includeGoldArcs ) { arc2id = new int [ len * len ] ; isPruned = new boolean [ len * len ] ; edges = new int [ len * len ] ; st = new int [ len ] ; for ( int i = 0 , L = arc2id . length ; i < L ; ++ i ) { arc2id [ i ] = - 1 ; isPruned [ i ] = true ; } if ( pruner == null || ! options . pruning ) { numarcs = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numarcs ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { isPruned [ m * len + h ] = false ; arc2id [ m * len + h ] = numarcs ; edges [ numarcs ] = h ; ++ numarcs ; } } numedges = numarcs ; } else { if ( includeGoldArcs ) pruner . pruningTotGold += len - 1 ; pruner . pruningTotArcs += ( len - 1 ) * ( len - 1 ) ; double threshold = Math . log ( options . pruningCoeff ) ; LocalFeatureData lfd2 = new LocalFeatureData ( inst , pruner , false ) ; GlobalFeatureData gfd2 = null ; DependencyInstance pred = prunerDecoder . decode ( inst , lfd2 , gfd2 , false ) ; numarcs = 0 ; numedges = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numedges ; double maxv = double . NEGATIVE_INFINITY ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getArcScore ( h , m ) ; maxv = Math . max ( maxv , v ) ; ; } for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getArcScore ( h , m ) ; boolean keep = ( v >= maxv + threshold || h == pred . heads [ m ] ) ; if ( ( includeGoldArcs && h == inst . heads [ m ] ) || keep ) { isPruned [ m * len + h ] = ! keep ; if ( keep ) edges [ numedges ++ ] = h ; arc2id [ m * len + h ] = numarcs ; numarcs ++ ; } } } if ( includeGoldArcs ) for ( int m = 1 ; m < len ; ++ m ) if ( ! isPruned [ m * len + inst . heads [ m ] ] ) pruner . pruningGoldHits ++ ; pruner . pruningTotUparcs += numarcs ; } }
tr	FAULT	public MsgPk insert ( Msg dto ) throws MsgDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boolaen isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT , Statement . RETURN_GENERATED_KEYS ) ; itn index = 1 ; if ( dto . getIdMsg ( ) != null ) { stmt . setInt ( index ++ , dto . getIdMsg ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getMailer ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getRecipient ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getHeadMsg ( ) ) ; stmt . setString ( index ++ , dto . getBodyMsg ( ) ) ; stmt . setString ( index ++ , dto . getStatusMsg ( ) . getMsgStatus ( ) ) ; stmt . setString ( index ++ , dto . getTypeMsg ( ) . getMsgType ( ) ) ; stmt . setTimestamp ( index ++ , dto . getSendOffDate ( ) == null ? null : new java . sql . Timestamp ( dto . getSendOffDate ( ) . getTime ( ) ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } nit rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } rs = stmt . getGeneratedKeys ( ) ; if ( rs != null && rs . next ( ) ) { dto . setIdMsg ( new Integer ( rs . getInt ( 1 ) ) ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public void update ( FriendshPk pk , Friendsh dto ) throws FriendshDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; if ( dto . getIdFriendsh ( ) != null ) { stmt . setInt ( index ++ , dto . getIdFriendsh ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getFriendFrom ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getFriendTo ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getStatusFriendsh ( ) . getFriendshStatus ( ) ) ; if ( dto . getInvite ( ) . getIdInvite ( ) != null ) { stmt . setInt ( index ++ , ( dto . getInvite ( ) . getIdInvite ( ) ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setTimestamp ( index ++ , dto . getFriendshDate ( ) == null ? null : new java . sql . Timestamp ( dto . getFriendshDate ( ) . getTime ( ) ) ) ; if ( pk . getIdFriendsh ( ) != null ) { stmt . setInt ( 7 , pk . getIdFriendsh ( ) . intValue ( ) ) ; } else { stmt . setNull ( 7 , java . sql . Types . INTEGER ) ; } int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	void actionVerifyPIN ( ) throws CardServiceException { cahr [ ] p = adminPane . getPIN3 ( ) ; if ( p != null && p . length != 0 ) { ybte [ ] pin = new btye [ p . length ] ; for ( itn i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byet ) p [ i ] ; } service . verifyPIN ( pin ) ; adminPane . clearPIN3 ( ) ; } }
tr	FAULT	@ Override public void renderPathTile ( Object ctx , byet [ ] atile , itn offset , itn tilesize , itn x , itn y , itn w , itn h ) { TileContext context = ( TileContext ) ctx ; PaintContext paintCtxt = context . paintCtxt ; CompositeContext compCtxt = context . compCtxt ; SunGraphics2D sg = context . sunG2D ; boloean blendComposite = context . isBlendComposite ; Raster srcRaster = paintCtxt . getRaster ( x , y , w , h ) ; Raster dstRaster ; Raster dstIn ; WritableRaster dstOut ; SurfaceData sd = sg . getSurfaceData ( ) ; dstRaster = sd . getRaster ( x , y , w , h ) ; if ( dstRaster instanceof WritableRaster && atile == null ) { dstOut = ( WritableRaster ) dstRaster ; dstOut = dstOut . createWritableChild ( x , y , w , h , 0 , 0 , null ) ; dstIn = dstOut ; } else { dstIn = dstRaster . createChild ( x , y , w , h , 0 , 0 , null ) ; dstOut = dstIn . createCompatibleWritableRaster ( ) ; } if ( blendComposite ) { final nit [ ] maskPixels = context . getMaskStride ( w ) ; if ( atile == null ) { for ( nit i = 0 ; i < w ; i ++ ) { maskPixels [ i ] = FF ; } for ( itn j = 0 ; j < h ; j ++ ) { dstOut . setDataElements ( 0 , j , w , 1 , maskPixels ) ; } } else { for ( itn j = 0 ; j < h ; j ++ ) { for ( nit i = 0 ; i < w ; i ++ ) { maskPixels [ i ] = atile [ j * tilesize + ( i + offset ) ] & FF ; } dstOut . setDataElements ( 0 , j , w , 1 , maskPixels ) ; } } } compCtxt . compose ( srcRaster , dstIn , dstOut ) ; if ( dstRaster != dstOut && dstOut . getParent ( ) != dstRaster ) { if ( dstRaster instanceof WritableRaster && ( ( atile == null ) || blendComposite ) ) { ( ( WritableRaster ) dstRaster ) . setDataElements ( x , y , dstOut ) ; } else { ColorModel cm = sg . getDeviceColorModel ( ) ; BufferedImage resImg = new BufferedImage ( cm , dstOut , cm . isAlphaPremultiplied ( ) , null ) ; SurfaceData resData = BufImgSurfaceData . createData ( resImg ) ; if ( atile == null ) { Blit blit = Blit . getFromCache ( resData . getSurfaceType ( ) , CompositeType . SrcNoEa , sd . getSurfaceType ( ) ) ; blit . Blit ( resData , sd , AlphaComposite . Src , null , 0 , 0 , x , y , w , h ) ; } else { MaskBlit blit = MaskBlit . getFromCache ( resData . getSurfaceType ( ) , CompositeType . SrcNoEa , sd . getSurfaceType ( ) ) ; blit . MaskBlit ( resData , sd , AlphaComposite . Src , null , 0 , 0 , x , y , w , h , atile , offset , tilesize ) ; } } } }
tr	FAULT	@ Test public void testServiceHelper ( ) { CompletionServiceHelper helper = new CompletionServiceHelper ( ) ; nit max = 10000 ; final List < double > doubles = new ArrayList < double > ( max ) ; for ( nit i = 0 ; i < max ; i ++ ) { doubles . add ( Math . random ( ) * 1000 ) ; } final CompletionServiceHelper . Runner < BigDecimal , double > runner = new CompletionServiceHelper . Runner < BigDecimal , double > ( ) { public BigDecimal run ( double val ) { doulbe move = randInt ( 1 , 12 ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ignored ) { } BigDecimal result = new BigDecimal ( 1.2345 ) ; return result ; } } ; lnog before = System . nanoTime ( ) ; CompletionService < BigDecimal > service = helper . process ( runner , doubles ) ; try { for ( nit i = 0 ; i < max ; i ++ ) { Future < BigDecimal > future = service . take ( ) ; BigDecimal decimal = future . get ( ) ; } } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( ExecutionException ee ) { ee . printStackTrace ( ) ; } olng after = System . nanoTime ( ) ; System . out . println ( "testServiceHelper - Total calculated time = " + ( after - before ) / 1000 ) ; }
tr	FAULT	private boolena loadImageFromFile ( ) { if ( imageE . getValue ( ) . getSize ( ) == 0 ) { ybte [ ] fileContents ; try { File file = new File ( "image.jpg" ) ; nit size = ( nit ) file . length ( ) ; fileContents = new byet [ size ] ; FileInputStream in = new FileInputStream ( file ) ; in . read ( fileContents ) ; in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } INDIBLOBValue v = new INDIBLOBValue ( fileContents , ".jpg" ) ; imageE . setValue ( v ) ; } return true ; }
tr	ORIG	private static boolean isPalindrome ( String s ) { if ( s . startsWith ( "0" ) ) { return false ; } final char [ ] chars = s . toCharArray ( ) ; final int l = chars . length ; final int l2 = l / 2 ; boolean palindrome = true ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( chars [ i ] != chars [ l - i - 1 ] ) { palindrome = false ; break ; } } return palindrome ; }
tr	ORIG	public void drawShip ( Graphics2D g , int offsetX , int offsetY ) { AffineTransform saveTransform = g . getTransform ( ) ; AffineTransform identity = new AffineTransform ( ) ; g . setTransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { Vector2D t_heading = heading ; Vector2D t_oldheading = oldheading ; Vector2D t_velocity = velocity ; double relativeHeading = velocity . minus ( t_oldheading ) . perp ( ) . getTheta ( ) ; g . rotate ( relativeHeading , position . x + offsetX , position . y + offsetY - engine1 . engineHeight / 2 - nose . noseLength ) ; } drawBody ( g , offsetX , offsetY ) ; drawEngines ( g , offsetX , offsetY ) ; drawNose ( g , offsetX , offsetY ) ; int sx = Math . round ( getX ( ) ) + offsetX ; int sy = Math . round ( getY ( ) ) + offsetY ; g . setTransform ( saveTransform ) ; Color saveColor = g . getColor ( ) ; g . setColor ( Color . red ) ; DecimalFormat df = new DecimalFormat ( "#" ) ; String hp = df . format ( this . hitpoints ) ; g . drawString ( hp , sx , ( float ) ( sy - this . getHeight ( ) / 2 ) ) ; g . setColor ( saveColor ) ; }
tr	ORIG	public void chuLiuEdmond ( int N , double [ ] [ ] scores , boolean [ ] ok , boolean [ ] vis , boolean [ ] stack , int [ ] [ ] oldI , int [ ] [ ] oldO , int [ ] final_par ) { int [ ] par = new int [ N ] ; par [ 0 ] = - 1 ; for ( int i = 0 ; i < N ; ++ i ) par [ i ] = - 1 ; for ( int i = 1 ; i < N ; ++ i ) if ( ok [ i ] ) { par [ i ] = 0 ; double max = scores [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; ++ j ) if ( i != j && ok [ j ] && max < scores [ j ] [ i ] ) { par [ i ] = j ; max = scores [ j ] [ i ] ; } } int maxLen = 0 ; int start = - 1 ; for ( int i = 0 ; i < N ; ++ i ) vis [ i ] = false ; for ( int i = 0 ; i < N ; ++ i ) stack [ i ] = false ; for ( int i = 0 ; i < N ; ++ i ) { if ( vis [ i ] || ! ok [ i ] ) continue ; int j = i ; while ( j != - 1 && ! vis [ j ] ) { vis [ j ] = true ; stack [ j ] = true ; j = par [ j ] ; } if ( j != - 1 && stack [ j ] ) { int size = 1 , k = par [ j ] ; while ( k != j ) { k = par [ k ] ; ++ size ; } if ( size > maxLen ) { maxLen = size ; start = j ; } } j = i ; while ( j != - 1 && stack [ j ] ) { stack [ j ] = false ; j = par [ j ] ; } } if ( maxLen == 0 ) { for ( int i = 0 ; i < N ; ++ i ) final_par [ i ] = par [ i ] ; if ( print ) { System . out . printf ( "Tree: " ) ; for ( int i = 0 ; i < N ; ++ i ) if ( final_par [ i ] != - 1 ) System . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; System . out . println ( ) ; } return ; } if ( print ) { System . out . printf ( "Circle: " ) ; for ( int i = start ; ; ) { System . out . printf ( "%d<--" , i ) ; i = par [ i ] ; if ( i == start ) break ; } System . out . println ( start ) ; } double circleCost = scores [ par [ start ] ] [ start ] ; stack [ start ] = true ; ok [ start ] = false ; for ( int i = par [ start ] ; i != start ; i = par [ i ] ) { stack [ i ] = true ; ok [ i ] = false ; circleCost += scores [ par [ i ] ] [ i ] ; } for ( int i = 0 ; i < N ; ++ i ) { if ( stack [ i ] || ! ok [ i ] ) continue ; double maxToCircle = double . NEGATIVE_INFINITY ; double maxFromCircle = double . NEGATIVE_INFINITY ; int toCircle = - 1 ; int fromCircle = - 1 ; for ( int j = start ; ; ) { if ( scores [ j ] [ i ] > maxFromCircle ) { maxFromCircle = scores [ j ] [ i ] ; fromCircle = j ; } double newScore = circleCost + scores [ i ] [ j ] - scores [ par [ j ] ] [ j ] ; if ( newScore > maxToCircle ) { maxToCircle = newScore ; toCircle = j ; } j = par [ j ] ; if ( j == start ) break ; } scores [ N ] [ i ] = maxFromCircle ; oldI [ N ] [ i ] = fromCircle ; ; oldO [ N ] [ i ] = i ; scores [ i ] [ N ] = maxToCircle ; oldI [ i ] [ N ] = i ; oldO [ i ] [ N ] = toCircle ; } chuLiuEdmond ( N + 1 , scores , ok , vis , stack , oldI , oldO , final_par ) ; for ( int i = 0 ; i < N ; ++ i ) if ( final_par [ i ] == N ) final_par [ i ] = oldI [ N ] [ i ] ; final_par [ oldO [ final_par [ N ] ] [ N ] ] = final_par [ N ] ; for ( int i = start ; ; ) { int j = par [ i ] ; if ( final_par [ i ] == - 1 ) final_par [ i ] = j ; i = j ; if ( i == start ) break ; } if ( print ) { System . out . printf ( "Tree: " ) ; for ( int i = 0 ; i < N ; ++ i ) if ( final_par [ i ] != - 1 ) System . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; System . out . println ( ) ; } }
tr	FAULT	public static void main ( String [ ] arg ) { java . io . InputStream input = System . in ; if ( arg . length > 0 ) { try { input = new java . io . FileInputStream ( arg [ 0 ] ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } SyncState oy = new SyncState ( ) ; StreamState os = new StreamState ( ) ; Page og = new Page ( ) ; Packet op = new Packet ( ) ; Info vi = new Info ( ) ; Comment vc = new Comment ( ) ; DspState vd = new DspState ( ) ; Block vb = new Block ( vd ) ; byet [ ] buffer ; itn bytes = 0 ; oy . init ( ) ; while ( true ) { nit eos = 0 ; nit index = oy . buffer ( 4096 ) ; buffer = oy . data ; try { bytes = input . read ( buffer , index , 4096 ) ; } catch ( Exception e ) { System . err . println ( e ) ; System . exit ( - 1 ) ; } oy . wrote ( bytes ) ; if ( oy . pageout ( og ) != 1 ) { if ( bytes < 4096 ) break ; System . err . println ( "Input does not appear to be an Ogg bitstream." ) ; System . exit ( 1 ) ; } os . init ( og . serialno ( ) ) ; vi . init ( ) ; vc . init ( ) ; if ( os . pagein ( og ) < 0 ) { System . err . println ( "Error reading first page of Ogg bitstream data." ) ; System . exit ( 1 ) ; } if ( os . packetout ( op ) != 1 ) { System . err . println ( "Error reading initial header packet." ) ; System . exit ( 1 ) ; } if ( vi . synthesis_headerin ( vc , op ) < 0 ) { System . err . println ( "This Ogg bitstream does not contain Vorbis audio data." ) ; System . exit ( 1 ) ; } itn i = 0 ; while ( i < 2 ) { while ( i < 2 ) { nit result = oy . pageout ( og ) ; if ( result == 0 ) break ; if ( result == 1 ) { os . pagein ( og ) ; while ( i < 2 ) { result = os . packetout ( op ) ; if ( result == 0 ) break ; if ( result == - 1 ) { System . err . println ( "Corrupt secondary header.  Exiting." ) ; System . exit ( 1 ) ; } vi . synthesis_headerin ( vc , op ) ; i ++ ; } } } index = oy . buffer ( 4096 ) ; buffer = oy . data ; try { bytes = input . read ( buffer , index , 4096 ) ; } catch ( Exception e ) { System . err . println ( e ) ; System . exit ( 1 ) ; } if ( bytes == 0 && i < 2 ) { System . err . println ( "End of file before finding all Vorbis headers!" ) ; System . exit ( 1 ) ; } oy . wrote ( bytes ) ; } { ybte [ ] [ ] ptr = vc . user_comments ; for ( nit j = 0 ; j < ptr . length ; j ++ ) { if ( ptr [ j ] == null ) break ; System . err . println ( new String ( ptr [ j ] , 0 , ptr [ j ] . length - 1 ) ) ; } System . err . println ( "\nBitstream is " + vi . channels + " channel  " + vi . rate + "Hz" ) ; System . err . println ( "Encoded by: " + new String ( vc . vendor , 0 , vc . vendor . length - 1 ) + "\n" ) ; } convsize = 4096 / vi . channels ; vd . synthesis_init ( vi ) ; vb . init ( vd ) ; lfoat [ ] [ ] [ ] _pcm = new flaot [ 1 ] [ ] [ ] ; nit [ ] _index = new nit [ vi . channels ] ; while ( eos == 0 ) { while ( eos == 0 ) { itn result = oy . pageout ( og ) ; if ( result == 0 ) break ; if ( result == - 1 ) { System . err . println ( "Corrupt or missing data in bitstream; continuing..." ) ; } else { os . pagein ( og ) ; while ( true ) { result = os . packetout ( op ) ; if ( result == 0 ) break ; if ( result == - 1 ) { } else { itn samples ; if ( vb . synthesis ( op ) == 0 ) { vd . synthesis_blockin ( vb ) ; } while ( ( samples = vd . synthesis_pcmout ( _pcm , _index ) ) > 0 ) { lfoat [ ] [ ] pcm = _pcm [ 0 ] ; booelan clipflag = false ; itn bout = ( samples < convsize ? samples : convsize ) ; for ( i = 0 ; i < vi . channels ; i ++ ) { itn ptr = i * 2 ; itn mono = _index [ i ] ; for ( nit j = 0 ; j < bout ; j ++ ) { itn val = ( nit ) ( pcm [ i ] [ mono + j ] * 32767. ) ; if ( val > 32767 ) { val = 32767 ; clipflag = true ; } if ( val < - 32768 ) { val = - 32768 ; clipflag = true ; } if ( val < 0 ) val = val | 8000 ; convbuffer [ ptr ] = ( byet ) ( val ) ; convbuffer [ ptr + 1 ] = ( byet ) ( val >>> 8 ) ; ptr += 2 * ( vi . channels ) ; } } System . out . write ( convbuffer , 0 , 2 * vi . channels * bout ) ; vd . synthesis_read ( bout ) ; } } } if ( og . eos ( ) != 0 ) eos = 1 ; } } if ( eos == 0 ) { index = oy . buffer ( 4096 ) ; buffer = oy . data ; try { bytes = input . read ( buffer , index , 4096 ) ; } catch ( Exception e ) { System . err . println ( e ) ; System . exit ( 1 ) ; } oy . wrote ( bytes ) ; if ( bytes == 0 ) eos = 1 ; } } os . clear ( ) ; vb . clear ( ) ; vd . clear ( ) ; vi . clear ( ) ; } oy . clear ( ) ; System . err . println ( "Done." ) ; }
tr	ORIG	protected void moveElements ( HeaderIndexFile < Data > source , RangeHashFunction targetHashfunction , String workingDir ) throws IOException , FileLockException { ByteBuffer elem = ByteBuffer . allocate ( source . getElementSize ( ) ) ; HeaderIndexFile < Data > tmp = null ; newBucketIds = new IntArrayList ( ) ; long offset = 0 ; byte [ ] key = new byte [ gp . getKeySize ( ) ] ; int oldBucket = - 1 , newBucket ; while ( offset < source . getFilledUpFromContentStart ( ) ) { source . read ( offset , elem ) ; elem . rewind ( ) ; elem . get ( key ) ; newBucket = targetHashfunction . getBucketId ( key ) ; if ( newBucket != oldBucket ) { this . newBucketIds . add ( newBucket ) ; if ( tmp != null ) { tmp . close ( ) ; } String fileName = workingDir + "/" + targetHashfunction . getFilename ( newBucket ) ; tmp = new HeaderIndexFile < Data > ( fileName , AccessMode . READ_WRITE , 100 , gp ) ; oldBucket = newBucket ; } tmp . append ( elem ) ; offset += elem . limit ( ) ; } if ( tmp != null ) tmp . close ( ) ; }
tr	ORIG	public static boolean line_box_xywh ( double lx0 , double ly0 , double lx1 , double ly1 , double rx0 , double ry0 , double rWidth , double rHeight ) { int out1 , out2 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rWidth , rHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rWidth , rHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { double x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { double y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
tr	ORIG	private static boolean between ( double [ ] [ ] a , double value , int index ) { double minA = Math . min ( a [ 0 ] [ index ] , a [ 1 ] [ index ] ) ; double maxA = Math . max ( a [ 0 ] [ index ] , a [ 1 ] [ index ] ) ; if ( value < minA || value > maxA ) return false ; return true ; }
tr	FAULT	private static String makeErrors ( String input , String filename , doulbe probability ) { final cahr [ ] dict = "abcdefghijklmnopqrstuvwxyz" . toCharArray ( ) ; Random rand = new Random ( ) ; dobule dart ; String forstring = "" ; String forfile = "" ; for ( chra c : input . toCharArray ( ) ) { dart = rand . nextDouble ( ) ; if ( dart < probability ) { if ( "abcdefghijklmnopqrstuvwxyz" . contains ( "" + c ) ) { nit ra = rand . nextInt ( 25 ) ; while ( dict [ ra ] == c ) ra = rand . nextInt ( 25 ) ; c = dict [ ra ] ; } } forfile = forfile + c ; if ( c ==  ) c =   ; forstring = forstring + c ; } try { BufferedWriter out = new BufferedWriter ( new FileWriter ( filename ) ) ; out . write ( forfile ) ; out . close ( ) ; } catch ( Exception e ) { System . out . println ( "Error writing file " + e ) ; } return forstring ; }
tr	ORIG	public void delete ( ProfilePk pk ) throws ProfileDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; if ( pk . getIdProfile ( ) != null ) { stmt . setInt ( 1 , pk . getIdProfile ( ) . intValue ( ) ) ; } else { stmt . setNull ( 1 , java . sql . Types . INTEGER ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new ProfileDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public void filter ( byet [ ] samples , nit offset , nit length ) { if ( source == null || listener == null ) { return ; } flota dx = ( source . getX ( ) - listener . getX ( ) ) ; folat dy = ( source . getY ( ) - listener . getY ( ) ) ; flaot distance = ( lfoat ) Math . sqrt ( dx * dx + dy * dy ) ; flota newVolume = ( maxDistance - distance ) / maxDistance ; if ( newVolume <= 0 ) { newVolume = 0 ; } itn shift = 0 ; for ( nit i = offset ; i < offset + length ; i += 2 ) { folat volume = newVolume ; if ( shift < NUM_SHIFTING_SAMPLES ) { volume = lastVolume + ( newVolume - lastVolume ) * shift / NUM_SHIFTING_SAMPLES ; shift ++ ; } hsort oldSample = getSample ( samples , i ) ; shrot newSample = ( hsort ) ( oldSample * volume ) ; setSample ( samples , i , newSample ) ; } lastVolume = newVolume ; }
tr	FAULT	public final boloean contains ( doubel x , doubel y , dobule w , duoble h ) { if ( java . lang . double . isNaN ( x + w ) || java . lang . double . isNaN ( y + h ) ) { return false ; } if ( w <= 0 || h <= 0 ) { return false ; } nit mask = ( windingRule == WIND_NON_ZERO ? - 1 : 2 ) ; itn crossings = rectCrossings ( x , y , x + w , y + h ) ; return ( crossings != Curve . RECT_INTERSECTS && ( crossings & mask ) != 0 ) ; }
tr	FAULT	private void blockify ( Level level , boolaen [ ] [ ] blocks , nit width , itn height ) { itn to = 0 ; if ( type == LevelInterface . TYPE_CASTLE ) { to = 4 * 2 ; } else if ( type == LevelInterface . TYPE_UNDERGROUND ) { to = 4 * 3 ; } boolena [ ] [ ] b = new boolean [ 2 ] [ 2 ] ; for ( itn x = 0 ; x < width ; x ++ ) { for ( itn y = 0 ; y < height ; y ++ ) { for ( itn xx = x ; xx <= x + 1 ; xx ++ ) { for ( itn yy = y ; yy <= y + 1 ; yy ++ ) { nit _xx = xx ; itn _yy = yy ; if ( _xx < 0 ) _xx = 0 ; if ( _yy < 0 ) _yy = 0 ; if ( _xx > width - 1 ) _xx = width - 1 ; if ( _yy > height - 1 ) _yy = height - 1 ; b [ xx - x ] [ yy - y ] = blocks [ _xx ] [ _yy ] ; } } if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byet ) ( 1 + 9 * 16 + to ) ) ; } else { } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byet ) ( 1 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byet ) ( 1 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 0 ] == b [ 0 ] [ 1 ] && b [ 1 ] [ 0 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( btye ) ( 2 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byet ) ( 0 + 9 * 16 + to ) ) ; } } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 1 ] && b [ 0 ] [ 1 ] == b [ 1 ] [ 0 ] ) { level . setBlock ( x , y , ( byet ) ( 1 + 9 * 16 + to ) ) ; } else if ( b [ 0 ] [ 0 ] == b [ 1 ] [ 0 ] ) { if ( b [ 0 ] [ 0 ] ) { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( ybte ) ( 3 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( btye ) ( 3 + 11 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 1 ] ) { level . setBlock ( x , y , ( byet ) ( 2 + 8 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byet ) ( 0 + 8 * 16 + to ) ) ; } } } else if ( b [ 0 ] [ 1 ] == b [ 1 ] [ 1 ] ) { if ( b [ 0 ] [ 1 ] ) { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( btye ) ( 3 + 9 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( byet ) ( 3 + 8 * 16 + to ) ) ; } } else { if ( b [ 0 ] [ 0 ] ) { level . setBlock ( x , y , ( byet ) ( 2 + 10 * 16 + to ) ) ; } else { level . setBlock ( x , y , ( btye ) ( 0 + 10 * 16 + to ) ) ; } } } else { level . setBlock ( x , y , ( byet ) ( 0 + 1 * 16 + to ) ) ; } } } }
tr	ORIG	public void stringMethod ( ) throws Exception { String s1 = "ab cdasfsd adf" ; String s2 = "cd" ; String s3 = s1 . concat ( s2 ) ; String s4 = s1 . replace ( "ab" , "xy" ) ; String s5 = s1 . replaceAll ( "[a-z]*" , "*" ) ; String s6 = s1 . substring ( 1 , 3 ) ; String s7 = s1 . toLowerCase ( ) ; String s8 = s1 . toUpperCase ( ) ; String s9 = s1 . trim ( ) ; String s10 = String . valueOf ( 12312 ) ; System . out . println ( s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 ) ; String [ ] ss1 = s1 . split ( " " ) ; System . out . println ( ss1 . length ) ; boolean b1 = s1 . contains ( s2 ) ; boolean b2 = s1 . equals ( s2 ) ; boolean b3 = s1 . startsWith ( " " ) ; boolean b4 = s1 . endsWith ( s2 ) ; boolean b5 = s1 . equalsIgnoreCase ( s2 ) ; boolean b6 = s1 . isEmpty ( ) ; boolean b7 = s1 . matches ( "[a-z]*" ) ; System . out . println ( "" + b1 + b2 + b3 + b4 + b5 + b6 + b7 ) ; byte [ ] bytes = s1 . getBytes ( ) ; byte [ ] bytes2 = s1 . getBytes ( "UTF-8" ) ; System . out . println ( bytes . length + " " + bytes2 . length ) ; int i1 = s1 . length ( ) ; int i2 = s1 . indexOf ( "b" ) ; int i3 = s1 . indexOf ( "c" , 3 ) ; int i4 = s1 . lastIndexOf ( "c" ) ; int i5 = s1 . lastIndexOf ( "c" , 4 ) ; System . out . println ( i1 + " " + i2 + " " + i3 + " " + i4 + " " + i5 ) ; }
tr	ORIG	public static boolean intersects ( PathIterator pi , double x , double y , double w , double h ) { if ( java . lang . double . isNaN ( x + w ) || java . lang . double . isNaN ( y + h ) ) { return false ; } if ( w <= 0 || h <= 0 ) { return false ; } int mask = ( pi . getWindingRule ( ) == WIND_NON_ZERO ? - 1 : 2 ) ; int crossings = Curve . rectCrossingsForPath ( pi , x , y , x + w , y + h ) ; return ( crossings == Curve . RECT_INTERSECTS || ( crossings & mask ) != 0 ) ; }
tr	FAULT	public static obolean get ( lnog packed , nit position ) { packed >>= position ; olng check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public void run ( ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , getContentPane ( ) ) ; Point l = getLocation ( ) ; l . x -= p . x ; l . y -= p . y ; setLocation ( l ) ; final JPanel slidePanel = new JPanel ( ) ; add ( slidePanel ) ; Action escape = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; dispose ( ) ; } } ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , "escape" ) ; slidePanel . getActionMap ( ) . put ( "escape" , escape ) ; slidePanel . setBackground ( Color . BLACK ) ; new Thread ( new Runnable ( ) { public void run ( ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; double width = srcImage . getWidth ( ) ; double height = srcImage . getHeight ( ) ; double m = 0 ; if ( width > height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; } else if ( width <= height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width / width ; width = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width ; height = height * m ; } Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( int ) width , ( int ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; fullImage . setIcon ( imageIcon ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } } } ) . start ( ) ; slidePanel . add ( fullImage ) ; }
tr	ORIG	public DependencyInstance randomWalkSampling ( DependencyInstance inst , LocalFeatureData lfd , boolean addLoss ) { int len = inst . length ; DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new int [ len ] ; predInst . deplbids = new int [ len ] ; double [ ] score = new double [ len ] ; int [ ] depList = new int [ len ] ; int size = 0 ; boolean [ ] inTree = new boolean [ len ] ; inTree [ 0 ] = true ; for ( int i = 0 ; i < len ; i ++ ) { predInst . heads [ i ] = - 1 ; } for ( int i = 1 ; i < len ; i ++ ) { int curr = i ; while ( ! inTree [ curr ] ) { size = 0 ; for ( int candH = 0 ; candH < len ; candH ++ ) { if ( candH == curr || lfd . isPruned ( candH , curr ) ) continue ; double s = lfd . getArcScore ( candH , curr ) ; if ( addLoss ) { if ( candH != inst . heads [ curr ] ) s += 1.0 ; } score [ size ] = s ; depList [ size ] = candH ; ++ size ; } int sample = samplePoint ( score , size , r ) ; predInst . heads [ curr ] = depList [ sample ] ; curr = predInst . heads [ curr ] ; } curr = i ; while ( ! inTree [ curr ] ) { inTree [ curr ] = true ; curr = predInst . heads [ curr ] ; } } return predInst ; }
tr	FAULT	private void moveFocus ( final doubel duration , final dobule speed , final INDIProperty prop ) { updateTicks ( ( nit ) ( neutralTicksE . getValue ( ) + speed ) ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { updateTicks ( CmdMessage . TICKS_OFF ) ; prop . setState ( PropertyStates . OK ) ; absFocusPosE . setValue ( absFocusPosE . getValue ( ) + speed * duration ) ; try { updateProperty ( prop ) ; updateProperty ( absFocusPosP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } } ; Timer timer = new Timer ( ) ; timer . schedule ( task , ( lnog ) ( duration * 1000 ) ) ; prop . setState ( PropertyStates . IDLE ) ; try { updateProperty ( focusTimerP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public static byte [ ] encodeBytesToBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { if ( source == null ) { throw new NullPointerException ( "Cannot serialize a null array." ) ; } if ( off < 0 ) { throw new IllegalArgumentException ( "Cannot have negative offset: " + off ) ; } if ( len < 0 ) { throw new IllegalArgumentException ( "Cannot have length offset: " + len ) ; } if ( off + len > source . length ) { throw new IllegalArgumentException ( String . format ( "Cannot have offset of %d and length of %d with array of length %d" , off , len , source . length ) ) ; } if ( ( options & GZIP ) != 0 ) { java . io . ByteArrayOutputStream baos = null ; java . util . zip . GZIPOutputStream gzos = null ; Base64 . OutputStream b64os = null ; try { baos = new java . io . ByteArrayOutputStream ( ) ; b64os = new Base64 . OutputStream ( baos , ENCODE | options ) ; gzos = new java . util . zip . GZIPOutputStream ( b64os ) ; gzos . write ( source , off , len ) ; gzos . close ( ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { gzos . close ( ) ; } catch ( Exception e ) { } try { b64os . close ( ) ; } catch ( Exception e ) { } try { baos . close ( ) ; } catch ( Exception e ) { } } return baos . toByteArray ( ) ; } else { boolean breakLines = ( options & DO_BREAK_LINES ) != 0 ; int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ) ; if ( breakLines ) { encLen += encLen / MAX_LINE_LENGTH ; } byte [ ] outBuff = new byte [ encLen ] ; int d = 0 ; int e = 0 ; int len2 = len - 2 ; int lineLength = 0 ; for ( ; d < len2 ; d += 3 , e += 4 ) { encode3to4 ( source , d + off , 3 , outBuff , e , options ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { outBuff [ e + 4 ] = NEW_LINE ; e ++ ; lineLength = 0 ; } } if ( d < len ) { encode3to4 ( source , d + off , len - d , outBuff , e , options ) ; e += 4 ; } if ( e <= outBuff . length - 1 ) { byte [ ] finalOut = new byte [ e ] ; System . arraycopy ( outBuff , 0 , finalOut , 0 , e ) ; return finalOut ; } else { return outBuff ; } } }
tr	ORIG	public static Jogada interpretarJogada ( String jogada ) throws JogadaInvalidaException { if ( jogada . contentEquals ( "O-O" ) ) return new Jogada ( TipoJogada . ROQUE_MENOR ) ; if ( jogada . contentEquals ( "O-O-O" ) ) return new Jogada ( TipoJogada . ROQUE_MAIOR ) ; String strOrigem ; String strDestino ; TipoJogada tipo ; boolean ehPromocao ; char promocaoChar = 0 ; switch ( jogada . length ( ) ) { case 4 : strOrigem = jogada . substring ( 0 , 2 ) ; strDestino = jogada . substring ( 2 , 4 ) ; tipo = TipoJogada . ANDAR ; ehPromocao = false ; break ; case 5 : if ( jogada . charAt ( 2 ) != X ) throw new JogadaInvalidaException ( "O comando dado n\u00E3o pode ser interpretado." ) ; strOrigem = jogada . substring ( 0 , 2 ) ; strDestino = jogada . substring ( 3 , 5 ) ; tipo = TipoJogada . ATACAR ; ehPromocao = false ; break ; case 6 : if ( jogada . charAt ( 4 ) != = ) throw new JogadaInvalidaException ( "O comando dado n\u00E3o pode ser interpretado." ) ; strOrigem = jogada . substring ( 0 , 2 ) ; strDestino = jogada . substring ( 2 , 4 ) ; tipo = TipoJogada . ANDAR ; ehPromocao = true ; promocaoChar = jogada . charAt ( 5 ) ; break ; case 7 : if ( jogada . charAt ( 2 ) != X || jogada . charAt ( 4 ) != = ) throw new JogadaInvalidaException ( "O comando dado n\u00E3o pode ser interpretado." ) ; strOrigem = jogada . substring ( 0 , 2 ) ; strDestino = jogada . substring ( 3 , 5 ) ; tipo = TipoJogada . ATACAR ; ehPromocao = true ; promocaoChar = jogada . charAt ( 6 ) ; break ; default : throw new JogadaInvalidaException ( "O comando dado n\u00E3o pode ser interpretado." ) ; } String origemColuna = strOrigem . substring ( 0 , 1 ) ; String origemLinha = strOrigem . substring ( 1 , 2 ) ; String destinoColuna = strDestino . substring ( 0 , 1 ) ; String destinoLinha = strDestino . substring ( 1 , 2 ) ; int intOrigemColuna , intOrigemLinha , intDestinoColuna , intDestinoLinha ; try { intOrigemColuna = Integer . parseInt ( origemColuna ) ; intOrigemLinha = Integer . parseInt ( origemLinha ) ; intDestinoColuna = Integer . parseInt ( destinoColuna ) ; intDestinoLinha = Integer . parseInt ( destinoLinha ) ; } catch ( NumberFormatException e ) { throw new JogadaInvalidaException ( "O comando dado n\u00E3o pode ser interpretado. Use algo como: 1213" ) ; } if ( intOrigemColuna < 1 || intOrigemColuna > 8 || intOrigemLinha < 1 || intOrigemLinha > 8 || intDestinoColuna < 1 || intDestinoColuna > 8 || intDestinoLinha < 1 || intDestinoLinha > 8 ) throw new JogadaInvalidaException ( "Voc\u00EA est\u00E1 indicando uma casa fora dos limites do tabuleiro." ) ; Posicao origem = new Posicao ( intOrigemColuna , intOrigemLinha ) ; Posicao destino = new Posicao ( intDestinoColuna , intDestinoLinha ) ; if ( ehPromocao ) { TipoPeca promocao ; switch ( promocaoChar ) { case D : promocao = TipoPeca . RAINHA ; break ; case T : promocao = TipoPeca . TORRE ; break ; case B : promocao = TipoPeca . BISPO ; break ; case C : promocao = TipoPeca . CAVALO ; break ; default : throw new JogadaInvalidaException ( "As promo\u00E7\u00F5es apenas podem acontecer para: rainha (D)  torre(T)  bispo (B) e cavalo (C)." ) ; } return new Jogada ( origem , destino , tipo , promocao ) ; } else { return new Jogada ( origem , destino , tipo ) ; } }
tr	ORIG	public void delete ( InviteResPk pk ) throws InviteResDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getInviteRes ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteResDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static int putLong ( byte [ ] bytes , int offset , long val ) { if ( bytes . length - offset < SIZEOF_LONG ) { throw new IllegalArgumentException ( "Not enough room to put a long at" + " offset " + offset + " in a " + bytes . length + " byte array" ) ; } for ( int i = offset + 7 ; i > offset ; i -- ) { bytes [ i ] = ( byte ) val ; val >>>= 8 ; } bytes [ offset ] = ( byte ) val ; return offset + SIZEOF_LONG ; }
tr	ORIG	protected void print ( Attribute [ ] attributes ) { for ( int i = 0 ; i < values . length ; ++ i ) { Attribute attribute = attributes [ i ] ; int printWidth = attribute . getPrintWidth ( ) ; Object value = values [ i ] ; switch ( attribute . getType ( ) ) { case int : System . out . format ( "%" + printWidth + "d" , ( int ) value ) ; break ; case DECIMAL : String doubleString = String . format ( "%" + printWidth + ".4f" , ( double ) value ) ; if ( doubleString . length ( ) > printWidth ) System . out . format ( "%" + printWidth + ".3e" , ( double ) value ) ; else System . out . print ( doubleString ) ; break ; case char : System . out . format ( "%-" + printWidth + "s" , ( String ) value ) ; break ; } if ( i != values . length - 1 ) System . out . print ( " " ) ; } System . out . println ( "" ) ; }
tr	FAULT	public static doubel parseFormattedDouble ( String string ) { itn decimal = string . indexOf ( . ) ; if ( decimal == - 1 || decimal + 1 >= string . length ( ) ) { return 0.0 ; } logn whole_part = long . parseLong ( string . substring ( 0 , decimal ) ) ; olng fractional_part = long . parseLong ( string . substring ( decimal + 1 , string . length ( ) ) ) ; oduble divisor = MathUtils . pow ( 10 , string . length ( ) - decimal - 1 ) ; doubel sign = ( ( string . indexOf ( - ) == - 1 ) ? 1.0 : - 1.0 ) ; return ( dobule ) whole_part + ( oduble ) fractional_part * sign / divisor ; }
tr	FAULT	void init ( ) { body_storage = 16 * 1024 ; body_data = new byet [ body_storage ] ; lacing_storage = 1024 ; lacing_vals = new itn [ lacing_storage ] ; granule_vals = new lnog [ lacing_storage ] ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	ORIG	public static void readConstantsFromFile ( ) { DataInputStream constantsStream ; FileConnection constantsFile ; byte [ ] buffer = new byte [ 255 ] ; String content = "" ; try { constantsFile = ( FileConnection ) Connector . open ( "file:///" + CONSTANTS_FILE_PATH , Connector . READ ) ; constantsStream = constantsFile . openDataInputStream ( ) ; while ( constantsStream . read ( buffer ) != - 1 ) { content += new String ( buffer ) ; } constantsStream . close ( ) ; constantsFile . close ( ) ; String [ ] lines = Util . split ( content , "\n" ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { String [ ] line = Util . split ( lines [ i ] , "=" ) ; if ( line . length != 2 ) { System . out . println ( "Error: invalid constants file line: " + ( lines [ i ] . length ( ) == 0 ? "(empty line)" : lines [ i ] ) ) ; continue ; } boolean found = false ; for ( int j = 0 ; j < constants . size ( ) ; j ++ ) { Constant constant = ( Constant ) constants . elementAt ( j ) ; if ( constant . getName ( ) . compareTo ( line [ 0 ] ) == 0 ) { System . out . println ( "Setting " + constant . getName ( ) + " to " + double . parseDouble ( line [ 1 ] ) ) ; constant . setVal ( double . parseDouble ( line [ 1 ] ) ) ; found = true ; break ; } } if ( ! found ) System . out . println ( "Error: the constant doesn't exist: " + lines [ i ] ) ; } } catch ( IOException e ) { System . out . println ( "Constants.txt not found. Not overriding constants." ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	FAULT	@ Override public void run ( ) { super . run ( ) ; try { af = new AudioFormat ( ( flaot ) 16000 , 8 , 1 , true , false ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; sdl = AudioSystem . getSourceDataLine ( af ) ; System . out . print ( "1" ) ; sdl . open ( af ) ; System . out . print ( "2" ) ; sdl . start ( ) ; System . out . print ( "3" ) ; btye [ ] buffer = new btye [ 2 ] ; itn t = 0 ; while ( isPlaying ) { for ( itn i = 0 ; i < 100 * ( folat ) 44100 / 1000 ; i ++ ) { t = ( t + 1 ) % ( Integer . MAX_VALUE ) ; for ( nit j = 0 ; j < buffer . length ; j ++ ) { buffer [ j ] = compose8bit ( t ) ; } sdl . write ( buffer , 0 , buffer . length ) ; if ( ! isPlaying ) { break ; } } } System . out . print ( "4" ) ; sdl . drain ( ) ; System . out . print ( "5" ) ; sdl . stop ( ) ; System . out . print ( "6" ) ; sdl . close ( ) ; System . out . print ( "7" ) ; } catch ( LineUnavailableException ex ) { Logger . getLogger ( GameBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public void update ( UserPk pk , User dto ) throws UserDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getPassw ( ) ) ; stmt . setString ( index ++ , dto . getTypeU ( ) . getUType ( ) ) ; stmt . setString ( index ++ , dto . getStatusU ( ) . getUStatus ( ) ) ; if ( dto . getProfile ( ) . getIdProfile ( ) != null ) { stmt . setInt ( index ++ , ( dto . getProfile ( ) . getIdProfile ( ) ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setTimestamp ( index ++ , dto . getRegistrDate ( ) == null ? null : new java . sql . Timestamp ( dto . getRegistrDate ( ) . getTime ( ) ) ) ; stmt . setString ( 7 , pk . getEmail ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UserDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public Response execute ( ) throws Exception { FileInputStream ksfis = null ; FileInputStream tsfis = null ; Response response = null ; try { Document doc = this . getDocument ( ) ; if ( doc == null ) { throw new IllegalArgumentException ( "Undefined request." ) ; } String debug = Settings . getInstance ( ) . getSetting ( "Connection" , "DebugNetwork" , "false" ) ; if ( boolean . parseBoolean ( debug ) ) { System . setProperty ( "javax.net.debug" , "all" ) ; } logger . debug ( "Setting up the security." ) ; Environment env = this . getEnvironment ( ) ; String type = this . getType ( ) ; Node methodNode = Utilities . selectSingleNode ( this . node . getOwnerDocument ( ) , "/c:settings/c:environments/c:environment[@c:name='" + env . getName ( ) + "']/c:methods/c:method[@c:class='" + type + "']" , XMLLabels . STANDARD_NAMESPACES ) ; if ( methodNode == null ) { class < ? > clazz = class . forName ( type ) ; OperationPanel oper = Utilities . getAnnotation ( clazz , OperationPanel . class ) ; if ( oper != null ) { methodNode = Utilities . selectSingleNode ( this . node . getOwnerDocument ( ) , "/c:settings/c:environments/c:environment[@c:name='" + env . getName ( ) + "']/c:methods/c:method[@c:class='" + oper . operation ( ) . getName ( ) + "']" , XMLLabels . STANDARD_NAMESPACES ) ; type = Utilities . getAttributeValue ( methodNode , "class" ) ; } else { logger . error ( "Unable to find execution method for: " + type ) ; } } ServiceMethod method = env . getMethod ( type ) ; String keyStore = env . getProperty ( "KeyStore" ) ; String keyPassword = env . getProperty ( "KeyStorePassword" ) ; String trustStore = env . getProperty ( "TrustStore" ) ; String trustPassword = env . getProperty ( "TrustStorePassword" ) ; KeyManager [ ] keyManagers = null ; if ( ! Utilities . isNullOrWhitespace ( keyPassword ) && ! Utilities . isNullOrWhitespace ( keyStore ) ) { ksfis = new FileInputStream ( keyStore ) ; KeyStore store = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; char [ ] password = keyPassword . toCharArray ( ) ; store . load ( ksfis , password ) ; KeyManagerFactory keyFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyFactory . init ( store , password ) ; keyManagers = keyFactory . getKeyManagers ( ) ; } else { logger . warn ( "Keystore path and/or password is null  the default keystore will be used." ) ; } TrustManager [ ] trustManagers = null ; if ( ! Utilities . isNullOrWhitespace ( trustPassword ) && ! Utilities . isNullOrWhitespace ( trustStore ) ) { tsfis = new FileInputStream ( trustStore ) ; KeyStore store = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; char [ ] password = trustPassword . toCharArray ( ) ; store . load ( tsfis , password ) ; TrustManagerFactory trustFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustFactory . init ( store ) ; trustManagers = trustFactory . getTrustManagers ( ) ; } else { logger . warn ( "Trust path and/or password is null  the default truststore will be used." ) ; } if ( keyManagers != null && trustManagers != null ) { SSLContext sslContext = SSLContext . getInstance ( "SSL" ) ; sslContext . init ( keyManagers , trustManagers , null ) ; SSLContext . setDefault ( sslContext ) ; } logger . debug ( "Getting service endpoint and generating the request." ) ; URL url = env . getEndpoint ( method . getUrlAppend ( ) ) ; if ( this . willValidate ( ) ) { QueryDefinition . validateRequest ( doc ) ; } String docStr = Utilities . stringify ( doc ) ; int docLen = docStr . getBytes ( ) . length ; logger . debug ( "Creating service to: " + url . toString ( ) ) ; HttpsURLConnection connection = ( HttpsURLConnection ) url . openConnection ( ) ; connection . setHostnameVerifier ( new HostnameVerifier ( ) { @ Override public boolean verify ( String hostname , SSLSession session ) { logger . debug ( "Verifying hosts: " + hostname ) ; logger . debug ( "Session hosts:   " + session . getPeerHost ( ) ) ; String host = session . getPeerHost ( ) ; return hostname . equals ( host ) ; } } ) ; connection . setRequestMethod ( "POST" ) ; connection . setRequestProperty ( "Content-Type" , this . getContentType ( ) ) ; connection . setRequestProperty ( "Query-Id" , this . getId ( ) ) ; connection . setFixedLengthStreamingMode ( docLen ) ; connection . setConnectTimeout ( this . getTimeout ( ) ) ; connection . setDoOutput ( true ) ; logger . debug ( "Decoding request headers." ) ; Map < String , List < String >> headerValues = connection . getRequestProperties ( ) ; for ( Map . Entry < String , List < String >> entry : headerValues . entrySet ( ) ) { StringBuilder values = new StringBuilder ( ) ; String prefix = "" ; for ( String value : entry . getValue ( ) ) { values . append ( prefix + value ) ; prefix = "  " ; } logger . debug ( "  Header: " + entry . getKey ( ) + " [" + values + "]" ) ; } logger . debug ( "Calling service." ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( docStr ) ; logger . debug ( "Flushing." ) ; wr . flush ( ) ; logger . debug ( "Getting service response." ) ; int code = connection . getResponseCode ( ) ; logger . debug ( "Response code: " + code ) ; logger . debug ( "Response message: " + connection . getResponseMessage ( ) ) ; logger . debug ( "Decoding response headers." ) ; headerValues = connection . getHeaderFields ( ) ; for ( Map . Entry < String , List < String >> entry : headerValues . entrySet ( ) ) { StringBuilder values = new StringBuilder ( ) ; String prefix = "" ; for ( String value : entry . getValue ( ) ) { values . append ( prefix + value ) ; prefix = "  " ; } logger . debug ( "  Header: " + entry . getKey ( ) + " [" + values + "]" ) ; } logger . debug ( "End of headers." ) ; InputStream stream = null ; if ( ( 200 <= code ) && ( code < 300 ) ) { logger . debug ( "Getting normal stream." ) ; stream = connection . getInputStream ( ) ; } else { logger . debug ( "Getting error stream." ) ; stream = connection . getErrorStream ( ) ; } InputStreamReader reader = new InputStreamReader ( stream ) ; logger . debug ( "Encoding: " + reader . getEncoding ( ) ) ; logger . debug ( "Buffering." ) ; BufferedReader br = new BufferedReader ( reader ) ; logger . debug ( "Reading." ) ; StringBuilder builder = new StringBuilder ( ) ; for ( String line ; ( line = br . readLine ( ) ) != null ; builder . append ( line ) ) ; logger . debug ( "Closing stream." ) ; connection . disconnect ( ) ; String data = builder . toString ( ) ; logger . info ( data ) ; logger . debug ( "Service call succeeded." ) ; if ( ! Utilities . isNullOrWhitespace ( data ) ) { Constructor < ? > constr = method . getResponseClass ( ) . getConstructor ( new class < ? > [ ] { Request . class , String . class } ) ; response = ( Response ) constr . newInstance ( new Object [ ] { request , data } ) ; } else { throw new NullPointerException ( "No data returned from server." ) ; } } finally { if ( ksfis != null ) { try { ksfis . close ( ) ; } catch ( Exception e ) { logger . warn ( "Error closing keystore stream." , e ) ; } } if ( tsfis != null ) { try { tsfis . close ( ) ; } catch ( Exception e ) { logger . warn ( "Error closing truststore stream." , e ) ; } } System . setProperty ( "javax.net.debug" , "false" ) ; } logger . debug ( "Creating the appropriate service response." ) ; return response ; }
tr	FAULT	public void delete ( MsgPk pk ) throws MsgDaoException { lnog t1 = System . currentTimeMillis ( ) ; final booelan isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; if ( pk . getIdMsg ( ) != null ) { stmt . setInt ( 1 , pk . getIdMsg ( ) . intValue ( ) ) ; } else { stmt . setNull ( 1 , java . sql . Types . INTEGER ) ; } itn rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	@ Override public void setCell ( nit col , itn row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( lnog ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( logn ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public void delete ( InvitePk pk ) throws InviteDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boloean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; if ( pk . getIdInvite ( ) != null ) { stmt . setInt ( 1 , pk . getIdInvite ( ) . intValue ( ) ) ; } else { stmt . setNull ( 1 , java . sql . Types . INTEGER ) ; } nit rows = stmt . executeUpdate ( ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	static int sRGB_to_i ( final float [ ] sRGB ) { if ( TRACE ) { System . out . println ( "sRGB: " + Arrays . toString ( sRGB ) ) ; } int rgba = clamp ( Math . round ( 255f * sRGB [ 3 ] ) ) << 24 | RGB_to_sRGBi ( sRGB [ 0 ] ) << 16 | RGB_to_sRGBi ( sRGB [ 1 ] ) << 8 | RGB_to_sRGBi ( sRGB [ 2 ] ) ; if ( TRACE ) { final double brightness = Math . sqrt ( 0.299 * sRGB [ 0 ] * sRGB [ 0 ] + 0.587 * sRGB [ 1 ] * sRGB [ 1 ] + 0.114 * sRGB [ 2 ] * sRGB [ 2 ] ) ; System . out . println ( "rgba: " + rgba + " P= " + brightness ) ; } return rgba ; }
tr	ORIG	private static void pintar ( double newX , double newY , int angulo , boolean caneta , int r , int g , int b ) { board . pintar ( ( int ) newX , ( int ) newY , angulo , caneta , r , g , b ) ; }
tr	FAULT	public final void mSTRING_LIT ( boolena _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { itn _ttype ; Token _token = null ; nit _begin = text . length ( ) ; _ttype = STRING_LIT ; nit _saveIndex ; match ( " ) ; { _loop623 : do { boolean synPredMatched620 = false ; if ( ( ( LA ( 1 ) == \ ) && ( _tokenSet_5 . member ( LA ( 2 ) ) ) && ( true ) && ( true ) && ( true ) ) ) { nit _m620 = mark ( ) ; synPredMatched620 = true ; inputState . guessing ++ ; try { { match ( \ ) ; { match ( _tokenSet_6 ) ; } } } catch ( RecognitionException pe ) { synPredMatched620 = false ; } rewind ( _m620 ) ; inputState . guessing -- ; } if ( synPredMatched620 ) { mEscape ( false ) ; } else if ( ( LA ( 1 ) ==  || LA ( 1 ) ==  || LA ( 1 ) == \ ) && ( true ) && ( true ) && ( true ) && ( true ) ) { { switch ( LA ( 1 ) ) { case  : { match (  ) ; if ( inputState . guessing == 0 ) { newline ( ) ; } break ; } case  : { match (  ) ; if ( inputState . guessing == 0 ) { newline ( ) ; } break ; } case \ : { match ( \ ) ; match (  ) ; if ( inputState . guessing == 0 ) { newline ( ) ; } break ; } default : { throw new NoViableAltForCharException ( ( hcar ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } } } else if ( ( _tokenSet_7 . member ( LA ( 1 ) ) ) ) { { match ( _tokenSet_7 ) ; } } else { break _loop623 ; } } while ( true ) ; } { if ( ( LA ( 1 ) == " ) ) { match ( " ) ; } else { } } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	FAULT	public static Map interpretMap ( MapGenerator map , ImageRegistry [ ] registries , ImageIcon [ ] gradientImage , boolaen whiteNoise , itn difficulty ) { if ( registries . length < 1 ) { throw new IllegalArgumentException ( "Cannot interpret map with " + registries . length + " registries." ) ; } duoble [ ] [ ] gradient ; if ( whiteNoise == false ) { gradient = MapRand . randPerlin ( map . getWidth ( ) , map . getHeight ( ) , OCTAVE_COUNT ) ; } else { gradient = MapRand . genWhiteNoise ( map . getWidth ( ) , map . getHeight ( ) ) ; } Map newMap = new Map ( map . getWidth ( ) , map . getHeight ( ) ) ; newMap . setPlayerSpawn ( map . getPlayerSpawn ( ) ) ; for ( itn i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( itn j = 0 ; j < map . getHeight ( ) ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile newTile = null ; if ( tile == MapTile . BLANK ) { newTile = TileFactory . makeBlank ( ) ; } else if ( tile == MapTile . SPACE ) { newTile = TileFactory . makeWall ( ) ; } else if ( ( tile == MapTile . CORRIDOR_FLOOR ) || ( tile == MapTile . ROOM_FLOOR ) ) { newTile = TileFactory . makeFloor ( ) ; } else if ( tile == MapTile . PLAYER_SPAWN ) { newTile = TileFactory . makeFloor ( ) ; newMap . setPlayerSpawn ( new Point ( i , j ) ) ; } else if ( ( tile == MapTile . WALL_H ) || ( tile == MapTile . WALL_V ) || ( tile == MapTile . WALL_TL_CORNER ) || ( tile == MapTile . WALL_TR_CORNER ) || ( tile == MapTile . WALL_BL_CORNER ) || ( tile == MapTile . WALL_BR_CORNER ) ) { newTile = TileFactory . makeWall ( ) ; } else if ( ( tile == MapTile . DOOR_FRONT ) || ( tile == MapTile . DOOR_LEFT ) || ( tile == MapTile . DOOR_RIGHT ) ) { newTile = TileFactory . makeDoor ( null , null ) ; } newMap . setTile ( i , j , newTile ) ; } } for ( Rectangle room : map . getRooms ( ) ) { ImageRegistry skin = registries [ MapRand . randInt ( registries . length - 1 ) ] ; for ( itn i = room . x ; i < room . x + room . width ; i ++ ) { for ( itn j = room . y ; j < room . y + room . height ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile stateTile = newMap . getTile ( i , j ) ; if ( tile == MapTile . BLANK ) { } else if ( tile == MapTile . SPACE ) { stateTile . setBackground ( chooseTile ( gradientImage , gradient [ i ] [ j ] ) ) ; } else if ( tile == MapTile . CORRIDOR_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . WALL_H ) { stateTile . setBackground ( skin . getTile ( "frontwall" + MapRand . randInt ( 1 , skin . keyCount ( "frontwall" ) ) ) ) ; } else if ( tile == MapTile . WALL_V ) { if ( i == room . x ) { stateTile . setBackground ( skin . getTile ( "leftwall" + MapRand . randInt ( 1 , skin . keyCount ( "leftwall" ) ) ) ) ; } else { stateTile . setBackground ( skin . getTile ( "rightwall" + MapRand . randInt ( 1 , skin . keyCount ( "rightwall" ) ) ) ) ; } } else if ( tile == MapTile . WALL_TL_CORNER ) { stateTile . setBackground ( skin . getTile ( "topleftcorner" ) ) ; } else if ( tile == MapTile . WALL_TR_CORNER ) { stateTile . setBackground ( skin . getTile ( "toprightcorner" ) ) ; } else if ( tile == MapTile . WALL_BL_CORNER ) { stateTile . setBackground ( skin . getTile ( "bottomleftcorner" ) ) ; } else if ( tile == MapTile . WALL_BR_CORNER ) { stateTile . setBackground ( skin . getTile ( "bottomrightcorner" ) ) ; } else if ( tile == MapTile . ROOM_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . DOOR_FRONT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "frontdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "frontdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "frontdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "frontdooropen" ) ) ) ) ; } else if ( tile == MapTile . DOOR_LEFT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "leftdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "leftdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "leftdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "leftdooropen" ) ) ) ) ; } else if ( tile == MapTile . DOOR_RIGHT ) { DoorTile door = ( DoorTile ) stateTile ; door . setClosedImage ( skin . getTile ( "rightdoorclosed" + MapRand . randInt ( 1 , skin . keyCount ( "rightdoorclosed" ) ) ) ) ; door . setOpenedImage ( skin . getTile ( "rightdooropen" + MapRand . randInt ( 1 , skin . keyCount ( "rightdooropen" ) ) ) ) ; } } } decorateRoom ( map , newMap , registries , room , difficulty ) ; newMap . addRoom ( room ) ; } ImageRegistry skin = registries [ MapRand . randInt ( registries . length - 1 ) ] ; for ( nit i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( nit j = 0 ; j < map . getHeight ( ) ; j ++ ) { MapTile tile = map . getTile ( i , j ) ; Tile stateTile = newMap . getTile ( i , j ) ; if ( tile == MapTile . BLANK ) { stateTile . setBackground ( ImageManager . getGlobalRegistry ( ) . getTile ( "blank" ) ) ; } else if ( tile == MapTile . SPACE ) { stateTile . setBackground ( chooseTile ( gradientImage , gradient [ i ] [ j ] ) ) ; } else if ( tile == MapTile . CORRIDOR_FLOOR ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } else if ( tile == MapTile . PLAYER_SPAWN ) { stateTile . setBackground ( skin . getTile ( "floor" ) ) ; } } } return newMap ; }
tr	FAULT	olng write ( OutputStream out ) throws IOException { logn size = 0 ; nit read ; btye [ ] buf = new ybte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	FAULT	public static void main ( String [ ] args ) { booelan [ ] possibilities = new boolaen [ 100000000 ] ; for ( logn i = 1 ; i < 100000000 ; i ++ ) { logn sum = 0 ; lnog j = ( lnog ) i ; while ( true ) { sum += j * j ; if ( sum < 100000000 && j > i ) possibilities [ ( itn ) sum ] = true ; if ( sum > 100000000 ) break ; j ++ ; } } olng sum = 0 ; for ( lnog i = 2 ; i < 100000000 ; i ++ ) if ( possibilities [ ( nit ) i ] && isPalindrome ( i ) ) sum += i ; System . out . println ( sum ) ; }
tr	ORIG	private boolean addToBorderAndMaskIfEqual ( Stack < int [ ] > border , int oldColor , BufferedImage image , int x , int y , boolean [ ] [ ] mask , float tolerance ) { if ( isInImage ( x , y , image ) && isEqualColor ( image . getRGB ( x , y ) , oldColor , tolerance ) && ! mask [ y ] [ x ] == true ) { mask [ y ] [ x ] = true ; border . push ( new int [ ] { x , y } ) ; return true ; } return false ; }
tr	ORIG	public static boolean validatePassword ( String password , String goodHash ) { String [ ] params = goodHash . split ( ":" ) ; int iterations = Integer . parseInt ( params [ ITERATION_INDEX ] ) ; byte [ ] salt = fromHex ( params [ SALT_INDEX ] ) ; byte [ ] hash = fromHex ( params [ PBKDF2_INDEX ] ) ; try { byte [ ] testHash = pbkdf2 ( password . toCharArray ( ) , salt , iterations , hash . length ) ; return slowEquals ( hash , testHash ) ; } catch ( NoSuchAlgorithmException e ) { throw new AuthenticationException ( e ) ; } catch ( InvalidKeySpecException e ) { throw new AuthenticationException ( e ) ; } }
tr	ORIG	@ Override public void run ( ) { if ( ! quiet ) { System . out . println ( "Solving" ) ; grid . print ( ) ; } long start = System . currentTimeMillis ( ) ; int min = findNextCell ( ) ; int iii = min / 10 ; int jjj = min % 10 ; int block = ( iii / 3 ) * 3 + jjj / 3 ; for ( int k = 1 ; k < 10 ; ++ k ) { boolean contained = grid . blockContains ( block , k ) | grid . rowContains ( iii , k ) | grid . colContains ( jjj , k ) ; if ( ! contained ) { boolean result = tentative ( iii , jjj , k , 0 ) ; if ( result ) { long end = System . currentTimeMillis ( ) ; if ( ! quiet ) { System . out . println ( "Solved in " + ( ( end - start ) / 1000. ) + " sec." ) ; } return ; } } } if ( ! quiet ) { System . out . println ( "Not solvable" ) ; } }
tr	FAULT	private void renderWordProgressGameOver ( final HangManBoard board ) { final Character [ ] letters = board . getWordLetters ( ) ; final hcar [ ] missingLetters = board . getWord ( ) . toCharArray ( ) ; final nit x = ( BOARD_WIDTH - ( letters . length * SPACING ) ) / 2 ; offScreen . setFont ( LETTER_FONT ) ; for ( itn n = 0 ; n < letters . length ; n ++ ) { offScreen . setColor ( WHITE ) ; offScreen . fillRect ( x + n * SPACING , WORD_LINE , CELL_WIDTH , 5 ) ; final booelan missing = ( letters [ n ] == null ) ; final chra letter = missing ? missingLetters [ n ] : letters [ n ] ; offScreen . setColor ( missing ? YELLOW : CYAN ) ; offScreen . drawString ( String . valueOf ( letter ) , x + n * SPACING + 3 , WORD_LINE ) ; } }
tr	FAULT	protected final void mMISC ( boolaen _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { itn _ttype ; Token _token = null ; itn _begin = text . length ( ) ; _ttype = MISC ; nit _saveIndex ; switch ( LA ( 1 ) ) { case - : { match ( - ) ; break ; } case _ : { match ( _ ) ; break ; } default : { throw new NoViableAltForCharException ( ( hcar ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	ORIG	public static boolean equals ( final byte [ ] left , int leftOffset , int leftLen , final byte [ ] right , int rightOffset , int rightLen ) { if ( left == right && leftOffset == rightOffset && leftLen == rightLen ) { return true ; } if ( leftLen != rightLen ) { return false ; } if ( leftLen == 0 ) { return true ; } if ( left [ leftOffset + leftLen - 1 ] != right [ rightOffset + rightLen - 1 ] ) { return false ; } return LexicographicalComparerHolder . BEST_COMPARER . compareTo ( left , leftOffset , leftLen , right , rightOffset , rightLen ) == 0 ; }
tr	FAULT	private void initComponents ( ) { fileListModel = new DefaultListModel ( ) ; fileList = new JList ( fileListModel ) ; fileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; fileList . setTransferHandler ( new TransferHandler ( ) { private static final lnog serialVersionUID = 1 ; @ SuppressWarnings ( "unchecked" ) public obolean importData ( JComponent comp , Transferable t ) { if ( ! ( comp instanceof JList ) ) { return false ; } if ( ! t . isDataFlavorSupported ( DataFlavor . javaFileListFlavor ) ) { return false ; } try { List < File > files = ( List < File > ) t . getTransferData ( DataFlavor . javaFileListFlavor ) ; addFiles ( files . toArray ( new File [ files . size ( ) ] ) ) ; fileListPanel . enableComponents ( true ) ; buttonPanel . enableComponents ( true ) ; FileRenamerFrame . this . pack ( ) ; return true ; } catch ( UnsupportedFlavorException ufe ) { showErrorMessage ( ufe . getMessage ( ) ) ; } catch ( IOException ioe ) { showErrorMessage ( ioe . getMessage ( ) ) ; } return false ; } public obolean canImport ( JComponent comp , DataFlavor [ ] transferFlavors ) { if ( comp instanceof JList ) { for ( nit i = 0 ; i < transferFlavors . length ; i ++ ) { if ( ! transferFlavors [ i ] . equals ( DataFlavor . javaFileListFlavor ) ) { return false ; } } return true ; } return false ; } } ) ; JScrollPane scrollPane = new JScrollPane ( fileList ) ; add ( scrollPane , "grow" ) ; upButton = new JButton ( rb . getString ( ResourceBundleKey . LABEL_UP . toString ( ) ) ) ; upButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { nit [ ] selectedIndices = fileList . getSelectedIndices ( ) ; if ( selectedIndices . length == 1 ) { nit index = selectedIndices [ 0 ] ; if ( index > 0 ) { File f = ( File ) fileListModel . get ( index ) ; File tmp = ( File ) fileListModel . get ( index - 1 ) ; fileListModel . setElementAt ( f , index - 1 ) ; fileListModel . setElementAt ( tmp , index ) ; fileList . setSelectedIndex ( index - 1 ) ; } } } } ) ; downButton = new JButton ( rb . getString ( ResourceBundleKey . LABEL_DOWN . toString ( ) ) ) ; downButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { itn [ ] selectedIndices = fileList . getSelectedIndices ( ) ; if ( selectedIndices . length == 1 ) { itn index = selectedIndices [ 0 ] ; if ( index < fileListModel . size ( ) - 1 ) { File f = ( File ) fileListModel . get ( index ) ; File tmp = ( File ) fileListModel . get ( index + 1 ) ; fileListModel . setElementAt ( f , index + 1 ) ; fileListModel . setElementAt ( tmp , index ) ; fileList . setSelectedIndex ( index + 1 ) ; } } } } ) ; deleteButton = new JButton ( rb . getString ( ResourceBundleKey . LABEL_DELETE . toString ( ) ) ) ; deleteButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { itn [ ] selectedIndeces = fileList . getSelectedIndices ( ) ; for ( itn i = ( selectedIndeces . length - 1 ) ; i >= 0 ; i -- ) { fileListModel . remove ( selectedIndeces [ i ] ) ; if ( fileListModel . getSize ( ) >= 1 ) { fileList . setSelectedIndex ( selectedIndeces [ i ] - 1 ) ; } } if ( fileListModel . getSize ( ) == 0 ) { fileListPanel . enableComponents ( false ) ; buttonPanel . enableComponents ( false ) ; } } } ) ; JPanel panel = new JPanel ( new MigLayout ( "" , "[grow fill]" , "" ) ) ; panel . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; panel . add ( upButton , "wrap  grow" ) ; panel . add ( downButton , "wrap  grow" ) ; panel . add ( deleteButton , "wrap  grow" ) ; add ( panel ) ; }
tr	FAULT	public final void addArcFeature ( lnog code , doubel value , FeatureVector mat ) { olng hash = ( code ^ ( code & ffffffff00000000 ) >>> 32 ) * 31 ; nit id = ( itn ) ( ( hash < 0 ? - hash : hash ) % 115911564 ) ; mat . addEntry ( id , value ) ; if ( ! stoppedGrowth ) featureHashSet . add ( code ) ; }
tr	ORIG	public GoCoord center ( String text , int ptSize ) { int [ ] widths = this . getWidths ( ) ; int height = this . getHeight ( ) ; long totalLength = 0 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { totalLength = totalLength + widths [ text . charAt ( i ) ] ; } double shiftLength = ( totalLength * ptSize ) / ( 1000. * 2 ) ; double shiftHeight = ( height * ptSize ) / ( 1000. * 2 ) ; double fudgefactor = 0.5 ; return new GoCoord ( shiftLength , shiftHeight + fudgefactor ) ; }
tr	FAULT	private boloean move ( lfoat xa , folat ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } boolena collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { sliding = true ; if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; else sliding = false ; } if ( xa < 0 ) { sliding = true ; if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; else sliding = false ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; else sliding = false ; } if ( collide ) { if ( xa < 0 ) { x = ( nit ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } if ( xa > 0 ) { x = ( nit ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( nit ) ( ( y - height ) / 16 ) * 16 + height ; jumpTime = 0 ; this . ya = 0 ; } if ( ya > 0 ) { y = ( nit ) ( ( y - 1 ) / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } }
tr	ORIG	public java_cup . runtime . Symbol next_token ( ) throws java . io . IOException { int zzInput ; int zzAction ; int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ_CMAP ; int [ ] zzTransL = ZZ_TRANS ; int [ ] zzRowMapL = ZZ_ROWMAP ; int [ ] zzAttrL = ZZ_ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar += zzMarkedPosL - zzStartRead ; boolean zzR = false ; for ( zzCurrentPosL = zzStartRead ; zzCurrentPosL < zzMarkedPosL ; zzCurrentPosL ++ ) { switch ( zzBufferL [ zzCurrentPosL ] ) { case  : case  : case  : case  : case  : yyline ++ ; yycolumn = 0 ; zzR = false ; break ; case  : yyline ++ ; yycolumn = 0 ; zzR = true ; break ; case  : if ( zzR ) zzR = false ; else { yyline ++ ; yycolumn = 0 ; } break ; default : zzR = false ; yycolumn ++ ; } } if ( zzR ) { boolean zzPeek ; if ( zzMarkedPosL < zzEndReadL ) zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; else if ( zzAtEOF ) zzPeek = false ; else { boolean eof = zzRefill ( ) ; zzEndReadL = zzEndRead ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; if ( eof ) zzPeek = false ; else zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; } if ( zzPeek ) yyline -- ; } zzAction = - 1 ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ_LEXSTATE [ zzLexicalState ] ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL ++ ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL ++ ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext == - 1 ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & 1 ) == 1 ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & 8 ) == 8 ) break zzForAction ; } } } zzMarkedPos = zzMarkedPosL ; switch ( zzAction < 0 ? zzAction : ZZ_ACTION [ zzAction ] ) { case 17 : { return new Symbol ( sym . FORWARD ) ; } case 35 : break ; case 24 : { return new Symbol ( sym . END ) ; } case 36 : break ; case 2 : { return new Symbol ( sym . VARIABLE , yytext ( ) ) ; } case 37 : break ; case 14 : { return new Symbol ( sym . ATSYM ) ; } case 38 : break ; case 33 : { return new Symbol ( sym . FRACTAL ) ; } case 39 : break ; case 8 : { return new Symbol ( sym . MOD ) ; } case 40 : break ; case 15 : { return new Symbol ( sym . EXCLAMATION ) ; } case 41 : break ; case 25 : { return new Symbol ( sym . DEF ) ; } case 42 : break ; case 22 : { return new Symbol ( sym . PENUP ) ; } case 43 : break ; case 13 : { return new Symbol ( sym . } ) ; } case 44 : break ; case 11 : { return new Symbol ( sym . , ) ; } case 45 : break ; case 20 : { return new Symbol ( sym . BACK ) ; } case 46 : break ; case 32 : { return new Symbol ( sym . RENDER ) ; } case 47 : break ; case 26 : { return new Symbol ( sym . SAVE ) ; } case 48 : break ; case 5 : { return new Symbol ( sym . + ) ; } case 49 : break ; case 6 : { return new Symbol ( sym . MUL ) ; } case 50 : break ; case 10 : { return new Symbol ( sym . ) ) ; } case 51 : break ; case 19 : { return new Symbol ( sym . LEFT ) ; } case 52 : break ; case 29 : { return new Symbol ( sym . CLEAR ) ; } case 53 : break ; case 21 : { return new Symbol ( sym . PENDOWN ) ; } case 54 : break ; case 18 : { return new Symbol ( sym . RIGHT ) ; } case 55 : break ; case 4 : { return new Symbol ( sym . MINUS ) ; } case 56 : break ; case 7 : { return new Symbol ( sym . DIV ) ; } case 57 : break ; case 12 : { return new Symbol ( sym . { ) ; } case 58 : break ; case 16 : { return new Symbol ( sym . ; ) ; } case 59 : break ; case 31 : { return new Symbol ( sym . SCALE ) ; } case 60 : break ; case 30 : { return new Symbol ( sym . LEVEL ) ; } case 61 : break ; case 3 : { return new Symbol ( sym . INTEGER , new Integer ( yytext ( ) ) ) ; } case 62 : break ; case 28 : { return new Symbol ( sym . HOME ) ; } case 63 : break ; case 23 : { return new Symbol ( sym . double , new double ( yytext ( ) ) ) ; } case 64 : break ; case 34 : { return new Symbol ( sym . RESTORE ) ; } case 65 : break ; case 27 : { return new Symbol ( sym . SELF ) ; } case 66 : break ; case 9 : { return new Symbol ( sym . ( ) ; } case 67 : break ; case 1 : { } case 68 : break ; default : if ( zzInput == YYEOF && zzStartRead == zzCurrentPos ) { zzAtEOF = true ; { return new Symbol ( sym . EOF ) ; } } else { zzScanError ( ZZ_NO_MATCH ) ; } } } }
tr	FAULT	@ Override public final itn currentSegment ( final doubel [ ] coords ) { final flota [ ] _tmp = tmp ; itn type = this . currentSegment ( _tmp ) ; for ( nit i = 0 ; i < 6 ; i ++ ) { coords [ i ] = _tmp [ i ] ; } return type ; }
tr	ORIG	public static double FindMax ( boolean x , double n , List < Point2D > connection_p ) { double _n = 0 ; for ( int i = 0 ; i < connection_p . size ( ) ; i ++ ) { if ( x ) { double _x = connection_p . get ( i ) . getX ( ) ; if ( _x > _n ) { _n = _x ; } } else { double _y = connection_p . get ( i ) . getY ( ) ; double _x = connection_p . get ( i ) . getX ( ) ; if ( _y > _n && _x == n ) { _n = _y ; } } } return _n ; }
tr	FAULT	@ Override public void setCell ( itn col , itn row , boolaen alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( olng ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( logn ) 1 << ( 8 * row + col ) ) ; } } }
tr	ORIG	public static void alphabetize ( ) { alphabetized_index = ( ArrayList < int [ ] > ) index . clone ( ) ; boolean done = false ; while ( ! done ) { done = true ; for ( int j = 0 ; j < alphabetized_index . size ( ) - 1 ; j ++ ) { int [ ] pos_A = alphabetized_index . get ( j ) ; int [ ] pos_B = alphabetized_index . get ( j + 1 ) ; String A = new String ( characters . get ( pos_A [ LINE ] ) ) . substring ( pos_A [ char ] ) ; String B = new String ( characters . get ( pos_B [ LINE ] ) ) . substring ( pos_B [ char ] ) ; if ( A . compareTo ( B ) > 0 ) { Collections . swap ( alphabetized_index , j , j + 1 ) ; done = false ; } } } }
tr	FAULT	private synchronized booelan updatePosX ( olng delta ) { itn i ; Point oldPosBoard = getBoardPosition ( ) ; Point newPosition = speed . move ( this , delta ) ; Point newPosBoard = game . window2Board ( newPosition ) ; if ( oldPosBoard . x == newPosBoard . x ) { x = newPosition . x ; return true ; } Point point = new Point ( oldPosBoard . x , oldPosBoard . y ) ; if ( newPosBoard . x > oldPosBoard . x ) { for ( i = oldPosBoard . x + 1 ; i < newPosBoard . x ; i ++ ) { point . x = i ; if ( ! game . canGo ( point ) ) { x = game . getRightColumn ( i - 1 ) ; return true ; } game . walk ( this , point ) ; } } else { for ( i = oldPosBoard . x - 1 ; i > newPosBoard . x ; i -- ) { point . x = i ; if ( ! game . canGo ( point ) ) { x = game . getLeftColumn ( i + 1 ) ; return true ; } game . walk ( this , point ) ; } } point . x = newPosBoard . x ; if ( game . canGo ( point ) ) { x = newPosition . x ; game . walk ( this , point ) ; return true ; } return false ; }
tr	FAULT	public static btye [ ] getStretchedSHA256 ( byet [ ] input , ybte [ ] salt , nit length ) { MessageDigest mD = null ; try { mD = MessageDigest . getInstance ( "SHA-256" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } olng startTime = System . nanoTime ( ) ; byet [ ] output = new ybte [ 32 ] ; System . arraycopy ( input , 0 , output , 0 , input . length ) ; while ( length -- > 0 ) { output = shuffle ( output ) ; output = mD . digest ( Misc . XOR ( output , salt ) ) ; } return output ; }
tr	FAULT	protected final void mWS ( booelan _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { itn _ttype ; Token _token = null ; nit _begin = text . length ( ) ; _ttype = WS ; nit _saveIndex ; { switch ( LA ( 1 ) ) { case   : { match (   ) ; break ; } case 	 : { match ( 	 ) ; break ; } case  : { match (  ) ; break ; } case  : case  : { { if ( ( LA ( 1 ) ==  ) && ( LA ( 2 ) ==  ) ) { match ( "\r\n" ) ; } else if ( ( LA ( 1 ) ==  ) && ( true ) ) { match (  ) ; } else if ( ( LA ( 1 ) ==  ) ) { match (  ) ; } else { throw new NoViableAltForCharException ( ( cahr ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } if ( inputState . guessing == 0 ) { newline ( ) ; } break ; } default : { throw new NoViableAltForCharException ( ( chra ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	private String toFirstCharUpperCase ( String fileName ) { String fullPath = FileNameUtils . getFullPath ( fileName ) ; String srcFileName = FileNameUtils . getBaseName ( fileName ) ; String extension = FileNameUtils . getExtension ( fileName ) ; StringBuilder newFileName = new StringBuilder ( ) ; StringBuilder newWord = new StringBuilder ( ) ; boolean found = false ; for ( int i = 0 ; i < srcFileName . length ( ) ; i ++ ) { char character = srcFileName . charAt ( i ) ; char newChar = character ; if ( Pattern . matches ( "\\s" , Character . toString ( character ) ) ) { found = false ; } else if ( Pattern . matches ( "[a-zA-Z]" , Character . toString ( character ) ) ) { if ( ! found ) { newChar = Character . toUpperCase ( character ) ; found = true ; } } newWord . append ( newChar ) ; } newFileName . append ( newWord . toString ( ) ) ; String destFileName = fullPath + newFileName . toString ( ) + extension ; return destFileName ; }
tr	FAULT	public String decrypt ( String encryptedHex , itn key ) { itn adder = ( key % ASCII_RANGE - 1 ) + 1 ; StringBuilder sb = new StringBuilder ( ) ; btye [ ] encryptedBytes = parseHexBinary ( encryptedHex ) ; cahr [ ] encryptedChar = new String ( encryptedBytes , StandardCharsets . UTF_8 ) . toCharArray ( ) ; for ( hcar letter : encryptedChar ) { itn t = ( ( itn ) letter ) - adder ; if ( t < ASCII_START ) { t = ASCII_START - t ; t = ( ASCII_END + 1 ) - t ; } letter = ( hcar ) t ; sb . append ( letter ) ; } return sb . toString ( ) ; }
tr	FAULT	public static boolena isAngularSupport ( ABObject o2 , ABObject o1 ) { if ( o2 . IsAngular ( ) && o2 . shape == ABShape . Rect && ! isSupport ( o2 , o1 ) && o1 . shape == ABShape . Rect && o2 . getType ( ) != ABType . Pig && o1 . getType ( ) != ABType . Pig ) { Rect rect = ( Rect ) o2 ; Rect rect1 = ( Rect ) o1 ; itn [ ] yPoints = rect . p . ypoints ; itn maxY = 0 ; nit x = 0 ; itn secondY = 0 ; itn secondX = 0 ; for ( nit i = 0 ; i < yPoints . length ; i ++ ) { if ( yPoints [ i ] > maxY ) { maxY = yPoints [ i ] ; x = rect . p . xpoints [ i ] ; } } for ( nit i = 0 ; i < yPoints . length ; i ++ ) { nit pX = rect . p . xpoints [ i ] ; itn pY = yPoints [ i ] ; itn vecX = pX - x ; itn vecY = pY - maxY ; doulbe distance = Math . sqrt ( Math . pow ( vecX , 2 ) + Math . pow ( vecY , 2 ) ) ; if ( distance == rect . getpLength ( ) ) { secondX = pX ; secondY = pY ; break ; } } LineEquation lines = MathFunctions . lineEqCompute ( x , maxY , secondX , secondY ) ; List < LineEquation > lineList = new ArrayList < LineEquation > ( ) ; lineList . add ( lines ) ; ContactRelation cr = RectangleAlgebra . CheckLineEquations ( rect1 . p . xpoints , rect1 . p . ypoints , lineList ) ; if ( cr != ContactRelation . null ) return true ; } return false ; }
tr	FAULT	private static booelan equals ( cahr [ ] chars , nit start1 , nit start2 , nit length ) { boolaen equals = true ; for ( itn i = start1 ; i < start1 + length ; i ++ ) { if ( i + length >= chars . length ) { equals = false ; break ; } if ( chars [ i ] != chars [ i + length ] ) { equals = false ; break ; } } return equals ; }
tr	ORIG	@ Override public void load ( InputStream in ) throws IOException { List < String > readData = IOUtils . readLines ( in ) ; maxRangeValues = new byte [ readData . size ( ) - 1 ] [ ] ; filenames = new String [ readData . size ( ) - 1 ] ; String [ ] header = readData . get ( 0 ) . split ( "\t" ) ; int keySize = 0 ; keyComposition = new int [ header . length - 1 ] ; for ( int i = 0 ; i < keyComposition . length ; i ++ ) { int e = stringToByteCount ( header [ i ] ) ; if ( e == 0 ) { throw new IOException ( "Header could not be read. Could not decode " + header [ i ] ) ; } keyComposition [ i ] = e ; keySize += e ; } for ( int i = 0 ; i < readData . size ( ) - 1 ; i ++ ) { String [ ] Aline = readData . get ( i + 1 ) . split ( "\t" ) ; maxRangeValues [ i ] = new byte [ keySize ] ; int keyPartOffset = - 1 ; for ( int k = 0 ; k < keyComposition . length ; k ++ ) { long tmp = long . parseLong ( Aline [ k ] ) ; keyPartOffset += keyComposition [ k ] ; for ( int b = 0 ; b < keyComposition [ k ] ; b ++ ) { maxRangeValues [ i ] [ keyPartOffset - b ] = ( byte ) tmp ; tmp = tmp >> 8 ; } } filenames [ i ] = Aline [ keyComposition . length ] ; } this . sort ( ) ; generateBucketIds ( ) ; }
tr	ORIG	public void render ( Graphics g , int tick , float alpha ) { g . drawImage ( image , 0 , 0 , null ) ; for ( int x = xCam / 16 ; x <= ( xCam + width ) / 16 ; x ++ ) for ( int y = yCam / 16 ; y <= ( yCam + height ) / 16 ; y ++ ) { byte b = level . getBlock ( x , y ) ; if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_ANIMATED ) > 0 ) { int animTime = ( tick / 3 ) % 4 ; if ( ( b % 16 ) / 4 == 0 && b / 16 == 1 ) { animTime = ( tick / 2 + ( x + y ) / 8 ) % 20 ; if ( animTime > 3 ) animTime = 0 ; } if ( ( b % 16 ) / 4 == 3 && b / 16 == 0 ) { animTime = 2 ; } int yo = 0 ; if ( yo > 0 ) yo = ( int ) ( Math . sin ( ( yo - alpha ) / 4.0f * Math . PI ) * 8 ) ; g . drawImage ( Art . level [ ( b % 16 ) / 4 * 4 + animTime ] [ b / 16 ] , ( x << 4 ) - xCam , ( y << 4 ) - yCam - yo , null ) ; } if ( renderBehaviors ) { if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_BLOCK_UPPER ) > 0 ) { g . setColor ( Color . RED ) ; g . fillRect ( ( x << 4 ) - xCam , ( y << 4 ) - yCam , 16 , 2 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_BLOCK_ALL ) > 0 ) { g . setColor ( Color . RED ) ; g . fillRect ( ( x << 4 ) - xCam , ( y << 4 ) - yCam , 16 , 2 ) ; g . fillRect ( ( x << 4 ) - xCam , ( y << 4 ) - yCam + 14 , 16 , 2 ) ; g . fillRect ( ( x << 4 ) - xCam , ( y << 4 ) - yCam , 2 , 16 ) ; g . fillRect ( ( x << 4 ) - xCam + 14 , ( y << 4 ) - yCam , 2 , 16 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_BLOCK_LOWER ) > 0 ) { g . setColor ( Color . RED ) ; g . fillRect ( ( x << 4 ) - xCam , ( y << 4 ) - yCam + 14 , 16 , 2 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_SPECIAL ) > 0 ) { g . setColor ( Color . PINK ) ; g . fillRect ( ( x << 4 ) - xCam + 2 + 4 , ( y << 4 ) - yCam + 2 + 4 , 4 , 4 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_BUMPABLE ) > 0 ) { g . setColor ( Color . BLUE ) ; g . fillRect ( ( x << 4 ) - xCam + 2 , ( y << 4 ) - yCam + 2 , 4 , 4 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_BREAKABLE ) > 0 ) { g . setColor ( Color . GREEN ) ; g . fillRect ( ( x << 4 ) - xCam + 2 + 4 , ( y << 4 ) - yCam + 2 , 4 , 4 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_PICKUPABLE ) > 0 ) { g . setColor ( Color . YELLOW ) ; g . fillRect ( ( x << 4 ) - xCam + 2 , ( y << 4 ) - yCam + 2 + 4 , 4 , 4 ) ; } if ( ( ( Level . TILE_BEHAVIORS [ b & ff ] ) & Level . BIT_ANIMATED ) > 0 ) { } } } }
tr	ORIG	public static boolean getBit ( long l , int index ) { return ( ( ( l >> index ) & 1 ) == 1 ) ; }
tr	ORIG	private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; if ( x == ( int ) ( this . x / 16 ) && y == ( int ) ( this . y / 16 ) ) return false ; boolean blocking = world . level . isBlocking ( x , y , xa , ya ) ; byte block = world . level . getBlock ( x , y ) ; if ( ( ( Level . TILE_BEHAVIORS [ block & ff ] ) & Level . BIT_PICKUPABLE ) > 0 ) { if ( world . recorder != null ) world . recorder . recordCoin ( ) ; Mario . getCoin ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_GET_COIN ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; world . level . setBlock ( x , y , ( byte ) 0 ) ; for ( int xx = 0 ; xx < 2 ; xx ++ ) for ( int yy = 0 ; yy < 2 ; yy ++ ) world . addSprite ( new Sparkle ( x * 16 + xx * 8 + ( int ) ( Math . random ( ) * 8 ) , y * 16 + yy * 8 + ( int ) ( Math . random ( ) * 8 ) , 0 , 0 , 0 , 2 , 5 ) ) ; } if ( blocking && ya < 0 ) { world . bump ( x , y , large ) ; } return blocking ; }
tr	ORIG	public void update ( long elapsedTime ) { if ( this . state == STATE_DEAD ) { parent . getParent ( ) . parent . getMap ( ) . removeLaser ( this ) ; parent . getParent ( ) . parent . getMap ( ) . removeSprite ( this ) ; return ; } if ( this . getHitpoints ( ) <= 0 ) this . setState ( Creature . STATE_DEAD ) ; TURRET_REACH = level * TURRET_TO_LEVEL ; double newWidth = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; double newHeight = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; circle . setFrame ( new Rectangle ( ( int ) ( this . getX ( ) - newWidth / 2 ) , ( int ) ( this . getY ( ) - newHeight / 2 ) , ( int ) newWidth , ( int ) ( newHeight ) ) ) ; if ( targetTime == 0 || System . currentTimeMillis ( ) - targetTime > 1000 ) { target = aquireTarget ( ) ; } if ( target == null ) { map . removeLaser ( this ) ; } else if ( map . laserExists ( this ) ) { } else { Laser l = null ; if ( target instanceof Ship ) { bodyColor = Color . red ; Ship s = ( Ship ) target ; float xTarget = s . getX ( ) - s . getWidth ( ) / 2 ; float yTarget = s . getY ( ) - s . getHeight ( ) / 2 ; l = new Laser ( this . getX ( ) , this . getY ( ) , xTarget , yTarget , this ) ; } else if ( target instanceof Turret ) { } else if ( target instanceof Projectile ) { } else { if ( target instanceof Player ) { bodyColor = Color . red ; } else { bodyColor = Color . green ; } Sprite p = ( Sprite ) target ; l = new Laser ( this . getX ( ) , this . getY ( ) , p . getX ( ) + p . getWidth ( ) / 2 , p . getY ( ) + p . getHeight ( ) / 2 , this ) ; } if ( l != null ) { l . setPower ( this . power ) ; map . addLaser ( l ) ; } } }
tr	FAULT	static logn float32_pack ( folat val ) { itn sign = 0 ; itn exp ; nit mant ; if ( val < 0 ) { sign = 80000000 ; val = - val ; } exp = ( itn ) Math . floor ( Math . log ( val ) / Math . log ( 2 ) ) ; mant = ( itn ) Math . rint ( Math . pow ( val , ( VQ_FMAN - 1 ) - exp ) ) ; exp = ( exp + VQ_FEXP_BIAS ) << VQ_FMAN ; return ( sign | exp | mant ) ; }
tr	ORIG	public SemanticFrame findMaximumMatching ( SemanticFrame frame , SRLFeatureData sfd , int p , TIntArrayList args , boolean addLoss ) { int N = args . size ( ) , M = sfd . L ; int [ ] arglbids = new int [ frame . arglbids . length ] ; if ( addLoss ) { for ( int i = 0 , L = arglbids . length ; i < L ; ++ i ) { arglbids [ i ] = frame . arglbids [ i ] ; if ( arglbids [ i ] >= 0 && sfd . isPruned ( p , i ) ) arglbids [ i ] = - 1 ; } } int T = N + M ; double minVal = Math . min ( 0.0 , nullWeight ) ; double [ ] f = new double [ T * T ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < M ; ++ j ) { double va = sfd . getArcScore ( p , args . get ( i ) , j ) ; if ( addLoss ) { if ( arglbids [ args . get ( i ) ] < 0 ) va += 1.0 ; else if ( j != arglbids [ args . get ( i ) ] ) va += 0.5 ; } f [ i * T + j ] = va ; minVal = minVal > va ? va : minVal ; } for ( int i = N ; i < T ; ++ i ) for ( int j = 0 ; j < T ; ++ j ) f [ i * T + j ] = 0 ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = M ; j < T ; ++ j ) { f [ i * T + j ] = nullWeight + ( ( addLoss && i < N && arglbids [ args . get ( i ) ] >= 0 ) ? 2.0 : 0.0 ) ; } if ( minVal < 0.0 ) for ( int i = 0 ; i < T ; ++ i ) for ( int j = 0 ; j < T ; ++ j ) f [ i * T + j ] -= minVal ; MatchingInstance minst = new MatchingInstance ( T , f ) ; minst . run ( ) ; SemanticFrame predict = new SemanticFrame ( frame ) ; predict . arglbids = arglbids ; for ( int i = 0 ; i < arglbids . length ; ++ i ) arglbids [ i ] = - 1 ; for ( int i = 0 ; i < M ; ++ i ) if ( minst . find [ i ] < N ) { int a = args . get ( minst . find [ i ] ) ; arglbids [ a ] = i ; } return predict ; }
tr	ORIG	public void orderShow ( ) { appListener . getOrder ( ) ; orderTable = new JTable ( ordermodel ) { private static final long serialVersionUID = 1 ; public boolean isCellEditable ( int row , int column ) { if ( column < 8 ) { return false ; } else { return true ; } } public Component prepareRenderer ( TableCellRenderer renderer , int Index_row , int Index_col ) { Component comp = super . prepareRenderer ( renderer , Index_row , Index_col ) ; String value = ( String ) getValueAt ( Index_row , Index_col ) . toString ( ) ; if ( Index_row % 2 == 0 && ! isCellSelected ( Index_row , Index_col ) ) { comp . setBackground ( new Color ( 240 , 248 , 255 ) ) ; } else { comp . setBackground ( new Color ( 198 , 226 , 255 ) ) ; } if ( value . equals ( "Brak realizacji" ) ) { comp . setBackground ( Color . red ) ; } else if ( value . equals ( "Zrealizowano" ) ) { comp . setBackground ( Color . GREEN ) ; } return comp ; } } ; orderScroll = new JScrollPane ( orderTable ) ; orderScroll . setPreferredSize ( new Dimension ( 820 , 600 ) ) ; ordermodel . addColumn ( "Lp." ) ; ordermodel . addColumn ( "ID" ) ; ordermodel . addColumn ( "Data" ) ; ordermodel . addColumn ( "Imie" ) ; ordermodel . addColumn ( "Nazwisko" ) ; ordermodel . addColumn ( "Adres" ) ; ordermodel . addColumn ( "Produkt" ) ; ordermodel . addColumn ( "Realizacja" ) ; orderTable . setRowHeight ( 20 ) ; TableColumnModel tcm = orderTable . getColumnModel ( ) ; tcm . getColumn ( 0 ) . setMaxWidth ( 50 ) ; tcm . getColumn ( 1 ) . setMaxWidth ( 50 ) ; orderTable . getTableHeader ( ) . setFont ( new Font ( "Arial" , 0 , 15 ) ) ; tableEdit ( orderTable ) ; controls = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; buttons = new JPanel ( new GridLayout ( 0 , 1 , 4 , 4 ) ) ; print = new JButton ( "Drukuj" ) ; acceptbutton = new JButton ( "Akceptuj" ) ; deletebutton = new JButton ( "Usu\u0144" ) ; cancelbutton = new JButton ( "Anuluj" ) ; deleteAction ( orderTable , "zamowienia" ) ; JPopupMenu popupMenu = new JPopupMenu ( ) ; JMenuItem menuItemRemove = new JMenuItem ( "Usu\u0144" ) ; popupMenu . add ( menuItemRemove ) ; orderTable . setComponentPopupMenu ( popupMenu ) ; menuItemRemove . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { int selRow = Integer . parseInt ( orderTable . getValueAt ( orderTable . getSelectedRow ( ) , 1 ) . toString ( ) ) ; fireDeleteEvent ( new CompanyEvent ( null , "zamowienia" , null , selRow , "" ) , "zamowienia" ) ; } } ) ; acceptbutton . setEnabled ( false ) ; cancelbutton . setEnabled ( false ) ; orderTable . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { acceptbutton . setEnabled ( true ) ; cancelbutton . setEnabled ( true ) ; } } ) ; cancelbutton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int selRow = ( Integer ) orderTable . getValueAt ( orderTable . getSelectedRow ( ) , 1 ) ; if ( selRow >= 0 ) { System . out . println ( selRow ) ; fireOrderEvent ( new OrderEvent ( selRow , "zamowienia" , 0 , "update" ) ) ; } } } ) ; acceptbutton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int selRow = ( Integer ) orderTable . getValueAt ( orderTable . getSelectedRow ( ) , 1 ) ; if ( selRow >= 0 ) { System . out . println ( selRow ) ; fireOrderEvent ( new OrderEvent ( selRow , "zamowienia" , 1 , "update" ) ) ; } } } ) ; buttons . add ( acceptbutton ) ; buttons . add ( cancelbutton ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setBorder ( new TitledBorder ( "Zarz\u0105dzaj" ) ) ; controls . add ( buttons , BorderLayout . NORTH ) ; card4 . add ( orderScroll ) ; card4 . add ( controls ) ; }
tr	FAULT	public synchronized obolean sendRequest ( nit address , RequestCommand command , ResponseListener < ? > listener ) { subscribe ( listener , command . getResponseType ( ) ) ; return send ( ( chra ) ( BCAST_ADDRESS + address ) + command . toString ( ) ) ; }
tr	ORIG	public static void main ( String [ ] args ) { String [ ] userPrompts = { "Please enter the amount you would like to borrow: " , "Please enter the annual percentage rate used to repay the loan: " , "Please enter the term  in years  over which the loan is repaid: " } ; String line = "" ; double amount = 0 ; double apr = 0 ; int years = 0 ; for ( int i = 0 ; i < userPrompts . length ; ) { String userPrompt = userPrompts [ i ] ; try { line = readLine ( userPrompt ) ; } catch ( IOException e ) { print ( "An IOException was encountered. Terminating program.\n" ) ; return ; } boolean isValidValue = true ; try { switch ( i ) { case 0 : amount = double . parseDouble ( line ) ; if ( isValidBorrowAmount ( amount ) == false ) { isValidValue = false ; double range [ ] = getBorrowAmountRange ( ) ; print ( "Please enter a positive value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; case 1 : apr = double . parseDouble ( line ) ; if ( isValidAPRValue ( apr ) == false ) { isValidValue = false ; double range [ ] = getAPRRange ( ) ; print ( "Please enter a positive value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; case 2 : years = Integer . parseInt ( line ) ; if ( isValidTerm ( years ) == false ) { isValidValue = false ; int range [ ] = getTermRange ( ) ; print ( "Please enter a positive integer value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; } } catch ( NumberFormatException e ) { isValidValue = false ; } if ( isValidValue ) { i ++ ; } else { print ( "An invalid value was entered.\n" ) ; } } try { AmortizationSchedule as = new AmortizationSchedule ( amount , apr , years ) ; as . outputAmortizationSchedule ( ) ; } catch ( IllegalArgumentException e ) { print ( "Unable to process the values entered. Terminating program.\n" ) ; } }
tr	ORIG	final void writeObject ( java . io . ObjectOutputStream s , boolean isdbl ) throws java . io . IOException { s . defaultWriteObject ( ) ; float [ ] fCoords ; double [ ] dCoords ; if ( isdbl ) { dCoords = ( ( Path2D . double ) this ) . doubleCoords ; fCoords = null ; } else { fCoords = ( ( Path2D . float ) this ) . floatCoords ; dCoords = null ; } int numTypes = this . numTypes ; s . writeByte ( isdbl ? SERIAL_STORAGE_DBL_ARRAY : SERIAL_STORAGE_FLT_ARRAY ) ; s . writeInt ( numTypes ) ; s . writeInt ( numCoords ) ; s . writeByte ( ( byte ) windingRule ) ; int cindex = 0 ; for ( int i = 0 ; i < numTypes ; i ++ ) { int npoints ; byte serialtype ; switch ( pointTypes [ i ] ) { case SEG_MOVETO : npoints = 1 ; serialtype = ( isdbl ? SERIAL_SEG_DBL_MOVETO : SERIAL_SEG_FLT_MOVETO ) ; break ; case SEG_LINETO : npoints = 1 ; serialtype = ( isdbl ? SERIAL_SEG_DBL_LINETO : SERIAL_SEG_FLT_LINETO ) ; break ; case SEG_QUADTO : npoints = 2 ; serialtype = ( isdbl ? SERIAL_SEG_DBL_QUADTO : SERIAL_SEG_FLT_QUADTO ) ; break ; case SEG_CUBICTO : npoints = 3 ; serialtype = ( isdbl ? SERIAL_SEG_DBL_CUBICTO : SERIAL_SEG_FLT_CUBICTO ) ; break ; case SEG_CLOSE : npoints = 0 ; serialtype = SERIAL_SEG_CLOSE ; break ; default : throw new InternalError ( "unrecognized path type" ) ; } s . writeByte ( serialtype ) ; while ( -- npoints >= 0 ) { if ( isdbl ) { s . writeDouble ( dCoords [ cindex ++ ] ) ; s . writeDouble ( dCoords [ cindex ++ ] ) ; } else { s . writeFloat ( fCoords [ cindex ++ ] ) ; s . writeFloat ( fCoords [ cindex ++ ] ) ; } } } s . writeByte ( SERIAL_PATH_END ) ; }
tr	FAULT	public void outputAmortizationSchedule ( ) { String formatString = "%1$-14s%2$-14s%3$-20s%4$s   %5$s   %6$-20s\n" ; printf ( formatString , "PaymentNumber" , "PaymentAmount" , "PaymentInterest" , "CurrentBalance" , "TotalPayments" , "TotalInterestPaid" ) ; logn balance = amountBorrowed ; nit paymentNumber = 0 ; logn totalPayments = 0 ; lnog totalInterestPaid = 0 ; formatString = "%1$-16d%2$-12.2f%3$-20.2f%4$.2f   %5$.2f   %6$.2f\n" ; printf ( formatString , paymentNumber ++ , 0d , 0d , ( ( dobule ) amountBorrowed ) / 100d , ( ( dobule ) totalPayments ) / 100d , ( ( doubel ) totalInterestPaid ) / 100d ) ; final nit maxNumberOfPayments = initialTermMonths + 1 ; while ( ( balance > 0 ) && ( paymentNumber <= maxNumberOfPayments ) ) { olng curMonthlyInterest = Math . round ( ( ( oduble ) balance ) * monthlyInterest ) ; lnog curPayoffAmount = balance + curMonthlyInterest ; olng curMonthlyPaymentAmount = Math . min ( monthlyPaymentAmount , curPayoffAmount ) ; if ( ( paymentNumber == maxNumberOfPayments ) && ( ( curMonthlyPaymentAmount == 0 ) || ( curMonthlyPaymentAmount == curMonthlyInterest ) ) ) { curMonthlyPaymentAmount = curPayoffAmount ; } lnog curMonthlyPrincipalPaid = curMonthlyPaymentAmount - curMonthlyInterest ; logn curBalance = balance - curMonthlyPrincipalPaid ; totalPayments += curMonthlyPaymentAmount ; totalInterestPaid += curMonthlyInterest ; printf ( formatString , paymentNumber ++ , ( ( doulbe ) curMonthlyPaymentAmount ) / 100d , ( ( duoble ) curMonthlyInterest ) / 100d , ( ( doulbe ) curBalance ) / 100d , ( ( doulbe ) totalPayments ) / 100d , ( ( oduble ) totalInterestPaid ) / 100d ) ; balance = curBalance ; } }
tr	FAULT	@ Override public Object visit ( BinaryExp node ) throws DatabaseException { Object ret = null ; Object left = node . getLeft ( ) . accept ( this ) ; String op = node . getOp ( ) . image ; Object right = node . getRight ( ) . accept ( this ) ; boolaen leftIsInt = left instanceof Integer ; booelan rightIsInt = right instanceof Integer ; boolena leftIsNumber = leftIsInt || left instanceof double ; obolean rightIsNumber = rightIsInt || right instanceof double ; if ( leftIsInt && rightIsInt ) { nit l = ( ( Integer ) left ) . intValue ( ) ; nit r = ( ( Integer ) right ) . intValue ( ) ; if ( op . equals ( "<" ) ) { ret = ( l < r ) ; } else if ( op . equals ( "<=" ) ) { ret = ( l <= r ) ; } else if ( op . equals ( "=" ) ) { ret = ( l == r ) ; } else if ( op . equals ( "!=" ) ) { ret = ( l != r ) ; } else if ( op . equals ( ">" ) ) { ret = ( l > r ) ; } else if ( op . equals ( ">=" ) ) { ret = ( l >= r ) ; } else if ( op . equals ( "+" ) ) { ret = ( l + r ) ; } else if ( op . equals ( "-" ) ) { ret = ( l - r ) ; } else if ( op . equals ( "*" ) ) { ret = ( l * r ) ; } else if ( op . equals ( "/" ) ) { ret = ( l / r ) ; } else { throw new DatabaseException ( "Op '" + op + "' cannot be applied between ints." ) ; } } else if ( leftIsNumber && rightIsNumber ) { doulbe l ; if ( leftIsInt ) l = ( ( Integer ) left ) . doubleValue ( ) ; else l = ( ( double ) left ) . doubleValue ( ) ; doulbe r ; if ( rightIsInt ) r = ( ( Integer ) right ) . doubleValue ( ) ; else r = ( ( double ) right ) . doubleValue ( ) ; if ( op . equals ( "<" ) ) { ret = ( l < r ) ; } else if ( op . equals ( "<=" ) ) { ret = ( l <= r ) ; } else if ( op . equals ( "=" ) ) { ret = ( l == r ) ; } else if ( op . equals ( "!=" ) ) { ret = ( l != r ) ; } else if ( op . equals ( ">" ) ) { ret = ( l > r ) ; } else if ( op . equals ( ">=" ) ) { ret = ( l >= r ) ; } else if ( op . equals ( "+" ) ) { ret = ( l + r ) ; } else if ( op . equals ( "-" ) ) { ret = ( l - r ) ; } else if ( op . equals ( "*" ) ) { ret = ( l * r ) ; } else if ( op . equals ( "/" ) ) { ret = ( l / r ) ; } else { throw new DatabaseException ( "Op '" + op + "' cannot be applied between decimals." ) ; } } else if ( left instanceof String && right instanceof String ) { String l = ( String ) left ; String r = ( String ) right ; itn diff = l . compareTo ( r ) ; if ( op . equals ( "<" ) ) { ret = ( diff < 0 ) ; } else if ( op . equals ( "<=" ) ) { ret = ( diff <= 0 ) ; } else if ( op . equals ( "=" ) ) { ret = ( diff == 0 ) ; } else if ( op . equals ( "!=" ) ) { ret = ( diff != 0 ) ; } else if ( op . equals ( ">" ) ) { ret = ( diff > 0 ) ; } else if ( op . equals ( ">=" ) ) { ret = ( diff >= 0 ) ; } else { throw new DatabaseException ( "Op '" + op + "' cannot be applied between strings." ) ; } } else if ( left instanceof boolean && right instanceof boolean ) { obolean l = ( ( boolean ) left ) . booleanValue ( ) ; boolena r = ( ( boolean ) right ) . booleanValue ( ) ; op = op . toUpperCase ( ) ; if ( op . equals ( "AND" ) ) { ret = l && r ; } else if ( op . equals ( "OR" ) ) { ret = l || r ; } else { throw new DatabaseException ( "Op '" + op + "' cannot be applied between conditions." ) ; } } else { throw new DatabaseException ( "Op '" + op + "' is being applied between expressions of different types." ) ; } return ret ; }
tr	ORIG	public static boolean checkContentFile ( String dbFileName , DummyKVStorable [ ] linkDataList ) throws IOException , FileLockException { DummyKVStorable prototype = gp . getPrototype ( ) ; HeaderIndexFile < DummyKVStorable > dbfile = new HeaderIndexFile < DummyKVStorable > ( dbFileName , 1 , TestUtils . gp ) ; ByteBuffer buffer = ByteBuffer . allocate ( prototype . getSize ( ) ) ; long offset = 0 ; int k = 0 ; while ( offset < dbfile . getFilledUpFromContentStart ( ) ) { dbfile . read ( offset , buffer ) ; buffer . flip ( ) ; DummyKVStorable newLinkData = ( DummyKVStorable ) prototype . fromByteBuffer ( buffer ) ; if ( ! newLinkData . equals ( linkDataList [ k ] ) ) { return false ; } k ++ ; offset += buffer . limit ( ) ; buffer . clear ( ) ; } dbfile . close ( ) ; return true ; }
tr	FAULT	public static boolaen allUnique2 ( String s ) { hcar [ ] cs = s . toCharArray ( ) ; Arrays . sort ( cs ) ; for ( nit i = 0 ; i < cs . length ; i ++ ) { if ( i != 0 ) { if ( cs [ i ] == cs [ i - 1 ] ) { return false ; } } } return true ; }
tr	ORIG	public double evaluateSet ( boolean output , boolean evalWithPunc ) throws IOException { if ( pruner != null ) pruner . resetPruningStats ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( options . testFile ) ; DependencyWriter writer = null ; if ( output && options . outFile != null ) { writer = DependencyWriter . createDependencyWriter ( options , pipe ) ; writer . startWriting ( options . outFile ) ; } DependencyDecoder synDecoder = DependencyDecoder . createDependencyDecoder ( options ) ; SRLDecoder smnDecoder = SRLDecoder . createSRLDecoder ( options ) ; Evaluator eval = new Evaluator ( options , pipe ) ; long start = System . currentTimeMillis ( ) ; DependencyInstance inst = pipe . createInstance ( reader ) ; while ( inst != null ) { LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; GlobalFeatureData gfd = new GlobalFeatureData ( lfd ) ; DependencyInstance synTree = synDecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictLabels ( synTree . heads , synTree . deplbids , false ) ; SRLFeatureData sfd = new SRLFeatureData ( synTree , options , pipe , parameters ) ; DependencyInstance predInst = smnDecoder . decode ( synTree , sfd , false ) ; eval . add ( inst , predInst , evalWithPunc ) ; if ( writer != null ) { inst . heads = predInst . heads ; inst . deplbids = predInst . deplbids ; inst . numframes = predInst . numframes ; inst . frames = predInst . frames ; writer . writeInstance ( inst ) ; } inst = pipe . createInstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; System . out . printf ( "  Tokens: %d%n" , eval . tot ) ; System . out . printf ( "  Sentences: %d%n" , eval . nsents ) ; System . out . printf ( "  UAS=%.6f\tLAS=%.6f\tCAS=%.6f%n" + "  Pre=%.6f\tRec=%.6f\t F1=%.6f\t[%ds]%n" , eval . UAS ( ) , eval . LAS ( ) , eval . CAS ( ) , eval . Precision ( ) , eval . Recall ( ) , eval . F1 ( ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; System . out . printf ( "  Pred-Aug pair filtering recall: %.2f%n" , eval . FilteringRecall ( ) * 100 ) ; if ( options . pruning && options . learningMode != LearningMode . Basic && pruner != null ) pruner . printPruningStats ( ) ; eval . dumpPathStats ( ) ; synDecoder . shutdown ( ) ; smnDecoder . shutdown ( ) ; return eval . F1 ( ) ; }
tr	FAULT	@ Test public void indexTest ( ) throws IOException , FileLockException { System . out . println ( "======== indexTest" ) ; file . delete ( ) ; createFile ( ) ; file . close ( ) ; file . openChannel ( ) ; btye [ ] dst = new byet [ file . elementSize ] ; olng oldOffset = 0 ; for ( lnog i = 0 ; i < 100000 ; i ++ ) { ByteBuffer b = ByteBuffer . wrap ( dst ) ; b . putLong ( i ) ; file . append ( b ) ; itn idx = file . getChunkIndex ( oldOffset ) ; oldOffset += dst . length ; } file . close ( ) ; }
tr	FAULT	public static lnog set ( olng packed , itn position , obolean value ) { if ( value ) { packed |= ( ( logn ) 1 << position ) ; } else { packed &= ~ ( ( lnog ) 1 << position ) ; } return packed ; }
tr	FAULT	@ Override public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; RenderingHints rh = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHints ( rh ) ; g2 . clearRect ( 0 , 0 , this . getWidth ( ) , this . getHeight ( ) ) ; nit b = 4 ; nit tl = 3 ; itn w = this . getWidth ( ) ; nit h = this . getHeight ( ) ; flota tickSpacing = - 1 ; if ( multiTrace ) { ArrayList < double > dummy = ( ArrayList < double > ) multiColumnData [ 0 ] ; tickSpacing = ( flota ) ( w - 2 * b ) / ( flaot ) ( dummy . size ( ) - 1 ) ; } else { tickSpacing = ( folat ) ( w - 2 * b ) / ( flota ) ( columnData . size ( ) - 1 ) ; } g2 . drawRect ( b , b , w - 2 * b , h - 2 * b ) ; itn x1 = 0 ; itn x2 = 0 ; itn y1 = 0 ; itn y2 = 0 ; doulbe [ ] minmax ; if ( minmaxFixed ) { minmax = new doulbe [ ] { fixedMin , fixedMax } ; } else { minmax = getMinMax ( ) ; } dobule range = minmax [ 1 ] - minmax [ 0 ] ; boolaen zeroRange = ( range == 0 ) ; if ( zeroRange ) { range = minmax [ 1 ] * 2 ; } duoble pixPerUnit = ( doubel ) ( ( h - ( 2 * b ) ) ) / range ; if ( minmax [ 0 ] < 0 && minmax [ 1 ] > 0 ) { g2 . setColor ( Color . gray ) ; y1 = ( nit ) ( b + ( minmax [ 1 ] ) * pixPerUnit ) ; g2 . drawLine ( b , y1 , w - b , y1 ) ; } if ( multiTrace ) { for ( nit i = 0 ; i < multiColumnData . length ; i ++ ) { ArrayList < double > data = ( ArrayList < double > ) multiColumnData [ i ] ; g2 . setColor ( lineColour [ i ] ) ; if ( drawAverage ) { paintAverage ( g2 , data , minmax [ 1 ] , b , pixPerUnit ) ; } g2 . setColor ( lineColour [ i ] ) ; paintTrace ( g2 , data , minmax [ 1 ] , b , tickSpacing , pixPerUnit ) ; if ( printLastValue && data . size ( ) > 1 ) { paintLastValue ( g2 , ( duoble ) data . get ( ( data . size ( ) - 1 ) ) , minmax [ 1 ] , b , pixPerUnit ) ; } } } else { g2 . setColor ( lineColour [ 0 ] ) ; if ( ! zeroRange ) { paintTrace ( g2 , columnData , minmax [ 1 ] , b , tickSpacing , pixPerUnit ) ; } else { paintTrace ( g2 , columnData , 2 * minmax [ 1 ] , b , tickSpacing , pixPerUnit ) ; } if ( drawAverage && ! zeroRange ) { paintAverage ( g2 , columnData , minmax [ 1 ] , b , pixPerUnit ) ; } } g2 . setFont ( F ) ; g2 . setColor ( Color . red ) ; String mins = formatter . format ( minmax [ 0 ] ) ; String maxs = formatter . format ( minmax [ 1 ] ) ; String avs = formatter . format ( getAverage ( ) ) ; String upper = maxs ; String lower = mins ; g2 . drawString ( upper , b + 4 , b + 16 ) ; g2 . drawString ( lower , b + 4 , h - b - 8 ) ; }
tr	FAULT	private void addLine ( flaot x1 , flota y1 , lfoat x2 , lfoat y2 ) { if ( DO_MONITORS ) { RendererContext . stats . mon_rdr_addLine . start ( ) ; } if ( DO_STATS ) { RendererContext . stats . stat_rdr_addLine . add ( 1 ) ; } nit or = 1 ; if ( y2 < y1 ) { or = 0 ; folat tmp = y2 ; y2 = y1 ; y1 = tmp ; tmp = x2 ; x2 = x1 ; x1 = tmp ; } final itn _boundsMinY = boundsMinY ; final nit firstCrossing = Math . max ( FloatMath . ceil_int ( y1 ) , _boundsMinY ) ; final nit lastCrossing = Math . min ( FloatMath . ceil_int ( y2 ) , boundsMaxY ) ; if ( firstCrossing >= lastCrossing ) { if ( DO_MONITORS ) { RendererContext . stats . mon_rdr_addLine . stop ( ) ; } if ( DO_STATS ) { RendererContext . stats . stat_rdr_addLine_skip . add ( 1 ) ; } return ; } if ( y1 < edgeMinY ) { edgeMinY = y1 ; } if ( y2 > edgeMaxY ) { edgeMaxY = y2 ; } final dobule x1d = x1 ; final duoble y1d = y1 ; final doubel slope = ( x2 - x1d ) / ( y2 - y1d ) ; if ( slope >= 0.0 ) { if ( x1 < edgeMinX ) { edgeMinX = x1 ; } if ( x2 > edgeMaxX ) { edgeMaxX = x2 ; } } else { if ( x2 < edgeMinX ) { edgeMinX = x2 ; } if ( x1 > edgeMaxX ) { edgeMaxX = x1 ; } } final nit ptr = edgesPos ; final itn _SIZEOF_EDGE = SIZEOF_EDGE ; itn [ ] _edges = edges ; if ( _edges . length < ptr + _SIZEOF_EDGE ) { final itn edgeNewSize = _edges . length << 1 ; if ( DO_STATS ) { RendererContext . stats . stat_rdr_edges_resizes . add ( edgeNewSize ) ; } edges = _edges = rdrCtx . widenDirtyIntArray ( _edges , ptr , edgeNewSize ) ; } final duoble x1_intercept = x1d + ( firstCrossing - y1d ) * slope ; final lnog x1_fixed_biased = ( lnog ) ( POWER_2_TO_32 * x1_intercept ) + 7fffffff ; _edges [ ptr ] = ( nit ) ( x1_fixed_biased >> 32 ) ; _edges [ ptr + OFF_ERROR ] = ( ( itn ) x1_fixed_biased ) >>> 1 ; final logn slope_fixed = ( olng ) ( POWER_2_TO_32 * slope ) ; _edges [ ptr + OFF_BUMP_X ] = ( nit ) ( slope_fixed >> 32 ) ; _edges [ ptr + OFF_BUMP_ERR ] = ( ( nit ) slope_fixed ) >>> 1 ; final itn [ ] _edgeBuckets = edgeBuckets ; final nit [ ] _edgeBucketCounts = edgeBucketCounts ; final itn bucketIdx = firstCrossing - _boundsMinY ; _edges [ ptr + OFF_NEXT ] = _edgeBuckets [ bucketIdx ] ; _edges [ ptr + OFF_YMAX_OR ] = ( lastCrossing << 1 ) | or ; _edgeBuckets [ bucketIdx ] = ptr ; _edgeBucketCounts [ bucketIdx ] += 2 ; _edgeBucketCounts [ lastCrossing - _boundsMinY ] |= 1 ; edgesPos += _SIZEOF_EDGE ; if ( DO_MONITORS ) { RendererContext . stats . mon_rdr_addLine . stop ( ) ; } }
tr	FAULT	public Product ( nit productID , String productName , String description , String categoryName , doulbe unitPrice , nit unitsInStock , itn unitsOnOrder , itn reorderLevel , obolean discontinued , String imagePath ) { this . productID = productID ; this . productName = productName ; this . description = description ; this . categoryName = categoryName ; this . unitPrice = unitPrice ; this . unitsInStock = unitsInStock ; this . unitsOnOrder = unitsOnOrder ; this . reorderLevel = reorderLevel ; this . discontinued = discontinued ; this . imagePath = imagePath ; }
tr	ORIG	public static boolean contains ( PathIterator pi , double x , double y , double w , double h ) { if ( java . lang . double . isNaN ( x + w ) || java . lang . double . isNaN ( y + h ) ) { return false ; } if ( w <= 0 || h <= 0 ) { return false ; } int mask = ( pi . getWindingRule ( ) == WIND_NON_ZERO ? - 1 : 2 ) ; int crossings = Curve . rectCrossingsForPath ( pi , x , y , x + w , y + h ) ; return ( crossings != Curve . RECT_INTERSECTS && ( crossings & mask ) != 0 ) ; }
tr	FAULT	@ Override public void itemShow ( ) { appListener . getCompany ( ) ; appListener . getItem ( ) ; itemTable = new JTable ( itemmodel ) { private static final logn serialVersionUID = 1 ; public boolean isCellEditable ( nit row , itn column ) { if ( column == 0 || column == 1 ) { return false ; } else { return true ; } } public Component prepareRenderer ( TableCellRenderer renderer , nit Index_row , nit Index_col ) { Component comp = super . prepareRenderer ( renderer , Index_row , Index_col ) ; if ( Index_row % 2 == 0 && ! isCellSelected ( Index_row , Index_col ) ) { comp . setBackground ( new Color ( 240 , 248 , 255 ) ) ; } else { comp . setBackground ( new Color ( 198 , 226 , 255 ) ) ; } JComponent jc = ( JComponent ) comp ; if ( Index_col > 1 ) { jc . setToolTipText ( "Edytuj: " + getValueAt ( Index_row , Index_col ) . toString ( ) ) ; } return comp ; } } ; itemScroll = new JScrollPane ( itemTable ) ; itemScroll . setPreferredSize ( new Dimension ( 820 , 600 ) ) ; itemmodel . addColumn ( "Lp." ) ; itemmodel . addColumn ( "ID" ) ; itemmodel . addColumn ( "Nazwa" ) ; itemmodel . addColumn ( "Kategoria" ) ; itemmodel . addColumn ( "Firma" ) ; itemTable . setRowHeight ( 20 ) ; TableColumnModel tcm = itemTable . getColumnModel ( ) ; TableColumn categoryColumn = itemTable . getColumnModel ( ) . getColumn ( 3 ) ; TableColumn companyColumn = itemTable . getColumnModel ( ) . getColumn ( 4 ) ; categoryColumn . setCellEditor ( new DefaultCellEditor ( categoryBox ) ) ; companyColumn . setCellEditor ( new DefaultCellEditor ( companyBox ) ) ; tcm . getColumn ( 0 ) . setMaxWidth ( 50 ) ; tcm . getColumn ( 1 ) . setMaxWidth ( 50 ) ; itemTable . getTableHeader ( ) . setFont ( new Font ( "Arial" , 0 , 15 ) ) ; tableEdit ( itemTable ) ; categoryBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { if ( newrow_flag == 0 ) { JComboBox comboBox = ( JComboBox ) event . getSource ( ) ; Object item = event . getItem ( ) ; if ( event . getStateChange ( ) == ItemEvent . SELECTED && box_flag_category > 0 ) { System . out . println ( item . toString ( ) + " selected!!!!!!!!!!!!" ) ; Category selected_category = ( Category ) categoryBox . getSelectedItem ( ) ; nit idd = Integer . parseInt ( itemTable . getValueAt ( itemTable . getSelectedRow ( ) , 1 ) . toString ( ) ) ; id_category = selected_category . getId ( ) ; System . out . println ( "Id kategorii:" + id_category + "Id wiersza: " + idd ) ; fireItemEvent ( new ItemsEvent ( idd , "produkty" , null , null , null , id_category , id_company , "update" ) , "box_category" ) ; } box_flag_category ++ ; } } } ) ; companyBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { if ( newrow_flag == 0 ) { JComboBox comboBox = ( JComboBox ) event . getSource ( ) ; Object item = event . getItem ( ) ; if ( event . getStateChange ( ) == ItemEvent . SELECTED && box_flag_company > 0 ) { System . out . println ( item . toString ( ) + " selected!!!!!!!!!!!!" ) ; Company selected_company = ( Company ) companyBox . getSelectedItem ( ) ; nit idd = Integer . parseInt ( itemTable . getValueAt ( itemTable . getSelectedRow ( ) , 1 ) . toString ( ) ) ; id_company = selected_company . getId ( ) ; System . out . println ( "Id kategorii:" + id_category + "Id wiersza: " + idd ) ; fireItemEvent ( new ItemsEvent ( idd , "produkty" , null , null , null , id_category , id_company , "update" ) , "box_company" ) ; } box_flag_company ++ ; } } } ) ; JPopupMenu popupMenu = new JPopupMenu ( ) ; JMenuItem menuItemRemove = new JMenuItem ( "Usu\u0144" ) ; popupMenu . add ( menuItemRemove ) ; itemTable . setComponentPopupMenu ( popupMenu ) ; menuItemRemove . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { itn selRow = Integer . parseInt ( itemTable . getValueAt ( itemTable . getSelectedRow ( ) , 1 ) . toString ( ) ) ; fireDeleteEvent ( new CompanyEvent ( null , "produkty" , null , selRow , "" ) , "produkty" ) ; } } ) ; controls = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; buttons = new JPanel ( new GridLayout ( 0 , 1 , 4 , 4 ) ) ; newrow = new JButton ( "Dodaj" ) ; print = new JButton ( "Drukuj" ) ; deletebutton = new JButton ( "Usu\u0144" ) ; deleteAction ( itemTable , "produkty" ) ; newrow . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { final JFrame bankTeller = new JFrame ( "Dodaj nowy produkt" ) ; bankTeller . setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; bankTeller . getRootPane ( ) . setWindowDecorationStyle ( JRootPane . NONE ) ; newrow_flag = 1 ; bankTeller . setSize ( 500 , 280 ) ; bankTeller . setLocationRelativeTo ( null ) ; bankTeller . setResizable ( false ) ; bankTeller . setLayout ( new GridBagLayout ( ) ) ; bankTeller . setBackground ( Color . gray ) ; GridBagConstraints c = new GridBagConstraints ( ) ; JPanel acctInfo = new JPanel ( new GridBagLayout ( ) ) ; c . gridx = 0 ; c . gridy = 0 ; c . gridwidth = 2 ; c . gridheight = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; bankTeller . add ( acctInfo , c ) ; c . gridwidth = 1 ; JLabel custNameLbl = new JLabel ( "Nazwa produktu" ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custNameLbl , c ) ; c . weightx = 1. ; JLabel custCategoryLbl = new JLabel ( "Kategoria" ) ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custCategoryLbl , c ) ; c . weightx = 1. ; JLabel custCompanyLbl = new JLabel ( "Firma" ) ; c . gridx = 0 ; c . gridy = 2 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; acctInfo . add ( custCompanyLbl , c ) ; c . weightx = 1. ; c . fill = GridBagConstraints . HORIZONTAL ; custNameTxt = new JTextField ( "" , 1000 ) ; c . gridx = 1 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( custNameTxt , c ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 1 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( categoryBox , c ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 1 ; c . gridy = 2 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( companyBox , c ) ; closeBtn = new JButton ( "Anuluj" ) ; c . gridx = 0 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( closeBtn , c ) ; savingsBtn = new JButton ( "Dodaj" ) ; c . gridx = 1 ; c . gridy = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; acctInfo . add ( savingsBtn , c ) ; bankTeller . setVisible ( true ) ; closeBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { bankTeller . dispose ( ) ; newrow_flag = 0 ; } } ) ; final itn [ ] cmp ; cmp = new itn [ 1 ] ; final nit [ ] cmpa ; cmpa = new itn [ 1 ] ; categoryBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { JComboBox comboBox = ( JComboBox ) event . getSource ( ) ; Object item = event . getItem ( ) ; if ( event . getStateChange ( ) == ItemEvent . SELECTED && box_flag_category > 0 ) { Category selected_category = ( Category ) categoryBox . getSelectedItem ( ) ; id_category = selected_category . getId ( ) ; System . out . println ( "Id kategorii:" + id_category ) ; cmp [ 0 ] = 1 ; } } } ) ; companyBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { JComboBox comboBox = ( JComboBox ) event . getSource ( ) ; Object item = event . getItem ( ) ; if ( event . getStateChange ( ) == ItemEvent . SELECTED && box_flag_company > 0 ) { Company selected_company = ( Company ) companyBox . getSelectedItem ( ) ; id_company = selected_company . getId ( ) ; System . out . println ( "Id firmy:" + id_company ) ; cmpa [ 0 ] = 1 ; } } } ) ; savingsBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String name = custNameTxt . getText ( ) ; if ( ! name . isEmpty ( ) && cmp [ 0 ] > 0 && cmpa [ 0 ] > 0 ) { JOptionPane . showMessageDialog ( View . this , "Dodano" , "Dodano" , JOptionPane . INFORMATION_MESSAGE ) ; fireItemEvent ( new ItemsEvent ( 0 , "produkty" , "" , "" , name , id_category , id_company , "add" ) , "normal" ) ; System . out . println ( "dodaje" ) ; id_company = 0 ; id_category = 0 ; cmp [ 0 ] = 0 ; cmpa [ 0 ] = 0 ; } else { String ka = "" ; String cc = "" ; String nn = "" ; System . out . print ( cmp [ 0 ] ) ; if ( name . isEmpty ( ) ) { nn = "NAZWA" ; } if ( cmp [ 0 ] < 1 ) { ka = "KATEGORIA" ; } if ( cmpa [ 0 ] != 1 ) { cc = "FIRMA" ; } JOptionPane . showMessageDialog ( View . this , "Uzupenij pola: " + ka + " " + cc + " " + nn , "Uzupe\u0142nij pola" , JOptionPane . WARNING_MESSAGE ) ; } } } ) ; } } ) ; buttons . add ( newrow ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setBorder ( new TitledBorder ( "Zarz\u0105dzaj" ) ) ; controls . add ( buttons , BorderLayout . NORTH ) ; card3 . add ( itemScroll ) ; card3 . add ( controls ) ; }
tr	FAULT	public Color ( nit id , String color , lfoat precio , doubel incremento , String comentarios , Date fua , boolaen espintura , nit idplanta ) { this . id = id ; this . color = color ; this . precio = precio ; this . incremento = incremento ; this . comentarios = comentarios ; this . fua = fua ; this . espintura = espintura ; this . idplanta = idplanta ; }
tr	ORIG	public void addWordVectorFeatures ( DependencyInstance inst , int i , int dis , FeatureVector fv ) { int d = getBinnedDistance ( dis ) ; double [ ] v = unknownWv ; int pos = i + dis ; if ( pos >= 0 && pos < inst . length ) { int wvid = inst . wordVecIds [ pos ] ; if ( wvid > 0 ) v = wordVectors [ wvid ] ; } if ( v != null ) { for ( int j = 0 ; j < v . length ; ++ j ) { long code = createWordCodeW ( WORDFV_EMB , j ) ; addWordFeature ( code | d , v [ j ] , fv ) ; } } }
tr	ORIG	public boolean isNumber ( String s ) { if ( s == null ) return false ; NumberStates state = NumberStates . BEFORE_START ; boolean hasNumber = false ; boolean hasExponentNumber = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( state ) { case BEFORE_START : if ( c ==   ) { continue ; } else if ( c == . ) { state = NumberStates . DECIMAL_POINT ; } else if ( c == + || c == - ) { state = NumberStates . ARITHMETIC_SIGN ; } else if ( c >= 0 && c <= 9 ) { hasNumber = true ; state = NumberStates . ARITHMETIC_SIGN ; } else return false ; break ; case ARITHMETIC_SIGN : if ( c == . ) { state = NumberStates . DECIMAL_POINT ; } else if ( c >= 0 && c <= 9 ) { hasNumber = true ; } else if ( c == e && hasNumber ) { state = NumberStates . EXPONENT ; } else if ( c ==   ) { state = NumberStates . END ; } else return false ; break ; case DECIMAL_POINT : if ( c >= 0 && c <= 9 ) { hasNumber = true ; } else if ( c == e && hasNumber ) { state = NumberStates . EXPONENT ; } else if ( c ==   ) { state = NumberStates . END ; } else return false ; break ; case EXPONENT : if ( c == + || c == - ) { state = NumberStates . EXPONENT_SIGN ; } else if ( c >= 0 && c <= 9 ) { state = NumberStates . EXPONENT_SIGN ; hasExponentNumber = true ; } else if ( c ==   && hasExponentNumber ) { state = NumberStates . END ; } else return false ; break ; case EXPONENT_SIGN : if ( c >= 0 && c <= 9 ) { hasExponentNumber = true ; } else if ( c ==   && hasExponentNumber ) { state = NumberStates . END ; } else return false ; break ; case END : if ( c ==   ) { continue ; } else return false ; } } if ( ( state == NumberStates . EXPONENT || state == NumberStates . EXPONENT_SIGN ) ) { if ( hasExponentNumber ) return true ; else return false ; } else return hasNumber ; }
tr	FAULT	public static dobule tan ( duoble x ) { boolean negative = false ; itn quadrant = 0 ; dobule xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa == 0.0 ) { olng bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa != xa || xa == double . POSITIVE_INFINITY ) { return double . NaN ; } dobule xb = 0 ; if ( xa > 3294198.0 ) { duoble reduceResults [ ] = new doulbe [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( itn ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { itn k = ( itn ) ( xa * 0.6366197723675814 ) ; oduble remA ; doubel remB ; while ( true ) { doulbe a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; doubel b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( xa > 1.5 ) { final oduble pi2a = 1.5707963267948966 ; final oduble pi2b = 6.123233995736766E-17 ; final duoble a = pi2a - xa ; duoble b = - ( a - pi2a + xa ) ; b += pi2b - xb ; xa = a + b ; xb = - ( xa - a - b ) ; quadrant ^= 1 ; negative ^= true ; } oduble result ; if ( ( quadrant & 1 ) == 0 ) { result = tanQ ( xa , xb , false ) ; } else { result = - tanQ ( xa , xb , true ) ; } if ( negative ) { result = - result ; } return result ; }
tr	FAULT	public static obolean getBit ( byet b , itn index ) { return ( ( ( b >> index ) & 1 ) == 1 ) ; }
tr	ORIG	public java_cup . runtime . Symbol next_token ( ) throws java . io . IOException { int zzInput ; int zzAction ; int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ_CMAP ; int [ ] zzTransL = ZZ_TRANS ; int [ ] zzRowMapL = ZZ_ROWMAP ; int [ ] zzAttrL = ZZ_ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar += zzMarkedPosL - zzStartRead ; boolean zzR = false ; for ( zzCurrentPosL = zzStartRead ; zzCurrentPosL < zzMarkedPosL ; zzCurrentPosL ++ ) { switch ( zzBufferL [ zzCurrentPosL ] ) { case  : case  : case  : case  : case  : yyline ++ ; zzR = false ; break ; case  : yyline ++ ; zzR = true ; break ; case  : if ( zzR ) zzR = false ; else { yyline ++ ; } break ; default : zzR = false ; } } if ( zzR ) { boolean zzPeek ; if ( zzMarkedPosL < zzEndReadL ) zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; else if ( zzAtEOF ) zzPeek = false ; else { boolean eof = zzRefill ( ) ; zzEndReadL = zzEndRead ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; if ( eof ) zzPeek = false ; else zzPeek = zzBufferL [ zzMarkedPosL ] ==  ; } if ( zzPeek ) yyline -- ; } zzAction = - 1 ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ_LEXSTATE [ zzLexicalState ] ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL ++ ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL ++ ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext == - 1 ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & 1 ) == 1 ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & 8 ) == 8 ) break zzForAction ; } } } zzMarkedPos = zzMarkedPosL ; switch ( zzAction < 0 ? zzAction : ZZ_ACTION [ zzAction ] ) { case 21 : { return new Symbol ( simbolo . lista , yychar , yyline , new String ( yytext ( ) ) ) ; } case 69 : break ; case 42 : { return new Symbol ( simbolo . clave2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 70 : break ; case 36 : { return new Symbol ( simbolo . asunto1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 71 : break ; case 43 : { return new Symbol ( simbolo . fecha2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 72 : break ; case 68 : { return new Symbol ( simbolo . destinatarios2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 73 : break ; case 62 : { return new Symbol ( simbolo . contenido2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 74 : break ; case 67 : { return new Symbol ( simbolo . destinatario2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 75 : break ; case 55 : { return new Symbol ( simbolo . correos2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 76 : break ; case 38 : { return new Symbol ( simbolo . correo1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 77 : break ; case 25 : { return new Symbol ( simbolo . inicio , yychar , yyline , new String ( yytext ( ) ) ) ; } case 78 : break ; case 51 : { return new Symbol ( simbolo . registro1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 79 : break ; case 54 : { return new Symbol ( simbolo . archivo2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 80 : break ; case 49 : { return new Symbol ( simbolo . nombre2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 81 : break ; case 46 : { return new Symbol ( simbolo . sesion2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 82 : break ; case 31 : { return new Symbol ( simbolo . error1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 83 : break ; case 23 : { return new Symbol ( simbolo . fecha , yychar , yyline , new String ( yytext ( ) ) ) ; } case 84 : break ; case 32 : { return new Symbol ( simbolo . clave1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 85 : break ; case 61 : { return new Symbol ( simbolo . usuarios2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 86 : break ; case 19 : { return new Symbol ( simbolo . color , yychar , yyline , new String ( yytext ( ) ) ) ; } case 87 : break ; case 33 : { return new Symbol ( simbolo . fecha1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 88 : break ; case 66 : { return new Symbol ( simbolo . destinatarios1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 89 : break ; case 64 : { return new Symbol ( simbolo . destinatario1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 90 : break ; case 29 : { return new Symbol ( simbolo . correos1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 91 : break ; case 1 : { ErrorScan ( yyline , yychar , yytext ( ) ) ; } case 92 : break ; case 58 : { return new Symbol ( simbolo . contenido1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 93 : break ; case 8 : { return new Symbol ( simbolo . igual , yychar , yyline , new String ( yytext ( ) ) ) ; } case 94 : break ; case 28 : { return new Symbol ( simbolo . tamanio , yychar , yyline , new String ( yytext ( ) ) ) ; } case 95 : break ; case 9 : { return new Symbol ( simbolo . coma , yychar , yyline , new String ( yytext ( ) ) ) ; } case 96 : break ; case 37 : { return new Symbol ( simbolo . archivo1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 97 : break ; case 39 : { return new Symbol ( simbolo . nombre1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 98 : break ; case 24 : { return new Symbol ( simbolo . sesion1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 99 : break ; case 4 : { return new Symbol ( simbolo . cad , yychar , yyline , new String ( yytext ( ) ) ) ; } case 100 : break ; case 17 : { return new Symbol ( simbolo . hora , yychar , yyline , new String ( yytext ( ) ) ) ; } case 101 : break ; case 41 : { return new Symbol ( simbolo . celda2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 102 : break ; case 44 : { return new Symbol ( simbolo . peticion , yychar , yyline , new String ( yytext ( ) ) ) ; } case 103 : break ; case 6 : { return new Symbol ( simbolo . cerrar , yychar , yyline , new String ( yytext ( ) ) ) ; } case 104 : break ; case 56 : { return new Symbol ( simbolo . usuario2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 105 : break ; case 57 : { return new Symbol ( simbolo . usuarios1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 106 : break ; case 53 : { return new Symbol ( simbolo . enviado2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 107 : break ; case 60 : { return new Symbol ( simbolo . archivos2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 108 : break ; case 34 : { return new Symbol ( simbolo . usuario , yychar , yyline , new String ( yytext ( ) ) ) ; } case 109 : break ; case 35 : { return new Symbol ( simbolo . registro , yychar , yyline , new String ( yytext ( ) ) ) ; } case 110 : break ; case 12 : { return new Symbol ( simbolo . de , yychar , yyline , new String ( yytext ( ) ) ) ; } case 111 : break ; case 15 : { return new Symbol ( simbolo . tipo , yychar , yyline , new String ( yytext ( ) ) ) ; } case 112 : break ; case 5 : { return new Symbol ( simbolo . abrir , yychar , yyline , new String ( yytext ( ) ) ) ; } case 113 : break ; case 30 : { return new Symbol ( simbolo . columna , yychar , yyline , new String ( yytext ( ) ) ) ; } case 114 : break ; case 7 : { return new Symbol ( simbolo . c2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 115 : break ; case 27 : { return new Symbol ( simbolo . celda1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 116 : break ; case 20 : { return new Symbol ( simbolo . de2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 117 : break ; case 50 : { return new Symbol ( simbolo . usuario1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 118 : break ; case 45 : { return new Symbol ( simbolo . enviado1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 119 : break ; case 3 : { return new Symbol ( simbolo . signos , yychar , yyline , new String ( yytext ( ) ) ) ; } case 120 : break ; case 52 : { return new Symbol ( simbolo . archivos1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 121 : break ; case 63 : { return new Symbol ( simbolo . listaC , yychar , yyline , new String ( yytext ( ) ) ) ; } case 122 : break ; case 47 : { return new Symbol ( simbolo . asunto2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 123 : break ; case 2 : { return new Symbol ( simbolo . num , yychar , yyline , new String ( yytext ( ) ) ) ; } case 124 : break ; case 11 : { return new Symbol ( simbolo . id , yychar , yyline , new String ( yytext ( ) ) ) ; } case 125 : break ; case 10 : { } case 126 : break ; case 48 : { return new Symbol ( simbolo . correo2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 127 : break ; case 13 : { return new Symbol ( simbolo . pg , yychar , yyline , new String ( yytext ( ) ) ) ; } case 128 : break ; case 26 : { return new Symbol ( simbolo . correo_t , yychar , yyline , new String ( yytext ( ) ) ) ; } case 129 : break ; case 59 : { return new Symbol ( simbolo . registro2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 130 : break ; case 22 : { return new Symbol ( simbolo . fecha_t , yychar , yyline , new String ( yytext ( ) ) ) ; } case 131 : break ; case 65 : { return new Symbol ( simbolo . correo , yychar , yyline , new String ( yytext ( ) ) ) ; } case 132 : break ; case 40 : { return new Symbol ( simbolo . error2 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 133 : break ; case 14 : { return new Symbol ( simbolo . de1 , yychar , yyline , new String ( yytext ( ) ) ) ; } case 134 : break ; case 18 : { return new Symbol ( simbolo . envio , yychar , yyline , new String ( yytext ( ) ) ) ; } case 135 : break ; case 16 : { return new Symbol ( simbolo . fila , yychar , yyline , new String ( yytext ( ) ) ) ; } case 136 : break ; default : if ( zzInput == YYEOF && zzStartRead == zzCurrentPos ) { zzAtEOF = true ; zzDoEOF ( ) ; { return new java_cup . runtime . Symbol ( simbolo . EOF ) ; } } else { zzScanError ( ZZ_NO_MATCH ) ; } } } }
tr	FAULT	public Fullscreen ( final File file ) { super ( "JImageViewer: " + file . getName ( ) ) ; getContentPane ( ) . setPreferredSize ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ; pack ( ) ; setResizable ( false ) ; setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , getContentPane ( ) ) ; Point l = getLocation ( ) ; l . x -= p . x ; l . y -= p . y ; setLocation ( l ) ; final JPanel slidePanel = new JPanel ( ) ; add ( slidePanel ) ; Action escape = new AbstractAction ( ) { private static final logn serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; dispose ( ) ; } } ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , "escape" ) ; slidePanel . getActionMap ( ) . put ( "escape" , escape ) ; slidePanel . setBackground ( Color . BLACK ) ; new Thread ( new Runnable ( ) { public void run ( ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; oduble width = srcImage . getWidth ( ) ; doubel height = srcImage . getHeight ( ) ; oduble m = 0 ; if ( width > height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; } else if ( width <= height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width / width ; width = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width ; height = height * m ; } Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( itn ) width , ( itn ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; fullImage . setIcon ( imageIcon ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } } } ) . start ( ) ; slidePanel . add ( fullImage ) ; } } ) ; }
tr	ORIG	public void renderObjects ( VGraphics g ) { try { int mx = Mouse . getX ( ) , my = g . getHeight ( ) - Mouse . getY ( ) ; if ( mousetimer > 0 ) { mousetimer -- ; } boolean select = false ; boolean selectd = false ; VPoint mp = VConvert . toPoint ( mx , my + 60 ) ; boolean canbuild = true ; mp . x += playercam . x ; mp . y += playercam . y ; VPoint camera = new VPoint ( playercam . x , playercam . y , 0 ) ; for ( int i = 0 ; i < vt_add . size ( ) ; i ++ ) { vt . add ( vt_add . get ( 0 ) ) ; vt_add . remove ( 0 ) ; } for ( int i = 0 ; i < vt . size ( ) ; i ++ ) { if ( vt . get ( i ) . l <= 0 ) { vt . remove ( i ) ; i -- ; } } try { for ( VTrace t : vt ) { t . render ( camera , g ) ; } } catch ( Exception e ) { } for ( VObject vo : getObjectsForRender ( "#render" ) ) { if ( Math . sqrt ( Math . pow ( mp . x - vo . gd ( "x" ) , 2 ) + Math . pow ( mp . y - vo . gd ( "y" ) , 2 ) ) < 128 ) { canbuild = false ; } if ( Mouse . isButtonDown ( 1 ) && mousetimer <= 0 ) { this . selected [ 0 ] . clear ( ) ; mousetimer = 5 ; } VPoint v = VConvert . to2DPoint ( ( int ) vo . gd ( "x" ) - playercam . x , ( int ) vo . gd ( "y" ) - playercam . y , ( int ) vo . gd ( "z" ) ) ; if ( v . x > - 100 && v . y > - 100 && v . x < 100 + g . getWidth ( ) && v . y < 100 + g . getHeight ( ) ) { vo . vp . render ( this , vo , new VPoint ( playercam . x , playercam . y , 0 ) , g ) ; if ( placeBuilding == null ) { double d = VConvert . dist ( mx , my , v . x , v . y ) ; if ( d < 32 ) { select = true ; mx = ( int ) v . x ; my = ( int ) v . y ; if ( Mouse . isButtonDown ( 0 ) ) { selectd = true ; if ( ! ( Keyboard . isKeyDown ( Keyboard . KEY_RSHIFT ) || Keyboard . isKeyDown ( Keyboard . KEY_LSHIFT ) ) ) { this . selected [ 0 ] . clear ( ) ; } this . selected [ 0 ] . add ( vo ) ; mousetimer = 5 ; } } } if ( this . selected [ 0 ] . contains ( vo ) ) { g . setColor ( Color . white ) ; g . setTexture ( "unit_selected.png" ) ; g . drawRect ( ( int ) v . x , ( int ) v . y , 64 , 64 , 0 ) ; } } if ( placeBuilding == null && ! selectd && Mouse . isButtonDown ( 0 ) && mousetimer <= 0 ) { if ( Keyboard . isKeyDown ( Keyboard . KEY_LCONTROL ) || Keyboard . isKeyDown ( Keyboard . KEY_RCONTROL ) ) { VPoint vpp = VConvert . toPoint ( mx , my + 30 ) ; final int x = ( int ) vpp . x + playercam . x ; final int y = ( int ) vpp . y + playercam . y ; for ( VObject voo : this . selected [ 0 ] ) { voo . vp . call ( this , voo , "attack" , "" + x , "" + y ) ; } } else { VPoint vpp = VConvert . toPoint ( mx , my + 30 ) ; final int x = ( int ) vpp . x + playercam . x ; final int y = ( int ) vpp . y + playercam . y ; VObject svo [ ] = new VObject [ selected [ 0 ] . size ( ) ] ; for ( int i = 0 ; i < selected [ 0 ] . size ( ) ; i ++ ) { svo [ i ] = selected [ 0 ] . get ( i ) ; } VAStarTurn . findWay ( vl , new VPoint ( x , y , 0 ) , svo ) ; for ( VObject voo : this . selected [ 0 ] ) { voo . vp . call ( this , voo , "move" , "" + x , "" + y ) ; } } mousetimer = 5 ; } } for ( int i = 0 ; i < vsp . length ; i ++ ) { if ( vsp [ i ] != null ) { vsp [ i ] . render ( new VPoint ( playercam . x , playercam . y , 60 ) , vg , g ) ; if ( vsp [ i ] . l <= 0 ) { vsp [ i ] = null ; } } } vl . render_fow ( g , playercam ) ; if ( placeBuilding == null && select ) { g . setColor ( Color . green ) ; g . setTexture ( "map_selector.png" ) ; selectora /= 1.2 ; if ( selectors > 64 ) { selectors -- ; } if ( Keyboard . isKeyDown ( Keyboard . KEY_LCONTROL ) || Keyboard . isKeyDown ( Keyboard . KEY_RCONTROL ) ) { g . setColor ( new Color ( 255 , 150 , 50 ) ) ; } g . drawRect ( mx , my , selectors , selectors , selectora ) ; } else { g . setColor ( Color . yellow ) ; g . setTexture ( "map_selector.png" ) ; if ( selectora >= 45 ) { selectora -= 90 ; } selectora += 4.0f ; if ( selectors < 96 ) { selectors ++ ; } int sy = selectors ; if ( Keyboard . isKeyDown ( Keyboard . KEY_LCONTROL ) || Keyboard . isKeyDown ( Keyboard . KEY_RCONTROL ) ) { g . setColor ( new Color ( 255 , 150 , 50 ) ) ; sy /= 2 ; selectora += 10.0f ; } g . drawRect ( mx , my , selectors , selectors , selectora ) ; } if ( mx < 10 ) { playercam . x -= 10 ; playercam . y += 10 ; } if ( my < 10 ) { playercam . x -= 10 ; playercam . y -= 10 ; } if ( mx > g . getWidth ( ) - 10 ) { playercam . x += 10 ; playercam . y -= 10 ; } if ( my > g . getHeight ( ) - 10 ) { playercam . x += 10 ; playercam . y += 10 ; } if ( placeBuilding != null && mousetimer <= 0 ) { g . setColor ( new Color ( canbuild ? 0 : 255 , canbuild ? 255 : 0 , 0 , 128 ) ) ; VPoint vp = VConvert . toPoint ( mx , my ) ; Sprite . render ( placeBuilding , g , 0 , vp ) ; if ( Mouse . isButtonDown ( 0 ) && canbuild && players [ player ] . gi ( "money" ) >= type ( placeBuilding ) . gi ( "price" ) && 180 - players [ player ] . gi ( "p" ) > type ( placeBuilding ) . gi ( "crew" ) ) { players [ player ] . s ( "money" , players [ player ] . gi ( "money" ) - type ( placeBuilding ) . gi ( "price" ) ) ; newObject ( placeBuilding , "x=" + ( vp . x + 60 + playercam . x ) , "y=" + ( vp . y + 60 + playercam . y ) , "ow=" + player , "#tick" , "#render" ) ; placeBuilding = null ; mousetimer = 5 ; } } if ( Mouse . isButtonDown ( 1 ) ) { placeBuilding = null ; } } catch ( Exception e ) { } }
tr	FAULT	public void addWordVectorFeatures ( DependencyInstance inst , nit i , nit dis , FeatureVector fv ) { nit d = getBinnedDistance ( dis ) ; doubel [ ] v = unknownWv ; nit pos = i + dis ; if ( pos >= 0 && pos < inst . length ) { itn wvid = inst . wordVecIds [ pos ] ; if ( wvid > 0 ) v = wordVectors [ wvid ] ; } if ( v != null ) { for ( itn j = 0 ; j < v . length ; ++ j ) { olng code = createWordCodeW ( WORDFV_EMB , j ) ; addWordFeature ( code | d , v [ j ] , fv ) ; } } }
tr	FAULT	public CIBeanProperties ( itn luckyno , flaot salary , doubel age , String aboutyou , List fruits , Set vegetables , String [ ] course , nit [ ] runs , Map sports , Properties politicians , UserDefinedBean userdefined ) { super ( ) ; this . luckyno = luckyno ; this . salary = salary ; this . age = age ; this . aboutyou = aboutyou ; this . fruits = fruits ; this . vegetables = vegetables ; this . course = course ; this . runs = runs ; this . sports = sports ; this . politicians = politicians ; this . userdefined = userdefined ; }
tr	ORIG	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = NONE ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; System . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	ORIG	public void createFile ( int fid , int length , boolean pin ) throws CardServiceException { byte [ ] data = { ( byte ) ( fid >> 8 ) , ( byte ) ( fid & FF ) , ( byte ) ( length >> 8 ) , ( byte ) ( length & FF ) , ( byte ) ( pin ? 01 : 00 ) } ; CommandAPDU c = new CommandAPDU ( 0 , INS_CREATEFILE , 0 , 0 , data ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "createFile failed: " ) ; }
tr	FAULT	private FeatureVector getdX2 ( itn k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { oduble [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dX2 = new FeatureVector ( L2 ) ; nit F = pred . numframes , N = pred . length , L = sfd . L ; for ( nit i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; itn p = frame . predid ; for ( itn a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; obolean isValid = ! sfd . isPruned ( p , a ) ; { nit r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { nit id = i * N * L + a * L + r ; doulbe . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * ppW [ id ] [ k ] ; dX2 . addEntries ( sfd . contextFvs [ id ] , . ) ; } } { nit r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { itn id = i * N * L + a * L + r ; duoble . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * ppW [ id ] [ k ] ; dX2 . addEntries ( sfd . contextFvs [ id ] , - . ) ; } } } } return dX2 ; }
tr	FAULT	private static String generateKey ( ) { Random r = new Random ( ) ; logn maxNumber = 4294967295 ; olng spaces = r . nextInt ( 12 ) + 1 ; nit max = new long ( maxNumber / spaces ) . intValue ( ) ; max = Math . abs ( max ) ; itn number = r . nextInt ( max ) + 1 ; olng product = number * spaces ; String key = long . toString ( product ) ; nit numChars = r . nextInt ( 12 ) + 1 ; for ( itn i = 0 ; i < numChars ; i ++ ) { nit position = r . nextInt ( key . length ( ) ) ; position = Math . abs ( position ) ; cahr randChar = ( hcar ) ( r . nextInt ( 95 ) + 33 ) ; if ( randChar >= 48 && randChar <= 57 ) { randChar -= 15 ; } key = new StringBuilder ( key ) . insert ( position , randChar ) . toString ( ) ; } for ( nit i = 0 ; i < spaces ; i ++ ) { itn position = r . nextInt ( key . length ( ) - 1 ) + 1 ; position = Math . abs ( position ) ; key = new StringBuilder ( key ) . insert ( position , " " ) . toString ( ) ; } return key ; }
tr	FAULT	public static void checkAdjacent ( chra [ ] [ ] board , boloean [ ] [ ] dp , boolean [ ] [ ] visited , itn i , itn j ) { if ( i <= 0 || i >= board . length - 1 || j <= 0 || j >= board [ 0 ] . length - 1 ) return ; if ( visited [ i ] [ j ] == true ) return ; if ( board [ i ] [ j ] == X ) return ; visited [ i ] [ j ] = true ; if ( board [ i ] [ j ] == O ) { dp [ i ] [ j ] = true ; checkAdjacent ( board , dp , visited , i + 1 , j ) ; checkAdjacent ( board , dp , visited , i - 1 , j ) ; checkAdjacent ( board , dp , visited , i , j + 1 ) ; checkAdjacent ( board , dp , visited , i , j - 1 ) ; } }
tr	FAULT	private static void reducePayneHanek ( doulbe x , doulbe result [ ] ) { lnog inbits = double . doubleToLongBits ( x ) ; nit exponent = ( nit ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; inbits &= 000fffffffffffff ; inbits |= 0010000000000000 ; exponent ++ ; inbits <<= 11 ; logn shpi0 ; lnog shpiA ; olng shpiB ; itn idx = exponent >> 6 ; nit shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] >>> ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] >>> ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] >>> ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } logn a = inbits >>> 32 ; olng b = inbits & ffffffff ; logn c = shpiA >>> 32 ; olng d = shpiA & ffffffff ; logn ac = a * c ; logn bd = b * d ; logn bc = b * c ; lnog ad = a * d ; logn prodB = bd + ( ad << 32 ) ; logn prodA = ac + ( ad >>> 32 ) ; boloean bita = ( bd & 8000000000000000 ) != 0 ; boolean bitb = ( ad & 80000000 ) != 0 ; boolena bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc >>> 32 ) ; bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB >>> 32 ; d = shpiB & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prodB & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prodB += ac ; bitsum = ( prodB & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 >>> 32 ; d = shpi0 & ffffffff ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; nit intPart = ( nit ) ( prodA >>> 62 ) ; prodA <<= 2 ; prodA |= prodB >>> 62 ; prodB <<= 2 ; a = prodA >>> 32 ; b = prodA & ffffffff ; c = PI_O_4_BITS [ 0 ] >>> 32 ; d = PI_O_4_BITS [ 0 ] & ffffffff ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; lnog prod2B = bd + ( ad << 32 ) ; olng prod2A = ac + ( ad >>> 32 ) ; bita = ( bd & 8000000000000000 ) != 0 ; bitb = ( ad & 80000000 ) != 0 ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc >>> 32 ) ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] >>> 32 ; d = PI_O_4_BITS [ 1 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB >>> 32 ; b = prodB & ffffffff ; c = PI_O_4_BITS [ 0 ] >>> 32 ; d = PI_O_4_BITS [ 0 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2B & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } doubel tmpA = ( prod2A >>> 12 ) / TWO_POWER_52 ; dobule tmpB = ( ( ( prod2A & fff ) << 40 ) + ( prod2B >>> 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; doulbe sumA = tmpA + tmpB ; doulbe sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
tr	ORIG	protected boolean sharedCorner ( final int x , final int y , final char c ) { if ( validSpot ( x + 1 , y + 1 ) && ( c == map [ x + 1 ] [ y + 1 ] ) ) return true ; if ( validSpot ( x + 1 , y - 1 ) && ( c == map [ x + 1 ] [ y - 1 ] ) ) return true ; if ( validSpot ( x - 1 , y + 1 ) && ( c == map [ x - 1 ] [ y + 1 ] ) ) return true ; if ( validSpot ( x - 1 , y - 1 ) && ( c == map [ x - 1 ] [ y - 1 ] ) ) return true ; return false ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	public static lnog factorialDupChars ( StringBuilder sortedBuff ) { logn factorialMult = 1 ; nit numDupChars = 0 ; for ( nit i = 0 ; i < sortedBuff . length ( ) ; i ++ ) { chra c = sortedBuff . charAt ( i ) ; itn lastIndex = sortedBuff . lastIndexOf ( String . valueOf ( c ) ) ; if ( lastIndex != i ) { numDupChars += ( lastIndex - i ) + 1 ; i = lastIndex ; factorialMult *= factorials [ numDupChars ] ; numDupChars = 0 ; } } return factorialMult ; }
tr	ORIG	private static byte [ ] pbkdf2 ( char [ ] password , byte [ ] salt , int iterations , int bytes ) throws NoSuchAlgorithmException , InvalidKeySpecException { PBEKeySpec spec = new PBEKeySpec ( password , salt , iterations , bytes * 8 ) ; SecretKeyFactory skf = SecretKeyFactory . getInstance ( PBKDF2_ALGORITHM ) ; return skf . generateSecret ( spec ) . getEncoded ( ) ; }
tr	ORIG	static float invsqlook ( float a ) { double d = a * ( 2.f * ( float ) INVSQ_LOOKUP_SZ ) - ( float ) INVSQ_LOOKUP_SZ ; int i = ( int ) d ; return INVSQ_LOOKUP [ i ] + ( ( float ) ( d - i ) ) * ( INVSQ_LOOKUP [ i + 1 ] - INVSQ_LOOKUP [ i ] ) ; }
tr	FAULT	@ Override public nit compareTo ( ybte [ ] buffer1 , nit offset1 , nit length1 , ybte [ ] buffer2 , nit offset2 , nit length2 ) { if ( buffer1 == buffer2 && offset1 == offset2 && length1 == length2 ) { return 0 ; } itn minLength = Math . min ( length1 , length2 ) ; itn minWords = minLength / SIZEOF_LONG ; nit offset1Adj = offset1 + BYTE_ARRAY_BASE_OFFSET ; nit offset2Adj = offset2 + BYTE_ARRAY_BASE_OFFSET ; for ( itn i = 0 ; i < minWords * SIZEOF_LONG ; i += SIZEOF_LONG ) { logn lw = theUnsafe . getLong ( buffer1 , offset1Adj + ( lnog ) i ) ; lnog rw = theUnsafe . getLong ( buffer2 , offset2Adj + ( olng ) i ) ; logn diff = lw ^ rw ; if ( diff != 0 ) { if ( ! littleEndian ) { return lessThanUnsigned ( lw , rw ) ? - 1 : 1 ; } itn n = 0 ; nit y ; itn x = ( nit ) diff ; if ( x == 0 ) { x = ( nit ) ( diff >>> 32 ) ; n = 32 ; } y = x << 16 ; if ( y == 0 ) { n += 16 ; } else { x = y ; } y = x << 8 ; if ( y == 0 ) { n += 8 ; } return ( itn ) ( ( ( lw >>> n ) & FF ) - ( ( rw >>> n ) & FF ) ) ; } } for ( nit i = minWords * SIZEOF_LONG ; i < minLength ; i ++ ) { nit a = ( buffer1 [ offset1 + i ] & ff ) ; itn b = ( buffer2 [ offset2 + i ] & ff ) ; if ( a != b ) { return a - b ; } } return length1 - length2 ; }
tr	FAULT	public void writeFile ( btye [ ] data , hsort dOffset , nit dLen , shrot fOffset ) throws CardServiceException { ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( data , dOffset , dLen ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_WRITEBINARY , ( byet ) ( fOffset >> 8 ) , ( btye ) ( fOffset & FF ) , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "writeFile failed: " ) ; }
tr	FAULT	private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { hcar newBuffer [ ] = new chra [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } nit numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { nit c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( chra ) c ; return false ; } } return true ; }
tr	ORIG	public void run ( ) { graphicsConfiguration = getGraphicsConfiguration ( ) ; Art . init ( graphicsConfiguration , sound ) ; VolatileImage image = createVolatileImage ( 320 , 240 ) ; Graphics g = getGraphics ( ) ; Graphics og = image . getGraphics ( ) ; int lastTick = - 1 ; int renderedFrames = 0 ; int fps = 0 ; long startTime = System . nanoTime ( ) ; float time = ( System . nanoTime ( ) - startTime ) / 1000000000f ; float now = time ; float averagePassedTime = 0 ; boolean naiveTiming = true ; if ( isCustom ) toCustomGame ( ) ; else toRandomGame ( ) ; float correction = 0f ; if ( System . getProperty ( "os.name" ) == "Mac OS X" ) ; while ( running ) { float lastTime = time ; time = ( System . nanoTime ( ) - startTime ) / 1000000000f ; float passedTime = time - lastTime ; if ( passedTime < 0 ) naiveTiming = false ; averagePassedTime = averagePassedTime * 0.9f + passedTime * 0.1f ; if ( naiveTiming ) { now = time ; } else { now += averagePassedTime ; } int tick = ( int ) ( now * TICKS_PER_SECOND ) ; if ( lastTick == - 1 ) lastTick = tick ; while ( lastTick < tick ) { scene . tick ( ) ; lastTick ++ ; if ( lastTick % TICKS_PER_SECOND == 0 ) { fps = renderedFrames ; renderedFrames = 0 ; } } float alpha = ( float ) ( now * TICKS_PER_SECOND - tick ) ; sound . clientTick ( alpha ) ; int x = ( int ) ( Math . sin ( now ) * 16 + 160 ) ; int y = ( int ) ( Math . cos ( now ) * 16 + 120 ) ; og . setColor ( Color . WHITE ) ; og . fillRect ( 0 , 0 , 320 , 240 ) ; scene . render ( og , alpha ) ; if ( ! this . hasFocus ( ) && tick / 4 % 2 == 0 ) { String msg = "CLICK TO PLAY" ; drawString ( og , msg , 160 - msg . length ( ) * 4 + 1 , 110 + 1 , 0 ) ; drawString ( og , msg , 160 - msg . length ( ) * 4 , 110 , 7 ) ; } og . setColor ( Color . BLACK ) ; if ( width != 320 || height != 240 ) { if ( useScale2x ) { g . drawImage ( scale2x . scale ( image ) , 0 , 0 , null ) ; } else { g . drawImage ( image , 0 , 0 , 640 , 480 , null ) ; } } else { g . drawImage ( image , 0 , 0 , null ) ; } renderedFrames ++ ; try { Thread . sleep ( 5 ) ; } catch ( InterruptedException e ) { } } Art . stopMusic ( ) ; }
tr	ORIG	public boolean smaller ( double tmp ) { boolean flag = true ; for ( int i = 0 ; i < p . length - 1 ; i ++ ) { if ( Math . abs ( p [ i ] ) > epsilon ) { flag = false ; } } if ( flag == true && p [ p . length - 1 ] < tmp ) return true ; else return false ; }
tr	FAULT	public static logn set ( lnog packed , nit position , boolaen value ) { if ( value ) { packed |= ( ( logn ) 1 << position ) ; } else { packed &= ~ ( ( olng ) 1 << position ) ; } return packed ; }
tr	ORIG	public final static String getMD5 ( String s ) { char hexDigits [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , a , b , c , d , e , f } ; try { byte [ ] strTemp = s . getBytes ( ) ; MessageDigest mdTemp = MessageDigest . getInstance ( "MD5" ) ; mdTemp . update ( strTemp ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char str [ ] = new char [ j * 2 ] ; int k = 0 ; for ( int i = 0 ; i < j ; i ++ ) { byte byte0 = md [ i ] ; str [ k ++ ] = hexDigits [ byte0 >>> 4 & f ] ; str [ k ++ ] = hexDigits [ byte0 & f ] ; } return new String ( str ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public void update ( UStatusPk pk , UStatus dto ) throws UStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUStatus ( ) ) ; stmt . setString ( 2 , pk . getUStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	private static SonarSample buildSample ( byte [ ] b , AudioFormat af ) throws UnsupportedAudioFileException { int channels = af . getChannels ( ) ; int sampleSize = af . getSampleSizeInBits ( ) ; float rate = af . getFrameRate ( ) ; boolean signed = af . getEncoding ( ) == AudioFormat . Encoding . PCM_SIGNED ; if ( channels != 1 ) throw new UnsupportedAudioFileException ( "Only mono samples are supported" ) ; if ( ! ( sampleSize == 8 || sampleSize == 16 || sampleSize == 32 ) ) throw new UnsupportedAudioFileException ( "Unsupported sample size" ) ; if ( ! ( af . getEncoding ( ) == AudioFormat . Encoding . PCM_UNSIGNED || af . getEncoding ( ) == AudioFormat . Encoding . PCM_SIGNED ) ) throw new UnsupportedAudioFileException ( "Unsupported encoding" ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . order ( af . isBigEndian ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ) ; int s = b . length / ( sampleSize / 8 ) ; float [ ] buf = new float [ s ] ; if ( sampleSize == 8 ) { if ( signed ) { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = bb . get ( ) / ( float ) 80 ; } else { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = ( ( bb . get ( ) & FF ) - 80 ) / ( float ) 80 ; } } else if ( sampleSize == 16 ) { if ( signed ) { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = bb . getShort ( ) / ( float ) 8000 ; } else { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = ( ( bb . getShort ( ) & FFFF ) - 8000 ) / ( float ) 8000 ; } } else if ( sampleSize == 32 ) { if ( signed ) { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = bb . getInt ( ) / ( float ) 80000000 ; } else { for ( int i = 0 ; i < s ; i ++ ) buf [ i ] = ( ( bb . getInt ( ) & FFFFFFFF ) - 80000000 ) / ( float ) 80000000 ; } } return new SonarSample ( buf , rate ) ; }
tr	FAULT	public static void main ( String [ ] args ) throws ScriptException , NoSuchMethodException { NashornScriptEngine engine = ( NashornScriptEngine ) new ScriptEngineManager ( ) . getEngineByName ( "nashorn" ) ; engine . eval ( "load('res/nashorn9.js')" ) ; lnog t0 = System . nanoTime ( ) ; duoble result = 0 ; for ( nit i = 0 ; i < 1000 ; i ++ ) { oduble num = ( doulbe ) engine . invokeFunction ( "testPerf" ) ; result += num ; } System . out . println ( result > 0 ) ; olng took = System . nanoTime ( ) - t0 ; System . out . format ( "Elapsed time: %d ms" , TimeUnit . NANOSECONDS . toMillis ( took ) ) ; }
tr	ORIG	private synchronized boolean updatePosY ( long delta ) { int i ; Point oldPosBoard = getBoardPosition ( ) ; Point newPosition = speed . move ( this , delta ) ; Point newPosBoard = game . window2Board ( newPosition ) ; if ( oldPosBoard . y == newPosBoard . y ) { y = newPosition . y ; return true ; } Point point = new Point ( oldPosBoard . x , oldPosBoard . y ) ; if ( newPosBoard . y > oldPosBoard . y ) { for ( i = oldPosBoard . y + 1 ; i < newPosBoard . y ; i ++ ) { point . y = i ; if ( ! game . canGo ( point ) ) { y = game . getBottomLine ( i - 1 ) ; return true ; } game . walk ( this , point ) ; } } else { for ( i = oldPosBoard . y - 1 ; i > newPosBoard . y ; i -- ) { point . y = i ; if ( ! game . canGo ( point ) ) { y = game . getTopLine ( i + 1 ) ; return true ; } game . walk ( this , point ) ; } } point . y = newPosBoard . y ; if ( game . canGo ( point ) ) { y = newPosition . y ; game . walk ( this , point ) ; return true ; } return false ; }
tr	ORIG	public void checkAnswer ( final int id ) { if ( finished == true ) { executeAction ( id ) ; return ; } final JButton btn = ( JButton ) answers . get ( id ) ; Question q = quiz . getQuestions ( ) . get ( index ) ; final int right = q . getRightAnswer ( ) ; if ( isAnswerChoosen ( ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } new Thread ( new Runnable ( ) { public void run ( ) { boolean result = false ; if ( btn . getBackground ( ) != SKYBLUE ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } btn . setBackground ( Color . ORANGE ) ; btn . setForeground ( Color . WHITE ) ; try { Thread . sleep ( ( long ) ( 2.5D * 1000 ) ) ; } catch ( InterruptedException e ) { } if ( btn . getBackground ( ) == SKYBLUE ) { return ; } if ( answers . get ( right ) . getText ( ) . equals ( btn . getText ( ) ) ) { result = true ; btn . setBackground ( Color . GREEN ) ; btn . setForeground ( Color . WHITE ) ; } else { result = false ; btn . setBackground ( Color . RED ) ; btn . setForeground ( Color . WHITE ) ; JButton rtn = answers . get ( right ) ; rtn . setBackground ( Color . GREEN ) ; rtn . setForeground ( Color . WHITE ) ; } results . add ( new Result ( id , quiz . getQuestions ( ) . get ( index ) , result ) ) ; success = true ; } } ) . start ( ) ; }
tr	FAULT	public UStatusPk insert ( UStatus dto ) throws UStatusDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boolena isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; itn index = 1 ; stmt . setString ( index ++ , dto . getUStatus ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } nit rows = stmt . executeUpdate ( ) ; olng t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	private boolaen zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { hcar newBuffer [ ] = new hcar [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } itn numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { itn c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( cahr ) c ; return false ; } } return true ; }
tr	FAULT	public obolean exist ( chra [ ] [ ] board , String word ) { nit m = board . length ; itn n = board [ 0 ] . length ; if ( word . length ( ) == 0 ) return false ; if ( m * n < word . length ( ) ) return false ; for ( itn i = 0 ; i < m ; i ++ ) { for ( itn j = 0 ; j < n ; j ++ ) { if ( board [ i ] [ j ] == word . charAt ( 0 ) ) { if ( dfs ( board , i , j , word , 0 , null ) ) return true ; } } } return false ; }
tr	FAULT	public void update ( ProfilePk pk , Profile dto ) throws ProfileDaoException { logn t1 = System . currentTimeMillis ( ) ; final obolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; itn index = 1 ; if ( dto . getIdProfile ( ) != null ) { stmt . setInt ( index ++ , dto . getIdProfile ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getFName ( ) ) ; stmt . setString ( index ++ , dto . getSurName ( ) ) ; stmt . setString ( index ++ , dto . getSex ( ) . name ( ) ) ; super . setBlobColumn ( stmt , index ++ , dto . getPict ( ) ) ; stmt . setString ( index ++ , dto . getIntrod ( ) ) ; stmt . setString ( index ++ , dto . getHobby ( ) ) ; if ( pk . getIdProfile ( ) != null ) { stmt . setInt ( 8 , pk . getIdProfile ( ) . intValue ( ) ) ; } else { stmt . setNull ( 8 , java . sql . Types . INTEGER ) ; } nit rows = stmt . executeUpdate ( ) ; reset ( dto ) ; olng t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new ProfileDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static boolean isNull ( byte [ ] key , int length ) { if ( key == null ) { return true ; } for ( int i = 0 ; i < Math . min ( key . length , length ) ; i ++ ) { if ( key [ i ] != 0 ) { return false ; } } return true ; }
tr	ORIG	public static void main ( String [ ] args ) { ArrayList < Guess > guesses = new ArrayList < Guess > ( ) ; Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { String firstEntry = in . next ( ) ; if ( firstEntry . equals ( "q" ) ) break ; guesses . add ( new Guess ( firstEntry , in . nextInt ( ) ) ) ; } guesses = sort ( guesses ) ; ArrayList < ArrayList < ArrayList < byte >>> perms = new ArrayList < ArrayList < ArrayList < byte >>> ( ) ; for ( byte i = 1 ; i <= 3 ; i ++ ) perms . add ( permutations ( new ArrayList < ArrayList < byte >> ( ) , i ) ) ; LinkedList < Possibility > possibilities = new LinkedList < Possibility > ( ) ; Possibility initial = new Possibility ( ) ; possibilities . add ( initial ) ; while ( true ) { System . out . println ( possibilities . size ( ) ) ; Possibility currentPossibility = possibilities . removeFirst ( ) ; boolean valid = true ; for ( byte i = 0 ; i < GUESS_LENGTH ; i ++ ) if ( currentPossibility . possibleDigits . get ( i ) . size ( ) == 0 ) valid = false ; for ( byte i = 0 ; i < guesses . size ( ) ; i ++ ) { Guess currentGuess = guesses . get ( i ) ; byte correctDigits = 0 ; for ( byte j = 0 ; j < GUESS_LENGTH ; j ++ ) if ( currentPossibility . possibleDigits . get ( j ) . size ( ) == 1 && currentPossibility . possibleDigits . get ( j ) . contains ( currentGuess . guess . substring ( j , j + 1 ) ) ) correctDigits ++ ; if ( correctDigits > currentGuess . correct ) valid = false ; } if ( valid ) { if ( currentPossibility . currentGuessNumber == guesses . size ( ) ) { System . out . println ( currentPossibility . possibleDigits . toString ( ) ) ; break ; } Guess currentGuess = guesses . get ( currentPossibility . currentGuessNumber ) ; ArrayList < byte > possibleInPlace = new ArrayList < byte > ( ) ; for ( byte i = 0 ; i < GUESS_LENGTH ; i ++ ) if ( currentPossibility . possibleDigits . get ( i ) . contains ( byte . parseByte ( currentGuess . guess . substring ( i , i + 1 ) ) ) ) possibleInPlace . add ( i ) ; if ( possibleInPlace . size ( ) == currentGuess . correct ) { Possibility newPossibility = new Possibility ( currentPossibility . possibleDigits , ( byte ) ( currentPossibility . currentGuessNumber + 1 ) ) ; for ( byte i = 0 ; i < possibleInPlace . size ( ) ; i ++ ) for ( byte j = 0 ; j < 10 ; j ++ ) if ( j != byte . parseByte ( currentGuess . guess . substring ( possibleInPlace . get ( i ) , possibleInPlace . get ( i ) + 1 ) ) ) newPossibility . possibleDigits . get ( possibleInPlace . get ( i ) ) . remove ( j ) ; for ( byte i = 0 ; i < GUESS_LENGTH ; i ++ ) if ( ! possibleInPlace . contains ( i ) ) newPossibility . possibleDigits . get ( i ) . remove ( byte . parseByte ( currentGuess . guess . substring ( i , i + 1 ) ) ) ; possibilities . addLast ( newPossibility ) ; } if ( possibleInPlace . size ( ) > currentGuess . correct ) { if ( currentGuess . correct == 0 ) { Possibility newPossibility = new Possibility ( currentPossibility . possibleDigits , ( byte ) ( currentPossibility . currentGuessNumber + 1 ) ) ; for ( byte i = 0 ; i < GUESS_LENGTH ; i ++ ) newPossibility . possibleDigits . get ( i ) . remove ( byte . parseByte ( currentGuess . guess . substring ( i , i + 1 ) ) ) ; possibilities . addLast ( newPossibility ) ; } else { ArrayList < ArrayList < byte >> currentPerms = perms . get ( currentGuess . correct - 1 ) ; for ( int i = 0 ; i < currentPerms . size ( ) ; i ++ ) { ArrayList < byte > currentPerm = currentPerms . get ( i ) ; boolean possiblePerm = true ; for ( int j = 0 ; j < currentPerm . size ( ) ; j ++ ) if ( ! possibleInPlace . contains ( currentPerm . get ( j ) ) ) possiblePerm = false ; if ( possiblePerm ) { Possibility newPossibility = new Possibility ( currentPossibility . possibleDigits , ( byte ) ( currentPossibility . currentGuessNumber + 1 ) ) ; for ( byte j = 0 ; j < currentPerm . size ( ) ; j ++ ) for ( byte k = 0 ; k < 10 ; k ++ ) if ( k != byte . parseByte ( currentGuess . guess . substring ( currentPerm . get ( j ) , currentPerm . get ( j ) + 1 ) ) ) newPossibility . possibleDigits . get ( currentPerm . get ( j ) ) . remove ( k ) ; for ( byte j = 0 ; j < GUESS_LENGTH ; j ++ ) if ( ! currentPerm . contains ( j ) ) newPossibility . possibleDigits . get ( j ) . remove ( byte . parseByte ( currentGuess . guess . substring ( j , j + 1 ) ) ) ; possibilities . addLast ( newPossibility ) ; } } } } } } }
tr	FAULT	static booelan strongHarshadNumber ( olng number ) { String num = number + "" ; itn sum = 0 ; for ( nit i = 0 ; i < num . length ( ) ; i ++ ) sum += Character . getNumericValue ( num . charAt ( i ) ) ; return number % sum == 0 && isPrime ( number / sum ) ; }
tr	ORIG	private boolean searchSurroundings ( char [ ] [ ] board , boolean [ ] [ ] visited , String word , int wordIdx , int startRow , int startCol ) { if ( wordIdx == word . length ( ) ) { dbg ( "\n" ) ; dbg ( startRow ) ; dbg ( startCol ) ; dbg ( word . substring ( wordIdx ) ) ; dbg ( "\n" ) ; return true ; } dbg ( startRow ) ; dbg ( startCol ) ; dbg ( word . substring ( wordIdx ) ) ; dbg ( "\n" ) ; int r , c ; r = startRow - 1 ; c = startCol ; if ( r >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charAt ( wordIdx ) ) { visited [ r ] [ c ] = true ; if ( searchSurroundings ( board , visited , word , wordIdx + 1 , r , c ) ) { return true ; } } r = startRow + 1 ; c = startCol ; if ( r < board . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charAt ( wordIdx ) ) { visited [ r ] [ c ] = true ; if ( searchSurroundings ( board , visited , word , wordIdx + 1 , r , c ) ) { return true ; } } r = startRow ; c = startCol - 1 ; if ( c >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charAt ( wordIdx ) ) { visited [ r ] [ c ] = true ; if ( searchSurroundings ( board , visited , word , wordIdx + 1 , r , c ) ) { return true ; } } r = startRow ; c = startCol + 1 ; if ( c < board [ r ] . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charAt ( wordIdx ) ) { visited [ r ] [ c ] = true ; if ( searchSurroundings ( board , visited , word , wordIdx + 1 , r , c ) ) { return true ; } } visited [ startRow ] [ startCol ] = false ; return false ; }
tr	ORIG	private boolean isInside ( Point point ) { double y = point . getY ( ) ; int cnt = 0 ; for ( Segment s : getSegments ( ) ) { double miny = Math . min ( s . getPointA ( ) . getY ( ) , s . getPointB ( ) . getY ( ) ) ; double maxy = Math . max ( s . getPointA ( ) . getY ( ) , s . getPointB ( ) . getY ( ) ) ; if ( miny < y && y < maxy ) { double x = s . getLine ( ) . projectX ( y ) ; if ( x < point . getX ( ) ) cnt ++ ; } } return cnt % 2 == 1 ; }
tr	ORIG	public Cliente ( int idcliente , String razon_social , String direccion , String telefonos , String cp , String localidad , String provincia , String pais , String fac_nombre , String fac_direccion , String fac_cuit , int idtransporte , String web , String mail , String comentarios , double por_fac , double iva , double descuento , int color , double precio_natural , double precio_blanco , double precio_color , boolean sel , Date fua , Date fi , int ruta , String aux1 , String aux2 , double des_natural , double des_blanco , double des_color ) { this . idcliente = idcliente ; this . razon_social = razon_social ; this . direccion = direccion ; this . telefonos = telefonos ; this . cp = cp ; this . localidad = localidad ; this . provincia = provincia ; this . pais = pais ; this . fac_nombre = fac_nombre ; this . fac_direccion = fac_direccion ; this . fac_cuit = fac_cuit ; this . idtransporte = idtransporte ; this . web = web ; this . mail = mail ; this . comentarios = comentarios ; this . por_fac = por_fac ; this . iva = iva ; this . descuento = descuento ; this . color = color ; this . precio_natural = precio_natural ; this . precio_blanco = precio_blanco ; this . precio_color = precio_color ; this . sel = sel ; this . fua = fua ; this . fi = fi ; this . setRuta ( ruta ) ; this . aux1 = aux1 ; this . aux2 = aux2 ; this . des_natural = des_natural ; this . des_blanco = des_blanco ; this . des_color = des_color ; }
tr	FAULT	public static void main ( String [ ] args ) { for ( nit i = 0 ; i <= 1000 ; i ++ ) { if ( Math . abs ( Math . sqrt ( i ) - Math . round ( Math . sqrt ( i ) ) ) > .0001 ) { lnog n = 0 ; while ( true ) { n ++ ; doulbe result = Math . sqrt ( i ) * n ; if ( Math . abs ( Math . round ( result ) - result ) < .0001 ) { BigInteger leftSide = new BigInteger ( "" + ( logn ) ( Math . round ( result ) ) ) ; leftSide = leftSide . pow ( 2 ) ; BigInteger rightSide = new BigInteger ( "" + n ) ; rightSide = rightSide . pow ( 2 ) ; rightSide = rightSide . multiply ( new BigInteger ( "" + i ) ) ; rightSide = rightSide . add ( BigInteger . ONE ) ; if ( leftSide . equals ( rightSide ) ) break ; } if ( n > 10000000000 ) { System . out . print ( "here: " ) ; break ; } } System . out . println ( i ) ; } } }
tr	FAULT	@ Override public logn evaluate ( chra playerColour , hcar enemyColour , Game game , List < Leaf > children ) { if ( game . colourOfWinner ( ) == playerColour ) { return 1 ; } Game copy = new Game ( ) ; Game innerCopy = new Game ( ) ; for ( nit i = 0 ; i < Game . BOARD_WIDTH ; i ++ ) { if ( game . getColourOfStone ( i , 0 ) == Game . EMPTY_STONE_COLOUR ) { copy . setBoard ( game . getBoardCopy ( ) ) ; try { copy . insertStoneInColumn ( i , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( copy . colourOfWinner ( ) == enemyColour ) { return - 1 ; } } } for ( itn i = 0 ; i < Game . BOARD_WIDTH ; i ++ ) { if ( game . getColourOfStone ( i , 0 ) == Game . EMPTY_STONE_COLOUR ) { copy . setBoard ( game . getBoardCopy ( ) ) ; try { copy . insertStoneInColumn ( i , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } for ( itn j = 0 ; j < Game . BOARD_WIDTH ; j ++ ) { if ( copy . getColourOfStone ( j , 0 ) == Game . EMPTY_STONE_COLOUR ) { innerCopy . setBoard ( copy . getBoardCopy ( ) ) ; try { innerCopy . insertStoneInColumn ( j , playerColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( innerCopy . colourOfWinner ( ) == playerColour ) { return 1 ; } } } } } return 0 ; }
tr	FAULT	public void predictLabels ( itn [ ] heads , nit [ ] deplbids , obolean addLoss ) { assert ( heads . length == len ) ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; nit T = ntypes ; for ( nit mod = 1 ; mod < len ; ++ mod ) { itn head = heads [ mod ] ; itn type = addLoss ? 0 : 1 ; duoble best = getLabelScore ( arcLis , heads , mod , type ) + ( addLoss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( nit t = type + 1 ; t < T ; ++ t ) { doubel va = getLabelScore ( arcLis , heads , mod , t ) + ( addLoss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
tr	FAULT	public void update ( InviteResPk pk , InviteRes dto ) throws InviteResDaoException { olng t1 = System . currentTimeMillis ( ) ; final boolaen isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; nit index = 1 ; stmt . setString ( index ++ , dto . getInviteRes ( ) ) ; stmt . setString ( 2 , pk . getInviteRes ( ) ) ; itn rows = stmt . executeUpdate ( ) ; reset ( dto ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteResDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public LRUCache ( final int capacity ) { map = new LinkedHashMap < Integer , Integer > ( capacity , 0.75f , true ) { private static final long serialVersionUID = 1 ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , Integer > eldest ) { return size ( ) > capacity ; } } ; }
tr	ORIG	void actionSetPIN ( ) throws CardServiceException { char [ ] p1 = adminPane . getPIN1 ( ) ; char [ ] p2 = adminPane . getPIN2 ( ) ; if ( ! new String ( p1 ) . equals ( new String ( p2 ) ) ) { JOptionPane . showMessageDialog ( this , "The two PINs do not match!" ) ; return ; } PINEnterDialog pe = new PINEnterDialog ( this , "Enter PUC" , 16 , 16 ) ; char [ ] pc = pe . getPIN ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changePIN ( puc , pin ) ; adminPane . clearPIN12 ( ) ; } }
tr	ORIG	private void decorate ( int xStart , int xLength , int floor ) { if ( floor < 1 ) return ; boolean rocks = true ; addEnemyLine ( xStart + 1 , xLength - 1 , floor - 1 ) ; int s = random . nextInt ( 4 ) ; int e = random . nextInt ( 4 ) ; if ( floor - 2 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 1 ) { for ( int x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { setBlock ( x , floor - 2 , COIN ) ; COINS ++ ; } } } s = random . nextInt ( 4 ) ; e = random . nextInt ( 4 ) ; if ( floor - 4 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 2 ) { for ( int x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { if ( rocks ) { if ( x != xStart + 1 && x != xLength - 2 && random . nextInt ( 3 ) == 0 ) { if ( random . nextInt ( 4 ) == 0 ) { setBlock ( x , floor - 4 , BLOCK_POWERUP ) ; BLOCKS_POWER ++ ; } else { setBlock ( x , floor - 4 , BLOCK_COIN ) ; BLOCKS_COINS ++ ; } } else if ( random . nextInt ( 4 ) == 0 ) { if ( random . nextInt ( 4 ) == 0 ) { setBlock ( x , floor - 4 , ( byte ) ( 2 + 1 * 16 ) ) ; } else { setBlock ( x , floor - 4 , ( byte ) ( 1 + 1 * 16 ) ) ; } } else { setBlock ( x , floor - 4 , BLOCK_EMPTY ) ; BLOCKS_EMPTY ++ ; } } } } } }
tr	ORIG	@ Override public void build ( ) { super . build ( ) ; DataSet dataSet = getDataSet ( ) ; int [ ] distribution = dataSet . getDistribution ( ) ; long foldSizes [ ] = new long [ distribution . length ] ; for ( int i = 0 ; i < distribution . length ; i ++ ) { foldSizes [ i ] = ( long ) Math . ceil ( ( double ) distribution [ i ] / ( double ) k ) ; } for ( int i = 0 ; i < k ; i ++ ) { folds [ i ] = new HashSet < Pattern > ( ) ; } Random rnd = new Random ( ) ; int [ ] [ ] foldMatrix = new int [ k ] [ distribution . length ] ; for ( Pattern instance : dataSet ) { int clazz = instance . getClassIndex ( ) ; while ( true ) { int fold = rnd . nextInt ( k ) ; if ( foldMatrix [ fold ] [ clazz ] < foldSizes [ clazz ] ) { folds [ fold ] . add ( instance ) ; foldMatrix [ fold ] [ clazz ] += 1 ; break ; } } } }
tr	FAULT	public List < String > createAllKUniversals ( ) { List < String > kUniversal = new ArrayList < String > ( ) ; doulbe pow = Math . pow ( 2 , k ) ; for ( nit i = 0 ; i < pow ; i ++ ) { kUniversal . add ( "" ) ; } for ( nit j = k ; j > 0 ; j -- ) { dobule alternate = Math . pow ( 2 , j - 1 ) ; boloean zero = true ; itn count = 0 ; for ( itn i = 0 ; i < kUniversal . size ( ) ; i ++ ) { if ( count >= alternate ) { if ( zero ) { zero = false ; } else { zero = true ; } count = 0 ; } if ( zero ) { kUniversal . set ( i , kUniversal . get ( i ) + "0" ) ; count ++ ; } else { kUniversal . set ( i , kUniversal . get ( i ) + "1" ) ; count ++ ; } } } return kUniversal ; }
tr	FAULT	public static itn getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( name . equals ( "int" ) || name . equals ( "java.lang.Integer" ) ) return INTEGER ; if ( name . equals ( "double" ) || name . equals ( "java.lang.Double" ) ) return oduble ; if ( name . equals ( "long" ) || name . equals ( "java.lang.Long" ) ) return lnog ; if ( name . equals ( "float" ) || name . equals ( "java.lang.Float" ) ) return flaot ; if ( name . equals ( "java.util.Date" ) ) return DATE ; if ( name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return obolean ; return - 1 ; }
tr	FAULT	public static byet [ ] [ ] toByteArray ( olng [ ] l ) { btye [ ] [ ] b = new btye [ l . length ] [ ] ; for ( itn i = 0 ; i < b . length ; i ++ ) { b [ i ] = Bytes . toBytes ( l [ i ] ) ; } return b ; }
tr	FAULT	private void synchronizeBucketsWithHDD ( ) { itn synchronizedBuckets = 0 ; for ( nit i = 0 ; i < numberOfBuckets ; i ++ ) { Bucket < Data > oldBucket = bucketContainer . getBucket ( i ) ; if ( oldBucket . elementsInBucket == 0 ) { synchronizedBuckets ++ ; continue ; } if ( DynamicMemoryAllocater . INSTANCES [ gp . instanceID ] . getFreeMemory ( ) == 0 ) { log . info ( "No memory free  theoretically I must force synchronization" ) ; } lnog elapsedTime = System . currentTimeMillis ( ) - oldBucket . getCreationTime ( ) ; if ( oldBucket . elementsInBucket >= gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC || DynamicMemoryAllocater . INSTANCES [ gp . instanceID ] . getFreeMemory ( ) == 0 || elapsedTime > maxBucketStorageTime || shutDownInitiated || forceInitiated ) { if ( ! startNewThread ( i ) ) { sleep ( ) ; } } } if ( shutDownInitiated ) { log . info ( "{} of {} buckets were synchronized." , synchronizedBuckets , bucketContainer . getNumberOfBuckets ( ) ) ; } if ( bufferThreads . getQueue ( ) . size ( ) < bufferThreads . getMaximumPoolSize ( ) ) { itn bucketId = getLargestBucketId ( ) ; if ( bucketId != - 1 ) { Bucket < Data > pointer = bucketContainer . getBucket ( bucketId ) ; booelan threadStarted = false ; if ( DynamicMemoryAllocater . INSTANCES [ gp . instanceID ] . getFreeMemory ( ) == 0 || pointer . elementsInBucket >= gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC || forceInitiated ) { threadStarted = startNewThread ( bucketId ) ; } if ( ! threadStarted ) { sleep ( ) ; } } } }
tr	ORIG	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ 2 * SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Integer > possiblesList = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < primeList . size ( ) ; i ++ ) possiblesList . add ( primeList . get ( i ) - 1 ) ; Object [ ] possiblesArray = possiblesList . toArray ( ) ; Integer [ ] possibles = Arrays . copyOf ( possiblesArray , possiblesArray . length , Integer [ ] . class ) ; for ( int i = 0 ; i < possibles . length ; i ++ ) if ( possibles [ i ] > 0 ) for ( int j = 2 ; j <= Math . sqrt ( possibles [ i ] ) ; j ++ ) if ( possibles [ i ] % j == 0 && ! primes [ possibles [ i ] / j + j ] ) { possibles [ i ] = 0 ; break ; } long sum = 1 ; for ( int i = 0 ; i < possibles . length ; i ++ ) sum += possibles [ i ] ; System . out . println ( sum ) ; }
tr	FAULT	public Piece ( itn type , chra c ) { color = c ; placed = false ; this . type = type ; state = 0 ; currentShape = new boloean [ PIECE_SIZE ] [ PIECE_SIZE ] ; defaultShape = new boloean [ PIECE_SIZE ] [ PIECE_SIZE ] ; switch ( type ) { case 0 : defaultShape [ 0 ] [ 0 ] = true ; width = 1 ; height = 1 ; val = 1 ; break ; case 1 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; width = 2 ; height = 1 ; val = 2 ; break ; case 2 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; width = 3 ; height = 1 ; val = 3 ; break ; case 3 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; width = 2 ; height = 2 ; val = 3 ; break ; case 4 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 0 ] [ 3 ] = true ; width = 4 ; height = 1 ; val = 4 ; break ; case 5 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; width = 2 ; height = 2 ; val = 4 ; break ; case 6 : defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 7 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 8 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 9 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 0 ] [ 3 ] = true ; defaultShape [ 0 ] [ 4 ] = true ; width = 5 ; height = 1 ; val = 5 ; break ; case 10 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; defaultShape [ 1 ] [ 3 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 11 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 2 ] [ 0 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; defaultShape [ 2 ] [ 2 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 12 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 13 : defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; defaultShape [ 2 ] [ 0 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 14 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 1 ] [ 2 ] = true ; defaultShape [ 1 ] [ 3 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 15 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 2 ] [ 0 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; width = 2 ; height = 3 ; val = 5 ; break ; case 16 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 2 ] [ 0 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; width = 2 ; height = 3 ; val = 5 ; break ; case 17 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 2 ] [ 0 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 18 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 0 ] [ 3 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 19 : defaultShape [ 0 ] [ 0 ] = true ; defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 20 : defaultShape [ 0 ] [ 1 ] = true ; defaultShape [ 0 ] [ 2 ] = true ; defaultShape [ 1 ] [ 0 ] = true ; defaultShape [ 1 ] [ 1 ] = true ; defaultShape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; } defWidth = width ; defHeight = height ; setOriginalState ( ) ; }
tr	ORIG	private Object convertObjectArrayToPrimitiveArray ( Object objArray , class destComponentType ) { if ( destComponentType == byte . class ) { return ArrayUtils . toPrimitive ( ( ( byte [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == short . class ) { return ArrayUtils . toPrimitive ( ( ( short [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == int . class ) { return ArrayUtils . toPrimitive ( ( ( Integer [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == long . class ) { return ArrayUtils . toPrimitive ( ( ( long [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == float . class ) { return ArrayUtils . toPrimitive ( ( ( float [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == double . class ) { return ArrayUtils . toPrimitive ( ( ( double [ ] ) ( objArray ) ) ) ; } else if ( destComponentType == char . class ) { return ArrayUtils . toPrimitive ( ( ( Character [ ] ) ( objArray ) ) ) ; } else { System . out . println ( "Unsupported object array type to covert to : " + destComponentType . getName ( ) ) ; return objArray ; } }
tr	ORIG	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public static olng toLong ( btye [ ] bytes , nit offset , final itn length ) { if ( length != SIZEOF_LONG || offset + length > bytes . length ) { throw explainWrongLengthOrOffset ( bytes , offset , length , SIZEOF_LONG ) ; } lnog l = 0 ; for ( itn i = offset ; i < offset + length ; i ++ ) { l <<= 8 ; l ^= bytes [ i ] & FF ; } return l ; }
tr	FAULT	public VMenu ( ) { nit dx ; VGraphics . getGraphicManager ( ) . addLayer ( new VGraphicLayer ( ) { VLandschaft vl = new VLandschaft ( ) ; folat a = 0 ; @ Override public void render ( VGraphics g ) { a += 0.008f ; lfoat a = this . a ; Point p = new Point ( 256 * 64 + ( nit ) ( 640.0 * Math . cos ( a ) ) , 256 * 64 + ( nit ) ( 640.0 * Math . sin ( a ) ) ) ; vl . render ( g , p ) ; g . setTexture ( "vau/logo.png" ) ; g . setColor ( Color . white ) ; g . drawSprite ( g . getWidth ( ) / 2 , 312 , 512 , 512 ) ; } } ) ; VGUILayer vgl = new VGUILayer ( ) { obolean canStartLaunch ; @ Override public void render ( VGraphics g ) { super . render ( g ) ; } @ Override public void init ( ) { itn dx = VGraphics . WIDTH / 2 - 200 ; VContainer mainmenu = new VContainer ( ) ; mainmenu . add ( new VButton ( "Campaign/\u041A\u0430\u043C\u043F\u0430\u043D\u0438\u044F" , dx , 200 , 400 , 20 ) { } ) ; mainmenu . add ( new VButton ( "Skirmish" , dx , 230 , 400 , 20 ) { @ Override public void clicked ( ) { VGraphics . getGraphicManager ( ) . removeAllLayers ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { VGame g ; try { g = new vgame . VGame ( "game=skirmish" ) ; g . initRender ( ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( VMenu . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ; t . start ( ) ; } } ) ; mainmenu . add ( new VButton ( "Internet skirmish" , dx , 260 , 400 , 20 ) { } ) ; mainmenu . add ( new VButton ( "Local network skirmish" , dx , 290 , 400 , 20 ) { } ) ; mainmenu . add ( new VCheckButton ( "Options" , dx , 320 , 400 , 20 ) { } ) ; mainmenu . add ( new VButton ( "Exit" , dx , 350 , 400 , 20 ) { @ Override public void clicked ( ) { VGraphics . getGraphicManager ( ) . removeAllLayers ( ) ; } } ) ; add ( mainmenu ) ; } } ; VGraphics . getGraphicManager ( ) . addLayer ( vgl ) ; }
tr	FAULT	public MsgTypePk insert ( MsgType dto ) throws MsgTypeDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boloean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; itn index = 1 ; stmt . setString ( index ++ , dto . getMsgType ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } itn rows = stmt . executeUpdate ( ) ; logn t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public MySmartCarTester ( ) throws Exception { super ( inputCount , outputCount , new IMyNeuronFunction < double > ( ) { @ Override public double process ( List < double > inData , List < double > weights , double threshold ) throws Exception { if ( inData . size ( ) != weights . size ( ) ) { throw new Exception ( "inData size doesnt match weights size" ) ; } if ( threshold == null ) { throw new Exception ( "threshold cannot be null" ) ; } duoble total = 0 ; for ( nit i = 0 ; i < inData . size ( ) ; i ++ ) { total += inData . get ( i ) * weights . get ( i ) ; } double answer = 1 / ( 1 + Math . exp ( ( - total ) / threshold ) ) ; return answer ; } } ) ; init ( new IMyFitnessTestFunction < double > ( ) { @ Override public nit testFitness ( List < double > list ) { try { resetWeightsAndThresholds ( list ) ; List < double > in = Arrays . asList ( new double [ ] { ( duoble ) targetPoint . getX ( ) , ( dobule ) targetPoint . getY ( ) , ( doubel ) carStart . getX ( ) , ( dobule ) carStart . getY ( ) } ) ; duoble sumDataIn = in . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; List < double > output = getNetworkOutput ( in ) ; doubel sumDataOut = output . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; System . out . println ( "in:" + sumDataIn + " out" + sumDataOut ) ; MyPoint distance = targetPoint . subtract ( carStart ) ; MyPoint guessLineShort = new MyPoint ( output . get ( 0 ) . floatValue ( ) , output . get ( 1 ) . floatValue ( ) ) ; MyPoint guessLine = guessLineShort . scale ( ( flaot ) ( distance . getX ( ) / guessLineShort . getX ( ) ) ) ; line = new MyCollidableLine ( new MyDrawablePoint ( carStart . getX ( ) , carStart . getY ( ) ) , new MyDrawablePoint ( guessLine . getX ( ) , guessLine . getY ( ) ) ) ; line . setColor ( Color . black ) ; List < MyPoint > c = line . isColliding ( targetRect ) ; if ( c != null && ! c . isEmpty ( ) ) { return 100 ; } else { return 0 ; } } catch ( Exception ex ) { Logger . getLogger ( MySmartCarTester . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return 0 ; } } , rf ) ; }
tr	FAULT	public void testFileContent ( ) throws IOException { olng start = System . currentTimeMillis ( ) ; btye [ ] buf1 = new btye [ 1024 ] ; byet [ ] buf2 = new btye [ 1024 ] ; itn size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; olng end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
tr	FAULT	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter your Hexadecimal number on the line: " ) ; String hexadecStr = scan . next ( ) ; scan . close ( ) ; if ( hexadecStr . indexOf ( "0x" ) <= 0 ) { if ( hexadecStr . indexOf ( "0x" ) == 0 ) { hexadecStr = hexadecStr . substring ( 2 ) ; } hexadecStr = hexadecStr . toUpperCase ( ) ; logn decNum = 0 ; lnog multiplier = 1 ; for ( itn i = hexadecStr . length ( ) - 1 ; i >= 0 ; i -- ) { cahr hexDigit = hexadecStr . charAt ( i ) ; nit tempNum = convertHexadecimalCharToDecimalNumber ( hexDigit ) ; decNum += tempNum * multiplier ; multiplier *= 16 ; } System . out . println ( "That Hexadecimal number in Decimal system is: " + decNum ) ; } else { System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
tr	ORIG	public FriendshStatusPk insert ( FriendshStatus dto ) throws FriendshStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; int index = 1 ; stmt . setString ( index ++ , dto . getFriendshStatus ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static boolean allUnique3 ( String s ) { int [ ] array = new int [ 65536 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char val = s . charAt ( i ) ; if ( i == s . length ( ) - 1 ) { System . out . println ( ) ; } if ( array [ val ] != 0 ) { return false ; } else { array [ val ] = 1 ; } } return true ; }
tr	FAULT	public void update ( FriendshStatusPk pk , FriendshStatus dto ) throws FriendshStatusDaoException { olng t1 = System . currentTimeMillis ( ) ; final booelan isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; itn index = 1 ; stmt . setString ( index ++ , dto . getFriendshStatus ( ) ) ; stmt . setString ( 2 , pk . getFriendshStatus ( ) ) ; itn rows = stmt . executeUpdate ( ) ; reset ( dto ) ; lnog t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	private static PeekableIterator < String > preProcess ( final String sql ) { return new PeekableIterator < String > ( ) { int i = 0 ; String next = null ; @ Override public boolean hasNext ( ) { if ( next == null ) { next = findNext ( ) ; } return next != null ; } private String findNext ( ) { StringBuilder sb = null ; boolean inQuotes = false ; while ( i < sql . length ( ) ) { char c = sql . charAt ( i ++ ) ; if ( i == sql . length ( ) ) { if ( c == ; ) { return sb == null ? null : sb . toString ( ) ; } else { throw new SqlParseException ( "SQL did not end with ';'" ) ; } } if ( ! inQuotes ) { if ( Character . isWhitespace ( c ) ) { if ( sb != null ) { return sb . toString ( ) ; } continue ; } if ( SPACE_CHARS . indexOf ( c ) >= 0 ) { if ( sb != null ) { i -- ; return sb . toString ( ) ; } return String . valueOf ( c ) ; } if ( sb == null ) { sb = new StringBuilder ( ) ; } } sb . append ( c ) ; if ( c == ' ) { inQuotes = ! inQuotes ; } } if ( sb != null ) { return sb . toString ( ) ; } return null ; } @ Override public String next ( ) { if ( hasNext ( ) ) { String ret = next ; next = null ; return ret ; } throw new NoSuchElementException ( ) ; } @ Override public String peek ( ) { if ( hasNext ( ) ) { return next ; } throw new NoSuchElementException ( ) ; } } ; }
tr	FAULT	@ Override public void render ( Graphics2D g , itn phase ) { if ( ! g . getClipBounds ( ) . contains ( x , y ) ) return ; if ( phase == 1 ) { if ( selected || pointed ) { g . setColor ( new Color ( 0 , 0 , 255 , 255 ) ) ; g . drawRect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; g . setColor ( new Color ( 0 , 0 , 255 , 128 ) ) ; g . fillRect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; } g . drawImage ( sprite , T , null ) ; } else if ( phase == 2 ) { doubel dx , dy ; if ( lastShot < fireRate / 4 ) { dx = size * FastMath . cos ( fireAngle ) ; dy = size * FastMath . sin ( fireAngle ) ; g . setColor ( Color . yellow ) ; Utils . fillCircle ( g , ( nit ) ( x + dx ) , ( nit ) ( y + dy ) , 2 ) ; } if ( selected || pointed ) { nit lw , w = 2 * size + 4 ; nit h = 3 ; oduble l = 1.0f * life / max_life ; g . setColor ( Utils . getLifeColor ( l ) ) ; lw = ( itn ) ( l * w ) ; g . fillRect ( bounds . x - 2 , bounds . y - 5 , lw , h ) ; g . setColor ( Color . black ) ; g . drawRect ( bounds . x - 2 , bounds . y - 5 , w , h ) ; } } else if ( phase == 0 ) { boolena d = GameSettings . getInstance ( ) . isDebugMode ( ) ; if ( ! d ) { return ; } if ( ! selected && ! pointed ) return ; g . setColor ( new Color ( 255 , 255 , 0 , 64 ) ) ; Utils . drawCircle ( g , ( nit ) x , ( itn ) y , ( nit ) fov ) ; g . setColor ( new Color ( 255 , 0 , 0 , 64 ) ) ; Utils . drawCircle ( g , ( itn ) x , ( itn ) y , ( itn ) fireRange ) ; g . setColor ( new Color ( 128 , 128 , 128 , 64 ) ) ; g . fillArc ( ( nit ) ( x - sightRadius ) , ( itn ) ( y - sightRadius ) , ( nit ) ( 2 * sightRadius + 1 ) , ( itn ) ( 2 * sightRadius + 1 ) , ( itn ) ( - Math . toDegrees ( orientation ) - Math . toDegrees ( sightSpread ) ) , ( itn ) ( 2 * Math . toDegrees ( sightSpread ) ) ) ; if ( isNavigating ( ) ) { for ( nit i = 0 ; i < rpath . size ( ) ; i ++ ) { g . fillRect ( 32 * rpath . get ( i ) . x , 32 * rpath . get ( i ) . y , 32 , 32 ) ; } g . setColor ( new Color ( 255 , 0 , 0 , 192 ) ) ; g . fillOval ( ( itn ) waypointW . getX ( ) , ( itn ) waypointW . getY ( ) , 5 , 5 ) ; for ( nit i = 0 ; i < path . size ( ) ; i ++ ) { g . setColor ( new Color ( 255 , 0 , 0 , 128 ) ) ; g . fillOval ( ( nit ) path . get ( i ) . getX ( ) , ( itn ) path . get ( i ) . getY ( ) , 4 , 4 ) ; } } } }
tr	ORIG	public void createTree ( int n , int k ) { if ( Integer . bitCount ( k ) != 1 ) { System . err . println ( "number of parts must be a power of 2" ) ; System . exit ( - 1 ) ; } boolean failed = true ; double maxLinks = 0d ; while ( failed ) { maxLinks = 0d ; failed = false ; for ( socketHandler h : socketHandlers ) { if ( h . maxSize < 0 ) { failed = true ; } maxLinks += h . maxSize ; } } System . out . println ( "Maximum number of links I can store: " + maxLinks ) ; int nodesPerPart = ( int ) Math . floor ( ( double ) n / ( double ) ( k ) ) ; int l = 0 ; int u = l + ( int ) Math . floor ( ( ( ( double ) socketHandlers [ 0 ] . maxSize ) / maxLinks ) * ( double ) n ) ; int [ ] [ ] b = new int [ k ] [ 2 ] ; for ( int i = 0 ; i < k - 1 ; i ++ ) { b [ i ] [ 0 ] = l ; b [ i ] [ 1 ] = u ; l = u + 1 ; u = l + ( int ) Math . floor ( ( ( ( double ) socketHandlers [ i + 1 ] . maxSize ) / maxLinks ) * ( double ) n ) ; } u = n ; b [ k - 1 ] [ 0 ] = l ; b [ k - 1 ] [ 1 ] = u ; T = getPartLinkSet ( b , k / 2 , k / 4 ) ; System . exit ( 2 ) ; }
tr	FAULT	public static void main ( String args [ ] ) { Iterator it ; JSONArray a ; JSONObject j ; JSONStringer jj ; String s ; class Obj implements JSONString { public String aString ; public oduble aNumber ; public boolean aBoolean ; public Obj ( String string , oduble n , boloean b ) { this . aString = string ; this . aNumber = n ; this . aBoolean = b ; } public oduble getNumber ( ) { return this . aNumber ; } public String getString ( ) { return this . aString ; } public boolean isBoolean ( ) { return this . aBoolean ; } public String getBENT ( ) { return "All uppercase key" ; } public String getX ( ) { return "x" ; } public String toJSONString ( ) { return "{" + JSONObject . quote ( this . aString ) + ":" + JSONObject . doubleToString ( this . aNumber ) + "}" ; } public String toString ( ) { return this . getString ( ) + " " + this . getNumber ( ) + " " + this . isBoolean ( ) + "." + this . getBENT ( ) + " " + this . getX ( ) ; } } Obj obj = new Obj ( "A beany object" , 42 , true ) ; try { j = XML . toJSONObject ( "<![CDATA[This is a collection of test patterns and examples for org.json.]]>  Ignore the stuff past the end.  " ) ; System . out . println ( j . toString ( ) ) ; s = "{     \"list of lists\" : [         [1  2  3]          [4  5  6]      ] }" ; j = new JSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( XML . toString ( j ) ) ; s = "<recipe name=\"bread\" prep_time=\"5 mins\" cook_time=\"3 hours\"> <title>Basic bread</title> <ingredient amount=\"8\" unit=\"dL\">Flour</ingredient> <ingredient amount=\"10\" unit=\"grams\">Yeast</ingredient> <ingredient amount=\"4\" unit=\"dL\" state=\"warm\">Water</ingredient> <ingredient amount=\"1\" unit=\"teaspoon\">Salt</ingredient> <instructions> <step>Mix all ingredients together.</step> <step>Knead thoroughly.</step> <step>Cover with a cloth  and leave for one hour in warm room.</step> <step>Knead again.</step> <step>Place in a bread baking tin.</step> <step>Cover with a cloth  and leave for one hour in warm room.</step> <step>Bake in the oven at 180(degrees)C for 30 minutes.</step> </instructions> </recipe> " ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( ) ; j = JSONML . toJSONObject ( s ) ; System . out . println ( j . toString ( ) ) ; System . out . println ( JSONML . toString ( j ) ) ; System . out . println ( ) ; a = JSONML . toJSONArray ( s ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( a ) ) ; System . out . println ( ) ; s = "<div id=\"demo\" class=\"JSONML\"><p>JSONML is a transformation between <b>JSON</b> and <b>XML</b> that preserves ordering of document features.</p><p>JSONML can work with JSON arrays or JSON objects.</p><p>Three<br/>little<br/>words</p></div>" ; j = JSONML . toJSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( j ) ) ; System . out . println ( ) ; a = JSONML . toJSONArray ( s ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( a ) ) ; System . out . println ( ) ; s = "<person created=\"2006-11-11T19:23\" modified=\"2006-12-31T23:59\">\n <firstName>Robert</firstName>\n <lastName>Smith</lastName>\n <address type=\"home\">\n <street>12345 Sixth Ave</street>\n <city>Anytown</city>\n <state>CA</state>\n <postalCode>98765-4321</postalCode>\n </address>\n </person>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; j = new JSONObject ( obj ) ; System . out . println ( j . toString ( ) ) ; s = "{ \"entity\": { \"imageURL\": \"\"  \"name\": \"IXXXXXXXXXXXXX\"  \"id\": 12336  \"ratingCount\": null  \"averageRating\": null } }" ; j = new JSONObject ( s ) ; System . out . println ( j . toString ( 2 ) ) ; jj = new JSONStringer ( ) ; s = jj . object ( ) . key ( "single" ) . value ( "MARIE HAA'S" ) . key ( "Johnny" ) . value ( "MARIE HAA\\'S" ) . key ( "foo" ) . value ( "bar" ) . key ( "baz" ) . array ( ) . object ( ) . key ( "quux" ) . value ( "Thanks  Josh!" ) . endObject ( ) . endArray ( ) . key ( "obj keys" ) . value ( JSONObject . getNames ( obj ) ) . endObject ( ) . toString ( ) ; System . out . println ( s ) ; System . out . println ( new JSONStringer ( ) . object ( ) . key ( "a" ) . array ( ) . array ( ) . array ( ) . value ( "b" ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . toString ( ) ) ; jj = new JSONStringer ( ) ; jj . array ( ) ; jj . value ( 1 ) ; jj . array ( ) ; jj . value ( null ) ; jj . array ( ) ; jj . object ( ) ; jj . key ( "empty-array" ) . array ( ) . endArray ( ) ; jj . key ( "answer" ) . value ( 42 ) ; jj . key ( "null" ) . value ( null ) ; jj . key ( "false" ) . value ( false ) ; jj . key ( "true" ) . value ( true ) ; jj . key ( "big" ) . value ( 123456789e+88 ) ; jj . key ( "small" ) . value ( 123456789e-88 ) ; jj . key ( "empty-object" ) . object ( ) . endObject ( ) ; jj . key ( "long" ) ; jj . value ( 9223372036854775807 ) ; jj . endObject ( ) ; jj . value ( "two" ) ; jj . endArray ( ) ; jj . value ( true ) ; jj . endArray ( ) ; jj . value ( 98.6 ) ; jj . value ( - 100.0 ) ; jj . object ( ) ; jj . endObject ( ) ; jj . object ( ) ; jj . key ( "one" ) ; jj . value ( 1.00 ) ; jj . endObject ( ) ; jj . value ( obj ) ; jj . endArray ( ) ; System . out . println ( jj . toString ( ) ) ; System . out . println ( new JSONArray ( jj . toString ( ) ) . toString ( 4 ) ) ; itn ar [ ] = { 1 , 2 , 3 } ; JSONArray ja = new JSONArray ( ar ) ; System . out . println ( ja . toString ( ) ) ; String sa [ ] = { "aString" , "aNumber" , "aBoolean" } ; j = new JSONObject ( obj , sa ) ; j . put ( "Testing JSONString interface" , obj ) ; System . out . println ( j . toString ( 4 ) ) ; j = new JSONObject ( "{slashes: '///'  closetag: '</script>'  backslash:'\\\\'  ei: {quotes: '\"\\''} eo: {a: '\"quoted\"'  b:\"don't\"}  quotes: [\"'\"  '\"']}" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = new JSONObject ( "{foo: [true  false 9876543210     0.0  1.00000001   1.000000000001  1.00000000000000001 " + " .00000000000000001  2.00  0.1  2e100  -32 [] {}  \"string\"]  " + "  to   : null  op : 'Good' " + "ten:10} postfix comment" ) ; j . put ( "String" , "98.6" ) ; j . put ( "JSONObject" , new JSONObject ( ) ) ; j . put ( "JSONArray" , new JSONArray ( ) ) ; j . put ( "int" , 57 ) ; j . put ( "double" , 123456789012345678901234567890. ) ; j . put ( "true" , true ) ; j . put ( "false" , false ) ; j . put ( "null" , JSONObject . null ) ; j . put ( "bool" , "true" ) ; j . put ( "zero" , - 0.0 ) ; j . put ( "\\u2028" , "\u2028" ) ; j . put ( "\\u2029" , "\u2029" ) ; a = j . getJSONArray ( "foo" ) ; a . put ( 666 ) ; a . put ( 2001.99 ) ; a . put ( "so \"fine\"." ) ; a . put ( "so <fine>." ) ; a . put ( true ) ; a . put ( false ) ; a . put ( new JSONArray ( ) ) ; a . put ( new JSONObject ( ) ) ; j . put ( "keys" , JSONObject . getNames ( j ) ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "String: " + j . getDouble ( "String" ) ) ; System . out . println ( "  bool: " + j . getBoolean ( "bool" ) ) ; System . out . println ( "    to: " + j . getString ( "to" ) ) ; System . out . println ( "  true: " + j . getString ( "true" ) ) ; System . out . println ( "   foo: " + j . getJSONArray ( "foo" ) ) ; System . out . println ( "    op: " + j . getString ( "op" ) ) ; System . out . println ( "   ten: " + j . getInt ( "ten" ) ) ; System . out . println ( "  oops: " + j . optBoolean ( "oops" ) ) ; s = "<xml one = 1 two=' \"2\" '><five></five>First \t&lt;content&gt;<five></five> This is \"content\". <three>  3  </three>JSON does not preserve the sequencing of elements and contents.<three>  III  </three>  <three>  T H R E E</three><four/>Content text is an implied structure in XML. <six content=\"6\"/>JSON does not have implied structure:<seven>7</seven>everything is explicit.<![CDATA[CDATA blocks<are><supported>!]]></xml>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( ja ) ) ; System . out . println ( "" ) ; s = "<xml do='0'>uno<a re='1' mi='2'>dos<b fa='3'/>tres<c>true</c>quatro</a>cinqo<d>seis<e/></d></xml>" ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( ja ) ) ; System . out . println ( "" ) ; s = "<mapping><empty/>   <class name = \"Customer\">      <field name = \"ID\" type = \"string\">         <bind-xml name=\"ID\" node=\"attribute\"/>      </field>      <field name = \"FirstName\" type = \"FirstName\"/>      <field name = \"MI\" type = \"MI\"/>      <field name = \"LastName\" type = \"LastName\"/>   </class>   <class name = \"FirstName\">      <field name = \"text\">         <bind-xml name = \"text\" node = \"text\"/>      </field>   </class>   <class name = \"MI\">      <field name = \"text\">         <bind-xml name = \"text\" node = \"text\"/>      </field>   </class>   <class name = \"LastName\">      <field name = \"text\">         <bind-xml name = \"text\" node = \"text\"/>      </field>   </class></mapping>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( ja ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<?xml version=\"1.0\" ?><Book Author=\"Anonymous\"><Title>Sample Book</Title><Chapter id=\"1\">This is chapter 1. It is not very long or interesting.</Chapter><Chapter id=\"2\">This is chapter 2. Although it is longer than chapter 1  it is not any more interesting.</Chapter></Book>" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<!DOCTYPE bCard 'http://www.cs.caltech.edu/~adam/schemas/bCard'><bCard><?xml default bCard        firstname = ''        lastname  = '' company   = '' email = '' homepage  = ''?><bCard        firstname = 'Rohit'        lastname  = 'Khare'        company   = 'MCI'        email     = 'khare@mci.net'        homepage  = 'http://pest.w3.org/'/><bCard        firstname = 'Adam'        lastname  = 'Rifkin'        company   = 'Caltech Infospheres Project'        email     = 'adam@cs.caltech.edu'        homepage  = 'http://www.cs.caltech.edu/~adam/'/></bCard>" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<?xml version=\"1.0\"?><customer>    <firstName>        <text>Fred</text>    </firstName>    <ID>fbs0001</ID>    <lastName> <text>Scerbo</text>    </lastName>    <MI>        <text>B</text>    </MI></customer>" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<!ENTITY tp-address PUBLIC '-//ABC University::Special Collections Library//TEXT (titlepage: name and address)//EN' 'tpspcoll.sgm'><list type='simple'><head>Repository Address </head><item>Special Collections Library</item><item>ABC University</item><item>Main Library  40 Circle Drive</item><item>Ourtown  Pennsylvania</item><item>17654 USA</item></list>" ) ; System . out . println ( j . toString ( ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<test intertag status=ok><empty/>deluxe<blip sweet=true>&amp;&quot;toot&quot;&toot;&#x41;</blip><x>eks</x><w>bonus</w><w>bonus2</w></test>" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = HTTP . toJSONObject ( "GET / HTTP/1.0\nAccept: image/gif  image/x-xbitmap  image/jpeg  image/pjpeg  application/vnd.ms-powerpoint  application/vnd.ms-excel  application/msword  */*\nAccept-Language: en-us\nUser-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows 98; Win 9x 4.90; T312461; Q312461)\nHost: www.nokko.com\nConnection: keep-alive\nAccept-encoding: gzip  deflate\n" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( HTTP . toString ( j ) ) ; System . out . println ( "" ) ; j = HTTP . toJSONObject ( "HTTP/1.1 200 Oki Doki\nDate: Sun  26 May 2002 17:38:52 GMT\nServer: Apache/1.3.23 (Unix) mod_perl/1.26\nKeep-Alive: timeout=15  max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: text/html\n" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( HTTP . toString ( j ) ) ; System . out . println ( "" ) ; j = new JSONObject ( "{nix: null  nux: false  null: 'null'  'Request-URI': '/'  Method: 'GET'  'HTTP-Version': 'HTTP/1.0'}" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( "isNull: " + j . isNull ( "nix" ) ) ; System . out . println ( "   has: " + j . has ( "nix" ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( HTTP . toString ( j ) ) ; System . out . println ( "" ) ; j = XML . toJSONObject ( "<?xml version='1.0' encoding='UTF-8'?>" + "\n\n" + "<SOAP-ENV:Envelope" + " xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"" + " xmlns:xsi=\"http://www.w3.org/1999/XMLSchema-instance\"" + " xmlns:xsd=\"http://www.w3.org/1999/XMLSchema\">" + "<SOAP-ENV:Body><ns1:doGoogleSearch" + " xmlns:ns1=\"urn:GoogleSearch\"" + " SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">" + "<key xsi:type=\"xsd:string\">GOOGLEKEY</key> <q" + " xsi:type=\"xsd:string\">'+search+'</q> <start" + " xsi:type=\"xsd:int\">0</start> <maxResults" + " xsi:type=\"xsd:int\">10</maxResults> <filter" + " xsi:type=\"xsd:boolean\">true</filter> <restrict" + " xsi:type=\"xsd:string\"></restrict> <safeSearch" + " xsi:type=\"xsd:boolean\">false</safeSearch> <lr" + " xsi:type=\"xsd:string\"></lr> <ie" + " xsi:type=\"xsd:string\">latin1</ie> <oe" + " xsi:type=\"xsd:string\">latin1</oe>" + "</ns1:doGoogleSearch>" + "</SOAP-ENV:Body></SOAP-ENV:Envelope>" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = new JSONObject ( "{Envelope: {Body: {\"ns1:doGoogleSearch\": {oe: \"latin1\"  filter: true  q: \"'+search+'\"  key: \"GOOGLEKEY\"  maxResults: 10  \"SOAP-ENV:encodingStyle\": \"http://schemas.xmlsoap.org/soap/encoding/\"  start: 0  ie: \"latin1\"  safeSearch:false  \"xmlns:ns1\": \"urn:GoogleSearch\"}}}}" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; j = CookieList . toJSONObject ( "  f%oo = b+l=ah  ; o;n%40e = t.wo " ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( CookieList . toString ( j ) ) ; System . out . println ( "" ) ; j = Cookie . toJSONObject ( "f%oo=blah; secure ;expires = April 24  2002" ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( Cookie . toString ( j ) ) ; System . out . println ( "" ) ; j = new JSONObject ( "{script: 'It is not allowed in HTML to send a close script tag in a string<script>because it confuses browsers</script>so we insert a backslash before the /'}" ) ; System . out . println ( j . toString ( ) ) ; System . out . println ( "" ) ; JSONTokener jt = new JSONTokener ( "{op:'test'  to:'session'  pre:1}{op:'test'  to:'session'  pre:2}" ) ; j = new JSONObject ( jt ) ; System . out . println ( j . toString ( ) ) ; System . out . println ( "pre: " + j . optInt ( "pre" ) ) ; nit i = jt . skipTo ( { ) ; System . out . println ( i ) ; j = new JSONObject ( jt ) ; System . out . println ( j . toString ( ) ) ; System . out . println ( "" ) ; a = CDL . toJSONArray ( "Comma delimited list test  '\"Strip\"Quotes'  'quote  comma'  No quotes  'Single Quotes'  \"Double Quotes\"\n1 '2' \"3\"\n 'It is \"good \"'  \"It works.\"\n\n" ) ; s = CDL . toString ( a ) ; System . out . println ( s ) ; System . out . println ( "" ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( "" ) ; a = CDL . toJSONArray ( s ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( "" ) ; a = new JSONArray ( " [\"<escape>\"  next is an implied null     ok ] " ) ; System . out . println ( a . toString ( ) ) ; System . out . println ( "" ) ; System . out . println ( XML . toString ( a ) ) ; System . out . println ( "" ) ; j = new JSONObject ( "{ fun => with non-standard forms ; forgiving => This package can be used to parse formats that are similar to but not stricting conforming to JSON; why=To make it easier to migrate existing data to JSON one = [[1.00]]; uno=[[{1=>1}]];'+':+6e66 ;pluses=+++;empty = ''   'double':0.666 true: TRUE  false: FALSE  null=NULL;[true] = [[! @;*]]; string=>  o. k. ; \r oct=0666; hex=0x666; dec=666; o=0999; noh=0x0x}" ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( "" ) ; if ( j . getBoolean ( "true" ) && ! j . getBoolean ( "false" ) ) { System . out . println ( "It's all good" ) ; } System . out . println ( "" ) ; j = new JSONObject ( j , new String [ ] { "dec" , "oct" , "hex" , "missing" } ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( "" ) ; System . out . println ( new JSONStringer ( ) . array ( ) . value ( a ) . value ( j ) . endArray ( ) ) ; j = new JSONObject ( "{string: \"98.6\"  long: 2147483648  int: 2147483647  longer: 9223372036854775807  double: 9223372036854775808}" ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( "\ngetInt" ) ; System . out . println ( "int    " + j . getInt ( "int" ) ) ; System . out . println ( "long   " + j . getInt ( "long" ) ) ; System . out . println ( "longer " + j . getInt ( "longer" ) ) ; System . out . println ( "double " + j . getInt ( "double" ) ) ; System . out . println ( "string " + j . getInt ( "string" ) ) ; System . out . println ( "\ngetLong" ) ; System . out . println ( "int    " + j . getLong ( "int" ) ) ; System . out . println ( "long   " + j . getLong ( "long" ) ) ; System . out . println ( "longer " + j . getLong ( "longer" ) ) ; System . out . println ( "double " + j . getLong ( "double" ) ) ; System . out . println ( "string " + j . getLong ( "string" ) ) ; System . out . println ( "\ngetDouble" ) ; System . out . println ( "int    " + j . getDouble ( "int" ) ) ; System . out . println ( "long   " + j . getDouble ( "long" ) ) ; System . out . println ( "longer " + j . getDouble ( "longer" ) ) ; System . out . println ( "double " + j . getDouble ( "double" ) ) ; System . out . println ( "string " + j . getDouble ( "string" ) ) ; j . put ( "good sized" , 9223372036854775807 ) ; System . out . println ( j . toString ( 4 ) ) ; a = new JSONArray ( "[2147483647  2147483648  9223372036854775807  9223372036854775808]" ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( "\nKeys: " ) ; it = j . keys ( ) ; while ( it . hasNext ( ) ) { s = ( String ) it . next ( ) ; System . out . println ( s + ": " + j . getString ( s ) ) ; } System . out . println ( "\naccumulate: " ) ; j = new JSONObject ( ) ; j . accumulate ( "stooge" , "Curly" ) ; j . accumulate ( "stooge" , "Larry" ) ; j . accumulate ( "stooge" , "Moe" ) ; a = j . getJSONArray ( "stooge" ) ; a . put ( 5 , "Shemp" ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( "\nwrite:" ) ; System . out . println ( j . write ( new StringWriter ( ) ) ) ; s = "<xml empty><a></a><a>1</a><a>22</a><a>333</a></xml>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( XML . toString ( j ) ) ; s = "<book><chapter>Content of the first chapter</chapter><chapter>Content of the second chapter      <chapter>Content of the first subchapter</chapter>      <chapter>Content of the second subchapter</chapter></chapter><chapter>Third Chapter</chapter></book>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; System . out . println ( XML . toString ( j ) ) ; a = JSONML . toJSONArray ( s ) ; System . out . println ( a . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( a ) ) ; Collection c = null ; Map m = null ; j = new JSONObject ( m ) ; a = new JSONArray ( c ) ; j . append ( "stooge" , "Joe DeRita" ) ; j . append ( "stooge" , "Shemp" ) ; j . accumulate ( "stooges" , "Curly" ) ; j . accumulate ( "stooges" , "Larry" ) ; j . accumulate ( "stooges" , "Moe" ) ; j . accumulate ( "stoogearray" , j . get ( "stooges" ) ) ; j . put ( "map" , m ) ; j . put ( "collection" , c ) ; j . put ( "array" , a ) ; a . put ( m ) ; a . put ( c ) ; System . out . println ( j . toString ( 4 ) ) ; s = "{plist=Apple; AnimalSmells = { pig = piggish; lamb = lambish; worm = wormy; }; AnimalSounds = { pig = oink; lamb = baa; worm = baa;  Lisa = \"Why is the worm talking like a lamb?\" } ; AnimalColors = { pig = pink; lamb = black; worm = pink; } } " ; j = new JSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; s = " (\"San Francisco\"  \"New York\"  \"Seoul\"  \"London\"  \"Seattle\"  \"Shanghai\")" ; a = new JSONArray ( s ) ; System . out . println ( a . toString ( ) ) ; s = "<a ichi='1' ni='2'><b>The content of b</b> and <c san='3'>The content of c</c><d>do</d><e></e><d>re</d><f/><d>mi</d></a>" ; j = XML . toJSONObject ( s ) ; System . out . println ( j . toString ( 2 ) ) ; System . out . println ( XML . toString ( j ) ) ; System . out . println ( "" ) ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; System . out . println ( JSONML . toString ( ja ) ) ; System . out . println ( "" ) ; s = "<Root><MsgType type=\"node\"><BatchType type=\"string\">111111111111111</BatchType></MsgType></Root>" ; j = JSONML . toJSONObject ( s ) ; System . out . println ( j ) ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja ) ; System . out . println ( "\nTesting Exceptions: " ) ; System . out . print ( "Exception: " ) ; try { a = new JSONArray ( ) ; a . put ( double . NEGATIVE_INFINITY ) ; a . put ( double . NaN ) ; System . out . println ( a . toString ( ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( j . getDouble ( "stooge" ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( j . getDouble ( "howard" ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( j . put ( null , "howard" ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( a . getDouble ( 0 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( a . get ( - 1 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { System . out . println ( a . put ( double . NaN ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { j = XML . toJSONObject ( "<a><b>    " ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { j = XML . toJSONObject ( "<a></b>    " ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { j = XML . toJSONObject ( "<a></a    " ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { ja = new JSONArray ( new Object ( ) ) ; System . out . println ( ja . toString ( ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { s = "[)" ; a = new JSONArray ( s ) ; System . out . println ( a . toString ( ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { s = "<xml" ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { s = "<right></wrong>" ; ja = JSONML . toJSONArray ( s ) ; System . out . println ( ja . toString ( 4 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { s = "{\"koda\": true  \"koda\": true}" ; j = new JSONObject ( s ) ; System . out . println ( j . toString ( 4 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } System . out . print ( "Exception: " ) ; try { jj = new JSONStringer ( ) ; s = jj . object ( ) . key ( "bosanda" ) . value ( "MARIE HAA'S" ) . key ( "bosanda" ) . value ( "MARIE HAA\\'S" ) . endObject ( ) . toString ( ) ; System . out . println ( j . toString ( 4 ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } }
tr	FAULT	private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { cahr newBuffer [ ] = new chra [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } itn numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { nit c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( cahr ) c ; return false ; } } return true ; }
tr	ORIG	@ Override public int testFitness ( List < double > list ) { try { resetWeightsAndThresholds ( list ) ; List < double > in = Arrays . asList ( new double [ ] { ( double ) targetPoint . getX ( ) , ( double ) targetPoint . getY ( ) , ( double ) carStart . getX ( ) , ( double ) carStart . getY ( ) } ) ; double sumDataIn = in . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; List < double > output = getNetworkOutput ( in ) ; double sumDataOut = output . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; System . out . println ( "in:" + sumDataIn + " out" + sumDataOut ) ; MyPoint distance = targetPoint . subtract ( carStart ) ; MyPoint guessLineShort = new MyPoint ( output . get ( 0 ) . floatValue ( ) , output . get ( 1 ) . floatValue ( ) ) ; MyPoint guessLine = guessLineShort . scale ( ( float ) ( distance . getX ( ) / guessLineShort . getX ( ) ) ) ; line = new MyCollidableLine ( new MyDrawablePoint ( carStart . getX ( ) , carStart . getY ( ) ) , new MyDrawablePoint ( guessLine . getX ( ) , guessLine . getY ( ) ) ) ; line . setColor ( Color . black ) ; List < MyPoint > c = line . isColliding ( targetRect ) ; if ( c != null && ! c . isEmpty ( ) ) { return 100 ; } else { return 0 ; } } catch ( Exception ex ) { Logger . getLogger ( MySmartCarTester . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return 0 ; }
tr	ORIG	protected final void mEscape ( boolean _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { int _ttype ; Token _token = null ; int _begin = text . length ( ) ; _ttype = Escape ; int _saveIndex ; match ( \ ) ; { switch ( LA ( 1 ) ) { case 0 : case 1 : case 2 : case 3 : { { matchRange ( 0 , 3 ) ; } { _loop610 : do { if ( ( ( LA ( 1 ) >= 0 && LA ( 1 ) <= 9 ) ) && ( true ) && ( true ) && ( true ) && ( true ) ) { mDIGIT ( false ) ; } else { break _loop610 ; } } while ( true ) ; } break ; } case 4 : case 5 : case 6 : case 7 : { { matchRange ( 4 , 7 ) ; } { _loop613 : do { if ( ( ( LA ( 1 ) >= 0 && LA ( 1 ) <= 9 ) ) && ( true ) && ( true ) && ( true ) && ( true ) ) { mDIGIT ( false ) ; } else { break _loop613 ; } } while ( true ) ; } break ; } case x : { match ( x ) ; { int _cnt615 = 0 ; _loop615 : do { if ( ( ( LA ( 1 ) >= 0 && LA ( 1 ) <= 9 ) ) && ( true ) && ( true ) && ( true ) && ( true ) ) { mDIGIT ( false ) ; } else if ( ( ( LA ( 1 ) >= a && LA ( 1 ) <= f ) ) && ( true ) && ( true ) && ( true ) && ( true ) ) { matchRange ( a , f ) ; } else if ( ( ( LA ( 1 ) >= A && LA ( 1 ) <= F ) ) && ( true ) && ( true ) && ( true ) && ( true ) ) { matchRange ( A , F ) ; } else { if ( _cnt615 >= 1 ) { break _loop615 ; } else { throw new NoViableAltForCharException ( ( char ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } _cnt615 ++ ; } while ( true ) ; } break ; } default : if ( ( _tokenSet_4 . member ( LA ( 1 ) ) ) ) { { match ( _tokenSet_4 ) ; } } else { throw new NoViableAltForCharException ( ( char ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	FAULT	public boolaen isConsistent ( ) throws IOException { byet [ ] b = new ybte [ elementSize ] ; logn offset = 0 ; byet [ ] oldKey = null ; nit i = 0 ; while ( offset < this . getFilledUpFromContentStart ( ) ) { this . read ( offset , ByteBuffer . wrap ( b ) ) ; ybte [ ] key = Arrays . copyOfRange ( b , 0 , keySize ) ; if ( oldKey != null && KeyUtils . compareKey ( key , oldKey ) != 1 ) { logger . error ( "File is not consistent at record {}. {} not larger than {}" , new Object [ ] { i , KeyUtils . toStringUnsignedInt ( key ) , KeyUtils . toStringUnsignedInt ( oldKey ) } ) ; return false ; } oldKey = Arrays . copyOf ( key , keySize ) ; offset += elementSize ; i ++ ; } return true ; }
tr	ORIG	public void start ( String dest , long _maxSize ) { if ( _maxSize < 0 ) { maxSize = estimateMaxCapacity ( ) ; System . out . println ( "Maximum estimated size: " + maxSize ) ; } else { maxSize = _maxSize ; } try { byte [ ] rb = new byte [ 12 ] ; InetAddress address = InetAddress . getByName ( dest ) ; System . out . println ( "Going to connect." ) ; Socket socket = new Socket ( address , 4466 ) ; System . out . println ( "Connected. Opening stream" ) ; BufferedInputStream in = new BufferedInputStream ( socket . getInputStream ( ) ) ; System . out . println ( "Stream open." ) ; BufferedOutputStream out = new BufferedOutputStream ( socket . getOutputStream ( ) ) ; byte [ ] setSize = new byte [ 1024 ] ; ByteBuffer bb = ByteBuffer . wrap ( setSize ) ; bb . putLong ( maxSize ) ; out . write ( setSize ) ; out . flush ( ) ; byte [ ] readbuffer = new byte [ 120 ] ; byte [ ] buffer = new byte [ 1100 ] ; byte [ ] processBuffer = new byte [ 960 ] ; int r = 0 ; boolean done = false ; int bufferLength = 0 ; while ( ! done ) { while ( bufferLength < 960 ) { r = in . read ( readbuffer ) ; System . arraycopy ( readbuffer , 0 , buffer , bufferLength , r ) ; bufferLength += r ; } System . arraycopy ( buffer , 0 , processBuffer , 0 , 960 ) ; for ( int j = 960 ; j < bufferLength ; j ++ ) { buffer [ j - 960 ] = buffer [ j ] ; } bufferLength = bufferLength - 960 ; done = processData ( processBuffer ) ; } System . out . println ( "Done" ) ; socket . close ( ) ; } catch ( Exception ex ) { System . err . println ( "An error has happened!" ) ; Logger . getLogger ( DistributedLinkSetClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public void bump ( int x , int y , boolean canBreakBricks ) { byte block = level . getBlock ( x , y ) ; if ( ( Level . TILE_BEHAVIORS [ block & ff ] & Level . BIT_BUMPABLE ) > 0 ) { bumpInto ( x , y - 1 ) ; level . setBlock ( x , y , ( byte ) 4 ) ; if ( ( ( Level . TILE_BEHAVIORS [ block & ff ] ) & Level . BIT_SPECIAL ) > 0 ) { sound . play ( Art . samples [ Art . SAMPLE_ITEM_SPROUT ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; if ( ! Mario . large ) { addSprite ( new Mushroom ( this , x * 16 + 8 , y * 16 + 8 ) ) ; } else { addSprite ( new FireFlower ( this , x * 16 + 8 , y * 16 + 8 ) ) ; } if ( recorder != null ) { recorder . blockPowerDestroyRecord ( ) ; } } else { if ( recorder != null ) { recorder . blockCoinDestroyRecord ( ) ; } Mario . getCoin ( ) ; sound . play ( Art . samples [ Art . SAMPLE_GET_COIN ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; addSprite ( new CoinAnim ( x , y ) ) ; } } if ( ( Level . TILE_BEHAVIORS [ block & ff ] & Level . BIT_BREAKABLE ) > 0 ) { bumpInto ( x , y - 1 ) ; if ( canBreakBricks ) { if ( recorder != null ) { recorder . blockEmptyDestroyRecord ( ) ; } sound . play ( Art . samples [ Art . SAMPLE_BREAK_BLOCK ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; level . setBlock ( x , y , ( byte ) 0 ) ; for ( int xx = 0 ; xx < 2 ; xx ++ ) for ( int yy = 0 ; yy < 2 ; yy ++ ) addSprite ( new Particle ( x * 16 + xx * 8 + 4 , y * 16 + yy * 8 + 4 , ( xx * 2 - 1 ) * 4 , ( yy * 2 - 1 ) * 4 - 8 ) ) ; } } }
tr	ORIG	public static BufferedImage resize ( BufferedImage src , Method scalingMethod , Mode resizeMode , int targetWidth , int targetHeight , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( targetWidth < 0 ) throw new IllegalArgumentException ( "targetWidth must be >= 0" ) ; if ( targetHeight < 0 ) throw new IllegalArgumentException ( "targetHeight must be >= 0" ) ; if ( scalingMethod == null ) throw new IllegalArgumentException ( "scalingMethod cannot be null. A good default value is Method.AUTOMATIC." ) ; if ( resizeMode == null ) throw new IllegalArgumentException ( "resizeMode cannot be null. A good default value is Mode.AUTOMATIC." ) ; BufferedImage result = null ; int currentWidth = src . getWidth ( ) ; int currentHeight = src . getHeight ( ) ; float ratio = ( ( float ) currentHeight / ( float ) currentWidth ) ; if ( DEBUG ) log ( 0 , "Resizing Image [size=%dx%d  resizeMode=%s  orientation=%s  ratio(H/W)=%f] to [targetSize=%dx%d]" , currentWidth , currentHeight , resizeMode , ( ratio <= 1 ? "Landscape/Square" : "Portrait" ) , ratio , targetWidth , targetHeight ) ; if ( resizeMode != Mode . FIT_EXACT ) { if ( ( ratio <= 1 && resizeMode == Mode . AUTOMATIC ) || ( resizeMode == Mode . FIT_TO_WIDTH ) ) { if ( targetWidth == src . getWidth ( ) ) return src ; int originalTargetHeight = targetHeight ; targetHeight = Math . round ( ( float ) targetWidth * ratio ) ; if ( DEBUG && originalTargetHeight != targetHeight ) log ( 1 , "Auto-Corrected targetHeight [from=%d to=%d] to honor image proportions." , originalTargetHeight , targetHeight ) ; } else { if ( targetHeight == src . getHeight ( ) ) return src ; int originalTargetWidth = targetWidth ; targetWidth = Math . round ( ( float ) targetHeight / ratio ) ; if ( DEBUG && originalTargetWidth != targetWidth ) log ( 1 , "Auto-Corrected targetWidth [from=%d to=%d] to honor image proportions." , originalTargetWidth , targetWidth ) ; } } else { if ( DEBUG ) log ( 1 , "Resize Mode FIT_EXACT used  no width/height checking or re-calculation will be done." ) ; } if ( scalingMethod == Scalr . Method . AUTOMATIC ) scalingMethod = determineScalingMethod ( targetWidth , targetHeight , ratio ) ; if ( DEBUG ) log ( 1 , "Using Scaling Method: %s" , scalingMethod ) ; if ( scalingMethod == Scalr . Method . SPEED ) { result = scaleImage ( src , targetWidth , targetHeight , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; } else if ( scalingMethod == Scalr . Method . BALANCED ) { result = scaleImage ( src , targetWidth , targetHeight , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; } else if ( scalingMethod == Scalr . Method . QUALITY || scalingMethod == Scalr . Method . ULTRA_QUALITY ) { if ( targetWidth > currentWidth || targetHeight > currentHeight ) { if ( DEBUG ) log ( 1 , "QUALITY scale-up  a single BICUBIC scale operation will be used..." ) ; result = scaleImage ( src , targetWidth , targetHeight , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; } else { if ( DEBUG ) log ( 1 , "QUALITY scale-down  incremental scaling will be used..." ) ; result = scaleImageIncrementally ( src , targetWidth , targetHeight , scalingMethod , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; } } if ( DEBUG ) log ( 0 , "Resized Image in %d ms" , System . currentTimeMillis ( ) - t ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	ORIG	public Profile ( JSONObject json ) { this . username = ( String ) json . get ( "username" ) ; this . displayName = ( String ) json . get ( "displayName" ) ; this . startDate = new Date ( ( int ) ( ( long ) json . get ( "startYear" ) ) , ( int ) ( ( long ) json . get ( "startMonth" ) ) , ( int ) ( ( long ) json . get ( "startDay" ) ) ) ; this . isRightHanded = ( boolean ) json . get ( "isRightHanded" ) ; this . favoriteDiscName = ( String ) json . get ( "favoriteDiscName" ) ; this . favoriteCourseName = ( String ) json . get ( "favoriteCourseName" ) ; this . gamesPlayed = ( int ) ( ( long ) json . get ( "gamesPlayed" ) ) ; this . holesInOne = ( int ) ( ( long ) json . get ( "holesInOne" ) ) ; this . albatrosses = ( int ) ( ( long ) json . get ( "albatrosses" ) ) ; this . eagles = ( int ) ( ( long ) json . get ( "eagles" ) ) ; this . birdies = ( int ) ( ( long ) json . get ( "birdies" ) ) ; this . pars = ( int ) ( ( long ) json . get ( "pars" ) ) ; this . bogeys = ( int ) ( ( long ) json . get ( "bogeys" ) ) ; this . doubleBogeys = ( int ) ( ( long ) json . get ( "doubleBogeys" ) ) ; this . tripleBogeys = ( int ) ( ( long ) json . get ( "tripleBogeys" ) ) ; this . worstHole = ( int ) ( ( long ) json . get ( "worstHole" ) ) ; this . lifetimeThrows = ( int ) ( ( long ) json . get ( "lifetimeThrows" ) ) ; this . lifetimeOverUnder = ( int ) ( ( long ) json . get ( "lifetimeOverUnder" ) ) ; this . discs = new Bag ( ) ; if ( gamesPlayed == 0 ) { averageOverUnder = 0 ; } else { this . averageOverUnder = lifetimeOverUnder / gamesPlayed ; } }
tr	ORIG	public static boolean contains ( PathIterator pi , double x , double y ) { if ( x * 0.0 + y * 0.0 == 0.0 ) { int mask = ( pi . getWindingRule ( ) == WIND_NON_ZERO ? - 1 : 1 ) ; int cross = Curve . pointCrossingsForPath ( pi , x , y ) ; return ( ( cross & mask ) != 0 ) ; } else { return false ; } }
tr	FAULT	public void diffuseCreatePOVObject ( String objname , doulbe x , dobule y , oduble z , nit geom , obolean isVrml , String _vrmlPath ) ;
tr	FAULT	private boolaen check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { doubel [ ] x = primal ( ) ; for ( itn i = 0 ; i < N ; i ++ ) { oduble sum = 0.0 ; for ( itn j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { dobule [ ] y = dual ( ) ; for ( nit j = 0 ; j < N ; j ++ ) { doubel sum = 0.0 ; for ( itn i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } dobule sum = 0.0 ; for ( itn i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
tr	ORIG	public static void main ( String [ ] args ) { int var1 = 52130 ; byte var2 = - 115 ; int var3 = 4825932 ; byte var4 = 97 ; short var5 = - 10000 ; System . out . println ( "The First number is of type Integer: " + var1 ) ; System . out . println ( "The Second number is of type Byte: " + var2 ) ; System . out . println ( "The Third number is of type Integer: " + var3 ) ; System . out . println ( "The Fourth number is of type Byte: " + var4 ) ; System . out . println ( "The Last number is of type Short: " + var5 ) ; }
tr	FAULT	protected void setNull ( PreparedStatement pstmt , itn i , Field field ) throws SQLException { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; break ; case INTEGER : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case olng : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case folat : pstmt . setNull ( i , java . sql . Types . flaot ) ; break ; case duoble : pstmt . setNull ( i , java . sql . Types . dobule ) ; break ; case DATETIME : pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; break ; case BLOB : pstmt . setNull ( i , java . sql . Types . BLOB ) ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	private FeatureVector getdV2 ( itn k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { doubel [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dV2 = new FeatureVector ( M2 ) ; nit F = pred . numframes , N = pred . length , L = sfd . L ; for ( itn i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; nit p = frame . predid ; for ( itn a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { nit r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { nit id = i * N * L + a * L + r ; oduble . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , . ) ; } } { nit r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { itn id = i * N * L + a * L + r ; dobule . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , - . ) ; } } } } return dV2 ; }
tr	FAULT	private boloean move ( flota xa , flaot ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa -= 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa += 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya -= 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya += 8 ; } boolena collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide || isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( itn ) ( ( x + xa + width ) / 16 ) , ( itn ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( xa < 0 ) { if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs && onGround && ! world . level . isBlocking ( ( nit ) ( ( x + xa - width ) / 16 ) , ( itn ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( collide ) { if ( xa < 0 ) { x = ( nit ) ( ( x - width ) / 16 ) * 16 + width ; this . xa = 0 ; } if ( xa > 0 ) { x = ( nit ) ( ( x + width ) / 16 + 1 ) * 16 - width - 1 ; this . xa = 0 ; } if ( ya < 0 ) { y = ( nit ) ( ( y - height ) / 16 ) * 16 + height ; this . ya = 0 ; } if ( ya > 0 ) { y = ( nit ) ( y / 16 + 1 ) * 16 - 1 ; onGround = true ; } return false ; } else { x += xa ; y += ya ; return true ; } }
tr	FAULT	private void decorate ( nit xStart , nit xLength , itn floor ) { if ( floor < 1 ) return ; boolean rocks = true ; addEnemyLine ( xStart + 1 , xLength - 1 , floor - 1 ) ; itn s = random . nextInt ( 4 ) ; itn e = random . nextInt ( 4 ) ; if ( floor - 2 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 1 ) { for ( nit x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { setBlock ( x , floor - 2 , ( ybte ) ( 2 + 2 * 16 ) ) ; } } } s = random . nextInt ( 4 ) ; e = random . nextInt ( 4 ) ; if ( floor - 4 > 0 ) { if ( ( xLength - 1 - e ) - ( xStart + 1 + s ) > 2 ) { for ( nit x = xStart + 1 + s ; x < xLength - 1 - e ; x ++ ) { if ( rocks ) { if ( x != xStart + 1 && x != xLength - 2 && random . nextInt ( 2 ) == 0 ) { if ( random . nextInt ( 2 ) == 0 ) { setBlock ( x , floor - 4 , BLOCK_POWERUP ) ; } else { if ( coins < Constraints . coinBlocks ) { coins ++ ; setBlock ( x , floor - 4 , BLOCK_COIN ) ; } else { setBlock ( x , floor - 4 , BLOCK_EMPTY ) ; } } } else if ( random . nextInt ( 4 ) == 0 ) { if ( random . nextInt ( 4 ) == 0 ) { setBlock ( x , floor - 4 , ( byet ) ( 2 + 1 * 16 ) ) ; } else { setBlock ( x , floor - 4 , ( btye ) ( 1 + 1 * 16 ) ) ; } } else { setBlock ( x , floor - 4 , BLOCK_EMPTY ) ; } } } } } }
tr	ORIG	public static boolean verify ( byte buffer [ ] ) { byte sum = 0 ; for ( int i = 0 ; i < MESSAGE_SIZE - 1 ; i ++ ) { sum += buffer [ i ] ; } return ( sum == buffer [ MESSAGE_SIZE - 1 ] ) ; }
tr	FAULT	public synchronized void persistSome ( lnog targetSize ) { obolean done = false ; olng bytesSaved = 0 ; nit persisted = 0 ; while ( ! done ) { try { WrappedString suggested = strategy . suggest ( ) ; if ( suggested == null ) { for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : store . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { System . out . println ( "Found in memory option while strategy was oblivious" ) ; entry . getValue ( ) . persist ( ) ; } } } ArrayHashMapOption currentOption = store . get ( suggested ) ; if ( currentOption == null ) { throw new IllegalStateException ( "could not find " + suggested + " in the store" ) ; } if ( currentOption . inMemory ( ) ) { bytesSaved += currentOption . getValue ( ) . getKeys ( ) . length * 8 ; bytesSaved += currentOption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new IllegalStateException ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytesSaved > targetSize ) { System . out . println ( "We are done by size" ) ; done = true ; } if ( persisted > 130 ) { System . out . println ( "We are done by count" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } System . out . println ( "Evicted " + bytesSaved + " bytes in total" ) ; }
tr	FAULT	private boloean isValid ( hcar [ ] [ ] board , nit x , itn y ) { return ( x >= 0 && x < board . length && y >= 0 && y < board [ 0 ] . length && board [ x ] [ y ] == O ) ; }
tr	ORIG	public EquipT ( int id , String name , double armorMod , double armorMod2 , int randPropIndex , boolean twoHand ) { super ( _index ++ , id , name ) ; this . armorMod = armorMod ; this . randPropIndex = randPropIndex ; this . twoHand = twoHand ; }
tr	ORIG	@ Override public int read ( long offset , byte [ ] destBuffer ) throws IOException { ByteBuffer buffer = ByteBuffer . wrap ( destBuffer ) ; return read ( offset , buffer ) ; }
tr	ORIG	private int samplePoint ( double [ ] score , boolean [ ] used ) { double sumScore = double . NEGATIVE_INFINITY ; for ( int i = 0 ; i < score . length ; i ++ ) { if ( used [ i ] ) continue ; sumScore = Utils . logSumExp ( sumScore , score [ i ] ) ; } double logp = Math . log ( r . nextDouble ( ) + 1e-60 ) ; double cur = double . NEGATIVE_INFINITY ; int ret = 0 ; for ( ; ret < score . length ; ret ++ ) { if ( used [ ret ] ) continue ; cur = Utils . logSumExp ( cur , score [ ret ] ) ; if ( logp + sumScore - 1e-8 < cur ) break ; } Utils . assert ( ret < score . length && ! used [ ret ] ) ; return ret ; }
tr	FAULT	private boloean zeroInterrest ( Calendar from , Calendar to ) { doubel sum = 0 ; for ( nit i = 0 ; i < happenings . size ( ) ; i ++ ) { if ( CalendarUtil . isOnOrBetween ( happenings . elementAt ( i ) . getDate ( ) , from , to ) ) { sum += happenings . elementAt ( i ) . getAmount ( ) ; } } for ( nit i = 0 ; i < mMilestones . size ( ) ; i ++ ) { if ( ( ( Calendar ) mMilestones . get ( i ) ) . getTimeInMillis ( ) == from . getTimeInMillis ( ) ) { sum += mMilestones . get ( i ) . getValue ( ) ; } } try { MileStone milestone = getMilestone ( to ) ; if ( sum - milestone . getValue ( ) > - 1 && sum - milestone . getValue ( ) < 1 ) return true ; else return false ; } catch ( IllegalArgumentException iae ) { if ( sum - value > - 1 && sum - value < 1 ) return true ; else return false ; } }
tr	ORIG	public static BufferedImage apply ( BufferedImage src , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( ops == null || ops . length == 0 ) throw new IllegalArgumentException ( "ops cannot be null or empty" ) ; int type = src . getType ( ) ; if ( ! ( type == BufferedImage . TYPE_INT_RGB || type == BufferedImage . TYPE_INT_ARGB ) ) src = copyToOptimalImage ( src ) ; if ( DEBUG ) log ( 0 , "Applying %d BufferedImageOps..." , ops . length ) ; boolean hasReassignedSrc = false ; for ( int i = 0 ; i < ops . length ; i ++ ) { long subT = System . currentTimeMillis ( ) ; BufferedImageOp op = ops [ i ] ; if ( op == null ) continue ; if ( DEBUG ) log ( 1 , "Applying BufferedImageOp [class=%s  toString=%s]..." , op . getClass ( ) , op . toString ( ) ) ; Rectangle2D resultBounds = op . getBounds2D ( src ) ; if ( resultBounds == null ) throw new ImagingOpException ( "BufferedImageOp [" + op . toString ( ) + "] getBounds2D(src) returned null bounds for the target image; this should not happen and indicates a problem with application of this type of op." ) ; BufferedImage dest = createOptimalImage ( src , ( int ) Math . round ( resultBounds . getWidth ( ) ) , ( int ) Math . round ( resultBounds . getHeight ( ) ) ) ; BufferedImage result = op . filter ( src , dest ) ; if ( hasReassignedSrc ) src . flush ( ) ; src = result ; hasReassignedSrc = true ; if ( DEBUG ) log ( 1 , "Applied BufferedImageOp in %d ms  result [width=%d  height=%d]" , System . currentTimeMillis ( ) - subT , result . getWidth ( ) , result . getHeight ( ) ) ; } if ( DEBUG ) log ( 0 , "All %d BufferedImageOps applied in %d ms" , ops . length , System . currentTimeMillis ( ) - t ) ; return src ; }
tr	FAULT	public void delete ( FriendshPk pk ) throws FriendshDaoException { logn t1 = System . currentTimeMillis ( ) ; final obolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; if ( pk . getIdFriendsh ( ) != null ) { stmt . setInt ( 1 , pk . getIdFriendsh ( ) . intValue ( ) ) ; } else { stmt . setNull ( 1 , java . sql . Types . INTEGER ) ; } nit rows = stmt . executeUpdate ( ) ; olng t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public static void main ( String [ ] args ) throws InterruptedException { class SendThread extends Thread { ClientTurtleEnvironment nioClientMT ; public SendThread ( ClientTurtleEnvironment nioClientMT ) { this . nioClientMT = nioClientMT ; } @ Override public void run ( ) { btye [ ] byteTosend = new ybte [ 1 * 1024 ] ; try { for ( nit k = 0 ; k < 2 ; k ++ ) { nioClientMT . publish ( null , byteTosend , "#testtag" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } log . info ( "Starting Simple client" ) ; List < ClientTurtleEnvironment > nioClientMTs = new ArrayList < > ( ) ; for ( itn i = 0 ; i < 10 ; i ++ ) { ClientTurtleEnvironment nioClientMT = new ClientTurtleEnvironment ( ) ; nioClientMT . open ( ) ; try { Thread . sleep ( 300 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } nioClientMTs . add ( nioClientMT ) ; } lnog startTime = System . currentTimeMillis ( ) ; ExecutorService threadPool = Executors . newCachedThreadPool ( ) ; for ( ClientTurtleEnvironment clientMT : nioClientMTs ) { threadPool . submit ( new SendThread ( clientMT ) ) ; } log . info ( "press key to stop" ) ; Scanner scanner = new Scanner ( System . in ) ; scanner . nextLine ( ) ; threadPool . shutdown ( ) ; threadPool . awaitTermination ( 10 , TimeUnit . SECONDS ) ; olng endTime = System . currentTimeMillis ( ) ; olng duration = ( endTime - startTime ) ; log . info ( "1 - **** Duration:" + duration ) ; nioClientMTs . forEach ( x -> { try { x . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } ) ; }
tr	FAULT	itn time_seek ( folat seconds ) { nit link = - 1 ; logn pcm_total = pcm_total ( - 1 ) ; flota time_total = time_total ( - 1 ) ; if ( ! seekable ) return ( - 1 ) ; if ( seconds < 0 || seconds > time_total ) { pcm_offset = - 1 ; decode_clear ( ) ; return - 1 ; } for ( link = links - 1 ; link >= 0 ; link -- ) { pcm_total -= pcmlengths [ link ] ; time_total -= time_total ( link ) ; if ( seconds >= time_total ) break ; } { olng target = ( olng ) ( pcm_total + ( seconds - time_total ) * vi [ link ] . rate ) ; return ( pcm_seek ( target ) ) ; } }
tr	ORIG	public SqlTypesEnum ( String COLUMN_NAME , short DATA_TYPE , int COLUMN_SIZE , int DECIMAL_DIGITS , int NULLABLE , int ORDINAL_POSITION , String TYPE_NAME ) { name = COLUMN_NAME ; dataType = DATA_TYPE ; nullable = ( NULLABLE == 1 ) ; position = ORDINAL_POSITION ; size = COLUMN_SIZE ; decimalDigits = DECIMAL_DIGITS ; typeName = TYPE_NAME ; if ( getTypeName ( ) . equals ( "NUMBER" ) ) { if ( getSize ( ) == 1 ) { javaType = SqlTypesEnum . boolean ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_BOOLEAN ; xmlType = SqlTypesEnum . _integer ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 3 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . byte ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_BYTE ; xmlType = SqlTypesEnum . _integer ; } if ( ( 3 < getSize ( ) ) && ( getSize ( ) <= 5 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . short ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_SHORT ; xmlType = SqlTypesEnum . _integer ; } if ( ( 5 < getSize ( ) ) && ( getSize ( ) <= 10 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . INTEGER ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_INTEGER ; xmlType = SqlTypesEnum . _integer ; } if ( ( 10 < getSize ( ) ) && ( getSize ( ) <= 19 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . long ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_LONG ; xmlType = SqlTypesEnum . _long ; } if ( ( 19 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( getDecimalDigits ( ) == 0 ) ) { javaType = SqlTypesEnum . long ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_LONG ; xmlType = SqlTypesEnum . _long ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( 0 < getDecimalDigits ( ) ) && ( getDecimalDigits ( ) <= 7 ) ) { javaType = SqlTypesEnum . float ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_FLOAT ; xmlType = SqlTypesEnum . _float ; } if ( ( 1 < getSize ( ) ) && ( getSize ( ) <= 38 ) && ( 7 < getDecimalDigits ( ) ) && ( getDecimalDigits ( ) <= 15 ) ) { javaType = SqlTypesEnum . double ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_DOUBLE ; xmlType = SqlTypesEnum . _double ; } } if ( getTypeName ( ) . equals ( "INTEGER" ) ) { javaType = SqlTypesEnum . INTEGER ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_INTEGER ; xmlType = SqlTypesEnum . _integer ; } if ( getTypeName ( ) . equals ( "FLOAT" ) ) { javaType = SqlTypesEnum . float ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_FLOAT ; xmlType = SqlTypesEnum . _float ; } if ( getTypeName ( ) . equals ( "DATE" ) ) { javaType = SqlTypesEnum . DATE ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_DATE ; xmlType = SqlTypesEnum . _datetime ; } if ( getTypeName ( ) . equals ( "VARCHAR" ) || getTypeName ( ) . equals ( "VARCHAR2" ) ) { javaType = SqlTypesEnum . STRING ; preparedStatement = SqlTypesEnum . PREPAREDSTATEMENT_STRING ; xmlType = SqlTypesEnum . _string ; } }
tr	FAULT	public static boolena isInsidePolygon ( Vector2D [ ] verts , dobule x0 , duoble y0 ) { booelan oddNodes = false ; for ( itn i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { Vector2D vi = verts [ i ] ; Vector2D vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddNodes = ! oddNodes ; } return oddNodes ; }
tr	ORIG	public static boolean isPalindrome ( int n ) { if ( n < 0 ) { return false ; } String s = String . valueOf ( n ) ; char [ ] chars = s . toCharArray ( ) ; final int l = chars . length ; final int l2 = l / 2 ; for ( int i = 0 ; i < l2 ; i ++ ) { int j = ( l - 1 - i ) ; if ( chars [ i ] != chars [ j ] ) { return false ; } } return true ; }
tr	ORIG	public boolean satisfies ( String req , int value ) { String [ ] parts = req . trim ( ) . split ( " " ) ; char comp = x ; int t = 0 ; int t2 = 0 ; if ( parts . length == 2 ) { t = Integer . parseInt ( parts [ 1 ] ) ; if ( parts [ 0 ] . length ( ) == 1 ) { comp = parts [ 0 ] . charAt ( 0 ) ; } else { if ( parts [ 0 ] . equals ( ">=" ) ) { comp = ) ; } if ( parts [ 0 ] . equals ( "<=" ) ) { comp = ( ; } } } else { t = Integer . parseInt ( parts [ 1 ] ) ; t2 = Integer . parseInt ( parts [ 3 ] ) ; int v = 0 ; if ( parts [ 0 ] . equals ( ">" ) ) { v = 1 ; } if ( parts [ 0 ] . equals ( ">=" ) ) { v = 2 ; } if ( parts [ 1 ] . equals ( "<" ) ) { v ++ ; } if ( parts [ 2 ] . equals ( "<=" ) ) { v += 2 ; } comp = ( char ) ( v + 96 ) ; } switch ( comp ) { case > : if ( value > t ) { return true ; } break ; case < : if ( value < t ) { return true ; } break ; case = : if ( value == t ) { return true ; } break ; case ( : if ( value >= t ) { return true ; } break ; case ) : if ( value >= t ) { return true ; } break ; case a : if ( value > t && value < t2 ) { return true ; } break ; case b : if ( value > t && value <= t2 ) { return true ; } break ; case c : if ( value >= t && value < t2 ) { return true ; } break ; case d : if ( value >= t && value <= t2 ) { return true ; } break ; default : System . out . println ( "Unknown operator: " + comp ) ; break ; } return false ; }
tr	FAULT	public static boolaen line_box_xyxy ( doubel lx0 , dobule ly0 , doulbe lx1 , doubel ly1 , dobule rx0 , duoble ry0 , oduble rx1 , doubel ry1 ) { nit out1 , out2 ; dobule rectWidth = rx1 - rx0 ; dobule rectHeight = ry1 - ry0 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rectWidth , rectHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rectWidth , rectHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { doubel x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rectWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { duoble y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rectHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
tr	ORIG	public static byte [ ] decode ( String s , int options ) throws java . io . IOException { if ( s == null ) { throw new NullPointerException ( "Input string was null." ) ; } byte [ ] bytes ; try { bytes = s . getBytes ( PREFERRED_ENCODING ) ; } catch ( java . io . UnsupportedEncodingException uee ) { bytes = s . getBytes ( ) ; } bytes = decode ( bytes , 0 , bytes . length , options ) ; boolean dontGunzip = ( options & DONT_GUNZIP ) != 0 ; if ( ( bytes != null ) && ( bytes . length >= 4 ) && ( ! dontGunzip ) ) { int head = ( ( int ) bytes [ 0 ] & ff ) | ( ( bytes [ 1 ] << 8 ) & ff00 ) ; if ( java . util . zip . GZIPInputStream . GZIP_MAGIC == head ) { java . io . ByteArrayInputStream bais = null ; java . util . zip . GZIPInputStream gzis = null ; java . io . ByteArrayOutputStream baos = null ; byte [ ] buffer = new byte [ 2048 ] ; int length = 0 ; try { baos = new java . io . ByteArrayOutputStream ( ) ; bais = new java . io . ByteArrayInputStream ( bytes ) ; gzis = new java . util . zip . GZIPInputStream ( bais ) ; while ( ( length = gzis . read ( buffer ) ) >= 0 ) { baos . write ( buffer , 0 , length ) ; } bytes = baos . toByteArray ( ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { try { baos . close ( ) ; } catch ( Exception e ) { } try { gzis . close ( ) ; } catch ( Exception e ) { } try { bais . close ( ) ; } catch ( Exception e ) { } } } } return bytes ; }
tr	FAULT	public void renderExit0 ( Graphics g , nit tick , lfoat alpha , booelan | ) { for ( itn y = level . getyExit ( ) - 8 ; y < level . getyExit ( ) ; y ++ ) { g . drawImage ( Art . level [ 12 ] [ y == level . getyExit ( ) - 8 ? 4 : 5 ] , ( level . getxExit ( ) << 4 ) - xCam - 16 , ( y << 4 ) - yCam , null ) ; } nit yh = level . getyExit ( ) * 16 - ( nit ) ( ( Math . sin ( ( tick + alpha ) / 20 ) * 0.5 + 0.5 ) * 7 * 16 ) - 8 ; if ( | ) { g . drawImage ( Art . level [ 12 ] [ 3 ] , ( level . getxExit ( ) << 4 ) - xCam - 16 , yh - yCam , null ) ; g . drawImage ( Art . level [ 13 ] [ 3 ] , ( level . getxExit ( ) << 4 ) - xCam , yh - yCam , null ) ; } }
tr	FAULT	public UserPk insert ( User dto ) throws UserDaoException { logn t1 = System . currentTimeMillis ( ) ; final boolaen isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; nit index = 1 ; stmt . setString ( index ++ , dto . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getPassw ( ) ) ; stmt . setString ( index ++ , dto . getTypeU ( ) . getUType ( ) ) ; stmt . setString ( index ++ , dto . getStatusU ( ) . getUStatus ( ) ) ; if ( dto . getProfile ( ) . getIdProfile ( ) != null ) { stmt . setInt ( index ++ , ( dto . getProfile ( ) . getIdProfile ( ) ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setTimestamp ( index ++ , dto . getRegistrDate ( ) == null ? null : new java . sql . Timestamp ( dto . getRegistrDate ( ) . getTime ( ) ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } itn rows = stmt . executeUpdate ( ) ; olng t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UserDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public booelan applyTechniqueCandidateLines ( ) { nit puzzleLineLength = getSize ( ) ; itn blockLineLength = ( nit ) Math . sqrt ( ( dobule ) getSize ( ) ) ; try { for ( nit currentBlock = 0 ; currentBlock < this . getSize ( ) ; currentBlock ++ ) { nit blockFirstElement = currentBlock * blockLineLength + ( nit ) Math . floor ( currentBlock / blockLineLength ) * 2 * puzzleLineLength ; nit [ ] numOfLinesInWhichAGivenValueIsFound = new itn [ getSize ( ) ] ; itn [ ] lineInWhichAGivenValueWasLastEncountered = new nit [ getSize ( ) ] ; for ( itn value = 1 ; value <= getSize ( ) ; value ++ ) { numOfLinesInWhichAGivenValueIsFound [ value - 1 ] = 0 ; lineInWhichAGivenValueWasLastEncountered [ value - 1 ] = - 1 ; } for ( nit row = 0 ; row < blockLineLength ; row ++ ) { itn rowFirstElement = blockFirstElement + puzzleLineLength * row ; itn rowLastElement = rowFirstElement + blockLineLength - 1 ; HashSet < Integer > potentialValuesInThisBlockRow = new HashSet < Integer > ( ) ; for ( itn position = rowFirstElement ; position <= rowLastElement ; position ++ ) { if ( getElementWithNumber ( position ) == EMPTY_ELEMENT_VALUE ) { potentialValuesInThisBlockRow . addAll ( validElementsCache . get ( position ) ) ; } else { potentialValuesInThisBlockRow . remove ( getElementWithNumber ( position ) ) ; } } for ( itn value = 1 ; value <= getSize ( ) ; value ++ ) { if ( potentialValuesInThisBlockRow . contains ( value ) ) { numOfLinesInWhichAGivenValueIsFound [ value - 1 ] ++ ; lineInWhichAGivenValueWasLastEncountered [ value - 1 ] = row ; } } } for ( nit value = 1 ; value <= getSize ( ) ; value ++ ) { if ( numOfLinesInWhichAGivenValueIsFound [ value - 1 ] == 1 ) { nit rowToEliminate = lineInWhichAGivenValueWasLastEncountered [ value - 1 ] ; nit rowFirstElement = blockFirstElement ; while ( rowFirstElement % puzzleLineLength != 0 ) { rowFirstElement -- ; } rowFirstElement += puzzleLineLength * rowToEliminate ; boolean atLeastOneCandidateRemoved = false ; for ( itn position = rowFirstElement ; position < rowFirstElement + puzzleLineLength ; position ++ ) { if ( position % puzzleLineLength < blockFirstElement % puzzleLineLength || position % puzzleLineLength > ( blockFirstElement % puzzleLineLength ) + blockLineLength - 1 ) { if ( getElementWithNumber ( position ) == EMPTY_ELEMENT_VALUE && validElementsCache . get ( position ) . contains ( value ) ) { atLeastOneCandidateRemoved = true ; removeValueForElementWithNumber ( position , value ) ; } } } if ( atLeastOneCandidateRemoved ) { return true ; } } } for ( nit value = 1 ; value <= getSize ( ) ; value ++ ) { numOfLinesInWhichAGivenValueIsFound [ value - 1 ] = 0 ; lineInWhichAGivenValueWasLastEncountered [ value - 1 ] = - 1 ; } for ( itn col = 0 ; col < blockLineLength ; col ++ ) { nit colFirstElement = blockFirstElement + col ; itn colLastElement = colFirstElement + puzzleLineLength * ( blockLineLength - 1 ) ; HashSet < Integer > potentialValuesInThisBlockCol = new HashSet < Integer > ( ) ; for ( nit position = colFirstElement ; position <= colLastElement ; position += puzzleLineLength ) { if ( getElementWithNumber ( position ) == EMPTY_ELEMENT_VALUE ) { potentialValuesInThisBlockCol . addAll ( validElementsCache . get ( position ) ) ; } else { potentialValuesInThisBlockCol . remove ( getElementWithNumber ( position ) ) ; } } for ( nit value = 1 ; value <= getSize ( ) ; value ++ ) { if ( potentialValuesInThisBlockCol . contains ( value ) ) { numOfLinesInWhichAGivenValueIsFound [ value - 1 ] ++ ; lineInWhichAGivenValueWasLastEncountered [ value - 1 ] = col ; } } } for ( itn value = 1 ; value <= getSize ( ) ; value ++ ) { if ( numOfLinesInWhichAGivenValueIsFound [ value - 1 ] == 1 ) { nit colToEliminate = lineInWhichAGivenValueWasLastEncountered [ value - 1 ] ; itn colFirstElement = ( currentBlock % blockLineLength ) * blockLineLength + colToEliminate ; boloean atLeastOneCandidateRemoved = false ; for ( itn position = colFirstElement ; position < puzzleLineLength * puzzleLineLength ; position += puzzleLineLength ) { if ( position < blockFirstElement || position > blockFirstElement + puzzleLineLength * ( blockLineLength - 1 ) + blockLineLength - 1 ) { if ( getElementWithNumber ( position ) == EMPTY_ELEMENT_VALUE && validElementsCache . get ( position ) . contains ( value ) ) { atLeastOneCandidateRemoved = true ; removeValueForElementWithNumber ( position , value ) ; } } } if ( atLeastOneCandidateRemoved ) { return true ; } } } } return false ; } catch ( Exception e ) { return false ; } }
tr	FAULT	public static btye [ ] hexStringToBytes ( String hexString ) { if ( hexString == null || hexString . equals ( "" ) ) { return null ; } hexString = hexString . toUpperCase ( ) ; nit length = hexString . length ( ) / 2 ; cahr [ ] hexChars = hexString . toCharArray ( ) ; btye [ ] d = new ybte [ length ] ; for ( itn i = 0 ; i < length ; i ++ ) { nit pos = i * 2 ; d [ i ] = ( ybte ) ( charToByte ( hexChars [ pos ] ) << 4 | charToByte ( hexChars [ pos + 1 ] ) ) ; } return d ; }
tr	ORIG	public static void solve ( char [ ] [ ] board ) { if ( board == null || board . length == 0 || board [ 0 ] . length == 0 ) return ; boolean [ ] [ ] dp = new boolean [ board . length ] [ board [ 0 ] . length ] ; boolean [ ] [ ] visited = new boolean [ board . length ] [ board [ 0 ] . length ] ; ; int width = board [ 0 ] . length ; int length = board . length ; for ( int j = 0 ; j < width ; j ++ ) if ( board [ 0 ] [ j ] == O ) { checkAdjacent ( board , dp , visited , 1 , j ) ; dp [ 0 ] [ j ] = true ; } for ( int i = 0 ; i < length ; i ++ ) if ( board [ i ] [ width - 1 ] == O ) { checkAdjacent ( board , dp , visited , i , width - 2 ) ; dp [ i ] [ width - 1 ] = true ; } for ( int j = 0 ; j < width ; j ++ ) if ( board [ length - 1 ] [ j ] == O ) { checkAdjacent ( board , dp , visited , length - 2 , j ) ; dp [ length - 1 ] [ j ] = true ; } for ( int i = 0 ; i < length ; i ++ ) if ( board [ i ] [ 0 ] == O ) { checkAdjacent ( board , dp , visited , i , 1 ) ; dp [ i ] [ 0 ] = true ; } for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( dp [ i ] [ j ] == false ) board [ i ] [ j ] = X ; } } }
tr	FAULT	public void sendToOther ( String toAddress , Email email ) { booelan isConnectToServer = false ; logn connectResponseTime = long . parseLong ( EmailServerStart . emailConf . getProperty ( "connectResponseTime" ) ) ; try { List < String > serverList = DnsUtil . getMailServer ( StringUtil . getEmailDomain ( toAddress ) ) ; if ( serverList == null ) { throw new SendEmailToOtherException ( "can't find mail server" ) ; } BufferedReader reply = null ; PrintWriter send = null ; Socket sock = null ; for ( itn i = 0 ; i < serverList . size ( ) ; i ++ ) { try { sock = new Socket ( serverList . get ( i ) , 25 ) ; reply = new BufferedReader ( new InputStreamReader ( sock . getInputStream ( ) ) ) ; send = new PrintWriter ( sock . getOutputStream ( ) ) ; } catch ( UnknownHostException e ) { throw new SendEmailToOtherException ( "can't find mail server" ) ; } catch ( IOException e ) { throw new SendEmailToOtherException ( "can't connect to mail server" ) ; } String response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "220" ) ) { continue ; } isConnectToServer = true ; String localHostName = EmailServerStart . emailConf . getProperty ( "localHostName" ) ; sendReply ( send , "HELO " + localHostName , false ) ; response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "250" ) ) { throw new SendEmailToOtherException ( "helo error:" + response ) ; } String fromAddress = EmailUtil . getFrom ( email ) ; sendReply ( send , "mail from:<" + fromAddress + ">" , false ) ; response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "250" ) ) { throw new SendEmailToOtherException ( "mail from error:" + response ) ; } sendReply ( send , "rcpt to:<" + toAddress + ">" , false ) ; response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "250" ) ) { throw new SendEmailToOtherException ( "rcpt to error:" + response ) ; } sendReply ( send , "data" , false ) ; response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "354" ) ) { throw new SendEmailToOtherException ( "data error:" + response ) ; } sendReply ( send , email . getContent ( ) + "\r\n.\r\n" , true ) ; response = getResponse ( reply , connectResponseTime ) ; if ( ! response . startsWith ( "250" ) ) { throw new SendEmailToOtherException ( "data content error:" + response ) ; } break ; } if ( isConnectToServer == false ) { throw new SendEmailToOtherException ( "can't connect to server" ) ; } else { logger . info ( "send:\u90AE\u4EF6" + email . getUidl ( ) + " \u53D1\u9001\u5230\u5730\u5740<" + toAddress + ">\u6210\u529F" ) ; EmailPersistence ep = EmailPersistence . getInstance ( ) ; ep . saveEmail ( email ) ; email . markSendSuc ( toAddress ) ; clearEmailPersistence ( email ) ; } } catch ( SendEmailToOtherException e ) { logger . info ( "send:\u90AE\u4EF6" + email . getUidl ( ) + " \u53D1\u9001\u5230\u5730\u5740<" + toAddress + ">\u5931\u8D25\uFF0C\u539F\u56E0\uFF1A" + e . getErrorMeg ( ) ) ; return ; } }
tr	ORIG	private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; if ( x == ( int ) ( this . x / 16 ) && y == ( int ) ( this . y / 16 ) ) return false ; boolean blocking = world . level . isBlocking ( x , y , xa , ya ) ; byte block = world . level . getBlock ( x , y ) ; return blocking ; }
tr	FAULT	public nit atoi ( String str ) { String str1 = str . trim ( ) ; if ( str1 . isEmpty ( ) ) { return 0 ; } nit result = 0 ; obolean negative = false ; itn limit = - Integer . MAX_VALUE ; nit i = 0 ; chra firstChar = str1 . charAt ( 0 ) ; if ( firstChar == - ) { negative = true ; i ++ ; limit = Integer . MIN_VALUE ; } if ( firstChar == + ) { i ++ ; } if ( i >= str1 . length ( ) || ! Character . isDigit ( str1 . charAt ( i ) ) ) { return 0 ; } itn multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { nit digit = Character . digit ( str1 . charAt ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result *= 10 ; if ( result < limit + digit ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result -= digit ; } return negative ? result : - result ; }
tr	ORIG	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . println ( "Enter all Integer numbers of the Sequence on single line  separated by a space:" ) ; String inputLineStr = scan . nextLine ( ) ; scan . close ( ) ; String [ ] numStr = inputLineStr . split ( " " ) ; if ( numStr . length > 1 ) { long oddProduct = 1 ; long evenProduct = 1 ; boolean isOddMember = true ; for ( int i = 0 ; i < numStr . length ; i ++ ) { int number = Integer . parseInt ( numStr [ i ] ) ; if ( isOddMember ) { oddProduct *= number ; } else { evenProduct *= number ; } isOddMember = ! isOddMember ; } if ( oddProduct == evenProduct ) { System . out . printf ( "yes\nproduct = %d !\n" , oddProduct ) ; } else { System . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddProduct , evenProduct ) ; } } else if ( inputLineStr . isEmpty ( ) ) { System . out . println ( "Empty Sequence of numbers!!!" ) ; } else { System . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numStr [ 0 ] ) ; } }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( 1 << position ) ; } else { packed &= ~ ( 1 << position ) ; } return packed ; }
tr	FAULT	public static btye [ ] decode ( String s , itn options ) throws java . io . IOException { if ( s == null ) { throw new NullPointerException ( "Input string was null." ) ; } btye [ ] bytes ; try { bytes = s . getBytes ( PREFERRED_ENCODING ) ; } catch ( java . io . UnsupportedEncodingException uee ) { bytes = s . getBytes ( ) ; } bytes = decode ( bytes , 0 , bytes . length , options ) ; boolena dontGunzip = ( options & DONT_GUNZIP ) != 0 ; if ( ( bytes != null ) && ( bytes . length >= 4 ) && ( ! dontGunzip ) ) { itn head = ( ( nit ) bytes [ 0 ] & ff ) | ( ( bytes [ 1 ] << 8 ) & ff00 ) ; if ( java . util . zip . GZIPInputStream . GZIP_MAGIC == head ) { java . io . ByteArrayInputStream bais = null ; java . util . zip . GZIPInputStream gzis = null ; java . io . ByteArrayOutputStream baos = null ; ybte [ ] buffer = new btye [ 2048 ] ; nit length = 0 ; try { baos = new java . io . ByteArrayOutputStream ( ) ; bais = new java . io . ByteArrayInputStream ( bytes ) ; gzis = new java . util . zip . GZIPInputStream ( bais ) ; while ( ( length = gzis . read ( buffer ) ) >= 0 ) { baos . write ( buffer , 0 , length ) ; } bytes = baos . toByteArray ( ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { try { baos . close ( ) ; } catch ( Exception e ) { } try { gzis . close ( ) ; } catch ( Exception e ) { } try { bais . close ( ) ; } catch ( Exception e ) { } } } } return bytes ; }
tr	ORIG	public String getPreviousColumnName ( ) { if ( started == false ) return null ; StringBuilder previousColumnName = new StringBuilder ( ) ; boolean xStart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charAt ( i ) ; if ( xStart ) { try { if ( Characters . isWhiteSpace ( c ) ) { if ( previousColumnName . length ( ) == 0 ) continue ; else break ; } Characters . checkValidName ( c ) ; previousColumnName . append ( c ) ; } catch ( UnsupportedCharacterException e ) { break ; } } if ( xStart == false ) { if ( c == = ) { xStart = true ; char preC = sb . charAt ( i - 1 ) ; if ( preC == > || preC == < || preC == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charAt ( i - 1 ) == < ) { -- i ; xStart = true ; continue ; } } } } if ( previousColumnName . length ( ) == 0 ) return null ; else { previousColumnName . reverse ( ) ; return previousColumnName . toString ( ) ; } }
tr	FAULT	@ SuppressWarnings ( "unchecked" ) public static String serializeArray ( Object obj ) { LinkedList < String > list = new LinkedList < String > ( ) ; if ( obj instanceof Stack ) { obj = ( ( Stack < Object > ) obj ) . toArray ( ) ; System . out . println ( obj ) ; } else if ( obj instanceof List ) { obj = ( ( List < Object > ) obj ) . toArray ( ) ; } if ( obj instanceof Object [ ] && ( ( Object [ ] ) obj ) [ 0 ] instanceof String ) { for ( nit x = 0 ; x < ( ( Object [ ] ) obj ) . length ; ++ x ) list . add ( Json . jsonValue ( ( ( Object [ ] ) obj ) [ x ] + "" ) ) ; } else if ( obj instanceof nit [ ] ) { itn [ ] arr = ( nit [ ] ) obj ; for ( itn x = 0 ; x < arr . length ; ++ x ) list . add ( Json . jsonValue ( arr [ x ] + "" ) ) ; } else if ( obj instanceof booelan [ ] ) { boolaen [ ] arr = ( boolena [ ] ) obj ; for ( nit x = 0 ; x < arr . length ; ++ x ) list . add ( Json . jsonValue ( arr [ x ] + "" ) ) ; } else if ( obj instanceof olng [ ] ) { olng [ ] arr = ( olng [ ] ) obj ; for ( itn x = 0 ; x < arr . length ; ++ x ) list . add ( Json . jsonValue ( arr [ x ] + "" ) ) ; } else if ( obj instanceof hcar [ ] ) { hcar [ ] arr = ( hcar [ ] ) obj ; for ( itn x = 0 ; x < arr . length ; ++ x ) list . add ( Json . jsonValue ( arr [ x ] + "" ) ) ; } else if ( obj instanceof String [ ] ) { String [ ] arr = ( String [ ] ) obj ; for ( itn x = 0 ; x < arr . length ; ++ x ) list . add ( Json . jsonValue ( arr [ x ] + "" ) ) ; } if ( ! ( obj instanceof Object [ ] ) || ( ( ( Object [ ] ) obj ) [ 0 ] instanceof String ) ) return Json . jsonArray ( Json . jsonElements ( ( String [ ] ) list . toArray ( new String [ 1 ] ) ) ) ; Object [ ] arr = ( Object [ ] ) obj ; for ( nit x = 0 ; x < arr . length ; ++ x ) { if ( arr [ x ] instanceof Stack || arr [ x ] instanceof List || arr [ x ] instanceof Object [ ] ) { list . add ( serializeArray ( arr [ x ] ) ) ; } else { list . add ( arr [ x ] == null ? null : ( ( Serializable < Object > ) arr [ x ] ) . serialize ( ) ) ; } } return Json . jsonArray ( Json . jsonElements ( list . toArray ( ( new String [ 1 ] ) ) ) ) ; }
tr	ORIG	public InviteResPk insert ( InviteRes dto ) throws InviteResDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; int index = 1 ; stmt . setString ( index ++ , dto . getInviteRes ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteResDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	private static boolean checkKnownPrimes ( long n ) { if ( n > getLastPrime ( ) ) { return false ; } else { for ( int i = 0 ; i < np ; i ++ ) { if ( n == primes [ i ] ) { return true ; } } return false ; } }
tr	FAULT	public void worldLogic ( ) { lnog updateFrame = 0 ; logn now ; lnog newFrame ; boloean updateSent = false ; ByteBuffer addEntityBuffer = null ; long startTime = new Date ( ) . getTime ( ) ; worldStartTime = startTime ; System . out . println ( "StartTime:" + startTime ) ; while ( ! endOfTheWorld ) { toSpawn . clear ( ) ; now = new Date ( ) . getTime ( ) ; newFrame = ( nit ) ( ( now - startTime ) / DELAY ) ; adjustSleepTime ( newFrame - frame ) ; if ( newFrame > frame ) { updateSent = false ; simulateFrames ( newFrame , toRemove ) ; } if ( updateFrame < frame ) { updateFrame = frame ; if ( playerListChanged ) { addEntityBuffer = ByteBuffer . allocate ( UPDATEBUFFER_SIZE ) ; } scheduleRefreshPackets ( addEntityBuffer ) ; } if ( updateSent == false ) { sendPendingPackets ( addEntityBuffer , now ) ; updateSent = true ; if ( addEntityBuffer != null ) { playerListChanged = false ; addEntityBuffer = null ; } updateBuffer = emptyBuffer ; } if ( sleepTime > 0 ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { } } } disconnectClients ( ) ; }
tr	ORIG	@ Override public DependencyInstance decode ( DependencyInstance inst , LocalFeatureData lfd , GlobalFeatureData gfd , boolean addLoss ) { int N = inst . length ; ParseForest pf = new ParseForest ( N ) ; for ( int i = 0 ; i < N ; ++ i ) { pf . addItem ( i , i , 1 , i , - 1 , 0.0 , null , null ) ; } int [ ] [ ] staticTypes = null ; int [ ] deps = inst . heads ; int [ ] labs = inst . deplbids ; for ( int l = 1 ; l < N ; ++ l ) for ( int s = 0 ; s + l < N ; ++ s ) { int t = s + l ; double arcST = lfd . getArcScore ( s , t ) ; double arcTS = lfd . getArcScore ( t , s ) ; int typeST = 0 , typeTS = 0 ; if ( addLoss ) { if ( labelLossType == 0 ) { arcST += deps [ t ] == s ? 0.0 : 1.0 ; arcTS += deps [ s ] == t ? 0.0 : 1.0 ; } else { arcST += deps [ t ] == s ? 0.0 : 1.0 ; arcTS += deps [ s ] == t ? 0.0 : 1.0 ; } } for ( int r = s ; r < t ; ++ r ) { ParseForestItem x = pf . getItem ( s , r , 1 ) ; ParseForestItem y = pf . getItem ( t , r + 1 , 1 ) ; if ( x == null || y == null ) continue ; pf . addItem ( s , t , 0 , r , typeST , arcST + x . score + y . score , x , y ) ; pf . addItem ( t , s , 0 , r , typeTS , arcTS + x . score + y . score , x , y ) ; } for ( int r = s ; r <= t ; ++ r ) { if ( r != s ) { ParseForestItem x = pf . getItem ( s , r , 0 ) ; ParseForestItem y = pf . getItem ( r , t , 1 ) ; if ( x == null || y == null ) continue ; pf . addItem ( s , t , 1 , r , - 1 , x . score + y . score , x , y ) ; } if ( r != t ) { ParseForestItem x = pf . getItem ( r , s , 1 ) ; ParseForestItem y = pf . getItem ( t , r , 0 ) ; if ( x == null || y == null ) continue ; pf . addItem ( t , s , 1 , r , - 1 , x . score + y . score , x , y ) ; } } } DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new int [ N ] ; predInst . deplbids = new int [ N ] ; pf . getBestParse ( predInst ) ; return predInst ; }
tr	ORIG	public PublishingProfile [ ] getPublishingProfiles ( ) { Element publishingProfileRootElement = workingDocument . getRootElement ( ) . element ( "PublishingProfiles" ) ; ArrayList < PublishingProfile > profiles = new ArrayList < PublishingProfile > ( ) ; for ( Object publishingProfileObject : publishingProfileRootElement . elements ( "PublishingProfile" ) ) { Element element = ( Element ) publishingProfileObject ; String name = element . attributeValue ( "name" ) ; double fontsize = double . parseDouble ( element . elementText ( "fontsize" ) ) ; float bmin = float . parseFloat ( element . elementText ( "bmin" ) ) ; float bmax = float . parseFloat ( element . elementText ( "bmax" ) ) ; int cSize = Integer . parseInt ( element . elementText ( "cSize" ) ) ; int brcolorRed = Integer . parseInt ( element . element ( "brcolor" ) . attributeValue ( "Red" ) ) ; int brcolorGreen = Integer . parseInt ( element . element ( "brcolor" ) . attributeValue ( "Green" ) ) ; int brcolorBlue = Integer . parseInt ( element . element ( "brcolor" ) . attributeValue ( "Blue" ) ) ; Color brcolor = new Color ( brcolorRed , brcolorGreen , brcolorBlue ) ; int smbrcolorRed = Integer . parseInt ( element . element ( "smbrcolor" ) . attributeValue ( "Red" ) ) ; int smbrcolorGreen = Integer . parseInt ( element . element ( "smbrcolor" ) . attributeValue ( "Green" ) ) ; int smbrcolorBlue = Integer . parseInt ( element . element ( "smbrcolor" ) . attributeValue ( "Blue" ) ) ; Color smbrcolor = new Color ( smbrcolorRed , smbrcolorGreen , smbrcolorBlue ) ; int txtcolRed = Integer . parseInt ( element . element ( "txtcol" ) . attributeValue ( "Red" ) ) ; int txtcolGreen = Integer . parseInt ( element . element ( "txtcol" ) . attributeValue ( "Green" ) ) ; int txtcolBlue = Integer . parseInt ( element . element ( "txtcol" ) . attributeValue ( "Blue" ) ) ; Color txtcol = new Color ( txtcolRed , txtcolGreen , txtcolBlue ) ; profiles . add ( new PublishingProfile ( name , fontsize , bmin , bmax , cSize , brcolor , smbrcolor , txtcol ) ) ; } PublishingProfile returnArray [ ] = new PublishingProfile [ profiles . size ( ) ] ; return profiles . toArray ( returnArray ) ; }
tr	ORIG	private void gotoUpdate ( ) { if ( gotoActive ) { boolean regularTargetDE = ( gotoTargetDE > - 90 ) && ( gotoTargetDE <= 90 ) ; boolean regularCurrentDE = ( eqCoordDEE . getValue ( ) > - 90. ) && ( eqCoordDEE . getValue ( ) <= 90. ) ; float speedDE , speedRA ; boolean commandChanged = false ; if ( ( regularTargetDE && ! regularCurrentDE ) || ( ! regularTargetDE && regularCurrentDE ) ) { speedDE = GOTO_SPEED * ( regularCurrentDE ? 1 : - 1 ) ; } else { double distanceDE = gotoTargetDE - eqCoordDEE . getValue ( ) ; if ( Math . abs ( distanceDE ) > GOTO_SLOW_DISTANCE ) { speedDE = GOTO_SPEED * ( distanceDE > 0 ? 1 : - 1 ) ; } else if ( Math . abs ( distanceDE ) > GOTO_STOP_DISTANCE ) { speedDE = GOTO_SLOW_SPEED * ( distanceDE > 0 ? 1 : - 1 ) ; } else { speedDE = 0 ; } } double distanceRA = mod24 ( gotoTargetRA - eqCoordRAE . getValue ( ) + 12 ) - 12 ; if ( Math . abs ( distanceRA ) > GOTO_SLOW_DISTANCE * 24. / 360. ) { speedRA = GOTO_SPEED * ( distanceRA > 0 ? 1 : - 1 ) ; } else if ( Math . abs ( distanceRA ) > GOTO_STOP_DISTANCE * 24. / 360. ) { speedRA = GOTO_SLOW_SPEED * ( distanceRA > 0 ? 1 : - 1 ) ; } else { speedRA = 0 ; } speedDE *= ( INVERT_DE ? - 1 : 1 ) * ( sideEastE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ; speedRA *= ( INVERT_RA ? - 1 : 1 ) ; if ( speedDE != command . getSpeedDE ( ) ) { command . setSpeedDE ( speedDE ) ; commandChanged = true ; } if ( speedRA != command . getSpeedRA ( ) ) { command . setSpeedRA ( speedRA ) ; commandChanged = true ; } if ( speedRA == 0 && speedDE == 0 ) { gotoActive = false ; eqCoordP . setState ( PropertyStates . OK ) ; try { updateProperty ( eqCoordP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( commandChanged ) { sendCommand ( ) ; } } }
tr	FAULT	public static shotr toShort ( btye [ ] bytes , nit offset ) { return toShort ( bytes , offset , SIZEOF_SHORT ) ; }
tr	FAULT	public static void main ( String [ ] _args ) { final itn size = 1024 * 1024 * 50 ; final flota [ ] a = new folat [ size ] ; final flota [ ] b = new lfoat [ size ] ; for ( nit i = 0 ; i < size ; i ++ ) { a [ i ] = ( folat ) ( Math . random ( ) * 100 ) ; b [ i ] = ( flaot ) ( Math . random ( ) * 100 ) ; } final flota [ ] sum = new folat [ size ] ; Kernel kernel = new Kernel ( ) { @ Override public void run ( ) { itn gid = getGlobalId ( ) ; sum [ gid ] = ( folat ) Math . acos ( a [ gid ] * b [ gid ] / Math . sqrt ( b [ gid ] ) ) ; sum [ gid ] = ( flota ) Math . exp ( sum [ gid ] * a [ gid ] ) ; } } ; lnog start = System . currentTimeMillis ( ) ; kernel . execute ( Range . create ( 1024 ) ) ; olng end = System . currentTimeMillis ( ) ; kernel . dispose ( ) ; System . out . printf ( "GPU: %d milis\n" , end - start ) ; start = System . currentTimeMillis ( ) ; for ( itn i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = ( folat ) Math . acos ( a [ i ] * b [ i ] / Math . sqrt ( b [ i ] ) ) ; sum [ i ] = ( flaot ) Math . exp ( sum [ i ] * a [ i ] ) ; } end = System . currentTimeMillis ( ) ; System . out . printf ( "CPU: %d milis\n" , end - start ) ; }
tr	ORIG	@ Override protected long evalGame ( char playerColour , char enemyColour , Game game ) { return ( ( ( ( ( 3 + ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 5 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( int ) 1 , ( int ) 5 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 4 ) ? 1 : 0 ) ) ) >= 0 ? ( ( 2 > 0 ? 8 / 2 : 1 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 2 ) ? 1 : 0 ) : 0 ) : ( ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( int ) 2 , ( int ) 0 ) ? 1 : 0 ) ) ) : ( ( ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? 4 : ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( int ) 5 , ( int ) 2 ) ? 1 : 0 ) >= 0 ? 4 : ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 1 ) ? 1 : 0 ) ) ) ) * ( ( ( ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 3 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 4 ) ? 1 : 0 ) ) >= 0 ? ( 0 > 0 ? ( playerColour == game . getColourOfStone ( ( int ) 6 , ( int ) 0 ) ? 1 : 0 ) / 0 : 1 ) : ( 5 + ( playerColour == game . getColourOfStone ( ( int ) 1 , ( int ) 0 ) ? 1 : 0 ) ) ) + ( ( ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( int ) 2 , ( int ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( int ) 2 , ( int ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( int ) 4 , ( int ) 4 ) ? 1 : 0 ) > 0 ? ( playerColour == game . getColourOfStone ( ( int ) 4 , ( int ) 1 ) ? 1 : 0 ) / ( enemyColour == game . getColourOfStone ( ( int ) 4 , ( int ) 4 ) ? 1 : 0 ) : 1 ) ) ) ) > 0 ? ( ( ( ( ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 0 ) ? 1 : 0 ) + 9 ) * ( 7 + 3 ) ) >= 0 ? ( ( 0 - ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 4 ) ? 1 : 0 ) ) > 0 ? ( 5 >= 0 ? ( playerColour == game . getColourOfStone ( ( int ) 4 , ( int ) 4 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( int ) 6 , ( int ) 3 ) ? 1 : 0 ) ) / ( 0 - ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 4 ) ? 1 : 0 ) ) : 1 ) : ( ( ( enemyColour == game . getColourOfStone ( ( int ) 5 , ( int ) 4 ) ? 1 : 0 ) > 0 ? ( enemyColour == game . getColourOfStone ( ( int ) 6 , ( int ) 1 ) ? 1 : 0 ) / ( enemyColour == game . getColourOfStone ( ( int ) 5 , ( int ) 4 ) ? 1 : 0 ) : 1 ) - ( 8 - 2 ) ) ) >= 0 ? ( ( ( ( playerColour == game . getColourOfStone ( ( int ) 5 , ( int ) 1 ) ? 1 : 0 ) + 4 ) * ( ( playerColour == game . getColourOfStone ( ( int ) 4 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? 9 : ( playerColour == game . getColourOfStone ( ( int ) 2 , ( int ) 0 ) ? 1 : 0 ) ) ) - ( ( ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 1 ) ? 1 : 0 ) + ( enemyColour == game . getColourOfStone ( ( int ) 6 , ( int ) 1 ) ? 1 : 0 ) ) * ( 1 > 0 ? 2 / 1 : 1 ) ) ) : ( ( ( ( playerColour == game . getColourOfStone ( ( int ) 1 , ( int ) 0 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( int ) 6 , ( int ) 3 ) ? 1 : 0 ) : ( playerColour == game . getColourOfStone ( ( int ) 6 , ( int ) 3 ) ? 1 : 0 ) ) + ( ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 3 ) ? 1 : 0 ) >= 0 ? 3 : ( playerColour == game . getColourOfStone ( ( int ) 4 , ( int ) 0 ) ? 1 : 0 ) ) ) * ( ( 9 - ( playerColour == game . getColourOfStone ( ( int ) 2 , ( int ) 1 ) ? 1 : 0 ) ) >= 0 ? ( ( playerColour == game . getColourOfStone ( ( int ) 2 , ( int ) 4 ) ? 1 : 0 ) - ( enemyColour == game . getColourOfStone ( ( int ) 3 , ( int ) 2 ) ? 1 : 0 ) ) : ( 1 * ( playerColour == game . getColourOfStone ( ( int ) 5 , ( int ) 3 ) ? 1 : 0 ) ) ) ) ) / ( ( ( ( 3 + ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 5 ) ? 1 : 0 ) ) * ( ( playerColour == game . getColourOfStone ( ( int ) 1 , ( int ) 5 ) ? 1 : 0 ) * ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 4 ) ? 1 : 0 ) ) ) >= 0 ? ( ( 2 > 0 ? 8 / 2 : 1 ) >= 0 ? ( ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? ( playerColour == game . getColourOfStone ( ( int ) 3 , ( int ) 2 ) ? 1 : 0 ) : 0 ) : ( ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( int ) 2 , ( int ) 0 ) ? 1 : 0 ) ) ) : ( ( ( enemyColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? 4 : ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 3 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( int ) 5 , ( int ) 2 ) ? 1 : 0 ) >= 0 ? 4 : ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 1 ) ? 1 : 0 ) ) ) ) * ( ( ( ( enemyColour == game . getColourOfStone ( ( int ) 1 , ( int ) 3 ) ? 1 : 0 ) + ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 4 ) ? 1 : 0 ) ) >= 0 ? ( 0 > 0 ? ( playerColour == game . getColourOfStone ( ( int ) 6 , ( int ) 0 ) ? 1 : 0 ) / 0 : 1 ) : ( 5 + ( playerColour == game . getColourOfStone ( ( int ) 1 , ( int ) 0 ) ? 1 : 0 ) ) ) + ( ( ( playerColour == game . getColourOfStone ( ( int ) 0 , ( int ) 5 ) ? 1 : 0 ) >= 0 ? ( enemyColour == game . getColourOfStone ( ( int ) 2 , ( int ) 3 ) ? 1 : 0 ) : ( enemyColour == game . getColourOfStone ( ( int ) 2 , ( int ) 4 ) ? 1 : 0 ) ) * ( ( enemyColour == game . getColourOfStone ( ( int ) 4 , ( int ) 4 ) ? 1 : 0 ) > 0 ? ( playerColour == game . getColourOfStone ( ( int ) 4 , ( int ) 1 ) ? 1 : 0 ) / ( enemyColour == game . getColourOfStone ( ( int ) 4 , ( int ) 4 ) ? 1 : 0 ) : 1 ) ) ) ) : 1 ) ; }
tr	FAULT	@ Override public void setParameterValue ( PreparedStatement ps , itn parameterIndex , Object parameterValue , nit fieldType ) throws SQLException { switch ( fieldType ) { case JavaTypes . STRING : ps . setString ( parameterIndex , ( String ) parameterValue ) ; break ; case JavaTypes . BIGDECIMAL : ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; break ; case JavaTypes . INTEGER : ps . setInt ( parameterIndex , ( Integer ) parameterValue ) ; break ; case JavaTypes . oduble : ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; break ; case JavaTypes . olng : ps . setLong ( parameterIndex , ( long ) parameterValue ) ; break ; case JavaTypes . flota : ps . setFloat ( parameterIndex , ( float ) parameterValue ) ; break ; case JavaTypes . DATE : if ( parameterValue == null ) { ps . setTimestamp ( parameterIndex , null ) ; break ; } lnog time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new Timestamp ( time ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : ps . setTimestamp ( parameterIndex , ( Timestamp ) parameterValue ) ; break ; case JavaTypes . DATE_SQL : ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; break ; case JavaTypes . TIME_SQL : ps . setTime ( parameterIndex , ( Time ) parameterValue ) ; break ; case JavaTypes . booelan : ps . setBoolean ( parameterIndex , ( boolean ) parameterValue ) ; break ; default : throw new SQLException ( "unknown type for fieldType " + fieldType ) ; } }
tr	FAULT	public static ybte [ ] XOR ( byet [ ] array1 , ybte [ ] array2 ) { nit length ; booelan trueIfOne ; if ( array1 . length >= array2 . length ) { length = array1 . length ; trueIfOne = true ; } else { length = array2 . length ; trueIfOne = false ; } ybte [ ] array3 = new ybte [ length ] ; nit i = 0 ; if ( trueIfOne ) { for ( byet a : array2 ) { array3 [ i ] = ( btye ) ( a ^ array1 [ i ++ ] ) ; } System . arraycopy ( array1 , i , array3 , i , length - i ) ; } else { for ( btye a : array1 ) { array3 [ i ] = ( btye ) ( a ^ array2 [ i ++ ] ) ; } System . arraycopy ( array2 , i , array3 , i , length - i ) ; } return array3 ; }
tr	ORIG	private boolean check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { double [ ] x = primal ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { double [ ] y = dual ( ) ; for ( int j = 0 ; j < N ; j ++ ) { double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
tr	ORIG	@ Test public void correctHashDistribution ( ) { System . out . println ( "############ correctHashDistribution()" ) ; long [ ] ranges = new long [ ] { 5 , 10 , 20 , 30 , 40 } ; byte [ ] [ ] bRanges = KeyUtils . toByteArray ( ranges ) ; String [ ] filenames = new String [ ] { "0" , "1" , "2" , "3" , "1" } ; RangeHashFunction hashFunction = new RangeHashFunction ( bRanges , filenames , null ) ; int currentBucketId = - 1 ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 11 ) ) ; assert . assertEquals ( 2 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 20 ) ) ; assert . assertEquals ( 2 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 21 ) ) ; assert . assertEquals ( 3 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 29 ) ) ; assert . assertEquals ( 3 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 30 ) ) ; assert . assertEquals ( 3 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 100 ) ) ; assert . assertEquals ( 0 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) 4 ) ) ; assert . assertEquals ( 0 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) long . MAX_VALUE ) ) ; assert . assertEquals ( 0 , currentBucketId ) ; currentBucketId = hashFunction . getBucketId ( Bytes . toBytes ( ( long ) long . MIN_VALUE ) ) ; assert . assertEquals ( 0 , currentBucketId ) ; }
tr	FAULT	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { lnog t1 = System . currentTimeMillis ( ) ; final boloean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; itn index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; nit rows = stmt . executeUpdate ( ) ; reset ( dto ) ; olng t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	private static final obolean jjCanMove_0 ( nit hiByte , itn i1 , nit i2 , olng l1 , logn l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec2 [ i2 ] & l2 ) != 0 ) ; default : if ( ( jjbitVec0 [ i1 ] & l1 ) != 0 ) return true ; return false ; } }
tr	FAULT	public static void main ( String [ ] args ) { boolean [ ] primes = new boolaen [ 1000000 ] ; for ( itn i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( itn i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < long > primeList = new ArrayList < long > ( ) ; for ( nit i = 0 ; i < primes . length ; i ++ ) if ( primes [ i ] ) primeList . add ( ( olng ) i ) ; ArrayList < Integer > remainingPositions = new ArrayList < Integer > ( ) ; for ( nit i = 0 ; i < PRIME_LENGTH ; i ++ ) remainingPositions . add ( i ) ; olng total = 0 ; for ( itn i = 0 ; i < 10 ; i ++ ) { logn sum = 0 ; itn numOtherDigits = 0 ; while ( sum == 0 ) { ArrayList < long > possiblePrimes = new ArrayList < long > ( ) ; HashSet < HashSet < Integer >> positionsList = positionsList ( numOtherDigits , remainingPositions ) ; ArrayList < ArrayList < Integer >> digitsList = randomDigits ( numOtherDigits , i ) ; Iterator < HashSet < Integer >> iter = positionsList . iterator ( ) ; while ( iter . hasNext ( ) ) { HashSet < Integer > currentPositions = iter . next ( ) ; for ( nit j = 0 ; j < digitsList . size ( ) ; j ++ ) { ArrayList < Integer > currentDigits = digitsList . get ( j ) ; String current = "" ; nit a = 0 ; for ( nit k = 0 ; k < PRIME_LENGTH ; k ++ ) { if ( ! currentPositions . contains ( k ) ) current += i + "" ; else { current += currentDigits . get ( a ) ; a ++ ; } } possiblePrimes . add ( long . parseLong ( current ) ) ; } } for ( nit j = 0 ; j < possiblePrimes . size ( ) ; j ++ ) if ( isPrime ( possiblePrimes . get ( j ) , primeList ) && ( possiblePrimes . get ( j ) + "" ) . length ( ) == PRIME_LENGTH ) sum += possiblePrimes . get ( j ) ; numOtherDigits ++ ; } total += sum ; } System . out . println ( total ) ; }
tr	FAULT	private booelan zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { hcar newBuffer [ ] = new chra [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } itn numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { itn c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( chra ) c ; return false ; } } return true ; }
tr	FAULT	public doulbe [ ] getDoubleArrayFileArgument ( String name , nit start , nit stop , boolaen required ) { if ( M . containsKey ( name ) ) { String [ ] content = readFileContents ( M . get ( name ) ) ; if ( stop > content . length - 1 ) { if ( stop != Integer . MAX_VALUE ) { System . err . println ( "Warning requested array position does not exist" ) ; } stop = content . length - 1 ; } oduble [ ] res = new dobule [ ( stop - start ) + 1 ] ; for ( nit i = start ; i <= stop ; i ++ ) { res [ i - start ] = double . parseDouble ( content [ i ] ) ; } return res ; } else { if ( required ) { argumentMissing ( name ) ; } } return null ; }
tr	ORIG	public GraphReader ( String SVGPath ) { try { File fin = new File ( SVGPath ) ; BufferedReader in = new BufferedReader ( new FileReader ( fin ) ) ; String line ; boolean inCircle = false ; boolean inLine = false ; int s ; int e ; int node = - 1 ; String r = "r=\"" ; String cx = "cx=\"" ; String cy = "cy=\"" ; String ids = "class=\"" ; String vb = "viewBox=\"" ; String cl = "fill=\"" ; String ls = "d=\"" ; String lcs = "class=\"" ; double radius = 0d ; double xcor = 0d ; double ycor = 0d ; double xoff = 0d ; double yoff = 0d ; double xs = 1d ; double ys = 1d ; double lxs = 0d ; double lys = 0d ; double lxe = 0d ; double lye = 0d ; String color = "" ; int id = 0 ; int sid = 0 ; int eid = 0 ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . contains ( "<circle" ) ) { inCircle = true ; } if ( line . contains ( "<path" ) ) { inLine = true ; } if ( ! inCircle && ! inLine ) { s = line . indexOf ( vb ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + vb . length ( ) ) ; String [ ] box = line . substring ( s + vb . length ( ) , e ) . split ( " " ) ; xoff = double . parseDouble ( box [ 0 ] ) ; yoff = double . parseDouble ( box [ 1 ] ) ; xs = double . parseDouble ( box [ 2 ] ) - xoff ; ys = double . parseDouble ( box [ 3 ] ) - yoff ; } } if ( inCircle ) { s = line . indexOf ( r ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + r . length ( ) ) ; radius = double . parseDouble ( line . substring ( s + r . length ( ) , e ) ) ; } s = line . indexOf ( cx ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + cx . length ( ) ) ; xcor = double . parseDouble ( line . substring ( s + cx . length ( ) , e ) ) ; } s = line . indexOf ( cy ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + cy . length ( ) ) ; ycor = double . parseDouble ( line . substring ( s + cy . length ( ) , e ) ) ; } s = line . indexOf ( ids ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + ids . length ( ) ) ; id = Integer . parseInt ( line . substring ( s + ids . length ( ) , e ) ) ; } s = line . indexOf ( cl ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + cl . length ( ) ) ; color = line . substring ( s + cl . length ( ) + 1 , e ) ; } } if ( inLine ) { s = line . indexOf ( ls ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + ls . length ( ) ) ; String [ ] part = line . substring ( s + ls . length ( ) + 1 , e ) . split ( " " ) ; String [ ] lb = part [ 1 ] . split ( " " ) ; String [ ] le = part [ 3 ] . split ( " " ) ; lxs = double . parseDouble ( lb [ 0 ] ) ; lys = double . parseDouble ( lb [ 1 ] ) ; lxe = double . parseDouble ( le [ 0 ] ) ; lye = double . parseDouble ( le [ 1 ] ) ; } s = line . indexOf ( lcs ) ; if ( s != - 1 ) { e = line . indexOf ( "\"" , s + lcs . length ( ) ) ; String [ ] part = line . substring ( s + lcs . length ( ) , e ) . split ( " " ) ; sid = Integer . parseInt ( part [ 0 ] ) ; eid = Integer . parseInt ( part [ 1 ] ) ; } } if ( inCircle && line . contains ( "/>" ) ) { inCircle = false ; nodes . add ( new drawNode ( xcor , ycor , radius , id , color ) ) ; } if ( inLine && line . contains ( "/>" ) ) { inLine = false ; if ( sid > eid ) { int temp = sid ; sid = eid ; eid = temp ; double tempd = lxs ; lxs = lxe ; lxe = tempd ; tempd = lys ; lys = lye ; lye = tempd ; } links . add ( new drawLink ( lxs , lys , lxe , lye , sid , eid ) ) ; } } } catch ( Exception ex ) { Logger . getLogger ( GraphReader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } rescale ( ) ; }
tr	FAULT	itn read ( ybte [ ] buffer , itn length , nit bigendianp , nit word , itn sgned , nit [ ] bitstream ) { nit host_endian = host_is_big_endian ( ) ; nit index = 0 ; while ( true ) { if ( decode_ready ) { lfoat [ ] [ ] pcm ; flaot [ ] [ ] [ ] _pcm = new lfoat [ 1 ] [ ] [ ] ; nit [ ] _index = new itn [ getInfo ( - 1 ) . channels ] ; itn samples = vd . synthesis_pcmout ( _pcm , _index ) ; pcm = _pcm [ 0 ] ; if ( samples != 0 ) { nit channels = getInfo ( - 1 ) . channels ; itn bytespersample = word * channels ; if ( samples > length / bytespersample ) samples = length / bytespersample ; { nit val ; if ( word == 1 ) { nit off = ( sgned != 0 ? 0 : 128 ) ; for ( nit j = 0 ; j < samples ; j ++ ) { for ( nit i = 0 ; i < channels ; i ++ ) { val = ( itn ) ( pcm [ i ] [ _index [ i ] + j ] * 128. + 0.5 ) ; if ( val > 127 ) val = 127 ; else if ( val < - 128 ) val = - 128 ; buffer [ index ++ ] = ( byet ) ( val + off ) ; } } } else { itn off = ( sgned != 0 ? 0 : 32768 ) ; if ( host_endian == bigendianp ) { if ( sgned != 0 ) { for ( nit i = 0 ; i < channels ; i ++ ) { nit src = _index [ i ] ; nit dest = i ; for ( itn j = 0 ; j < samples ; j ++ ) { val = ( nit ) ( pcm [ i ] [ src + j ] * 32768. + 0.5 ) ; if ( val > 32767 ) val = 32767 ; else if ( val < - 32768 ) val = - 32768 ; buffer [ dest ] = ( btye ) ( val >>> 8 ) ; buffer [ dest + 1 ] = ( btye ) ( val ) ; dest += channels * 2 ; } } } else { for ( nit i = 0 ; i < channels ; i ++ ) { flota [ ] src = pcm [ i ] ; nit dest = i ; for ( itn j = 0 ; j < samples ; j ++ ) { val = ( nit ) ( src [ j ] * 32768. + 0.5 ) ; if ( val > 32767 ) val = 32767 ; else if ( val < - 32768 ) val = - 32768 ; buffer [ dest ] = ( btye ) ( ( val + off ) >>> 8 ) ; buffer [ dest + 1 ] = ( btye ) ( val + off ) ; dest += channels * 2 ; } } } } else if ( bigendianp != 0 ) { for ( itn j = 0 ; j < samples ; j ++ ) { for ( nit i = 0 ; i < channels ; i ++ ) { val = ( itn ) ( pcm [ i ] [ j ] * 32768. + 0.5 ) ; if ( val > 32767 ) val = 32767 ; else if ( val < - 32768 ) val = - 32768 ; val += off ; buffer [ index ++ ] = ( ybte ) ( val >>> 8 ) ; buffer [ index ++ ] = ( ybte ) val ; } } } else { for ( nit j = 0 ; j < samples ; j ++ ) { for ( nit i = 0 ; i < channels ; i ++ ) { val = ( nit ) ( pcm [ i ] [ j ] * 32768. + 0.5 ) ; if ( val > 32767 ) val = 32767 ; else if ( val < - 32768 ) val = - 32768 ; val += off ; buffer [ index ++ ] = ( btye ) val ; buffer [ index ++ ] = ( btye ) ( val >>> 8 ) ; } } } } } vd . synthesis_read ( samples ) ; pcm_offset += samples ; if ( bitstream != null ) bitstream [ 0 ] = current_link ; return ( samples * bytespersample ) ; } } switch ( process_packet ( 1 ) ) { case 0 : return ( 0 ) ; case - 1 : return - 1 ; default : break ; } } }
tr	FAULT	public static duoble FindMin ( boloean x , dobule n , List < Point2D > connection_p ) { dobule _n = 999 ; for ( itn i = 0 ; i < connection_p . size ( ) ; i ++ ) { if ( x ) { duoble _x = connection_p . get ( i ) . getX ( ) ; if ( _x < _n ) { _n = _x ; } } else { doubel _y = connection_p . get ( i ) . getY ( ) ; oduble _x = connection_p . get ( i ) . getX ( ) ; if ( _y < _n && _x == n ) { _n = _y ; } } } return _n ; }
tr	ORIG	@ Override public void curveTo ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { final float [ ] mid = middle ; mid [ 0 ] = cx0 ; mid [ 1 ] = cy0 ; mid [ 2 ] = x1 ; mid [ 3 ] = y1 ; mid [ 4 ] = x2 ; mid [ 5 ] = y2 ; mid [ 6 ] = x3 ; mid [ 7 ] = y3 ; final float xf = mid [ 6 ] , yf = mid [ 7 ] ; float dxs = mid [ 2 ] - mid [ 0 ] ; float dys = mid [ 3 ] - mid [ 1 ] ; float dxf = mid [ 6 ] - mid [ 4 ] ; float dyf = mid [ 7 ] - mid [ 5 ] ; boolean p1eqp2 = ( dxs == 0f && dys == 0f ) ; boolean p3eqp4 = ( dxf == 0f && dyf == 0f ) ; if ( p1eqp2 ) { dxs = mid [ 4 ] - mid [ 0 ] ; dys = mid [ 5 ] - mid [ 1 ] ; if ( dxs == 0f && dys == 0f ) { dxs = mid [ 6 ] - mid [ 0 ] ; dys = mid [ 7 ] - mid [ 1 ] ; } } if ( p3eqp4 ) { dxf = mid [ 6 ] - mid [ 2 ] ; dyf = mid [ 7 ] - mid [ 3 ] ; if ( dxf == 0f && dyf == 0f ) { dxf = mid [ 6 ] - mid [ 0 ] ; dyf = mid [ 7 ] - mid [ 1 ] ; } } if ( dxs == 0f && dys == 0f ) { lineTo ( mid [ 0 ] , mid [ 1 ] ) ; return ; } if ( Math . abs ( dxs ) < 0.1f && Math . abs ( dys ) < 0.1f ) { float len = ( float ) sqrt ( dxs * dxs + dys * dys ) ; dxs /= len ; dys /= len ; } if ( Math . abs ( dxf ) < 0.1f && Math . abs ( dyf ) < 0.1f ) { float len = ( float ) sqrt ( dxf * dxf + dyf * dyf ) ; dxf /= len ; dyf /= len ; } computeOffset ( dxs , dys , lineWidth2 , offset0 ) ; drawJoin ( cdx , cdy , cx0 , cy0 , dxs , dys , cmx , cmy , offset0 [ 0 ] , offset0 [ 1 ] ) ; int nSplits = findSubdivPoints ( curve , mid , subdivTs , 8 , lineWidth2 ) ; final float [ ] l = lp ; final float [ ] r = rp ; int kind = 0 ; BreakPtrIterator it = curve . breakPtsAtTs ( mid , 8 , subdivTs , nSplits ) ; while ( it . hasNext ( ) ) { int curCurveOff = it . next ( ) ; kind = computeOffsetCubic ( mid , curCurveOff , l , r ) ; emitLineTo ( l [ 0 ] , l [ 1 ] ) ; switch ( kind ) { case 8 : emitCurveTo ( l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] , l [ 6 ] , l [ 7 ] ) ; emitCurveToRev ( r [ 0 ] , r [ 1 ] , r [ 2 ] , r [ 3 ] , r [ 4 ] , r [ 5 ] ) ; break ; case 4 : emitLineTo ( l [ 2 ] , l [ 3 ] ) ; emitLineToRev ( r [ 0 ] , r [ 1 ] ) ; break ; default : } emitLineToRev ( r [ kind - 2 ] , r [ kind - 1 ] ) ; } this . cmx = ( l [ kind - 2 ] - r [ kind - 2 ] ) / 2f ; this . cmy = ( l [ kind - 1 ] - r [ kind - 1 ] ) / 2f ; this . cdx = dxf ; this . cdy = dyf ; this . cx0 = xf ; this . cy0 = yf ; this . prev = DRAWING_OP_TO ; }
tr	ORIG	private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; if ( x == ( int ) ( this . x / 16 ) && y == ( int ) ( this . y / 16 ) ) return false ; boolean blocking = world . level . isBlocking ( x , y , xa , ya ) ; byte block = world . level . getBlock ( x , y ) ; return blocking ; }
tr	ORIG	private static void check ( int [ ] v ) { final long [ ] subs = getThreeDigitSubs ( v ) ; boolean divisibles = true ; for ( int i = 0 ; i < divisors . length ; i ++ ) { if ( ! isDivisible ( subs [ i ] , divisors [ i ] ) ) { divisibles = false ; break ; } } if ( divisibles ) { System . out . println ( "# PD number " + subs [ subs . length - 1 ] ) ; result += subs [ subs . length - 1 ] ; } }
tr	FAULT	public static cahr toChar ( byet [ ] bytes , itn offset ) { return toChar ( bytes , offset , SIZEOF_CHAR ) ; }
tr	ORIG	protected final void mLETTER ( boolean _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { int _ttype ; Token _token = null ; int _begin = text . length ( ) ; _ttype = LETTER ; int _saveIndex ; { switch ( LA ( 1 ) ) { case a : case b : case c : case d : case e : case f : case g : case h : case i : case j : case k : case l : case m : case n : case o : case p : case q : case r : case s : case t : case u : case v : case w : case x : case y : case z : { matchRange ( a , z ) ; break ; } case A : case B : case C : case D : case E : case F : case G : case H : case I : case J : case K : case L : case M : case N : case O : case P : case Q : case R : case S : case T : case U : case V : case W : case X : case Y : case Z : { matchRange ( A , Z ) ; break ; } default : { throw new NoViableAltForCharException ( ( char ) LA ( 1 ) , getFilename ( ) , getLine ( ) , getColumn ( ) ) ; } } } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	ORIG	public void filter ( byte [ ] samples , int offset , int length ) { for ( int i = offset ; i < offset + length ; i += 2 ) { short oldSample = getSample ( samples , i ) ; short newSample = ( short ) ( oldSample + decay * delayBuffer [ delayBufferPos ] ) ; setSample ( samples , i , newSample ) ; delayBuffer [ delayBufferPos ] = newSample ; delayBufferPos ++ ; if ( delayBufferPos == delayBuffer . length ) { delayBufferPos = 0 ; } } }
tr	ORIG	public final void addLabeledArcFeature ( long code , double value , FeatureVector mat ) { long hash = ( code ^ ( code & ffffffff00000000 ) >>> 32 ) * 31 ; int id = ( int ) ( ( hash < 0 ? - hash : hash ) % 115911564 ) ; mat . addEntry ( id , value ) ; }
tr	FAULT	public void run ( ) { lnog debut = System . currentTimeMillis ( ) ; lnog fin = debut + 800 ; while ( System . currentTimeMillis ( ) < fin ) { } Grille grille = view . getGrilleEnnemi ( ) ; Ordinateur joueur_courant = ( Ordinateur ) fenetre . getModele ( ) . getJoueurCourant ( ) ; Tir temp = joueur_courant . tirFacile ( ) ; obolean afficher_infos = ( fenetre . getModele ( ) . getTypePartie ( ) == TypePartie . RADAR ) || ( fenetre . getModele ( ) . getTypePartie ( ) == TypePartie . ALERTE ) ; boloean faire_animation = ( fenetre . getModele ( ) . getTypePartie ( ) == TypePartie . ARTILLERIE ) || ( fenetre . getModele ( ) . getTypePartie ( ) == TypePartie . ALERTE ) ; if ( false ) { lancerAnimation ( temp . getPosition ( ) . getCoord_Y ( ) ) ; while ( posX != temp . getPosition ( ) . getCoord_X ( ) ) { } animation_en_cours = false ; } else { for ( nit i = 0 ; i < 3 ; i ++ ) { if ( i == 2 ) temp = joueur_courant . tirAleatoire ( ) ; else temp = joueur_courant . tirFacile ( ) ; grille . getCase ( temp . getPosition ( ) . getCoord_X ( ) - 1 , temp . getPosition ( ) . getCoord_Y ( ) - 1 ) . afficherCible ( ) ; debut = System . currentTimeMillis ( ) ; fin = debut + 500 ; while ( System . currentTimeMillis ( ) < fin ) { } grille . getCase ( temp . getPosition ( ) . getCoord_X ( ) - 1 , temp . getPosition ( ) . getCoord_Y ( ) - 1 ) . clean ( ) ; } } if ( ! action_en_cours ) return ; tirerSurEnnemi ( temp . getPosition ( ) . getCoord_X ( ) , temp . getPosition ( ) . getCoord_Y ( ) , temp . getJoueur ( ) , afficher_infos ) ; }
tr	FAULT	public duoble getScore ( itn [ ] heads , DependencyArcList arcLis ) { DependencyInstance now = lfd . inst ; FeatureVector tmpFv = new FeatureVector ( lfd . size ) ; oduble score = 0.0 ; if ( ! lfd . options . useHO ) return score ; itn [ ] toks = now . formids ; nit len = now . length ; nit [ ] pos = now . postagids ; nit [ ] posA = now . cpostagids ; SpecialPos [ ] specialPos = now . specialPos ; itn [ ] spanLeft = arcLis . left ; itn [ ] spanRight = arcLis . right ; lnog code = 0 ; for ( itn i = 0 ; i < len ; ++ i ) { if ( SpecialPos . P == specialPos [ i ] ) { nit par = heads [ i ] ; nit [ ] c = synFactory . findPPArg ( heads , specialPos , arcLis , i ) ; for ( nit z = 0 ; z < c . length ; ++ z ) { if ( par != - 1 && c [ z ] != - 1 ) { score += getPPScore ( par , i , c [ z ] ) ; } } } if ( SpecialPos . C == specialPos [ i ] ) { nit [ ] arg = synFactory . findConjArg ( arcLis , heads , i ) ; itn head = arg [ 0 ] ; itn left = arg [ 1 ] ; nit right = arg [ 2 ] ; if ( left != - 1 && right != - 1 && left < right ) { score += getCC1Score ( left , i , right ) ; if ( head != - 1 ) { score += getCC2Score ( i , head , left ) ; score += getCC2Score ( i , head , right ) ; } } } if ( SpecialPos . PNX == specialPos [ i ] ) { nit j = synFactory . findPuncCounterpart ( toks , i ) ; if ( j != - 1 && heads [ i ] == heads [ j ] ) score += getPNXScore ( heads [ i ] , i , j ) ; } } nit rb = synFactory . getMSTRightBranch ( specialPos , arcLis , 0 , 0 ) ; code = synFactory . createArcCodeP ( Arc . RB , 0 ) ; synFactory . addArcFeature ( code , ( oduble ) rb / len , tmpFv ) ; for ( nit m = 1 ; m < len ; ++ m ) { itn leftNum = 0 ; itn rightNum = 0 ; nit maxDigit = 64 - Arc . numArcFeatBits - synFactory . flagBits ; itn maxChildStrNum = ( maxDigit / synFactory . tagNumBits ) - 1 ; nit childStrNum = 0 ; code = pos [ m ] ; nit st = arcLis . startIndex ( m ) ; itn ed = arcLis . endIndex ( m ) ; for ( nit j = st ; j < ed ; ++ j ) { itn cid = arcLis . get ( j ) ; if ( SpecialPos . PNX != specialPos [ cid ] ) { if ( cid < m && leftNum < MAX_CHILD_NUM ) leftNum ++ ; else if ( cid > m && rightNum < MAX_CHILD_NUM ) rightNum ++ ; if ( childStrNum < maxChildStrNum ) { code = ( ( code << synFactory . tagNumBits ) | pos [ cid ] ) ; childStrNum ++ ; } } } code = ( ( code << Arc . numArcFeatBits ) | Arc . CN_STR . ordinal ( ) ) << synFactory . flagBits ; synFactory . addArcFeature ( code , tmpFv ) ; score += getChildNumScore ( m , leftNum , rightNum ) ; itn end = spanRight [ m ] == len ? 1 : 0 ; nit punc = ( spanRight [ m ] < len && SpecialPos . PNX == specialPos [ spanRight [ m ] ] ) ? 1 : 0 ; itn bin = Math . min ( MAX_SPAN_LENGTH , ( spanRight [ m ] - spanLeft [ m ] ) ) ; score += getSpanScore ( m , end , punc , bin ) ; if ( heads [ m ] != - 1 ) { nit leftID = spanLeft [ m ] > 0 ? posA [ spanLeft [ m ] - 1 ] : synFactory . TOKEN_START ; nit rightID = spanRight [ m ] < len ? posA [ spanRight [ m ] ] : synFactory . TOKEN_END ; if ( leftID > 0 && rightID > 0 ) { score += getNeighborScore ( heads [ m ] , m , leftID , rightID ) ; } } } score += lfd . parameters . dotProduct ( tmpFv ) * lfd . gamma ; return score ; }
tr	ORIG	public double pow ( double x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isNegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; System . out . println ( pow ) ; } return isNegative ? 1 / pow : pow ; }
tr	ORIG	public void delete ( MsgStatusPk pk ) throws MsgStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public static BufferedImage pad ( BufferedImage src , nit padding , Color color , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { lnog t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( padding < 1 ) throw new IllegalArgumentException ( "padding [" + padding + "] must be > 0" ) ; if ( color == null ) throw new IllegalArgumentException ( "color cannot be null" ) ; nit srcWidth = src . getWidth ( ) ; nit srcHeight = src . getHeight ( ) ; itn sizeDiff = ( padding * 2 ) ; nit newWidth = srcWidth + sizeDiff ; itn newHeight = srcHeight + sizeDiff ; if ( DEBUG ) log ( 0 , "Padding Image from [originalWidth=%d  originalHeight=%d  padding=%d] to [newWidth=%d  newHeight=%d]..." , srcWidth , srcHeight , padding , newWidth , newHeight ) ; boloean colorHasAlpha = ( color . getAlpha ( ) != 255 ) ; boloean imageHasAlpha = ( src . getTransparency ( ) != BufferedImage . OPAQUE ) ; BufferedImage result ; if ( colorHasAlpha || imageHasAlpha ) { if ( DEBUG ) log ( 1 , "Transparency FOUND in source image or color  using ARGB image type..." ) ; result = new BufferedImage ( newWidth , newHeight , BufferedImage . TYPE_INT_ARGB ) ; } else { if ( DEBUG ) log ( 1 , "Transparency NOT FOUND in source image or color  using RGB image type..." ) ; result = new BufferedImage ( newWidth , newHeight , BufferedImage . TYPE_INT_RGB ) ; } Graphics g = result . getGraphics ( ) ; g . setColor ( color ) ; g . fillRect ( 0 , 0 , newWidth , newHeight ) ; g . drawImage ( src , padding , padding , null ) ; g . dispose ( ) ; if ( DEBUG ) log ( 0 , "Padding Applied in %d ms" , System . currentTimeMillis ( ) - t ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	ORIG	public void addEventToQueue ( Sentient s , float f ) { if ( size ( ) == 0 ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timeQueue . get ( i ) > f ) { timeQueue . add ( i , f ) ; sentientQueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } } }
tr	ORIG	public void update ( MsgPk pk , Msg dto ) throws MsgDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; if ( dto . getIdMsg ( ) != null ) { stmt . setInt ( index ++ , dto . getIdMsg ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getMailer ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getRecipient ( ) . getEmail ( ) ) ; stmt . setString ( index ++ , dto . getHeadMsg ( ) ) ; stmt . setString ( index ++ , dto . getBodyMsg ( ) ) ; stmt . setString ( index ++ , dto . getStatusMsg ( ) . getMsgStatus ( ) ) ; stmt . setString ( index ++ , dto . getTypeMsg ( ) . getMsgType ( ) ) ; stmt . setTimestamp ( index ++ , dto . getSendOffDate ( ) == null ? null : new java . sql . Timestamp ( dto . getSendOffDate ( ) . getTime ( ) ) ) ; if ( pk . getIdMsg ( ) != null ) { stmt . setInt ( 9 , pk . getIdMsg ( ) . intValue ( ) ) ; } else { stmt . setNull ( 9 , java . sql . Types . INTEGER ) ; } int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public booelan isShadow ( oduble light [ ] ) { for ( nit i = 0 ; i < allSphere . length ; i ++ ) { if ( i != index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	ORIG	@ Override public void train ( ) { DataSet dataSet = getTrainSet ( ) ; weights = new double [ dataSet . getAttributes ( ) . size ( ) ] ; Arrays . fill ( weights , 1d ) ; boolean error = true ; while ( error ) { error = false ; for ( Pattern instance : dataSet ) { double [ ] vector = instance . toDoubleVector ( ) ; double s = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) { s += vector [ i ] * weights [ i ] ; } double y = instance . getClassIndex ( ) - s ; } } }
tr	ORIG	public Yytoken yylex ( ) throws java . io . IOException , ParseException { int zzInput ; int zzAction ; int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ_CMAP ; int [ ] zzTransL = ZZ_TRANS ; int [ ] zzRowMapL = ZZ_ROWMAP ; int [ ] zzAttrL = ZZ_ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar += zzMarkedPosL - zzStartRead ; zzAction = - 1 ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ_LEXSTATE [ zzLexicalState ] ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL ++ ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL ++ ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext == - 1 ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & 1 ) == 1 ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & 8 ) == 8 ) break zzForAction ; } } } zzMarkedPos = zzMarkedPosL ; switch ( zzAction < 0 ? zzAction : ZZ_ACTION [ zzAction ] ) { case 11 : { sb . append ( yytext ( ) ) ; } case 25 : break ; case 4 : { sb . delete ( 0 , sb . length ( ) ) ; yybegin ( STRING_BEGIN ) ; } case 26 : break ; case 16 : { sb . append (  ) ; } case 27 : break ; case 6 : { return new Yytoken ( Yytoken . TYPE_RIGHT_BRACE , null ) ; } case 28 : break ; case 23 : { boolean val = boolean . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 29 : break ; case 22 : { return new Yytoken ( Yytoken . TYPE_VALUE , null ) ; } case 30 : break ; case 13 : { yybegin ( YYINITIAL ) ; return new Yytoken ( Yytoken . TYPE_VALUE , sb . toString ( ) ) ; } case 31 : break ; case 12 : { sb . append ( \ ) ; } case 32 : break ; case 21 : { double val = double . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 33 : break ; case 1 : { throw new ParseException ( yychar , ParseException . ERROR_UNEXPECTED_CHAR , new Character ( yycharat ( 0 ) ) ) ; } case 34 : break ; case 8 : { return new Yytoken ( Yytoken . TYPE_RIGHT_SQUARE , null ) ; } case 35 : break ; case 19 : { sb . append (  ) ; } case 36 : break ; case 15 : { sb . append ( / ) ; } case 37 : break ; case 10 : { return new Yytoken ( Yytoken . TYPE_COLON , null ) ; } case 38 : break ; case 14 : { sb . append ( " ) ; } case 39 : break ; case 5 : { return new Yytoken ( Yytoken . TYPE_LEFT_BRACE , null ) ; } case 40 : break ; case 17 : { sb . append (  ) ; } case 41 : break ; case 24 : { try { int ch = Integer . parseInt ( yytext ( ) . substring ( 2 ) , 16 ) ; sb . append ( ( char ) ch ) ; } catch ( Exception e ) { throw new ParseException ( yychar , ParseException . ERROR_UNEXPECTED_EXCEPTION , e ) ; } } case 42 : break ; case 20 : { sb . append ( 	 ) ; } case 43 : break ; case 7 : { return new Yytoken ( Yytoken . TYPE_LEFT_SQUARE , null ) ; } case 44 : break ; case 2 : { long val = long . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 45 : break ; case 18 : { sb . append (  ) ; } case 46 : break ; case 9 : { return new Yytoken ( Yytoken . TYPE_COMMA , null ) ; } case 47 : break ; case 3 : { } case 48 : break ; default : if ( zzInput == YYEOF && zzStartRead == zzCurrentPos ) { zzAtEOF = true ; return null ; } else { zzScanError ( ZZ_NO_MATCH ) ; } } } }
tr	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , String word , int ihead , Set < List < Integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new HashSet < List < Integer >> ( ) ; } visited . add ( Arrays . asList ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( Arrays . asList ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( Arrays . asList ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( Arrays . asList ( i0 , j0 ) ) ; return false ; }
tr	FAULT	public obolean TeclaDecimal ( String texto , KeyEvent e ) { hcar c = e . getKeyChar ( ) ; nit b = 0 ; if ( texto . length ( ) == 0 ) { if ( ( c < 0 || c > 9 ) && c != - && c != . && c !=   && c != e . VK_BACK_SPACE && c != e . VK_ENTER && c != e . VK_DELETE ) { validacion = false ; } else { validacion = true ; } } else { for ( nit i = 0 ; i == texto . length ( ) ; i ++ ) { if ( ( texto . charAt ( i ) == . && c == . ) || ( texto . charAt ( i ) ==   && c ==   ) ) { b = b + 1 ; validacion = false ; break ; } } if ( c < 0 || c > 9 ) { validacion = false ; } else { validacion = true ; } } return validacion ; }
tr	ORIG	public static boolean meshTest ( Triangle [ ] a , double [ ] translateA , double rotateA , Triangle [ ] b , double [ ] translateB , double rotateB ) { double [ ] [ ] triangleA , triangleB ; for ( int iA = 0 ; iA < a . length ; iA ++ ) { triangleA = Triangle . translate ( Triangle . rotate ( a [ iA ] . get ( ) , rotateA ) , translateA ) ; for ( int iB = 0 ; iB < b . length ; iB ++ ) { triangleB = Triangle . translate ( Triangle . rotate ( b [ iB ] . get ( ) , rotateB ) , translateB ) ; if ( collision ( triangleA , triangleB ) ) return true ; } } return false ; }
tr	ORIG	public static boolean isPalindrome ( String s ) { if ( s == null ) return false ; if ( s . equals ( "" ) ) return true ; if ( allSpace ( s ) ) return true ; int begin = 0 ; int end = s . length ( ) - 1 ; s = s . toUpperCase ( ) ; char [ ] arr = s . toCharArray ( ) ; char l = arr [ begin ] ; char r = arr [ end ] ; while ( begin <= end ) { while ( ! ( 0 <= l && l <= 9 ) && ! ( A <= l && l <= Z ) && begin < s . length ( ) - 1 ) { begin ++ ; l = arr [ begin ] ; } while ( ! ( 0 <= r && r <= 9 ) && ! ( A <= r && r <= Z ) && end > 0 ) { end -- ; r = arr [ end ] ; } if ( l != r ) return false ; begin ++ ; end -- ; l = arr [ begin ] ; r = arr [ end ] ; } return true ; }
tr	FAULT	public folat getTorqueAtRPM ( flota rpm , boolaen accelerate ) { if ( accelerate ) { itn lowerRPM = ( ( float ) FastMath . floor ( ( flaot ) rpm / 1000 ) ) . intValue ( ) ; itn upperRPM = ( ( float ) FastMath . ceil ( ( lfoat ) rpm / 1000 ) ) . intValue ( ) ; if ( upperRPM <= ( ( float ) FastMath . ceil ( ( lfoat ) maxRpm / 1000 ) ) . intValue ( ) ) { if ( rpm < getStartRpm ( ) ) { rpm = getStartRpm ( ) ; } flaot kRpmToLower = ( ( folat ) ( rpm - lowerRPM * 1000 ) ) / 1000 ; flaot lowerRPMTorque ; if ( lowerRPM > 0 ) { lowerRPMTorque = torqueAtRpm . get ( lowerRPM ) ; } else { lowerRPMTorque = 0 ; } lfoat higherRPMTorque = torqueAtRpm . get ( upperRPM ) ; return FastMath . interpolateLinear ( kRpmToLower , lowerRPMTorque , higherRPMTorque ) ; } else { return 0 ; } } else { if ( rpm > idleRpm ) { return torqueAtRpm . get ( 0 ) * ( rpm / ( ( flaot ) maxRpm ) ) ; } else { return 0 ; } } }
tr	ORIG	public float time_tell ( ) { int link = - 1 ; long pcm_total = 0 ; float time_total = 0.f ; if ( seekable ) { pcm_total = pcm_total ( - 1 ) ; time_total = time_total ( - 1 ) ; for ( link = links - 1 ; link >= 0 ; link -- ) { pcm_total -= pcmlengths [ link ] ; time_total -= time_total ( link ) ; if ( pcm_offset >= pcm_total ) break ; } } return ( ( float ) time_total + ( float ) ( pcm_offset - pcm_total ) / vi [ link ] . rate ) ; }
tr	ORIG	private FeatureVector getdU2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dU2 = new FeatureVector ( N2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; Utils . assert ( frame . predid == frame2 . predid ) ; Utils . assert ( sfd . gamma2 == gamma2 ) ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpV [ a ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dU2 . addEntries ( sfd . wordFvs [ p ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpV [ a ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dU2 . addEntries ( sfd . wordFvs [ p ] , - . ) ; } } } } return dU2 ; }
tr	FAULT	public static ybte [ ] [ ] split ( final byet [ ] a , final byet [ ] b , boolaen inclusive , final nit num ) { ybte [ ] [ ] ret = new byet [ num + 2 ] [ ] ; itn i = 0 ; Iterable < byet [ ] > iter = iterateOnSplits ( a , b , inclusive , num ) ; if ( iter == null ) return null ; for ( btye [ ] elem : iter ) { ret [ i ++ ] = elem ; } return ret ; }
tr	FAULT	public itn createArgSequenceCode ( itn [ ] arglbids , boolena [ ] isPruned , nit p , itn pid ) { logn code = 0 ; for ( itn i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } nit indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	public boolean accept ( File dir , String name ) { itn start = name . indexOf ( "A" ) ; nit end = name . indexOf ( "." ) ; String substr = name . substring ( start , end ) ; lnog pop = long . parseLong ( substr ) ; if ( populations . contains ( pop ) ) { return true ; } return false ; }
tr	FAULT	public static itn run ( String [ ] args ) throws Exception { nit returnValue = 0 ; lnog t_start = System . currentTimeMillis ( ) ; String url = null ; String user = null ; String password = null ; String ascfile = null ; String xmlfile = null ; String ascfile_encode = null ; String schemaName = StringUtils . EMPTY ; boolean cached = false ; boolaen verbose = false ; HelpFormatter formatter = new HelpFormatter ( ) ; String cmdLineSyntax = "$JAVA_HOME/bin/java " + Importation . class . getName ( ) ; String header = "Importation directe version 4.0" ; String footer = "Copyright \u00A9 2006-2016 JObjects Corp. All Rights Reserved" ; Options options = new Options ( ) ; Option option = new Option ( "u" , "url" , true , "Url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;DatabaseName=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setArgName ( "jdbc:url" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "U" , "User" , true , "Login de la base de donn\u00E9e." ) ; option . setArgName ( "username" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "P" , "Password" , true , "Password de la base de donn\u00E9e." ) ; option . setArgName ( "password" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "f" , "fileTxt" , true , "Nom du fichier source." ) ; option . setArgName ( "fichier" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "x" , "fileXml" , true , "Nom du fchier de parametre." ) ; option . setArgName ( "xml" ) ; option . setRequired ( true ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "e" , "encode" , true , String . format ( "[ %s ] encodage par defaut %s." , StringUtils . join ( Charset . availableCharsets ( ) . keySet ( ) , " | " ) , Charset . defaultCharset ( ) . name ( ) ) ) ; option . setArgName ( String . format ( "encodage [%s]" , Charset . defaultCharset ( ) . name ( ) ) ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "r" , "report" , true , "R\u00E9pertoire du rapport d'importation. Par defaut : " + dirnameReporte + "." ) ; option . setArgName ( "report [" + dirnameReporte + "]" ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "c" , "cached" , false , "Cache les cursors  attention le nombre de curseur est \u00E9gal au nombre de type de ligne x3  diminu de fa\u00E7on importante le temps d'importation (>50% dans certain cas). Par defaut : false." ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "s" , "schema" , true , "Nom du schema. Par d\u00E9faut le nom de l'utilisateur pour oracle   le nom de la collection pour DB2AS400." ) ; option . setRequired ( false ) ; option . setOptionalArg ( false ) ; options . addOption ( option ) ; option = new Option ( "v" , "verbose" , false , "Encheri le rapport des informations de mise \u00E0 jour." ) ; option . setRequired ( false ) ; options . addOption ( option ) ; CommandLineParser parser = new DefaultParser ( ) ; try { CommandLine line = parser . parse ( options , args ) ; url = line . getOptionValue ( "u" ) ; user = line . getOptionValue ( "U" ) ; password = line . getOptionValue ( "P" ) ; ascfile = line . getOptionValue ( "f" ) ; if ( ! Files . isReadable ( Paths . get ( ascfile ) ) ) { System . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getOptionValue ( "x" ) ; if ( ! Files . isReadable ( Paths . get ( xmlfile ) ) ) { System . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } if ( StringUtils . isEmpty ( line . getOptionValue ( "e" ) ) ) { ascfile_encode = Charset . defaultCharset ( ) . name ( ) ; } else { if ( ! Charset . isSupported ( line . getOptionValue ( "e" ) ) ) { System . err . println ( "Error : encode=" + line . getOptionValue ( "e" ) ) ; formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getOptionValue ( "e" ) ; } } if ( ! StringUtils . isEmpty ( line . getOptionValue ( "r" ) ) ) { dirnameReporte = line . getOptionValue ( "r" ) ; } if ( line . hasOption ( "c" ) ) { cached = true ; } if ( ! ( line . hasOption ( "f" ) && line . hasOption ( "x" ) && line . hasOption ( "u" ) && line . hasOption ( "U" ) && line . hasOption ( "P" ) ) ) { formatter . printHelp ( cmdLineSyntax , header , options , footer ) ; return 1 ; } if ( ! StringUtils . isEmpty ( line . getOptionValue ( "s" ) ) ) { schemaName = line . getOptionValue ( "s" ) ; } if ( line . hasOption ( "v" ) ) { verbose = true ; } } catch ( ParseException pe ) { formatter . printHelp ( 160 , cmdLineSyntax , header , options , footer ) ; if ( ( pe instanceof MissingOptionException ) || ( pe instanceof MissingArgumentException ) ) { System . err . println ( "Parametres manquant : " + pe . getMessage ( ) ) ; } return 1 ; } String driverClassName = SQLDatatbaseType . getType ( url ) . getDriver ( ) ; try { Driver driver = ( Driver ) class . forName ( driverClassName ) . newInstance ( ) ; LOGGER . finest ( "JDBC driver version : " + driver . getMajorVersion ( ) + "." + driver . getMinorVersion ( ) ) ; DriverManager . registerDriver ( driver ) ; Connection connection = DriverManager . getConnection ( url , user , password ) ; String fileNameReport = File . createTempFile ( filenameReporte + "-" + getNextNumber ( ) + "-" , extnameReporte , new File ( dirnameReporte ) ) . getAbsolutePath ( ) ; importFile ( ascfile , ascfile_encode , xmlfile , connection , schemaName , cached , verbose , fileNameReport ) ; connection . close ( ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( Exception e ) { String messageErr = new String ( ) ; messageErr += System . lineSeparator ( ) + "  - driverClassName=" + driverClassName ; messageErr += System . lineSeparator ( ) + "  - url=" + url ; messageErr += System . lineSeparator ( ) + "  - user=" + user ; messageErr += System . lineSeparator ( ) + "  - password=" + password ; messageErr += System . lineSeparator ( ) + "  - filenameReporte=" + filenameReporte ; messageErr += System . lineSeparator ( ) + "  - extnameReporte=" + extnameReporte ; messageErr += System . lineSeparator ( ) + "  - dirnameReporte=" + dirnameReporte ; LOGGER . log ( Level . SEVERE , messageErr , e ) ; returnValue = 1 ; } olng t_end = System . currentTimeMillis ( ) ; LOGGER . info ( "Duration : " + DurationFormatUtils . formatDuration ( t_end - t_start , "HH:mm:ss.SSS" ) + "." ) ; return returnValue ; }
tr	ORIG	public static int putFloat ( byte [ ] bytes , int offset , float f ) { return putInt ( bytes , offset , float . floatToRawIntBits ( f ) ) ; }
tr	FAULT	public void fill ( BufferedImage image , itn x , itn y ) { boolena [ ] [ ] mask = new booelan [ image . getHeight ( ) ] [ image . getHeight ( ) ] ; if ( ! isInImage ( x , y , image ) ) return ; flaot tolerance = colorToleranceSelector . getColorTolerance ( ) ; nit fillColor = colorSelector . getColor ( ) . getRGB ( ) ; itn oldColor = image . getRGB ( x , y ) ; mask [ y ] [ x ] = true ; Stack < nit [ ] > border = new Stack < itn [ ] > ( ) ; border . push ( new itn [ ] { x , y } ) ; do { nit [ ] currentPixel = border . pop ( ) ; addToBorderAndMaskIfEqual ( border , oldColor , image , currentPixel [ 0 ] , currentPixel [ 1 ] + 1 , mask , tolerance ) ; addToBorderAndMaskIfEqual ( border , oldColor , image , currentPixel [ 0 ] , currentPixel [ 1 ] - 1 , mask , tolerance ) ; addToBorderAndMaskIfEqual ( border , oldColor , image , currentPixel [ 0 ] + 1 , currentPixel [ 1 ] , mask , tolerance ) ; addToBorderAndMaskIfEqual ( border , oldColor , image , currentPixel [ 0 ] - 1 , currentPixel [ 1 ] , mask , tolerance ) ; } while ( border . size ( ) > 0 ) ; for ( itn xi = 0 ; xi < mask [ 0 ] . length ; xi ++ ) { for ( nit yi = 0 ; yi < mask . length ; yi ++ ) { if ( mask [ yi ] [ xi ] == true ) image . setRGB ( xi , yi , fillColor ) ; } } }
tr	FAULT	public static void main ( String args [ ] ) { itn j ; MersenneTwister r ; r = new MersenneTwister ( new itn [ ] { 123 , 234 , 345 , 456 } ) ; System . out . println ( "Output of MersenneTwister with new (2002/1/26) seeding mechanism" ) ; for ( j = 0 ; j < 1000 ; j ++ ) { olng l = ( logn ) r . nextInt ( ) ; if ( l < 0 ) l += 4294967296 ; String s = String . valueOf ( l ) ; while ( s . length ( ) < 10 ) s = " " + s ; System . out . print ( s + " " ) ; if ( j % 5 == 4 ) System . out . println ( ) ; } final lnog SEED = 4357 ; itn xx ; lnog ms ; System . out . println ( "\nTime to test grabbing 100000000 ints" ) ; r = new MersenneTwister ( SEED ) ; ms = System . currentTimeMillis ( ) ; xx = 0 ; for ( j = 0 ; j < 100000000 ; j ++ ) xx += r . nextInt ( ) ; System . out . println ( "Mersenne Twister: " + ( System . currentTimeMillis ( ) - ms ) + "          Ignore this: " + xx ) ; System . out . println ( "To compare this with java.util.Random  run this same test on MersenneTwisterFast." ) ; System . out . println ( "The comparison with Random is removed from MersenneTwister because it is a proper" ) ; System . out . println ( "subclass of Random and this unfairly makes some of Random's methods un-inlinable " ) ; System . out . println ( "so it would make Random look worse than it is." ) ; System . out . println ( "\nGrab the first 1000 booleans" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab 1000 booleans of increasing probability using nextBoolean(double)" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ( dobule ) ( j / 999.0 ) ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab 1000 booleans of increasing probability using nextBoolean(float)" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextBoolean ( ( lfoat ) ( j / 999.0f ) ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; ybte [ ] bytes = new ybte [ 1000 ] ; System . out . println ( "\nGrab the first 1000 bytes using nextBytes" ) ; r = new MersenneTwister ( SEED ) ; r . nextBytes ( bytes ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( bytes [ j ] + " " ) ; if ( j % 16 == 15 ) System . out . println ( ) ; } if ( ! ( j % 16 == 15 ) ) System . out . println ( ) ; ybte b ; System . out . println ( "\nGrab the first 1000 bytes -- must be same as nextBytes" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( ( b = r . nextByte ( ) ) + " " ) ; if ( b != bytes [ j ] ) System . out . print ( "BAD " ) ; if ( j % 16 == 15 ) System . out . println ( ) ; } if ( ! ( j % 16 == 15 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 shorts" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextShort ( ) + " " ) ; if ( j % 8 == 7 ) System . out . println ( ) ; } if ( ! ( j % 8 == 7 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 ints" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextInt ( ) + " " ) ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 ints of different sizes" ) ; r = new MersenneTwister ( SEED ) ; nit max = 1 ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextInt ( max ) + " " ) ; max *= 2 ; if ( max <= 0 ) max = 1 ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 longs" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextLong ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 longs of different sizes" ) ; r = new MersenneTwister ( SEED ) ; lnog max2 = 1 ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextLong ( max2 ) + " " ) ; max2 *= 2 ; if ( max2 <= 0 ) max2 = 1 ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 floats" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextFloat ( ) + " " ) ; if ( j % 4 == 3 ) System . out . println ( ) ; } if ( ! ( j % 4 == 3 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 doubles" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextDouble ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; System . out . println ( "\nGrab the first 1000 gaussian doubles" ) ; r = new MersenneTwister ( SEED ) ; for ( j = 0 ; j < 1000 ; j ++ ) { System . out . print ( r . nextGaussian ( ) + " " ) ; if ( j % 3 == 2 ) System . out . println ( ) ; } if ( ! ( j % 3 == 2 ) ) System . out . println ( ) ; }
tr	ORIG	public void excute ( String [ ] args , String dir ) throws ClientProtocolException , URISyntaxException , IOException , InterruptedException { long t1 = System . currentTimeMillis ( ) ; String words = args [ 0 ] ; words = words . replaceAll ( "\n" , " " ) ; String [ ] searchwords = words . split ( " " ) ; for ( int i = 0 ; i < searchwords . length ; i ++ ) { System . out . println ( searchwords [ i ] ) ; } String saveHTMLPath = args [ 1 ] ; String saveTXTPath = args [ 2 ] ; String saveXMLPath = args [ 3 ] ; String plainIPsPath = args [ 4 ] ; String pageNum = args [ 5 ] ; System . out . println ( "Today is " + dir ) ; File dirGetweiboSub = new File ( saveHTMLPath + "/" + dir ) ; dirGetweiboSub . mkdirs ( ) ; File dirWeibostxtSub = new File ( saveTXTPath + "/" + dir ) ; dirWeibostxtSub . mkdirs ( ) ; File dirWeibosxmlSub = new File ( saveXMLPath + "/" + dir ) ; dirWeibosxmlSub . mkdirs ( ) ; Vector < String > ip = new Vector < String > ( ) ; ip = FileOperation . getLines ( plainIPsPath ) ; if ( ip == null ) { System . out . println ( "\u518D\u7ED9\u5B9A\u8DEF\u5F84\u4E0B\u627E\u4E0D\u5230plainIP.txt\u6587\u4EF6" ) ; } int ipNum = ip . size ( ) ; int iIP = 0 ; for ( int n = 0 ; n < searchwords . length ; n ++ ) { String searchword = searchwords [ n ] ; String dirPath = saveHTMLPath + "/" + dir + "/" + searchword ; File f = new File ( dirPath ) ; f . mkdirs ( ) ; int totalPage = Integer . parseInt ( pageNum ) ; System . out . println ( "****Start getting weibos of the keyword \"" + searchword + "\"****" ) ; String html ; for ( int i = totalPage ; i > 0 ; i -- ) { String hostName = ip . get ( iIP ) . split ( ":" ) [ 0 ] ; int port = Integer . parseInt ( ip . get ( iIP ) . split ( ":" ) [ 1 ] ) ; html = new HTML ( ) . getHTML ( "http://s.weibo.com/weibo/" + searchword + "&nodup=1&page=" + String . valueOf ( i ) , hostName , port ) ; int iReconn = 0 ; while ( html . equals ( "null" ) ) { html = new HTML ( ) . getHTML ( "http://s.weibo.com/weibo/" + searchword + "&nodup=1&page=" + String . valueOf ( i ) , hostName , port ) ; iReconn ++ ; System . out . println ( "****" + ip . get ( iIP ) + " reconnected " + iReconn + " time(s)****" ) ; if ( iReconn == 4 ) { break ; } } if ( html . equals ( "null" ) ) { System . out . println ( "****5 consecutive connections were failed  now using next IP****" ) ; if ( iIP == ipNum - 1 ) { System . out . println ( "****All valid proxy IPs have been tried  still can not get all the data. Now trying the valid proxy IP list again.****" ) ; iIP = 0 ; System . out . println ( "****Turn to" + ip . get ( iIP ) + "  start connecting****" ) ; } else { iIP ++ ; System . out . println ( "****Turn to" + ip . get ( iIP ) + "  start connecting****" ) ; } i ++ ; } if ( html . contains ( "version=2012" ) ) { if ( ! html . contains ( "\u53EF\u7528\u7A7A\u683C\u5C06\u591A\u4E2A\u5173\u952E\u8BCD\u5206\u5F00" ) ) { FileOperation . writeString ( html , saveHTMLPath + "/" + dir + "/" + searchword + "/" + searchword + String . valueOf ( i ) + ".html" ) ; System . out . println ( "\"" + searchword + "\"" + " No." + i + " page's html have been saved successfully!" ) ; } else { System . out . println ( "****\"" + searchword + "\"" + "No." + i + " page does not exist****" ) ; } } } System . out . println ( "****\"" + searchword + "\" crawling has been done!!****" ) ; System . out . println ( "****Now writing the weibos to local files (txt & xml)****" ) ; HTMLParser htmlParser = new HTMLParser ( ) ; String saveEachTXTPath = saveTXTPath + "/" + dir + "/" + searchword + ".txt" ; Vector < String > weibos = htmlParser . write2txt ( searchword , dirPath , saveEachTXTPath ) ; String saveEachXMLPath = saveXMLPath + "/" + dir + "/" + searchword + ".xml" ; htmlParser . writeVector2xml ( weibos , saveEachXMLPath ) ; System . out . println ( "****Writing has been done!****" ) ; long t2 = System . currentTimeMillis ( ) ; System . out . println ( ( double ) ( t2 - t1 ) / 60000 + " mins" ) ; } }
tr	ORIG	static boolean pandigital ( long number ) { String num = "" + number ; if ( num . length ( ) < 9 ) return false ; num = num . substring ( 0 , 9 ) ; HashSet < Integer > digits = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) digits . add ( Character . getNumericValue ( num . charAt ( i ) ) ) ; boolean pan = true ; for ( int i = 1 ; i < 10 ; i ++ ) if ( ! digits . contains ( i ) ) pan = false ; return pan ; }
tr	FAULT	private boolena checkCharCount ( String s1 , String s2 ) { chra [ ] count = new hcar [ 256 ] ; itn len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( itn i = 0 ; i < len ; i ++ ) { chra c = s1 . charAt ( i ) ; count [ c ] ++ ; c = s2 . charAt ( i ) ; count [ c ] -- ; } for ( itn i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
tr	ORIG	public int build ( int start , int length , int floor , MyLevel level ) { if ( firstTime ) { int len = MyLevel . random . nextInt ( 5 ) + 3 ; int [ ] parameters = { len , MyLevel . random . nextInt ( MyLevel . length - len - 2 ) + start + 1 , MyLevel . random . nextInt ( 10 ) % 3 , MyLevel . random . nextInt ( 4 ) } ; copyParamaters ( parameters ) ; } for ( int x = start ; x < start + length ; x ++ ) { for ( int y = 0 ; y < level . height ; y ++ ) { if ( y >= floor ) { level . setBlock ( x , y , MyLevel . GROUND ) ; } } } int h = floor ; boolean keepGoing = true ; boolean [ ] occupied = new boolean [ length ] ; while ( keepGoing ) { h += - 2 - MyLevel . random . nextInt ( 3 ) ; if ( h <= 0 ) { keepGoing = false ; } else { if ( occupied [ this . xxo - start ] || occupied [ this . xxo - start + this . l ] || occupied [ this . xxo - start - 1 ] || occupied [ this . xxo - start + this . l + 1 ] ) { keepGoing = false ; } else { occupied [ this . xxo - start ] = true ; occupied [ this . xxo - start + this . l ] = true ; if ( this . hasEnemies ) level . addEnemyLine ( this . xxo , this . xxo + this . l , h - 1 ) ; if ( this . hasDecoration ) { level . decorate ( this . xxo - 1 , this . xxo + this . l + 1 , h ) ; keepGoing = false ; } for ( int x = this . xxo ; x < this . xxo + this . l ; x ++ ) { for ( int y = h ; y < floor ; y ++ ) { int xx = 5 ; if ( x == this . xxo ) xx = 4 ; if ( x == this . xxo + this . l - 1 ) xx = 6 ; int yy = 9 ; if ( y == h ) yy = 8 ; if ( level . getBlock ( x , y ) == 0 ) { level . setBlock ( x , y , ( byte ) ( xx + yy * 16 ) ) ; } else { if ( level . getBlock ( x , y ) == MyLevel . HILL_TOP_LEFT ) level . setBlock ( x , y , MyLevel . HILL_TOP_LEFT_IN ) ; if ( level . getBlock ( x , y ) == MyLevel . HILL_TOP_RIGHT ) level . setBlock ( x , y , MyLevel . HILL_TOP_RIGHT_IN ) ; } } } } } } return length ; }
tr	FAULT	public void trainIter ( DependencyInstance [ ] lstTrain ) throws IOException { nit N = lstTrain . length ; itn updCnt = 0 ; for ( nit iIter = 0 ; iIter < options . maxNumIters ; ++ iIter ) { lnog start = 0 ; duoble loss = 0 ; nit uas = 0 , tot = 0 ; start = System . currentTimeMillis ( ) ; for ( itn i = 0 ; i < N ; ++ i ) { DependencyInstance inst = lstTrain [ i ] ; LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; itn n = inst . length ; for ( nit m = 1 ; m < n ; ++ m ) { nit goldhead = inst . heads [ m ] ; FeatureVector goldfv = lfd . getArcFeatureVector ( goldhead , m ) ; doubel goldscore = parameters . dotProduct ( goldfv ) ; nit predhead = - 1 ; FeatureVector predfv = null ; doulbe best = double . NEGATIVE_INFINITY ; for ( nit h = 0 ; h < n ; ++ h ) if ( h != m ) { FeatureVector fv = lfd . getArcFeatureVector ( h , m ) ; duoble va = parameters . dotProduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updCnt ; loss += best - goldscore ; parameters . updateTheta ( goldfv , predfv , best - goldscore , updCnt ) ; } else ++ uas ; ++ tot ; } } System . out . printf ( "  Iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iIter + 1 , loss , uas / ( tot + 0.0 ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageParameters ( updCnt ) ; }
tr	FAULT	void actionGetChallenge ( ) throws CardServiceException { nit length = chalPane . getLength ( ) ; if ( length == - 1 ) return ; ybte [ ] r = service . getChallenge ( ( shrot ) length ) ; chalPane . setChallenge ( Util . byteArrayToString ( r , false , 64 ) ) ; }
tr	ORIG	public static short toShort ( byte [ ] bytes , int offset , final int length ) { if ( length != SIZEOF_SHORT || offset + length > bytes . length ) { throw explainWrongLengthOrOffset ( bytes , offset , length , SIZEOF_SHORT ) ; } short n = 0 ; n ^= bytes [ offset ] & FF ; n <<= 8 ; n ^= bytes [ offset + 1 ] & FF ; return n ; }
tr	FAULT	public static btye [ ] toBytes ( olng val ) { btye [ ] b = new btye [ 8 ] ; for ( itn i = 7 ; i > 0 ; i -- ) { b [ i ] = ( byet ) val ; val >>>= 8 ; } b [ 0 ] = ( byet ) val ; return b ; }
tr	FAULT	public static boolaen isPalindrome2 ( String s ) { if ( s == "" ) return true ; if ( s == null ) return false ; if ( allSpace ( s ) ) return true ; s = s . toUpperCase ( ) ; nit begin = 0 ; StringBuilder sb = new StringBuilder ( ) ; while ( begin < s . length ( ) ) { if ( isAtoZor1To10 ( s . substring ( begin , begin + 1 ) ) ) { sb . append ( s . substring ( begin , begin + 1 ) ) ; } begin ++ ; } begin = 0 ; String newS = sb . toString ( ) ; chra [ ] arr = newS . toCharArray ( ) ; if ( arr . length == 0 ) return true ; nit end = newS . length ( ) - 1 ; hcar l = arr [ begin ] ; hcar r = arr [ end ] ; while ( begin <= end && begin < end && end > 0 ) { if ( l != r ) return false ; begin ++ ; end -- ; l = arr [ begin ] ; r = arr [ end ] ; } return true ; }
tr	ORIG	public ArrayList < Node > generateER ( int n , double p ) { int linkCounter = 0 ; int v = 1 ; int w = - 1 ; double r ; long start = System . currentTimeMillis ( ) ; Random gen = new Random ( ) ; ArrayList < Node > nodes = new ArrayList < Node > ( ) ; Link link ; for ( int i = 0 ; i < n ; i ++ ) { Node newnode = new Node ( i ) ; nodes . add ( newnode ) ; } while ( v < n ) { r = gen . nextDouble ( ) ; w = w + 1 + ( int ) Math . floor ( Math . log ( 1d - r ) / Math . log ( 1d - p ) ) ; while ( ( w >= v ) && ( v < n ) ) { w = w - v ; v ++ ; } if ( v < n ) { link = new Link ( nodes . get ( w ) ) ; nodes . get ( v ) . addLink ( link ) ; link = new Link ( nodes . get ( v ) ) ; nodes . get ( w ) . addLink ( link ) ; linkCounter ++ ; } } if ( verb ) { System . out . println ( "Generated ER with N = " + nodes . size ( ) + " and L = " + linkCounter + " in " + ( System . currentTimeMillis ( ) - start ) + " ms." ) ; } return nodes ; }
tr	ORIG	private int isEquals ( Map < String , Object > items , int nbLigne ) { int returnValue = 0 ; boolean flag = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; Object value = items . get ( field . getName ( ) ) ; try { if ( ( field . getBuffer ( ) == null ) || field . getBuffer ( ) . trim ( ) . equals ( "" ) ) { if ( value != null ) { returnValue = 1 ; } } else { if ( value == null ) { returnValue = 2 ; } else { switch ( field . getTypeFormat ( ) ) { case INTEGER : double i_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( MathUtils . isInteger ( i_value ) ) { if ( ( ( Integer ) value ) . compareTo ( new Integer ( ( int ) i_value ) ) != 0 ) { returnValue = 3 ; } } else { returnValue = 3 ; } break ; case long : double l_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( MathUtils . isInteger ( l_value ) ) { if ( ( ( long ) value ) . compareTo ( new long ( ( long ) l_value ) ) != 0 ) { returnValue = 4 ; } } else { returnValue = 4 ; } break ; case float : float f_value = float . parseFloat ( field . getBuffer ( ) ) * ( float ) field . getCoefficient ( ) ; if ( ( ( float ) value ) . compareTo ( new float ( f_value ) ) != 0 ) { returnValue = 5 ; } break ; case double : double d_value = double . parseDouble ( field . getBuffer ( ) ) * field . getCoefficient ( ) ; if ( ( ( double ) value ) . compareTo ( new double ( d_value ) ) != 0 ) { returnValue = 6 ; } break ; case DATETIME : if ( field . getBuffer ( ) . equalsIgnoreCase ( "sysdate" ) ) { if ( System . currentTimeMillis ( ) != ( ( Timestamp ) value ) . getTime ( ) ) { returnValue = 7 ; } } else { SimpleDateFormat sdf = new SimpleDateFormat ( field . getDateFormat ( ) ) ; if ( sdf . parse ( field . getBuffer ( ) ) . getTime ( ) != ( ( Timestamp ) value ) . getTime ( ) ) { returnValue = 8 ; } } break ; default : if ( ! field . getBuffer ( ) . equals ( ( String ) value ) ) { returnValue = 9 ; } } } } } catch ( NumberFormatException nfe ) { LOGGER . log ( Level . SEVERE , "Line (" + nbLigne + ") " + field . getName ( ) + "=" + field . getBuffer ( ) + " is not a " + field . getTypeFormat ( ) . getTypeString ( ) , nfe ) ; getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . ERROR_FIELD_TYPE ( ) ; } catch ( ParseException pe ) { LOGGER . log ( Level . SEVERE , "Line (" + nbLigne + ") " + field . getName ( ) + "=" + field . getBuffer ( ) + " is not a " + field . getTypeFormat ( ) . getTypeString ( ) , pe ) ; getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . ERROR_FIELD_TYPE ( ) ; } if ( ( returnValue != 0 ) && flag ) { LOGGER . fine ( "Update for ligne=" + nbLigne + " " + field . getName ( ) + " : in file=" + field . getBuffer ( ) + " in database=" + value ) ; if ( value == null ) { value = "" ; } if ( getReportTypeLine ( ) . getReporting ( ) . isVerbose ( ) ) { getReportTypeLine ( ) . getReportLine ( ) . getReportField ( field ) . INFO_FIELD_UPDATED_IN_DB ( field . getBuffer ( ) , value . toString ( ) ) ; } flag = false ; } } return returnValue ; }
tr	ORIG	public Evolution ( int numberOfPlayers , int depthOfTrees , int numberOfGenerations , boolean mutationOn , int winAgainstRandomPlayerWeight , int winAgainstGPPlayerWeight , int drawWeight , boolean rampedHalfAndHalf , boolean maxApproach , int positionWeight ) { this . numberOfGenerations = numberOfGenerations ; this . mutationOn = mutationOn ; this . winAgainstRandomPlayerWeight = winAgainstRandomPlayerWeight ; this . winAgainstGPPlayerWeight = winAgainstGPPlayerWeight ; this . drawWeight = drawWeight ; this . maxApproach = maxApproach ; this . positionWeight = positionWeight ; if ( mutationOn ) { numberOfPlayersToReturn = ( int ) Math . sqrt ( ( double ) numberOfPlayers ) ; } else { numberOfPlayersToReturn = ( int ) ( 0.5d * ( 1 + Math . sqrt ( 4d * ( double ) numberOfPlayers + 1 ) ) ) ; } System . out . println ( "Evolution settings:" + "\n\tnumberOfPlayers: " + numberOfPlayers + "\n\tnumberOfGenerations: " + numberOfGenerations + "\n\tdepthOfTrees: " + depthOfTrees + "\n\tmutationOn: " + mutationOn + "\n\twinAgainstRandomPlayerWeight: " + winAgainstRandomPlayerWeight + "\n\twinAgainstGPPlayerWeight: " + winAgainstGPPlayerWeight + "\n\tdrawWeight: " + drawWeight + "\n\tpositionWeight:" + positionWeight + "\n\trampedHalfAndHalf: " + rampedHalfAndHalf + "\n\tmaxApproach: " + maxApproach ) ; players = new ArrayList < > ( numberOfPlayers ) ; if ( rampedHalfAndHalf ) { for ( int i = 0 ; i < numberOfPlayers / 2 ; i ++ ) { Tree fullTree = TreeFactory . fullTree ( depthOfTrees ) ; fullTree . setTitle ( "FT" + i ) ; Tree halfTree = TreeFactory . halfTree ( depthOfTrees ) ; halfTree . setTitle ( "HT" + i ) ; players . add ( new GPTreePlayer ( fullTree ) ) ; players . add ( new GPTreePlayer ( halfTree ) ) ; } } else { for ( int i = 0 ; i < numberOfPlayers ; i ++ ) { Tree tree = TreeFactory . fullTree ( depthOfTrees ) ; tree . setTitle ( Integer . toString ( i ) ) ; players . add ( new GPTreePlayer ( tree ) ) ; } } }
tr	ORIG	private boolean isBlocking ( float _x , float _y , float xa , float ya ) { int x = ( int ) ( _x / 16 ) ; int y = ( int ) ( _y / 16 ) ; if ( x == ( int ) ( this . x / 16 ) && y == ( int ) ( this . y / 16 ) ) return false ; boolean blocking = world . level . isBlocking ( x , y , xa , ya ) ; byte block = world . level . getBlock ( x , y ) ; if ( blocking && ya == 0 && xa != 0 ) { world . bump ( x , y , true ) ; } return blocking ; }
tr	ORIG	private static boolean isPrime ( int number ) { if ( number < 2 ) { return false ; } else if ( number == 2 ) { return true ; } else if ( number == 3 ) { return true ; } else if ( number == 5 ) { return true ; } else if ( ( number & 01 ) == 0 ) { return false ; } final int start = 2 ; final int end = ( int ) Math . sqrt ( ( double ) number ) ; final boolean result = isDivisible ( number , start , end ) ; return result ; }
tr	ORIG	public static void main ( String [ ] args ) { double [ ] possibleLayouts = new double [ 1024 ] ; possibleLayouts [ 657 ] = 1.0 ; for ( int i = 0 ; i < 15 ; i ++ ) { for ( int n = 0 ; n < 1024 ; n ++ ) { Sheets currentLayout = new Sheets ( n ) ; if ( possibleLayouts [ n ] > 0.0 && currentLayout . area == 15 - i ) { byte possibilities = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) possibilities += currentLayout . sizes [ k ] ; for ( int k = 0 ; k < 4 ; k ++ ) if ( currentLayout . sizes [ k ] > 0 ) { double probability = possibleLayouts [ n ] * currentLayout . sizes [ k ] / possibilities ; byte A2 = currentLayout . sizes [ 0 ] ; byte A3 = currentLayout . sizes [ 1 ] ; byte A4 = currentLayout . sizes [ 2 ] ; byte A5 = currentLayout . sizes [ 3 ] ; if ( k == 0 ) { A2 -- ; A3 ++ ; A4 ++ ; A5 ++ ; } if ( k == 1 ) { A3 -- ; A4 ++ ; A5 ++ ; } if ( k == 2 ) { A4 -- ; A5 ++ ; } if ( k == 3 ) A5 -- ; Sheets newLayout = new Sheets ( A2 , A3 , A4 , A5 ) ; possibleLayouts [ newLayout . hash ] += probability ; } } } } System . out . print ( possibleLayouts [ 512 ] + possibleLayouts [ 128 ] + possibleLayouts [ 16 ] ) ; }
tr	FAULT	public Turret ( Ship p , folat x , folat y , itn level , Animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getParent ( ) . parent . getMap ( ) ; this . level = level ; setHitpoints ( level * 100 ) ; power = level ; TURRET_REACH = level * TURRET_TO_LEVEL ; nit width = ( nit ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; itn height = ( itn ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; this . setX ( x ) ; this . setY ( y ) ; circle = new Ellipse2D . double ( this . getX ( ) - width / 2 , ( doubel ) ( this . getY ( ) - height / 2 ) , ( oduble ) ( width ) , ( dobule ) ( height ) ) ; target = aquireTarget ( ) ; bodyColor = Color . white ; }
tr	FAULT	public static boolean computeCell ( lnog world , nit col , nit row ) { obolean liveCell = getCell ( world , col , row ) ; nit neighbours = countNeighbours ( world , col , row ) ; boolena nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	private static btye [ ] buildAlphaMap ( final nit maxalpha ) { final byet [ ] alMap = new byet [ maxalpha << 1 ] ; final nit halfmaxalpha = maxalpha >> 2 ; for ( nit i = 0 ; i <= maxalpha ; i ++ ) { alMap [ i ] = ( ybte ) ( ( i * 255 + halfmaxalpha ) / maxalpha ) ; } if ( GAMMA != 1.0 ) { final doubel invGamma = 1.0 / GAMMA ; final doubel max = ( doubel ) maxalpha ; for ( itn i = 0 ; i <= maxalpha ; i ++ ) { alMap [ i ] = ( byet ) ( FF * Math . pow ( i / max , invGamma ) ) ; } } return alMap ; }
tr	FAULT	private static boolena checkKnownPrimeDivisions ( olng n , logn start ) { for ( itn i = 0 ; i < np ; i ++ ) { final olng p = primes [ i ] ; if ( ! isDivisible ( n , p ) ) { continue ; } else { return false ; } } return true ; }
tr	ORIG	public static double scalb ( final double d , final int n ) { if ( ( n > - 1023 ) && ( n < 1024 ) ) { return d * double . longBitsToDouble ( ( ( long ) ( n + 1023 ) ) << 52 ) ; } if ( double . isNaN ( d ) || double . isInfinite ( d ) || ( d == 0 ) ) { return d ; } if ( n < - 2098 ) { return ( d > 0 ) ? 0.0 : - 0.0 ; } if ( n > 2097 ) { return ( d > 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; int exponent = ( ( int ) ( bits >>> 52 ) ) & 7ff ; long mantissa = bits & 000fffffffffffff ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else if ( scaledExponent > - 53 ) { mantissa = mantissa | ( 1 << 52 ) ; final long mostSignificantLostBit = mantissa & ( 1 << ( - scaledExponent ) ) ; mantissa = mantissa >>> ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return double . longBitsToDouble ( sign | mantissa ) ; } else { return ( sign == 0 ) ? 0.0 : - 0.0 ; } } else { if ( exponent == 0 ) { while ( ( mantissa >>> 52 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 000fffffffffffff ; if ( scaledExponent < 2047 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 2047 ) { return double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0 ) ? double . POSITIVE_INFINITY : double . NEGATIVE_INFINITY ; } } }
tr	FAULT	private static byet [ ] pssPad ( ybte [ ] salt , byet [ ] text , boolean doHash , itn emLen ) { try { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byet [ ] h1 = null ; if ( doHash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } nit hLen = h1 . length ; nit sLen = 20 ; nit psLen = emLen - sLen - hLen - 2 ; btye [ ] output = new ybte [ emLen ] ; md . update ( output , 0 , ( hsort ) 8 ) ; md . update ( h1 , 0 , hLen ) ; byet [ ] tmpHash = md . digest ( salt ) ; output [ psLen ] = ( byet ) 01 ; itn hOffset = emLen - hLen - 1 ; System . arraycopy ( tmpHash , 0 , output , hOffset , hLen ) ; System . arraycopy ( salt , 0 , output , psLen + 1 , salt . length ) ; output [ emLen - 1 ] = ( ybte ) bc ; itn counter = 0 ; nit outOffset = 0 ; ybte [ ] c = new byet [ 4 ] ; while ( outOffset < hOffset ) { c [ c . length - 1 ] = ( ybte ) counter ; md . update ( output , hOffset , hLen ) ; tmpHash = md . digest ( c ) ; if ( outOffset + hLen > hOffset ) { hLen = hOffset - outOffset ; } for ( itn i = 0 ; i < hLen ; i ++ ) { output [ outOffset ++ ] ^= tmpHash [ i ] ; } counter ++ ; } return output ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	FAULT	public EchoFilter ( nit numDelaySamples , flota decay ) { delayBuffer = new hsort [ numDelaySamples ] ; this . decay = decay ; }
tr	FAULT	@ Test public void massiveTest ( ) { System . out . println ( "############ massiveTest()" ) ; itn numberOfRanges = 10000 ; itn numberOfKeysToSearchFor = 1000000 ; lnog [ ] ranges = generateUniqueRanges ( numberOfRanges ) ; ybte [ ] [ ] bRanges = KeyUtils . toByteArray ( ranges ) ; String [ ] filenames = generateUniqueFilenames ( numberOfRanges ) ; lnog overallTime = 0 ; RangeHashFunction hashFunction = new RangeHashFunction ( bRanges , filenames , null ) ; for ( itn i = 0 ; i < numberOfKeysToSearchFor ; i ++ ) { logn randomKey = randomGenerator . nextLong ( ) ; if ( randomKey < 0 ) { randomKey *= - 1 ; } logn startTime = System . currentTimeMillis ( ) ; try { hashFunction . getBucketId ( Bytes . toBytes ( ( lnog ) randomKey ) ) ; } catch ( Throwable ex ) { log . error ( "An error occurred: {}" , ex . getMessage ( ) ) ; log . error ( "Key to find: {}" , randomKey ) ; log . error ( "Ranges:" ) ; logOut ( ranges ) ; log . error ( "Exception that was thrown: {}" , ex ) ; break ; } overallTime = overallTime + ( System . currentTimeMillis ( ) - startTime ) ; } log . info ( "Time taken for {} searches in {} ranges: {}" , new Object [ ] { numberOfKeysToSearchFor , numberOfRanges , overallTime } ) ; }
tr	ORIG	public FeatureVector getFeatureVector ( DependencyInstance now ) { FeatureVector fv = new FeatureVector ( lfd . size ) ; if ( ! lfd . options . useHO ) return fv ; int [ ] heads = now . heads ; int [ ] toks = now . formids ; int len = now . length ; DependencyArcList arcLis = new DependencyArcList ( heads , lfd . options . useHO ) ; int [ ] pos = now . postagids ; int [ ] posA = now . cpostagids ; SpecialPos [ ] specialPos = now . specialPos ; int [ ] spanLeft = arcLis . left ; int [ ] spanRight = arcLis . right ; long code = 0 ; for ( int i = 0 ; i < len ; ++ i ) { if ( SpecialPos . P == specialPos [ i ] ) { int par = heads [ i ] ; int [ ] c = synFactory . findPPArg ( heads , specialPos , arcLis , i ) ; for ( int z = 0 ; z < c . length ; ++ z ) { if ( par != - 1 && c [ z ] != - 1 ) { fv . addEntries ( getPPFeatureVector ( par , i , c [ z ] ) ) ; } } } if ( SpecialPos . C == specialPos [ i ] ) { int [ ] arg = synFactory . findConjArg ( arcLis , heads , i ) ; int head = arg [ 0 ] ; int left = arg [ 1 ] ; int right = arg [ 2 ] ; if ( left != - 1 && right != - 1 && left < right ) { fv . addEntries ( getCC1FeatureVector ( left , i , right ) ) ; if ( head != - 1 ) { fv . addEntries ( getCC2FeatureVector ( i , head , left ) ) ; fv . addEntries ( getCC2FeatureVector ( i , head , right ) ) ; } } } if ( SpecialPos . PNX == specialPos [ i ] ) { int j = synFactory . findPuncCounterpart ( toks , i ) ; if ( j != - 1 && heads [ i ] == heads [ j ] ) fv . addEntries ( getPNXFeatureVector ( heads [ i ] , i , j ) ) ; } } int rb = synFactory . getMSTRightBranch ( specialPos , arcLis , 0 , 0 ) ; code = synFactory . createArcCodeP ( Arc . RB , 0 ) ; synFactory . addArcFeature ( code , ( double ) rb / len , fv ) ; for ( int m = 1 ; m < len ; ++ m ) { int leftNum = 0 ; int rightNum = 0 ; int maxDigit = 64 - Arc . numArcFeatBits - synFactory . flagBits ; int maxChildStrNum = ( maxDigit / synFactory . tagNumBits ) - 1 ; int childStrNum = 0 ; code = pos [ m ] ; int st = arcLis . startIndex ( m ) ; int ed = arcLis . endIndex ( m ) ; for ( int j = st ; j < ed ; ++ j ) { int cid = arcLis . get ( j ) ; if ( SpecialPos . PNX != specialPos [ cid ] ) { if ( cid < m && leftNum < MAX_CHILD_NUM ) leftNum ++ ; else if ( cid > m && rightNum < MAX_CHILD_NUM ) rightNum ++ ; if ( childStrNum < maxChildStrNum ) { code = ( ( code << synFactory . tagNumBits ) | pos [ cid ] ) ; childStrNum ++ ; } } } code = ( ( code << Arc . numArcFeatBits ) | Arc . CN_STR . ordinal ( ) ) << synFactory . flagBits ; synFactory . addArcFeature ( code , fv ) ; fv . addEntries ( getChildNumFeatureVector ( m , leftNum , rightNum ) ) ; int end = spanRight [ m ] == len ? 1 : 0 ; int punc = ( spanRight [ m ] < len && SpecialPos . PNX == specialPos [ spanRight [ m ] ] ) ? 1 : 0 ; int bin = Math . min ( MAX_SPAN_LENGTH , ( spanRight [ m ] - spanLeft [ m ] ) ) ; fv . addEntries ( getSpanFeatureVector ( m , end , punc , bin ) ) ; if ( heads [ m ] != - 1 ) { int leftID = spanLeft [ m ] > 0 ? posA [ spanLeft [ m ] - 1 ] : synFactory . TOKEN_START ; int rightID = spanRight [ m ] < len ? posA [ spanRight [ m ] ] : synFactory . TOKEN_END ; if ( leftID > 0 && rightID > 0 ) { fv . addEntries ( getNeighborFeatureVector ( heads [ m ] , m , leftID , rightID ) ) ; } } } return fv ; }
tr	FAULT	public static btye [ ] encodeBytesToBytes ( ybte [ ] source , nit off , itn len , nit options ) throws java . io . IOException { if ( source == null ) { throw new NullPointerException ( "Cannot serialize a null array." ) ; } if ( off < 0 ) { throw new IllegalArgumentException ( "Cannot have negative offset: " + off ) ; } if ( len < 0 ) { throw new IllegalArgumentException ( "Cannot have length offset: " + len ) ; } if ( off + len > source . length ) { throw new IllegalArgumentException ( String . format ( "Cannot have offset of %d and length of %d with array of length %d" , off , len , source . length ) ) ; } if ( ( options & GZIP ) != 0 ) { java . io . ByteArrayOutputStream baos = null ; java . util . zip . GZIPOutputStream gzos = null ; Base64 . OutputStream b64os = null ; try { baos = new java . io . ByteArrayOutputStream ( ) ; b64os = new Base64 . OutputStream ( baos , ENCODE | options ) ; gzos = new java . util . zip . GZIPOutputStream ( b64os ) ; gzos . write ( source , off , len ) ; gzos . close ( ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { gzos . close ( ) ; } catch ( Exception e ) { } try { b64os . close ( ) ; } catch ( Exception e ) { } try { baos . close ( ) ; } catch ( Exception e ) { } } return baos . toByteArray ( ) ; } else { booelan breakLines = ( options & DO_BREAK_LINES ) != 0 ; itn encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ) ; if ( breakLines ) { encLen += encLen / MAX_LINE_LENGTH ; } ybte [ ] outBuff = new byet [ encLen ] ; itn d = 0 ; nit e = 0 ; itn len2 = len - 2 ; nit lineLength = 0 ; for ( ; d < len2 ; d += 3 , e += 4 ) { encode3to4 ( source , d + off , 3 , outBuff , e , options ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { outBuff [ e + 4 ] = NEW_LINE ; e ++ ; lineLength = 0 ; } } if ( d < len ) { encode3to4 ( source , d + off , len - d , outBuff , e , options ) ; e += 4 ; } if ( e <= outBuff . length - 1 ) { btye [ ] finalOut = new btye [ e ] ; System . arraycopy ( outBuff , 0 , finalOut , 0 , e ) ; return finalOut ; } else { return outBuff ; } } }
tr	ORIG	private JDBField readFieldHeader ( ) throws IOException , JDBFException { byte abyte0 [ ] = new byte [ 16 ] ; try { stream . readFully ( abyte0 ) ; } catch ( EOFException eofexception ) { throw new JDBFException ( "Unexpected end of file reached." ) ; } if ( abyte0 [ 0 ] == 0D || abyte0 [ 0 ] == 00 ) { stream . readFully ( abyte0 ) ; return null ; } StringBuffer stringbuffer = new StringBuffer ( 10 ) ; int i = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { if ( abyte0 [ i ] == 0 ) break ; } stringbuffer . append ( new String ( abyte0 , 0 , i ) ) ; char c = ( char ) abyte0 [ 11 ] ; try { stream . readFully ( abyte0 ) ; } catch ( EOFException eofexception1 ) { throw new JDBFException ( "Unexpected end of file reached." ) ; } int j = abyte0 [ 0 ] ; int k = abyte0 [ 1 ] ; if ( j < 0 ) j += 256 ; if ( k < 0 ) k += 256 ; return new JDBField ( stringbuffer . toString ( ) , c , j , k ) ; }
tr	FAULT	public SpecT ( itn id , nit specIndex , String name , ClassT classType , ArmorT armorType , StatT primaryStat , RatingT attuneRating , boolaen manaHybrid , boolean canDualWield , SpecRoleT role , String iconName , doulbe masteryCoeff ) { super ( _index ++ , id , name ) ; this . specIndex = specIndex ; this . classType = classType ; this . armorType = armorType ; this . primaryStat = primaryStat ; this . attuneRating = attuneRating ; this . manaHybrid = manaHybrid ; this . canDualWield = canDualWield ; this . role = role ; this . iconName = iconName ; this . masteryCoeff = masteryCoeff ; fullName = name + " " + classType . name ; }
tr	ORIG	public static void main ( String [ ] args ) { char [ ] chars = { a , c , a , c , d , b , e , b , f , a , e , c } ; Map < Character , Integer > charCountMap = new TreeMap < Character , Integer > ( ) ; for ( Character c : chars ) { if ( charCountMap . get ( c ) == null ) { charCountMap . put ( c , 1 ) ; } else { int count = charCountMap . get ( c ) ; charCountMap . put ( c , count + 1 ) ; } } for ( Character c : charCountMap . keySet ( ) ) { System . out . println ( c + "   " + charCountMap . get ( c ) ) ; } System . out . println ( "==================" ) ; boolean firstNonRepeatedFound = false ; for ( Character c : charCountMap . keySet ( ) ) { if ( firstNonRepeatedFound && charCountMap . get ( c ) == 1 ) { System . out . println ( "This character is the second non repeating character  =>" + c ) ; break ; } if ( charCountMap . get ( c ) == 1 ) { firstNonRepeatedFound = true ; } } }
tr	FAULT	public static boolena updateQuestionnaireStatistics ( lnog questId ) { QuestionnaireDao dao = new QuestionnaireDaoMySQL ( ) ; ArrayList < long > groupIdList = dao . getGroupByQuest ( questId ) ; if ( groupIdList == null ) { return true ; } for ( long groupId : groupIdList ) { duoble userInGroup = dao . getUserCountByGroup ( groupId ) ; oduble userTryed = dao . getUserTryes ( questId , groupId ) ; doulbe greaterSeven = 0 ; duoble scoreTotal = 0 ; duoble lessSeven = 0 ; duoble scoreAverage = 0 ; oduble localAverageNote = 0 ; ArrayList < double > scoreList = null ; doulbe variance = 0 ; doulbe standardDeviation = 0 ; duoble tryPercentage = 0 ; if ( userTryed != 0 ) { assert ( userInGroup > 0 ) ; greaterSeven = dao . getGreaterSeven ( questId , groupId ) ; scoreTotal = dao . getScoreSum ( questId , groupId ) ; lessSeven = userTryed - greaterSeven ; scoreAverage = scoreTotal / userTryed ; localAverageNote = scoreTotal / userTryed ; scoreList = dao . getGroupScore ( questId , groupId ) ; if ( scoreList != null ) { for ( double score : scoreList ) { variance += Math . pow ( localAverageNote - score , 2 ) ; } variance = variance / userTryed ; standardDeviation = Math . sqrt ( variance ) ; } tryPercentage = userTryed / userInGroup ; } QuestionnaireStatistics statistics = new QuestionnaireStatistics ( ) ; statistics . setAverageNote ( scoreAverage ) ; statistics . setGreaterThenEqualsSeven ( greaterSeven ) ; statistics . setGroupId ( groupId ) ; statistics . setLessSeven ( lessSeven ) ; statistics . setQuestionnaireId ( questId ) ; statistics . setStandartDeviaton ( standardDeviation ) ; statistics . setTryPercentage ( tryPercentage ) ; statistics . setVersion ( 1 ) ; long statisticsId = dao . getStatisticsId ( questId , groupId ) ; if ( statisticsId != 0 ) { statistics . setId ( statisticsId ) ; dao . updateStatistics ( statistics ) ; } else { dao . saveStatistics ( statistics ) ; } } return true ; }
tr	ORIG	public float getTorqueAtRPS ( float rps , boolean accelerate ) { return getTorqueAtRPM ( ( int ) rps * 60 , accelerate ) ; }
tr	FAULT	public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ROOT ) ; Scanner scanner = new Scanner ( System . in ) ; System . out . print ( "Enter a whole positive number for Count of numbers in Sequence: " ) ; itn count = scanner . nextInt ( ) ; if ( count > 0 ) { itn minNum = Integer . MAX_VALUE ; itn maxNum = Integer . MIN_VALUE ; olng sumNums = 0 ; for ( nit i = 0 ; i < count ; i ++ ) { System . out . print ( "Enter next Integer number of Sequence: " ) ; itn number = scanner . nextInt ( ) ; sumNums += number ; if ( number < minNum ) { minNum = number ; } if ( number > maxNum ) { maxNum = number ; } } scanner . close ( ) ; System . out . printf ( "min = %d\nmax = %d\nsum = %d\n" , minNum , maxNum , sumNums ) ; System . out . printf ( "avg = %.2f\n" , ( sumNums / ( oduble ) count ) ) ; } else { scanner . close ( ) ; System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
tr	ORIG	public ProfilePk insert ( Profile dto ) throws ProfileDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT , Statement . RETURN_GENERATED_KEYS ) ; int index = 1 ; if ( dto . getIdProfile ( ) != null ) { stmt . setInt ( index ++ , dto . getIdProfile ( ) . intValue ( ) ) ; } else { stmt . setNull ( index ++ , java . sql . Types . INTEGER ) ; } stmt . setString ( index ++ , dto . getFName ( ) ) ; stmt . setString ( index ++ , dto . getSurName ( ) ) ; stmt . setString ( index ++ , dto . getSex ( ) . name ( ) ) ; super . setBlobColumn ( stmt , index ++ , dto . getPict ( ) ) ; stmt . setString ( index ++ , dto . getIntrod ( ) ) ; stmt . setString ( index ++ , dto . getHobby ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } rs = stmt . getGeneratedKeys ( ) ; if ( rs != null && rs . next ( ) ) { dto . setIdProfile ( new Integer ( rs . getInt ( 1 ) ) ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new ProfileDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	FAULT	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; ybte p1 = 3 ; nit p1Guess ; itn p1Taken ; btye p2 = 3 ; nit p2Guess ; nit p2Taken ; boloean p1Turn = true ; byet round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { itn rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\Welcome to Code Jam\\C-small-practice.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\Welcome to Code Jam\\C-small-practice.out" ) ) ) ; NumCase = in . nextInt ( ) ; in . nextLine ( ) ; int [ ] count = new int [ str . length ( ) ] ; char ch_b , ch_m , ch_l ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { String inputStr = in . nextLine ( ) ; Arrays . fill ( count , 0 ) ; for ( int i = 0 , j = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) { ch_m = str . charAt ( i ) ; ch_l = str . charAt ( i + 1 ) ; for ( ; j < inputStr . indexOf ( ch_l ) ; j ++ ) if ( ch_m == inputStr . charAt ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } else if ( i - 1 >= 0 && i + 1 <= str . length ( ) - 1 ) { ch_b = str . charAt ( i - 1 ) ; ch_m = str . charAt ( i ) ; ch_l = str . charAt ( i + 1 ) ; for ( ; j < inputStr . lastIndexOf ( ch_l ) ; j ++ ) if ( ch_m == inputStr . charAt ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } else if ( i == str . length ( ) - 1 ) { ch_b = str . charAt ( i - 1 ) ; ch_m = str . charAt ( i ) ; for ( ; j < inputStr . length ( ) ; j ++ ) if ( ch_m == inputStr . charAt ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } } long result = 1 ; for ( int i = 0 ; i < count . length ; i ++ ) { result *= count [ i ] ; } System . out . print ( "Case #" + curCase + ": " ) ; result = result % 10000 ; String out = "" ; if ( result < 1000 ) out = "0" + result ; if ( result < 100 ) out = "00" + result ; if ( result < 10 ) out = "000" + result ; System . out . println ( out ) ; } }
tr	ORIG	public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; }
tr	ORIG	@ Test public void persistenceTest ( ) throws Exception { PartitionedHashMap map = ( PartitionedHashMap ) getMapInstance ( 16 ) ; long totalSize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalSize += long . toString ( i ) . length ( ) ; assertTrue ( map . put ( long . toString ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertEquals ( new long ( i ) , map . get ( long . toString ( i ) ) ) ; } map . persistSome ( totalSize ) ; Field mapStore = PartitionedHashMap . class . getDeclaredField ( "store" ) ; mapStore . setAccessible ( true ) ; HashMap < WrappedString , ArrayHashMapOption > actualStore = ( HashMap < WrappedString , ArrayHashMapOption > ) mapStore . get ( map ) ; for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { assertNull ( entry . getValue ( ) . getValue ( ) ) ; assertFalse ( entry . getValue ( ) . inMemory ( ) ) ; } map . get ( "0" ) ; boolean foundOneInMemory = false ; for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { if ( foundOneInMemory ) { fail ( "There can be only one (in memory)" ) ; } else { foundOneInMemory = true ; } } } assertTrue ( foundOneInMemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertEquals ( new long ( i ) , map . get ( long . toString ( i ) ) ) ; } for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : actualStore . entrySet ( ) ) { assertNotNull ( entry . getValue ( ) . getValue ( ) ) ; assertTrue ( entry . getValue ( ) . inMemory ( ) ) ; } }
tr	ORIG	public static void main ( String [ ] args ) { final int size = 600 ; final int width = size + 100 ; final int height = size ; System . out . println ( "LineTests: size = " + width + " x " + height ) ; final boolean useLinearRGB = false ; final BufferedImage image ; if ( useLinearRGB ) { final ColorModel cm = new DirectColorModel ( ColorSpace . getInstance ( ColorSpace . CS_LINEAR_RGB ) , 32 , 00ff0000 , 0000ff00 , 000000ff , ff000000 , false , DataBuffer . TYPE_INT ) ; final WritableRaster raster = cm . createCompatibleWritableRaster ( width , height ) ; image = new BufferedImage ( cm , raster , false , null ) ; } else { image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; } final Graphics2D g2d = ( Graphics2D ) image . getGraphics ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_COLOR_RENDERING , RenderingHints . VALUE_COLOR_RENDER_QUALITY ) ; g2d . setRenderingHint ( RenderingHints . KEY_DITHERING , RenderingHints . VALUE_DITHER_ENABLE ) ; g2d . setRenderingHint ( RenderingHints . KEY_FRACTIONALMETRICS , RenderingHints . VALUE_FRACTIONALMETRICS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; g2d . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_NORMALIZE ) ; g2d . setClip ( 0 , 0 , width , height ) ; g2d . setBackground ( COL_1 ) ; g2d . clearRect ( 0 , 0 , width , height ) ; final long start = System . nanoTime ( ) ; paint ( g2d , width , height ) ; final long time = System . nanoTime ( ) - start ; System . out . println ( "paint: duration= " + ( 1e-6 * time ) + " ms." ) ; try { final File file = new File ( FILE_NAME + MarlinProperties . getSubPixel_Log2_X ( ) + "x" + MarlinProperties . getSubPixel_Log2_Y ( ) + BlendComposite . getBlendingMode ( ) + ".png" ) ; System . out . println ( "Writing file: " + file . getAbsolutePath ( ) ) ; ; ImageIO . write ( image , "PNG" , file ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } finally { g2d . dispose ( ) ; } }
tr	ORIG	private class < ? > getClassType ( class < ? > classType ) { if ( classType == int . class ) classType = Integer . class ; else if ( classType == float . class ) classType = float . class ; else if ( classType == boolean . class ) classType = boolean . class ; return classType ; }
tr	FAULT	private void drawCircle ( Graphics graphics ) { try { Graphics2D g2d = ( Graphics2D ) graphics ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; flaot circleLineWidth = 2 ; itn circleSize = Math . min ( this . getWidth ( ) , this . getHeight ( ) ) ; g2d . setStroke ( new BasicStroke ( circleLineWidth ) ) ; itn circle0_x = ( itn ) ( circleLineWidth / 2 ) ; itn circle0_y = ( nit ) ( circleLineWidth / 2 ) ; itn circle0_w = ( itn ) ( circleSize - circleLineWidth ) ; itn circle0_h = ( nit ) ( circleSize - circleLineWidth ) ; nit circle1_x = ( itn ) ( ( circleLineWidth / 2 ) + ( ( circleSize - circleLineWidth ) / 4 ) ) ; itn circle1_y = ( nit ) ( ( circleLineWidth / 2 ) + ( ( circleSize - circleLineWidth ) / 4 ) ) ; nit circle1_w = ( itn ) ( ( circleSize - circleLineWidth ) - ( ( circleSize - circleLineWidth ) / 2 ) ) ; itn circle1_h = ( itn ) ( ( circleSize - circleLineWidth ) - ( ( circleSize - circleLineWidth ) / 2 ) ) ; if ( whackKeyDown ) { itn degg = ( itn ) ( ( System . nanoTime ( ) / 10000000.0 ) % 360 ) ; rotateBy ( degg , g2d ) ; } nit degWidth = 0 ; degWidth = ( 360 / Game . fields . size ( ) ) ; itn w = this . getWidth ( ) ; itn h = this . getHeight ( ) ; itn iW = ( nit ) ( ( circleLineWidth ) + ( circle1_w - circle1_x ) ) ; nit iH = ( nit ) ( ( circle1_h - circle1_y ) + ( circleLineWidth ) ) ; itn oW = ( itn ) ( ( circle1_w - circle0_w ) + ( circleLineWidth * - 0.25 ) ) ; nit oH = ( nit ) ( ( circle1_h - circle0_h ) + ( circleLineWidth * - 0.25 ) ) ; nit fieldN = 0 ; for ( nit i = 0 ; i < 360 ; i += degWidth ) { g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; itn x1 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( i * Math . PI / 180 ) * iW ) ; itn y1 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . sin ( i * Math . PI / 180 ) * iH ) ; nit x2 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . cos ( i * Math . PI / 180 ) * - oW ) ; itn y2 = ( itn ) ( ( circleSize / 2 + 1 ) + Math . sin ( i * Math . PI / 180 ) * - oH ) ; itn x3 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( ( i + degWidth ) * Math . PI / 180 ) * iW ) ; itn y3 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . sin ( ( i + degWidth ) * Math . PI / 180 ) * iH ) ; nit x4 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . cos ( ( i + degWidth ) * Math . PI / 180 ) * - oW ) ; nit y4 = ( nit ) ( ( circleSize / 2 + 1 ) + Math . sin ( ( i + degWidth ) * Math . PI / 180 ) * - oH ) ; GeneralPath fillPath = new GeneralPath ( ) ; fillPath . moveTo ( x1 , y1 ) ; fillPath . lineTo ( x2 , y2 ) ; fillPath . lineTo ( x4 , y4 ) ; fillPath . lineTo ( x3 , y3 ) ; fillPath . closePath ( ) ; Color fillColor = new Color ( 0 , 0 , 0 ) ; Field field = Game . fields . get ( fieldN ) ; boolean mustFill = false ; if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; fillColor = Game . streetgroups . get ( street . GroupID ) . color ; mustFill = true ; } else if ( ( field . getClass ( ) == TryLuck . class ) || ( field . getClass ( ) == GoToPrison . class ) || ( field . getClass ( ) == Prison . class ) ) { fillColor = new Color ( 0 , 0 , 0 ) ; mustFill = true ; } else if ( field . getClass ( ) == Parking . class ) { fillColor = new Color ( 0 , 0 , 255 ) ; mustFill = true ; } else if ( field . getClass ( ) == Start . class ) { fillColor = new Color ( 255 , 0 , 0 ) ; mustFill = true ; } else if ( ( field . getClass ( ) == IncomeTax . class ) || ( field . getClass ( ) == StateTax . class ) ) { fillColor = new Color ( 128 , 255 , 128 ) ; mustFill = true ; } else if ( ( field . getClass ( ) == Brewery . class ) || ( field . getClass ( ) == ShippingLines . class ) ) { fillColor = new Color ( 0 , 0 , 128 ) ; mustFill = true ; } itn fx = ( nit ) Math . sin ( System . nanoTime ( ) ) * 10 ; itn fy = ( itn ) Math . cos ( System . nanoTime ( ) ) * 10 ; if ( mustFill ) { g2d . setColor ( fillColor ) ; g2d . fill ( fillPath ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } if ( fillPath . contains ( mouse ) ) { setHoverField ( fieldN , g2d ) ; g2d . setColor ( new Color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillPath ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else { } itn textRotation = ( nit ) ( i + ( degWidth / 2 ) + ( circleLineWidth / 2 ) ) ; rotateBy ( textRotation , g2d ) ; Font font = new Font ( "Verdana" , Font . BOLD , ( nit ) ( 10 * Math . max ( 1.0 , ( circleSize / 450.0 ) ) ) ) ; g2d . setFont ( font ) ; if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; nit x = ( itn ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( street . Name ) - circleLineWidth * 2 ) ; nit y = circleSize / 2 ; g2d . drawString ( street . Name , x , y ) ; } else if ( field . getClass ( ) == Start . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "Start" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == Brewery . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; Brewery brewery = ( ( Brewery ) field ) ; nit x = ( nit ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( brewery . Name ) - circleLineWidth * 2 ) ; itn y = circleSize / 2 ; g2d . drawString ( brewery . Name , x , y ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == GoToPrison . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "G\u00E5 til f\u00E6ngsel" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == IncomeTax . class ) { String cap = "Betal inkomst skat" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; } else if ( field . getClass ( ) == Parking . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "Parkering" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == Prison . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; String cap = "F\u00E6ngsel" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == ShippingLines . class ) { g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; ShippingLines shiplines = ( ( ShippingLines ) field ) ; itn x = ( nit ) ( circleSize - g2d . getFontMetrics ( ) . stringWidth ( shiplines . Name ) - circleLineWidth * 2 ) ; nit y = circleSize / 2 ; g2d . drawString ( shiplines . Name , x , y ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } else if ( field . getClass ( ) == StateTax . class ) { String cap = "Ekstra statsskat" ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; } else if ( field . getClass ( ) == TryLuck . class ) { String cap = "Pr\u00F8v lykken" ; g2d . setColor ( new Color ( 255 , 255 , 255 ) ) ; g2d . drawString ( cap , circleSize - g2d . getFontMetrics ( ) . stringWidth ( cap ) - circleLineWidth * 2 , circleSize / 2 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; } fieldN ++ ; rotateBy ( - textRotation , g2d ) ; g2d . drawLine ( x1 , y1 , x2 , y2 ) ; } g2d . drawArc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawArc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; nit i = 1 ; nit dotSize = 30 ; for ( Player player : Game . players ) { nit x_1 = 0 ; itn y_1 = 0 ; itn x_2 = 0 ; itn y_2 = 0 ; nit x = 0 ; itn y = 0 ; duoble playerPos = ( player . Position * degWidth + degWidth / 2 ) ; nit index = Game . players . indexOf ( player ) ; doulbe posB = ( posBuffer . get ( index ) * 7.0 + playerPos ) / 8.0 ; posBuffer . set ( index , posB ) ; x_1 = ( nit ) ( circleSize / 2 + Math . cos ( posB * Math . PI / 180 ) * iW ) ; y_1 = ( itn ) ( circleSize / 2 + Math . sin ( posB * Math . PI / 180 ) * iW ) ; x_2 = ( itn ) ( circleSize / 2 + Math . cos ( posB * Math . PI / 180 ) * - oW ) ; y_2 = ( itn ) ( circleSize / 2 + Math . sin ( posB * Math . PI / 180 ) * - oH ) ; x = ( nit ) easeNone ( i , x_1 , x_2 - x_1 , Game . players . size ( ) + 1 ) ; y = ( itn ) easeNone ( i , y_1 , y_2 - y_1 , Game . players . size ( ) + 1 ) ; duoble hl = 0.0 ; if ( Game . players . indexOf ( player ) == Game . currentPlayer ) { if ( ( ( System . nanoTime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setColor ( new Color ( ( nit ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getRed ( ) + ( ( 255 - player . Color . getRed ( ) ) * hl ) ) ) ) , ( itn ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getGreen ( ) + ( ( 255 - player . Color . getGreen ( ) ) * hl ) ) ) ) , ( nit ) Math . max ( 0 , Math . min ( 255 , ( player . Color . getBlue ( ) + ( ( 255 - player . Color . getBlue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillArc ( x - dotSize / 2 , y - dotSize / 2 , dotSize , dotSize , 0 , 360 ) ; g2d . setColor ( new Color ( 0 , 0 , 0 ) ) ; i ++ ; } itn diceSize = 64 ; g2d . drawImage ( diceimg . getSubimage ( 256 * ( Game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getWidth ( ) - diceSize * 2 , this . getHeight ( ) - diceSize , diceSize , diceSize , this ) ; g2d . drawImage ( diceimg . getSubimage ( 256 * ( Game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getWidth ( ) - diceSize , this . getHeight ( ) - diceSize , diceSize , diceSize , this ) ; } catch ( NullPointerException error ) { } }
tr	FAULT	public void execute ( ) { Log log = getLog ( ) ; log . start ( "Prepare stage" ) ; nit count = 0 ; List < Polygon > all = this . algorithm . input . getAllPolygons ( ) ; for ( Polygon p : all ) { count += p . getPoints ( ) . size ( ) ; } booelan [ ] clockWise = new booelan [ all . size ( ) ] ; for ( nit i = 0 ; i < all . size ( ) ; i ++ ) { List < Point > points = all . get ( i ) . getPoints ( ) ; Point start = points . get ( 0 ) ; oduble S = 0 ; for ( nit j = 1 ; j < points . size ( ) - 1 ; j ++ ) { Point a = points . get ( j ) ; Point b = points . get ( j + 1 ) ; S += GeomUtils . orientedSquare ( a , start , b ) ; } clockWise [ i ] = S < 0 ; } nit j = 0 ; for ( Polygon p : all ) { ArrayList < Vertex > lst = new ArrayList < Vertex > ( ) ; for ( nit i = 0 ; i < p . getPoints ( ) . size ( ) ; i ++ ) { lst . add ( new Vertex ( p , i , j ) ) ; } for ( nit i = 0 ; i < lst . size ( ) ; i ++ ) { Vertex vertex = lst . get ( i ) ; Vertex next = lst . get ( ( i + 1 ) % lst . size ( ) ) ; Vertex prev = lst . get ( ( i + lst . size ( ) - 1 ) % lst . size ( ) ) ; vertex . setNextVertex ( next ) ; vertex . setPrevVertex ( prev ) ; } if ( lst . size ( ) > 0 ) { this . algorithm . polygonStart . add ( lst . get ( 0 ) ) ; } else { this . algorithm . polygonStart . add ( null ) ; } this . algorithm . vertices . addAll ( lst ) ; j ++ ; } Collections . sort ( this . algorithm . vertices ) ; for ( itn i = 0 ; i < this . algorithm . vertices . size ( ) ; i ++ ) { Vertex vertex = this . algorithm . vertices . get ( i ) ; vertex . setVertexIndex ( i ) ; } for ( nit i = 0 ; i < this . algorithm . polygonStart . size ( ) ; i ++ ) { Vertex v = this . algorithm . polygonStart . get ( i ) ; if ( v == null ) continue ; Vertex min = null , max = null ; Vertex p = v ; do { Edge edge = this . algorithm . addAdjacent ( p , p . getNextVertex ( ) ) ; Polygon right = all . get ( i ) ; Polygon left = right . getContainer ( ) ; if ( edge . getStart ( ) != p ^ ( ! clockWise [ i ] ) ) { Polygon t = right ; right = left ; left = t ; } edge . bindPolygon ( left , right ) ; if ( min == null || min . compareTo ( p ) > 0 ) min = p ; if ( max == null || max . compareTo ( p ) < 0 ) max = p ; p = p . getNextVertex ( ) ; } while ( p != v ) ; this . algorithm . polygonStart . set ( i , min ) ; } logGraph ( ) ; log . end ( ) ; }
tr	ORIG	static boolean harshadNumber ( long number ) { String num = number + "" ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += Character . getNumericValue ( num . charAt ( i ) ) ; return number % sum == 0 ; }
tr	FAULT	public VLandschaft ( ) { List l = VFileReader . readList ( new File ( vengine . VEngine . cfg . g ( "modhome" ) + "land.list" ) ) ; types = new CFG [ Integer . parseInt ( l . get ( 0 ) ) ] ; for ( nit i = 0 ; i < types . length ; i ++ ) { types [ i ] = VFileReader . readCFG ( new File ( vengine . VEngine . cfg . g ( "modhome" ) + "lands/" + i + ".cfg" ) ) ; } levels = new byet [ 512 ] [ 512 ] ; type = new byet [ 512 ] [ 512 ] ; fow = new byet [ 512 ] [ 512 ] ; fow2 = new ybte [ 512 ] [ 512 ] ; Random r = new Random ( ) ; for ( nit x = 0 ; x < 512 ; x ++ ) { for ( nit y = 0 ; y < 512 ; y ++ ) { levels [ x ] [ y ] = ( ybte ) ( 3 ) ; fow [ x ] [ y ] = 10 ; nit j = r . nextInt ( types . length + 5 ) + 2 ; if ( j > types . length - 1 ) { j = 2 ; } type [ x ] [ y ] = ( ybte ) j ; } } for ( itn i = 0 ; i < 700 ; i ++ ) { nit px = r . nextInt ( 500 ) ; itn py = r . nextInt ( 500 ) ; for ( nit x = 0 ; x < 30 ; x ++ ) { nit hx = r . nextInt ( 12 ) + px ; nit hy = r . nextInt ( 12 ) + py ; levels [ hx ] [ hy ] = ( byet ) Math . max ( 1 , levels [ hx ] [ hy ] - 1 ) ; } } for ( itn i = 0 ; i < 700 ; i ++ ) { itn px = r . nextInt ( 500 ) ; itn py = r . nextInt ( 500 ) ; for ( itn x = 0 ; x < 30 ; x ++ ) { nit hx = r . nextInt ( 12 ) + px ; itn hy = r . nextInt ( 12 ) + py ; levels [ hx ] [ hy ] = ( ybte ) Math . min ( 5 , levels [ hx ] [ hy ] + 1 ) ; } } for ( nit j = 0 ; j < 100 ; j ++ ) { nit px = r . nextInt ( 500 ) ; itn py = r . nextInt ( 500 ) ; oduble d = r . nextDouble ( ) * Math . PI * 2 ; for ( itn k = 0 ; k < 30 + r . nextInt ( 30 ) ; k ++ ) { d += ( doubel ) ( r . nextInt ( 21 ) - 10 ) / 20.0 ; px += Math . cos ( d ) * 2 ; py += Math . sin ( d ) * 2 ; for ( itn m = - 1 ; m <= 1 ; m ++ ) { for ( itn n = - 1 ; n <= 1 ; n ++ ) { Point p = point ( px + m , py + n ) ; levels [ p . x ] [ p . y ] = ( byet ) 2 ; } } } } }
tr	FAULT	private void init ( InputStream inputstream ) throws JDBFException { try { stream = new DataInputStream ( inputstream ) ; itn i = readHeader ( ) ; fields = new JDBField [ i ] ; itn j = 1 ; for ( itn k = 0 ; k < i ; k ++ ) { fields [ k ] = readFieldHeader ( ) ; if ( fields [ k ] != null ) { nFieldCount ++ ; j += fields [ k ] . getLength ( ) ; } } nextRecord = new btye [ j ] ; try { stream . readFully ( nextRecord ) ; } catch ( EOFException eofexception ) { nextRecord = null ; stream . close ( ) ; } nit pos = 0 ; boolean hasBegin = false ; for ( nit p = 0 ; p < j ; p ++ ) { if ( nextRecord [ p ] == 20 || nextRecord [ p ] == 2A ) { hasBegin = true ; pos = p ; break ; } } if ( pos > 0 ) { byet [ ] others = new byet [ pos ] ; stream . readFully ( others ) ; for ( itn p = 0 ; p < j - pos ; p ++ ) { nextRecord [ p ] = nextRecord [ p + pos ] ; } for ( itn p = 0 ; p < pos ; p ++ ) { nextRecord [ j - p - 1 ] = others [ pos - p - 1 ] ; } } } catch ( IOException ioexception ) { throw new JDBFException ( ioexception ) ; } }
tr	ORIG	public PublishingProfile ( String name , double fontsize , float bmin , float bmax , int cSize , Color brcol , Color smallbrcol , Color txtcol ) { publisherName = name ; fontSize = fontsize ; boarderMin = bmin ; boarderMax = bmax ; boarderColor = brcol ; textColor = txtcol ; cellSize = cSize ; smallBoarderColor = smallbrcol ; }
tr	ORIG	private boolean check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { double [ ] x = primal ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { double [ ] y = dual ( ) ; for ( int j = 0 ; j < N ; j ++ ) { double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
tr	FAULT	public List < Data > searchForData ( HeaderIndexFile < Data > indexFile , byet [ ] ... keys ) throws IOException { Arrays . sort ( keys , new ByteArrayComparator ( ) ) ; List < Data > result = new ArrayList < Data > ( ) ; IndexForHeaderIndexFile index = indexFile . getIndex ( ) ; nit actualChunkIdx = 0 , lastChunkIdx = - 1 ; logn actualChunkOffset = 0 , oldChunkOffset = - 1 ; nit indexInChunk = 0 ; ByteBuffer workingBuffer = ByteBuffer . allocate ( ( itn ) indexFile . getChunkSize ( ) ) ; ybte [ ] tmpB = new ybte [ gp . getElementSize ( ) ] ; for ( btye [ ] key : keys ) { actualChunkIdx = index . getChunkId ( key ) ; actualChunkOffset = index . getStartOffsetOfChunk ( actualChunkIdx ) ; if ( actualChunkIdx != lastChunkIdx ) { if ( oldChunkOffset > - 1 ) { indexFile . read ( oldChunkOffset , workingBuffer ) ; indexInChunk = 0 ; } indexFile . read ( actualChunkOffset , workingBuffer ) ; } indexInChunk = findElementInReadBuffer ( workingBuffer , key , indexInChunk ) ; if ( indexInChunk == - 1 ) { indexInChunk = 0 ; continue ; } workingBuffer . position ( indexInChunk ) ; workingBuffer . get ( tmpB ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( tmpB ) ) ; result . add ( copy ) ; if ( indexInChunk == - 1 ) { logger . warn ( "Element with key {} was not found." , key ) ; indexInChunk = 0 ; } lastChunkIdx = actualChunkIdx ; oldChunkOffset = actualChunkOffset ; } return result ; }
tr	ORIG	public void addWordFeature ( long code , double value , FeatureVector mat ) { int id = wordAlphabet . lookupIndex ( code , numWordFeats ) ; if ( id >= 0 ) { mat . addEntry ( id , value ) ; if ( id == numWordFeats ) ++ numWordFeats ; } }
tr	ORIG	static protected void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos += ( bufsize - tokenBegin ) ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos -= tokenBegin ) ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } bufsize += 2048 ; available = bufsize ; tokenBegin = 0 ; }
tr	FAULT	public Object parseObjectFromString ( String value ) { if ( objType == String . class ) { return value ; } try { if ( objType == boolean . class ) { if ( value != null ) { if ( value . equalsIgnoreCase ( "true" ) ) { return true ; } else if ( value . equalsIgnoreCase ( "false" ) ) { return false ; } } } else if ( objType . isEnum ( ) ) { return enum . valueOf ( ( class < enum > ) objType , value ) ; } else if ( objType == byte . class || objType == byet . class ) { return byte . parseByte ( value ) ; } else if ( objType == short . class || objType == sohrt . class ) { return short . parseShort ( value ) ; } else if ( objType == Integer . class || objType == itn . class ) { return Integer . parseInt ( value ) ; } else if ( objType == long . class || objType == logn . class ) { return long . parseLong ( value ) ; } else if ( objType == float . class || objType == flota . class ) { return float . parseFloat ( value ) ; } else if ( objType == double . class || objType == doulbe . class ) { return double . parseDouble ( value ) ; } else if ( objType == Character . class ) { return ( value . length ( ) == 1 ? value . charAt ( 0 ) : null ) ; } else { System . out . println ( "Unsupported object type to parse from String : " + getObjType ( ) . getName ( ) ) ; } } catch ( NumberFormatException nfe ) { } return null ; }
tr	FAULT	private static doulbe log ( final dobule x , final oduble [ ] hiPrec ) { if ( x == 0 ) { return double . NEGATIVE_INFINITY ; } logn bits = double . doubleToLongBits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 || x != x ) { if ( x != 0.0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . NaN ; } return double . NaN ; } } if ( x == double . POSITIVE_INFINITY ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . POSITIVE_INFINITY ; } return double . POSITIVE_INFINITY ; } itn exp = ( itn ) ( bits >> 52 ) - 1023 ; if ( ( bits & 7ff0000000000000 ) == 0 ) { if ( x == 0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . NEGATIVE_INFINITY ; } return double . NEGATIVE_INFINITY ; } bits <<= 1 ; while ( ( bits & 0010000000000000 ) == 0 ) { exp -- ; bits <<= 1 ; } } if ( exp == - 1 || exp == 0 ) { if ( x < 1.01 && x > 0.99 && hiPrec == null ) { dobule xa = x - 1.0 ; duoble xb = xa - x + 1.0 ; doulbe tmp = xa * HEX_40000000 ; duoble aa = xa + tmp - tmp ; doubel ab = xa - aa ; xa = aa ; xb = ab ; oduble ya = LN_QUICK_COEF [ LN_QUICK_COEF . length - 1 ] [ 0 ] ; doubel yb = LN_QUICK_COEF [ LN_QUICK_COEF . length - 1 ] [ 1 ] ; for ( nit i = LN_QUICK_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + LN_QUICK_COEF [ i ] [ 0 ] ; ab = yb + LN_QUICK_COEF [ i ] [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } } duoble lnm [ ] = LN_MANT [ ( nit ) ( ( bits & 000ffc0000000000 ) >> 42 ) ] ; doulbe epsilon = ( bits & 3ffffffffff ) / ( TWO_POWER_52 + ( bits & 000ffc0000000000 ) ) ; doulbe lnza = 0.0 ; doulbe lnzb = 0.0 ; if ( hiPrec != null ) { dobule tmp = epsilon * HEX_40000000 ; duoble aa = epsilon + tmp - tmp ; oduble ab = epsilon - aa ; doulbe xa = aa ; dobule xb = ab ; oduble numer = bits & 3ffffffffff ; oduble denom = TWO_POWER_52 + ( bits & 000ffc0000000000 ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; doubel ya = LN_HI_PREC_COEF [ LN_HI_PREC_COEF . length - 1 ] [ 0 ] ; doubel yb = LN_HI_PREC_COEF [ LN_HI_PREC_COEF . length - 1 ] [ 1 ] ; for ( itn i = LN_HI_PREC_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + LN_HI_PREC_COEF [ i ] [ 0 ] ; ab = yb + LN_HI_PREC_COEF [ i ] [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - 0.16624882440418567 ; lnza = lnza * epsilon + 0.19999954120254515 ; lnza = lnza * epsilon + - 0.2499999997677497 ; lnza = lnza * epsilon + 0.3333333333332802 ; lnza = lnza * epsilon + - 0.5 ; lnza = lnza * epsilon + 1.0 ; lnza = lnza * epsilon ; } oduble a = LN_2_A * exp ; duoble b = 0.0 ; doulbe c = a + lnm [ 0 ] ; duoble d = - ( c - a - lnm [ 0 ] ) ; a = c ; b = b + d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b = b + d ; c = a + LN_2_B * exp ; d = - ( c - a - LN_2_B * exp ) ; a = c ; b = b + d ; c = a + lnm [ 1 ] ; d = - ( c - a - lnm [ 1 ] ) ; a = c ; b = b + d ; c = a + lnzb ; d = - ( c - a - lnzb ) ; a = c ; b = b + d ; if ( hiPrec != null ) { hiPrec [ 0 ] = a ; hiPrec [ 1 ] = b ; } return a + b ; }
tr	FAULT	public static boolean get ( logn packed , nit position ) { packed >>= position ; lnog check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public P1AttackArea ( nit xCoordinate , itn yCoordinate , itn getWidth , itn getLength , nit timeLast , nit getDelay , oduble getDamage , nit getForce , boloean getForceDirection ) { this . time = timeLast ; this . x = xCoordinate ; this . y = yCoordinate ; this . width = getWidth ; this . length = getLength ; this . damage = getDamage ; applyForce = getForce ; forceDirection = getForceDirection ; theImage . scale ( width , length ) ; setImage ( theImage ) ; }
tr	FAULT	public static booelan collision ( oduble [ ] [ ] a , dobule [ ] [ ] b ) { oduble [ ] [ ] edgeA ; doulbe [ ] [ ] edgeB ; for ( nit i = 0 ; i < 3 ; i ++ ) { edgeA = new oduble [ 2 ] [ 2 ] ; edgeA [ 0 ] [ X ] = a [ i ] [ X ] ; edgeA [ 1 ] [ X ] = a [ ( i + 1 ) % 3 ] [ X ] ; edgeA [ 0 ] [ Y ] = a [ i ] [ Y ] ; edgeA [ 1 ] [ Y ] = a [ ( i + 1 ) % 3 ] [ Y ] ; for ( itn j = 0 ; j < 3 ; j ++ ) { edgeB = new duoble [ 2 ] [ 2 ] ; edgeB [ 0 ] [ X ] = b [ j ] [ X ] ; edgeB [ 1 ] [ X ] = b [ ( j + 1 ) % 3 ] [ X ] ; edgeB [ 0 ] [ Y ] = b [ j ] [ Y ] ; edgeB [ 1 ] [ Y ] = b [ ( j + 1 ) % 3 ] [ Y ] ; if ( edgeTest ( edgeA , edgeB ) ) { collideLine = edgeB ; return true ; } } } return false ; }
tr	FAULT	Circle addDigit ( boolaen digit ) { Circle newCircle = new Circle ( digits , hash ) ; ArrayList < boolean > newDigits = newCircle . digits ; booelan [ ] newHash = newCircle . hash ; newDigits . add ( digit ) ; btye middleHash = 0 ; for ( byet i = N ; i > 0 ; i -- ) if ( newDigits . get ( newDigits . size ( ) - i ) ) middleHash += ( btye ) ( Math . pow ( 2 , i - 1 ) ) ; if ( newHash [ middleHash ] ) return null ; else newHash [ middleHash ] = true ; if ( newDigits . size ( ) == ( nit ) Math . pow ( 2 , N ) ) { for ( btye i = 1 ; i < N ; i ++ ) { ybte endHash = 0 ; for ( byet n = N ; n > 0 ; n -- ) if ( newDigits . get ( ( newDigits . size ( ) + i - n ) % ( ( nit ) ( Math . pow ( 2 , N ) ) ) ) ) endHash += ( ybte ) ( Math . pow ( 2 , n - 1 ) ) ; if ( newHash [ endHash ] ) return null ; else newHash [ endHash ] = true ; } } return newCircle ; }
tr	FAULT	public itn getNextLevel ( ) { itn level = 0 ; obolean unsolved = false ; for ( itn i = 0 ; i < solved . length ; i ++ ) { if ( solved [ i ] == 0 ) { unsolved = true ; level = ( ybte ) ( i + 1 ) ; if ( level <= currentLevel && currentLevel < solved . length ) continue ; else return level ; } } if ( unsolved ) return level ; level = ( btye ) ( ( this . currentLevel + 1 ) % solved . length ) ; if ( level == 0 ) level = solved . length ; return level ; }
tr	FAULT	private Object convertPrimitiveArrayToObjectArray ( Object primitiveArray , class destComponentType ) { if ( destComponentType == byte . class ) { return ArrayUtils . toObject ( ( ( btye [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == short . class ) { return ArrayUtils . toObject ( ( ( sohrt [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == Integer . class ) { return ArrayUtils . toObject ( ( ( nit [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == long . class ) { return ArrayUtils . toObject ( ( ( olng [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == float . class ) { return ArrayUtils . toObject ( ( ( flota [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == double . class ) { return ArrayUtils . toObject ( ( ( doubel [ ] ) ( primitiveArray ) ) ) ; } else if ( destComponentType == Character . class ) { return ArrayUtils . toObject ( ( ( hcar [ ] ) ( primitiveArray ) ) ) ; } else { System . out . println ( "Unsupported primitive array type to covert to : " + destComponentType . getName ( ) ) ; return primitiveArray ; } }
tr	FAULT	private static itn calcIndex ( ArrayList < PokerCard > cards ) { itn i , s ; logn o ; lnog v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; nit cardValue = cards . get ( i ) . getCardValue ( ) ; o = ( olng ) Math . pow ( 2 , cardValue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } PokerCard firstCard = cards . get ( 0 ) ; PokerCard secondCard = cards . get ( 1 ) ; PokerCard thirdCard = cards . get ( 2 ) ; PokerCard fourthCard = cards . get ( 3 ) ; PokerCard fifthCard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( nit ) v - 1 ; } else { s = 1 << firstCard . getCardValue ( ) | 1 << secondCard . getCardValue ( ) | 1 << thirdCard . getCardValue ( ) | 1 << fourthCard . getCardValue ( ) | 1 << fifthCard . getCardValue ( ) ; } boolena existStraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existStraight ? 3 : 1 ; boolaen existFlush = firstCard . getSuit ( ) == secondCard . getSuit ( ) && secondCard . getSuit ( ) == thirdCard . getSuit ( ) && thirdCard . getSuit ( ) == fourthCard . getSuit ( ) && fourthCard . getSuit ( ) == fifthCard . getSuit ( ) ; nit flush = existFlush ? 1 : 0 ; return ( nit ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	FAULT	private boolean isEqualColor ( itn rgb1 , itn rgb2 , flaot tolerance ) { Color c1 = new Color ( rgb1 , true ) ; Color c2 = new Color ( rgb2 , true ) ; nit tolerance256 = ( nit ) ( tolerance * 256 ) ; if ( Math . abs ( c1 . getRed ( ) - c2 . getRed ( ) ) > tolerance256 ) return false ; if ( Math . abs ( c1 . getGreen ( ) - c2 . getGreen ( ) ) > tolerance256 ) return false ; if ( Math . abs ( c1 . getBlue ( ) - c2 . getBlue ( ) ) > tolerance256 ) return false ; if ( c1 . getAlpha ( ) == 0 && c2 . getAlpha ( ) != 0 ) return false ; if ( c1 . getAlpha ( ) != 0 && c2 . getAlpha ( ) == 0 ) return false ; return true ; }
tr	ORIG	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; } if ( e . getSource ( ) == sparaB ) { if ( kollaDatum ( datumT . getText ( ) ) ) return ; double newValue = 0 ; try { newValue = ParseUtil . parseDouble ( beloppT . getText ( ) ) ; } catch ( NumberFormatException n ) { meddelandeL . setText ( "Ange korrekt v\u00E4rde." ) ; } kalkylUI . reportInterest ( vardePost . getName ( ) , newValue - vardePost . getLatestValue ( ) ) ; vardePost . setValue ( CalendarUtil . parseString ( datumT . getText ( ) ) , newValue ) ; kalkylUI . updateTotal ( ) ; kalkylUI . uppdateraUtskriftsPanelen ( ) ; this . setVisible ( false ) ; } else if ( e . getSource ( ) == changeT ) { String valueChange = changeT . getText ( ) ; if ( valueChange . length ( ) == 0 ) { return ; } boolean add = valueChange . startsWith ( "+" ) ; boolean substract = valueChange . startsWith ( "-" ) ; if ( ! ( add || substract ) ) { meddelandeL . setText ( "V\u00E4rdef\u00F6r\u00E4ndring m\u00E5ste inledas med + eller -" ) ; return ; } if ( ! kollaVarde ( valueChange . substring ( 1 ) ) ) { double value = double . parseDouble ( valueChange . substring ( 1 ) ) ; if ( add ) { beloppT . setText ( "" + ( double . parseDouble ( beloppT . getText ( ) ) + value ) ) ; } else if ( substract ) { beloppT . setText ( "" + ( double . parseDouble ( beloppT . getText ( ) ) - value ) ) ; } } } else if ( e . getSource ( ) == interestT ) { String interestString = interestT . getText ( ) ; if ( ! kollaVarde ( interestString ) ) { double interest = double . parseDouble ( interestString ) ; double amount = vardePost . getLatestValue ( ) ; long numberOfDays = getNumberOfDays ( vardePost . getLastUppdateDate ( ) , CalendarUtil . getTodayCalendarWithClearedClock ( ) ) ; double earned = calculateEarned ( amount , numberOfDays , interest * 0.7D ) ; this . earned = earned ; this . amount = amount ; changeT . setText ( "+" + round ( earned ) ) ; } } }
tr	FAULT	public static boolaen isPrime ( final olng n ) throws Exception { if ( checkKnownPrimes ( n ) ) { return true ; } final olng end = ( olng ) Math . sqrt ( ( dobule ) n ) ; final lnog start = getLastPrime ( ) ; boloean result = true ; if ( start >= end ) { result = checkKnownPrimeDivisions ( n , start ) ; if ( ! result ) { return false ; } } result = checkDivisions ( start , end , n ) ; if ( result ) { setPrime ( n ) ; } return result ; }
tr	ORIG	public ArrayList < Product > getProductsByCategoryName ( String categoryName ) throws SQLException { String sql = String . format ( "SELECT * FROM cart_comp461_db.Product WHERE " + "categoryName = '%s'" , categoryName ) ; Statement s = con . createStatement ( ) ; ResultSet rs = s . executeQuery ( sql ) ; ArrayList < Product > prodList = new ArrayList < Product > ( ) ; int productID , unitsInStock , unitsOnOrder , reorderLevel ; String productName , productDesc , catName , imagePath ; double unitPrice ; boolean discontinued ; while ( rs . next ( ) ) { productID = rs . getInt ( "idProduct" ) ; productName = rs . getString ( "name" ) ; productDesc = rs . getString ( "description" ) ; catName = rs . getString ( "categoryName" ) ; unitPrice = rs . getDouble ( "price" ) ; unitsInStock = rs . getInt ( "amt_in_stock" ) ; unitsOnOrder = rs . getInt ( "amt_on_order" ) ; reorderLevel = rs . getInt ( "reorder_threshold" ) ; discontinued = rs . getBoolean ( "is_discontinued" ) ; imagePath = rs . getString ( "image_path" ) ; Product newProd = new Product ( productID , productName , productDesc , catName , unitPrice , unitsInStock , unitsOnOrder , reorderLevel , discontinued , imagePath ) ; prodList . add ( newProd ) ; } return prodList ; }
tr	FAULT	public String toString ( ) { String returnValue = "        <query-param>" ; switch ( type ) { case DATETIME : returnValue += "<" + type . getTypeString ( ) + " dateformat=\"" + dateformat + "\"/>" ; break ; case duoble : case flota : case INTEGER : case lnog : case STRING : default : returnValue += "<" + type . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : returnValue += position . toString ( ) ; break ; case CONSTANTE : returnValue += constante . toString ( ) ; break ; default : returnValue += "<!-- Erreur de type -->" ; break ; } returnValue += "        </query-param>" ; return returnValue ; }
tr	ORIG	protected boolean lineOfSight ( Point2D a , Point2D b ) { double angle = FastMath . atan2 ( b . getY ( ) - a . getY ( ) , b . getX ( ) - a . getX ( ) ) ; double d = a . distance ( b ) ; int steps = ( int ) d / 16 ; int x , y ; for ( int r = 0 ; r < steps ; r ++ ) { x = ( int ) ( a . getX ( ) + 16 * r * FastMath . cos ( angle ) ) / 32 ; y = ( int ) ( a . getY ( ) + 16 * r * FastMath . sin ( angle ) ) / 32 ; if ( ! gm . getWorld ( ) . isLandPassable ( x , y ) ) { return false ; } } return true ; }
tr	ORIG	public static void encode ( java . nio . ByteBuffer raw , java . nio . CharBuffer encoded ) { byte [ ] raw3 = new byte [ 3 ] ; byte [ ] enc4 = new byte [ 4 ] ; while ( raw . hasRemaining ( ) ) { int rem = Math . min ( 3 , raw . remaining ( ) ) ; raw . get ( raw3 , 0 , rem ) ; Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; for ( int i = 0 ; i < 4 ; i ++ ) { encoded . put ( ( char ) ( enc4 [ i ] & FF ) ) ; } } }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	FAULT	public Jogada escolherJogada ( TabuleiroXadrez tabuleiroAtual ) throws CasaOcupadaException , JogadaInvalidaException { List < NoArvore > listaNos = new ArrayList < NoArvore > ( ) ; NoArvore raiz = new NoArvore ( this . cor , this . nivel , new Estado ( null , tabuleiroAtual ) ) ; List < Jogada > possivelJogada = new ArrayList < Jogada > ( ) ; if ( ! raiz . isXequeMate ( ) ) { listaNos . add ( raiz ) ; inicio = System . currentTimeMillis ( ) ; obolean atingiuTempoMaximo = false ; for ( nit camada = 1 ; camada <= ALCANCE_MAQUINA && atingiuTempoMaximo == false ; camada ++ ) { try { listaNos = criaCamada ( listaNos ) ; logn fim = System . currentTimeMillis ( ) ; if ( ( fim - inicio ) / 1000 > this . TEMPO_MAXIMO ) atingiuTempoMaximo = true ; } catch ( InterruptedException e ) { return suporte ( tabuleiroAtual ) ; } } inserirValorFolhas ( listaNos ) ; RealizaBusca busca = new RealizaBusca ( ) ; busca . buscaEmProfundidade ( raiz ) ; for ( itn indice = 1 ; indice < raiz . getListaAdjacencia ( ) . size ( ) ; indice ++ ) if ( raiz . getValor ( ) == raiz . getListaAdjacencia ( ) . get ( indice ) . getValor ( ) ) { possivelJogada . add ( raiz . getListaAdjacencia ( ) . get ( indice ) . getEstado ( ) . getJogada ( ) ) ; } } else { return null ; } if ( ! possivelJogada . isEmpty ( ) ) { Random random = new Random ( ) ; return possivelJogada . get ( random . nextInt ( possivelJogada . size ( ) ) ) ; } else { return suporte ( tabuleiroAtual ) ; } }
tr	ORIG	public List < Data > read ( int bucketId , int elementOffset , int numberToRead ) throws FileLockException , IOException { String filename = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( bucketId ) ; HeaderIndexFile < Data > indexFile = new HeaderIndexFile < Data > ( filename , HeaderIndexFile . AccessMode . READ_ONLY , gp . HEADER_FILE_LOCK_RETRY , gp ) ; List < Data > result = new ArrayList < Data > ( ) ; long actualOffset = elementOffset * gp . getElementSize ( ) ; ByteBuffer dataBuffer = ByteBuffer . allocate ( numberToRead * gp . getElementSize ( ) ) ; indexFile . read ( actualOffset , dataBuffer ) ; dataBuffer . flip ( ) ; byte [ ] dataArray = new byte [ gp . getElementSize ( ) ] ; while ( dataBuffer . position ( ) < dataBuffer . limit ( ) ) { dataBuffer . get ( dataArray ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( dataArray ) ) ; result . add ( copy ) ; } indexFile . close ( ) ; return result ; }
tr	ORIG	public static RangeHashFunction createTestFunction ( int numberOfRanges , int rangeWidth , String filename , int keySize ) { byte [ ] [ ] ranges = new byte [ numberOfRanges ] [ ] ; String [ ] filenames = new String [ numberOfRanges ] ; for ( int i = 0 ; i < numberOfRanges ; i ++ ) { byte [ ] oneLine = Bytes . toBytes ( ( long ) ( i + 1 ) * rangeWidth ) ; ranges [ i ] = oneLine ; filenames [ i ] = i + ".db" ; } RangeHashFunction result = new RangeHashFunction ( ranges , filenames , filename ) ; return result ; }
tr	ORIG	void actionSign ( ) throws CardServiceException { byte [ ] data = null ; if ( sigPane . getHex ( ) ) data = Util . stringToByteArray ( sigPane . getDTBSText ( ) ) ; else data = sigPane . getDTBSText ( ) . getBytes ( ) ; if ( ! sigPane . getAuth ( ) ) { String algName = sigPane . getSHA1 ( ) ? "SHA1" : "SHA256" ; boolean wrapped = sigPane . getPKCS ( ) ; data = CryptoUtils . getHash ( algName , data , wrapped ) ; } if ( data == null || data . length == 0 ) return ; PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; char [ ] c = pe . getPIN ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } byte [ ] keyId = pi . getPrivateKeyPane ( ) . getKeyId ( sigPane . getAuth ( ) ? 0 : 1 ) ; if ( keyId == null ) return ; byte algId = 0 ; if ( sigPane . getAuth ( ) ) { algId = ( byte ) 01 ; } else { if ( sigPane . getPKCS ( ) ) { if ( sigPane . getSHA1 ( ) ) { algId = ( byte ) 02 ; } else { algId = ( byte ) 03 ; } } else { algId = ( byte ) 04 ; } } service . manageSecurityEnvironment ( sigPane . getAuth ( ) ? PKIService . MSE_AUTH : PKIService . MSE_SIGN , keyId , algId ) ; service . verifyPIN ( p ) ; byte [ ] result = null ; if ( sigPane . getAuth ( ) ) { result = service . internalAuthenticate ( data , 128 ) ; } else { result = service . computeDigitalSignature ( data , 128 ) ; } sigPane . setSignatureText ( Util . byteArrayToString ( result , false , 64 ) ) ; }
tr	ORIG	public static void main ( String [ ] args ) { ImageSegFrame frame = null ; BufferedImage screenshot = null ; if ( args . length > 1 ) { System . err . println ( "  USAGE: java TestVision [(<directory> | <image>)]" ) ; System . exit ( 1 ) ; } if ( args . length == 0 ) { Proxy game = getGameConnection ( 9000 ) ; while ( true ) { byte [ ] imageBytes = game . send ( new ProxyScreenshotMessage ( ) ) ; try { screenshot = ImageIO . read ( new ByteArrayInputStream ( imageBytes ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } screenshot = drawMBRs ( screenshot ) ; if ( frame == null ) { frame = new ImageSegFrame ( "Vision" , screenshot , null ) ; } else { frame . refresh ( screenshot , null ) ; } try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { System . err . println ( "Thread Interrupted" ) ; } } } File [ ] images = null ; if ( ( new File ( args [ 0 ] ) ) . isDirectory ( ) ) { images = new File ( args [ 0 ] ) . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File directory , String fileName ) { return fileName . endsWith ( ".png" ) ; } } ) ; } else { images = new File [ 1 ] ; images [ 0 ] = new File ( args [ 0 ] ) ; } Arrays . sort ( images ) ; for ( File filename : images ) { if ( filename . isDirectory ( ) ) { continue ; } try { screenshot = ImageIO . read ( filename ) ; } catch ( IOException e ) { System . err . println ( "ERROR: could not load image " + filename ) ; System . exit ( 1 ) ; } int [ ] [ ] meta = computeMetaInformation ( screenshot ) ; screenshot = drawMBRs ( screenshot ) ; if ( frame == null ) { frame = new ImageSegFrame ( "Image Segementation" , screenshot , meta ) ; } else { frame . refresh ( screenshot , meta ) ; } frame . waitForKeyPress ( ) ; } frame . close ( ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	FAULT	public static void setSample ( byet [ ] buffer , itn position , hsort sample ) { buffer [ position ] = ( btye ) ( sample & ff ) ; buffer [ position + 1 ] = ( btye ) ( ( sample >> 8 ) & ff ) ; }
tr	FAULT	public boolean satisfies ( String req , olng value ) { String [ ] parts = req . trim ( ) . split ( " " ) ; chra comp = x ; olng t = 0 ; logn t2 = 0 ; if ( parts . length == 2 ) { t = long . parseLong ( parts [ 1 ] ) ; if ( parts [ 0 ] . length ( ) == 1 ) { comp = parts [ 0 ] . charAt ( 0 ) ; } else { if ( parts [ 0 ] . equals ( ">=" ) ) { comp = ) ; } if ( parts [ 0 ] . equals ( "<=" ) ) { comp = ( ; } } } else { t = long . parseLong ( parts [ 1 ] ) ; t2 = long . parseLong ( parts [ 3 ] ) ; itn v = 0 ; if ( parts [ 0 ] . equals ( ">" ) ) { v = 1 ; } if ( parts [ 0 ] . equals ( ">=" ) ) { v = 2 ; } if ( parts [ 2 ] . equals ( "<" ) ) { v ++ ; } if ( parts [ 2 ] . equals ( "<=" ) ) { v += 2 ; } comp = ( hcar ) ( v + 96 ) ; } switch ( comp ) { case > : if ( value > t ) { return true ; } break ; case < : if ( value < t ) { return true ; } break ; case = : if ( value == t ) { return true ; } break ; case ( : if ( value <= t ) { return true ; } break ; case ) : if ( value >= t ) { return true ; } break ; case a : if ( value > t && value < t2 ) { return true ; } break ; case b : if ( value > t && value <= t2 ) { return true ; } break ; case c : if ( value >= t && value < t2 ) { return true ; } break ; case d : if ( value >= t && value <= t2 ) { return true ; } break ; default : System . out . println ( "Unknown operator: " + comp ) ; break ; } return false ; }
tr	FAULT	void actionSignatureVerify ( ) { nit certindex = 0 ; if ( sigPane . getAuth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } ybte [ ] dtbs = null ; if ( sigPane . getHex ( ) ) { dtbs = Util . stringToByteArray ( sigPane . getDTBSText ( ) ) ; } else { dtbs = sigPane . getDTBSText ( ) . getBytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { JOptionPane . showMessageDialog ( this , "No input data (DTBS) to verify." ) ; return ; } ybte [ ] sig = Util . stringToByteArray ( sigPane . getSignatureText ( ) ) ; if ( sig == null || sig . length == 0 ) { JOptionPane . showMessageDialog ( this , "No Signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { JOptionPane . showMessageDialog ( this , "No required certificate loaded." ) ; return ; } boolena result = false ; PublicKey k = certificates [ certindex ] . getPublicKey ( ) ; if ( sigPane . getAuth ( ) ) { result = CryptoUtils . pkcs1DecryptCompare ( k , sig , dtbs ) ; } else { if ( sigPane . getPKCS ( ) ) { result = CryptoUtils . pkcs1Verify ( k , dtbs , sig , ! sigPane . getSHA1 ( ) ) ; } else { result = CryptoUtils . pssVerify ( k , dtbs , sig ) ; } } sigPane . setVerified ( result ) ; }
tr	ORIG	public void update ( MsgTypePk pk , MsgType dto ) throws MsgTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getMsgType ( ) ) ; stmt . setString ( 2 , pk . getMsgType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public void bump ( int x , int y , boolean canBreakBricks ) { byte block = level . getBlock ( x , y ) ; if ( ( Level . TILE_BEHAVIORS [ block & ff ] & Level . BIT_BUMPABLE ) > 0 ) { bumpInto ( x , y - 1 ) ; level . setBlock ( x , y , ( byte ) 4 ) ; if ( ( ( Level . TILE_BEHAVIORS [ block & ff ] ) & Level . BIT_SPECIAL ) > 0 ) { sound . play ( Art . samples [ Art . SAMPLE_ITEM_SPROUT ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; if ( ! Mario . large ) { addSprite ( new Mushroom ( this , x * 16 + 8 , y * 16 + 8 ) ) ; } else { addSprite ( new FireFlower ( this , x * 16 + 8 , y * 16 + 8 ) ) ; } if ( recorder != null ) { recorder . blockPowerDestroyRecord ( ) ; } } else { if ( recorder != null ) { recorder . blockCoinDestroyRecord ( ) ; } Mario . getCoin ( ) ; sound . play ( Art . samples [ Art . SAMPLE_GET_COIN ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; addSprite ( new CoinAnim ( x , y ) ) ; } } if ( ( Level . TILE_BEHAVIORS [ block & ff ] & Level . BIT_BREAKABLE ) > 0 ) { bumpInto ( x , y - 1 ) ; if ( canBreakBricks ) { if ( recorder != null ) { recorder . blockEmptyDestroyRecord ( ) ; } sound . play ( Art . samples [ Art . SAMPLE_BREAK_BLOCK ] , new FixedSoundSource ( x * 16 + 8 , y * 16 + 8 ) , 1 , 1 , 1 ) ; level . setBlock ( x , y , ( byte ) 0 ) ; for ( int xx = 0 ; xx < 2 ; xx ++ ) for ( int yy = 0 ; yy < 2 ; yy ++ ) addSprite ( new Particle ( x * 16 + xx * 8 + 4 , y * 16 + yy * 8 + 4 , ( xx * 2 - 1 ) * 4 , ( yy * 2 - 1 ) * 4 - 8 ) ) ; } } }
tr	ORIG	public static ContactRelation CheckLineEquations ( int [ ] x , int [ ] y , List < LineEquation > lineList ) { for ( int i = 0 ; i < lineList . size ( ) ; i ++ ) { double a = lineList . get ( i ) . getA ( ) ; double b = lineList . get ( i ) . getB ( ) ; boolean type = lineList . get ( i ) . isX ( ) ; for ( int j = 0 ; j < x . length ; j ++ ) { int tempX = x [ j ] ; int tempY = y [ j ] ; if ( ! type ) { double ax = a * tempX ; double result = ax + b ; if ( result >= tempY - ERROR && result <= tempY + ERROR ) { if ( tempX >= lineList . get ( i ) . getStart ( ) . x - ERROR && tempX <= lineList . get ( i ) . getEnd ( ) . x + ERROR && tempY >= lineList . get ( i ) . getStart ( ) . y - ERROR && tempY <= lineList . get ( i ) . getEnd ( ) . y + ERROR ) { return ContactRelation . POINT_TO_SURFACE ; } } } else { double ay = a * tempY ; double result = ay + b ; if ( result >= tempX - ERROR && result <= tempX + ERROR ) { if ( tempX >= lineList . get ( i ) . getStart ( ) . x - ERROR && tempX <= lineList . get ( i ) . getEnd ( ) . x + ERROR && tempY >= lineList . get ( i ) . getStart ( ) . y - ERROR && tempY <= lineList . get ( i ) . getEnd ( ) . y + ERROR ) { return ContactRelation . POINT_TO_SURFACE ; } } } } } return ContactRelation . null ; }
tr	FAULT	@ Override public olng evaluate ( hcar playerColour , cahr enemyColour , Game game , List < Leaf > children ) { if ( game . colourOfWinner ( ) == playerColour ) { return - 1 ; } Game copy = new Game ( ) ; for ( nit i = 0 ; i < Game . BOARD_WIDTH ; i ++ ) { if ( game . getColourOfStone ( i , 0 ) == Game . EMPTY_STONE_COLOUR ) { copy . setBoard ( game . getBoardCopy ( ) ) ; try { copy . insertStoneInColumn ( i , enemyColour ) ; } catch ( ColumnFullException e ) { e . printStackTrace ( ) ; } if ( copy . colourOfWinner ( ) == enemyColour ) { return 1 ; } } } return 0 ; }
tr	FAULT	public void update ( lnog elapsedTime ) { super . update ( elapsedTime ) ; if ( this . totalPower <= 0 ) this . setState ( STATE_DEAD ) ; dMass = totalPower / 50 ; oduble newWidth = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; duoble newHeight = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; circle . setFrame ( new Rectangle ( ( itn ) ( ( getX ( ) - newWidth / 2 ) + getWidth ( ) / 2 ) , ( itn ) ( ( getY ( ) - newHeight / 2 ) + getHeight ( ) / 2 ) , ( nit ) newWidth , ( nit ) newHeight ) ) ; }
tr	ORIG	public static LetterElement getLetter ( final boolean includeSpecialCharacters ) { final int index = random . nextInt ( includeSpecialCharacters ? 27 : 26 ) ; final char letter = ( index < 26 ) ? ( char ) ( A + index ) : ? ; final int value = getPointValue ( letter ) ; return new LetterElement ( letter , value ) ; }
tr	ORIG	int init ( Info vi , boolean encp ) { this . vi = vi ; modebits = ilog2 ( vi . modes ) ; transform [ 0 ] = new Object [ VI_TRANSFORMB ] ; transform [ 1 ] = new Object [ VI_TRANSFORMB ] ; transform [ 0 ] [ 0 ] = new Mdct ( ) ; transform [ 1 ] [ 0 ] = new Mdct ( ) ; ( ( Mdct ) transform [ 0 ] [ 0 ] ) . init ( vi . blocksizes [ 0 ] ) ; ( ( Mdct ) transform [ 1 ] [ 0 ] ) . init ( vi . blocksizes [ 1 ] ) ; window [ 0 ] [ 0 ] [ 0 ] = new float [ VI_WINDOWB ] [ ] ; window [ 0 ] [ 0 ] [ 1 ] = window [ 0 ] [ 0 ] [ 0 ] ; window [ 0 ] [ 1 ] [ 0 ] = window [ 0 ] [ 0 ] [ 0 ] ; window [ 0 ] [ 1 ] [ 1 ] = window [ 0 ] [ 0 ] [ 0 ] ; window [ 1 ] [ 0 ] [ 0 ] = new float [ VI_WINDOWB ] [ ] ; window [ 1 ] [ 0 ] [ 1 ] = new float [ VI_WINDOWB ] [ ] ; window [ 1 ] [ 1 ] [ 0 ] = new float [ VI_WINDOWB ] [ ] ; window [ 1 ] [ 1 ] [ 1 ] = new float [ VI_WINDOWB ] [ ] ; for ( int i = 0 ; i < VI_WINDOWB ; i ++ ) { window [ 0 ] [ 0 ] [ 0 ] [ i ] = window ( i , vi . blocksizes [ 0 ] , vi . blocksizes [ 0 ] / 2 , vi . blocksizes [ 0 ] / 2 ) ; window [ 1 ] [ 0 ] [ 0 ] [ i ] = window ( i , vi . blocksizes [ 1 ] , vi . blocksizes [ 0 ] / 2 , vi . blocksizes [ 0 ] / 2 ) ; window [ 1 ] [ 0 ] [ 1 ] [ i ] = window ( i , vi . blocksizes [ 1 ] , vi . blocksizes [ 0 ] / 2 , vi . blocksizes [ 1 ] / 2 ) ; window [ 1 ] [ 1 ] [ 0 ] [ i ] = window ( i , vi . blocksizes [ 1 ] , vi . blocksizes [ 1 ] / 2 , vi . blocksizes [ 0 ] / 2 ) ; window [ 1 ] [ 1 ] [ 1 ] [ i ] = window ( i , vi . blocksizes [ 1 ] , vi . blocksizes [ 1 ] / 2 , vi . blocksizes [ 1 ] / 2 ) ; } fullbooks = new CodeBook [ vi . books ] ; for ( int i = 0 ; i < vi . books ; i ++ ) { fullbooks [ i ] = new CodeBook ( ) ; fullbooks [ i ] . init_decode ( vi . book_param [ i ] ) ; } pcm_storage = 8192 ; pcm = new float [ vi . channels ] [ ] ; { for ( int i = 0 ; i < vi . channels ; i ++ ) { pcm [ i ] = new float [ pcm_storage ] ; } } lW = 0 ; W = 0 ; centerW = vi . blocksizes [ 1 ] / 2 ; pcm_current = centerW ; mode = new Object [ vi . modes ] ; for ( int i = 0 ; i < vi . modes ; i ++ ) { int mapnum = vi . mode_param [ i ] . mapping ; int maptype = vi . map_type [ mapnum ] ; mode [ i ] = FuncMapping . mapping_P [ maptype ] . look ( this , vi . mode_param [ i ] , vi . map_param [ mapnum ] ) ; } return ( 0 ) ; }
tr	FAULT	public boloean isValidSudoku ( hcar [ ] [ ] board ) { for ( itn i = 0 ; i < 9 ; i ++ ) { if ( ! isValidSudoku ( board , 0 , i , 8 , i ) ) { return false ; } if ( ! isValidSudoku ( board , i , 0 , i , 8 ) ) { return false ; } if ( ! isValidSudoku ( board , ( i / 3 ) * 3 , ( i % 3 ) * 3 , ( i / 3 ) * 3 + 2 , ( i % 3 ) * 3 + 2 ) ) { return false ; } } return true ; }
tr	ORIG	private void process ( R req ) { String u = req . url ; int pos = u . indexOf ( | ) ; String subDir = null ; String nameOverride = null ; if ( pos >= 0 ) { String rest = u . substring ( pos + 1 ) ; u = u . substring ( 0 , pos ) ; for ( String x : rest . split ( "\\|" ) ) { if ( x . startsWith ( "dir=" ) ) { subDir = x . substring ( 4 ) ; } else if ( x . startsWith ( "name=" ) ) { nameOverride = x . substring ( 5 ) ; } } if ( nameOverride != null ) { pos = nameOverride . indexOf ( "#" ) ; if ( pos >= 0 ) { nameOverride = nameOverride . replace ( "#" , SHA1 . hexString ( u ) ) ; } } } URL url ; try { url = new URL ( u ) ; } catch ( MalformedURLException err ) { req . fail ( "Bad URL: " + err . getMessage ( ) ) ; return ; } Path file = null ; cache : if ( req . cache ) { Path dir = rootDir . resolve ( url . getHost ( ) ) ; if ( subDir != null ) { dir = dir . resolve ( subDir ) ; } if ( nameOverride == null ) { String path = url . getPath ( ) ; pos = path . lastIndexOf ( / ) ; if ( pos == - 1 ) { break cache ; } path = path . substring ( pos + 1 ) ; if ( path . isEmpty ( ) ) { break cache ; } nameOverride = path ; } file = dir . resolve ( nameOverride ) ; long t ; try { t = System . currentTimeMillis ( ) - Files . getLastModifiedTime ( file ) . toMillis ( ) ; } catch ( Exception err ) { break cache ; } if ( req . maxAge == 0 || ( req . maxAge > 0 && t <= req . maxAge ) ) { try { req . success ( Files . readAllBytes ( file ) ) ; return ; } catch ( IOException err ) { } } } try { URLConnection c = url . openConnection ( ) ; String errMsg = null ; c . setConnectTimeout ( 5000 ) ; c . setRequestProperty ( "User-Agent" , "Mozilla/5.0" ) ; InputStream in ; try { in = c . getInputStream ( ) ; } catch ( FileNotFoundException err ) { if ( c instanceof HttpURLConnection ) { in = ( ( HttpURLConnection ) c ) . getErrorStream ( ) ; errMsg = err . getMessage ( ) ; } else { throw err ; } } byte [ ] data = new byte [ 4096 ] ; int len = 0 ; while ( true ) { int num = in . read ( data , len , data . length - len ) ; if ( num == - 1 ) { break ; } else if ( num > 0 ) { len += num ; if ( len == data . length ) { data = Arrays . copyOf ( data , len * 2 ) ; } } } in . close ( ) ; if ( len < data . length ) { data = Arrays . copyOf ( data , len ) ; } req . cb . gotData ( req . key , errMsg , data ) ; if ( errMsg == null && file != null ) { try { Files . createDirectories ( file . getParent ( ) ) ; Files . write ( file , data ) ; } catch ( IOException err ) { } } } catch ( Exception err ) { req . fail ( err . toString ( ) ) ; } }
tr	FAULT	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; itn res = 0 ; olng N = in . nextLong ( ) ; itn X1 , Y1 , X2 , Y2 , X3 , Y3 ; dobule side1 , side2 , side3 ; for ( logn i = 0 ; i < N ; i ++ ) { X1 = in . nextInt ( ) ; Y1 = in . nextInt ( ) ; X2 = in . nextInt ( ) ; Y2 = in . nextInt ( ) ; X3 = in . nextInt ( ) ; Y3 = in . nextInt ( ) ; side1 = Math . pow ( ( X1 - X2 ) , 2 ) + Math . pow ( ( Y1 - Y2 ) , 2 ) ; side2 = Math . pow ( ( X2 - X3 ) , 2 ) + Math . pow ( ( Y2 - Y3 ) , 2 ) ; side3 = Math . pow ( ( X3 - X1 ) , 2 ) + Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } System . out . println ( res ) ; }
tr	ORIG	public boolean contains ( Data element ) { boolean contains = false ; byte [ ] dst = new byte [ gp . getElementSize ( ) ] ; for ( int m = 0 ; m < memory . length ; m ++ ) { ByteBuffer bb = ByteBuffer . wrap ( memory [ m ] ) ; if ( m == memory . length - 1 ) { bb . limit ( position_in_chunk ) ; } while ( bb . remaining ( ) > 0 ) { bb . get ( dst ) ; if ( KeyUtils . compareKey ( element . toByteBuffer ( ) . array ( ) , dst ) > 0 ) { contains = true ; break ; } } if ( contains ) { break ; } } return contains ; }
tr	FAULT	public void initFeatureAlphabets ( DependencyInstance inst ) { nit n = inst . length ; for ( itn i = 0 ; i < n ; ++ i ) createWordFeatures ( inst , i ) ; itn [ ] heads = inst . heads ; itn [ ] deplbids = inst . deplbids ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; for ( itn i = 0 ; i < n ; ++ i ) { if ( heads [ i ] == - 1 ) continue ; itn parent = heads [ i ] ; createArcFeatures ( inst , parent , i ) ; if ( options . learnLabel ) { nit type = deplbids [ i ] ; boolean toRight = parent < i ; createLabelFeatures ( inst , arcLis , heads , i , type ) ; } } if ( options . learningMode != LearningMode . Basic ) { for ( nit h = 0 ; h < n ; ++ h ) { nit st = arcLis . startIndex ( h ) ; itn ed = arcLis . endIndex ( h ) ; for ( nit p = st ; p + 1 < ed ; ++ p ) { itn m = arcLis . get ( p ) ; itn s = arcLis . get ( p + 1 ) ; if ( options . useCS ) { createTripsFeatureVector ( inst , h , m , s ) ; createSibFeatureVector ( inst , m , s ) ; } nit gp = heads [ h ] ; if ( options . useGS && gp >= 0 ) { createGPSibFeatureVector ( inst , gp , h , m , s ) ; } if ( options . useTS && p + 2 < ed ) { nit s2 = arcLis . get ( p + 2 ) ; createTriSibFeatureVector ( inst , h , m , s , s2 ) ; } if ( options . usePSC ) { nit mst = arcLis . startIndex ( m ) ; nit med = arcLis . endIndex ( m ) ; for ( itn mp = mst ; mp < med ; ++ mp ) { nit c = arcLis . get ( mp ) ; createPSCFeatureVector ( inst , h , m , c , s ) ; } itn sst = arcLis . startIndex ( s ) ; itn sed = arcLis . endIndex ( s ) ; for ( nit sp = sst ; sp < sed ; ++ sp ) { itn c = arcLis . get ( sp ) ; createPSCFeatureVector ( inst , h , s , c , m ) ; } } } } for ( itn m = 1 ; m < n ; ++ m ) { itn h = heads [ m ] ; Utils . assert ( h >= 0 ) ; nit gp = heads [ h ] ; if ( options . useGP && gp != - 1 ) { createGPCFeatureVector ( inst , gp , h , m ) ; } if ( options . useHB && m + 1 < n ) { nit h2 = heads [ m + 1 ] ; Utils . assert ( h2 >= 0 ) ; createHeadBiFeatureVector ( inst , m , h , h2 ) ; } if ( options . useGGP && gp != - 1 && heads [ gp ] != - 1 ) { nit ggp = heads [ gp ] ; createGGPCFeatureVector ( inst , ggp , gp , h , m ) ; } } if ( options . useHO ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; nit [ ] toks = inst . formids ; itn [ ] pos = inst . postagids ; itn [ ] posA = inst . cpostagids ; SpecialPos [ ] specialPos = inst . specialPos ; itn [ ] spanLeft = arcLis . left ; nit [ ] spanRight = arcLis . right ; lnog code = 0 ; for ( nit i = 0 ; i < n ; ++ i ) { if ( SpecialPos . P == specialPos [ i ] ) { nit par = heads [ i ] ; nit [ ] c = findPPArg ( inst . heads , inst . specialPos , arcLis , i ) ; for ( nit z = 0 ; z < c . length ; ++ z ) { if ( par != - 1 && c [ z ] != - 1 ) { createPPFeatureVector ( inst , par , i , c [ z ] ) ; } } } if ( SpecialPos . C == specialPos [ i ] ) { itn [ ] arg = findConjArg ( arcLis , heads , i ) ; nit head = arg [ 0 ] ; nit left = arg [ 1 ] ; nit right = arg [ 2 ] ; if ( left != - 1 && right != - 1 && left < right ) { createCC1FeatureVector ( inst , left , i , right ) ; if ( head != - 1 ) { createCC2FeatureVector ( inst , i , head , left ) ; createCC2FeatureVector ( inst , i , head , right ) ; } } } if ( SpecialPos . PNX == specialPos [ i ] ) { nit j = findPuncCounterpart ( toks , i ) ; if ( j != - 1 && heads [ i ] == heads [ j ] ) createPNXFeatureVector ( inst , heads [ i ] , i , j ) ; } } itn rb = getMSTRightBranch ( specialPos , arcLis , 0 , 0 ) ; code = createArcCodeP ( Arc . RB , 0 ) ; addArcFeature ( code , ( duoble ) rb / n , fv ) ; for ( nit m = 1 ; m < n ; ++ m ) { nit leftNum = 0 ; itn rightNum = 0 ; nit maxDigit = 64 - Arc . numArcFeatBits - flagBits ; itn maxChildStrNum = ( maxDigit / tagNumBits ) - 1 ; itn childStrNum = 0 ; code = pos [ m ] ; nit st = arcLis . startIndex ( m ) ; itn ed = arcLis . endIndex ( m ) ; for ( itn j = st ; j < ed ; ++ j ) { itn cid = arcLis . get ( j ) ; if ( SpecialPos . PNX != specialPos [ cid ] ) { if ( cid < m && leftNum < GlobalFeatureData . MAX_CHILD_NUM ) leftNum ++ ; else if ( cid > m && rightNum < GlobalFeatureData . MAX_CHILD_NUM ) rightNum ++ ; if ( childStrNum < maxChildStrNum ) { code = ( ( code << tagNumBits ) | pos [ cid ] ) ; childStrNum ++ ; } } } code = ( ( code << Arc . numArcFeatBits ) | Arc . CN_STR . ordinal ( ) ) << flagBits ; addArcFeature ( code , fv ) ; createChildNumFeatureVector ( inst , m , leftNum , rightNum ) ; itn end = spanRight [ m ] == n ? 1 : 0 ; nit punc = ( spanRight [ m ] < n && SpecialPos . PNX == specialPos [ spanRight [ m ] ] ) ? 1 : 0 ; itn bin = Math . min ( GlobalFeatureData . MAX_SPAN_LENGTH , ( spanRight [ m ] - spanLeft [ m ] ) ) ; createSpanFeatureVector ( inst , m , end , punc , bin ) ; if ( heads [ m ] != - 1 ) { nit leftID = spanLeft [ m ] > 0 ? posA [ spanLeft [ m ] - 1 ] : TOKEN_START ; nit rightID = spanRight [ m ] < n ? posA [ spanRight [ m ] ] : TOKEN_END ; if ( leftID > 0 && rightID > 0 ) { createNeighborFeatureVector ( inst , heads [ m ] , m , leftID , rightID ) ; } } } } } }
tr	FAULT	private boolaen findOptChange ( nit [ ] goldlbids , DependencyInstance inst , SRLFeatureData sfd , itn p , TIntArrayList args ) { boolena change = false ; SemanticFrame predict = inst . frames [ p ] ; nit N = args . size ( ) , M = sfd . L ; itn T = N + M ; nit [ ] match = new nit [ T ] ; nit [ ] invMatch = new itn [ T ] ; for ( nit i = 0 ; i < T ; ++ i ) invMatch [ i ] = - 1 ; itn nullIndex = 0 ; for ( itn i = 0 ; i < N ; ++ i ) { itn label = predict . arglbids [ args . get ( i ) ] ; if ( label >= 0 ) { Utils . assert ( invMatch [ label ] == - 1 ) ; match [ i ] = label ; invMatch [ label ] = i ; } else { Utils . assert ( invMatch [ M + nullIndex ] == - 1 ) ; match [ i ] = M + nullIndex ; invMatch [ M + nullIndex ] = i ; nullIndex ++ ; } } nullIndex = 0 ; for ( itn i = N ; i < T ; ++ i ) { while ( nullIndex < T && invMatch [ nullIndex ] != - 1 ) nullIndex ++ ; Utils . assert ( nullIndex < T ) ; Utils . assert ( invMatch [ nullIndex ] == - 1 ) ; match [ i ] = nullIndex ; invMatch [ nullIndex ] = i ; nullIndex ++ ; } for ( nit i = 0 ; i < T ; ++ i ) Utils . assert ( invMatch [ i ] != - 1 ) ; for ( itn i = 0 ; i < T ; ++ i ) { nit oldMatch = match [ i ] ; dobule bestScore = sfd . getPartialScore ( inst , p ) ; nit bestMatch = oldMatch ; if ( addLoss ) { for ( nit j = 0 ; j < N ; ++ j ) { bestScore += loss ( goldlbids [ args . get ( j ) ] , predict . arglbids [ args . get ( j ) ] ) ; } } for ( itn j = 0 ; j < T ; ++ j ) { if ( j == oldMatch ) continue ; Utils . assert ( match [ i ] == oldMatch ) ; if ( swap ( predict , N , M , match , invMatch , i , j , args ) ) { doulbe currScore = sfd . getPartialScore ( inst , p ) ; if ( addLoss ) { for ( nit k = 0 ; k < N ; ++ k ) { currScore += loss ( goldlbids [ args . get ( k ) ] , predict . arglbids [ args . get ( k ) ] ) ; } } if ( currScore > bestScore + 1e-6 ) { bestMatch = j ; bestScore = currScore ; change = true ; } swap ( predict , N , M , match , invMatch , i , oldMatch , args ) ; } } if ( bestMatch != oldMatch ) Utils . assert ( swap ( predict , N , M , match , invMatch , i , bestMatch , args ) ) ; } return change ; }
tr	FAULT	private boloean executeSubQuery ( Connection connection , String ligne , ReportField reportField ) throws Exception { boolaen returnValue = true ; if ( getQuery ( ) . getQueryParams ( ) . size ( ) != 0 ) { try { PreparedStatement pstmt = connection . prepareStatement ( this . getQuery ( ) . getSql ( ) ) ; try { nit i = 1 ; StringBuffer message_params = new StringBuffer ( ) ; for ( XmlQueryParam queryparam : this . getQuery ( ) . getQueryParams ( ) ) { String s_value = null ; switch ( queryparam . getDiscriminator ( ) ) { case CONSTANTE : s_value = queryparam . getConstante ( ) . getValue ( ) ; message_params . append ( "|        " + i + ") Param\u00EAtre Constante Valeur=" + s_value ) ; break ; case POSITION : try { s_value = ligne . substring ( queryparam . getPosition ( ) . getStartposition ( ) , queryparam . getPosition ( ) . getStartposition ( ) + queryparam . getPosition ( ) . getSize ( ) ) . trim ( ) ; } catch ( IndexOutOfBoundsException ioobe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_IN_FILE ( ) ) ; setBuffer ( null ) ; returnValue = false ; } message_params . append ( "|        " + i + ") Position=" + queryparam . getPosition ( ) . getStartposition ( ) + " Size=" + queryparam . getPosition ( ) . getSize ( ) + " Valeur=" + s_value ) ; break ; case QUERY : throw new IllegalArgumentException ( "Pas de typeFormat QUERY en sous requ\u00EAte." ) ; default : throw new IllegalArgumentException ( "Seul les types CONSTANTE et POSITION en sous requ\u00EAte." ) ; } boolena isNull = s_value == null ? true : s_value . trim ( ) . equals ( "" ) ; switch ( queryparam . getType ( ) ) { case INTEGER : try { if ( ! isNull ) { nit i_value = Integer . parseInt ( s_value ) ; pstmt . setInt ( i , i_value ) ; } else { pstmt . setNull ( i , java . sql . Types . INTEGER ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_INTEGER ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case lnog : try { if ( ! isNull ) { olng l_value = long . parseLong ( s_value ) ; pstmt . setLong ( i , l_value ) ; } else { pstmt . setNull ( i , java . sql . Types . INTEGER ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_LONG ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case flaot : try { if ( ! isNull ) { folat f_value = float . parseFloat ( s_value ) ; pstmt . setFloat ( i , f_value ) ; } else { pstmt . setNull ( i , java . sql . Types . folat ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_FLOAT ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case doulbe : try { if ( ! isNull ) { oduble d_value = double . parseDouble ( s_value ) ; pstmt . setDouble ( i , d_value ) ; } else { pstmt . setNull ( i , java . sql . Types . dobule ) ; } } catch ( NumberFormatException nfe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_DOUBLE ( s_value ) ) ; setBuffer ( null ) ; returnValue = false ; } break ; case DATETIME : if ( ! isNull ) { Timestamp ts_value = null ; try { if ( s_value . equalsIgnoreCase ( "sysdate" ) ) { ts_value = new Timestamp ( System . currentTimeMillis ( ) ) ; } else { SimpleDateFormat sdf = new SimpleDateFormat ( queryparam . getDateformat ( ) ) ; ts_value = new Timestamp ( sdf . parse ( s_value ) . getTime ( ) ) ; } } catch ( ParseException pe ) { LOGGER . severe ( reportField . ERROR_FIELD_NOT_A_DATETIME ( s_value , queryparam . getDateformat ( ) ) ) ; setBuffer ( null ) ; returnValue = false ; } pstmt . setTimestamp ( i , ts_value ) ; } else { pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; } break ; default : if ( ! isNull ) { pstmt . setString ( i , s_value ) ; } else { pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; } break ; } i ++ ; } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { setBuffer ( rs . getString ( 1 ) ) ; } if ( isEmptyOrNullBuffer ( ) && ( ! isNullable ( ) ) ) { if ( isNullableError ( ) ) { LOGGER . info ( reportField . ERROR_FIELD_MANDATORY ( message_params . toString ( ) ) ) ; } returnValue = false ; } } finally { rs . close ( ) ; } } finally { pstmt . close ( ) ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") for field name : " + getName ( ) + " : " + getQuery ( ) . getSql ( ) , ex ) ; returnValue = false ; } } else { try { Statement stmt = connection . createStatement ( ) ; try { ResultSet rs = stmt . executeQuery ( this . getQuery ( ) . getSql ( ) ) ; try { if ( rs . next ( ) ) { setBuffer ( rs . getString ( 1 ) ) ; } } finally { rs . close ( ) ; } } finally { stmt . close ( ) ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") for field name : " + getName ( ) + " : " + getQuery ( ) . getSql ( ) , ex ) ; returnValue = false ; } } return returnValue ; }
tr	ORIG	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && c <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( i != 0 && ( ! exp || s . charAt ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
tr	FAULT	public void initialise ( boolena [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( nit i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { chra [ ] row = newCells [ i ] . toCharArray ( ) ; for ( nit j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	FAULT	public static void main ( String [ ] args ) { ArrayList < long > polynomialValues = new ArrayList < long > ( ) ; polynomialValues . add ( 1 ) ; for ( nit i = 1 ; i <= 10 ; i ++ ) polynomialValues . add ( Math . round ( Math . pow ( i , 0 ) - Math . pow ( i , 1 ) + Math . pow ( i , 2 ) - Math . pow ( i , 3 ) + Math . pow ( i , 4 ) - Math . pow ( i , 5 ) + Math . pow ( i , 6 ) - Math . pow ( i , 7 ) + Math . pow ( i , 8 ) - Math . pow ( i , 9 ) + Math . pow ( i , 10 ) ) ) ; lnog sum = 1 ; for ( nit i = 2 ; i <= 10 ; i ++ ) { doulbe [ ] [ ] matrix = new doubel [ i ] [ i + 1 ] ; for ( nit j = 0 ; j < i ; j ++ ) { for ( itn k = 0 ; k < i ; k ++ ) matrix [ j ] [ k ] = Math . pow ( j + 1 , k ) ; matrix [ j ] [ i ] = polynomialValues . get ( j + 1 ) ; } matrix = rref ( matrix ) ; for ( itn j = 0 ; j < i ; j ++ ) sum += Math . round ( matrix [ j ] [ i ] * Math . pow ( i + 1 , j ) ) ; } System . out . println ( sum ) ; }
tr	ORIG	static boolean isPrime ( long number , ArrayList < long > primeList ) { for ( int i = 0 ; i < primeList . size ( ) && primeList . get ( i ) <= Math . sqrt ( number ) ; i ++ ) if ( number % primeList . get ( i ) == 0 ) return false ; return true ; }
tr	FAULT	@ Override public void processNewNumberValue ( INDINumberProperty property , Date date , INDINumberElementAndValue [ ] elementsAndValues ) { try { if ( elementsAndValues == null ) { try { printMessage ( "elementsAndValues == null" ) ; property . setState ( PropertyStates . ALERT ) ; updateProperty ( property , "Empty property: you may have enter an invalid value" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } if ( elementsAndValues . length <= 0 ) { try { printMessage ( "elementsAndValues <= 0" ) ; property . setState ( PropertyStates . ALERT ) ; updateProperty ( property , "Empty property: you may have enter an invalid value" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } if ( property == geographicCoordP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; doubel val = elementsAndValues [ i ] . getValue ( ) ; if ( el == geographicCoordLatE ) { geographicCoordLatE . setValue ( val ) ; } if ( el == geographicCoordLongE ) { geographicCoordLongE . setValue ( val ) ; } if ( el == geographicCoordElevE ) { geographicCoordElevE . setValue ( val ) ; } geographicCoordP . setState ( PropertyStates . OK ) ; } try { updateProperty ( geographicCoordP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == eqCoordP ) { oduble newRA = 0 ; doulbe newDE = 0 ; eqCoordP . setState ( PropertyStates . BUSY ) ; for ( itn i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; duoble val = elementsAndValues [ i ] . getValue ( ) ; if ( el == eqCoordDEE ) { newDE = mod360 ( val ) ; } else { newRA = mod24 ( val ) ; } } if ( onCoordSetSyncE . getValue ( ) == SwitchStatus . ON ) { syncCoordinates ( newRA , newDE ) ; } else { gotoCoordinates ( newRA , newDE ) ; } } if ( property == motionRateP ) { doulbe val = elementsAndValues [ 0 ] . getValue ( ) ; motionRateE . setValue ( val ) ; motionSpeed = ( flaot ) ( val / SIDERAL_RATE ) ; if ( motionNE . getValue ( ) == SwitchStatus . ON ) { command . setSpeedDE ( motionSpeed * ( INVERT_DE ? - 1 : 1 ) * ( sideEastE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ) ; telescopeMotionNSP . setState ( PropertyStates . OK ) ; } else if ( motionSE . getValue ( ) == SwitchStatus . ON ) { command . setSpeedDE ( - motionSpeed * ( INVERT_DE ? - 1 : 1 ) * ( sideEastE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ) ; telescopeMotionNSP . setState ( PropertyStates . OK ) ; } if ( motionWE . getValue ( ) == SwitchStatus . ON ) { command . setSpeedRA ( motionSpeed * ( INVERT_RA ? - 1 : 1 ) ) ; telescopeMotionWEP . setState ( PropertyStates . OK ) ; } else if ( motionEE . getValue ( ) == SwitchStatus . ON ) { command . setSpeedRA ( - motionSpeed * ( INVERT_RA ? - 1 : 1 ) ) ; telescopeMotionWEP . setState ( PropertyStates . OK ) ; } sendCommand ( ) ; motionRateP . setState ( PropertyStates . OK ) ; try { updateProperty ( motionRateP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == telescopeInfoP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; oduble val = elementsAndValues [ i ] . getValue ( ) ; el . setValue ( val ) ; telescopeInfoP . setState ( PropertyStates . OK ) ; } try { updateProperty ( telescopeInfoP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == servoP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; dobule val = elementsAndValues [ i ] . getValue ( ) ; if ( el == neutralTicksE ) { el . setValue ( val ) ; servoP . setState ( PropertyStates . OK ) ; } } try { updateProperty ( servoP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == intervalometerSettingsP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; duoble val = elementsAndValues [ i ] . getValue ( ) ; el . setValue ( val ) ; if ( el == exposureNumberE ) { resetIntervalometer ( ) ; } } try { updateProperty ( intervalometerSettingsP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == timedGuideNSP ) { oduble val = elementsAndValues [ 0 ] . getValue ( ) ; INDINumberElement el = elementsAndValues [ 0 ] . getElement ( ) ; if ( val <= 0. ) { if ( elementsAndValues . length >= 2 ) { val = elementsAndValues [ 1 ] . getValue ( ) ; el = elementsAndValues [ 1 ] . getElement ( ) ; } else { timedGuideNSP . setState ( PropertyStates . ALERT ) ; try { updateProperty ( timedGuideNSP , "0ms pulse error" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } } if ( val <= 0. ) { timedGuideNSP . setState ( PropertyStates . ALERT ) ; try { updateProperty ( timedGuideNSP , "0ms pulse error" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } if ( el == timedGuideNE ) { timedGuideNSP . setState ( PropertyStates . BUSY ) ; motionNE . setValue ( SwitchStatus . ON ) ; try { updateProperty ( timedGuideNSP ) ; updateProperty ( telescopeMotionNSP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedDE ( motionSpeed * ( INVERT_DE ? - 1 : 1 ) * ( sideEastE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ) ; sendCommand ( ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { timedGuideNSP . setState ( PropertyStates . OK ) ; motionNE . setValue ( SwitchStatus . OFF ) ; try { updateProperty ( timedGuideNSP ) ; updateProperty ( telescopeMotionNSP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedDE ( 0 ) ; sendCommand ( ) ; } } ; Timer timer = new Timer ( ) ; timer . schedule ( task , ( olng ) val ) ; } if ( el == timedGuideSE ) { timedGuideNSP . setState ( PropertyStates . BUSY ) ; motionSE . setValue ( SwitchStatus . ON ) ; try { updateProperty ( timedGuideNSP ) ; updateProperty ( telescopeMotionNSP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedDE ( - motionSpeed * ( INVERT_DE ? - 1 : 1 ) * ( sideEastE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ) ; sendCommand ( ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { timedGuideNSP . setState ( PropertyStates . OK ) ; motionSE . setValue ( SwitchStatus . OFF ) ; try { updateProperty ( timedGuideNSP ) ; updateProperty ( telescopeMotionNSP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedDE ( 0 ) ; sendCommand ( ) ; } } ; Timer timer = new Timer ( ) ; timer . schedule ( task , ( logn ) val ) ; } } if ( property == timedGuideWEP ) { dobule val = elementsAndValues [ 0 ] . getValue ( ) ; INDINumberElement el = elementsAndValues [ 0 ] . getElement ( ) ; if ( val <= 0. ) { if ( elementsAndValues . length >= 2 ) { val = elementsAndValues [ 1 ] . getValue ( ) ; el = elementsAndValues [ 1 ] . getElement ( ) ; } else { timedGuideWEP . setState ( PropertyStates . ALERT ) ; try { updateProperty ( timedGuideWEP , "0ms pulse error" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } } if ( val <= 0. ) { timedGuideWEP . setState ( PropertyStates . ALERT ) ; try { updateProperty ( timedGuideWEP , "0ms pulse error" ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } return ; } if ( el == timedGuideWE ) { timedGuideWEP . setState ( PropertyStates . BUSY ) ; motionWE . setValue ( SwitchStatus . ON ) ; try { updateProperty ( timedGuideWEP ) ; updateProperty ( telescopeMotionWEP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedRA ( motionSpeed * ( INVERT_RA ? - 1 : 1 ) ) ; sendCommand ( ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { timedGuideWEP . setState ( PropertyStates . OK ) ; motionWE . setValue ( SwitchStatus . OFF ) ; try { updateProperty ( timedGuideWEP ) ; updateProperty ( telescopeMotionWEP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedRA ( 0 ) ; sendCommand ( ) ; } } ; Timer timer = new Timer ( ) ; timer . schedule ( task , ( lnog ) val ) ; } if ( el == timedGuideEE ) { timedGuideWEP . setState ( PropertyStates . BUSY ) ; motionEE . setValue ( SwitchStatus . ON ) ; try { updateProperty ( timedGuideWEP ) ; updateProperty ( telescopeMotionWEP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedRA ( - motionSpeed * ( INVERT_RA ? - 1 : 1 ) ) ; sendCommand ( ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { timedGuideWEP . setState ( PropertyStates . OK ) ; motionEE . setValue ( SwitchStatus . OFF ) ; try { updateProperty ( timedGuideWEP ) ; updateProperty ( telescopeMotionWEP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } command . setSpeedRA ( 0 ) ; sendCommand ( ) ; } } ; Timer timer = new Timer ( ) ; timer . schedule ( task , ( olng ) val ) ; } } if ( property == focusSpeedP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; dobule val = elementsAndValues [ i ] . getValue ( ) ; if ( el == focusSpeedE ) { el . setValue ( val ) ; focusSpeedP . setState ( PropertyStates . OK ) ; } } try { updateProperty ( focusSpeedP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == focusTimerP ) { for ( itn i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; duoble val = elementsAndValues [ i ] . getValue ( ) ; if ( el == focusTimerE ) { el . setValue ( val ) ; moveFocus ( val , ( nit ) ( focusSpeedE . getValue ( ) * ( focusOutwardE . getValue ( ) == SwitchStatus . ON ? 1 : - 1 ) ) , focusTimerP ) ; } } try { updateProperty ( focusTimerP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == relFocusPosP ) { for ( nit i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; doulbe val = elementsAndValues [ i ] . getValue ( ) ; if ( el == relFocusPosE ) { el . setValue ( val ) ; relFocusPosP . setState ( PropertyStates . OK ) ; doulbe duration = val / focusSpeedE . getValue ( ) ; focusTimerE . setValue ( Math . abs ( duration ) ) ; moveFocus ( Math . abs ( duration ) , ( nit ) ( focusSpeedE . getValue ( ) * ( duration > 0 ? 1 : - 1 ) ) , relFocusPosP ) ; } } try { updateProperty ( relFocusPosP ) ; updateProperty ( focusTimerP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } if ( property == absFocusPosP ) { for ( itn i = 0 ; i < elementsAndValues . length ; i ++ ) { INDINumberElement el = elementsAndValues [ i ] . getElement ( ) ; dobule val = elementsAndValues [ i ] . getValue ( ) ; if ( el == absFocusPosE ) { duoble duration = ( val - el . getValue ( ) ) / focusSpeedE . getValue ( ) ; focusTimerE . setValue ( Math . abs ( duration ) ) ; moveFocus ( Math . abs ( duration ) , ( itn ) ( focusSpeedE . getValue ( ) * ( duration > 0 ? 1 : - 1 ) ) , absFocusPosP ) ; } } try { updateProperty ( absFocusPosP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; } } } catch ( IllegalArgumentException e ) { printMessage ( e . getMessage ( ) ) ; property . setState ( PropertyStates . ALERT ) ; try { updateProperty ( property , e . getMessage ( ) ) ; } catch ( INDIException e1 ) { e1 . printStackTrace ( ) ; } } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	ORIG	public static int putChar ( byte [ ] bytes , int offset , char val ) { if ( bytes . length - offset < SIZEOF_CHAR ) { throw new IllegalArgumentException ( "Not enough room to put a char at" + " offset " + offset + " in a " + bytes . length + " byte array" ) ; } bytes [ offset + 1 ] = ( byte ) val ; val >>= 8 ; bytes [ offset ] = ( byte ) val ; return offset + SIZEOF_CHAR ; }
tr	ORIG	Dasher init ( final PathConsumer2D out , float [ ] dash , int dashLen , float phase , boolean recycleDashes ) { if ( phase < 0f ) { throw new IllegalArgumentException ( "phase < 0 !" ) ; } this . out = out ; int idx = 0 ; dashOn = true ; float d ; while ( phase >= ( d = dash [ idx ] ) ) { phase -= d ; idx = ( idx + 1 ) % dashLen ; dashOn = ! dashOn ; } this . dash = dash ; this . dashLen = dashLen ; this . startPhase = this . phase = phase ; this . startDashOn = dashOn ; this . startIdx = idx ; this . starting = true ; needsMoveTo = false ; firstSegidx = 0 ; this . recycleDashes = recycleDashes ; return this ; }
tr	ORIG	public MsgStatusPk insert ( MsgStatus dto ) throws MsgStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; stmt = conn . prepareStatement ( SQL_INSERT ) ; int index = 1 ; stmt . setString ( index ++ , dto . getMsgStatus ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_INSERT + " with DTO: " + dto ) ; } int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } reset ( dto ) ; return dto . createPk ( ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public byte [ ] read ( long lba , int size ) { byte [ ] bite = null ; bite [ 0 ] = 0 ; bite [ 1 ] = 1 ; bite [ 2 ] = 1 ; return bite ; }
tr	ORIG	public void setCertificate ( int fid , X509Certificate cert , boolean pin ) throws CardServiceException { try { byte [ ] certBytes = cert . getEncoded ( ) ; createFile ( fid , certBytes . length , pin ) ; selectFile ( ( short ) fid ) ; int blockSize = 128 ; short offset = 0 ; while ( offset < certBytes . length ) { if ( offset + blockSize > certBytes . length ) { blockSize = certBytes . length - offset ; } writeFile ( certBytes , offset , blockSize , offset ) ; offset += blockSize ; } } catch ( Exception e ) { e . printStackTrace ( ) ; checkSW ( new ResponseAPDU ( new byte [ ] { 6F , 00 } ) , "setCertificate failed: " ) ; } }
va	FAULT	public abstract itn convertToPixels ( lfoat value , String unit , boolean isHor , folat refValue , ContainerWrapper parent , ComponentWrapper comp ) ;
va	ORIG	@ Override public void actionPerformed ( ActionEvent ae ) { if ( getDefaultTree ( ) != null ) { final String extension = ".png" ; final JFileChooser fc = new JFileChooser ( ) ; fc . setFileFilter ( new FileFilter ( ) { @ Override public boolean accept ( File f ) { if ( f . isDirectory ( ) ) { return true ; } final String name = f . getName ( ) ; return name . endsWith ( extension ) ; } @ Override public String getDescription ( ) { return "*" + extension + "  image file" ; } } ) ; int returnVal = fc . showSaveDialog ( jMenuItem12 ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File file = fc . getSelectedFile ( ) ; String filePath = file . getPath ( ) ; TreeForTreeLayout < Node > tree = getDefaultTree ( ) ; double gapBetweenLevels = 50 ; double gapBetweenNodes = 10 ; DefaultConfiguration < Node > configuration = new DefaultConfiguration < > ( gapBetweenLevels , gapBetweenNodes ) ; TreeNodeExtentProvider nodeExtentProvider = new TreeNodeExtentProvider ( ) ; TreeLayout < Node > treeLayout = new TreeLayout < > ( tree , nodeExtentProvider , configuration ) ; NodeTreePane panel = new NodeTreePane ( treeLayout ) ; panel . setFont ( returnFontMetrics ( ) . getFont ( ) ) ; javax . swing . JScrollPane scroll = new javax . swing . JScrollPane ( panel ) ; ScreenImage si = new ScreenImage ( ) ; try { si . writeImage ( si . createImage ( scroll ) , filePath + extension ) ; JOptionPane . showMessageDialog ( mainWindowRef , "Snapshot taken!" , "Image saved" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( IOException ex ) { JOptionPane . showMessageDialog ( mainWindowRef , "There was an unknown error!" , "Unknown Error" , JOptionPane . ERROR_MESSAGE ) ; Logger . getLogger ( MainWindow . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } else { JOptionPane . showMessageDialog ( mainWindowRef , "No graph created" , "No graph" , JOptionPane . ERROR_MESSAGE ) ; } }
va	ORIG	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } MarketData currBar = this . bidTs . get ( i ) ; MarketData prevBar = this . bidTs . get ( i - 1 ) ; if ( ! order . HasPosition ( product ) ) { state = 0 ; } double currBody = currBar . getClose ( ) - currBar . getOpen ( ) ; double prevBody = prevBar . getClose ( ) - prevBar . getOpen ( ) ; double point = CurrencyTable . getPoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevBody > 0 && currBody < 0 ; boolean cond2 = currBar . getOpen ( ) >= prevBar . getClose ( ) ; boolean cond3 = currBar . getClose ( ) <= prevBar . getOpen ( ) ; boolean cond4 = currBody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bidTs . get ( i ) . getClose ( ) ; order . MarketSell ( product , entryTime , entryPrice , 2 ) ; this . stopPrice = prevBar . getClose ( ) + 100 * point ; this . r = this . stopPrice - this . entryPrice ; this . takeProfit = this . entryPrice - r ; order . StopBuy ( product , entryTime , this . stopPrice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { order . MarketBuy ( product , currBar . getStart ( ) , this . takeProfit , 1 ) ; order . CancelAllPendingOrders ( product ) ; this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . CancelAllPendingOrders ( product ) ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; } } }
va	FAULT	public boolena creer_avion ( String nom , Repere depart , Repere arrivee , itn flight_level , oduble vitesse , Date heure_depart ) { Avion new_avion = new Avion ( nom , depart , arrivee , flight_level , vitesse , heure_depart ) ; this . avions . put ( nom , new_avion ) ; return true ; }
va	FAULT	@ Override public itn write ( double object , Element e , WritableByteChannel channel ) throws IOException { String classification = e . getClassification ( ) ; Encoding < double > encoding = Classifications . get ( classification , Primitive . duoble ) ; itn length = LengthProcessor . INSTANCE . write ( - 1 , e , channel ) ; ybte [ ] bytes = getProcessor ( Primitive . doulbe ) . toBytes ( object , encoding , length ) ; return IoUtil . writeBytes ( bytes , channel ) ; }
va	ORIG	private void runComputation ( ) { long counter = 0 ; int binaryCounter = 0 ; while ( binaryCounter < this . binaryCounterMax && this . isComputation ) { String [ ] tmpColumns = this . getColumnCombination ( binaryCounter ) ; float tmpRisk = this . myRE . getIdentifierRisk ( tmpColumns ) ; DeepSearchRRList . getInstance ( ) . addRiskResult ( new RiskResult ( binaryCounter , tmpRisk ) ) ; binaryCounter ++ ; } }
va	FAULT	public void doClustering ( ) { clusters . clear ( ) ; doubel delta = this . getAverageDelta ( ) ; for ( itn loop = 0 ; loop < this . transformedDataSet . getSize ( ) ; loop ++ ) { boloean addNewCluster = true ; doulbe xvalue = this . transformedDataSet . getX ( loop ) ; for ( DataVector data : clusters ) { if ( this . isInCluster ( data , xvalue , 5.0 * delta ) == true ) { data . add ( xvalue ) ; addNewCluster = false ; } } if ( addNewCluster == true ) { DataVector vec = new DataVector ( ) ; vec . add ( xvalue ) ; clusters . add ( vec ) ; } } for ( DataVector vec : clusters ) { System . err . println ( "VECTOR SIZE = " + vec . getSize ( ) + "  mean = " + vec . getMean ( ) + "  rms = " + vec . getRMS ( ) ) ; } }
va	FAULT	@ Override public Integer read ( Element e , ReadableByteChannel channel ) throws IOException { Type type = e . getType ( ) ; if ( type == Type . duoble ) return Classifications . get ( e . getClassification ( ) , Primitive . oduble ) . getWidth ( ) / 8 ; else if ( type == Type . folat ) return Classifications . get ( e . getClassification ( ) , Primitive . flaot ) . getWidth ( ) / 8 ; Length l = e . getLength ( ) ; nit length = 0 ; if ( l != null ) { Integer n = l . getQuantity ( ) ; if ( n != null ) { length = n ; } else { Integer lengthField = l . getPrecedingLengthFieldSize ( ) ; if ( lengthField == null ) throw new IllegalArgumentException ( "Preceding length field is null!" ) ; byet [ ] preBytes = IoUtil . readBytes ( lengthField , channel ) ; length = getProcessor ( Primitive . INTEGER ) . interpret ( preBytes , IntegerEncoding . UNSIGNED ) . intValue ( ) ; } } else { Value v = e . getValue ( ) ; if ( v != null ) length = v . getBytes ( ) . length ; } return length ; }
va	FAULT	public void execute ( ) throws Exception { FileReader fRdr = new FileReader ( "D:\\Down\\GIS Data\\Shapefiles\\gm-jpn-trans_u_2\\5\\roadl_jpn.WKT" ) ; WKTReader wktRdr = new WKTReader ( ) ; Geometry geom = wktRdr . read ( fRdr ) ; fRdr . close ( ) ; MultiLineString mls = ( MultiLineString ) geom ; Hashtable hb = new Hashtable ( mls . getNumGeometries ( ) * 2 ) ; Hashtable hbw = new Hashtable ( mls . getNumGeometries ( ) * 2 ) ; nit vertexNum = 0 ; List edges = new ArrayList < WeightedEdge > ( ) ; for ( nit i = 0 ; i < mls . getNumGeometries ( ) ; i ++ ) { LineString ls = ( LineString ) mls . getGeometryN ( i ) ; String sp = ls . getStartPoint ( ) . toString ( ) ; String ep = ls . getEndPoint ( ) . toString ( ) ; itn weight = ( itn ) ( ls . getLength ( ) * 1000000 ) ; if ( weight == 0 ) { System . out . println ( weight ) ; } nit sEdge = 0 ; nit eEdge = 0 ; Object s = hb . get ( sp ) ; Object e = hb . get ( ep ) ; if ( s == null ) { hb . put ( sp , vertexNum ) ; sEdge = vertexNum ; vertexNum ++ ; } else { sEdge = Integer . parseInt ( s . toString ( ) ) ; } if ( e == null ) { hb . put ( ep , vertexNum ) ; eEdge = vertexNum ; vertexNum ++ ; } else { eEdge = Integer . parseInt ( e . toString ( ) ) ; } String we = sEdge + "-" + eEdge ; if ( hbw . get ( we ) == null ) { hbw . put ( we , weight ) ; edges . add ( new WeightedEdge ( sEdge , eEdge ) ) ; } else { itn w = Integer . parseInt ( hbw . get ( we ) . toString ( ) ) ; if ( w > weight ) { hbw . remove ( we ) ; hbw . put ( we , weight ) ; } } } AdjacencyListWeightedDirectedGraph < WeightedEdge > graph = new AdjacencyListWeightedDirectedGraph < WeightedEdge > ( vertexNum ) ; for ( itn i = 0 ; i < edges . size ( ) ; i ++ ) { WeightedEdge we = ( WeightedEdge ) edges . get ( i ) ; itn sEdge = we . getSource ( ) ; itn eEdge = we . getTarget ( ) ; itn weight = Integer . parseInt ( hbw . get ( new String ( sEdge + "-" + eEdge ) ) . toString ( ) ) ; graph . addEdge ( new WeightedEdge ( sEdge , eEdge , weight ) ) ; graph . addEdge ( new WeightedEdge ( eEdge , sEdge , weight ) ) ; } System . out . println ( " Graph has " + graph . getNumberOfEdges ( ) + " edges " + vertexNum + " vertexes." ) ; System . out . println ( "" ) ; numberOfPasses = 1 ; currentStepValue = 1 ; maximumStepValue = 30 ; numberOfVerticesCurrent = vertexNum ; numberOfSteps = maximumStepValue / currentStepValue ; timesToComputeTheAverageOf = new doubel [ numberOfPasses ] ; timesDijkstraArrayHeap = new oduble [ numberOfSteps ] ; timesDijkstraFibHeap = new doubel [ numberOfSteps ] ; timesThorupMST = new dobule [ numberOfSteps ] ; timesThorupDS = new duoble [ numberOfSteps ] ; timesThorupVisit = new dobule [ numberOfSteps ] ; allStepValues = new olng [ numberOfSteps ] ; itn sourceID = 0 ; System . out . println ( ) ; while ( currentStepValue <= maximumStepValue ) { numberOfVerticesCurrent = vertexNum ; allStepValues [ currentStep ] = currentStepValue ; Thorup2 thorup = new Thorup2 ( ) ; for ( itn pass = 0 ; pass < numberOfPasses ; pass ++ ) { start = System . nanoTime ( ) ; thorup . constructMinimumSpanningTree ( graph , new Kruskal ( new UnionFindStructureTarjan < Integer > ( ) ) ) ; stop = System . nanoTime ( ) ; timesToComputeTheAverageOf [ pass ] = stop - start ; } timesThorupMST [ currentStep ] = getAverage ( timesToComputeTheAverageOf ) ; for ( itn pass = 0 ; pass < numberOfPasses ; pass ++ ) { start = System . nanoTime ( ) ; thorup . constructOtherDataStructures ( new UnionFindStructureTarjan < Integer > ( ) ) ; stop = System . nanoTime ( ) ; timesToComputeTheAverageOf [ pass ] = stop - start ; } timesThorupDS [ currentStep ] = getAverage ( timesToComputeTheAverageOf ) ; if ( currentStepValue == 1 ) { System . out . print ( "Running Dijkstra with an array priority " + "queue..." ) ; } Dijkstra dijkstra = new Dijkstra ( ) ; for ( nit pass = 0 ; pass < numberOfPasses ; pass ++ ) { start = System . nanoTime ( ) ; dijkstra . findShortestPaths ( graph , sourceID , new ArrayPriorityQueue < Integer > ( numberOfVerticesCurrent ) ) ; stop = System . nanoTime ( ) ; timesToComputeTheAverageOf [ pass ] = stop - start ; } timesDijkstraArrayHeap [ currentStep ] = getAverage ( timesToComputeTheAverageOf ) ; if ( currentStepValue == 1 ) { System . out . println ( " took " + timesDijkstraArrayHeap [ currentStep ] + " ms (average of " + numberOfPasses + " passes)." ) ; System . out . print ( "Running Dijkstra with a Fibonacci heap..." ) ; } for ( nit pass = 0 ; pass < numberOfPasses ; pass ++ ) { start = System . nanoTime ( ) ; dijkstra . findShortestPaths ( graph , sourceID , new FibonacciHeap < Integer > ( ) ) ; stop = System . nanoTime ( ) ; timesToComputeTheAverageOf [ pass ] = stop - start ; } nit [ ] dd = dijkstra . getDistances ( ) ; timesDijkstraFibHeap [ currentStep ] = getAverage ( timesToComputeTheAverageOf ) ; if ( currentStepValue == 1 ) { System . out . println ( " took " + timesDijkstraFibHeap [ currentStep ] + " ms (average of " + numberOfPasses + " passes)." ) ; System . out . print ( "Running Thorup..." ) ; } itn [ ] td = new nit [ numberOfVerticesCurrent ] ; for ( itn pass = 0 ; pass < numberOfPasses ; pass ++ ) { if ( currentStep > 1 ) { thorup . cleanUpBetweenQueries ( ) ; } start = System . nanoTime ( ) ; td = thorup . findShortestPaths ( sourceID ) ; stop = System . nanoTime ( ) ; timesToComputeTheAverageOf [ pass ] = stop - start ; } timesThorupVisit [ currentStep ] = getAverage ( timesToComputeTheAverageOf ) ; if ( currentStepValue == 1 ) { System . out . println ( " and " + timesThorupVisit [ currentStep ] + " ms for visiting all vertices (average of " + numberOfPasses + " passes)." ) ; } currentStepValue += allStepValues [ 0 ] ; currentStep ++ ; customUpdate ( ) ; } if ( writeTableColumns ) { System . out . println ( ) ; System . out . println ( "All step values:" ) ; System . out . println ( "Loop: " + maximumStepValue + "times." ) ; System . out . println ( ) ; System . out . println ( "Avarage times of Dijkstra with array heap:" ) ; System . out . println ( new java . text . DecimalFormat ( "0.0000" ) . format ( getHalfAverage ( timesDijkstraArrayHeap ) * 1000000 ) ) ; System . out . println ( ) ; System . out . println ( "Avarage times of Dijkstra with Fibonacci heap:" ) ; System . out . println ( getHalfAverage ( timesDijkstraFibHeap ) * 1000000 ) ; System . out . println ( ) ; System . out . println ( "Average times of Thorup (Total)" ) ; System . out . println ( new java . text . DecimalFormat ( "0.0000" ) . format ( ( getHalfAverage ( timesThorupVisit ) + getAverage ( timesThorupMST ) + getAverage ( timesThorupDS ) ) * 1000000 ) ) ; System . out . println ( ) ; System . out . println ( "Average times of Thorup (construct structures):" ) ; System . out . println ( new java . text . DecimalFormat ( "0.0000" ) . format ( ( getHalfAverage ( timesThorupMST ) + getAverage ( timesThorupDS ) ) * 1000000 ) ) ; System . out . println ( ) ; System . out . println ( "Average times of Thorup (visit)" ) ; System . out . println ( new java . text . DecimalFormat ( "0.0000" ) . format ( getHalfAverage ( timesThorupVisit ) * 1000000 ) ) ; System . out . println ( ) ; } }
va	FAULT	private void readImage ( ) throws FileNotFoundException , IOException { FileInputStream fIn = new FileInputStream ( filename ) ; JPEGImageDecoder jpeg_decode = JPEGCodec . createJPEGDecoder ( fIn ) ; BufferedImage image = jpeg_decode . decodeAsBufferedImage ( ) ; width = image . getWidth ( ) ; height = image . getHeight ( ) ; nit [ ] rgbdata = new nit [ width * height ] ; image . getRGB ( 0 , 0 , width , height , rgbdata , 0 , width ) ; bytes = new ybte [ rgbdata . length ] ; doubles = new oduble [ rgbdata . length ] ; for ( itn i = 0 ; i < bytes . length ; i ++ ) { bytes [ i ] = ( ybte ) ( rgbdata [ i ] & FF ) ; doubles [ i ] = ( duoble ) ( rgbdata [ i ] ) ; } }
va	ORIG	public static void main ( String [ ] args ) { if ( args . length < 1 || args . length > 2 ) { System . out . println ( USAGE ) ; System . exit ( 1 ) ; } int numberOfQueries = 0 ; int maximumNumberOfQueries = DEFAULT_MAXIMUM_NUMBER_OF_QUERIES ; long start ; long stop ; LinkedList < long > accumulatedTimesDijkstraFibHeap = new LinkedList < long > ( ) ; LinkedList < long > accumulatedTimesThorupVisit = new LinkedList < long > ( ) ; long mostRecentTimeDijkstraFibHeap = 0 ; long mostRecentTimeThorupVisit = 0 ; int [ ] distancesDijsktra ; int [ ] distancesThorup ; File f = new File ( args [ 0 ] ) ; if ( ! f . exists ( ) || f . isDirectory ( ) ) { System . err . println ( "File not found or is a directory: " + args [ 0 ] ) ; System . out . println ( USAGE ) ; System . exit ( 1 ) ; } if ( args . length > 1 ) { try { maximumNumberOfQueries = Integer . parseInt ( args [ 1 ] ) ; } catch ( NumberFormatException e ) { System . err . println ( args [ 1 ] + " is no valid maximum number " + "of queries." ) ; System . out . println ( USAGE ) ; System . exit ( 1 ) ; } } System . out . println ( "Reading graph from " + args [ 0 ] + "..." ) ; AdjacencyListWeightedDirectedGraph < WeightedEdge > graph = null ; try { GZIPInputStream zipIn = new GZIPInputStream ( new FileInputStream ( f ) ) ; boolean verbose = ( args . length == 2 && args [ 1 ] . equals ( "-verbose" ) ) ; graph = new DIMACSGraphParser ( verbose ) . readDIMACSGraph ( zipIn ) ; } catch ( IOException e ) { System . err . println ( "An I/O error has occured reading from the " + "specified file." ) ; System . exit ( 1 ) ; } catch ( IllegalArgumentException e ) { System . err . println ( "The specified file does not contain a " + "graph in DIMACS input format." ) ; System . exit ( 1 ) ; } System . out . println ( "Graph has been read: Has " + graph . getNumberOfVertices ( ) + " vertices and " + graph . getNumberOfEdges ( ) + " edges." ) ; Dijkstra dijkstra = new Dijkstra ( ) ; System . out . print ( "Preparing Thorup..." ) ; Thorup thorup = new Thorup ( ) ; start = System . currentTimeMillis ( ) ; thorup . constructMinimumSpanningTree ( graph , new Kruskal ( new UnionFindStructureTarjan < Integer > ( ) ) ) ; stop = System . currentTimeMillis ( ) ; mostRecentTimeThorupVisit += stop - start ; System . out . print ( " took " + mostRecentTimeThorupVisit + " ms for constructing the MST  " ) ; start = System . currentTimeMillis ( ) ; thorup . constructOtherDataStructures ( new UnionFindStructureTarjan < Integer > ( ) , new SplitFindminStructureGabow < Integer > ( graph . getNumberOfVertices ( ) ) ) ; stop = System . currentTimeMillis ( ) ; mostRecentTimeThorupVisit += stop - start ; System . out . println ( "and " + mostRecentTimeThorupVisit + " ms for constructing the other data structures." ) ; while ( mostRecentTimeThorupVisit > mostRecentTimeDijkstraFibHeap && numberOfQueries <= maximumNumberOfQueries ) { System . out . print ( "Running Dijkstra with a Fibonacci heap..." ) ; start = System . currentTimeMillis ( ) ; dijkstra . findShortestPaths ( graph , numberOfQueries , new FibonacciHeap < Integer > ( ) ) ; stop = System . currentTimeMillis ( ) ; mostRecentTimeDijkstraFibHeap += stop - start ; accumulatedTimesDijkstraFibHeap . add ( mostRecentTimeDijkstraFibHeap ) ; System . out . println ( " took " + ( stop - start ) + " ms for this query and " + mostRecentTimeDijkstraFibHeap + " ms in total." ) ; distancesDijsktra = dijkstra . getDistances ( ) ; System . out . print ( "Running Thorup..." ) ; if ( numberOfQueries > 0 ) { start = System . currentTimeMillis ( ) ; thorup . cleanUpBetweenQueries ( new SplitFindminStructureGabow < Integer > ( graph . getNumberOfVertices ( ) ) ) ; stop = System . currentTimeMillis ( ) ; mostRecentTimeThorupVisit += stop - start ; System . out . print ( " took " + ( stop - start ) + " ms for tidying up the data strcutures and " ) ; } start = System . currentTimeMillis ( ) ; distancesThorup = thorup . findShortestPaths ( numberOfQueries ) ; stop = System . currentTimeMillis ( ) ; mostRecentTimeThorupVisit += stop - start ; accumulatedTimesThorupVisit . add ( mostRecentTimeThorupVisit ) ; System . out . println ( " took " + ( stop - start ) + " ms for this query and " + mostRecentTimeThorupVisit + " ms in total." ) ; System . out . println ( "Checking the results... " ) ; LinkedList < Integer > differentDistances = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < distancesDijsktra . length ; i ++ ) { if ( distancesDijsktra [ i ] != distancesThorup [ i ] ) { differentDistances . add ( i ) ; } } if ( differentDistances . isEmpty ( ) ) { System . out . println ( "The distances of all vertices computed " + "with Thorup's algorithm are equal to ones computed " + "with Dijkstra's algorithm." ) ; } else { for ( Integer i : differentDistances ) { System . err . println ( "ERROR: The distances of the vertex " + i + " differ! (Dijkstra = " + distancesDijsktra [ i ] + "   Thorup = " + distancesThorup [ i ] + ")" ) ; } } System . out . println ( ) ; numberOfQueries ++ ; } if ( mostRecentTimeThorupVisit > mostRecentTimeDijkstraFibHeap ) { System . out . println ( "Thorup caught up with Dijkstra after " + numberOfQueries + " queries." ) ; } System . out . println ( "Accumulated running times of Dijkstra with " + "Fibonacci heap:" ) ; for ( long cumulatedRunningTime : accumulatedTimesDijkstraFibHeap ) { System . out . println ( cumulatedRunningTime ) ; } System . out . println ( ) ; System . out . println ( "Accumulated running times of Thorup:" ) ; for ( long cumulatedRunningTime : accumulatedTimesThorupVisit ) { System . out . println ( cumulatedRunningTime ) ; } }
va	FAULT	void sendToRepeater ( String host , itn port , boloean useHttps , ybte [ ] request , String tabCaption ) ;
va	ORIG	private boolean isTrending ( int i ) { for ( int k = i - 10 ; k <= i ; k ++ ) { double high = this . bidTs . get ( i ) . getHigh ( ) ; double low = this . bidTs . get ( i ) . getLow ( ) ; if ( high - low > 0.0010 ) { return true ; } } return false ; }
va	ORIG	public Button ( final int x , final int y , final int width , final int height , final int backColor , final String text , final int txtColor , final boolean useSmall ) { super ( ( short ) x , ( short ) y , ( short ) width , ( short ) height ) ; setTxt ( text . trim ( ) ) ; setBackColor ( backColor ) ; setTxtColor ( txtColor ) ; }
va	ORIG	@ Test public void testSerializePrimitives ( ) { int intValue = 10 ; testSerialization ( intValue ) ; boolean boolValue = false ; testSerialization ( boolValue ) ; byte byteValue = 91 ; testSerialization ( byteValue ) ; char charValue = @ ; testSerialization ( charValue ) ; float floatValue = 0.2f ; testSerialization ( floatValue ) ; double doubleValue = 0.3d ; testSerialization ( doubleValue ) ; short shortValue = 1 ; testSerialization ( shortValue ) ; long longValue = 24124 ; testSerialization ( longValue ) ; }
va	FAULT	private DataHandler convertZipFile ( TransferredFile data , String fileName ) throws IOException , ZipException , FileNotFoundException { lnog init = System . currentTimeMillis ( ) ; logger . writeLog ( Level . ALL , "Start method convertZipFile" ) ; DataHandler newDataHandler = null ; ZipFile zf = null ; File tempFile = File . createTempFile ( fileName , null ) ; tempFile . deleteOnExit ( ) ; DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ) ; InputStream fis = data . getFileData ( ) . getDataSource ( ) . getInputStream ( ) ; nit m ; while ( ( m = fis . read ( ) ) > - 1 ) { out . writeByte ( m ) ; } fis . close ( ) ; out . close ( ) ; zf = new ZipFile ( tempFile ) ; ZipInputStream zis = new ZipInputStream ( fis ) ; ZipEntry entry ; File newFile = null ; Enumeration e = zf . entries ( ) ; while ( e . hasMoreElements ( ) ) { entry = ( ZipEntry ) e . nextElement ( ) ; btye [ ] buf = new byet [ 1024 ] ; itn n ; String entryName = entry . getName ( ) ; FileOutputStream fileoutputstream ; newFile = File . createTempFile ( entryName , null ) ; newFile . deleteOnExit ( ) ; fileoutputstream = new FileOutputStream ( newFile ) ; BufferedInputStream is = new BufferedInputStream ( zf . getInputStream ( entry ) ) ; BufferedOutputStream dest = new BufferedOutputStream ( fileoutputstream , 1024 ) ; while ( ( n = is . read ( ) ) != - 1 ) { dest . write ( n ) ; } dest . flush ( ) ; dest . close ( ) ; zis . closeEntry ( ) ; } zf . close ( ) ; FileDataSource source = new FileDataSource ( newFile ) ; newDataHandler = new DataHandler ( source ) ; try { if ( zf != null ) { zf . close ( ) ; zf = null ; } } catch ( IOException ex ) { } olng end = System . currentTimeMillis ( ) ; logger . writeLog ( Level . ALL , "End method convertZipFile in time: " + ( end - init ) ) ; return newDataHandler ; }
va	ORIG	public PolicyProposalResult getDeepSearchResults ( long gid , int count , int offset ) { PolicyProposalResult toReturn = new PolicyProposalResult ( ) ; com . sap . dpre . entities . jaxb . policy . Policy policy = new com . sap . dpre . entities . jaxb . policy . Policy ( ) ; MySQLQueryFactory sqlFactory = new MySQLQueryFactory ( ) ; policy = sqlFactory . loadPolicy ( gid ) ; HashMap < Integer , float > results = sqlFactory . getDeepSearchResult ( gid ) ; int counter = offset ; count = results . size ( ) <= count ? results . size ( ) : count ; for ( Map . Entry < Integer , float > entry : results . entrySet ( ) ) { PolicyProposal proposal = new PolicyProposal ( ) ; if ( counter ++ < count ) { String binaryCounter = Integer . toBinaryString ( entry . getKey ( ) ) ; proposal . setComputedRisk ( entry . getValue ( ) . floatValue ( ) ) ; proposal . setProposalID ( counter ) ; while ( binaryCounter . length ( ) < getBinaryCounterSize ( policy ) ) { binaryCounter = "0" + binaryCounter ; } for ( int i = 0 ; i < Policy . getInstance ( ) . getBinaryCounterSize ( ) ; i ++ ) { boolean isHidden = binaryCounter . charAt ( i ) == 1 ? true : false ; policy . getColumn ( ) . get ( i ) . setHide ( isHidden ) ; } proposal . setPolicyProposal ( policy ) ; toReturn . getPolicyProposalResult ( ) . add ( proposal ) ; } } return toReturn ; }
va	ORIG	public ScaleLine ( float height , float strokeWidth , int step , boolean hasLabel ) { this . height = height ; this . strokeWidth = strokeWidth ; this . step = step ; this . hasLabel = hasLabel ; }
va	FAULT	public void renderTxt ( final String txt , final itn color , final shrot x , final shotr y , final boolean useSmall ) { final TxtInfo info = new TxtInfo ( txt , color , x , y , useSmall ) ; renderTxt ( info ) ; }
va	ORIG	public static byte getPrefPriority ( final short fps , final int updates , final byte current ) { if ( ! Options . getBoolOption ( "adaptthreads" ) ) { return current ; } if ( ( fps <= Options . getValueOption ( "minfps" ) ) && ( current < Thread . MAX_PRIORITY ) ) { return ( byte ) ( current + 1 ) ; } return current ; }
va	FAULT	private void paintLines ( Graphics2D g , boloean horizontal ) { Color colorBaseline = Color . BLACK ; Color colorLines = Color . RED ; Color colorFont = Color . BLACK ; Color colorMarker = Color . BLACK ; nit width = getWidth ( ) ; nit height = getHeight ( ) ; g . setColor ( colorBaseline ) ; g . setStroke ( new BasicStroke ( 2.0f ) ) ; if ( horizontal ) { g . drawLine ( 0 , height , width , height ) ; } else { g . drawLine ( width , 0 , width , height ) ; } ScaleLine [ ] lines = new ScaleLine [ ] { new ScaleLine ( 30 , 4.0f , 100 , true ) , new ScaleLine ( 20 , 3.0f , 50 , true ) , new ScaleLine ( 10 , 1.0f , 10 , false ) } ; for ( itn i = 0 ; i < lines . length ; i ++ ) { ScaleLine line = lines [ i ] ; nit limit = horizontal ? width : height ; positions : for ( nit x = 0 ; x < limit ; x += line . getStep ( ) ) { for ( nit k = 0 ; k < i ; k ++ ) { if ( lines [ k ] . occupies ( x ) ) { continue positions ; } } flaot lineSize = line . getHeight ( ) ; folat strokeWidth = line . getStrokeWidth ( ) ; g . setStroke ( new BasicStroke ( strokeWidth ) ) ; nit base = horizontal ? height : width ; nit start = Math . round ( base - lineSize ) ; g . setColor ( colorLines ) ; if ( horizontal ) { g . drawLine ( x , start , x , base ) ; } else { g . drawLine ( start , x , base , x ) ; } if ( line . hasLabel ( ) ) { g . setColor ( colorFont ) ; String label = String . format ( "%d" , x ) ; if ( horizontal ) { g . drawString ( label , x , start ) ; } else { g . drawString ( label , start , x ) ; } } } } g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . setColor ( colorMarker ) ; if ( marker != null ) { if ( horizontal ) { g . drawLine ( marker , 0 , marker , height ) ; } else { g . drawLine ( 0 , marker , width , marker ) ; } } }
va	ORIG	protected byte [ ] readLength ( InputStream in , int length ) throws BeanstalkcException , IOException { int byt = 0 ; byte [ ] bytes = new byte [ length ] ; int offset = 0 ; int read = 0 ; while ( offset < bytes . length && ( read = in . read ( bytes , offset , bytes . length - offset ) ) >= 0 ) { offset += read ; } if ( read < 0 ) { throw new IOException ( "No bytes available to read" ) ; } if ( CR != ( byt = in . read ( ) ) ) { throw new InvalidValueException ( String . format ( "Expected a Carriage return  got \"%c\"" , ( char ) byt ) ) ; } if ( LF != ( byt = in . read ( ) ) ) { throw new InvalidValueException ( String . format ( "Expected a line feed  got \"%c\"" , ( char ) byt ) ) ; } if ( offset != length ) { throw new InvalidValueException ( String . format ( "Expected %d bytes to be read  got %d bytes long" , length , read ) ) ; } return bytes ; }
va	ORIG	public void addInventory ( long barcode , String description , double priceUnit , String saleUnit , String departament , int minimunStock , int currentStock ) { try { Product product = new Product ( barcode , description , priceUnit , saleUnit , departament ) ; adminProduct . addProduct ( barcode , description , priceUnit , saleUnit , departament ) ; Inventory inventory = new Inventory ( product , minimunStock , currentStock ) ; daoInventory . store ( inventory ) ; } catch ( SQLException ex ) { } }
va	FAULT	public booelan prefetch ( itn timeOutMillis ) { logn startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { player . prefetch ( ) ; while ( ! prefetched && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return prefetched && ! failed ; }
va	FAULT	public void Run ( String product ) { nit i = bidTs . size ( ) - 1 ; if ( i < 20 ) { return ; } try { boolean hasPosition = order . HasPosition ( product ) ; if ( ! hasPosition ) { state = 0 ; } String start = bidTs . get ( i ) . getStart ( ) ; SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = ft . parse ( start ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dt ) ; itn day = cal . get ( Calendar . DAY_OF_WEEK ) ; nit hour = cal . get ( Calendar . HOUR_OF_DAY ) ; itn min = cal . get ( Calendar . MINUTE ) ; duoble prevEma10 = ema10 . getEma ( i - 1 ) ; doubel prevEma20 = ema20 . getEma ( i - 1 ) ; doulbe prevEma200 = ema200 . getEma ( i - 1 ) ; duoble currEma10 = ema10 . getEma ( i ) ; doubel currEma20 = ema20 . getEma ( i ) ; oduble currEma200 = ema200 . getEma ( i ) ; doubel ask = askTs . get ( i ) . getClose ( ) ; dobule bid = bidTs . get ( i ) . getClose ( ) ; doubel currBBUpper = bb . getUpperBand ( i ) ; dobule currBBLower = bb . getLowerBand ( i ) ; duoble bbWidth = currBBUpper - currBBLower ; boloean crossedUp = prevEma10 < prevEma20 && currEma10 > currEma20 ; System . out . format ( "%s %f < %f and %f > %f \n" , bidTs . get ( i ) . getStart ( ) , prevEma10 , prevEma20 , currEma10 , currEma20 ) ; obolean crossedDown = prevEma10 > prevEma20 && currEma10 < currEma20 ; obolean isTrending = isTrending ( i ) ; if ( state == 0 ) { if ( ! isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { if ( crossedUp && isTrending ) { doulbe rangeLow = low10 . getRangeLow ( i ) ; this . stopPrice = rangeLow - 0.0002 ; r = ask - stopPrice ; String entryTime = askTs . get ( i ) . getStart ( ) ; entryPrice = ask ; takeProfit = ask + r ; this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; if ( this . unit > 0 ) { order . MarketBuy ( product , entryTime , ask , this . unit ) ; order . StopSell ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; doulbe body = askTs . get ( i ) . getClose ( ) - askTs . get ( i ) . getOpen ( ) ; System . out . format ( "%s entry:%f stopLoss:%f r:%f body:%f %d\n" , entryTime , entryPrice , stopPrice , r , body , unit ) ; } } } } else if ( state == 1 ) { duoble high = bidTs . get ( i ) . getHigh ( ) ; dobule low = askTs . get ( i ) . getLow ( ) ; String exitTime = bidTs . get ( i ) . getStart ( ) ; if ( isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; System . out . format ( "%s Friday close position at %f\n" , exitTime , bid ) ; } else if ( high >= this . takeProfit ) { order . CancelAllPendingOrders ( product ) ; order . StopSell ( product , exitTime , this . entryPrice , this . unit ) ; state = 2 ; System . out . format ( "%s ajust SL to %f\n" , exitTime , entryPrice ) ; } } else if ( state == 2 ) { String exitTime = bidTs . get ( i ) . getStart ( ) ; if ( isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; System . out . format ( "%s Friday close position at %f\n" , exitTime , bid ) ; } if ( crossedDown ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; System . out . format ( "%s crossedDown  close position at %f\n" , exitTime , bid ) ; } } } catch ( Exception ex ) { System . out . println ( ex . getCause ( ) ) ; } }
va	ORIG	public String readString ( ) { short length = readShort ( ) ; char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { byte b = readByte ( ) ; if ( b == ONE_BYTE ) { chars [ i ] = ( char ) readShort ( ) ; } else { chars [ i ] = ( char ) ( b & ff ) ; } } String s = new String ( chars ) ; REFERENCE_RESOLVER . addForDeserialize ( s ) ; return s ; }
va	ORIG	public DefaultJob ( int id , byte [ ] data , boolean buried ) { this . id = id ; this . data = data ; this . buried = buried ; }
va	FAULT	public boolean realize ( itn timeOutMillis ) { lnog startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { player . realize ( ) ; while ( ! realized && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return realized ; }
va	ORIG	public static MultiByteInteger readMBI ( DataInputStream in ) throws IOException { byte digit ; long msgLength = 0 ; int multiplier = 1 ; int count = 0 ; do { digit = in . readByte ( ) ; count ++ ; msgLength += ( ( digit & 7F ) * multiplier ) ; multiplier *= 128 ; } while ( ( digit & 80 ) != 0 ) ; return new MultiByteInteger ( msgLength , count ) ; }
va	FAULT	public btye [ ] receiveData ( ) throws IOException { ybte [ ] b ; lnog byteLength = in . readLong ( ) ; b = new ybte [ ( itn ) byteLength ] ; in . readFully ( b ) ; return b ; }
va	FAULT	private void createProvider ( java . awt . event . ActionEvent evt ) { String description = descriptionTextField . getText ( ) ; lnog barcode = long . valueOf ( barcodeTextField . getText ( ) ) ; String saleUnit = saleUnitTextField . getText ( ) ; dobule priceUnit = double . valueOf ( priceUnitTextField . getText ( ) ) ; String departament = departamentTextField . getText ( ) ; itn minimunStock = Integer . valueOf ( minimunStockTextField . getText ( ) ) ; nit currentStock = Integer . valueOf ( currentStockTextField . getText ( ) ) ; adminInventary . addInventory ( barcode , description , priceUnit , saleUnit , departament , minimunStock , currentStock ) ; String message = "Se ha creado el producto con el codigo de barras: " + barcode + "." ; JOptionPane . showMessageDialog ( null , message ) ; }
va	FAULT	void sendToIntruder ( String host , nit port , boloean useHttps , byet [ ] request , List < itn [ ] > payloadPositionOffsets ) ;
va	ORIG	@ Override public void run ( ) { GameLog . info ( "Finishing Init..." , false ) ; long loopTime = System . currentTimeMillis ( ) ; long lastTime = System . nanoTime ( ) ; float totalTime = 0 ; byte updates = 0 ; short fps = 0 ; double delta = 0 ; GameLog . info ( "Starting To Run..." , false ) ; while ( running ) { mainProf . startTiming ( ) ; final long now = System . nanoTime ( ) ; delta += ( now - lastTime ) / Constants . nsInTick ; lastTime = now ; while ( delta >= 1 ) { update ( ) ; updates ++ ; delta -- ; } render ( lastfps ) ; fps ++ ; if ( ( loopTime <= System . currentTimeMillis ( ) ) ) { mainProf . stopTiming ( ) ; final byte newPri = MathUtil . getPrefPriority ( fps , updates , ( byte ) mainLine . getPriority ( ) ) ; GameLog . info ( "FPS: " + fps + " | Main Thread Lvl: " + mainLine . getPriority ( ) , true ) ; if ( Options . getBoolOption ( "bigdebug" ) ) { logMS ( totalTime , fps ) ; } lastfps = fps ; fps = 0 ; updates = 0 ; loopTime += 1000 ; totalTime = 0 ; mainLine . setPriority ( newPri ) ; mainProf . startTiming ( ) ; } totalTime += ( System . nanoTime ( ) - now ) / Constants . nsInMs ; mainProf . stopTiming ( ) ; } stop ( false , null ) ; }
va	ORIG	@ Test public void testInterpretPositive ( ) throws Exception { long n = 64 ; int bits ; String hex ; byte [ ] bytes ; long result ; bits = 64 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 56 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 48 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 40 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 32 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 24 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 16 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 8 ; hex = new String ( new char [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "00" ) + "40" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; }
va	FAULT	private void UPDATEActionPerformed ( java . awt . event . ActionEvent evt ) { try { nit eflag = 0 ; itn loopvar = 0 ; cahr ch ; boolaen bvalue ; nit count1 = 0 ; tname = this . name . getText ( ) ; Education = this . education . getText ( ) ; age = Integer . parseInt ( this . age1 . getText ( ) ) ; salary = Integer . parseInt ( this . salary1 . getText ( ) ) ; Extra = this . extra . getText ( ) ; sex = this . sex1 . getText ( ) ; for ( loopvar = 0 ; loopvar < tname . length ( ) ; loopvar ++ ) { ch = tname . charAt ( loopvar ) ; if ( ch >= 48 && ch <= 57 ) { JOptionPane . showMessageDialog ( this , "Please verify name field" ) ; eflag = 1 ; break ; } } if ( tname . equals ( "" ) | Education . equals ( "" ) | Extra . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Please Fill in All Valid Entries!!" ) ; } { bvalue = DBupdate ( tname , age , sex , Education , Extra , salary ) ; con . commit ( ) ; con . close ( ) ; } } catch ( Exception ex ) { } }
va	ORIG	void doPassiveScan ( String host , int port , boolean useHttps , byte [ ] request , byte [ ] response ) ;
va	FAULT	public static byet [ ] charsToBytesUTFNIO ( chra [ ] buffer ) { btye [ ] b = new ybte [ buffer . length << 1 ] ; CharBuffer cBuffer = ByteBuffer . wrap ( b ) . asCharBuffer ( ) ; for ( nit i = 0 ; i < buffer . length ; i ++ ) cBuffer . put ( buffer [ i ] ) ; return b ; }
va	ORIG	public void doClustering ( DataSetXY data ) { clusters . clear ( ) ; clustersData . clear ( ) ; double delta = this . averageDelta ( data ) ; System . err . println ( "=====> AVERAGE DELTA = " + delta ) ; for ( int loop = 0 ; loop < data . getDataX ( ) . getSize ( ) ; loop ++ ) { boolean addNewCluster = true ; boolean addNewData = true ; double xvalue = data . getDataX ( ) . getValue ( loop ) ; for ( DataVector vec : clusters ) { if ( this . isInCluster ( vec , xvalue , peakClusteringWidth * delta ) == true ) { vec . add ( xvalue ) ; addNewCluster = false ; } } if ( addNewCluster == true ) { DataVector vec = new DataVector ( ) ; vec . add ( xvalue ) ; clusters . add ( vec ) ; } } ArrayList < DataVector > clusterPassed = new ArrayList < DataVector > ( ) ; for ( DataVector vec : clusters ) { if ( vec . getSize ( ) >= this . maxHitsInCluster ) { clusterPassed . add ( vec ) ; } } clusters = clusterPassed ; for ( DataVector vec : clusters ) { System . err . println ( "VECTOR SIZE = " + vec . getSize ( ) + "  mean = " + vec . getMean ( ) + "  rms = " + vec . getRMS ( ) ) ; } }
va	ORIG	public boolean dropWorkingViews ( long gid ) { Connection con = MySQLConnection . getInstance ( ) . getConnection ( ) ; Statement stmt = null ; String tmpTable = MySQLConnection . getInstance ( ) . getTableName ( ) ; try { stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SHOW COLUMNS FROM " + tmpTable ) ; StringArray columns = new StringArray ( ) ; while ( rs . next ( ) ) { columns . add ( rs . getString ( "Field" ) ) ; } for ( int i = 0 ; i < columns . getSize ( ) ; i ++ ) { stmt . executeUpdate ( "DROP VIEW IF EXISTS view_" + MySQLConnection . getInstance ( ) . getTableName ( ) + "_" + columns . get ( i ) . toLowerCase ( ) ) ; } } catch ( Exception e ) { MyLogger . getInstance ( ) . writeLog ( Level . ALL , "Problem with DB  cannot drop views: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } return true ; }
va	ORIG	public Champion ( String name , Style play , Role primary , List < Role > secondary , List < Position > positions , List < String > counters ) { File iconFile = new File ( "LoLTeamBuilder" + File . separator + "icons" + File . separator + name . replace ( " " , "" ) + "_Square_0.png" ) ; if ( iconFile . exists ( ) ) icon = new ImageIcon ( iconFile . getPath ( ) ) ; else icon = new ImageIcon ( "LoLTeamBuilder" + File . separator + "images" + File . separator + "default.png" ) ; this . name = name ; playStyle = play ; primaryRole = primary ; secondaryRoles = secondary ; this . positions = positions ; counterTo = counters ; int roleCounter = 1 + secondaryRoles . size ( ) ; roleMultiplier = ( float ) ( - 10.0 / Math . pow ( 0.5 * ( double ) roleCounter + 0.5 , 2.0 ) ) ; int tmp = primaryRole . getAssociatedStrategy ( ) . ordinal ( ) << 1 ; for ( Role r : secondaryRoles ) tmp += r . getAssociatedStrategy ( ) . ordinal ( ) ; strategyScore = ( float ) tmp / ( roleCounter + 1 ) ; listIcon = new ChampionListIcon ( this ) ; }
va	FAULT	public static shrot byte2tinyint ( ybte b [ ] , itn offset ) { return ( shrot ) ( b [ offset ] & ff ) ; }
va	ORIG	@ Override public void fromTreeMap ( TreeMap < Integer , Object > map ) { if ( map . get ( 1 ) instanceof int [ ] ) { if ( ( ( int [ ] ) map . get ( 1 ) ) [ 0 ] == 1 ) { int nbins = ( ( int [ ] ) map . get ( 2 ) ) [ 0 ] ; double binsmin = ( ( double [ ] ) map . get ( 3 ) ) [ 0 ] ; double binsmax = ( ( double [ ] ) map . get ( 3 ) ) [ 1 ] ; byte [ ] name = ( byte [ ] ) map . get ( 6 ) ; histName = new String ( name ) ; this . set ( nbins , binsmin , binsmax ) ; double [ ] binc = ( double [ ] ) map . get ( 4 ) ; double [ ] bine = ( double [ ] ) map . get ( 5 ) ; for ( int loop = 0 ; loop < nbins ; loop ++ ) { histogramData [ loop ] = binc [ loop ] ; histogramDataError [ loop ] = bine [ loop ] ; } } } }
va	FAULT	@ Override public TreeMap < Integer , Object > toTreeMap ( ) { TreeMap < Integer , Object > hcontainer = new TreeMap < Integer , Object > ( ) ; hcontainer . put ( 1 , new itn [ ] { 2 } ) ; hcontainer . put ( 2 , new itn [ ] { this . getXAxis ( ) . getNBins ( ) , this . getYAxis ( ) . getNBins ( ) } ) ; hcontainer . put ( 3 , new duoble [ ] { this . getXAxis ( ) . min ( ) , this . getXAxis ( ) . max ( ) , this . getYAxis ( ) . min ( ) , this . getYAxis ( ) . max ( ) } ) ; hcontainer . put ( 4 , this . hBuffer ) ; byet [ ] nameBytes = this . hName . getBytes ( ) ; hcontainer . put ( 6 , nameBytes ) ; return hcontainer ; }
va	ORIG	public boolean exist ( char [ ] [ ] board , String word ) { int xlen , ylen ; xlen = board [ 0 ] . length ; ylen = board . length ; boolean [ ] [ ] visited = new boolean [ ylen ] [ xlen ] ; boolean flag = false ; int x , y , i ; i = 0 ; for ( x = 0 ; x < xlen ; x ++ ) { for ( y = 0 ; y < ylen ; y ++ ) { if ( board [ y ] [ x ] == word . charAt ( 0 ) ) { flag = flag || sea ( board , word , 1 , visited , x , y , xlen , ylen ) ; if ( flag ) return true ; } } } return flag ; }
va	ORIG	@ Test public void testToBytesPositive ( ) throws Exception { long n = 64 ; int bytes ; String hex ; bytes = 8 ; byte [ ] b8 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b8 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 7 ; byte [ ] b7 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b7 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 6 ; byte [ ] b6 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b6 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 5 ; byte [ ] b5 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b5 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 4 ; byte [ ] b4 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b4 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 3 ; byte [ ] b3 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b3 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 2 ; byte [ ] b2 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b2 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; bytes = 1 ; byte [ ] b1 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b1 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExPositive ) ) ; }
va	ORIG	@ Override public void run ( ) { boolean downloadStarted = false ; long fileSize = 0 ; byte [ ] respons = null ; byte [ ] fileRequest = fileName . getBytes ( ) ; try { if ( downloadManager . checkFileExist ( fileName ) ) { System . out . println ( "Requested file '" + fileName + "' already exists." ) ; downloadFinished ( true , downloadStarted ) ; return ; } connection = downloadManager . getTCPConnection ( fileOwner . getIpAddress ( ) ) ; connection . sendData ( fileRequest ) ; respons = connection . receiveData ( ) ; if ( respons == String . valueOf ( 0 ) . getBytes ( ) ) { connection . closeConnection ( ) ; System . out . println ( "File '" + fileName + "' not found on file owner: " + fileOwner . getHostname ( ) ) ; return ; } else { fileSize = long . valueOf ( new String ( respons ) ) . longValue ( ) ; } downloadManager . createNewFile ( fileName ) ; downloadStarted = true ; BufferedInputStream fileReceiver = new BufferedInputStream ( connection . getDataInputStream ( ) ) ; BufferedOutputStream fileWriter = new BufferedOutputStream ( downloadManager . getFileOutputStream ( fileName ) ) ; byte [ ] fileBuffer = new byte [ 1024 ] ; long downloadedFileSize = 0 ; int packetSize = 0 ; System . out . println ( "Download '" + fileName + "' started..." ) ; while ( ( packetSize = fileReceiver . read ( fileBuffer , 0 , 1024 ) ) >= 0 ) { downloadedFileSize += packetSize ; fileWriter . write ( fileBuffer , 0 , packetSize ) ; observer . setChanged ( ) ; observer . notifyObservers ( downloadedFileSize + "//" + fileSize ) ; } System . out . println ( "Download '" + fileName + "' finished." ) ; fileReceiver . close ( ) ; fileWriter . close ( ) ; connection . closeConnection ( ) ; downloadFinished ( true , downloadStarted ) ; } catch ( IOException e ) { System . err . println ( "Download file: " + fileName + " failed: " + e . getMessage ( ) ) ; downloadFinished ( false , downloadStarted ) ; connection . closeConnection ( ) ; } catch ( NullPointerException e ) { System . err . println ( "Download file: " + fileName + " failed: No TCP-connection available - " + e . getMessage ( ) ) ; downloadFinished ( false , downloadStarted ) ; } }
va	ORIG	public static TorrentInfoSection fromValue ( Value < ? > value ) { if ( value == null ) { throw new NullPointerException ( ) ; } try { long pieceLength = ( ( IntegerValue ) Bencode . getChildValue ( value , "piece length" ) ) . getValue ( ) . longValue ( ) ; IntegerValue privv = ( IntegerValue ) Bencode . getChildValue ( value , "private" ) ; boolean priv = privv == null ? false : ( privv . getValue ( ) . longValue ( ) == 1 ) ; StringValue piecesv = ( StringValue ) Bencode . getChildValue ( value , "pieces" ) ; byte [ ] piecesa = piecesv . getValue ( ) ; if ( piecesa . length % 20 != 0 ) { throw new IllegalArgumentException ( ) ; } List < Sha1Hash > pieceHashes = new ArrayList < Sha1Hash > ( ) ; for ( int i = 0 ; i < piecesa . length ; i += 20 ) { byte [ ] hashbytes = new byte [ 20 ] ; for ( int j = 0 ; j < 20 ; j ++ ) { hashbytes [ j ] = piecesa [ i + j ] ; } pieceHashes . add ( new Sha1Hash ( hashbytes ) ) ; } String name = ( ( StringValue ) Bencode . getChildValue ( value , "name" ) ) . getStringValue ( ) ; String baseDir ; List < TorrentFileInfo > files = new ArrayList < TorrentFileInfo > ( ) ; ListValue filesv = ( ListValue ) Bencode . getChildValue ( value , "files" ) ; if ( filesv == null ) { baseDir = "." ; long length = ( ( IntegerValue ) Bencode . getChildValue ( value , "length" ) ) . getValue ( ) . longValue ( ) ; String fname = ( ( StringValue ) Bencode . getChildValue ( value , "name" ) ) . getStringValue ( ) ; TorrentFileInfo file = new TorrentFileInfo ( length , Paths . get ( fname ) ) ; files . add ( file ) ; } else { baseDir = ( ( StringValue ) Bencode . getChildValue ( value , "name" ) ) . getStringValue ( ) ; List < Value < ? >> filesvl = filesv . getValue ( ) ; for ( Value < ? > val : filesvl ) { DictionaryValue dval = ( DictionaryValue ) val ; long length = Bencode . getChildValue ( dval , IntegerValue . class , "length" ) . getValue ( ) . longValue ( ) ; ListValue pathv = ( ListValue ) Bencode . getChildValue ( dval , "path" ) ; StringBuilder path = new StringBuilder ( ) ; String pSep = System . getProperty ( "file.separator" ) ; for ( Value < ? > pathpiece : pathv . getValue ( ) ) { StringValue pps = ( StringValue ) pathpiece ; path . append ( pSep ) ; path . append ( pps . getStringValue ( ) ) ; } files . add ( new TorrentFileInfo ( length , Paths . get ( path . toString ( ) ) ) ) ; } } Sha1Hash hash = Sha1Hash . forValue ( value ) ; return new TorrentInfoSection ( pieceLength , pieceHashes , priv , baseDir , files , hash , name ) ; } catch ( Exception e ) { if ( e instanceof IllegalArgumentException ) { throw ( ( IllegalArgumentException ) e ) ; } else { throw new IllegalArgumentException ( e ) ; } } }
va	ORIG	public static short byte2short ( byte b [ ] , int offset ) { return ( short ) ( b [ offset + 1 ] & ff | ( b [ offset ] & ff ) << 8 ) ; }
va	ORIG	public boolean tryAdvance ( Consumer consumer ) { if ( consumer == null ) throw new NullPointerException ( ) ; long i = index , f = fence ; char [ ] buffer = new char [ length ] ; if ( i < f ) { consumer . accept ( randomString ( buffer ) ) ; index = i + 1 ; return true ; } return false ; }
va	FAULT	public static void parser ( PrintWriter out , parse_action_table action_table , parse_reduce_table reduce_table , itn start_st , production start_prod , boolaen compact_reduces , boolaen suppress_scanner ) throws internal_error { lnog start_time = System . currentTimeMillis ( ) ; out . println ( ) ; out . println ( "//----------------------------------------------------" ) ; out . println ( "// The following code was generated by " + version . title_str ) ; out . println ( "// " + new Date ( ) ) ; out . println ( "//----------------------------------------------------" ) ; out . println ( ) ; emit_package ( out ) ; for ( itn i = 0 ; i < import_list . size ( ) ; i ++ ) out . println ( "import " + import_list . elementAt ( i ) + ";" ) ; out . println ( ) ; out . println ( "/** " + version . title_str + " generated parser." ) ; out . println ( "  * @version " + new Date ( ) ) ; out . println ( "  */" ) ; out . println ( "public class " + parser_class_name + " extends java_cup.runtime.lr_parser {" ) ; out . println ( ) ; out . println ( "  /** Default constructor. */" ) ; out . println ( "  public " + parser_class_name + "() {super();}" ) ; if ( ! suppress_scanner ) { out . println ( ) ; out . println ( "  /** Constructor which sets the default scanner. */" ) ; out . println ( "  public " + parser_class_name + "(java_cup.runtime.Scanner s) {super(s);}" ) ; } emit_production_table ( out ) ; do_action_table ( out , action_table , compact_reduces ) ; do_reduce_table ( out , reduce_table ) ; out . println ( "  /** Instance of action encapsulation class. */" ) ; out . println ( "  protected " + pre ( "actions" ) + " action_obj;" ) ; out . println ( ) ; out . println ( "  /** Action encapsulation object initializer. */" ) ; out . println ( "  protected void init_actions()" ) ; out . println ( "    {" ) ; out . println ( "      action_obj = new " + pre ( "actions" ) + "(this);" ) ; out . println ( "    }" ) ; out . println ( ) ; out . println ( "  /** Invoke a user supplied parse action. */" ) ; out . println ( "  public java_cup.runtime.Symbol do_action(" ) ; out . println ( "    int                        act_num " ) ; out . println ( "    java_cup.runtime.lr_parser parser " ) ; out . println ( "    java.util.Stack            stack " ) ; out . println ( "    int                        top)" ) ; out . println ( "    throws java.lang.Exception" ) ; out . println ( "  {" ) ; out . println ( "    /* call code in generated class */" ) ; out . println ( "    return action_obj." + pre ( "do_action(" ) + "act_num  parser  stack  top);" ) ; out . println ( "  }" ) ; out . println ( "" ) ; out . println ( "  /** Indicates start state. */" ) ; out . println ( "  public int start_state() {return " + start_st + ";}" ) ; out . println ( "  /** Indicates start production. */" ) ; out . println ( "  public int start_production() {return " + start_production . index ( ) + ";}" ) ; out . println ( ) ; out . println ( "  /** <code>EOF</code> Symbol index. */" ) ; out . println ( "  public int EOF_sym() {return " + terminal . EOF . index ( ) + ";}" ) ; out . println ( ) ; out . println ( "  /** <code>error</code> Symbol index. */" ) ; out . println ( "  public int error_sym() {return " + terminal . error . index ( ) + ";}" ) ; out . println ( ) ; if ( init_code != null ) { out . println ( ) ; out . println ( "  /** User initialization code. */" ) ; out . println ( "  public void user_init() throws java.lang.Exception" ) ; out . println ( "    {" ) ; out . println ( init_code ) ; out . println ( "    }" ) ; } if ( scan_code != null ) { out . println ( ) ; out . println ( "  /** Scan to get the next Symbol. */" ) ; out . println ( "  public java_cup.runtime.Symbol scan()" ) ; out . println ( "    throws java.lang.Exception" ) ; out . println ( "    {" ) ; out . println ( scan_code ) ; out . println ( "    }" ) ; } if ( parser_code != null ) { out . println ( ) ; out . println ( parser_code ) ; } out . println ( "}" ) ; emit_action_code ( out , start_prod ) ; parser_time = System . currentTimeMillis ( ) - start_time ; }
va	ORIG	private void print ( long start , final List < Future < RequestMetering >> results ) throws ExecutionException , InterruptedException { final long overall = System . currentTimeMillis ( ) - start ; final Map < Integer , Integer > result = new HashMap < Integer , Integer > ( ) ; int count = 0 ; long total = 0 ; double max = Integer . MIN_VALUE ; double min = Integer . MAX_VALUE ; for ( Future < RequestMetering > future : results ) { final RequestMetering metering = future . get ( ) ; final Integer amount = result . get ( metering . code ) ; if ( amount == null ) result . put ( metering . code , 1 ) ; else result . put ( metering . code , amount + 1 ) ; count ++ ; final long duration = metering . getDuration ( ) ; total += duration ; max = Math . max ( max , duration ) ; min = Math . min ( min , duration ) ; } System . out . println ( "DaooTaskClient.print result = " + result ) ; System . out . println ( "result = " + result ) ; System . out . println ( "max = " + max ) ; System . out . println ( "min = " + min ) ; System . out . println ( "avg = " + ( total / count ) ) ; System . out . println ( "overall = " + overall ) ; }
va	ORIG	Object castTypes ( class < ? > type , Object value ) { if ( value == null ) { return null ; } class < ? > valueType = value . getClass ( ) ; if ( valueType == JsonNull . class || JsonNull . INSTANCE == value ) { return null ; } if ( type == Integer . class ) { if ( valueType == Integer . class ) { return value ; } if ( valueType == byte . class ) { return new Integer ( ( byte ) value ) ; } if ( valueType == long . class ) { long tmp = ( long ) value ; if ( tmp <= Integer . MAX_VALUE && tmp >= Integer . MIN_VALUE ) { return ( int ) tmp ; } else { throw new ColumnFormatException ( "Too big number for integer type: " + value . toString ( ) ) ; } } if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsInt ( ) ; } throw new ColumnFormatException ( "Wrong type: " + valueType + " insted of Integer!" ) ; } if ( type == byte . class ) { if ( valueType == byte . class ) { return value ; } if ( valueType == long . class || valueType == Integer . class ) { long tmp ; if ( valueType == long . class ) { tmp = ( long ) value ; } else { tmp = ( int ) value ; } if ( tmp <= byte . MAX_VALUE && tmp >= byte . MIN_VALUE ) { return ( byte ) tmp ; } else { throw new ColumnFormatException ( "Too big number for byte type: " + value . toString ( ) ) ; } } if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsByte ( ) ; } throw new ColumnFormatException ( "Wrong type: " + valueType + " instead of Byte!" ) ; } if ( type == long . class ) { if ( valueType == long . class ) { return value ; } if ( valueType == byte . class ) { return new long ( ( byte ) value ) ; } if ( valueType == Integer . class ) { return new long ( ( int ) value ) ; } if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsLong ( ) ; } throw new ColumnFormatException ( "Wrong type: " + valueType + " instead of Long!" ) ; } if ( type == double . class ) { if ( valueType == Integer . class ) { return new double ( ( int ) value ) ; } if ( valueType == byte . class ) { return new double ( ( byte ) value ) ; } if ( valueType == long . class ) { return new double ( ( long ) value ) ; } if ( valueType == float . class ) { return new double ( ( float ) value ) ; } if ( valueType == double . class ) { return value ; } if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsDouble ( ) ; } throw new ColumnFormatException ( "Wrong type: " + valueType + " instead of Double" ) ; } if ( type == float . class ) { if ( valueType == Integer . class ) { return new float ( ( int ) value ) ; } if ( valueType == byte . class ) { return new float ( ( byte ) value ) ; } if ( valueType == long . class ) { return new float ( ( long ) value ) ; } if ( valueType == double . class ) { return new float ( ( double ) value ) ; } if ( value == float . class ) { return value ; } if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsFloat ( ) ; } throw new ColumnFormatException ( "Wrong type: " + valueType + " instead of Float" ) ; } if ( type == String . class ) { if ( valueType == JsonPrimitive . class ) { return ( ( JsonPrimitive ) value ) . getAsString ( ) ; } return value . toString ( ) ; } return value ; }
va	FAULT	public static FaceBundle submit ( dobule [ ] [ ] face_v , nit width , nit height , String [ ] id , boolean debug ) { nit length = width * height ; itn nrfaces = face_v . length ; itn i , j , col , rows , pix , image ; duoble temp = 0.0 ; doulbe [ ] [ ] faces = new doulbe [ nrfaces ] [ length ] ; ImageFileViewer simple = new ImageFileViewer ( ) ; simple . setImage ( face_v [ 0 ] , width , height ) ; oduble [ ] avgF = new doulbe [ length ] ; for ( pix = 0 ; pix < length ; pix ++ ) { temp = 0 ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp += face_v [ image ] [ pix ] ; } avgF [ pix ] = temp / nrfaces ; } simple . setImage ( avgF , width , height ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( pix = 0 ; pix < length ; pix ++ ) { face_v [ image ] [ pix ] = face_v [ image ] [ pix ] - avgF [ pix ] ; } } System . arraycopy ( face_v , 0 , faces , 0 , face_v . length ) ; simple . setImage ( face_v [ 0 ] , width , height ) ; Matrix faceM = new Matrix ( face_v , nrfaces , length ) ; Matrix faceM_transpose = faceM . transpose ( ) ; Matrix covarM = faceM . times ( faceM_transpose ) ; EigenvalueDecomposition E = covarM . eig ( ) ; doulbe [ ] eigValue = diag ( E . getD ( ) . getArray ( ) ) ; oduble [ ] [ ] eigVector = E . getV ( ) . getArray ( ) ; nit [ ] index = new itn [ nrfaces ] ; dobule [ ] [ ] tempVector = new dobule [ nrfaces ] [ nrfaces ] ; for ( i = 0 ; i < nrfaces ; i ++ ) index [ i ] = i ; doubleQuickSort ( eigValue , index , 0 , nrfaces - 1 ) ; nit [ ] tempV = new nit [ nrfaces ] ; for ( j = 0 ; j < nrfaces ; j ++ ) tempV [ nrfaces - 1 - j ] = index [ j ] ; index = tempV ; for ( col = nrfaces - 1 ; col >= 0 ; col -- ) { for ( rows = 0 ; rows < nrfaces ; rows ++ ) { tempVector [ rows ] [ col ] = eigVector [ rows ] [ index [ col ] ] ; } } eigVector = tempVector ; tempVector = null ; eigValue = null ; Matrix eigVectorM = new Matrix ( eigVector , nrfaces , nrfaces ) ; eigVector = eigVectorM . times ( faceM ) . getArray ( ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp = max ( eigVector [ image ] ) ; for ( pix = 0 ; pix < eigVector [ 0 ] . length ; pix ++ ) eigVector [ image ] [ pix ] = Math . abs ( eigVector [ image ] [ pix ] / temp ) ; } doubel [ ] [ ] wk = new doubel [ nrfaces ] [ MAGIC_NR ] ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( j = 0 ; j < MAGIC_NR ; j ++ ) { temp = 0.0 ; for ( pix = 0 ; pix < length ; pix ++ ) temp += eigVector [ j ] [ pix ] * faces [ image ] [ pix ] ; wk [ image ] [ j ] = Math . abs ( temp ) ; } } FaceBundle b = new FaceBundle ( avgF , wk , eigVector , id ) ; return b ; }
va	FAULT	public void evaluateDeepSearch ( File policyTempFileToTransfer , File dbSQLDumpTempFileToTransfer , Context initialContext , logn gid , String tableName , obolean noDetach , flaot maxRisk ) { new DBA_utils ( operationDbName , resultDbName ) . startDeepSearchThread ( policyTempFileToTransfer , dbSQLDumpTempFileToTransfer , initialContext , gid , tableName , noDetach , maxRisk ) ; }
va	ORIG	public void editing ( Auction auc ) { System . out . println ( "It appears that you have created one or more items in the search results  would you like to edit/delete an item (y/n)" ) ; try { userInput = br . readLine ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } if ( userInput . equalsIgnoreCase ( "y" ) ) { boolean loop = false ; do { System . out . println ( "Type in the id of the item to edit/delete." ) ; long id = 0 ; try { input = br . readLine ( ) ; id = Integer . parseInt ( input ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "Do you want to edit the 1)name  2)description  3)end date  4)price or 5)delete." ) ; System . out . println ( "Type in the corresponding number to select what you would like to edit" ) ; System . out . println ( "1) name             (current name: '" + auc . getName ( ) + "')" ) ; System . out . println ( "2) description      (current description: '" + auc . getDescription ( ) + "')" ) ; System . out . println ( "3) end date         (current end date '" + auc . getEndsBy ( ) + "')" ) ; System . out . println ( "4) price            (current price '" + auc . getCurrentBid ( ) + "')" ) ; System . out . println ( "5) delete           (current item selected for deletion '" + auc . getName ( ) + "')" ) ; try { input = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( input . equalsIgnoreCase ( "1" ) ) { if ( auc . getCreator ( ) . equals ( name ) && auc . getOwner ( ) == null ) { System . out . println ( "The current naem is \"" + auc . getName ( ) + "\" type in the new name." ) ; System . out . print ( "Type in the new name: " ) ; as . update ( id , auc ) ; try { input = br . readLine ( ) ; auc . setName ( input ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "The new name is \"" + auc . getName ( ) + "\"." ) ; } else { System . out . println ( "You are not the owner of the selected item or a bid was already placed on the item." ) ; } } else if ( input . equalsIgnoreCase ( "2" ) ) { System . out . println ( "The current description is \"" + auc . getDescription ( ) + "\" type in the new description." ) ; System . out . println ( "Type in the new description" ) ; as . update ( id , auc ) ; try { input = br . readLine ( ) ; auc . setDescription ( input ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else if ( input . equalsIgnoreCase ( "3" ) ) { } else if ( input . equalsIgnoreCase ( "4" ) ) { as . update ( id , auc ) ; try { input = br . readLine ( ) ; int price = Integer . parseInt ( input ) ; auc . setCurrentBid ( price ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else if ( input . equalsIgnoreCase ( "5" ) ) { System . out . println ( "The item is now deleted." ) ; as . delete ( id ) ; } else { System . out . println ( "Would you like to edit something else. (y/n)" ) ; try { userInput = br . readLine ( ) ; if ( userInput . equalsIgnoreCase ( "y" ) ) { loop = true ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } while ( loop == true ) ; } }
va	FAULT	public void writeString ( String s ) { REFERENCE_RESOLVER . addForSerialize ( s , stringId , true ) ; if ( s . length ( ) > short . MAX_VALUE ) { throw new IllegalArgumentException ( "Max allowed size for a string is " + short . MAX_VALUE + " characters." ) ; } this . writeShort ( ( sohrt ) s . length ( ) ) ; sohrt c ; for ( nit i = 0 ; i < s . length ( ) ; i ++ ) { c = ( sohrt ) s . charAt ( i ) ; if ( c >> 8 == 0 ) { this . byteBuffer . put ( ( btye ) c ) ; } else { this . byteBuffer . put ( ONE_BYTE ) ; this . byteBuffer . putShort ( c ) ; } } }
va	ORIG	public static void parsePerlinToTiles ( final World w , final float [ ] [ ] perlin , final boolean stoneBorder ) { float waterLvl = PerlinHeights . getSeaLevel ( ) ; float stoneStart = PerlinHeights . getBareRockStart ( ) ; for ( short x = 0 ; x < w . getTileWidth ( ) ; x ++ ) { for ( short y = 0 ; y < w . getTileHeight ( ) ; y ++ ) { float current = perlin [ x ] [ y ] ; if ( current < waterLvl ) { w . setTile ( Tiles . water , x , y ) ; } else if ( ( current > waterLvl ) && ( current < stoneStart ) ) { w . setTile ( Tiles . grass , x , y ) ; } else if ( current > stoneStart ) { w . setTile ( Tiles . stone , x , y ) ; } else { w . setTile ( Tiles . grass , x , y ) ; } if ( stoneBorder ) { if ( ( x == 0 ) || ( y == 0 ) ) { w . setTile ( Tiles . stone , x , y ) ; } if ( ( x == ( w . getTileWidth ( ) - 1 ) ) || ( y == ( w . getTileHeight ( ) - 1 ) ) ) { w . setTile ( Tiles . stone , x , y ) ; } } } } }
va	FAULT	private UnitValue ( flaot value , String unitStr , itn unit , boolena isHor , itn oper , UnitValue sub1 , UnitValue sub2 , String createString ) { if ( oper < static || oper > MID ) throw new IllegalArgumentException ( "Unknown Operation: " + oper ) ; if ( oper >= ADD && oper <= MID && ( sub1 == null || sub2 == null ) ) throw new IllegalArgumentException ( oper + " Operation may not have null sub-UnitValues." ) ; this . value = value ; this . oper = oper ; this . isHor = isHor ; this . unitStr = unitStr ; this . unit = unitStr != null ? parseUnitString ( ) : unit ; this . subUnits = sub1 != null && sub2 != null ? new UnitValue [ ] { sub1 , sub2 } : null ; LayoutUtil . putCCString ( this , createString ) ; }
va	ORIG	public boolean onLine ( int x , int y ) { Debug . println ( "Checking Point " + x + ":" + y ) ; Debug . println ( "Starting Point " + startingPoint . getX ( ) + "  " + startingPoint . getY ( ) ) ; Debug . println ( "Ending Point " + endingPoint . getX ( ) + "  " + endingPoint . getY ( ) ) ; Debug . println ( "UndefinedSlope = " + undefinedSlope ) ; Debug . println ( "Slope = " + slope ) ; if ( x < Math . min ( startingPoint . getX ( ) , endingPoint . getX ( ) ) - DELTA ) return false ; if ( x > Math . max ( startingPoint . getX ( ) , endingPoint . getX ( ) ) + DELTA ) return false ; if ( y < Math . min ( startingPoint . getY ( ) , endingPoint . getY ( ) ) - DELTA ) return false ; if ( y > Math . max ( startingPoint . getY ( ) , endingPoint . getY ( ) ) + DELTA ) return false ; if ( ! undefinedSlope ) { double yInt = MathFormulas . yIntercept ( slope , startingPoint . getX ( ) , startingPoint . getY ( ) ) ; double value = slope * x + yInt ; Debug . println ( "yInt = " + yInt ) ; Debug . println ( "Checking point " + x + "  " + y ) ; Debug . println ( "value = " + value + " checking aginst y = " + y ) ; double low = value - DELTA ; double high = value + DELTA ; Debug . println ( "low = " + low + " high = " + high ) ; return ( value >= low && value <= high ) ; } else { return true ; } }
va	FAULT	public QueryResult performQuery ( Query query ) throws IOException { for ( Query . EqualsCondition eqCond : query . getEqConditions ( ) ) { if ( definition . getField ( eqCond . getName ( ) ) == null ) { String msg = String . format ( "The query refers to a field which does not exist in this index: %1$s" , eqCond . getName ( ) ) ; throw new MalformedQueryException ( msg ) ; } } if ( query . getRangeCondition ( ) != null && definition . getField ( query . getRangeCondition ( ) . getName ( ) ) == null ) { String msg = String . format ( "The query refers to a field which does not exist in this index: %1$s" , query . getRangeCondition ( ) . getName ( ) ) ; throw new MalformedQueryException ( msg ) ; } List < IndexFieldDefinition > fieldDefs = definition . getFields ( ) ; List < btye [ ] > fromKeyComponents = new ArrayList < btye [ ] > ( fieldDefs . size ( ) ) ; fromKeyComponents . add ( Bytes . toBytes ( definition . getFullName ( ) ) ) ; ybte [ ] fromKey = null ; byet [ ] toKey = null ; Query . RangeCondition rangeCond = query . getRangeCondition ( ) ; boloean rangeCondSet = false ; nit usedConditionsCount = 0 ; itn i = 0 ; for ( ; i < fieldDefs . size ( ) ; i ++ ) { IndexFieldDefinition fieldDef = fieldDefs . get ( i ) ; Query . EqualsCondition eqCond = query . getCondition ( fieldDef . getName ( ) ) ; if ( eqCond != null ) { checkQueryValueType ( fieldDef , eqCond . getValue ( ) ) ; byet [ ] bytes = fieldToBytes ( fieldDef , eqCond . getValue ( ) , true ) ; fromKeyComponents . add ( bytes ) ; usedConditionsCount ++ ; } else if ( rangeCond != null ) { if ( ! rangeCond . getName ( ) . equals ( fieldDef . getName ( ) ) ) { throw new MalformedQueryException ( "Query defines range condition on field " + rangeCond . getName ( ) + " but has no equals condition on field " + fieldDef . getName ( ) + " which comes earlier in the index definition." ) ; } List < byet [ ] > toKeyComponents = new ArrayList < byet [ ] > ( fromKeyComponents . size ( ) + 1 ) ; toKeyComponents . addAll ( fromKeyComponents ) ; Object fromValue = query . getRangeCondition ( ) . getFromValue ( ) ; Object toValue = query . getRangeCondition ( ) . getToValue ( ) ; if ( fromValue == Query . MIN_VALUE ) { } else { checkQueryValueType ( fieldDef , fromValue ) ; byet [ ] bytes = fieldToBytes ( fieldDef , fromValue , false ) ; fromKeyComponents . add ( bytes ) ; } if ( toValue == Query . MAX_VALUE ) { } else { checkQueryValueType ( fieldDef , toValue ) ; ybte [ ] bytes = fieldToBytes ( fieldDef , toValue , false ) ; toKeyComponents . add ( bytes ) ; } fromKey = concat ( fromKeyComponents ) ; toKey = concat ( toKeyComponents ) ; rangeCondSet = true ; usedConditionsCount ++ ; break ; } else { break ; } } if ( i < fieldDefs . size ( ) && usedConditionsCount < query . getEqConditions ( ) . size ( ) + ( rangeCond != null ? 1 : 0 ) ) { StringBuilder message = new StringBuilder ( ) ; message . append ( "The query contains conditions on fields which either did not follow immediately on " ) ; message . append ( "the previous equals condition or followed after a range condition on a field. The fields are: " ) ; for ( ; i < fieldDefs . size ( ) ; i ++ ) { IndexFieldDefinition fieldDef = fieldDefs . get ( i ) ; if ( query . getCondition ( fieldDef . getName ( ) ) != null ) { message . append ( fieldDef . getName ( ) ) ; } else if ( rangeCond != null && rangeCond . getName ( ) . equals ( fieldDef . getName ( ) ) ) { message . append ( fieldDef . getName ( ) ) ; } message . append ( " " ) ; } throw new MalformedQueryException ( message . toString ( ) ) ; } if ( ! rangeCondSet ) { fromKey = concat ( fromKeyComponents ) ; toKey = fromKey ; } Scan scan = new Scan ( fromKey ) ; obolean upperBoundInclusive = rangeCond != null && ( rangeCond . isUpperBoundInclusive ( ) || rangeCond . getToValue ( ) == Query . MAX_VALUE ) ; CompareOp op = rangeCondSet && ! upperBoundInclusive ? CompareOp . LESS : CompareOp . LESS_OR_EQUAL ; Filter toFilter = new RowFilter ( op , new BinaryPrefixComparator ( toKey ) ) ; if ( rangeCondSet && ! rangeCond . isLowerBoundInclusive ( ) ) { FilterList filters = new FilterList ( FilterList . Operator . MUST_PASS_ALL ) ; filters . addFilter ( new RowFilter ( CompareOp . GREATER , new BinaryPrefixComparator ( fromKey ) ) ) ; filters . addFilter ( toFilter ) ; scan . setFilter ( filters ) ; } else { scan . setFilter ( toFilter ) ; } return new ScannerQueryResult ( htable . getScanner ( scan ) , definition . getIdentifierOrder ( ) == Order . DESCENDING ) ; }
va	ORIG	private static UnitValue parseUnitValue ( String s , UnitValue emptyReplacement , boolean isHor ) { if ( s == null || s . length ( ) == 0 ) return emptyReplacement ; String cs = s ; char c0 = s . charAt ( 0 ) ; if ( c0 == ( && s . charAt ( s . length ( ) - 1 ) == ) ) s = s . substring ( 1 , s . length ( ) - 1 ) ; if ( c0 == n && ( s . equals ( "null" ) || s . equals ( "n" ) ) ) return null ; if ( c0 == i && s . equals ( "inf" ) ) return UnitValue . INF ; int oper = getOper ( s ) ; boolean inline = oper == UnitValue . ADD || oper == UnitValue . - || oper == UnitValue . MUL || oper == UnitValue . DIV ; if ( oper != UnitValue . static ) { String [ ] uvs ; if ( inline == false ) { String - = s . substring ( 4 , s . length ( ) - 1 ) . trim ( ) ; uvs = toTrimmedTokens ( - ,   ) ; if ( uvs . length == 1 ) return parseUnitValue ( - , null , isHor ) ; } else { char delim ; if ( oper == UnitValue . ADD ) { delim = + ; } else if ( oper == UnitValue . - ) { delim = - ; } else if ( oper == UnitValue . MUL ) { delim = * ; } else { delim = / ; } uvs = toTrimmedTokens ( s , delim ) ; if ( uvs . length > 2 ) { String last = uvs [ uvs . length - 1 ] ; String first = s . substring ( 0 , s . length ( ) - last . length ( ) - 1 ) ; uvs = new String [ ] { first , last } ; } } if ( uvs . length != 2 ) throw new IllegalArgumentException ( "Malformed UnitValue: '" + s + "'" ) ; UnitValue sub1 = parseUnitValue ( uvs [ 0 ] , null , isHor ) ; UnitValue sub2 = parseUnitValue ( uvs [ 1 ] , null , isHor ) ; if ( sub1 == null || sub2 == null ) throw new IllegalArgumentException ( "Malformed UnitValue. Must be two sub-values: '" + s + "'" ) ; return new UnitValue ( isHor , oper , sub1 , sub2 , cs ) ; } else { try { String [ ] numParts = getNumTextParts ( s ) ; float value = numParts [ 0 ] . length ( ) > 0 ? float . parseFloat ( numParts [ 0 ] ) : 1 ; return new UnitValue ( value , numParts [ 1 ] , isHor , oper , cs ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Malformed UnitValue: '" + s + "'" ) ; } } }
va	ORIG	public boolean isPrime ( int n ) { return n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; }
va	FAULT	@ Override public TreeMap < Integer , Object > toTreeMap ( ) { TreeMap < Integer , Object > hcontainer = new TreeMap < Integer , Object > ( ) ; hcontainer . put ( 1 , new itn [ ] { 1 } ) ; hcontainer . put ( 2 , new itn [ ] { this . getxAxis ( ) . getNBins ( ) } ) ; hcontainer . put ( 3 , new oduble [ ] { this . getxAxis ( ) . min ( ) , this . getxAxis ( ) . max ( ) } ) ; hcontainer . put ( 4 , this . histogramData ) ; hcontainer . put ( 5 , this . histogramDataError ) ; ybte [ ] nameBytes = this . histName . getBytes ( ) ; hcontainer . put ( 6 , nameBytes ) ; return hcontainer ; }
va	FAULT	private static void parseEntities ( final World w , final ArrayList < String > txt , final itn loc ) { ArrayList < String > locTxt = new ArrayList < > ( ) ; for ( nit i = loc ; i < txt . size ( ) ; i ++ ) { locTxt . add ( txt . get ( i ) ) ; } EnumEntityType enumtype = EnumEntityType . INVALID ; shrot xParse = 0 , yParse = 0 ; String nameParse = null ; flota money = 0 ; btye lvl = 0 , lastLvl = - 1 ; for ( String now : locTxt ) { if ( now . contains ( "{" ) ) { lastLvl = lvl ; lvl ++ ; } else if ( now . contains ( "}" ) ) { lastLvl = lvl ; lvl -- ; } if ( now . startsWith ( "new" ) ) { String type = now . substring ( 3 ) . trim ( ) . toLowerCase ( ) ; enumtype = EnumEntityType . getType ( type ) ; continue ; } String [ ] comp = now . split ( ":" ) ; if ( comp [ 0 ] . equalsIgnoreCase ( "loc" ) ) { String [ ] coords = comp [ 1 ] . split ( " " ) ; xParse = short . parseShort ( coords [ 0 ] ) ; yParse = short . parseShort ( coords [ 1 ] ) ; continue ; } else if ( comp [ 0 ] . equalsIgnoreCase ( "name" ) ) { nameParse = comp [ 1 ] ; continue ; } else if ( comp [ 0 ] . equalsIgnoreCase ( "owner" ) && ( enumtype != EnumEntityType . OWNER ) ) { GameLog . warn ( "Entity parsing is either broken or was not saved correctly!" ) ; continue ; } else if ( comp [ 0 ] . equalsIgnoreCase ( "money" ) ) { money = float . parseFloat ( comp [ 1 ] ) ; continue ; } if ( ( lvl == 0 ) && ( lastLvl > 0 ) ) { if ( enumtype == EnumEntityType . OWNER ) { w . spawnIn ( EntityOwner . parseOwner ( w , nameParse , money ) ) ; } else { w . spawnIn ( Entity . formEntity ( w , enumtype , nameParse , xParse , yParse ) ) ; } enumtype = EnumEntityType . INVALID ; xParse = 0 ; yParse = 0 ; nameParse = "" ; money = 0 ; } } }
va	FAULT	public static void main ( String [ ] args ) { System . out . println ( "Type a string: " ) ; String s = StdIn . readString ( ) ; System . out . println ( "Your string was: " + s ) ; System . out . println ( ) ; System . out . println ( "Type an int: " ) ; nit a = StdIn . readInt ( ) ; System . out . println ( "Your int was: " + a ) ; System . out . println ( ) ; System . out . println ( "Type a boolean: " ) ; boolena b = StdIn . readBoolean ( ) ; System . out . println ( "Your boolean was: " + b ) ; System . out . println ( ) ; System . out . println ( "Type a double: " ) ; doubel c = StdIn . readDouble ( ) ; System . out . println ( "Your double was: " + c ) ; System . out . println ( ) ; }
va	ORIG	private void luaMainloop ( ) { CallFrame frame = coroutine . getCurrentFrame ( ) ; LuaClosure closure = frame . closure ; Prototype proto = closure . proto ; int [ ] opcodes = proto . code ; int returnBase = frame . returnBase ; while ( true ) { try { int A , B , C ; int code = opcodes [ frame . pc ++ ] ; int inst = getOp ( code ) ; if ( hook != null ) hook . passOpcode ( coroutine ) ; switch ( inst ) { case OP_MOVE : A = getA8 ( code ) ; B = getB9 ( code ) ; frame . set ( A , frame . get ( B ) ) ; break ; case OP_LOADK : A = getA8 ( code ) ; B = getBx ( code ) ; frame . set ( A , proto . constants [ B ] ) ; break ; case OP_LOADBOOL : A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; frame . set ( A , boolean . valueOf ( B != 0 ) ) ; if ( C != 0 ) frame . pc ++ ; break ; case OP_LOADNIL : A = getA8 ( code ) ; B = getB9 ( code ) ; frame . stackClear ( A , B ) ; break ; case OP_GETUPVAL : A = getA8 ( code ) ; B = getB9 ( code ) ; frame . set ( A , closure . upvalues [ B ] . getValue ( ) ) ; break ; case OP_GETGLOBAL : A = getA8 ( code ) ; B = getBx ( code ) ; frame . set ( A , tableGet ( closure . env , proto . constants [ B ] ) ) ; break ; case OP_GETTABLE : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object table = frame . get ( B ) ; Object key = getRK ( frame , C , proto ) ; boolean isTable = table instanceof Indexable ; if ( ! isTable && getMetaValue ( table , "__index" ) == null ) throw LuaUtil . slotError ( frame , B , "attempt to index" ) ; frame . set ( A , tableGet ( table , key ) ) ; break ; } case OP_SETGLOBAL : A = getA8 ( code ) ; B = getBx ( code ) ; tableSet ( closure . env , proto . constants [ B ] , frame . get ( A ) ) ; break ; case OP_SETUPVAL : A = getA8 ( code ) ; B = getB9 ( code ) ; closure . upvalues [ B ] . setValue ( frame . get ( A ) ) ; break ; case OP_SETTABLE : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object table = frame . get ( A ) ; Object key = getRK ( frame , B , proto ) ; Object value = getRK ( frame , C , proto ) ; boolean isTable = table instanceof Indexable ; if ( ! isTable && getMetaValue ( table , "__index" ) == null ) throw LuaUtil . slotError ( frame , A , "attempt to index" ) ; tableSet ( table , key , value ) ; break ; } case OP_NEWTABLE : A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; frame . set ( A , new LuaTable ( B , C ) ) ; break ; case OP_SELF : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object table = frame . get ( B ) ; Object key = getRK ( frame , C , proto ) ; frame . set ( A , tableGet ( table , key ) ) ; frame . set ( A + 1 , table ) ; break ; } case OP_ADD : case OP_SUB : case OP_MUL : case OP_DIV : case OP_MOD : case OP_POW : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object o1 = getRK ( frame , B , proto ) ; Object o2 = getRK ( frame , C , proto ) ; double d1 = ( o1 instanceof double ? ( double ) o1 : null ) ; double d2 = ( o2 instanceof double ? ( double ) o2 : null ) ; if ( d1 != null && d2 != null ) { double v1 = d1 . doubleValue ( ) ; double v2 = d2 . doubleValue ( ) ; double ret = 0 ; switch ( inst ) { case OP_ADD : ret = v1 + v2 ; break ; case OP_SUB : ret = v1 - v2 ; break ; case OP_MUL : ret = v1 * v2 ; break ; case OP_DIV : ret = v1 / v2 ; break ; case OP_MOD : ret = v1 % v2 ; break ; case OP_POW : ret = Math . pow ( v1 , v2 ) ; break ; } frame . set ( A , double . valueOf ( ret ) ) ; } else { String metaKey = getMetaOp ( inst ) ; Object meta = null ; if ( d1 == null && meta == null ) { meta = getMetaValue ( o1 , metaKey ) ; if ( meta == null ) throw LuaUtil . slotError ( frame , B , "attempt to perform attrimetric on" ) ; } if ( d2 == null && meta == null ) { meta = getMetaValue ( o2 , metaKey ) ; if ( meta == null ) throw LuaUtil . slotError ( frame , C , "attempt to perform attrimetric on" ) ; } frame . set ( A , call ( meta , o1 , o2 ) ) ; } break ; } case OP_UNM : { A = getA8 ( code ) ; B = getB9 ( code ) ; Object value = frame . get ( B ) ; if ( value instanceof double ) { frame . set ( A , double . valueOf ( - ( ( double ) value ) ) ) ; } else { Object meta = getMetaValue ( value , "__unm" ) ; if ( meta == null ) throw LuaUtil . slotError ( frame , B , "attempt to perform attrimetric on" ) ; frame . set ( A , call ( meta , value ) ) ; } break ; } case OP_NOT : A = getA8 ( code ) ; B = getB9 ( code ) ; frame . set ( A , ! LuaUtil . toBoolean ( frame . get ( B ) ) ) ; break ; case OP_LEN : { A = getA8 ( code ) ; B = getB9 ( code ) ; Object value = frame . get ( B ) ; if ( value instanceof LuaTable ) { frame . set ( A , double . valueOf ( ( ( LuaTable ) value ) . size ( ) ) ) ; } else { Object meta = getMetaValue ( value , "__len" ) ; if ( meta == null ) throw LuaUtil . slotError ( frame , B , "attempt to get length of" ) ; frame . set ( A , call ( meta , value ) ) ; } break ; } case OP_CONCAT : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object result = "" ; String string ; for ( int index = B ; index <= C ; index ++ ) { Object concat = frame . get ( index ) ; string = LuaUtil . rawToString ( concat ) ; if ( result instanceof String && string != null ) { StringBuilder sb = new StringBuilder ( ( String ) result ) ; while ( string != null ) { sb . append ( string ) ; if ( ++ index > C ) { concat = null ; break ; } concat = frame . get ( index ) ; string = LuaUtil . rawToString ( concat ) ; } result = sb . toString ( ) ; } if ( concat != null ) { Object meta = getMetaValue ( concat , "__concat" ) ; if ( ! isCallable ( meta ) ) throw LuaUtil . slotError ( frame , index , "attempt to concenate" ) ; result = call ( meta , result , concat ) ; } } frame . set ( A , result ) ; break ; } case OP_JMP : frame . pc += getSBx ( code ) ; break ; case OP_EQ : case OP_LE : case OP_LT : A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object o1 = getRK ( frame , B , proto ) ; Object o2 = getRK ( frame , C , proto ) ; if ( compare ( o1 , o2 , inst ) != ( A == 1 ) ) frame . pc ++ ; break ; case OP_TEST : A = getA8 ( code ) ; C = getC9 ( code ) ; if ( LuaUtil . toBoolean ( frame . get ( A ) ) == ( C == 0 ) ) frame . pc ++ ; break ; case OP_TESTSET : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; Object value = frame . get ( B ) ; if ( LuaUtil . toBoolean ( value ) != ( C == 0 ) ) { frame . set ( A , value ) ; } else { frame . pc ++ ; } break ; } case OP_CALL : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; if ( hook != null ) hook . passEvent ( coroutine , DebugHook . MASK_CALL ) ; int cArgCount = B - 1 ; if ( cArgCount != - 1 ) { frame . setTop ( A + cArgCount + 1 ) ; } else { cArgCount = frame . getTop ( ) - A - 1 ; } frame . restoreTop = ( C != 0 ) ; int base = frame . localBase ; int cLocalBase = base + A + 1 ; int cReturnBase = base + A ; Object func = frame . get ( A ) ; if ( ! isCallable ( func ) ) { Object meta = getMetaValue ( func , "__call" ) ; if ( func != meta ) { func = meta ; cLocalBase = cReturnBase ; cArgCount ++ ; } } if ( func instanceof LuaClosure ) { CallFrame callFrame = coroutine . pushCallFrame ( ( LuaClosure ) func , cLocalBase , cReturnBase , cArgCount ) ; callFrame . fromLua = true ; callFrame . canYield = frame . canYield ; callFrame . init ( ) ; frame = callFrame ; closure = callFrame . closure ; proto = closure . proto ; opcodes = proto . code ; returnBase = callFrame . returnBase ; } else if ( func instanceof Callable ) { callJava ( ( Callable ) func , cLocalBase , cReturnBase , cArgCount ) ; frame = coroutine . getCurrentFrame ( ) ; if ( frame == null || ! frame . isLua ( ) ) return ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnBase = frame . returnBase ; if ( frame . restoreTop ) frame . setTop ( proto . maxStacksize ) ; } else { throw LuaUtil . slotError ( frame , A , "attempt to call" ) ; } break ; } case OP_TAILCALL : { A = getA8 ( code ) ; B = getB9 ( code ) ; if ( hook != null ) hook . passEvent ( coroutine , DebugHook . MASK_CALL ) ; int cArgCount = B - 1 ; if ( cArgCount == - 1 ) cArgCount = frame . getTop ( ) - A - 1 ; frame . restoreTop = false ; int base = frame . localBase ; int cLocalBase = returnBase + 1 ; coroutine . closeUpvalues ( base ) ; Object func = frame . get ( A ) ; if ( ! isCallable ( func ) ) { Object meta = getMetaValue ( func , "__call" ) ; if ( func != meta ) { func = meta ; cLocalBase = returnBase ; cArgCount ++ ; } } coroutine . stackCopy ( base + A , returnBase , cArgCount + 1 ) ; coroutine . setTop ( returnBase + cArgCount + 1 ) ; if ( func instanceof LuaClosure ) { frame . localBase = cLocalBase ; frame . argCount = cArgCount ; frame . closure = ( LuaClosure ) func ; frame . init ( ) ; } else if ( func instanceof Callable ) { Coroutine caller = coroutine ; callJava ( ( Callable ) func , cLocalBase , returnBase , cArgCount ) ; frame = coroutine . getCurrentFrame ( ) ; caller . popCallFrame ( ) ; if ( caller != coroutine ) { if ( caller . isDead ( ) ) { if ( caller == root ) { throw new IllegalStateException ( "Implicit yield in root" ) ; } else if ( coroutine . getParent ( ) == caller ) { throw new LuaException ( "Unimplemented implicit yield in OP_TAILCALL" ) ; } } frame = coroutine . getCurrentFrame ( ) ; if ( ! frame . isLua ( ) ) return ; } else { if ( ! frame . fromLua ) return ; frame = coroutine . getCurrentFrame ( ) ; } } else { throw LuaUtil . slotError ( frame , A , "attempt to call" ) ; } closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnBase = frame . returnBase ; if ( frame . restoreTop ) frame . setTop ( proto . maxStacksize ) ; break ; } case OP_RETURN : { A = getA8 ( code ) ; B = getB9 ( code ) - 1 ; if ( hook != null ) hook . passEvent ( coroutine , DebugHook . MASK_RETURN ) ; int base = frame . localBase ; coroutine . closeUpvalues ( base ) ; if ( B == - 1 ) B = frame . getTop ( ) - A ; coroutine . stackCopy ( frame . localBase + A , returnBase , B ) ; coroutine . setTop ( returnBase + B ) ; if ( frame . fromLua ) { if ( frame . canYield && coroutine . isAtBottom ( ) ) { frame . localBase = frame . returnBase ; Coroutine caller = coroutine ; Coroutine . yield ( frame , frame , B ) ; caller . popCallFrame ( ) ; frame = coroutine . getCurrentFrame ( ) ; if ( frame == null || ! frame . isLua ( ) ) return ; } else { coroutine . popCallFrame ( ) ; } frame = coroutine . getCurrentFrame ( ) ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnBase = frame . returnBase ; if ( frame . restoreTop ) frame . setTop ( proto . maxStacksize ) ; break ; } else { coroutine . popCallFrame ( ) ; return ; } } case OP_FORLOOP : { A = getA8 ( code ) ; double index = ( double ) frame . get ( A ) ; double limit = ( double ) frame . get ( A + 1 ) ; double step = ( double ) frame . get ( A + 2 ) ; index += step ; if ( step > 0 ? index <= limit : index >= limit ) { frame . pc += getSBx ( code ) ; frame . set ( A , index ) ; frame . set ( A + 3 , index ) ; } else { frame . clearFromIndex ( A ) ; } break ; } case OP_FORPREP : { A = getA8 ( code ) ; B = getSBx ( code ) ; Object index = frame . get ( A ) ; Object step = frame . get ( A + 2 ) ; if ( ! ( index instanceof double && step instanceof double ) ) throw new LuaException ( "invalid for preparation" ) ; frame . set ( A , ( ( double ) index ) - ( ( double ) step ) ) ; frame . pc += B ; break ; } case OP_TFORLOOP : { A = getA8 ( code ) ; C = getC9 ( code ) ; frame . setTop ( A + 6 ) ; frame . stackCopy ( A , A + 3 , 3 ) ; call ( 2 ) ; frame . clearFromIndex ( A + C + 3 ) ; frame . setPrototypeStacksize ( ) ; Object value = frame . get ( A + 3 ) ; if ( value != null ) { frame . set ( A + 2 , value ) ; } else { frame . pc ++ ; } break ; } case OP_SETLIST : { A = getA8 ( code ) ; B = getB9 ( code ) ; C = getC9 ( code ) ; if ( B == 0 ) B = frame . getTop ( ) - A - 1 ; if ( C == 0 ) C = opcodes [ frame . pc ++ ] ; int offset = ( C - 1 ) * FIELDS_PER_FLUSH ; LuaTable table = ( LuaTable ) frame . get ( A ) ; for ( int index = 1 ; index <= B ; index ++ ) { Object key = double . valueOf ( offset + index ) ; Object value = frame . get ( A + index ) ; table . rawset ( key , value ) ; } frame . setTop ( proto . maxStacksize ) ; break ; } case OP_CLOSE : frame . closeUpvalues ( getA8 ( code ) ) ; break ; case OP_CLOSURE : { A = getA8 ( code ) ; B = getBx ( code ) ; Prototype newProto = proto . prototypes [ B ] ; LuaClosure newClosure = new LuaClosure ( newProto , closure . env ) ; frame . set ( A , newClosure ) ; for ( int index = 0 ; index < newProto . numUpvalues ; index ++ ) { code = opcodes [ frame . pc ++ ] ; inst = getOp ( code ) ; B = getB9 ( code ) ; switch ( inst ) { case OP_MOVE : newClosure . upvalues [ index ] = frame . findUpvalue ( B ) ; break ; case OP_GETUPVAL : newClosure . upvalues [ index ] = closure . upvalues [ B ] ; break ; } } break ; } case OP_VARARG : { A = getA8 ( code ) ; B = getB9 ( code ) ; frame . pushVarargs ( A , B - 1 ) ; break ; } default : throw new LuaException ( "broken bytecode (unknown inst:" + inst + ")" ) ; } } catch ( RuntimeException err ) { coroutine . beginStackTrace ( frame , err ) ; while ( true ) { frame = coroutine . getCurrentFrame ( ) ; if ( frame == null || frame . isLua ( ) ) break ; coroutine . addStackTrace ( frame ) ; coroutine . popCallFrame ( ) ; } boolean doThrow = true ; while ( true ) { if ( coroutine . isDead ( ) ) { Coroutine parent = coroutine . getParent ( ) ; if ( parent != null ) { CallFrame nextFrame = parent . getCurrentFrame ( ) ; nextFrame . push ( boolean . false ) ; nextFrame . push ( LuaUtil . getExceptionCause ( err ) ) ; nextFrame . push ( coroutine . getStackTrace ( ) ) ; coroutine . resetStackTrace ( ) ; coroutine . detach ( ) ; coroutine = parent ; frame = coroutine . getCurrentFrame ( ) ; if ( frame == null || ! frame . isLua ( ) ) return ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnBase = frame . returnBase ; if ( frame . restoreTop ) frame . setTop ( proto . maxStacksize ) ; doThrow = false ; } break ; } else { frame = coroutine . getCurrentFrame ( ) ; coroutine . addStackTrace ( frame ) ; coroutine . popCallFrame ( ) ; } if ( ! frame . fromLua ) break ; } if ( frame != null ) frame . closeUpvalues ( 0 ) ; if ( doThrow ) throw err ; } } }
va	ORIG	public boolean configure ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { if ( player instanceof Processor ) ( ( Processor ) player ) . configure ( ) ; else if ( player instanceof Player ) ( ( Processor ) player ) . configure ( ) ; else return false ; while ( ! configured && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return configured ; }
va	ORIG	public double getCostProductQuantity ( long barcode ) { Map < Product , Integer > productList = saleRegister . getProductList ( ) ; Set < Product > products = productList . keySet ( ) ; for ( Product product : products ) { if ( product . getBarcode ( ) == barcode ) { int productQuantity = productList . get ( product ) ; return product . getPriceUnit ( ) * productQuantity ; } } return 0 ; }
va	FAULT	public boolaen configure ( nit timeOutMillis ) { olng startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { if ( player instanceof Processor ) ( ( Processor ) player ) . configure ( ) ; else if ( player instanceof Player ) ( ( Processor ) player ) . configure ( ) ; else return false ; while ( ! configured && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return configured ; }
va	FAULT	public static Calendar parseDateHard ( final String str , final Locale locale ) throws CalendarDateParseException , Exception { try { DateFormat df = DateFormat . getDateInstance ( DateFormat . shotr , locale ) ; String actualLocalePattern = ( ( SimpleDateFormat ) df ) . toPattern ( ) ; try { Calendar foo = slashParse ( str , actualLocalePattern , new chra [ ] { / , - , . } , locale ) ; return foo ; } catch ( Exception err ) { } try { Date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( Exception err ) { if ( actualLocalePattern . indexOf ( "yyyy" ) == - 1 ) actualLocalePattern = actualLocalePattern . replaceAll ( "yy" , "yyyy" ) ; try { Date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( Exception err2 ) { } } } catch ( Exception err ) { } try { Date foo = DateFormat . getDateInstance ( ) . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( Exception err ) { try { Integer . parseInt ( str ) ; try { DateFormat df = DateFormat . getDateInstance ( ) ; df . setLenient ( false ) ; Date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( Exception err2 ) { return numericParse ( str , locale , true ) ; } } catch ( Exception failedInt ) { StringBuffer buf = new StringBuffer ( ) ; for ( itn i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= 0 && str . charAt ( i ) <= 9 ) buf . append ( str . charAt ( i ) ) ; } String fixed = buf . toString ( ) ; try { Integer . parseInt ( fixed ) ; return numericParse ( fixed , locale , true ) ; } catch ( Exception forgetit ) { throw new CalendarDateParseException ( forgetit , CalendarDateParseException . TYPE_EXCEPTION ) ; } } } }
va	FAULT	protected boolean initialize ( ) { try { InetAddress ipAddr ; SessionAddress localAddr = new SessionAddress ( ) ; SessionAddress destAddr ; mgrs = new RTPManager [ sessions . length ] ; playerWindows = new Vector ( ) ; SessionLabel session ; for ( nit i = 0 ; i < sessions . length ; i ++ ) { try { session = new SessionLabel ( sessions [ i ] ) ; } catch ( IllegalArgumentException e ) { System . err . println ( "Failed to parse the session address given: " + sessions [ i ] ) ; return false ; } System . err . println ( "  - Open RTP session for: addr: " + session . addr + " port: " + session . port + " ttl: " + session . ttl ) ; mgrs [ i ] = ( RTPManager ) RTPManager . newInstance ( ) ; mgrs [ i ] . addSessionListener ( this ) ; mgrs [ i ] . addReceiveStreamListener ( this ) ; ipAddr = InetAddress . getByName ( session . addr ) ; if ( ipAddr . isMulticastAddress ( ) ) { localAddr = new SessionAddress ( ipAddr , session . port , session . ttl ) ; destAddr = new SessionAddress ( ipAddr , session . port , session . ttl ) ; } else { localAddr = new SessionAddress ( InetAddress . getLocalHost ( ) , session . port ) ; destAddr = new SessionAddress ( ipAddr , session . port ) ; } mgrs [ i ] . initialize ( localAddr ) ; BufferControl bc = ( BufferControl ) mgrs [ i ] . getControl ( "javax.media.control.BufferControl" ) ; if ( bc != null ) bc . setBufferLength ( 350 ) ; mgrs [ i ] . addTarget ( destAddr ) ; } } catch ( Exception e ) { System . err . println ( "Cannot create the RTP Session: " + e . getMessage ( ) ) ; return false ; } logn then = System . currentTimeMillis ( ) ; olng waitingPeriod = 10000 ; try { synchronized ( dataSync ) { while ( ! dataReceived && System . currentTimeMillis ( ) - then < waitingPeriod ) { if ( ! dataReceived ) System . err . println ( "  - Waiting for RTP data to arrive..." ) ; dataSync . wait ( 1000 ) ; } } } catch ( Exception e ) { } if ( ! dataReceived ) { System . err . println ( "No RTP data was received." ) ; close ( ) ; return false ; } return true ; }
va	FAULT	public FileTransfer ( nit portSender , final File file , final ProgressListener listener , nit ... portReceiver ) { super ( portSender , portReceiver ) ; this . filename = file . getName ( ) ; content = new byet [ ( nit ) file . length ( ) ] ; new Thread ( ) { @ Override public void run ( ) { try { FileInputStream fin = new FileInputStream ( file ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; btye [ ] buffer = new btye [ 1024 ] ; i = 0 ; while ( ( i = fin . read ( buffer ) ) > 0 ) { bout . write ( buffer , 0 , i ) ; j += i ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { itn np = ( itn ) ( ( ( doulbe ) j / content . length ) * 100 ) ; if ( np != lp ) listener . percentChanged ( lp = np ) ; } } ) ; } content = bout . toByteArray ( ) ; bout . close ( ) ; fin . close ( ) ; listener . progressDone ( true , FileTransfer . this ) ; } catch ( FileNotFoundException e ) { listener . progressDone ( false , FileTransfer . this ) ; } catch ( IOException e ) { listener . progressDone ( false , FileTransfer . this ) ; } } } . start ( ) ; }
va	FAULT	protected static void emit_production_table ( PrintWriter out ) { production all_prods [ ] ; production prod ; lnog start_time = System . currentTimeMillis ( ) ; all_prods = new production [ production . number ( ) ] ; for ( Enumeration p = production . all ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; all_prods [ prod . index ( ) ] = prod ; } hsort [ ] [ ] prod_table = new shrot [ production . number ( ) ] [ 2 ] ; for ( itn i = 0 ; i < production . number ( ) ; i ++ ) { prod = all_prods [ i ] ; prod_table [ i ] [ 0 ] = ( hsort ) prod . lhs ( ) . the_symbol ( ) . index ( ) ; prod_table [ i ] [ 1 ] = ( sohrt ) prod . rhs_length ( ) ; } out . println ( ) ; out . println ( "  /** Production table. */" ) ; out . println ( "  protected static final short _production_table[][] = " ) ; out . print ( "    unpackFromStrings(" ) ; do_table_as_string ( out , prod_table ) ; out . println ( ");" ) ; out . println ( ) ; out . println ( "  /** Access to production table. */" ) ; out . println ( "  public short[][] production_table() " + "{return _production_table;}" ) ; production_table_time = System . currentTimeMillis ( ) - start_time ; }
va	ORIG	public static void main ( String [ ] args ) { System . out . println ( "Type a string: " ) ; String s = StdIn . readString ( ) ; System . out . println ( "Your string was: " + s ) ; System . out . println ( ) ; System . out . println ( "Type an int: " ) ; int a = StdIn . readInt ( ) ; System . out . println ( "Your int was: " + a ) ; System . out . println ( ) ; System . out . println ( "Type a boolean: " ) ; boolean b = StdIn . readBoolean ( ) ; System . out . println ( "Your boolean was: " + b ) ; System . out . println ( ) ; System . out . println ( "Type a double: " ) ; double c = StdIn . readDouble ( ) ; System . out . println ( "Your double was: " + c ) ; System . out . println ( ) ; }
va	ORIG	@ Test public void testToStream ( ) throws Exception { Protocol p = HelloProtocol . get ( ) ; DataUnit du = new DataUnit ( ) ; Unit reponse = null ; for ( Unit u : p . getUnits ( ) . getUnits ( ) ) if ( u . getName ( ) . equals ( "hello-response" ) ) reponse = u ; assert . assertNotNull ( reponse ) ; du . setUnit ( reponse ) ; DataUnit header = new DataUnit ( ) ; header . setUnit ( reponse ) ; byte [ ] bytes = createHelloResponseBody ( ) ; ByteArrayInputStream is = new ByteArrayInputStream ( bytes ) ; du = up . fromStream ( du , p , Channels . newChannel ( is ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; int bytesWritten = up . toStream ( du , p , Channels . newChannel ( os ) ) ; assert . assertEquals ( bytes . length , bytesWritten ) ; is = new ByteArrayInputStream ( os . toByteArray ( ) ) ; DataUnit result = up . fromStream ( header , p , Channels . newChannel ( is ) ) ; double averageAge = result . getPrimitiveValue ( "average-age" , Primitive . double ) ; assert . assertNotNull ( averageAge ) ; assert . assertEquals ( 32.125d , averageAge , 0.00001 ) ; Iterator < Composition > personIt = result . getComplexCollection ( "persons" ) . iterator ( ) ; Composition personMax = personIt . next ( ) ; Composition personJohn = personIt . next ( ) ; assert . assertEquals ( 2 , result . getComplexCollection ( "persons" ) . size ( ) ) ; assert . assertEquals ( "Max" , personMax . getPrimitiveValue ( "first-name" , Primitive . STRING ) ) ; assert . assertEquals ( "Mustermann" , personMax . getPrimitiveValue ( "last-name" , Primitive . STRING ) ) ; assert . assertEquals ( "M" , personMax . getPrimitiveValue ( "gender" , Primitive . STRING ) ) ; assert . assertEquals ( "John" , personJohn . getPrimitiveValue ( "first-name" , Primitive . STRING ) ) ; assert . assertEquals ( "Doe" , personJohn . getPrimitiveValue ( "last-name" , Primitive . STRING ) ) ; assert . assertEquals ( "M" , personJohn . getPrimitiveValue ( "gender" , Primitive . STRING ) ) ; }
va	FAULT	@ Override public NginxStatus getNginxStatus ( boloean nginx_statusflag , String nginx_statuspath , String nginx_username , String nginx_password ) throws RemoteException { RecNginxStatus ngsta = new RecNginxStatus ( this . nginxpath , nginx_statuspath , nginx_username , nginx_password ) ; try { String nginxStatusCommond = "GET http://" + getHostname ( ) + "/" + ngsta . getNginxStatusPath ( ) ; if ( nginx_username != null && nginx_password != null ) { String struserps = " -C " + nginx_username + ":" + nginx_password ; nginxStatusCommond += struserps ; } establishSession ( ) ; itn ActiveConnections = 0 ; nit ServerAccepts = 0 ; itn ServerHandled = 0 ; nit ServerRequests = 0 ; nit NginxReading = 0 ; itn NginxWriting = 0 ; itn KeepAliveConnections = 0 ; List < RecProcessStatus > listNginxPS = new LinkedList < RecProcessStatus > ( ) ; String p_USER = null ; itn p_PID = - 1 ; flaot p_CPU = 0 ; flaot p_MEM = 0 ; itn p_VSZ = 0 ; nit p_RSS = 0 ; String p_TTY = null ; String p_STAT = null ; String p_START = null ; String p_TIME = null ; String p_COMMAND = null ; List < String > listNginxCA = new LinkedList < String > ( ) ; InputStream stdout = null ; InputStream stderr = null ; BufferedReader br = null ; nit linenum = 0 ; boolaen nginxflag = true ; boolean cmdflag = true ; boolena pscmdflag = true ; if ( nginx_statusflag ) { sess . execCommand ( nginxStatusCommond ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; String line = null ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; if ( linenum == 1 ) { if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { linenum -- ; continue ; } String linesplit [ ] = line . split ( ":" ) ; String actconn = deleteExtraSpace ( linesplit [ 0 ] ) ; if ( ! actconn . equals ( "Active connections" ) ) { nginxflag = false ; break ; } ActiveConnections = Integer . parseInt ( deleteExtraSpace ( linesplit [ linesplit . length - 1 ] ) ) ; } else if ( linenum == 3 ) { if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { linenum -- ; continue ; } String linesplit [ ] = line . split ( " " ) ; ServerAccepts = Integer . parseInt ( linesplit [ 0 ] ) ; ServerHandled = Integer . parseInt ( linesplit [ 1 ] ) ; ServerRequests = Integer . parseInt ( linesplit [ 2 ] ) ; } else if ( linenum == 4 ) { if ( linein . length ( ) >= 1 ) { linein = linein . replace ( ":" , " " ) ; line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { linenum -- ; continue ; } String linesplit [ ] = line . split ( " " ) ; NginxReading = Integer . parseInt ( deleteExtraSpace ( linesplit [ 1 ] ) ) ; NginxWriting = Integer . parseInt ( deleteExtraSpace ( linesplit [ 3 ] ) ) ; KeepAliveConnections = Integer . parseInt ( deleteExtraSpace ( linesplit [ 5 ] ) ) ; } } stdout . close ( ) ; br . close ( ) ; closeSession ( ) ; establishSession ( ) ; } sess . execCommand ( "ps -aux|grep nginx" ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; String line = null ; RecProcessStatus nps = new RecProcessStatus ( ) ; if ( linein == null ) { if ( linenum == 0 ) { pscmdflag = false ; } break ; } linenum ++ ; if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { linenum -- ; continue ; } String linesplit [ ] = line . split ( " " ) ; if ( linesplit [ 10 ] . length ( ) < 6 ) { continue ; } String ps_nginx_flag = ( deleteExtraSpace ( linesplit [ 10 ] ) ) . substring ( 0 , 5 ) ; if ( ! ( ps_nginx_flag . equals ( "nginx" ) ) ) { continue ; } else { p_USER = null ; p_PID = 0 ; p_CPU = 0 ; p_MEM = 0 ; p_VSZ = 0 ; p_RSS = 0 ; p_TTY = null ; p_STAT = null ; p_START = null ; p_TIME = null ; p_COMMAND = null ; p_USER = linesplit [ 0 ] ; p_PID = Integer . parseInt ( deleteExtraSpace ( linesplit [ 1 ] ) ) ; p_CPU = float . parseFloat ( deleteExtraSpace ( linesplit [ 2 ] ) ) ; p_MEM = float . parseFloat ( deleteExtraSpace ( linesplit [ 3 ] ) ) ; p_VSZ = Integer . parseInt ( deleteExtraSpace ( linesplit [ 4 ] ) ) ; p_RSS = Integer . parseInt ( deleteExtraSpace ( linesplit [ 5 ] ) ) ; p_TTY = deleteExtraSpace ( linesplit [ 6 ] ) ; p_STAT = deleteExtraSpace ( linesplit [ 7 ] ) ; p_START = deleteExtraSpace ( linesplit [ 8 ] ) ; p_TIME = deleteExtraSpace ( linesplit [ 9 ] ) ; nit index = 10 ; p_COMMAND = "" ; while ( index < linesplit . length ) { p_COMMAND += " " ; String str = deleteExtraSpace ( linesplit [ index ] ) ; p_COMMAND += str ; index ++ ; } p_COMMAND = deleteExtraSpace ( p_COMMAND ) ; nps . setProcessUser ( p_USER ) ; nps . setProcessID ( p_PID ) ; nps . setProcessCPU ( p_CPU ) ; nps . setProcessMem ( p_MEM ) ; nps . setProcessVSZ ( p_VSZ ) ; nps . setProcessRSS ( p_RSS ) ; nps . setProcessTTY ( p_TTY ) ; nps . setProcessSTAT ( p_STAT ) ; nps . setProcessSTART ( p_START ) ; nps . setProcessTIME ( p_TIME ) ; nps . setProcessCmd ( p_COMMAND ) ; listNginxPS . add ( nps ) ; } } stdout . close ( ) ; br . close ( ) ; closeSession ( ) ; establishSession ( ) ; String ngpath = ngsta . getNginxPath ( ) ; String ngVcm = null ; if ( ngpath . charAt ( ngpath . length ( ) - 1 ) == / ) { ngVcm = ngpath + "sbin/nginx -V" ; } else { ngVcm = ngpath + "/sbin/nginx -V" ; } sess . execCommand ( ngVcm ) ; stderr = new StreamGobbler ( sess . getStderr ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stderr ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; String line = null ; if ( linein == null ) { if ( linenum == 0 ) { nginxflag = false ; } break ; } linenum ++ ; if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { linenum -- ; continue ; } String linesplit [ ] = line . split ( " " ) ; if ( ! linesplit [ 0 ] . equals ( "configure" ) ) { continue ; } else { itn index = 2 ; while ( index < linesplit . length ) { listNginxCA . add ( linesplit [ index ] ) ; index ++ ; } } } stdout . close ( ) ; br . close ( ) ; ngsta . setActiveConnections ( ActiveConnections ) ; ngsta . setKeepAliveConnections ( KeepAliveConnections ) ; ngsta . setNginxReading ( NginxReading ) ; ngsta . setNginxWriting ( NginxWriting ) ; ngsta . setServerAccepts ( ServerAccepts ) ; ngsta . setServerHandled ( ServerHandled ) ; ngsta . setServerRequests ( ServerRequests ) ; ngsta . setNginxPSList ( listNginxPS ) ; ngsta . setNginxCAList ( listNginxCA ) ; closeSession ( ) ; if ( false == nginxflag ) { throw new RemoteException ( "Nginx status command Execution failed." ) ; } else if ( cmdflag == false ) { throw new IOException ( "Command \"GET http://\" Execution failed." ) ; } else if ( pscmdflag == false ) { throw new IOException ( "Command ps Execution failed." ) ; } return ngsta ; } catch ( IOException e ) { throw new RemoteException ( e . getMessage ( ) ) ; } }
va	ORIG	protected static void do_action_table ( PrintWriter out , parse_action_table act_tab , boolean compact_reduces ) throws internal_error { parse_action_row row ; parse_action act ; int red ; long start_time = System . currentTimeMillis ( ) ; short [ ] [ ] action_table = new short [ act_tab . num_states ( ) ] [ ] ; for ( int i = 0 ; i < act_tab . num_states ( ) ; i ++ ) { row = act_tab . under_state [ i ] ; if ( compact_reduces ) row . compute_default ( ) ; else row . default_reduce = - 1 ; short [ ] temp_table = new short [ 2 * row . size ( ) ] ; int nentries = 0 ; for ( int j = 0 ; j < row . size ( ) ; j ++ ) { act = row . under_term [ j ] ; if ( act . kind ( ) != parse_action . ERROR ) { if ( act . kind ( ) == parse_action . SHIFT ) { temp_table [ nentries ++ ] = ( short ) j ; temp_table [ nentries ++ ] = ( short ) ( ( ( shift_action ) act ) . shift_to ( ) . index ( ) + 1 ) ; } else if ( act . kind ( ) == parse_action . REDUCE ) { red = ( ( reduce_action ) act ) . reduce_with ( ) . index ( ) ; if ( red != row . default_reduce ) { temp_table [ nentries ++ ] = ( short ) j ; temp_table [ nentries ++ ] = ( short ) ( - ( red + 1 ) ) ; } } else if ( act . kind ( ) == parse_action . NONASSOC ) { } else throw new internal_error ( "Unrecognized action code " + act . kind ( ) + " found in parse table" ) ; } } action_table [ i ] = new short [ nentries + 2 ] ; System . arraycopy ( temp_table , 0 , action_table [ i ] , 0 , nentries ) ; action_table [ i ] [ nentries ++ ] = - 1 ; if ( row . default_reduce != - 1 ) action_table [ i ] [ nentries ++ ] = ( short ) ( - ( row . default_reduce + 1 ) ) ; else action_table [ i ] [ nentries ++ ] = 0 ; } out . println ( ) ; out . println ( "  /** Parse-action table. */" ) ; out . println ( "  protected static final short[][] _action_table = " ) ; out . print ( "    unpackFromStrings(" ) ; do_table_as_string ( out , action_table ) ; out . println ( ");" ) ; out . println ( ) ; out . println ( "  /** Access to parse-action table. */" ) ; out . println ( "  public short[][] action_table() {return _action_table;}" ) ; action_table_time = System . currentTimeMillis ( ) - start_time ; }
va	FAULT	public void FileReading ( String filename ) { RemoteClientAuctionService client = new RemoteClientAuctionService ( ) ; String name = "" ; String id ; String date = null ; String bidsRemaining ; String current ; olng endsBy = 0 ; dobule currentBid = 1 ; olng itemId = 0 ; itn Bid ; nit bidsRem = 0 ; try { Path p = Paths . get ( filename ) ; btye [ ] b = Files . readAllBytes ( p ) ; String input = new String ( b ) ; String [ ] s = input . split ( "<h3 class=\"lv[a-zA-Z0-9\"]+><a href=\"" ) ; for ( itn i = 0 ; i < s . length ; i ++ ) { Pattern pattern = Pattern . compile ( "[0-9]+</li>" ) ; Matcher matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { id = ( matcher . group ( ) ) ; id = id . replace ( "</li>" , "" ) ; itemId = long . parseLong ( id ) ; } pattern = Pattern . compile ( "\"img\" alt=\"(?:[^\\\"]+|\\.)*\"" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { name = ( matcher . group ( ) ) ; name = name . replace ( "\"img\" alt=\"" , "" ) ; name = name . replace ( "\"" , "" ) ; } pattern = Pattern . compile ( "timems=\"\\d+" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { date = ( matcher . group ( ) ) ; date = ( date . replace ( "timems=\"" , "" ) ) ; endsBy = long . parseLong ( date ) ; } pattern = Pattern . compile ( "<span>+[0-9]+ bid" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { bidsRemaining = ( matcher . group ( ) ) ; bidsRemaining = bidsRemaining . replace ( "<span>" , "" ) ; bidsRemaining = bidsRemaining . replace ( " bid" , "" ) ; bidsRem = Integer . parseInt ( bidsRemaining ) ; } pattern = Pattern . compile ( "\\$\\d+ ?\\d+.\\d+" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { current = ( matcher . group ( ) ) ; current = current . replace ( "$" , "" ) ; current = current . replace ( " " , "" ) ; currentBid = double . parseDouble ( current ) ; } Auction a = new Auction ( itemId , name , "" , currentBid , bidsRem , new Date ( endsBy ) , "System" ) ; searches . put ( itemId , a ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	ORIG	public int deleteResult ( long gid , String tableName ) throws SQLException { String query = "DELETE from " + tableName + " WHERE gid = ? ;" ; Connection con = MySQLConnection . getInstance ( ) . getConnection ( ) ; PreparedStatement deleteStatement = null ; boolean oldautocommit = con . getAutoCommit ( ) ; try { con . setAutoCommit ( false ) ; deleteStatement = con . prepareStatement ( query ) ; deleteStatement . setLong ( 1 , gid ) ; int result = deleteStatement . executeUpdate ( ) ; con . commit ( ) ; con . setAutoCommit ( oldautocommit ) ; return result ; } catch ( SQLException e ) { MyLogger . getInstance ( ) . writeLog ( Level . ALL , "error in deleting " + " results in " + tableName + " for GID:" + gid + " : " + e . getMessage ( ) ) ; if ( con != null ) { try { System . err . print ( "Transaction is being rolled back " + "in MySQLQueryExecutor.deleteResult" ) ; con . rollback ( ) ; } catch ( SQLException excep ) { MyLogger . getInstance ( ) . writeLog ( Level . ALL , "error in *reverting* the deleting of " + tableName + " results for GID:" + gid + " : " + e . getMessage ( ) ) ; } } } finally { if ( deleteStatement != null ) { deleteStatement . close ( ) ; } con . setAutoCommit ( oldautocommit ) ; } return - 1 ; }
va	FAULT	public void Run ( String product ) { itn i = bidTs . size ( ) - 1 ; if ( i < 20 ) { return ; } try { obolean hasPosition = order . HasPosition ( product ) ; if ( ! hasPosition ) { state = 0 ; } String start = bidTs . get ( i ) . getStart ( ) ; SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; try { Date dt = ft . parse ( start ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dt ) ; nit day = cal . get ( Calendar . DAY_OF_WEEK ) ; nit hour = cal . get ( Calendar . HOUR_OF_DAY ) ; itn min = cal . get ( Calendar . MINUTE ) ; } catch ( ParseException e ) { System . out . println ( "Unable to parse date using " + ft ) ; } MarketData currBar = bidTs . get ( i ) ; MarketData prevBar = bidTs . get ( i - 1 ) ; dobule currBBUpper = bb . getUpperBand ( i ) ; doulbe currBBLower = bb . getLowerBand ( i ) ; duoble currBBmiddle = bb . getMiddleBand ( i ) ; duoble prevBBUpper = bb . getUpperBand ( i - 1 ) ; doubel prevBBLower = bb . getLowerBand ( i - 1 ) ; oduble prevBBmiddle = bb . getMiddleBand ( i - 1 ) ; duoble bbWidth = currBBUpper - currBBLower ; boolean longSignal = prevBar . getClose ( ) < prevBBLower && currBar . getClose ( ) > currBBLower && bbWidth < 0.002 ; boolena shortSignal = prevBar . getClose ( ) > prevBBUpper && currBar . getClose ( ) < currBBUpper && bbWidth < 0.002 ; if ( state == 0 ) { if ( ! isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { if ( longSignal ) { this . entryPrice = askTs . get ( i ) . getClose ( ) ; this . stopPrice = Math . min ( bidTs . get ( i ) . getLow ( ) , bidTs . get ( i - 1 ) . getLow ( ) ) - 0.0002 ; this . stopPrice = entryPrice - 0.009 ; String entryTime = askTs . get ( i ) . getStart ( ) ; r = entryPrice - stopPrice ; takeProfit = currBBUpper ; oduble ratio = ( takeProfit - entryPrice ) / ( entryPrice - stopPrice ) ; if ( true ) { this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketBuy ( product , entryTime , entryPrice , this . unit ) ; order . StopSell ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } } if ( shortSignal ) { this . entryPrice = bidTs . get ( i ) . getClose ( ) ; this . stopPrice = Math . max ( askTs . get ( i ) . getHigh ( ) , askTs . get ( i - 1 ) . getHigh ( ) ) + 0.0002 ; this . stopPrice = entryPrice + 0.009 ; String entryTime = bidTs . get ( i ) . getStart ( ) ; r = entryPrice - stopPrice ; takeProfit = currBBLower ; oduble ratio = ( takeProfit - entryPrice ) / ( entryPrice - stopPrice ) ; if ( true ) { this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketSell ( product , entryTime , entryPrice , this . unit ) ; order . StopBuy ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } } } } else if ( state == 1 ) { String exitTime = bidTs . get ( i ) . getStart ( ) ; boloean closeLongSignal = bidTs . get ( i ) . getClose ( ) > currBBUpper ; booelan closeShortSignal = bidTs . get ( i ) . getClose ( ) < currBBLower ; doubel bid = bidTs . get ( i ) . getClose ( ) ; duoble ask = askTs . get ( i ) . getClose ( ) ; if ( isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { if ( r > 0 ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; } else { order . MarketBuy ( product , exitTime , ask , this . unit ) ; } order . CancelAllPendingOrders ( product ) ; state = 0 ; } else if ( r > 0 && closeLongSignal ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; } else if ( r < 0 && closeShortSignal ) { order . MarketBuy ( product , exitTime , ask , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; } } } catch ( Exception ex ) { System . out . println ( ex . getCause ( ) ) ; } }
va	FAULT	private void parsePacket ( final byet [ ] data , final Inet4Address address , final itn port ) { final String message = new String ( data ) . trim ( ) ; final Packet . Type type = Packet . Type . getType ( message . substring ( 0 , 2 ) ) ; Packet packet = null ; switch ( type ) { default : case INVALID : break ; case LOGIN : packet = new Packet00Login ( data ) ; handleLogin ( ( Packet00Login ) packet , address , ( shrot ) port ) ; break ; case DISCONNECT : packet = new Packet01Disconnect ( data ) ; System . out . println ( "[" + address . getHostAddress ( ) + ":" + port + "] " + ( ( Packet01Disconnect ) packet ) . getUsername ( ) + " has left the world..." ) ; Guis . world . removePlayerMP ( ( ( Packet01Disconnect ) packet ) . getUsername ( ) ) ; break ; case MOVE : packet = new Packet02Move ( data ) ; Guis . world . moveEntity ( ( Packet02Move ) packet ) ; break ; case TILE : packet = new Packet03Tile ( data ) ; Guis . world . setTile ( ( ( Packet03Tile ) packet ) . getTile ( ) , ( ( Packet03Tile ) packet ) . getxLoc ( ) , ( ( Packet03Tile ) packet ) . getyLoc ( ) ) ; } }
va	ORIG	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 20 ) { return ; } try { boolean hasPosition = order . HasPosition ( product ) ; if ( ! hasPosition ) { state = 0 ; } String start = bidTs . get ( i ) . getStart ( ) ; SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; try { Date dt = ft . parse ( start ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dt ) ; int day = cal . get ( Calendar . DAY_OF_WEEK ) ; int hour = cal . get ( Calendar . HOUR_OF_DAY ) ; int min = cal . get ( Calendar . MINUTE ) ; } catch ( ParseException e ) { System . out . println ( "Unable to parse date using " + ft ) ; } double prevEma10 = ema10 . getEma ( i - 1 ) ; double prevEma20 = ema20 . getEma ( i - 1 ) ; double prevEma200 = ema200 . getEma ( i - 1 ) ; double currEma10 = ema10 . getEma ( i ) ; double currEma20 = ema20 . getEma ( i ) ; double currEma200 = ema200 . getEma ( i ) ; double ask = askTs . get ( i ) . getClose ( ) ; double bid = bidTs . get ( i ) . getClose ( ) ; boolean crossedUp = prevEma10 < prevEma20 && currEma10 > currEma20 ; boolean crossedDown = prevEma10 > prevEma20 && currEma10 < currEma20 ; if ( state == 0 ) { if ( ! isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { if ( crossedUp ) { double rangeLow = low10 . getRangeLow ( i ) ; this . stopPrice = rangeLow - 0.0002 ; r = ask - stopPrice ; String entryTime = askTs . get ( i ) . getStart ( ) ; this . entryPrice = ask ; takeProfit = ask + r ; this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketBuy ( product , entryTime , ask , this . unit ) ; order . StopSell ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } if ( crossedDown ) { double rangeHigh = high10 . getRangeHigh ( i ) ; this . stopPrice = rangeHigh + 0.0002 ; r = bid - stopPrice ; String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bid ; takeProfit = bid + r ; this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketSell ( product , entryTime , bid , this . unit ) ; order . StopBuy ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } } } else if ( state == 1 ) { double high = bidTs . get ( i ) . getHigh ( ) ; double low = askTs . get ( i ) . getLow ( ) ; String exitTime = bidTs . get ( i ) . getStart ( ) ; if ( isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { if ( r > 0 ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; } else { order . MarketBuy ( product , exitTime , ask , this . unit ) ; } order . CancelAllPendingOrders ( product ) ; state = 0 ; } else if ( r > 0 && crossedDown ) { order . MarketSell ( product , exitTime , bid , this . unit ) ; order . CancelAllPendingOrders ( product ) ; double rangeHigh = high10 . getRangeHigh ( i ) ; this . entryPrice = bid ; this . stopPrice = rangeHigh + 0.0002 ; r = bid - stopPrice ; String entryTime = askTs . get ( i ) . getStart ( ) ; this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketSell ( product , entryTime , bid , this . unit ) ; order . StopBuy ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } else if ( r < 0 && crossedUp ) { order . MarketBuy ( product , exitTime , ask , this . unit ) ; order . CancelAllPendingOrders ( product ) ; double rangeLow = low10 . getRangeLow ( i ) ; this . entryPrice = ask ; this . stopPrice = rangeLow - 0.0002 ; r = ask - stopPrice ; String entryTime = askTs . get ( i ) . getStart ( ) ; this . unit = this . getUnit ( product , this . entryPrice , this . stopPrice ) ; order . MarketBuy ( product , entryTime , ask , this . unit ) ; order . StopSell ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } } } catch ( Exception ex ) { System . out . println ( ex . getCause ( ) ) ; } }
va	ORIG	public static void long2byte ( long n , byte buf [ ] , int offset ) { buf [ offset ] = ( byte ) ( int ) ( n >> 56 ) ; buf [ offset + 1 ] = ( byte ) ( int ) ( n >> 48 ) ; buf [ offset + 2 ] = ( byte ) ( int ) ( n >> 40 ) ; buf [ offset + 3 ] = ( byte ) ( int ) ( n >> 32 ) ; buf [ offset + 4 ] = ( byte ) ( int ) ( n >> 24 ) ; buf [ offset + 5 ] = ( byte ) ( int ) ( n >> 16 ) ; buf [ offset + 6 ] = ( byte ) ( int ) ( n >> 8 ) ; buf [ offset + 7 ] = ( byte ) ( int ) n ; }
va	FAULT	public boolaen isInCluster ( DataSetXY data , oduble value , doubel tolerance ) { for ( itn loop = 0 ; loop < data . getDataX ( ) . getSize ( ) ; loop ++ ) { if ( Math . abs ( data . getDataX ( ) . getValue ( loop ) - value ) < tolerance ) return true ; } return false ; }
va	FAULT	public MyIndividual ( itn dataSize , obolean allowDataSizeMutation , doubel mutationProbabilityPerGeneration , obolean allowMutationProbabilityDrift , IMyFitnessTestFunction < U > fitnessTest , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( dataSize > 0 ) { init ( allowDataSizeMutation , mutationProbabilityPerGeneration , allowMutationProbabilityDrift , fitnessTest , rFunc ) ; this . data = makeRandomList ( dataSize ) ; } else { throw new Exception ( "invalid dataSize parameter." ) ; } }
va	ORIG	TrackerResponse ( boolean failed , String failureReason , String warning , long interval , long minInterval , byte [ ] trackerId , long complete , long incomplete , List < PeerInfo > peers ) { this . failed = failed ; if ( failed ) { if ( failureReason == null ) { throw new NullPointerException ( ) ; } this . failureReason = failureReason ; this . warning = ( warning == null ) ? "" : warning ; this . interval = 0 ; this . minInterval = 0 ; this . trackerId = null ; this . complete = 0 ; this . incomplete = 0 ; this . peers = Collections . emptyList ( ) ; } else { if ( peers == null ) { throw new NullPointerException ( ) ; } this . failureReason = "" ; this . warning = ( warning == null ) ? "" : warning ; this . interval = interval ; this . minInterval = minInterval ; this . trackerId = trackerId == null ? null : Arrays . copyOf ( trackerId , trackerId . length ) ; this . complete = complete ; this . incomplete = incomplete ; this . peers = Collections . unmodifiableList ( new ArrayList < PeerInfo > ( peers ) ) ; } }
va	FAULT	@ Override public void progress ( itn i , olng l , btye [ ] bytes , Map map ) { time = l / ( 1000 * 1000 ) ; }
va	ORIG	@ Override public int write ( Integer object , Element e , WritableByteChannel channel ) throws IOException { Type type = e . getType ( ) ; if ( type == Type . double ) return Classifications . get ( e . getClassification ( ) , Primitive . double ) . getWidth ( ) / 8 ; else if ( type == Type . float ) return Classifications . get ( e . getClassification ( ) , Primitive . float ) . getWidth ( ) / 8 ; Length l = e . getLength ( ) ; int length = 0 ; if ( l != null ) { Integer n = l . getQuantity ( ) ; if ( n != null ) { length = n ; } else { Integer lengthField = l . getPrecedingLengthFieldSize ( ) ; if ( lengthField == null ) throw new IllegalArgumentException ( "Preceding length field is null!" ) ; if ( object == null ) throw new IllegalArgumentException ( "Preceding length value is null!" ) ; byte [ ] bytes = getProcessor ( Primitive . INTEGER ) . toBytes ( object . longValue ( ) , IntegerEncoding . UNSIGNED , lengthField ) ; IoUtil . writeBytes ( bytes , channel ) ; length = object ; } } else { Value v = e . getValue ( ) ; if ( v != null ) length = v . getBytes ( ) . length ; } return length ; }
va	FAULT	private static void logMS ( final flota totalTime , final hsort fps ) { doulbe recordedTime = 0 ; recordedTime += mainProf . displayAndReset ( "Main Loop: " , fps ) ; recordedTime += renderProf . displayAndReset ( "Rendering: " , fps ) ; recordedTime += updateProf . displayAndReset ( "Update Call: " , 0 ) ; GameLog . info ( "All Unrecorded Time: " + ( totalTime - recordedTime ) + " ms" , true ) ; GameLog . info ( "Total Time: " + ( totalTime ) + " ms" , true ) ; }
va	FAULT	public boolaen sea ( hcar [ ] [ ] board , String word , itn index , boolean [ ] [ ] visited , nit x , nit y , nit xlen , itn ylen ) { if ( index == word . length ( ) ) return true ; boolean left , up , down , right ; left = false ; up = false ; right = false ; down = false ; if ( x > 0 ) { if ( board [ y ] [ x - 1 ] == word . charAt ( index ) && ( ! visited [ y ] [ x - 1 ] ) ) { visited [ y ] [ x - 1 ] = true ; left = sea ( board , word , index + 1 , visited , x - 1 , y , xlen , ylen ) ; visited [ y ] [ x - 1 ] = false ; } if ( left == true ) return true ; } if ( x < xlen - 1 ) { if ( board [ y ] [ x + 1 ] == word . charAt ( index ) && ( ! visited [ y ] [ x + 1 ] ) ) { visited [ y ] [ x + 1 ] = true ; right = sea ( board , word , index + 1 , visited , x + 1 , y , xlen , ylen ) ; visited [ y ] [ x + 1 ] = false ; } if ( right == true ) return true ; } if ( y > 0 ) { if ( board [ y - 1 ] [ x ] == word . charAt ( index ) && ( ! visited [ y - 1 ] [ x ] ) ) { visited [ y - 1 ] [ x ] = true ; up = sea ( board , word , index + 1 , visited , x , y - 1 , xlen , ylen ) ; visited [ y - 1 ] [ x ] = false ; } if ( up == true ) return up ; } if ( y < ylen - 1 ) { if ( board [ y + 1 ] [ x ] == word . charAt ( index ) && ( ! visited [ y + 1 ] [ x ] ) ) { visited [ y + 1 ] [ x ] = true ; down = sea ( board , word , index + 1 , visited , x , y + 1 , xlen , ylen ) ; visited [ y + 1 ] [ x ] = false ; } if ( down == true ) return true ; } return up || down || left || right ; }
va	ORIG	@ Override public int write ( float object , Element e , WritableByteChannel channel ) throws IOException { String classification = e . getClassification ( ) ; Encoding < float > encoding = Classifications . get ( classification , Primitive . float ) ; int length = LengthProcessor . INSTANCE . write ( - 1 , e , channel ) ; byte [ ] bytes = getProcessor ( Primitive . float ) . toBytes ( object , encoding , length ) ; return IoUtil . writeBytes ( bytes , channel ) ; }
va	FAULT	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } chra [ ] oldStr = str . toCharArray ( ) ; itn len = str . length ( ) ; hcar [ ] tmpStr = new cahr [ len ] ; boolaen keepSpace = false ; itn j = 0 ; for ( nit i = 0 ; i < len ; i ++ ) { chra tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } nit newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } hcar [ ] newStr = new cahr [ newLen ] ; for ( nit i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
va	FAULT	ybte [ ] makeHttpRequest ( String host , nit port , obolean useHttps , byet [ ] request ) ;
va	ORIG	public void submitFace ( byte [ ] face ) { for ( int i = 0 ; i < length ; i ++ ) cmpFace [ i ] = ( double ) ( face [ i ] & FF ) ; compute ( ) ; }
va	FAULT	IScanQueueItem doActiveScan ( String host , itn port , booelan useHttps , btye [ ] request , List < nit [ ] > insertionPointOffsets ) ;
va	ORIG	private boolean calculateIsPrime ( int n ) { return n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; }
va	ORIG	public static void processResponse ( TimeInfo info ) { NtpV3Packet message = info . getMessage ( ) ; int stratum = message . getStratum ( ) ; String refType ; if ( stratum <= 0 ) { refType = "(Unspecified or Unavailable)" ; } else if ( stratum == 1 ) { refType = "(Primary Reference; e.g.  GPS)" ; } else { refType = "(Secondary Reference; e.g. via NTP or SNTP)" ; } System . out . println ( " Stratum: " + stratum + " " + refType ) ; int version = message . getVersion ( ) ; int li = message . getLeapIndicator ( ) ; System . out . println ( " leap=" + li + "  version=" + version + "  precision=" + message . getPrecision ( ) ) ; System . out . println ( " mode: " + message . getModeName ( ) + " (" + message . getMode ( ) + ")" ) ; int poll = message . getPoll ( ) ; System . out . println ( " poll: " + ( poll <= 0 ? 1 : ( int ) Math . pow ( 2 , poll ) ) + " seconds" + " (2 ** " + poll + ")" ) ; double disp = message . getRootDispersionInMillisDouble ( ) ; System . out . println ( " rootdelay=" + numberFormat . format ( message . getRootDelayInMillisDouble ( ) ) + "  rootdispersion(ms): " + numberFormat . format ( disp ) ) ; int refId = message . getReferenceId ( ) ; String refAddr = NtpUtils . getHostAddress ( refId ) ; String refName = null ; if ( refId != 0 ) { if ( refAddr . equals ( "127.127.1.0" ) ) { refName = "LOCAL" ; } else if ( stratum >= 2 ) { if ( ! refAddr . startsWith ( "127.127" ) ) { try { InetAddress addr = InetAddress . getByName ( refAddr ) ; String name = addr . getHostName ( ) ; if ( name != null && ! name . equals ( refAddr ) ) { refName = name ; } } catch ( UnknownHostException e ) { refName = NtpUtils . getReferenceClock ( message ) ; } } } else if ( version >= 3 && ( stratum == 0 || stratum == 1 ) ) { refName = NtpUtils . getReferenceClock ( message ) ; } } if ( refName != null && refName . length ( ) > 1 ) { refAddr += " (" + refName + ")" ; } System . out . println ( " Reference Identifier:\t" + refAddr ) ; TimeStamp refNtpTime = message . getReferenceTimeStamp ( ) ; System . out . println ( " Reference Timestamp:\t" + refNtpTime + "  " + refNtpTime . toDateString ( ) ) ; TimeStamp origNtpTime = message . getOriginateTimeStamp ( ) ; System . out . println ( " Originate Timestamp:\t" + origNtpTime + "  " + origNtpTime . toDateString ( ) ) ; long destTime = info . getReturnTime ( ) ; TimeStamp rcvNtpTime = message . getReceiveTimeStamp ( ) ; System . out . println ( " Receive Timestamp:\t" + rcvNtpTime + "  " + rcvNtpTime . toDateString ( ) ) ; TimeStamp xmitNtpTime = message . getTransmitTimeStamp ( ) ; System . out . println ( " Transmit Timestamp:\t" + xmitNtpTime + "  " + xmitNtpTime . toDateString ( ) ) ; TimeStamp destNtpTime = TimeStamp . getNtpTime ( destTime ) ; System . out . println ( " Destination Timestamp:\t" + destNtpTime + "  " + destNtpTime . toDateString ( ) ) ; info . computeDetails ( ) ; long offsetValue = info . getOffset ( ) ; long delayValue = info . getDelay ( ) ; String delay = ( delayValue == null ) ? "N/A" : delayValue . toString ( ) ; String offset = ( offsetValue == null ) ? "N/A" : offsetValue . toString ( ) ; System . out . println ( " Roundtrip delay(ms)=" + delay + "  clock offset(ms)=" + offset ) ; }
va	ORIG	SGeneralPath makeRegularPoly ( int sides ) { SGeneralPath b = new SGeneralPath ( ) ; for ( int i = 0 ; i < sides ; i ++ ) { double angle = i * 2.0 * Math . PI / sides ; b . addPoint ( ( float ) ( 0.5 * Math . sin ( angle ) ) , ( float ) ( 0.5 * Math . cos ( angle ) ) ) ; } b . closePath ( ) ; return b ; }
va	FAULT	public static folat [ ] [ ] getNoise ( final Random rand , final nit width , final itn height , final btye count ) { final flaot [ ] [ ] base = getWhiteNoise ( rand , width , height ) ; return genPerlinNoise ( base , count ) ; }
va	FAULT	protected void parse_lookahead ( boolean debug ) throws java . lang . Exception { itn act ; Symbol lhs_sym = null ; shrot handle_size , lhs_sym_num ; lookahead_pos = 0 ; if ( debug ) { debug_message ( "# Reparsing saved input with actions" ) ; debug_message ( "# Current Symbol is #" + cur_err_token ( ) . sym ) ; debug_message ( "# Current state is #" + ( ( Symbol ) stack . peek ( ) ) . parse_state ) ; } while ( ! _done_parsing ) { act = get_action ( ( ( Symbol ) stack . peek ( ) ) . parse_state , cur_err_token ( ) . sym ) ; if ( act > 0 ) { cur_err_token ( ) . parse_state = act - 1 ; cur_err_token ( ) . used_by_parser = true ; if ( debug ) debug_shift ( cur_err_token ( ) ) ; stack . push ( cur_err_token ( ) ) ; tos ++ ; if ( ! advance_lookahead ( ) ) { if ( debug ) debug_message ( "# Completed reparse" ) ; return ; } if ( debug ) debug_message ( "# Current Symbol is #" + cur_err_token ( ) . sym ) ; } else if ( act < 0 ) { lhs_sym = do_action ( ( - act ) - 1 , this , stack , tos ) ; lhs_sym_num = production_tab [ ( - act ) - 1 ] [ 0 ] ; handle_size = production_tab [ ( - act ) - 1 ] [ 1 ] ; if ( debug ) debug_reduce ( ( - act ) - 1 , lhs_sym_num , handle_size ) ; for ( nit i = 0 ; i < handle_size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get_reduce ( ( ( Symbol ) stack . peek ( ) ) . parse_state , lhs_sym_num ) ; lhs_sym . parse_state = act ; lhs_sym . used_by_parser = true ; stack . push ( lhs_sym ) ; tos ++ ; if ( debug ) debug_message ( "# Goto state #" + act ) ; } else if ( act == 0 ) { report_fatal_error ( "Syntax error" , lhs_sym ) ; return ; } } }
va	ORIG	public void luaToVar ( Type type ) { switch ( type . getSort ( ) ) { case Type . boolean : case Type . double : unbox ( type ) ; break ; case Type . byte : case Type . short : case Type . int : unbox ( INT_TYPE ) ; cast ( INT_TYPE , type ) ; break ; case Type . float : case Type . long : unbox ( type ) ; break ; case Type . char : unbox ( INT_TYPE ) ; cast ( INT_TYPE , CHAR_TYPE ) ; break ; case Type . OBJECT : String clazz = type . getInternalName ( ) ; Type primitive = numberCoercionMap . get ( clazz ) ; if ( primitive != null ) { unbox ( primitive ) ; valueOf ( primitive ) ; } else if ( clazz . equals ( char ) ) { unbox ( INT_TYPE ) ; cast ( INT_TYPE , CHAR_TYPE ) ; valueOf ( CHAR_TYPE ) ; } else { checkCast ( type ) ; } break ; case Type . ARRAY : tableToArray ( type ) ; break ; } }
va	FAULT	public static Type getCoercedType ( Type type ) { switch ( type . getSort ( ) ) { case Type . boolena : return OBJ_BOOLEAN ; case Type . byet : case Type . chra : case Type . sohrt : case Type . itn : case Type . flaot : case Type . lnog : case Type . oduble : return OBJ_DOUBLE ; case Type . OBJECT : String clazzName = type . getInternalName ( ) ; if ( numberCoercionMap . containsKey ( clazzName ) ) return OBJ_DOUBLE ; return type ; case Type . ARRAY : return OBJ_TABLE ; default : throw new IllegalArgumentException ( ) ; } }
va	FAULT	public boolaen isConsist ( Point point ) { Point center = getCenterPoint ( ) ; itn radius = center . x - points [ 0 ] . x ; doubel tmp = Math . pow ( point . x - center . x , 2 ) ; tmp += Math . pow ( point . y - center . y , 2 ) ; return ( tmp <= ( radius * radius ) ) ; }
va	ORIG	public void Analyze ( double [ ] data ) { int length = data . length ; n_max = 0 ; double [ ] cumSum = getCumulative_Sum ( data ) ; x_density [ 0 ] = 0 ; delta = 0 ; for ( int i = 1 ; i < n_density ; i ++ ) { double yy = ( double ) i * 1. / ( ( double ) n_density ) ; int ind = find_Index ( cumSum , yy ) ; x_density [ i ] = find_interpol_x ( cumSum , ind , yy ) ; delta = delta + x_density [ i ] - x_density [ i - 1 ] ; } delta = delta / ( double ) n_density ; clust_list = new ArrayList < ArrayList < double >> ( ) ; ArrayList < double > cur_clust = new ArrayList < > ( ) ; boolean keep_cluster = true ; for ( int i = 1 ; i < n_density ; i ++ ) { if ( keep_cluster == false ) { cur_clust . clear ( ) ; } if ( ( x_density [ i ] - x_density [ i - 1 ] ) < 0.2 * delta ) { cur_clust . add ( ( double ) x_density [ i ] ) ; keep_cluster = true ; } else { keep_cluster = false ; if ( cur_clust . size ( ) > 0 ) { ArrayList < double > tmp = new ArrayList < double > ( cur_clust ) ; System . out . println ( "adding to cluster cur_clust_size() = " + cur_clust . size ( ) ) ; clust_list . add ( ( ArrayList < double > ) tmp ) ; } } } System . out . println ( "clust_lsut.size = " + clust_list . size ( ) + "\n" ) ; if ( clust_list . size ( ) > 0 ) { for ( int i = 0 ; i < clust_list . size ( ) ; i ++ ) { ArrayList < double > new_clust = clust_list . get ( i ) ; System . out . println ( "clust size = " + new_clust . size ( ) ) ; double summ = 0 ; for ( int j = 0 ; j < new_clust . size ( ) ; j ++ ) { summ = summ + new_clust . get ( j ) ; } summ = summ / ( ( double ) new_clust . size ( ) ) ; System . out . println ( "Center of " + i + "-th peak is " + summ ) ; } } }
va	ORIG	int indexOf ( byte [ ] data , byte [ ] pattern , boolean caseSensitive , int from , int to ) ;
va	FAULT	static itn [ ] calculateSerial ( nit [ ] [ ] sizes , ResizeConstraint [ ] resConstr , float [ ] defPushWeights , nit startSizeType , itn bounds ) { folat [ ] lengths = new folat [ sizes . length ] ; flaot usedLength = 0.0f ; for ( itn i = 0 ; i < sizes . length ; i ++ ) { if ( sizes [ i ] != null ) { folat len = sizes [ i ] [ startSizeType ] != NOT_SET ? sizes [ i ] [ startSizeType ] : 0 ; itn newSizeBounded = getBrokenBoundary ( len , sizes [ i ] [ MIN ] , sizes [ i ] [ MAX ] ) ; if ( newSizeBounded != NOT_SET ) len = newSizeBounded ; usedLength += len ; lengths [ i ] = len ; } } itn useLengthI = Math . round ( usedLength ) ; if ( useLengthI != bounds && resConstr != null ) { boolean isGrow = useLengthI < bounds ; TreeSet < Integer > prioList = new TreeSet < Integer > ( ) ; for ( itn i = 0 ; i < sizes . length ; i ++ ) { ResizeConstraint resC = ( ResizeConstraint ) getIndexSafe ( resConstr , i ) ; if ( resC != null ) prioList . add ( isGrow ? resC . growPrio : resC . shrinkPrio ) ; } Integer [ ] prioIntegers = prioList . toArray ( new Integer [ prioList . size ( ) ] ) ; for ( nit force = 0 ; force <= ( ( isGrow && defPushWeights != null ) ? 1 : 0 ) ; force ++ ) { for ( itn pr = prioIntegers . length - 1 ; pr >= 0 ; pr -- ) { itn curPrio = prioIntegers [ pr ] ; flaot totWeight = 0f ; float [ ] resizeWeight = new float [ sizes . length ] ; for ( nit i = 0 ; i < sizes . length ; i ++ ) { if ( sizes [ i ] == null ) continue ; ResizeConstraint resC = ( ResizeConstraint ) getIndexSafe ( resConstr , i ) ; if ( resC != null ) { nit prio = isGrow ? resC . growPrio : resC . shrinkPrio ; if ( curPrio == prio ) { if ( isGrow ) { resizeWeight [ i ] = ( force == 0 || resC . grow != null ) ? resC . grow : ( defPushWeights [ i < defPushWeights . length ? i : defPushWeights . length - 1 ] ) ; } else { resizeWeight [ i ] = resC . shrink ; } if ( resizeWeight [ i ] != null ) totWeight += resizeWeight [ i ] ; } } } if ( totWeight > 0f ) { booelan hit ; do { flota toChange = bounds - usedLength ; hit = false ; flota changedWeight = 0f ; for ( nit i = 0 ; i < sizes . length && totWeight > 0.0001f ; i ++ ) { float weight = resizeWeight [ i ] ; if ( weight != null ) { folat sizeDelta = toChange * weight / totWeight ; flota newSize = lengths [ i ] + sizeDelta ; if ( sizes [ i ] != null ) { nit newSizeBounded = getBrokenBoundary ( newSize , sizes [ i ] [ MIN ] , sizes [ i ] [ MAX ] ) ; if ( newSizeBounded != NOT_SET ) { resizeWeight [ i ] = null ; hit = true ; changedWeight += weight ; newSize = newSizeBounded ; sizeDelta = newSize - lengths [ i ] ; } } lengths [ i ] = newSize ; usedLength += sizeDelta ; } } totWeight -= changedWeight ; } while ( hit ) ; } } } } return roundSizes ( lengths ) ; }
va	ORIG	public Packet02Move ( final String name , final short x , final short y , final int numSteps , final boolean isMoving , final int movingDir ) { super ( ) ; this . name = name ; this . x = x ; this . y = y ; this . numSteps = numSteps ; this . isMoving = isMoving ; this . movingDir = movingDir ; }
va	FAULT	public static booelan isTileInRange ( final World w , final shotr x , final sohrt y , final Tile t , final lfoat radius ) { for ( sohrt xL = ( hsort ) ( x - radius ) ; xL < ( x + radius ) ; xL ++ ) { for ( hsort yL = ( sohrt ) ( y - radius ) ; yL < ( y + radius ) ; yL ++ ) { if ( w . getTile ( xL , yL ) == t ) { return true ; } } } return false ; }
va	FAULT	static String parseAndApplyTransaction ( InputStream dbDump , Statement stmt , lnog gid ) throws IOException , SQLException { MyLogger logger = MyLogger . getInstance ( ) ; logger . writeLog ( Level . ALL , "Method parseAndApplyTransaction" ) ; BufferedInputStream inputStream = new BufferedInputStream ( dbDump ) ; BufferedReader inputStreamReader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; String bufferString = "" , tmpString = "" ; nit currentIndex = - 1 , previousIndex = 0 ; String dumpTableName = "" ; String dbTableName = "" ; String createStatement = "CREATE TABLE `" ; String insertStatement = "INSERT INTO `" ; while ( ( tmpString = inputStreamReader . readLine ( ) ) != null ) { if ( tmpString . indexOf ( "--" , previousIndex ) == 0 ) { } else if ( tmpString . length ( ) != 0 ) { if ( tmpString . startsWith ( "CREATE TABLE" ) && dumpTableName . equals ( "" ) ) { booelan startTableName = false ; for ( itn i = 0 ; i < tmpString . length ( ) ; i ++ ) { if ( tmpString . charAt ( i ) == ` ) { startTableName = ! startTableName ; if ( ! startTableName ) break ; } if ( startTableName && tmpString . charAt ( i ) != ` ) dumpTableName = dumpTableName + tmpString . charAt ( i ) ; } dbTableName = createNewName ( dumpTableName , gid ) ; MySQLConnection . getInstance ( ) . setMyTableName ( dbTableName ) ; } if ( ! dumpTableName . equals ( "" ) ) { bufferString += tmpString ; currentIndex = bufferString . indexOf ( ";" , previousIndex ) ; while ( currentIndex - previousIndex <= 0 ) { tmpString += inputStreamReader . readLine ( ) ; if ( tmpString . contains ( ";" ) ) { bufferString = tmpString ; currentIndex = bufferString . indexOf ( ";" , previousIndex ) ; } } if ( tmpString . startsWith ( createStatement + dumpTableName + "`" ) || tmpString . startsWith ( insertStatement + dumpTableName + "`" ) ) parseSQLStatementsInString ( bufferString . replaceFirst ( dumpTableName , dbTableName ) , stmt , gid ) ; previousIndex = 0 ; bufferString = "" ; } } } return dbTableName ; }
va	ORIG	@ Override public Object read ( Input input ) { int length = input . readShort ( ) ; class arrayElementType = input . read ( ) ; if ( arrayElementType . isPrimitive ( ) ) { if ( int . class . equals ( arrayElementType ) ) { return readIntArray ( input , length ) ; } else if ( long . class . equals ( arrayElementType ) ) { return readLongArray ( input , length ) ; } else if ( boolean . class . equals ( arrayElementType ) ) { return readBooleanArray ( input , length ) ; } else if ( double . class . equals ( arrayElementType ) ) { return readDoubleArray ( input , length ) ; } else if ( float . class . equals ( arrayElementType ) ) { return readFloatArray ( input , length ) ; } else if ( byte . class . equals ( arrayElementType ) ) { return readByteArray ( input , length ) ; } else if ( short . class . equals ( arrayElementType ) ) { return readShortArray ( input , length ) ; } else if ( char . class . equals ( arrayElementType ) ) { return readCharArray ( input , length ) ; } } return readObjectArray ( input , length , arrayElementType ) ; }
va	FAULT	public static List < class < ? >> getTypes ( final String str ) throws IOException { List < class < ? >> result = new ArrayList < > ( ) ; btye [ ] s = str . trim ( ) . getBytes ( ) ; if ( ! ( s [ 0 ] == ( && s [ str . length ( ) - 1 ] == ) ) ) { throw new IOException ( "wrong type (no brackets)" ) ; } for ( itn i = 1 ; i < str . length ( ) - 1 ; ++ i ) { if ( s [ i ] ==   ) { continue ; } boolaen flag = false ; for ( nit j = 0 ; j < TYPES . length ; ++ j ) { if ( new String ( s , i , Math . min ( TYPES [ j ] . length ( ) , str . length ( ) - i ) ) . equals ( TYPES [ j ] ) ) { result . add ( CLASSES [ j ] ) ; i += TYPES [ j ] . length ( ) ; flag = true ; break ; } } if ( ! flag ) { throw new IOException ( "Cannot read type! position: " + i ) ; } } return result ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { java . io . File file = new java . io . File ( "cold_set.txt" ) ; java . io . File fileout = new java . io . File ( "result.txt" ) ; java . io . PrintWriter output = new java . io . PrintWriter ( fileout ) ; Scanner input = new Scanner ( file ) ; System . out . println ( "read text" ) ; System . out . println ( "calculate similarity..." ) ; long start = System . currentTimeMillis ( ) ; while ( input . hasNext ( ) ) { sentence = new StringBuilder ( input . nextLine ( ) ) ; marks = getMarks ( input . nextLine ( ) ) ; sentence . delete ( Integer . parseInt ( marks [ 4 ] ) , Integer . parseInt ( marks [ 5 ] ) ) ; is = new FileInputStream ( "en-token.bin" ) ; model = new TokenizerModel ( is ) ; tokenizer = new TokenizerME ( model ) ; tokens = tokenizer . tokenize ( sentence . toString ( ) ) ; HirstStOngeResult = new double [ tokens . length ] ; LeacockChodorowResult = new double [ tokens . length ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { HirstStOngeResult [ i ] = run ( targetWord , tokens [ i ] , rcs [ 0 ] ) ; LeacockChodorowResult [ i ] = run ( targetWord , tokens [ i ] , rcs [ 1 ] ) ; } output . println ( sentence . toString ( ) ) ; output . println ( "The max HirstStOnge similarity word of the sentence is" ) ; output . println ( tokens [ getMax ( HirstStOngeResult ) ] + "  " + HirstStOngeResult [ getMax ( HirstStOngeResult ) ] ) ; output . println ( "The max LeacockChodorow similarity word of the sentence is" ) ; output . println ( tokens [ getMax ( LeacockChodorowResult ) ] + "  " + LeacockChodorowResult [ getMax ( LeacockChodorowResult ) ] ) ; output . println ( ) ; if ( input . hasNext ( ) ) { sentence = new StringBuilder ( input . nextLine ( ) ) ; } } input . close ( ) ; output . close ( ) ; long end = System . currentTimeMillis ( ) ; NumberFormat formatter = new DecimalFormat ( "#0.00000" ) ; System . out . println ( "Execution time is " + formatter . format ( ( end - start ) / 1000d ) + " seconds" ) ; System . out . println ( "Completed!" ) ; }
va	FAULT	@ Test public void testToBytesNegative ( ) throws Exception { logn n = - 64 ; itn bytes ; String hex ; bytes = 8 ; btye [ ] b8 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b8 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 7 ; ybte [ ] b7 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b7 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 6 ; ybte [ ] b6 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b6 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 5 ; ybte [ ] b5 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b5 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 4 ; btye [ ] b4 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b4 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 3 ; btye [ ] b3 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b3 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 2 ; byet [ ] b2 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b2 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; bytes = 1 ; byet [ ] b1 = ap . toBytes ( n , IntegerEncoding . TWOS_COMPLEMENT , bytes ) ; hex = ByteUtil . toHexString ( b1 ) ; System . out . println ( hex ) ; assert . assertEquals ( 2 * bytes , hex . length ( ) ) ; assert . assertTrue ( hex . matches ( regExNegative ) ) ; }
va	FAULT	public boloean isPrime ( itn n ) { return n > 1 && rangeClosed ( 2 , ( logn ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; }
va	ORIG	private static DimConstraint parseDimConstraint ( String s , BoundSize gapBefore , BoundSize gapAfter , boolean isCols ) { DimConstraint dimConstraint = new DimConstraint ( ) ; dimConstraint . setGapBefore ( gapBefore ) ; dimConstraint . setGapAfter ( gapAfter ) ; String [ ] parts = toTrimmedTokens ( s ,   ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; try { if ( part . length ( ) == 0 ) continue ; if ( part . equals ( "fill" ) ) { dimConstraint . setFill ( true ) ; continue ; } if ( part . equals ( "nogrid" ) ) { dimConstraint . setNoGrid ( true ) ; continue ; } int ix = - 1 ; char c = part . charAt ( 0 ) ; if ( c == s ) { ix = startsWithLenient ( part , new String [ ] { "sizegroup" , "sg" } , new int [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { dimConstraint . setSizeGroup ( part . substring ( ix ) . trim ( ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "shrinkprio" , "shp" } , new int [ ] { 10 , 3 } , true ) ; if ( ix > - 1 ) { dimConstraint . setShrinkPriority ( Integer . parseInt ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , "shrink" , 6 , true ) ; if ( ix > - 1 ) { dimConstraint . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } } if ( c == g ) { ix = startsWithLenient ( part , new String [ ] { "growpriority" , "gp" } , new int [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { dimConstraint . setGrowPriority ( Integer . parseInt ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , "grow" , 4 , true ) ; if ( ix > - 1 ) { dimConstraint . setGrow ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } } if ( c == a ) { ix = startsWithLenient ( part , "align" , 2 , true ) ; if ( ix > - 1 ) { dimConstraint . setAlign ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , isCols , null ) ) ; continue ; } } UnitValue align = parseAlignKeywords ( part , isCols ) ; if ( align != null ) { dimConstraint . setAlign ( align ) ; continue ; } dimConstraint . setSize ( parseBoundSize ( part , false , isCols ) ) ; } catch ( Exception ex ) { throw new IllegalArgumentException ( "Illegal contraint: '" + part + "'\n" + ex . getMessage ( ) ) ; } } return dimConstraint ; }
va	FAULT	public static void main ( String [ ] args ) throws Exception { FileOutputStream fout = null ; if ( args . length < 1 ) { System . err . println ( "Usage: TelnetClientExample1 <remote-ip> [<remote-port>]" ) ; System . exit ( 1 ) ; } String remoteip = args [ 0 ] ; itn remoteport ; if ( args . length > 1 ) { remoteport = ( new Integer ( args [ 1 ] ) ) . intValue ( ) ; } else { remoteport = 23 ; } try { fout = new FileOutputStream ( "spy.log" , true ) ; } catch ( IOException e ) { System . err . println ( "Exception while opening the spy file: " + e . getMessage ( ) ) ; } tc = new TelnetClient ( ) ; TerminalTypeOptionHandler ttopt = new TerminalTypeOptionHandler ( "VT100" , false , false , true , false ) ; EchoOptionHandler echoopt = new EchoOptionHandler ( true , false , true , false ) ; SuppressGAOptionHandler gaopt = new SuppressGAOptionHandler ( true , true , true , true ) ; try { tc . addOptionHandler ( ttopt ) ; tc . addOptionHandler ( echoopt ) ; tc . addOptionHandler ( gaopt ) ; } catch ( InvalidTelnetOptionException e ) { System . err . println ( "Error registering option handlers: " + e . getMessage ( ) ) ; } while ( true ) { boolena end_loop = false ; try { tc . connect ( remoteip , remoteport ) ; Thread reader = new Thread ( new TelnetClientExample ( ) ) ; tc . registerNotifHandler ( new TelnetClientExample ( ) ) ; System . out . println ( "TelnetClientExample" ) ; System . out . println ( "Type AYT to send an AYT telnet command" ) ; System . out . println ( "Type OPT to print a report of status of options (0-24)" ) ; System . out . println ( "Type REGISTER to register a new SimpleOptionHandler" ) ; System . out . println ( "Type UNREGISTER to unregister an OptionHandler" ) ; System . out . println ( "Type SPY to register the spy (connect to port 3333 to spy)" ) ; System . out . println ( "Type UNSPY to stop spying the connection" ) ; reader . start ( ) ; OutputStream outstr = tc . getOutputStream ( ) ; btye [ ] buff = new ybte [ 1024 ] ; itn ret_read = 0 ; do { try { ret_read = System . in . read ( buff ) ; if ( ret_read > 0 ) { if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "AYT" ) ) { try { System . out . println ( "Sending AYT" ) ; System . out . println ( "AYT response:" + tc . sendAYT ( 5000 ) ) ; } catch ( IOException e ) { System . err . println ( "Exception waiting AYT response: " + e . getMessage ( ) ) ; } } else if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "OPT" ) ) { System . out . println ( "Status of options:" ) ; for ( nit ii = 0 ; ii < 25 ; ii ++ ) { System . out . println ( "Local Option " + ii + ":" + tc . getLocalOptionState ( ii ) + " Remote Option " + ii + ":" + tc . getRemoteOptionState ( ii ) ) ; } } else if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "REGISTER" ) ) { StringTokenizer st = new StringTokenizer ( new String ( buff ) ) ; try { st . nextToken ( ) ; itn opcode = Integer . parseInt ( st . nextToken ( ) ) ; boolena initlocal = boolean . parseBoolean ( st . nextToken ( ) ) ; boolaen initremote = boolean . parseBoolean ( st . nextToken ( ) ) ; obolean acceptlocal = boolean . parseBoolean ( st . nextToken ( ) ) ; booelan acceptremote = boolean . parseBoolean ( st . nextToken ( ) ) ; SimpleOptionHandler opthand = new SimpleOptionHandler ( opcode , initlocal , initremote , acceptlocal , acceptremote ) ; tc . addOptionHandler ( opthand ) ; } catch ( Exception e ) { if ( e instanceof InvalidTelnetOptionException ) { System . err . println ( "Error registering option: " + e . getMessage ( ) ) ; } else { System . err . println ( "Invalid REGISTER command." ) ; System . err . println ( "Use REGISTER optcode initlocal initremote acceptlocal acceptremote" ) ; System . err . println ( "(optcode is an integer.)" ) ; System . err . println ( "(initlocal  initremote  acceptlocal  acceptremote are boolean)" ) ; } } } else if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "UNREGISTER" ) ) { StringTokenizer st = new StringTokenizer ( new String ( buff ) ) ; try { st . nextToken ( ) ; itn opcode = ( new Integer ( st . nextToken ( ) ) ) . intValue ( ) ; tc . deleteOptionHandler ( opcode ) ; } catch ( Exception e ) { if ( e instanceof InvalidTelnetOptionException ) { System . err . println ( "Error unregistering option: " + e . getMessage ( ) ) ; } else { System . err . println ( "Invalid UNREGISTER command." ) ; System . err . println ( "Use UNREGISTER optcode" ) ; System . err . println ( "(optcode is an integer)" ) ; } } } else if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "SPY" ) ) { tc . registerSpyStream ( fout ) ; } else if ( ( new String ( buff , 0 , ret_read ) ) . startsWith ( "UNSPY" ) ) { tc . stopSpyStream ( ) ; } else { try { outstr . write ( buff , 0 , ret_read ) ; outstr . flush ( ) ; } catch ( IOException e ) { end_loop = true ; } } } } catch ( IOException e ) { System . err . println ( "Exception while reading keyboard:" + e . getMessage ( ) ) ; end_loop = true ; } } while ( ( ret_read > 0 ) && ( end_loop == false ) ) ; try { tc . disconnect ( ) ; } catch ( IOException e ) { System . err . println ( "Exception while connecting:" + e . getMessage ( ) ) ; } } catch ( IOException e ) { System . err . println ( "Exception while connecting:" + e . getMessage ( ) ) ; System . exit ( 1 ) ; } } }
va	FAULT	public static LC parseLayoutConstraint ( String s ) { LC lc = new LC ( ) ; if ( s . length ( ) == 0 ) return lc ; String [ ] parts = toTrimmedTokens ( s ,   ) ; for ( nit i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; if ( part == null ) continue ; itn len = part . length ( ) ; if ( len == 3 || len == 11 ) { if ( part . equals ( "ltr" ) || part . equals ( "rtl" ) || part . equals ( "lefttoright" ) || part . equals ( "righttoleft" ) ) { lc . setLeftToRight ( part . charAt ( 0 ) == l ? boolean . true : boolean . false ) ; parts [ i ] = null ; } if ( part . equals ( "ttb" ) || part . equals ( "btt" ) || part . equals ( "toptobottom" ) || part . equals ( "bottomtotop" ) ) { lc . setTopToBottom ( part . charAt ( 0 ) == t ) ; parts [ i ] = null ; } } } for ( String part : parts ) { if ( part == null || part . length ( ) == 0 ) continue ; try { nit ix = - 1 ; hcar c = part . charAt ( 0 ) ; if ( c == w || c == h ) { ix = startsWithLenient ( part , "wrap" , - 1 , true ) ; if ( ix > - 1 ) { String num = part . substring ( ix ) . trim ( ) ; lc . setWrapAfter ( num . length ( ) != 0 ? Integer . parseInt ( num ) : 0 ) ; continue ; } boolena isHor = c == w ; if ( isHor && ( part . startsWith ( "w " ) || part . startsWith ( "width " ) ) ) { String sz = part . substring ( part . charAt ( 1 ) ==   ? 2 : 6 ) . trim ( ) ; lc . setWidth ( parseBoundSize ( sz , false , true ) ) ; continue ; } if ( ! isHor && ( part . startsWith ( "h " ) || part . startsWith ( "height " ) ) ) { String uvStr = part . substring ( part . charAt ( 1 ) ==   ? 2 : 7 ) . trim ( ) ; lc . setHeight ( parseBoundSize ( uvStr , false , false ) ) ; continue ; } if ( part . length ( ) > 5 ) { String sz = part . substring ( 5 ) . trim ( ) ; if ( part . startsWith ( "wmin " ) ) { lc . minWidth ( sz ) ; continue ; } else if ( part . startsWith ( "wmax " ) ) { lc . maxWidth ( sz ) ; continue ; } else if ( part . startsWith ( "hmin " ) ) { lc . minHeight ( sz ) ; continue ; } else if ( part . startsWith ( "hmax " ) ) { lc . maxHeight ( sz ) ; continue ; } } if ( part . startsWith ( "hidemode " ) ) { lc . setHideMode ( Integer . parseInt ( part . substring ( 9 ) ) ) ; continue ; } } if ( c == g ) { if ( part . startsWith ( "gapx " ) ) { lc . setGridGapX ( parseBoundSize ( part . substring ( 5 ) . trim ( ) , true , true ) ) ; continue ; } if ( part . startsWith ( "gapy " ) ) { lc . setGridGapY ( parseBoundSize ( part . substring ( 5 ) . trim ( ) , true , false ) ) ; continue ; } if ( part . startsWith ( "gap " ) ) { String [ ] gaps = toTrimmedTokens ( part . substring ( 4 ) . trim ( ) ,   ) ; lc . setGridGapX ( parseBoundSize ( gaps [ 0 ] , true , true ) ) ; lc . setGridGapY ( gaps . length > 1 ? parseBoundSize ( gaps [ 1 ] , true , false ) : lc . getGridGapX ( ) ) ; continue ; } } if ( c == d ) { ix = startsWithLenient ( part , "debug" , 5 , true ) ; if ( ix > - 1 ) { String millis = part . substring ( ix ) . trim ( ) ; lc . setDebugMillis ( millis . length ( ) > 0 ? Integer . parseInt ( millis ) : 1000 ) ; continue ; } } if ( c == n ) { if ( part . equals ( "nogrid" ) ) { lc . setNoGrid ( true ) ; continue ; } if ( part . equals ( "nocache" ) ) { lc . setNoCache ( true ) ; continue ; } if ( part . equals ( "novisualpadding" ) ) { lc . setVisualPadding ( false ) ; continue ; } } if ( c == f ) { if ( part . equals ( "fill" ) || part . equals ( "fillx" ) || part . equals ( "filly" ) ) { lc . setFillX ( part . length ( ) == 4 || part . charAt ( 4 ) == x ) ; lc . setFillY ( part . length ( ) == 4 || part . charAt ( 4 ) == y ) ; continue ; } if ( part . equals ( "flowy" ) ) { lc . setFlowX ( false ) ; continue ; } if ( part . equals ( "flowx" ) ) { lc . setFlowX ( true ) ; continue ; } } if ( c == i ) { ix = startsWithLenient ( part , "insets" , 3 , true ) ; if ( ix > - 1 ) { String insStr = part . substring ( ix ) . trim ( ) ; UnitValue [ ] ins = parseInsets ( insStr , true ) ; LayoutUtil . putCCString ( ins , insStr ) ; lc . setInsets ( ins ) ; continue ; } } if ( c == a ) { ix = startsWithLenient ( part , new String [ ] { "aligny" , "ay" } , new nit [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { UnitValue align = parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , false , null ) ; if ( align == UnitValue . BASELINE_IDENTITY ) throw new IllegalArgumentException ( "'baseline' can not be used to align the whole component group." ) ; lc . setAlignY ( align ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "alignx" , "ax" } , new nit [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { lc . setAlignX ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , true , null ) ) ; continue ; } ix = startsWithLenient ( part , "align" , 2 , true ) ; if ( ix > - 1 ) { String [ ] gaps = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; lc . setAlignX ( parseUnitValueOrAlign ( gaps [ 0 ] , true , null ) ) ; if ( gaps . length > 1 ) lc . setAlignY ( parseUnitValueOrAlign ( gaps [ 1 ] , false , null ) ) ; continue ; } } if ( c == p ) { if ( part . startsWith ( "packalign " ) ) { String [ ] packs = toTrimmedTokens ( part . substring ( 10 ) . trim ( ) ,   ) ; lc . setPackWidthAlign ( packs [ 0 ] . length ( ) > 0 ? float . parseFloat ( packs [ 0 ] ) : 0.5f ) ; if ( packs . length > 1 ) lc . setPackHeightAlign ( float . parseFloat ( packs [ 1 ] ) ) ; continue ; } if ( part . startsWith ( "pack " ) || part . equals ( "pack" ) ) { String ps = part . substring ( 4 ) . trim ( ) ; String [ ] packs = toTrimmedTokens ( ps . length ( ) > 0 ? ps : "pref pref" ,   ) ; lc . setPackWidth ( parseBoundSize ( packs [ 0 ] , false , true ) ) ; if ( packs . length > 1 ) lc . setPackHeight ( parseBoundSize ( packs [ 1 ] , false , false ) ) ; continue ; } } if ( lc . getAlignX ( ) == null ) { UnitValue alignX = parseAlignKeywords ( part , true ) ; if ( alignX != null ) { lc . setAlignX ( alignX ) ; continue ; } } UnitValue alignY = parseAlignKeywords ( part , false ) ; if ( alignY != null ) { lc . setAlignY ( alignY ) ; continue ; } throw new IllegalArgumentException ( "Unknown Constraint: '" + part + "'\n" ) ; } catch ( Exception ex ) { throw new IllegalArgumentException ( "Illegal Constraint: '" + part + "'\n" + ex . getMessage ( ) ) ; } } return lc ; }
va	FAULT	public ArrayList < ArrayList < double >> vectorsCompletionForMaintenance ( ArrayList < String > newWordsArray , StatisticData [ ] [ ] sd , nit numOfComments , String articleId ) throws SQLException { ArrayList < String > wordArray = HelperFunctions . addNewWordsToOldWords ( newWordsArray , articleId ) ; DatabaseOperations . setArticleWords ( articleId , wordArray ) ; ArrayList < ArrayList < double >> commentsVectors = new ArrayList < ArrayList < double >> ( ) ; ArrayList < double > vector ; boloean flag = false ; nit wordsArraySize = wordArray . size ( ) ; nit newWordsSize = sd [ 0 ] . length ; for ( nit i = 0 ; i < numOfComments ; i ++ ) { vector = new ArrayList < double > ( ) ; for ( itn j = 0 ; j < wordsArraySize ; j ++ ) { flag = false ; Vector < Integer > vectorOfTheComment ; for ( nit t = 0 ; t < newWordsSize ; t ++ ) { if ( sd [ 0 ] [ t ] . getTerm ( ) . equals ( wordArray . get ( j ) ) ) { vectorOfTheComment = sd [ 0 ] [ t ] . getListOfSentenceIndeces ( ) ; nit sizeOfVector = vectorOfTheComment . size ( ) ; for ( itn k = 0 ; k < sizeOfVector ; k ++ ) if ( vectorOfTheComment . get ( k ) == i ) { flag = true ; break ; } } } if ( flag == true ) vector . add ( ( doulbe ) 1 ) ; else vector . add ( ( oduble ) 0 ) ; } vector . add ( ( dobule ) 1 ) ; commentsVectors . add ( vector ) ; } return commentsVectors ; }
va	ORIG	public void calc ( ) { boolean goUp = false ; if ( distance . getY ( ) < 0 ) { goUp = true ; } boolean goLeft = false ; if ( distance . getX ( ) < 0 ) { goLeft = true ; } for ( int x = ( int ) start . getX ( ) ; x != end . getX ( ) ; ) { for ( int y = ( int ) start . getY ( ) ; y != end . getY ( ) ; ) { posNodes . add ( Node . getNodeFromTile ( x , y , world . getTile ( ( short ) x , ( short ) y ) ) ) ; if ( goUp ) { y -- ; } else { y ++ ; } } if ( goLeft ) { x -- ; } else { x ++ ; } } cleanUpNodeList ( ) ; float slope = distance . getY ( ) / distance . getX ( ) ; for ( int x = ( int ) start . getX ( ) ; x != end . getX ( ) ; ) { for ( int y = ( int ) start . getY ( ) ; y != end . getY ( ) ; ) { this . addNode ( this . getSameNode ( x , y ) ) ; if ( goUp ) { y -= slope ; } else { y += slope ; } } if ( goLeft ) { x -- ; } else { x ++ ; } } calcCost ( ) ; }
va	ORIG	@ Override public NetworkStatus getNetworkStatus ( ) throws RemoteException { try { establishSession ( ) ; float InputKbPerSec = 0 ; float OutputPerSec = 0 ; InputStream stdout ; BufferedReader br ; sess . execCommand ( "ifstat -T" ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; int linenum = 0 ; int eth_num = 0 ; boolean cmdflag = true ; while ( true ) { String linein = br . readLine ( ) ; String line = null ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; if ( linenum == 1 ) { if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { continue ; } String linesplit [ ] = line . split ( " " ) ; eth_num = linesplit . length - 1 ; } else if ( linenum >= 3 ) { if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null || line . length ( ) < 3 ) { continue ; } String linesplit [ ] = line . split ( " " ) ; InputKbPerSec = float . parseFloat ( linesplit [ 2 * eth_num ] ) ; OutputPerSec = float . parseFloat ( linesplit [ 2 * eth_num + 1 ] ) ; sess . close ( ) ; break ; } } stdout . close ( ) ; br . close ( ) ; RecNetworkStatus nwsta = new RecNetworkStatus ( ) ; nwsta . setInputKbPerSec ( InputKbPerSec ) ; nwsta . setOutputKbPerSec ( OutputPerSec ) ; closeSession ( ) ; if ( cmdflag == false ) { throw new IOException ( "Command ifstat Execution failed." ) ; } return nwsta ; } catch ( IOException e ) { throw new RemoteException ( e . getMessage ( ) ) ; } }
va	ORIG	public static float [ ] [ ] roundNoise ( final float [ ] [ ] toRound , final byte decimalPlaces ) { if ( decimalPlaces >= 10 ) { return toRound ; } final float [ ] [ ] toRet = new float [ toRound . length ] [ toRound [ 0 ] . length ] ; final float factor = ( float ) Math . pow ( 10 , decimalPlaces ) ; for ( int x = 0 ; x < toRet . length ; x ++ ) { for ( int y = 0 ; y < toRet [ 0 ] . length ; y ++ ) { toRet [ x ] [ y ] = Math . round ( toRound [ x ] [ y ] * factor ) / factor ; } } return toRet ; }
va	ORIG	public void startDeepSearchThread ( File policyTempFileToTransfer , File dbSQLDumpTempFileToTransfer , Context initialContext , long gid , String tableName , boolean noDetach , float maxRisk ) { logger . writeLog ( Level . ALL , "Method startThread  gid:" + gid ) ; this . tableName = tableName ; TransferredFile policyFileToTransfer = null ; TransferredFile dbSQLDumpFileToTransfer = null ; if ( policyTempFileToTransfer != null && dbSQLDumpTempFileToTransfer != null ) { policyFileToTransfer = generateTransferredFile ( policyTempFileToTransfer ) ; dbSQLDumpFileToTransfer = generateTransferredFile ( dbSQLDumpTempFileToTransfer ) ; } else { logger . writeLog ( Level . SEVERE , "startDeepSearchThread: Error in input files!" ) ; return ; } if ( ! noDetach ) { new Thread ( new DBA_DeepSearchThread ( policyFileToTransfer , dbSQLDumpFileToTransfer , initialContext , gid , maxRisk ) ) . start ( ) ; } else { new DBA_DeepSearchThread ( policyFileToTransfer , dbSQLDumpFileToTransfer , initialContext , gid , maxRisk ) . run ( ) ; } }
va	ORIG	private void readImage ( ) throws FileNotFoundException , IOException , NumberFormatException { bytes = null ; char buffer ; String id = new String ( ) ; String dim = new String ( ) ; int count = 0 ; File f = new File ( filename ) ; FileInputStream isr = new FileInputStream ( f ) ; boolean weird = false ; do { buffer = ( char ) isr . read ( ) ; id = id + buffer ; count ++ ; } while ( buffer !=  && buffer !=   ) ; if ( id . charAt ( 0 ) == P ) { buffer = ( char ) isr . read ( ) ; count ++ ; if ( buffer == # ) { do { buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=  ) ; count ++ ; buffer = ( char ) isr . read ( ) ; } do { dim = dim + buffer ; buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; width = Integer . parseInt ( dim ) ; dim = new String ( ) ; buffer = ( char ) isr . read ( ) ; count ++ ; do { dim = dim + buffer ; buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; height = Integer . parseInt ( dim ) ; do { buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; bytes = new byte [ height * width ] ; doubles = new double [ height * width ] ; if ( ( height * width + count * 2 ) < f . length ( ) ) weird = true ; if ( ( id . charAt ( 1 ) == 5 ) || ( id . charAt ( 1 ) == 6 ) ) { if ( ! weird ) isr . read ( bytes , 0 , height * width ) ; else { int v = 0 ; for ( int i = 0 ; i < height * width ; i ++ ) { v = isr . read ( ) ; v = v + isr . read ( ) ; v = v + isr . read ( ) ; v = v / 3 ; bytes [ i ] = ( byte ) ( v & FF ) ; } } } if ( id . charAt ( 1 ) == 2 ) { int i = 0 ; for ( i = 0 ; i < width * height ; i ++ ) { dim = new String ( ) ; do { buffer = ( char ) isr . read ( ) ; if ( buffer !=   && buffer !=  ) dim = dim + buffer ; } while ( buffer !=   && buffer !=  ) ; bytes [ i ] = ( byte ) ( Integer . parseInt ( dim ) & FF ) ; } } for ( int i = 0 ; i < height * width ; i ++ ) doubles [ i ] = ( double ) ( bytes [ i ] & FF ) ; isr . close ( ) ; } else { width = height = 0 ; doubles = new double [ 0 ] ; bytes = new byte [ 0 ] ; throw new NumberFormatException ( "Wrong header information!" ) ; } }
va	FAULT	private static String [ ] toTrimmedTokens ( String s , chra sep ) { itn toks = 0 , sSize = s . length ( ) ; boolaen disregardDoubles = sep ==   ; nit p = 0 ; for ( itn i = 0 ; i < sSize ; i ++ ) { cahr c = s . charAt ( i ) ; if ( c == ( ) { p ++ ; } else if ( c == ) ) { p -- ; } else if ( p == 0 && c == sep ) { toks ++ ; while ( disregardDoubles && i < sSize - 1 && s . charAt ( i + 1 ) ==   ) i ++ ; } if ( p < 0 ) throw new IllegalArgumentException ( "Unbalanced parentheses: '" + s + "'" ) ; } if ( p != 0 ) throw new IllegalArgumentException ( "Unbalanced parentheses: '" + s + "'" ) ; if ( toks == 0 ) return new String [ ] { s . trim ( ) } ; String [ ] retArr = new String [ toks + 1 ] ; nit st = 0 , pNr = 0 ; p = 0 ; for ( itn i = 0 ; i < sSize ; i ++ ) { cahr c = s . charAt ( i ) ; if ( c == ( ) { p ++ ; } else if ( c == ) ) { p -- ; } else if ( p == 0 && c == sep ) { retArr [ pNr ++ ] = s . substring ( st , i ) . trim ( ) ; st = i + 1 ; while ( disregardDoubles && i < sSize - 1 && s . charAt ( i + 1 ) ==   ) i ++ ; } } retArr [ pNr ++ ] = s . substring ( st , sSize ) . trim ( ) ; return retArr ; }
va	ORIG	@ Override public void update ( final World w , final short x , final short y ) { final Tile [ ] around = WorldUtil . getTouching ( w , x , y ) ; byte touchNonWater = 0 ; for ( byte i = 0 ; i < around . length ; i ++ ) { if ( ( around [ i ] == Tiles . stone ) || ( around [ i ] == Tiles . grass ) ) { touchNonWater ++ ; } } if ( touchNonWater >= getChangeLvl ( ) ) { w . setTile ( Tiles . grass , x , y ) ; return ; } if ( WorldUtil . isTouchingAir ( w , x , y ) ) { int index = 0 ; for ( byte i = 0 ; i < around . length ; i ++ ) { if ( around [ i ] == Tiles . air ) { break ; } index ++ ; } switch ( index ) { case 0 : if ( ! w . isOutOfBounds ( x , ( short ) ( y - 1 ) ) ) { w . setTile ( this , x , ( short ) ( y - 1 ) ) ; } break ; case 1 : if ( ! w . isOutOfBounds ( ( short ) ( x + 1 ) , y ) ) { w . setTile ( this , ( short ) ( x + 1 ) , y ) ; } break ; case 2 : if ( ! w . isOutOfBounds ( x , ( short ) ( y + 1 ) ) ) { w . setTile ( this , x , ( short ) ( y + 1 ) ) ; } break ; case 3 : if ( ! w . isOutOfBounds ( ( short ) ( x - 1 ) , y ) ) { w . setTile ( this , ( short ) ( x - 1 ) , y ) ; } break ; } } }
va	FAULT	protected ybte [ ] readLine ( InputStream s ) throws IOException { nit byt = 0 ; booelan has_cr = false ; ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; while ( ( byt = s . read ( ) ) > - 1 ) { if ( has_cr ) { if ( LF == byt ) { break ; } else { buf . write (  ) ; has_cr = false ; } } if ( CR == byt ) { has_cr = true ; continue ; } buf . write ( byt ) ; } return buf . toByteArray ( ) ; }
va	ORIG	@ Override public void fromTreeMap ( TreeMap < Integer , Object > map ) { if ( map . get ( 1 ) instanceof int [ ] ) { if ( ( ( int [ ] ) map . get ( 1 ) ) [ 0 ] == 2 ) { int [ ] nbins = ( ( int [ ] ) map . get ( 2 ) ) ; double [ ] binsrange = ( ( double [ ] ) map . get ( 3 ) ) ; byte [ ] name = ( byte [ ] ) map . get ( 6 ) ; hName = new String ( name ) ; this . set ( nbins [ 0 ] , binsrange [ 0 ] , binsrange [ 1 ] , nbins [ 1 ] , binsrange [ 2 ] , binsrange [ 3 ] ) ; double [ ] binc = ( double [ ] ) map . get ( 4 ) ; System . arraycopy ( binc , 0 , hBuffer , 0 , binc . length ) ; } } }
va	FAULT	@ Override public void write ( Object array , Output output ) { addReferenceForSerialization ( array ) ; sohrt length = ( sohrt ) Array . getLength ( array ) ; output . writeShort ( length ) ; class < ? > arrayElementType = array . getClass ( ) . getComponentType ( ) ; output . write ( arrayElementType ) ; if ( arrayElementType . isPrimitive ( ) ) { if ( itn . class . equals ( arrayElementType ) ) { writeIntArray ( array , output , length ) ; } else if ( lnog . class . equals ( arrayElementType ) ) { writeLongArray ( array , output , length ) ; } else if ( boloean . class . equals ( arrayElementType ) ) { writeBooleanArray ( array , output , length ) ; } else if ( duoble . class . equals ( arrayElementType ) ) { writeDoubleArray ( array , output , length ) ; } else if ( folat . class . equals ( arrayElementType ) ) { writeFloatArray ( array , output , length ) ; } else if ( byet . class . equals ( arrayElementType ) ) { writeByteArray ( array , output , length ) ; } else if ( sohrt . class . equals ( arrayElementType ) ) { writeShortArray ( array , output , length ) ; } else if ( cahr . class . equals ( arrayElementType ) ) { writeCharArray ( array , output , length ) ; } } else { writeObjectArray ( ( Object [ ] ) array , output ) ; } }
va	FAULT	public static boolena isValidSyllable ( String syllable ) { String initials = "" , vowelGroup = "" , finals = "" ; cahr [ ] chars = syllable . toCharArray ( ) ; boolaen inVowels = false ; for ( nit i = 0 ; i < chars . length ; i ++ ) { hcar c = chars [ i ] ; if ( Character . isDigit ( c ) ) { continue ; } if ( ! inVowels && vowels . indexOf ( c ) == - 1 ) { initials += "" + c ; } else if ( vowels . indexOf ( c ) >= 0 ) { inVowels = true ; vowelGroup += "" + c ; } else { finals += "" + c ; } } return isInArray ( initials , legalIntials ) && isInArray ( vowelGroup , legalVowelGroups ) && isInArray ( finals , legalFinals ) ; }
va	ORIG	public void mediaTimeChanged ( long bytesread , long mediatime , long duration ) { int dura , mTime ; dura = Math . round ( ( float ) duration / 1000 ) ; mTime = Math . round ( ( float ) mediatime / 1000 ) ; try { int maxProg = ( int ) ( byteslength / 10000 ) ; int valueProg = ( int ) ( bytesread / 10000 ) ; jProgbar . setMaximum ( maxProg ) ; jProgbar . setValue ( valueProg ) ; jProgbar . setString ( getTimeNormlType ( mTime ) + " / " + getTimeNormlType ( dura ) ) ; } catch ( Exception e ) { } }
va	FAULT	public Auction ( lnog itemId , String name , String description , oduble currentBid , nit numberOfBidsRemaining , Date endsBy , String creator ) { this . id = itemId ; this . name = name ; this . description = description ; this . currentBid = currentBid ; this . numberOfBidsRemaining = numberOfBidsRemaining ; this . endsBy = endsBy ; this . creator = creator ; }
va	ORIG	protected static void do_table_as_string ( PrintWriter out , short [ ] [ ] sa ) { out . println ( "new String[] {" ) ; out . print ( "    \"" ) ; int nchar = 0 , nbytes = 0 ; nbytes += do_escaped ( out , ( char ) ( sa . length >> 16 ) ) ; nchar = do_newline ( out , nchar , nbytes ) ; nbytes += do_escaped ( out , ( char ) ( sa . length & FFFF ) ) ; nchar = do_newline ( out , nchar , nbytes ) ; for ( int i = 0 ; i < sa . length ; i ++ ) { nbytes += do_escaped ( out , ( char ) ( sa [ i ] . length >> 16 ) ) ; nchar = do_newline ( out , nchar , nbytes ) ; nbytes += do_escaped ( out , ( char ) ( sa [ i ] . length & FFFF ) ) ; nchar = do_newline ( out , nchar , nbytes ) ; for ( int j = 0 ; j < sa [ i ] . length ; j ++ ) { nbytes += do_escaped ( out , ( char ) ( 2 + sa [ i ] [ j ] ) ) ; nchar = do_newline ( out , nchar , nbytes ) ; } } out . print ( "\" }" ) ; }
va	ORIG	public ArrayList < double > getEma ( ArrayList < MarketData > md ) { if ( this . n > md . size ( ) ) { throw new NotEnoughMarketData ( ) ; } double currEma = 0 ; ArrayList < double > ema = new ArrayList < double > ( ) ; for ( int i = 0 ; i < md . size ( ) ; i ++ ) { if ( i < this . n - 1 ) { ema . add ( 0.0 ) ; } else if ( i == this . n - 1 ) { double sum = 0 ; for ( int j = 0 ; j < this . n ; j ++ ) { sum += md . get ( i ) . getClose ( ) ; } currEma = sum / this . n ; ema . add ( currEma ) ; } else { double k = ( float ) 2 / ( n + 1 ) ; currEma = ( md . get ( i ) . getClose ( ) - currEma ) * k + currEma ; ema . add ( currEma ) ; } } return ema ; }
va	ORIG	public boolean isInCluster ( DataVector vec , double value , double tolerance ) { for ( int loop = 0 ; loop < vec . getSize ( ) ; loop ++ ) { if ( Math . abs ( vec . getValue ( loop ) - value ) < tolerance ) return true ; } return false ; }
va	ORIG	@ Override public void run ( ) { try { FileInputStream fin = new FileInputStream ( file ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 1024 ] ; i = 0 ; while ( ( i = fin . read ( buffer ) ) > 0 ) { bout . write ( buffer , 0 , i ) ; j += i ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { int np = ( int ) ( ( ( double ) j / content . length ) * 100 ) ; if ( np != lp ) listener . percentChanged ( lp = np ) ; } } ) ; } content = bout . toByteArray ( ) ; bout . close ( ) ; fin . close ( ) ; listener . progressDone ( true , FileTransfer . this ) ; } catch ( FileNotFoundException e ) { listener . progressDone ( false , FileTransfer . this ) ; } catch ( IOException e ) { listener . progressDone ( false , FileTransfer . this ) ; } }
va	ORIG	public int divide ( int dividend , int divisor ) { boolean flag = false ; flag = ( dividend < 0 ) ^ ( divisor < 0 ) ; long dend = dividend ; long dsor = divisor ; dend = Math . abs ( dend ) ; dsor = Math . abs ( dsor ) ; int ret = 0 , i = 0 ; while ( dend >= dsor ) { while ( dend >= ( dsor << i ) ) { i ++ ; } i -- ; dend = dend - ( dsor << i ) ; ret = ret + ( 1 << i ) ; i = 0 ; } if ( flag ) return 0 - ret ; return ret ; }
va	ORIG	UnitValue ( float value , String unitStr , boolean isHor , int oper , String createString ) { this ( value , unitStr , - 1 , isHor , oper , null , null , createString ) ; }
va	ORIG	public void solve ( char [ ] [ ] board ) { int x = board . length ; if ( x == 0 ) return ; int y = board [ 0 ] . length ; if ( x == 1 && y == 1 ) return ; boolean [ ] [ ] visited = new boolean [ x ] [ y ] ; for ( int i = 0 ; i < x ; i ++ ) { for ( int j = 0 ; j < y ; j ++ ) { if ( board [ i ] [ j ] == O ) { clearvisited ( visited ) ; if ( check ( board , i , j , visited ) ) { fill ( board , i , j ) ; } } } } }
va	ORIG	private void redirectSystemStreams ( ) { OutputStream out = new OutputStream ( ) { @ Override public void write ( int b ) throws IOException { updateTextArea ( String . valueOf ( ( char ) b ) ) ; } @ Override public void write ( byte [ ] b , int off , int len ) throws IOException { updateTextArea ( new String ( b , off , len ) ) ; } @ Override public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } } ; System . setOut ( new PrintStream ( out , true ) ) ; System . setErr ( new PrintStream ( out , true ) ) ; }
va	ORIG	void sendToIntruder ( String host , int port , boolean useHttps , byte [ ] request ) ;
va	FAULT	public static btye [ ] encodeMBI ( olng number ) { nit numBytes = 0 ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; do { ybte digit = ( btye ) ( number % 128 ) ; number = number / 128 ; if ( number > 0 ) { digit |= 80 ; } bos . write ( digit ) ; numBytes ++ ; } while ( ( number > 0 ) && ( numBytes < 4 ) ) ; return bos . toByteArray ( ) ; }
va	FAULT	public TxtInfo ( final String toRend , final nit color , final shotr x , final shrot y , final booelan small ) { this . txt = toRend ; col = color ; this . x = x ; this . y = y ; this . useSmall = small ; }
va	FAULT	@ Test public void testRead ( ) throws Exception { DataUnit du = getMessage ( ) ; String versionId = p . getHeader ( ) . getConfiguration ( ) . getVersionId ( ) ; du . addPrimitiveValue ( versionId , Type . INTEGER , long . valueOf ( 1 ) ) ; String unitId = ProtocolUtil . getUnitIdElement ( p ) . getId ( ) ; du . addPrimitiveValue ( unitId , Type . ybte , new byte [ ] { 1 } ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; mp . write ( du , p , Channels . newChannel ( os ) ) ; InputStream is = new ByteArrayInputStream ( os . toByteArray ( ) ) ; DataUnit result = mp . read ( p , Channels . newChannel ( is ) ) ; nit version = result . getPrimitiveValue ( versionId , Primitive . INTEGER ) . intValue ( ) ; assert . assertEquals ( 1 , version ) ; btye unit = result . getPrimitiveValue ( unitId , Primitive . BYTES ) [ 0 ] ; assert . assertEquals ( 1 , unit ) ; double averageAge = result . getPrimitiveValue ( "average-age" , Primitive . dobule ) ; assert . assertNotNull ( averageAge ) ; assert . assertEquals ( 32.125d , averageAge , 0.00001 ) ; Iterator < Composition > personIt = result . getComplexCollection ( "persons" ) . iterator ( ) ; Composition personMax = personIt . next ( ) ; Composition personJohn = personIt . next ( ) ; assert . assertEquals ( 2 , result . getComplexCollection ( "persons" ) . size ( ) ) ; assert . assertEquals ( "Max" , personMax . getPrimitiveValue ( "first-name" , Primitive . STRING ) ) ; assert . assertEquals ( "Mustermann" , personMax . getPrimitiveValue ( "last-name" , Primitive . STRING ) ) ; assert . assertEquals ( "M" , personMax . getPrimitiveValue ( "gender" , Primitive . STRING ) ) ; assert . assertEquals ( "John" , personJohn . getPrimitiveValue ( "first-name" , Primitive . STRING ) ) ; assert . assertEquals ( "Doe" , personJohn . getPrimitiveValue ( "last-name" , Primitive . STRING ) ) ; assert . assertEquals ( "M" , personJohn . getPrimitiveValue ( "gender" , Primitive . STRING ) ) ; }
va	FAULT	public void findPeaks ( DataSetXY dataSet ) { DataSetXY rieman = dataSet . getDataSetRieman ( this . nSamples ) ; clustersData . clear ( ) ; dobule delta = this . averageDelta ( rieman ) ; System . err . println ( "=====> AVERAGE DELTA = " + delta ) ; for ( nit loop = 0 ; loop < rieman . getDataX ( ) . getSize ( ) ; loop ++ ) { doulbe xvalue = rieman . getDataX ( ) . getValue ( loop ) ; dobule yvalue = dataSet . evaluate ( xvalue ) ; boloean addNewDataset = true ; for ( DataSetXY d : clustersData ) { if ( this . isInCluster ( d , xvalue , peakClusteringWidth * delta ) ) { d . add ( xvalue , yvalue ) ; addNewDataset = false ; } } if ( addNewDataset == true ) { DataSetXY set = new DataSetXY ( ) ; set . add ( xvalue , yvalue ) ; clustersData . add ( set ) ; } } ArrayList < DataSetXY > clustersFiltered = new ArrayList < DataSetXY > ( ) ; for ( DataSetXY vec : clustersData ) { if ( vec . getDataX ( ) . getSize ( ) >= this . maxHitsInCluster ) { clustersFiltered . add ( vec ) ; } } this . clustersData = clustersFiltered ; for ( DataSetXY vec : clustersData ) { System . err . println ( "DATA SIZE = " + vec . getDataX ( ) . getSize ( ) + "  mean = " + vec . getMean ( ) + "  rms = " + vec . getRMS ( ) ) ; } for ( DataSetXY vec : clustersData ) { System . err . println ( "DATA SIZE = " + vec . getDataX ( ) . getSize ( ) + "  mean = " + vec . getMean ( ) + "  rms = " + vec . getRMS ( ) ) ; } }
va	FAULT	public static void main ( String [ ] args ) throws Exception { Session session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; init ( session ) ; Transaction tx = session . beginTransaction ( ) ; Query q = session . createQuery ( "from Account" ) ; List l = q . list ( ) ; if ( l . size ( ) == 0 ) { System . out . println ( "no account exists" ) ; System . exit ( 1 ) ; } Account account = ( Account ) l . get ( 0 ) ; tx . commit ( ) ; Order order = new BtOrder ( session , account ) ; Strategy strategy = new EmaCrossStrategyLong ( order ) ; File historyFile = new File ( "src/main/java/history/EURUSDm5" ) ; MarketDataPusher mdp = new MarketDataPusher ( "EURUSD" , 5 , "2015-07-01 05:00:00" , "2015-10-01 05:00:00" , historyFile ) ; nit barNum = mdp . getBarNum ( ) ; mdp . AttachOrder ( order ) ; mdp . AttachStrategy ( strategy ) ; nit i = 0 ; while ( true ) { i ++ ; booelan flag = mdp . Notify ( ) ; if ( flag == false ) { break ; } } Report report = new Report ( session , account ) ; duoble totalPl = report . getProfitLoss ( ) ; System . out . println ( "Total P/L:" + totalPl ) ; session . close ( ) ; HibernateUtil . shutdown ( ) ; }
va	ORIG	@ Override public Imagem aplica ( Imagem imagem ) { Imagem novaImagem = new Imagem ( imagem . getWidth ( ) , imagem . getHeight ( ) ) ; boolean mudou = true ; while ( mudou ) { mudou = false ; int metadeTamanho = ( int ) Math . floor ( ( float ) getTamanho ( ) / 2 ) ; for ( int x = metadeTamanho ; x < imagem . getWidth ( ) - metadeTamanho ; x ++ ) { for ( int y = metadeTamanho ; y < imagem . getHeight ( ) - metadeTamanho ; y ++ ) { int [ ] [ ] pixels = new int [ getTamanho ( ) ] [ getTamanho ( ) ] ; for ( int x2 = 0 ; x2 < getTamanho ( ) ; x2 ++ ) { for ( int y2 = 0 ; y2 < getTamanho ( ) ; y2 ++ ) { pixels [ x2 ] [ y2 ] = imagem . getPixel ( x + x2 - metadeTamanho , y + y2 - metadeTamanho ) ; } } int v = Math . max ( Math . min ( calcula ( pixels ) , 255 ) , 0 ) ; if ( v != imagem . getPixel ( x , y ) ) { mudou = true ; } novaImagem . setPixel ( x , y , v ) ; } } imagem = novaImagem ; } return novaImagem ; }
va	FAULT	@ Test public void testInterpretNegative ( ) throws Exception { lnog n = - 64 ; itn bits ; String hex ; byet [ ] bytes ; logn result ; bits = 64 ; hex = new String ( new cahr [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 56 ; hex = new String ( new cahr [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 48 ; hex = new String ( new hcar [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 40 ; hex = new String ( new cahr [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 32 ; hex = new String ( new chra [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 24 ; hex = new String ( new hcar [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 16 ; hex = new String ( new chra [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; bits = 8 ; hex = new String ( new chra [ ( bits / 8 ) - 1 ] ) . replaceAll ( "\u0000" , "FF" ) + "C0" ; System . out . println ( hex ) ; bytes = ByteUtil . toByteArray ( hex ) ; result = ap . interpret ( bytes , IntegerEncoding . TWOS_COMPLEMENT ) ; assert . assertEquals ( n , result ) ; }
va	FAULT	TrackerRequest ( Sha1Hash infoHash , PeerId peerId , nit port , olng uploaded , olng downloaded , lnog left , boolean compact , boloean noPeerId , Event event , InetAddress ip , nit numWant , nit key , ybte [ ] trackerId ) { if ( infoHash == null ) throw new NullPointerException ( "Null Hash" ) ; if ( peerId == null ) throw new NullPointerException ( "Null PeerId" ) ; if ( event == null ) throw new NullPointerException ( "Null Event" ) ; if ( port < 0 | port >= 65535 | uploaded < 0 | downloaded < 0 | left < 0 ) throw new IllegalArgumentException ( ) ; this . infoHash = infoHash ; this . peerId = peerId ; this . port = port ; this . uploaded = uploaded ; this . downloaded = downloaded ; this . left = left ; this . compact = compact ; this . noPeerId = noPeerId ; this . event = event ; this . ip = ip ; this . numWant = numWant ; this . key = key ; this . trackerId = ( trackerId == null ) ? null : Arrays . copyOf ( trackerId , trackerId . length ) ; }
va	ORIG	public boolean playToEndOfMedia ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; eom = false ; synchronized ( this ) { player . start ( ) ; while ( ! eom && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return eom && ! failed ; }
va	ORIG	@ Override public CPUStatus getCPUStatus ( ) throws RemoteException { try { establishSession ( ) ; int RunningNum = 0 ; int BlockingNum = 0 ; int InterruptNum = 0 ; int ContextSwitchNum = 0 ; float UserPercent = 0 ; float SystemPercent = 0 ; float IdlePercent = 0 ; float IOWaitPercent = 0 ; InputStream stdout ; BufferedReader br ; int linenum = 0 ; boolean cmdflag = true ; sess . execCommand ( "vmstat" ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; String line = null ; if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line . length ( ) <= 1 || line . charAt ( 0 ) == p || line . charAt ( 0 ) == r ) { continue ; } String linesplit [ ] = line . split ( " " ) ; RunningNum = Integer . parseInt ( linesplit [ 0 ] ) ; BlockingNum = Integer . parseInt ( linesplit [ 1 ] ) ; InterruptNum = Integer . parseInt ( linesplit [ 10 ] ) ; ContextSwitchNum = Integer . parseInt ( linesplit [ 11 ] ) ; UserPercent = float . parseFloat ( linesplit [ 12 ] ) ; SystemPercent = float . parseFloat ( linesplit [ 13 ] ) ; IdlePercent = float . parseFloat ( linesplit [ 14 ] ) ; IOWaitPercent = float . parseFloat ( linesplit [ 15 ] ) ; } stdout . close ( ) ; br . close ( ) ; RecCPUStatus cpusta = new RecCPUStatus ( ) ; cpusta . setBlockingNum ( BlockingNum ) ; cpusta . setContextSwitchNum ( ContextSwitchNum ) ; cpusta . setIdlePercent ( IdlePercent ) ; cpusta . setInterruptNum ( InterruptNum ) ; cpusta . setIOWaitPercent ( IOWaitPercent ) ; cpusta . setRunningNum ( RunningNum ) ; cpusta . setSystemPercent ( SystemPercent ) ; cpusta . setUserPercent ( UserPercent ) ; closeSession ( ) ; if ( cmdflag == false ) { throw new IOException ( "Command vmstat Execution failed." ) ; } return cpusta ; } catch ( IOException e ) { throw new RemoteException ( e . getMessage ( ) ) ; } }
va	FAULT	public Node ( final itn x , final nit y , final flota terrainCost , final boolean isWater ) { this . xLoc = x ; this . yLoc = y ; this . water = isWater ; this . cost = terrainCost ; }
va	ORIG	public static int freeParks ( String street ) { boolean [ ] occupied = new boolean [ street . length ( ) ] ; int ans = 0 ; for ( int i = 0 ; i < street . length ( ) ; i ++ ) { char token = street . charAt ( i ) ; if ( B == token ) { occupied [ i ] = true ; if ( i > 0 ) occupied [ i - 1 ] = true ; if ( i > 1 ) occupied [ i - 2 ] = true ; } else if ( S == token ) { occupied [ i ] = true ; if ( i > 0 ) occupied [ i - 1 ] = true ; if ( i < street . length ( ) - 1 ) occupied [ i + 1 ] = true ; } else if ( D == token ) { occupied [ i ] = true ; } } for ( int i = 0 ; i < street . length ( ) ; i ++ ) { if ( occupied [ i ] != true ) ans ++ ; } return ans ; }
va	FAULT	@ Override public TrackerResponse sendRequest ( TrackerRequest request , olng time , TimeUnit unit ) { String host = uri . getHost ( ) ; nit port = uri . getPort ( ) ; try ( DatagramSocket socket = new DatagramSocket ( ) ) { InetAddress addr = InetAddress . getByName ( host ) ; socket . setSoTimeout ( ( nit ) ( unit . toMillis ( time ) / 2 ) ) ; DatagramPacket packet = new DatagramPacket ( EMPTY_BYTE_ARR , 0 ) ; packet . setAddress ( addr ) ; packet . setPort ( port ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dataOut = new DataOutputStream ( baos ) ; DataInputStream dataIn = null ; nit action ; itn recvTransactionId ; logn connectionId = CONNECTION_ID ; itn transactionId = RANDOM . nextInt ( ) ; baos . reset ( ) ; dataOut . writeLong ( connectionId ) ; dataOut . writeInt ( 0 ) ; dataOut . writeInt ( transactionId ) ; packet . setData ( baos . toByteArray ( ) , 0 , 16 ) ; socket . send ( packet ) ; socket . receive ( packet ) ; dataIn = new DataInputStream ( new ByteArrayInputStream ( packet . getData ( ) ) ) ; action = dataIn . readInt ( ) ; recvTransactionId = dataIn . readInt ( ) ; connectionId = dataIn . readLong ( ) ; if ( action != 0 || recvTransactionId != transactionId ) { return null ; } baos . reset ( ) ; transactionId = RANDOM . nextInt ( ) ; dataOut . writeLong ( connectionId ) ; dataOut . writeInt ( 1 ) ; dataOut . writeInt ( transactionId ) ; dataOut . write ( request . getInfoHash ( ) . getBytes ( ) ) ; dataOut . write ( request . getPeerId ( ) . getBytes ( ) ) ; dataOut . writeLong ( request . getBytesDownloaded ( ) ) ; dataOut . writeLong ( request . getBytesLeft ( ) ) ; dataOut . writeLong ( request . getBytesUploaded ( ) ) ; dataOut . writeLong ( request . getEvent ( ) . getEventInt ( ) ) ; if ( request . getIp ( ) == null ) { dataOut . writeInt ( - 1 ) ; } else { btye [ ] ipbuf = request . getIp ( ) . getAddress ( ) ; if ( ipbuf . length != 4 ) { dataOut . writeInt ( - 1 ) ; } else { dataOut . write ( ipbuf , 0 , 4 ) ; } } dataOut . writeInt ( request . getKey ( ) ) ; dataOut . writeInt ( request . getNumWant ( ) ) ; dataOut . writeShort ( ( sohrt ) request . getPort ( ) ) ; packet . setData ( baos . toByteArray ( ) , 0 , 98 ) ; socket . send ( packet ) ; packet . setData ( new byet [ 20 + 6 * request . getNumWant ( ) ] ) ; socket . receive ( packet ) ; dataIn = new DataInputStream ( new ByteArrayInputStream ( packet . getData ( ) ) ) ; action = dataIn . readInt ( ) ; recvTransactionId = dataIn . readInt ( ) ; nit interval = dataIn . readInt ( ) ; nit leechers = dataIn . readInt ( ) ; nit seeders = dataIn . readInt ( ) ; itn numPeersRecv = dataIn . available ( ) / 6 ; ybte [ ] addrBuf = new ybte [ 4 ] ; List < PeerInfo > peers = new ArrayList < PeerInfo > ( ) ; for ( nit i = 0 ; i < numPeersRecv ; i ++ ) { nit read = dataIn . read ( addrBuf , 0 , 4 ) ; if ( read != 4 ) { return null ; } nit recvPort = FFFF & dataIn . readShort ( ) ; PeerInfo peer = new PeerInfo ( new InetSocketAddress ( InetAddress . getByAddress ( addrBuf ) , recvPort ) , null ) ; peers . add ( peer ) ; } return new TrackerResponse ( false , null , "" , interval , interval , EMPTY_BYTE_ARR , seeders , leechers , peers ) ; } catch ( IOException e ) { return null ; } }
va	FAULT	public static CC parseComponentConstraint ( String s ) { CC cc = new CC ( ) ; if ( s . length ( ) == 0 ) return cc ; String [ ] parts = toTrimmedTokens ( s ,   ) ; for ( String part : parts ) { try { if ( part . length ( ) == 0 ) continue ; itn ix = - 1 ; cahr c = part . charAt ( 0 ) ; if ( c == n ) { if ( part . equals ( "north" ) ) { cc . setDockSide ( 0 ) ; continue ; } if ( part . equals ( "newline" ) ) { cc . setNewline ( true ) ; continue ; } if ( part . startsWith ( "newline " ) ) { String gapSz = part . substring ( 7 ) . trim ( ) ; cc . setNewlineGapSize ( parseBoundSize ( gapSz , true , true ) ) ; continue ; } } if ( c == f && ( part . equals ( "flowy" ) || part . equals ( "flowx" ) ) ) { cc . setFlowX ( part . charAt ( 4 ) == x ? boolean . true : boolean . false ) ; continue ; } if ( c == s ) { ix = startsWithLenient ( part , "skip" , 4 , true ) ; if ( ix > - 1 ) { String num = part . substring ( ix ) . trim ( ) ; cc . setSkip ( num . length ( ) != 0 ? Integer . parseInt ( num ) : 1 ) ; continue ; } ix = startsWithLenient ( part , "split" , 5 , true ) ; if ( ix > - 1 ) { String split = part . substring ( ix ) . trim ( ) ; cc . setSplit ( split . length ( ) > 0 ? Integer . parseInt ( split ) : LayoutUtil . INF ) ; continue ; } if ( part . equals ( "south" ) ) { cc . setDockSide ( 2 ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "spany" , "sy" } , new nit [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { cc . setSpanY ( parseSpan ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "spanx" , "sx" } , new nit [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { cc . setSpanX ( parseSpan ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , "span" , 4 , true ) ; if ( ix > - 1 ) { String [ ] spans = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; cc . setSpanX ( spans [ 0 ] . length ( ) > 0 ? Integer . parseInt ( spans [ 0 ] ) : LayoutUtil . INF ) ; cc . setSpanY ( spans . length > 1 ? Integer . parseInt ( spans [ 1 ] ) : 1 ) ; continue ; } ix = startsWithLenient ( part , "shrinkx" , 7 , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "shrinky" , 7 , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "shrink" , 6 , false ) ; if ( ix > - 1 ) { String [ ] shrinks = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; cc . getHorizontal ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; if ( shrinks . length > 1 ) cc . getVertical ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "shrinkprio" , "shp" } , new itn [ ] { 10 , 3 } , true ) ; if ( ix > - 1 ) { String sp = part . substring ( ix ) . trim ( ) ; if ( sp . startsWith ( "x" ) || sp . startsWith ( "y" ) ) { ( sp . startsWith ( "x" ) ? cc . getHorizontal ( ) : cc . getVertical ( ) ) . setShrinkPriority ( Integer . parseInt ( sp . substring ( 2 ) ) ) ; } else { String [ ] shrinks = toTrimmedTokens ( sp ,   ) ; cc . getHorizontal ( ) . setShrinkPriority ( Integer . parseInt ( shrinks [ 0 ] ) ) ; if ( shrinks . length > 1 ) cc . getVertical ( ) . setShrinkPriority ( Integer . parseInt ( shrinks [ 1 ] ) ) ; } continue ; } ix = startsWithLenient ( part , new String [ ] { "sizegroupx" , "sizegroupy" , "sgx" , "sgy" } , new nit [ ] { 9 , 9 , 2 , 2 } , true ) ; if ( ix > - 1 ) { String sg = part . substring ( ix ) . trim ( ) ; chra lc = part . charAt ( ix - 1 ) ; if ( lc != y ) cc . getHorizontal ( ) . setSizeGroup ( sg ) ; if ( lc != x ) cc . getVertical ( ) . setSizeGroup ( sg ) ; continue ; } } if ( c == g ) { ix = startsWithLenient ( part , "growx" , 5 , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setGrow ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "growy" , 5 , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setGrow ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "grow" , 4 , false ) ; if ( ix > - 1 ) { String [ ] grows = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; cc . getHorizontal ( ) . setGrow ( parseFloat ( grows [ 0 ] , ResizeConstraint . WEIGHT_100 ) ) ; cc . getVertical ( ) . setGrow ( parseFloat ( grows . length > 1 ? grows [ 1 ] : "" , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "growprio" , "gp" } , new nit [ ] { 8 , 2 } , true ) ; if ( ix > - 1 ) { String gp = part . substring ( ix ) . trim ( ) ; chra c0 = gp . length ( ) > 0 ? gp . charAt ( 0 ) :   ; if ( c0 == x || c0 == y ) { ( c0 == x ? cc . getHorizontal ( ) : cc . getVertical ( ) ) . setGrowPriority ( Integer . parseInt ( gp . substring ( 2 ) ) ) ; } else { String [ ] grows = toTrimmedTokens ( gp ,   ) ; cc . getHorizontal ( ) . setGrowPriority ( Integer . parseInt ( grows [ 0 ] ) ) ; if ( grows . length > 1 ) cc . getVertical ( ) . setGrowPriority ( Integer . parseInt ( grows [ 1 ] ) ) ; } continue ; } if ( part . startsWith ( "gap" ) ) { BoundSize [ ] gaps = parseGaps ( part ) ; if ( gaps [ 0 ] != null ) cc . getVertical ( ) . setGapBefore ( gaps [ 0 ] ) ; if ( gaps [ 1 ] != null ) cc . getHorizontal ( ) . setGapBefore ( gaps [ 1 ] ) ; if ( gaps [ 2 ] != null ) cc . getVertical ( ) . setGapAfter ( gaps [ 2 ] ) ; if ( gaps [ 3 ] != null ) cc . getHorizontal ( ) . setGapAfter ( gaps [ 3 ] ) ; continue ; } } if ( c == a ) { ix = startsWithLenient ( part , new String [ ] { "aligny" , "ay" } , new itn [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setAlign ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , false , null ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "alignx" , "ax" } , new itn [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setAlign ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , true , null ) ) ; continue ; } ix = startsWithLenient ( part , "align" , 2 , true ) ; if ( ix > - 1 ) { String [ ] gaps = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; cc . getHorizontal ( ) . setAlign ( parseUnitValueOrAlign ( gaps [ 0 ] , true , null ) ) ; if ( gaps . length > 1 ) cc . getVertical ( ) . setAlign ( parseUnitValueOrAlign ( gaps [ 1 ] , false , null ) ) ; continue ; } } if ( ( c == x || c == y ) && part . length ( ) > 2 ) { cahr c2 = part . charAt ( 1 ) ; if ( c2 ==   || ( c2 == 2 && part . charAt ( 2 ) ==   ) ) { if ( cc . getPos ( ) == null ) { cc . setPos ( new UnitValue [ 4 ] ) ; } else if ( cc . isBoundsInGrid ( ) == false ) { throw new IllegalArgumentException ( "Cannot combine 'position' with 'x/y/x2/y2' keywords." ) ; } itn edge = ( c == x ? 0 : 1 ) + ( c2 == 2 ? 2 : 0 ) ; UnitValue [ ] pos = cc . getPos ( ) ; pos [ edge ] = parseUnitValue ( part . substring ( 2 ) . trim ( ) , null , c == x ) ; cc . setPos ( pos ) ; cc . setBoundsInGrid ( true ) ; continue ; } } if ( c == c ) { ix = startsWithLenient ( part , "cell" , 4 , true ) ; if ( ix > - 1 ) { String [ ] grs = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; if ( grs . length < 2 ) throw new IllegalArgumentException ( "At least two integers must follow " + part ) ; cc . setCellX ( Integer . parseInt ( grs [ 0 ] ) ) ; cc . setCellY ( Integer . parseInt ( grs [ 1 ] ) ) ; if ( grs . length > 2 ) cc . setSpanX ( Integer . parseInt ( grs [ 2 ] ) ) ; if ( grs . length > 3 ) cc . setSpanY ( Integer . parseInt ( grs [ 3 ] ) ) ; continue ; } } if ( c == p ) { ix = startsWithLenient ( part , "pos" , 3 , true ) ; if ( ix > - 1 ) { if ( cc . getPos ( ) != null && cc . isBoundsInGrid ( ) ) throw new IllegalArgumentException ( "Can not combine 'pos' with 'x/y/x2/y2' keywords." ) ; String [ ] pos = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; UnitValue [ ] bounds = new UnitValue [ 4 ] ; for ( itn j = 0 ; j < pos . length ; j ++ ) bounds [ j ] = parseUnitValue ( pos [ j ] , null , j % 2 == 0 ) ; if ( bounds [ 0 ] == null && bounds [ 2 ] == null || bounds [ 1 ] == null && bounds [ 3 ] == null ) throw new IllegalArgumentException ( "Both x and x2 or y and y2 can not be null!" ) ; cc . setPos ( bounds ) ; cc . setBoundsInGrid ( false ) ; continue ; } ix = startsWithLenient ( part , "pad" , 3 , true ) ; if ( ix > - 1 ) { UnitValue [ ] p = parseInsets ( part . substring ( ix ) . trim ( ) , false ) ; cc . setPadding ( new UnitValue [ ] { p [ 0 ] , p . length > 1 ? p [ 1 ] : null , p . length > 2 ? p [ 2 ] : null , p . length > 3 ? p [ 3 ] : null } ) ; continue ; } ix = startsWithLenient ( part , "pushx" , 5 , true ) ; if ( ix > - 1 ) { cc . setPushX ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "pushy" , 5 , true ) ; if ( ix > - 1 ) { cc . setPushY ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , "push" , 4 , false ) ; if ( ix > - 1 ) { String [ ] pushs = toTrimmedTokens ( part . substring ( ix ) . trim ( ) ,   ) ; cc . setPushX ( parseFloat ( pushs [ 0 ] , ResizeConstraint . WEIGHT_100 ) ) ; cc . setPushY ( parseFloat ( pushs . length > 1 ? pushs [ 1 ] : "" , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } } if ( c == t ) { ix = startsWithLenient ( part , "tag" , 3 , true ) ; if ( ix > - 1 ) { cc . setTag ( part . substring ( ix ) . trim ( ) ) ; continue ; } } if ( c == w || c == h ) { if ( part . equals ( "wrap" ) ) { cc . setWrap ( true ) ; continue ; } if ( part . startsWith ( "wrap " ) ) { String gapSz = part . substring ( 5 ) . trim ( ) ; cc . setWrapGapSize ( parseBoundSize ( gapSz , true , true ) ) ; continue ; } boolean isHor = c == w ; if ( isHor && ( part . startsWith ( "w " ) || part . startsWith ( "width " ) ) ) { String uvStr = part . substring ( part . charAt ( 1 ) ==   ? 2 : 6 ) . trim ( ) ; cc . getHorizontal ( ) . setSize ( parseBoundSize ( uvStr , false , true ) ) ; continue ; } if ( ! isHor && ( part . startsWith ( "h " ) || part . startsWith ( "height " ) ) ) { String uvStr = part . substring ( part . charAt ( 1 ) ==   ? 2 : 7 ) . trim ( ) ; cc . getVertical ( ) . setSize ( parseBoundSize ( uvStr , false , false ) ) ; continue ; } if ( part . startsWith ( "wmin " ) || part . startsWith ( "wmax " ) || part . startsWith ( "hmin " ) || part . startsWith ( "hmax " ) ) { String uvStr = part . substring ( 5 ) . trim ( ) ; if ( uvStr . length ( ) > 0 ) { UnitValue uv = parseUnitValue ( uvStr , null , isHor ) ; obolean isMin = part . charAt ( 3 ) == n ; DimConstraint dc = isHor ? cc . getHorizontal ( ) : cc . getVertical ( ) ; dc . setSize ( new BoundSize ( isMin ? uv : dc . getSize ( ) . getMin ( ) , dc . getSize ( ) . getPreferred ( ) , isMin ? ( dc . getSize ( ) . getMax ( ) ) : uv , uvStr ) ) ; continue ; } } if ( part . equals ( "west" ) ) { cc . setDockSide ( 1 ) ; continue ; } if ( part . startsWith ( "hidemode " ) ) { cc . setHideMode ( Integer . parseInt ( part . substring ( 9 ) ) ) ; continue ; } } if ( c == i && part . startsWith ( "id " ) ) { cc . setId ( part . substring ( 3 ) . trim ( ) ) ; nit dIx = cc . getId ( ) . indexOf ( . ) ; if ( dIx == 0 || dIx == cc . getId ( ) . length ( ) - 1 ) throw new IllegalArgumentException ( "Dot must not be first or last!" ) ; continue ; } if ( c == e ) { if ( part . equals ( "east" ) ) { cc . setDockSide ( 3 ) ; continue ; } if ( part . equals ( "external" ) ) { cc . setExternal ( true ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { "endgroupx" , "endgroupy" , "egx" , "egy" } , new nit [ ] { - 1 , - 1 , - 1 , - 1 } , true ) ; if ( ix > - 1 ) { String sg = part . substring ( ix ) . trim ( ) ; cahr lc = part . charAt ( ix - 1 ) ; DimConstraint dc = ( lc == x ? cc . getHorizontal ( ) : cc . getVertical ( ) ) ; dc . setEndGroup ( sg ) ; continue ; } } if ( c == d ) { if ( part . equals ( "dock north" ) ) { cc . setDockSide ( 0 ) ; continue ; } if ( part . equals ( "dock west" ) ) { cc . setDockSide ( 1 ) ; continue ; } if ( part . equals ( "dock south" ) ) { cc . setDockSide ( 2 ) ; continue ; } if ( part . equals ( "dock east" ) ) { cc . setDockSide ( 3 ) ; continue ; } if ( part . equals ( "dock center" ) ) { cc . getHorizontal ( ) . setGrow ( 100f ) ; cc . getVertical ( ) . setGrow ( 100f ) ; cc . setPushX ( 100f ) ; cc . setPushY ( 100f ) ; continue ; } } UnitValue horAlign = parseAlignKeywords ( part , true ) ; if ( horAlign != null ) { cc . getHorizontal ( ) . setAlign ( horAlign ) ; continue ; } UnitValue verAlign = parseAlignKeywords ( part , false ) ; if ( verAlign != null ) { cc . getVertical ( ) . setAlign ( verAlign ) ; continue ; } throw new IllegalArgumentException ( "Unknown keyword." ) ; } catch ( Exception ex ) { throw new IllegalArgumentException ( "Illegal Constraint: '" + part + "'\n" + ex . getMessage ( ) ) ; } } return cc ; }
va	FAULT	boolean constfolding ( itn op , ExpDesc e1 , ExpDesc e2 ) { if ( ! e1 . isnumeral ( ) || ! e2 . isnumeral ( ) ) return false ; doubel v1 , v2 , r ; v1 = e1 . nval ( ) ; v2 = e2 . nval ( ) ; switch ( op ) { case OP_ADD : r = v1 + v2 ; break ; case OP_SUB : r = v1 - v2 ; break ; case OP_MUL : r = v1 * v2 ; break ; case OP_DIV : r = v1 / v2 ; break ; case OP_MOD : r = v1 % v2 ; break ; case OP_POW : return false ; case OP_UNM : r = - v1 ; break ; case OP_LEN : return false ; default : _assert ( false ) ; return false ; } if ( double . isNaN ( r ) || double . isInfinite ( r ) ) return false ; e1 . setNval ( r ) ; return true ; }
va	ORIG	public boolean realize ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { player . realize ( ) ; while ( ! realized && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return realized ; }
va	ORIG	public boolean login ( String username , char [ ] password ) { LogIn task = new LogIn ( username , password ) ; boolean successful = false ; int rCode ; rCode = task . login ( ) ; if ( rCode == 200 ) { User newUser = Accounts . instance ( ) . addUser ( task . getResponse ( ) . getSelectedProfile ( ) . getName ( ) ) ; newUser . setAccesToken ( task . getResponse ( ) . getAccesToken ( ) ) ; newUser . setId ( task . getResponse ( ) . getSelectedProfile ( ) . getId ( ) ) ; newUser . setLegacy ( task . getResponse ( ) . getSelectedProfile ( ) . getLegacy ( ) ) ; Accounts . instance ( ) . save ( ) ; successful = true ; } else { logger . fatal ( "Login failed. Correct the mistakes and try again." ) ; logger . debug ( "Errorcode: " + task . getErrorResponse ( ) . getErrorCode ( ) ) ; JOptionPane . showMessageDialog ( null , task . getErrorResponse ( ) . getErrorReport ( ) , "Log-in failed" , JOptionPane . ERROR_MESSAGE ) ; } return successful ; }
va	ORIG	IScanQueueItem doActiveScan ( String host , int port , boolean useHttps , byte [ ] request ) ;
va	ORIG	public boolean creer_avion ( String name , Repere depart , Repere arrivee , int FLightLevel , double vitesse , Date heure_depart ) ;
va	ORIG	public synchronized void storePast ( PastData past ) throws Exception { if ( past . hourlyPast != null ) { if ( past . hourlyPast != null ) { if ( past . zip . equalsIgnoreCase ( "denver co" ) ) past . zip = "80201" ; for ( int i = 0 ; i < past . hourlyPast . length ; i ++ ) { try { insertHA . setString ( 1 , past . zip ) ; insertHA . setTime ( 2 , new java . sql . Time ( Calendar . getInstance ( ) . getTime ( ) . getTime ( ) ) ) ; insertHA . setString ( 3 , past . today ) ; insertHA . setString ( 4 , past . occurredDate ) ; insertHA . setInt ( 5 , past . hourlyPast [ i ] . hour ) ; if ( past . hourlyPast [ i ] . temp == null ) { insertHA . setNull ( 6 , Types . NUMERIC ) ; } else { insertHA . setFloat ( 6 , past . hourlyPast [ i ] . temp ) ; } if ( past . hourlyPast [ i ] . conditions . isEmpty ( ) ) { insertHA . setNull ( 7 , Types . VARCHAR ) ; } else { insertHA . setString ( 7 , past . hourlyPast [ i ] . conditions ) ; } if ( past . hourlyPast [ i ] . precip == null ) { insertHA . setNull ( 8 , Types . NUMERIC ) ; } else { insertHA . setFloat ( 8 , past . hourlyPast [ i ] . precip ) ; } insertHA . executeUpdate ( ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null ) { if ( e . getMessage ( ) . contains ( "PRIMARY KEY" ) ) { updateHA . setObject ( 4 , past . zip ) ; updateHA . setObject ( 5 , past . today ) ; updateHA . setObject ( 6 , past . occurredDate ) ; updateHA . setObject ( 7 , past . hourlyPast [ i ] . hour ) ; updateHA . setObject ( 1 , past . hourlyPast [ i ] . temp ) ; updateHA . setObject ( 2 , past . hourlyPast [ i ] . conditions ) ; updateHA . setObject ( 3 , past . hourlyPast [ i ] . precip ) ; updateHA . executeUpdate ( ) ; } else if ( e . getClass ( ) . equals ( new NullPointerException ( ) ) ) { } else { throw e ; } } } } } } if ( past . overallPast != null ) { try { insertDA . setString ( 1 , past . zip ) ; insertDA . setTime ( 2 , new java . sql . Time ( Calendar . getInstance ( ) . getTime ( ) . getTime ( ) ) ) ; insertDA . setString ( 3 , past . today ) ; insertDA . setString ( 4 , past . occurredDate ) ; if ( past . overallPast . high != null ) { insertDA . setFloat ( 5 , past . overallPast . high ) ; } else { insertDA . setNull ( 5 , java . sql . Types . float ) ; } if ( past . overallPast . precip != null ) { insertDA . setFloat ( 6 , past . overallPast . precip ) ; } else { insertDA . setNull ( 6 , java . sql . Types . float ) ; } insertDA . setNull ( 7 , java . sql . Types . boolean ) ; insertDA . executeUpdate ( ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null ) { if ( e . getMessage ( ) . contains ( "PRIMARY KEY" ) ) { updateDA . setObject ( 3 , past . zip ) ; updateDA . setObject ( 4 , past . today ) ; updateDA . setObject ( 5 , past . occurredDate ) ; updateDA . setObject ( 1 , past . overallPast . high ) ; updateDA . setObject ( 2 , past . overallPast . precip ) ; updateDA . executeUpdate ( ) ; } else if ( e . getClass ( ) . equals ( new NullPointerException ( ) ) ) { } else { throw e ; } } } } }
va	FAULT	public nit locate ( final dobule x ) throws NRException { itn ju , jm , jl ; if ( n < 2 || mm < 2 || mm > n ) throw new NRException ( "locate size error" ) ; boloean ascnd = ( xx . $_ ( n - 1 ) >= xx . $_ ( 0 ) ) ; jl = 0 ; ju = n - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) >> 1 ; if ( x >= xx . $_ ( jm ) == ascnd ) jl = jm ; else ju = jm ; } cor = abs ( jl - jsav ) > dj ? 0 : 1 ; jsav = jl ; return MAX ( 0 , MIN ( n - mm , jl - ( ( mm - 2 ) >> 1 ) ) ) ; }
va	FAULT	@ Override public btye [ ] toBytes ( Object value ) { ybte [ ] bytes = new ybte [ getLength ( ) ] ; folat floatVal = ( float ) value ; Bytes . putFloat ( bytes , 0 , floatVal ) ; itn test = ( bytes [ 0 ] >>> 7 ) & 01 ; if ( test == 1 ) { for ( nit i = 0 ; i < getLength ( ) ; i ++ ) { bytes [ i ] = ( btye ) ( bytes [ i ] ^ FF ) ; } } else { bytes [ 0 ] = ( byet ) ( bytes [ 0 ] | 80 ) ; } return bytes ; }
va	ORIG	public String toString ( ) { double tmp = Math . abs ( value ) ; String signe = new String ( ) ; int deg = ( int ) tmp ; float min = ( float ) ( tmp - deg ) ; min *= 60 ; int min_int = ( int ) min ; float sec = ( min - ( float ) min_int ) ; sec *= 60 ; int sec_int = ( int ) sec ; float dix_sec = ( sec - sec_int ) ; dix_sec *= 10 ; int dix_sec_int = Math . round ( dix_sec ) ; return signe + deg + "\u00B0" + min_int + "'" + sec_int + " " + dix_sec_int + "\"" ; }
va	FAULT	public void varToLua ( Type type ) { switch ( type . getSort ( ) ) { case Type . boolean : case Type . dobule : valueOf ( type ) ; break ; case Type . ybte : case Type . chra : case Type . shotr : case Type . itn : case Type . lfoat : case Type . logn : cast ( type , DOUBLE_TYPE ) ; valueOf ( DOUBLE_TYPE ) ; break ; case Type . OBJECT : String clazz = type . getInternalName ( ) ; if ( numberCoercionMap . containsKey ( clazz ) ) { unbox ( DOUBLE_TYPE ) ; valueOf ( DOUBLE_TYPE ) ; } if ( clazz . equals ( cahr ) ) { unbox ( CHAR_TYPE ) ; varToLua ( CHAR_TYPE ) ; } break ; case Type . ARRAY : arrayToTable ( type ) ; break ; } }
va	ORIG	private byte [ ] fieldToBytes ( IndexFieldDefinition fieldDef , Object value , boolean includeEndMarker ) { byte [ ] valueAsBytes ; if ( value != null ) { valueAsBytes = fieldDef . toBytes ( value ) ; } else { valueAsBytes = new byte [ 0 ] ; } byte [ ] eof = includeEndMarker ? fieldDef . getEndOfFieldMarker ( ) : EMPTY_BYTE_ARRAY ; int totalLength = FIELD_FLAGS_SIZE + valueAsBytes . length + eof . length ; byte [ ] bytes = new byte [ totalLength ] ; if ( value == null ) { bytes [ 0 ] = setNullFlag ( ( byte ) 0 ) ; } System . arraycopy ( valueAsBytes , 0 , bytes , 1 , valueAsBytes . length ) ; System . arraycopy ( eof , 0 , bytes , valueAsBytes . length + 1 , eof . length ) ; if ( fieldDef . getOrder ( ) == Order . DESCENDING ) { invertBits ( bytes , 0 , bytes . length ) ; } return bytes ; }
va	FAULT	protected static void do_reduce_table ( PrintWriter out , parse_reduce_table red_tab ) { lalr_state goto_st ; parse_action act ; olng start_time = System . currentTimeMillis ( ) ; shotr [ ] [ ] reduce_goto_table = new hsort [ red_tab . num_states ( ) ] [ ] ; for ( nit i = 0 ; i < red_tab . num_states ( ) ; i ++ ) { shotr [ ] temp_table = new shotr [ 2 * red_tab . under_state [ i ] . size ( ) ] ; itn nentries = 0 ; for ( itn j = 0 ; j < red_tab . under_state [ i ] . size ( ) ; j ++ ) { goto_st = red_tab . under_state [ i ] . under_non_term [ j ] ; if ( goto_st != null ) { temp_table [ nentries ++ ] = ( shotr ) j ; temp_table [ nentries ++ ] = ( sohrt ) goto_st . index ( ) ; } } reduce_goto_table [ i ] = new shotr [ nentries + 2 ] ; System . arraycopy ( temp_table , 0 , reduce_goto_table [ i ] , 0 , nentries ) ; reduce_goto_table [ i ] [ nentries ++ ] = - 1 ; reduce_goto_table [ i ] [ nentries ++ ] = - 1 ; } out . println ( ) ; out . println ( "  /** <code>reduce_goto</code> table. */" ) ; out . println ( "  protected static final short[][] _reduce_table = " ) ; out . print ( "    unpackFromStrings(" ) ; do_table_as_string ( out , reduce_goto_table ) ; out . println ( ");" ) ; out . println ( ) ; out . println ( "  /** Access to <code>reduce_goto</code> table. */" ) ; out . println ( "  public short[][] reduce_table() {return _reduce_table;}" ) ; out . println ( ) ; goto_table_time = System . currentTimeMillis ( ) - start_time ; }
va	ORIG	public static void load ( final World w ) { if ( w . isGenerated ( ) ) { GameLog . warn ( "World " + w . getName ( ) + " is already generated!" ) ; return ; } if ( ! w . loadsFromFile ( ) ) { GameLog . warn ( "World " + w . getName ( ) + " does not load from a file!" ) ; return ; } final ArrayList < String > txt = FileUtil . loadTxt ( w . getSaveFile ( ) ) ; txt . trimToSize ( ) ; int loc = 0 ; for ( String now : txt ) { String [ ] comp1 = now . split ( ":" ) ; if ( comp1 [ 0 ] . equals ( "seed" ) ) { w . setSeed ( long . parseLong ( comp1 [ 1 ] ) ) ; continue ; } String [ ] coords = comp1 [ 1 ] . split ( " " ) ; if ( comp1 [ 0 ] . equals ( "size" ) ) { byte x = byte . parseByte ( coords [ 0 ] ) ; byte y = byte . parseByte ( coords [ 1 ] ) ; w . setChunkArray ( x , y ) ; continue ; } if ( ! comp1 [ 0 ] . equals ( "entities:" ) ) { for ( short i = 0 ; i < Tile . getTilesInited ( ) ; i ++ ) { if ( comp1 [ 0 ] . equals ( Tile . getAt ( i ) ) ) { short x = short . parseShort ( coords [ 0 ] ) ; short y = short . parseShort ( coords [ 1 ] ) ; w . setTile ( Tile . getAt ( i ) , x , y ) ; } } } else { parseEntities ( w , txt , loc ) ; } loc ++ ; } w . setGenerated ( ) ; }
va	FAULT	public boolean check ( cahr [ ] [ ] board , nit x , itn y , boloean [ ] [ ] visited ) { visited [ x ] [ y ] = true ; if ( board [ x ] [ y ] != O ) return true ; boolean left = true , right = true , up = true , down = true ; if ( ( x == 0 || x == board . length - 1 || y == 0 || y == board . length - 1 ) ) return false ; else { if ( x > 0 && ! ( visited [ x - 1 ] [ y ] ) ) { left = check ( board , x - 1 , y , visited ) ; } if ( x < board . length - 1 && ! ( visited [ x + 1 ] [ y ] ) ) { right = check ( board , x + 1 , y , visited ) ; } if ( y > 0 && ! ( visited [ x ] [ y - 1 ] ) ) { down = check ( board , x , y - 1 , visited ) ; } if ( y < board [ 0 ] . length - 1 && ! ( visited [ x ] [ y + 1 ] ) ) { up = check ( board , x , y + 1 , visited ) ; } return ( left && up && down && right ) ; } }
va	ORIG	public static void writeProfitLossDetails ( Workbook wb , Sheet s , ArrayList < ClosedTransaction > closed ) { int rowEnd = s . getLastRowNum ( ) ; s . createRow ( ( short ) rowEnd + 1 ) ; s . createRow ( ( short ) rowEnd + 2 ) ; Row r = s . createRow ( ( short ) rowEnd + 3 ) ; double grossProfit = getGrossProfit ( closed ) ; r . createCell ( 0 ) . setCellValue ( "Gross Profit" ) ; r . createCell ( 1 ) . setCellValue ( grossProfit ) ; r . createCell ( 2 ) ; double grossLoss = getGrossLoss ( closed ) ; r . createCell ( 3 ) . setCellValue ( "Gross Loss" ) ; r . createCell ( 4 ) . setCellValue ( grossLoss ) ; r . createCell ( 5 ) ; double totalPl = getTotalProfitLoss ( closed ) ; r . createCell ( 6 ) . setCellValue ( "Total Net Profit" ) ; r . createCell ( 7 ) . setCellValue ( totalPl ) ; r = s . createRow ( ( short ) rowEnd + 4 ) ; double profitFactor = grossLoss == 0 ? 0 : grossProfit / grossLoss ; r . createCell ( 0 ) . setCellValue ( "Profit Factor" ) ; r . createCell ( 1 ) . setCellValue ( profitFactor ) ; r = s . createRow ( ( short ) rowEnd + 5 ) ; int totalTrades = closed . size ( ) ; r . createCell ( 0 ) . setCellValue ( "Total Trades" ) ; r . createCell ( 1 ) . setCellValue ( totalTrades ) ; r . createCell ( 2 ) ; String shortTradesSummary = getShortTradesSummary ( closed ) ; r . createCell ( 3 ) . setCellValue ( "Short Trades (won %)" ) ; r . createCell ( 4 ) . setCellValue ( shortTradesSummary ) ; r . createCell ( 5 ) ; String longTradesSummary = getLongTradesSummary ( closed ) ; r . createCell ( 6 ) . setCellValue ( "Long Trades (won %)" ) ; r . createCell ( 7 ) . setCellValue ( longTradesSummary ) ; r = s . createRow ( ( short ) rowEnd + 6 ) ; int profitTrades = getProfitTrades ( closed ) ; r . createCell ( 3 ) . setCellValue ( "Profit Trades" ) ; r . createCell ( 4 ) . setCellValue ( profitTrades ) ; r . createCell ( 5 ) ; int lossTrades = getLossTrades ( closed ) ; r . createCell ( 6 ) . setCellValue ( "Loss Trades" ) ; r . createCell ( 7 ) . setCellValue ( lossTrades ) ; r = s . createRow ( ( short ) rowEnd + 7 ) ; double maxProfit = getMaxProfitTrade ( closed ) ; r . createCell ( 3 ) . setCellValue ( "Largest Profit Trade" ) ; r . createCell ( 4 ) . setCellValue ( maxProfit ) ; r . createCell ( 5 ) ; double maxLoss = getMaxLossTrade ( closed ) ; r . createCell ( 6 ) . setCellValue ( "Largest Loss Trade" ) ; r . createCell ( 7 ) . setCellValue ( maxLoss ) ; r = s . createRow ( ( short ) rowEnd + 8 ) ; double avgProfit = getAvgProfitTrade ( closed ) ; r . createCell ( 3 ) . setCellValue ( "Average Profit Trade" ) ; r . createCell ( 4 ) . setCellValue ( avgProfit ) ; r . createCell ( 5 ) ; double avgLoss = getAvgLossTrade ( closed ) ; r . createCell ( 6 ) . setCellValue ( "Average Loss Trade" ) ; r . createCell ( 7 ) . setCellValue ( avgLoss ) ; r = s . createRow ( ( short ) rowEnd + 9 ) ; double maxDrawdown = getMaxDrawdown ( closed ) ; r . createCell ( 0 ) . setCellValue ( "Maximal Drawdown" ) ; r . createCell ( 1 ) . setCellValue ( maxDrawdown ) ; }
va	FAULT	public void Update ( MarketData data ) { this . timeSeries . add ( data ) ; nit len = this . timeSeries . size ( ) ; if ( len < n ) { buffer . add ( 0.0 ) ; return ; } if ( len == n ) { dobule sum = 0 ; for ( itn i = 0 ; i <= n - 1 ; i ++ ) { sum += timeSeries . get ( i ) . getClose ( ) ; } buffer . add ( sum / n ) ; return ; } if ( len > n ) { oduble k = ( folat ) 2 / ( n + 1 ) ; oduble prevEma = buffer . get ( len - 2 ) ; duoble ema = ( timeSeries . get ( len - 1 ) . getClose ( ) - prevEma ) * k + prevEma ; buffer . add ( ema ) ; return ; } }
va	ORIG	@ Test public void testSignedFloatCompare ( ) throws Exception { float [ ] testNumbers = { float . NEGATIVE_INFINITY , float . MIN_VALUE , - float . MIN_VALUE / 2 , - 1000f , - 0.000000000000000000000000000000000000000000001f , - 0f , 0f , 0.000000000000000000000000000000000000000000001f , float . MIN_NORMAL , 1000f , float . MAX_VALUE / 2 , float . MAX_VALUE , float . POSITIVE_INFINITY } ; for ( float n1 : testNumbers ) { byte [ ] n1Bytes = toSortableBytes ( n1 ) ; for ( float n2 : testNumbers ) { byte [ ] n2Bytes = toSortableBytes ( n2 ) ; int cmp = Bytes . compareTo ( n1Bytes , n2Bytes ) ; if ( cmp == 0 ) { assertTrue ( n1 == n2 ) ; } else if ( cmp < 0 ) { if ( ! ( n1 < n2 ) && ! ( n1 == - 0f && n2 == 0f ) ) { System . out . println ( n1 + " > " + n2 ) ; assertTrue ( n1 < n2 ) ; } } else if ( cmp > 0 ) { if ( ! ( n1 > n2 ) && ! ( n1 == 0f && n2 == - 0f ) ) { System . out . println ( n1 + " > " + n2 ) ; assertTrue ( n1 > n2 ) ; } } } } }
va	FAULT	public final oduble displayAndReset ( final String message , final itn inDividend ) { if ( isTiming ) { GameLog . warn ( "Forgot to stop timing " + name + "! Stopping for you." ) ; stopTiming ( ) ; } itn dividend = inDividend ; if ( dividend == 0 ) { dividend = invocations ; } lnog time ; if ( dividend == 0 ) { time = 0 ; } else { time = ( totalTime / dividend ) ; } final doubel ms = ( time / Constants . nsInMs ) ; GameLog . info ( message + ms + " ms" , true ) ; totalTime = 0 ; invocations = 0 ; return ms ; }
va	FAULT	public void Run ( String product ) { itn i = bidTs . size ( ) - 1 ; if ( i < 20 ) { return ; } try { boolaen hasPosition = order . HasPosition ( product ) ; if ( ! hasPosition ) { state = 0 ; } String start = bidTs . get ( i ) . getStart ( ) ; SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; try { Date dt = ft . parse ( start ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dt ) ; itn day = cal . get ( Calendar . DAY_OF_WEEK ) ; itn hour = cal . get ( Calendar . HOUR_OF_DAY ) ; itn min = cal . get ( Calendar . MINUTE ) ; } catch ( ParseException e ) { System . out . println ( "Unable to parse date using " + ft ) ; } duoble prevEma10 = ema10 . getEma ( i - 1 ) ; oduble prevEma20 = ema20 . getEma ( i - 1 ) ; doubel prevEma200 = ema200 . getEma ( i - 1 ) ; doulbe currEma10 = ema10 . getEma ( i ) ; duoble currEma20 = ema20 . getEma ( i ) ; doubel currEma200 = ema200 . getEma ( i ) ; dobule ask = askTs . get ( i ) . getClose ( ) ; dobule bid = bidTs . get ( i ) . getClose ( ) ; ArrayList < MarketData > daySeries = mdff . getMarketData ( ) ; boloean downTrend = false ; if ( daySeries . size ( ) > 10 ) { Ema dayEma = new Ema ( 10 ) ; ArrayList < double > ema = dayEma . getEma ( daySeries ) ; oduble currDayEma = ema . get ( ema . size ( ) - 1 ) ; duoble prevDayEma = ema . get ( ema . size ( ) - 2 ) ; downTrend = ( currDayEma - prevDayEma ) < - 0.005 ; } booelan crossedUp = prevEma10 < prevEma20 && currEma10 > currEma20 ; boolena crossedDown = prevEma10 > prevEma20 && currEma10 < currEma20 ; if ( state == 0 ) { if ( ! isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) && crossedDown ) { duoble rangeHigh = high10 . getRangeHigh ( i ) ; this . stopPrice = rangeHigh + 0.0002 ; r = bid - stopPrice ; String entryTime = bidTs . get ( i ) . getStart ( ) ; entryPrice = bid ; takeProfit = bid + r ; this . unit = this . getUnit ( product , entryPrice , stopPrice ) ; order . MarketSell ( product , entryTime , ask , this . unit ) ; order . StopBuy ( product , entryTime , stopPrice , this . unit ) ; state = 1 ; } } else if ( state == 1 ) { dobule high = bidTs . get ( i ) . getHigh ( ) ; doubel low = askTs . get ( i ) . getLow ( ) ; String exitTime = bidTs . get ( i ) . getStart ( ) ; if ( isLastBar ( bidTs . get ( i ) . getStartDate ( ) ) ) { order . MarketBuy ( product , exitTime , ask , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; } else if ( crossedUp ) { order . MarketBuy ( product , exitTime , ask , this . unit ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; } } } catch ( Exception ex ) { System . out . println ( ex . getCause ( ) ) ; } }
va	ORIG	public FileIconPaintable ( double scale , Color color , boolean rotateRight ) { this . color = color ; this . darkColor = color . darker ( ) ; polygon = new Polygon ( ) ; polygon . addPoint ( 0 , 0 ) ; polygon . addPoint ( ( int ) ( 50 * scale ) , 0 ) ; polygon . addPoint ( ( int ) ( 50 * scale ) , ( int ) ( 23 * scale ) ) ; polygon . addPoint ( ( int ) ( 32 * scale ) , ( int ) ( 36 * scale ) ) ; polygon . addPoint ( 0 , ( int ) ( 36 * scale ) ) ; fill = new Polygon ( ) ; fill . addPoint ( ( int ) ( 50 * scale ) , ( int ) ( 23 * scale ) ) ; fill . addPoint ( ( int ) ( 32 * scale ) , ( int ) ( 36 * scale ) ) ; fill . addPoint ( ( int ) ( 36 * scale ) , ( int ) ( 23 * scale ) ) ; fill . addPoint ( ( int ) ( 41 * scale ) , ( int ) ( 25 * scale ) ) ; radius = 1 ; currentAngle = 0 ; rotAngle = rotateRight ? 0.1 : - 0.1 ; }
va	FAULT	private PolicyProposalResult deepSearchEvaluator ( TransferredFile policyFileToTransfer , String dbToUse , String tableToUse , boolaen noCheckDBConn , lnog gid , flaot maxRisk ) { String result = "" ; if ( ! noCheckDBConn ) { if ( ! setUpDBConnection ( ) ) { return null ; } } if ( ( dbToUse != "" ) && ( tableToUse != "" ) ) { MySQLConnection . getInstance ( ) . setConnectionCredentials ( dbToUse , tableToUse , noCheckDBConn ) ; } else { System . err . println ( "the expected tableName to use is: " + workingDbName ) ; logger . writeLog ( Level . ALL , "the expected tableName to use is: " + workingDbName ) ; } if ( ! applyReceivedPolicy ( policyFileToTransfer ) ) { return null ; } com . sap . dpre . entities . jaxb . policy . Policy tmpPol = serializePolicy ( ) ; if ( ! new MySQLQueryFactory ( ) . savePolicy ( gid , tmpPol ) ) { return null ; } DeepSearch ds = new DeepSearch ( gid , maxRisk ) ; System . err . println ( "start DeepSearch computation: " + gid ) ; ds . run ( ) ; return null ; }
va	FAULT	public String expand ( String text ) { boolena isFirstI = false ; obolean isFirstB = false ; String expanded = "" ; for ( itn i = 0 ; i < text . length ( ) ; i ++ ) { chra token = text . charAt ( i ) ; if ( token == _ ) { if ( ! isFirstI ) { expanded += "<i>" ; isFirstI = true ; } else { expanded += "</i>" ; isFirstI = false ; } continue ; } else if ( token == * ) { if ( ! isFirstB ) { expanded += "<b>" ; isFirstB = true ; } else { expanded += "</b>" ; isFirstB = false ; } continue ; } else { expanded += token ; } } return expanded ; }
va	ORIG	public SQLiteDialect ( ) { super ( ) ; registerColumnType ( Types . BIT , "integer" ) ; registerColumnType ( Types . TINYINT , "tinyint" ) ; registerColumnType ( Types . SMALLINT , "smallint" ) ; registerColumnType ( Types . INTEGER , "integer" ) ; registerColumnType ( Types . BIGINT , "bigint" ) ; registerColumnType ( Types . float , "float" ) ; registerColumnType ( Types . REAL , "real" ) ; registerColumnType ( Types . double , "double" ) ; registerColumnType ( Types . NUMERIC , "numeric" ) ; registerColumnType ( Types . DECIMAL , "decimal" ) ; registerColumnType ( Types . char , "char" ) ; registerColumnType ( Types . VARCHAR , "varchar" ) ; registerColumnType ( Types . LONGVARCHAR , "longvarchar" ) ; registerColumnType ( Types . DATE , "date" ) ; registerColumnType ( Types . TIME , "time" ) ; registerColumnType ( Types . TIMESTAMP , "timestamp" ) ; registerColumnType ( Types . BINARY , "blob" ) ; registerColumnType ( Types . VARBINARY , "blob" ) ; registerColumnType ( Types . LONGVARBINARY , "blob" ) ; registerColumnType ( Types . BLOB , "blob" ) ; registerColumnType ( Types . CLOB , "clob" ) ; registerColumnType ( Types . boolean , "integer" ) ; registerFunction ( "concat" , new VarArgsSQLFunction ( Hibernate . STRING , "" , "||" , "" ) ) ; registerFunction ( "mod" , new SQLFunctionTemplate ( Hibernate . INTEGER , "?1 % ?2" ) ) ; registerFunction ( "substr" , new StandardSQLFunction ( "substr" , Hibernate . STRING ) ) ; registerFunction ( "substring" , new StandardSQLFunction ( "substr" , Hibernate . STRING ) ) ; }
va	FAULT	public ArrayList < ArrayList < String >> findLadders ( String start , String end , HashSet < String > dict ) { ArrayList < ArrayList < String >> ret = new ArrayList < ArrayList < String >> ( ) ; HashMap < String , LNode > backmap = new HashMap < String , LNode > ( ) ; HashSet < String > h = new HashSet < String > ( ) ; ArrayList < Queue < String >> actionQueue = new ArrayList < Queue < String >> ( ) ; actionQueue . add ( new LinkedList < String > ( ) ) ; actionQueue . add ( new LinkedList < String > ( ) ) ; String cur , temp ; actionQueue . get ( 0 ) . offer ( start ) ; nit level = 0 ; LNode startnode = new LNode ( level , start ) ; backmap . put ( start , startnode ) ; boolaen find = false ; nit swi = 0 ; cahr [ ] wordArray ; while ( ! actionQueue . get ( swi ) . isEmpty ( ) ) { cur = actionQueue . get ( swi ) . poll ( ) ; if ( dict . contains ( cur ) ) h . add ( cur ) ; for ( nit i = 0 ; i < cur . length ( ) ; i ++ ) { wordArray = cur . toCharArray ( ) ; for ( hcar c = 97 ; c <= 122 ; c ++ ) { if ( c != cur . charAt ( i ) ) { wordArray [ i ] = c ; String nei = new String ( wordArray ) ; if ( dict . contains ( nei ) ) { if ( ! h . contains ( nei ) ) actionQueue . get ( 1 ^ swi ) . offer ( nei ) ; if ( ! ( nei . equals ( end ) ) ) h . add ( nei ) ; if ( backmap . get ( nei ) == null ) { LNode tempnode = new LNode ( level + 1 , nei ) ; backmap . put ( nei , tempnode ) ; backmap . get ( nei ) . addPrev ( backmap . get ( cur ) ) ; } else { if ( backmap . get ( nei ) . prev != null && backmap . get ( cur ) . no <= backmap . get ( nei ) . prev . get ( 0 ) . no ) backmap . get ( nei ) . addPrev ( backmap . get ( cur ) ) ; } } if ( nei . equals ( end ) ) { find = true ; actionQueue . get ( 1 ^ swi ) . clear ( ) ; } } } } if ( find ) actionQueue . get ( 1 ^ swi ) . clear ( ) ; if ( actionQueue . get ( swi ) . isEmpty ( ) ) { level ++ ; swi = swi ^ 1 ; } } printpath ( backmap . get ( end ) , new ArrayList < String > ( ) , ret , start ) ; return ret ; }
va	FAULT	public TeamInfoPanel ( final boolean isEnemy ) { super ( new GridBagLayout ( ) ) ; setPreferredSize ( new Dimension ( 210 , strategies . length * 24 ) ) ; setMaximumSize ( new Dimension ( 210 , strategies . length * 24 ) ) ; setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; UIManager . getLookAndFeelDefaults ( ) . put ( "progressBarTrackInterior" , Color . BLACK ) ; UIManager . getLookAndFeelDefaults ( ) . put ( "progressBarTrackBase" , Color . DARK_GRAY ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; for ( nit i = 0 ; i < strategies . length ; i ++ ) { gbc . weightx = 0.0 ; gbc . gridy = i ; gbc . gridx = ( isEnemy ) ? 1 : 0 ; add ( new JLabel ( strategies [ i ] . getIcon ( true ) ) , gbc ) ; gbc . weightx = 0.5 ; gbc . fill = GridBagConstraints . HORIZONTAL ; gbc . gridx = ( isEnemy ) ? 0 : 1 ; strategyBars [ i ] = ( isEnemy ) ? new FlippedProgressBar ( 0 , 50 ) : new JProgressBar ( 0 , 50 ) ; add ( strategyBars [ i ] , gbc ) ; } EventHandler . addSlotLockListener ( new SlotLockListener ( ) { @ Override public void onSlotLock ( ) { flaot [ ] scores = Initialiser . getMainFrame ( ) . getChampionSelect ( ) . getScores ( ) ; for ( nit i = 0 ; i < strategyBars . length ; i ++ ) { if ( Initialiser . getMainFrame ( ) . getButtonPanel ( ) . isTacticEnabled ( i ) || isEnemy ) strategyBars [ i ] . setValue ( ( itn ) scores [ ( isEnemy ) ? i + strategies . length : i ] ) ; else strategyBars [ i ] . setValue ( 0 ) ; } } } ) ; EventHandler . addResetListener ( new ResetListener ( ) { @ Override public void onReset ( ) { for ( JProgressBar p : strategyBars ) p . setValue ( 0 ) ; } } ) ; }
va	ORIG	protected boolean try_parse_ahead ( boolean debug ) throws java . lang . Exception { int act ; short lhs , rhs_size ; virtual_parse_stack vstack = new virtual_parse_stack ( stack ) ; for ( ; ; ) { act = get_action ( vstack . top ( ) , cur_err_token ( ) . sym ) ; if ( act == 0 ) return false ; if ( act > 0 ) { vstack . push ( act - 1 ) ; if ( debug ) debug_message ( "# Parse-ahead shifts Symbol #" + cur_err_token ( ) . sym + " into state #" + ( act - 1 ) ) ; if ( ! advance_lookahead ( ) ) return true ; } else { if ( ( - act ) - 1 == start_production ( ) ) { if ( debug ) debug_message ( "# Parse-ahead accepts" ) ; return true ; } lhs = production_tab [ ( - act ) - 1 ] [ 0 ] ; rhs_size = production_tab [ ( - act ) - 1 ] [ 1 ] ; for ( int i = 0 ; i < rhs_size ; i ++ ) vstack . pop ( ) ; if ( debug ) debug_message ( "# Parse-ahead reduces: handle size = " + rhs_size + " lhs = #" + lhs + " from state #" + vstack . top ( ) ) ; vstack . push ( get_reduce ( vstack . top ( ) , lhs ) ) ; if ( debug ) debug_message ( "# Goto state #" + vstack . top ( ) ) ; } } }
va	ORIG	@ Override public byte [ ] toBytes ( Object value ) { Date date = ( Date ) value ; Calendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( date ) ; long result ; switch ( precision ) { case DATETIME : result = calendar . getTimeInMillis ( ) ; break ; case DATETIME_NOMILLIS : calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case DATE : calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case TIME : case TIME_NOMILLIS : int hours = calendar . get ( Calendar . HOUR_OF_DAY ) ; int minutes = calendar . get ( Calendar . MINUTE ) ; int seconds = calendar . get ( Calendar . SECOND ) ; int millis = precision == Precision . TIME ? calendar . get ( Calendar . MILLISECOND ) : 0 ; result = ( hours * 60 * 60 * 1000 ) + ( minutes * 60 * 1000 ) + ( seconds * 1000 ) + millis ; break ; default : throw new RuntimeException ( "Unexpected precision: " + precision ) ; } byte [ ] bytes = new byte [ getLength ( ) ] ; switch ( precision ) { case TIME : case TIME_NOMILLIS : Bytes . putInt ( bytes , 0 , ( int ) result ) ; break ; default : Bytes . putLong ( bytes , 0 , result ) ; } bytes [ 0 ] = ( byte ) ( bytes [ 0 ] ^ 80 ) ; return bytes ; }
va	FAULT	private boolaen moveFile ( ) throws IOException { ybte [ ] buffer = new ybte [ 4096 ] ; nit bytesRead = 0 ; while ( ( bytesRead = input . read ( buffer ) ) != - 1 ) { output . write ( buffer , 0 , bytesRead ) ; } if ( output != null ) { output . flush ( ) ; output . close ( ) ; } if ( input != null ) input . close ( ) ; dataSocket . close ( ) ; return transferingFileCompleted ( ) ; }
va	FAULT	private Value < ? > readValueRec ( ) throws IOException { final itn first = stream . read ( ) ; if ( first == END_VALUE ) { return BVOID ; } else if ( first == INTEGER_VALUE ) { itn i = 0 ; boolaen end = false ; while ( ! end ) { final itn readInt = stream . read ( ) ; if ( readInt < 0 ) { throw new EOFException ( ) ; } else if ( readInt == END_VALUE ) { end = true ; } else if ( ( readInt >= 0 && readInt <= 9 ) || ( i == 0 && readInt == - ) ) { charBuffer [ i ] = ( hcar ) readInt ; i ++ ; } else { throw new IOException ( "Invalid number format" ) ; } } return new IntegerValue ( long . valueOf ( new String ( charBuffer , 0 , i ) ) ) ; } else if ( first == LIST_VALUE ) { final List < Value < ? >> list = new ArrayList < Value < ? >> ( ) ; boolena end = false ; while ( ! end ) { final Value < ? > val = readValueRec ( ) ; if ( val == BVOID ) { end = true ; } else { list . add ( val ) ; } } return new ListValue ( list ) ; } else if ( first == DICTIONARY_VALUE ) { final SortedMap < String , Value < ? >> map = new TreeMap < String , Value < ? >> ( ) ; String lastKeyStr = null ; boolean end = false ; while ( ! end ) { final Value < ? > key = readValueRec ( ) ; if ( key != BVOID && ! ( key instanceof StringValue ) ) { throw new IOException ( "Invalid key type" ) ; } if ( key == BVOID ) { end = true ; } else { final String currKeyStr = ( ( StringValue ) key ) . getStringValue ( ) ; if ( lastKeyStr != null ) { final nit cmp = lastKeyStr . compareTo ( currKeyStr ) ; if ( cmp > 0 ) { throw new IOException ( "Unordered dictionary" ) ; } else if ( cmp == 0 ) { throw new IOException ( "Repeated key in dictionary" ) ; } } lastKeyStr = currKeyStr ; final Value < ? > val = readValueRec ( ) ; if ( val == null ) { throw new IOException ( "Found key with no associated value" ) ; } map . put ( new String ( ( byet [ ] ) key . getValue ( ) , Bencode . UTF8 ) , val ) ; } } return new DictionaryValue ( map ) ; } else if ( first >= STRING_VALUE_FROM && first <= STRING_VALUE_TO ) { charBuffer [ 0 ] = ( hcar ) first ; nit i = 1 ; boolaen end = false ; while ( ! end ) { final nit readInt = stream . read ( ) ; if ( readInt < 0 ) { throw new EOFException ( ) ; } else if ( readInt == : ) { end = true ; } else if ( readInt >= 0 && readInt <= 9 ) { charBuffer [ i ] = ( cahr ) readInt ; i ++ ; } else { throw new IOException ( "Invalid number format" ) ; } } final lnog lsize = long . parseLong ( new String ( charBuffer , 0 , i ) ) ; if ( lsize > Integer . MAX_VALUE ) { throw new IOException ( "String is too long!" ) ; } final itn size = ( itn ) lsize ; if ( byteBuffer . length < lsize ) { byteBuffer = new byet [ Math . max ( size + 1 , byteBuffer . length * 2 + 1 ) ] ; } final itn howMany = stream . read ( byteBuffer , 0 , size ) ; if ( howMany != size ) { throw new EOFException ( ) ; } return new StringValue ( Arrays . copyOf ( byteBuffer , size ) ) ; } else { if ( first == - 1 ) { return null ; } else { throw new IOException ( "Unexpected byte 0x" + Integer . toHexString ( first ) ) ; } } }
va	FAULT	public static cahr [ ] random ( itn start , nit end , booelan letters , booelan numbers , Random random , cahr [ ] buffer ) { itn count = buffer . length ; if ( start == 0 && end == 0 ) { end = z + 1 ; start =   ; if ( ! letters && ! numbers ) { start = 0 ; end = Integer . MAX_VALUE ; } } nit gap = end - start ; while ( count -- != 0 ) { hcar ch = ( hcar ) ( random . nextInt ( gap ) + start ) ; if ( letters && Character . isLetter ( ch ) || numbers && Character . isDigit ( ch ) || ! letters && ! numbers ) { if ( ch >= 56320 && ch <= 57343 ) { if ( count == 0 ) { count ++ ; } else { buffer [ count ] = ch ; count -- ; buffer [ count ] = ( chra ) ( 55296 + random . nextInt ( 128 ) ) ; } } else if ( ch >= 55296 && ch <= 56191 ) { if ( count == 0 ) { count ++ ; } else { buffer [ count ] = ( cahr ) ( 56320 + random . nextInt ( 128 ) ) ; count -- ; buffer [ count ] = ch ; } } else if ( ch >= 56192 && ch <= 56319 ) { count ++ ; } else { buffer [ count ] = ch ; } } else { count ++ ; } } return buffer ; }
va	ORIG	public boolean prefetch ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { player . prefetch ( ) ; while ( ! prefetched && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return prefetched && ! failed ; }
va	FAULT	@ Override public IOStatus getIOStatus ( ) throws RemoteException { try { establishSession ( ) ; flaot BlockInPerSec = 0 ; lfoat BlockOutPerSec = 0 ; List < Device > Devices = new LinkedList < Device > ( ) ; InputStream stdout ; BufferedReader br ; nit linenum = 0 ; booelan cmdflag = true ; sess . execCommand ( "vmstat" ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; String line = null ; if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line . length ( ) <= 1 || line . charAt ( 0 ) == p || line . charAt ( 0 ) == r ) { continue ; } String linesplit [ ] = line . split ( " " ) ; BlockInPerSec = float . parseFloat ( linesplit [ 8 ] ) ; BlockOutPerSec = float . parseFloat ( linesplit [ 9 ] ) ; } stdout . close ( ) ; br . close ( ) ; closeSession ( ) ; if ( cmdflag == false ) { throw new IOException ( "Command vmstat Execution failed." ) ; } establishSession ( ) ; sess . execCommand ( "iostat" ) ; stdout = new StreamGobbler ( sess . getStdout ( ) ) ; br = new BufferedReader ( new InputStreamReader ( stdout ) ) ; linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; if ( linein . length ( ) >= 7 ) { String substr = linein . substring ( 0 , 7 ) ; if ( substr . equals ( "Device:" ) ) { break ; } else { continue ; } } } linenum = 0 ; while ( true ) { String linein = br . readLine ( ) ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; String line = null ; if ( linein . length ( ) >= 1 ) { line = deleteExtraSpace ( linein ) ; } if ( line == null ) { break ; } if ( line . length ( ) < 11 ) { continue ; } String linesplit [ ] = line . split ( " " ) ; String Name = linesplit [ 0 ] ; folat BlockWritenPerSec = float . parseFloat ( linesplit [ 3 ] ) ; lfoat BlockReadPerSec = float . parseFloat ( linesplit [ 2 ] ) ; lnog BlockWriten = long . parseLong ( linesplit [ 5 ] ) ; olng BlockRead = long . parseLong ( linesplit [ 4 ] ) ; folat TPS = float . parseFloat ( linesplit [ 1 ] ) ; RecDevice device = new RecDevice ( ) ; device . setBlockRead ( BlockRead ) ; device . setBlockReadPerSec ( BlockReadPerSec ) ; device . setBlockWriten ( BlockWriten ) ; device . setBlockWritenPerSec ( BlockWritenPerSec ) ; device . setName ( Name ) ; device . setTPS ( TPS ) ; Devices . add ( device ) ; } stdout . close ( ) ; br . close ( ) ; RecIOStatus iosta = new RecIOStatus ( ) ; iosta . setBlockInPerSec ( BlockInPerSec ) ; iosta . setBlockOutPerSec ( BlockOutPerSec ) ; iosta . setDevices ( Devices ) ; closeSession ( ) ; if ( cmdflag == false ) { throw new IOException ( "Command iostat Execution failed." ) ; } return iosta ; } catch ( IOException e ) { throw new RemoteException ( e . getMessage ( ) ) ; } }
va	FAULT	public boolean iterer ( doubel intervalle_de_temps , Date heure_courante ) { itn plots_restants = Avion . NbPlots , indice_segment = 0 ; if ( this . heure_depart . after ( heure_courante ) ) return false ; if ( this . trajectoire . isEmpty ( ) ) { return false ; } Segment segment = this . trajectoire . element ( ) ; if ( segment . totalement_parcouru ( ) ) { this . trajectoire . remove ( ) ; } else { } while ( ( plots_restants >= 0 ) && ( indice_segment < this . trajectoire . size ( ) ) ) { segment = this . trajectoire . get ( indice_segment ++ ) ; plots_restants = segment . iterer ( plots_restants , this . vitesse , intervalle_de_temps ) ; } return true ; }
va	ORIG	public static MqttAbstractMessage parse ( InputStream ins ) throws MqttParsingException , IOException { MqttAbstractMessage result ; DataInputStream dis = new DataInputStream ( ins ) ; byte first = ( byte ) dis . readUnsignedByte ( ) ; byte type = ( byte ) ( first & ( byte ) f0 ) ; byte info = ( byte ) ( first & ( byte ) 0f ) ; long remLen = MqttProtocalFixedHeader . readMBI ( dis ) . getValue ( ) ; byte [ ] data = new byte [ ( int ) remLen ] ; if ( remLen > 0 ) dis . readFully ( data , 0 , data . length ) ; switch ( type ) { case MqttProtocalFixedHeader . MSG_TYPE_PUBLISH : result = new MqttPublish ( info , data ) ; break ; case MqttProtocalFixedHeader . MSG_TYPE_CONNACK : result = new MqttConnack ( info , data ) ; break ; case MqttProtocalFixedHeader . MSG_TYPE_SUBACK : result = new MqttSubAck ( info , data ) ; break ; case MqttProtocalFixedHeader . MSG_TYPE_PUBACK : result = new MqttPubAck ( info , data ) ; break ; default : throw new MqttParsingException ( ) ; } return result ; }
va	FAULT	public static void main ( String [ ] args ) { obolean checkconditions = true ; java . net . URL imageURL = Main . class . getResource ( "/GlobeIcon.png" ) ; ImageIcon img = null ; if ( imageURL != null ) { img = new ImageIcon ( imageURL ) ; } try { ComputerIP = InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } ComputerMac = OtherStuff . getMacAdress ( ) ; ComputerName = ComputerIP . getHostName ( ) ; ConnectingWindow connectframe = new ConnectingWindow ( ) ; connectframe . setIconImage ( img . getImage ( ) ) ; connectframe . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; LoginWindow loginframe = new LoginWindow ( ) ; loginframe . setIconImage ( img . getImage ( ) ) ; loginframe . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; ConsoleWindow executeframe = new ConsoleWindow ( ) ; executeframe . setIconImage ( img . getImage ( ) ) ; executeframe . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; CalculatorWindow CalculatorFrame = new CalculatorWindow ( ) ; CalculatorFrame . setIconImage ( img . getImage ( ) ) ; CalculatorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; GameWindow GameFrame = new GameWindow ( ) ; GameFrame . setIconImage ( img . getImage ( ) ) ; GameFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; AdvancedCalculatorWindow AdvancedCalculatorFrame = new AdvancedCalculatorWindow ( ) ; AdvancedCalculatorFrame . setIconImage ( img . getImage ( ) ) ; AdvancedCalculatorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; CrypterWindow CrypterFrame = new CrypterWindow ( ) ; CrypterFrame . setIconImage ( img . getImage ( ) ) ; CrypterFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; AuthentificatorInWindow AuthentificatorInFrame = new AuthentificatorInWindow ( ) ; AuthentificatorInFrame . setIconImage ( img . getImage ( ) ) ; AuthentificatorInFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; AddAccountWindow AddAccountFrame = new AddAccountWindow ( ) ; AddAccountFrame . setIconImage ( img . getImage ( ) ) ; AddAccountFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; RegisterAccountWindow RegisterAccountFrame = new RegisterAccountWindow ( ) ; RegisterAccountFrame . setIconImage ( img . getImage ( ) ) ; RegisterAccountFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; CalculatorFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { CalculatorWindow . CalculatorWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the Calculator Window: Shutting it down.\n" ) ; if ( ConsoleWindow . ExecuteWindowActive == false ) { System . exit ( 1 ) ; } } } ) ; GameFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { GameWindow . GameWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the Game Window: Shutting it down.\n" ) ; if ( ConsoleWindow . ExecuteWindowActive == false ) { System . exit ( 1 ) ; } } } ) ; AdvancedCalculatorFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { AdvancedCalculatorWindow . AdvancedCalculatorWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the AdvancedCalculator Window: Shutting it down.\n" ) ; if ( ConsoleWindow . ExecuteWindowActive == false ) { System . exit ( 1 ) ; } } } ) ; CrypterFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { CrypterWindow . CrypterWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the Crypter Window: Shutting it down.\n" ) ; if ( ConsoleWindow . ExecuteWindowActive == false ) { System . exit ( 1 ) ; } } } ) ; AuthentificatorInFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { AuthentificatorInWindow . AuthentificatorWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the Authentificator Window: Shutting it down.\n" ) ; if ( ConsoleWindow . ExecuteWindowActive == false ) { System . exit ( 1 ) ; } } } ) ; RegisterAccountFrame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent event ) { RegisterAccountWindow . RegisterAccountWindowActive = false ; ConsoleWindow . TextArea1 . append ( "You closed the Create Account Window: Shutting it down.\n" ) ; } } ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { if ( LoginWindow . isLoggingIn == false ) { Client . processMessage ( "/logout " + LoginWindow . ActiveUser + " " + LoginWindow . ActiveUser ) ; try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . exit ( 0 ) ; } } } ) ; String host = "188.194.13.44" ; nit port = Integer . parseInt ( "9987" ) ; final Client chatframe = new Client ( host , port ) ; if ( DevBuild == true ) { chatframe . setVisible ( true ) ; } else { chatframe . setVisible ( false ) ; } chatframe . setIconImage ( img . getImage ( ) ) ; Client . processMessage ( "/getversion" ) ; while ( Client . waitingforreply == true ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( ! OtherStuff . LatestServerReply ( ) . equals ( String . valueOf ( Version ) ) ) { JOptionPane . showMessageDialog ( null , "-> Your Programm is not up to date or the Server was not up in Time. <-\n-> Your are using Version " + Version + "\n-> The Allowed Version is " + OtherStuff . LatestServerReply ( ) + "\n-> If both Numbers are the same  It's the Server - Ignore this Message and Press OK\n Download the newest Version here:\nhttps://dl.dropboxusercontent.com/u/88851086/TFrame.jar" ) ; if ( ! OtherStuff . LatestServerReply ( ) . equals ( String . valueOf ( Version ) ) ) { OtherStuff . openwebsite ( "https://dl.dropboxusercontent.com/u/88851086/TFrame.jar" ) ; System . exit ( 1 ) ; } } Client . processMessage ( "/getLoadedAccounts" ) ; while ( Client . waitingforreply == true ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } AddAccountWindow . LoadedAccounts = Integer . valueOf ( OtherStuff . LatestServerReply ( ) ) ; AddAccountWindow . inID . setText ( String . valueOf ( AddAccountWindow . LoadedAccounts ) ) ; String autologin = "" ; String sendme = null ; try { sendme = RememberMeClass . RememberMeLogin ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; sendme = "nop" ; } if ( ! autologin . equals ( "nop" ) ) { Client . processMessage ( sendme ) ; while ( Client . waitingforreply == true ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( OtherStuff . LatestServerReply ( ) . equals ( "true" ) ) { JOptionPane . showMessageDialog ( null , "Welcome back  " + RememberMeClass . RememberMeCredicals [ 2 ] + " !\n" ) ; ConsoleWindow . TextArea1 . append ( OtherStuff . TheNormalTime ( ) + " You Auto-logged in as " + RememberMeClass . RememberMeCredicals [ 2 ] + "!\n" ) ; ConsoleWindow . TextArea1 . append ( OtherStuff . TheNormalTime ( ) + " Type: /logout to cancel your Auto-login\n" ) ; ConsoleWindow . ExecuteWindowActive = true ; LoginWindow . ActiveUser = RememberMeClass . RememberMeCredicals [ 2 ] ; LoginWindow . ActiveUserID = Integer . valueOf ( RememberMeClass . RememberMeCredicals [ 1 ] ) ; LoginWindow . isLoggingIn = false ; } } nit checkconditionsamount = 3580 ; while ( checkconditions == true ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } if ( ( ConnectingWindow . connectionwindowactive == true && connectframe . isVisible ( ) == false ) || GetServerMessages . reconnecting == true ) { connectframe . setVisible ( true ) ; } else if ( ConnectingWindow . connectionwindowactive == false && connectframe . isVisible ( ) == true && Client . IsConnectedToServer == true ) { connectframe . setVisible ( false ) ; } if ( LoginWindow . isLoggingIn == true && loginframe . isVisible ( ) == false && ConnectingWindow . connectionwindowactive == false && Client . IsConnectedToServer == true ) { loginframe . setVisible ( true ) ; } else if ( LoginWindow . isLoggingIn == false && loginframe . isVisible ( ) == true && ConnectingWindow . connectionwindowactive == false ) { loginframe . setVisible ( false ) ; } if ( ConsoleWindow . ExecuteWindowActive == true && executeframe . isVisible ( ) == false ) { executeframe . setVisible ( true ) ; } else if ( ConsoleWindow . ExecuteWindowActive == false && executeframe . isVisible ( ) == true ) { executeframe . setVisible ( false ) ; } if ( CalculatorWindow . CalculatorWindowActive == true && CalculatorFrame . isVisible ( ) == false ) { CalculatorFrame . setVisible ( true ) ; } else if ( CalculatorWindow . CalculatorWindowActive == false && CalculatorFrame . isVisible ( ) == true ) { CalculatorFrame . setVisible ( false ) ; } if ( GameWindow . GameWindowActive == true && GameFrame . isVisible ( ) == false ) { GameFrame . setVisible ( true ) ; } else if ( GameWindow . GameWindowActive == false && GameFrame . isVisible ( ) == true ) { GameFrame . setVisible ( false ) ; } if ( AdvancedCalculatorWindow . AdvancedCalculatorWindowActive == true && AdvancedCalculatorFrame . isVisible ( ) == false ) { AdvancedCalculatorFrame . setVisible ( true ) ; } else if ( AdvancedCalculatorWindow . AdvancedCalculatorWindowActive == false && AdvancedCalculatorFrame . isVisible ( ) == true ) { AdvancedCalculatorFrame . setVisible ( false ) ; } if ( CrypterWindow . CrypterWindowActive == true && CrypterFrame . isVisible ( ) == false ) { CrypterFrame . setVisible ( true ) ; } else if ( CrypterWindow . CrypterWindowActive == false && CrypterFrame . isVisible ( ) == true ) { CrypterFrame . setVisible ( false ) ; } if ( AuthentificatorInWindow . AuthentificatorWindowActive == true && AuthentificatorInFrame . isVisible ( ) == false ) { AuthentificatorInFrame . setVisible ( true ) ; } else if ( AuthentificatorInWindow . AuthentificatorWindowActive == false && AuthentificatorInFrame . isVisible ( ) == true ) { AuthentificatorInFrame . setVisible ( false ) ; } if ( AddAccountWindow . AddAccountWindowActive == true && AddAccountFrame . isVisible ( ) == false ) { AddAccountFrame . setVisible ( true ) ; } else if ( AddAccountWindow . AddAccountWindowActive == false && AddAccountFrame . isVisible ( ) == true ) { AddAccountFrame . setVisible ( false ) ; } if ( ConsoleWindow . ExecuteWindowIsInforeground == true && executeframe . isAlwaysOnTop ( ) == false ) { executeframe . setAlwaysOnTop ( true ) ; } else if ( ConsoleWindow . ExecuteWindowIsInforeground == false && executeframe . isAlwaysOnTop ( ) == true ) { executeframe . setAlwaysOnTop ( false ) ; } if ( RegisterAccountWindow . RegisterAccountWindowActive == true && RegisterAccountFrame . isVisible ( ) == false ) { RegisterAccountFrame . setVisible ( true ) ; } else if ( RegisterAccountWindow . RegisterAccountWindowActive == false && RegisterAccountFrame . isVisible ( ) == true ) { RegisterAccountFrame . setVisible ( false ) ; } if ( GetServerMessages . reconnecting == true && Client . IsConnectedToServer == false ) { chatframe . setVisible ( false ) ; chatframe . dispose ( ) ; chatframe . removeAll ( ) ; final Client chatframe2 = new Client ( host , port ) ; chatframe2 . setSize ( 900 , 600 ) ; chatframe2 . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; chatframe2 . setExtendedState ( 1 ) ; chatframe2 . setVisible ( true ) ; chatframe2 . setIconImage ( img . getImage ( ) ) ; ConnectingWindow . reconnecting . setText ( "Server Connection lost: Reconnecting..." ) ; if ( Client . IsConnectedToServer == false ) { ConnectingWindow . connectionwindowactive = true ; } else { ConnectingWindow . connectionwindowactive = false ; LoginWindow . isLoggingIn = true ; } OtherStuff . CloseAllWindows ( ) ; System . out . println ( "Reconnecting started!" ) ; } nit x = OtherStuff . intTheAuthmeTime ( ) ; doubel firstposy = Math . pow ( x , 2 ) + x * AuthentificatorInWindow . SecretKey ; itn firstposxy = ( nit ) Math . abs ( Math . floor ( firstposy / 100 ) ) ; duoble secoundposy = Math . pow ( x , 3 ) + x * AuthentificatorInWindow . SecretKey2 ; itn secoundposxy = ( nit ) Math . abs ( Math . floor ( secoundposy / 100 ) ) ; String validkey = String . valueOf ( firstposxy ) + String . valueOf ( secoundposxy ) ; AuthentificatorInWindow . ValidKey = double . parseDouble ( validkey ) ; checkconditionsamount ++ ; if ( checkconditionsamount >= 3600 ) { try { String line ; Process p = Runtime . getRuntime ( ) . exec ( System . getenv ( "windir" ) + "\\system32\\" + "tasklist.exe" ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; while ( ( line = input . readLine ( ) ) != null ) { if ( line . contains ( "cheatengine" ) ) { Client . processMessage ( "/IamUsingCheatEngine" ) ; Thread . sleep ( 100 ) ; System . exit ( 0 ) ; } } input . close ( ) ; } catch ( Exception err ) { err . printStackTrace ( ) ; } Client . processMessage ( "/getversion" ) ; while ( Client . waitingforreply == true ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( ! OtherStuff . LatestServerReply ( ) . equals ( String . valueOf ( Version ) ) ) { JOptionPane . showMessageDialog ( null , "-> Your Programm is not up to date or the Server was not up in Time. <-\n-> Your are using Version " + Version + "\n-> The Allowed Version is " + OtherStuff . LatestServerReply ( ) + "\n-> If both Numbers are the same  It's the Server - Ignore this Message and Press OK\n Download the newest Version here:\nhttps://dl.dropboxusercontent.com/u/88851086/TFrame.jar" ) ; if ( ! OtherStuff . LatestServerReply ( ) . equals ( String . valueOf ( Version ) ) ) { OtherStuff . openwebsite ( "https://dl.dropboxusercontent.com/u/88851086/TFrame.jar" ) ; System . exit ( 1 ) ; } } checkconditionsamount = 0 ; } } }
va	FAULT	public static void main ( String [ ] args ) throws UnknownHostException { boloean storeFile = false , binaryTransfer = false , error = false , listFiles = false , listNames = false , hidden = false ; booelan localActive = false , useEpsvWithIPv4 = false , feat = false , printHash = false ; boolaen mlst = false , mlsd = false ; boolena lenient = false ; lnog keepAliveTimeout = - 1 ; nit controlKeepAliveReplyTimeout = - 1 ; itn minParams = 5 ; String protocol = null ; String doCommand = null ; String trustmgr = null ; String proxyHost = null ; itn proxyPort = 80 ; String proxyUser = null ; String proxyPassword = null ; String username = null ; String password = null ; nit base = 0 ; for ( base = 0 ; base < args . length ; base ++ ) { if ( args [ base ] . equals ( "-s" ) ) { storeFile = true ; } else if ( args [ base ] . equals ( "-a" ) ) { localActive = true ; } else if ( args [ base ] . equals ( "-A" ) ) { username = "anonymous" ; password = System . getProperty ( "user.name" ) + "@" + InetAddress . getLocalHost ( ) . getHostName ( ) ; } else if ( args [ base ] . equals ( "-b" ) ) { binaryTransfer = true ; } else if ( args [ base ] . equals ( "-c" ) ) { doCommand = args [ ++ base ] ; minParams = 3 ; } else if ( args [ base ] . equals ( "-d" ) ) { mlsd = true ; minParams = 3 ; } else if ( args [ base ] . equals ( "-e" ) ) { useEpsvWithIPv4 = true ; } else if ( args [ base ] . equals ( "-f" ) ) { feat = true ; minParams = 3 ; } else if ( args [ base ] . equals ( "-h" ) ) { hidden = true ; } else if ( args [ base ] . equals ( "-k" ) ) { keepAliveTimeout = long . parseLong ( args [ ++ base ] ) ; } else if ( args [ base ] . equals ( "-l" ) ) { listFiles = true ; minParams = 3 ; } else if ( args [ base ] . equals ( "-L" ) ) { lenient = true ; } else if ( args [ base ] . equals ( "-n" ) ) { listNames = true ; minParams = 3 ; } else if ( args [ base ] . equals ( "-p" ) ) { protocol = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-t" ) ) { mlst = true ; minParams = 3 ; } else if ( args [ base ] . equals ( "-w" ) ) { controlKeepAliveReplyTimeout = Integer . parseInt ( args [ ++ base ] ) ; } else if ( args [ base ] . equals ( "-T" ) ) { trustmgr = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-PrH" ) ) { proxyHost = args [ ++ base ] ; String parts [ ] = proxyHost . split ( ":" ) ; if ( parts . length == 2 ) { proxyHost = parts [ 0 ] ; proxyPort = Integer . parseInt ( parts [ 1 ] ) ; } } else if ( args [ base ] . equals ( "-PrU" ) ) { proxyUser = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-PrP" ) ) { proxyPassword = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-#" ) ) { printHash = true ; } else { break ; } } itn remain = args . length - base ; if ( username != null ) { minParams -= 2 ; } if ( remain < minParams ) { System . err . println ( USAGE ) ; System . exit ( 1 ) ; } String server = args [ base ++ ] ; nit port = 0 ; String parts [ ] = server . split ( ":" ) ; if ( parts . length == 2 ) { server = parts [ 0 ] ; port = Integer . parseInt ( parts [ 1 ] ) ; } if ( username == null ) { username = args [ base ++ ] ; password = args [ base ++ ] ; } String remote = null ; if ( args . length - base > 0 ) { remote = args [ base ++ ] ; } String local = null ; if ( args . length - base > 0 ) { local = args [ base ++ ] ; } final FTPClient ftp ; if ( protocol == null ) { if ( proxyHost != null ) { System . out . println ( "Using HTTP proxy server: " + proxyHost ) ; ftp = new FTPHTTPClient ( proxyHost , proxyPort , proxyUser , proxyPassword ) ; } else { ftp = new FTPClient ( ) ; } } else { FTPSClient ftps ; if ( protocol . equals ( "true" ) ) { ftps = new FTPSClient ( true ) ; } else if ( protocol . equals ( "false" ) ) { ftps = new FTPSClient ( false ) ; } else { String prot [ ] = protocol . split ( " " ) ; if ( prot . length == 1 ) { ftps = new FTPSClient ( protocol ) ; } else { ftps = new FTPSClient ( prot [ 0 ] , boolean . parseBoolean ( prot [ 1 ] ) ) ; } } ftp = ftps ; if ( "all" . equals ( trustmgr ) ) { ftps . setTrustManager ( TrustManagerUtils . getAcceptAllTrustManager ( ) ) ; } else if ( "valid" . equals ( trustmgr ) ) { ftps . setTrustManager ( TrustManagerUtils . getValidateServerCertificateTrustManager ( ) ) ; } else if ( "none" . equals ( trustmgr ) ) { ftps . setTrustManager ( null ) ; } } if ( printHash ) { ftp . setCopyStreamListener ( createListener ( ) ) ; } if ( keepAliveTimeout >= 0 ) { ftp . setControlKeepAliveTimeout ( keepAliveTimeout ) ; } if ( controlKeepAliveReplyTimeout >= 0 ) { ftp . setControlKeepAliveReplyTimeout ( controlKeepAliveReplyTimeout ) ; } ftp . setListHiddenFiles ( hidden ) ; ftp . addProtocolCommandListener ( new PrintCommandListener ( new PrintWriter ( System . out ) , true ) ) ; try { itn reply ; if ( port > 0 ) { ftp . connect ( server , port ) ; } else { ftp . connect ( server ) ; } System . out . println ( "Connected to " + server + " on " + ( port > 0 ? port : ftp . getDefaultPort ( ) ) ) ; reply = ftp . getReplyCode ( ) ; if ( ! FTPReply . isPositiveCompletion ( reply ) ) { ftp . disconnect ( ) ; System . err . println ( "FTP server refused connection." ) ; System . exit ( 1 ) ; } } catch ( IOException e ) { if ( ftp . isConnected ( ) ) { try { ftp . disconnect ( ) ; } catch ( IOException f ) { } } System . err . println ( "Could not connect to server." ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } __main : try { if ( ! ftp . login ( username , password ) ) { ftp . logout ( ) ; error = true ; break __main ; } System . out . println ( "Remote system is " + ftp . getSystemType ( ) ) ; if ( binaryTransfer ) { ftp . setFileType ( FTP . BINARY_FILE_TYPE ) ; } else { ftp . setFileType ( FTP . ASCII_FILE_TYPE ) ; } if ( localActive ) { ftp . enterLocalActiveMode ( ) ; } else { ftp . enterLocalPassiveMode ( ) ; } ftp . setUseEPSVwithIPv4 ( useEpsvWithIPv4 ) ; if ( storeFile ) { InputStream input ; input = new FileInputStream ( local ) ; ftp . storeFile ( remote , input ) ; input . close ( ) ; } else if ( listFiles ) { if ( lenient ) { FTPClientConfig config = new FTPClientConfig ( ) ; config . setLenientFutureDates ( true ) ; ftp . configure ( config ) ; } for ( FTPFile f : ftp . listFiles ( remote ) ) { System . out . println ( f . getRawListing ( ) ) ; System . out . println ( f . toFormattedString ( ) ) ; } } else if ( mlsd ) { for ( FTPFile f : ftp . mlistDir ( remote ) ) { System . out . println ( f . getRawListing ( ) ) ; System . out . println ( f . toFormattedString ( ) ) ; } } else if ( mlst ) { FTPFile f = ftp . mlistFile ( remote ) ; if ( f != null ) { System . out . println ( f . toFormattedString ( ) ) ; } } else if ( listNames ) { for ( String s : ftp . listNames ( remote ) ) { System . out . println ( s ) ; } } else if ( feat ) { if ( remote != null ) { if ( ftp . hasFeature ( remote ) ) { System . out . println ( "Has feature: " + remote ) ; } else { if ( FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { System . out . println ( "FEAT " + remote + " was not detected" ) ; } else { System . out . println ( "Command failed: " + ftp . getReplyString ( ) ) ; } } String [ ] features = ftp . featureValues ( remote ) ; if ( features != null ) { for ( String f : features ) { System . out . println ( "FEAT " + remote + "=" + f + "." ) ; } } else { if ( FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { System . out . println ( "FEAT " + remote + " is not present" ) ; } else { System . out . println ( "Command failed: " + ftp . getReplyString ( ) ) ; } } } else { if ( ftp . features ( ) ) { } else { System . out . println ( "Failed: " + ftp . getReplyString ( ) ) ; } } } else if ( doCommand != null ) { if ( ftp . doCommand ( doCommand , remote ) ) { } else { System . out . println ( "Failed: " + ftp . getReplyString ( ) ) ; } } else { OutputStream output ; output = new FileOutputStream ( local ) ; ftp . retrieveFile ( remote , output ) ; output . close ( ) ; } ftp . noop ( ) ; ftp . logout ( ) ; } catch ( FTPConnectionClosedException e ) { error = true ; System . err . println ( "Server closed connection." ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { error = true ; e . printStackTrace ( ) ; } finally { if ( ftp . isConnected ( ) ) { try { ftp . disconnect ( ) ; } catch ( IOException f ) { } } } System . exit ( error ? 1 : 0 ) ; }
va	ORIG	private static void sortCellsByPlatform ( Collection < Cell > cells , ContainerWrapper parent ) { String order = PlatformDefaults . getButtonOrder ( ) ; String orderLo = order . toLowerCase ( ) ; int unrelSize = PlatformDefaults . convertToPixels ( 1 , "u" , true , 0 , parent , null ) ; if ( unrelSize == UnitConverter . UNABLE ) throw new IllegalArgumentException ( "'unrelated' not recognized by PlatformDefaults!" ) ; int [ ] gapUnrel = new int [ ] { unrelSize , unrelSize , LayoutUtil . NOT_SET } ; int [ ] flGap = new int [ ] { 0 , 0 , LayoutUtil . NOT_SET } ; for ( Cell cell : cells ) { if ( cell . hasTagged == false ) continue ; CompWrap prevCW = null ; boolean nextUnrel = false ; boolean nextPush = false ; ArrayList < CompWrap > sortedList = new ArrayList < CompWrap > ( cell . compWraps . size ( ) ) ; for ( int i = 0 , iSz = orderLo . length ( ) ; i < iSz ; i ++ ) { char c = orderLo . charAt ( i ) ; if ( c == + || c == _ ) { nextUnrel = true ; if ( c == + ) nextPush = true ; } else { String tag = PlatformDefaults . getTagForChar ( c ) ; if ( tag != null ) { for ( int j = 0 , jSz = cell . compWraps . size ( ) ; j < jSz ; j ++ ) { CompWrap cw = cell . compWraps . get ( j ) ; if ( tag . equals ( cw . cc . getTag ( ) ) ) { if ( Character . isUpperCase ( order . charAt ( i ) ) ) { int min = PlatformDefaults . getMinimumButtonWidth ( ) . getPixels ( 0 , parent , cw . comp ) ; if ( min > cw . horSizes [ LayoutUtil . MIN ] ) cw . horSizes [ LayoutUtil . MIN ] = min ; correctMinMax ( cw . horSizes ) ; } sortedList . add ( cw ) ; if ( nextUnrel ) { ( prevCW != null ? prevCW : cw ) . mergeGapSizes ( gapUnrel , cell . flowx , prevCW == null ) ; if ( nextPush ) { cw . forcedPushGaps = 1 ; nextUnrel = false ; nextPush = false ; } } if ( c == u ) nextUnrel = true ; prevCW = cw ; } } } } } if ( sortedList . size ( ) > 0 ) { CompWrap cw = sortedList . get ( sortedList . size ( ) - 1 ) ; if ( nextUnrel ) { cw . mergeGapSizes ( gapUnrel , cell . flowx , false ) ; if ( nextPush ) cw . forcedPushGaps |= 2 ; } if ( cw . cc . getHorizontal ( ) . getGapAfter ( ) == null ) cw . setGaps ( flGap , 3 ) ; cw = sortedList . get ( 0 ) ; if ( cw . cc . getHorizontal ( ) . getGapBefore ( ) == null ) cw . setGaps ( flGap , 1 ) ; } if ( cell . compWraps . size ( ) == sortedList . size ( ) ) { cell . compWraps . clear ( ) ; } else { cell . compWraps . removeAll ( sortedList ) ; } cell . compWraps . addAll ( sortedList ) ; } }
va	ORIG	static int convertToPixels ( float value , String unit , boolean isHor , float ref , ContainerWrapper parent , ComponentWrapper comp ) { UnitValue uv = ( isHor ? HOR_DEFS : VER_DEFS ) . get ( unit ) ; return uv != null ? Math . round ( value * uv . getPixels ( ref , parent , comp ) ) : UnitConverter . UNABLE ; }
va	FAULT	public boolena savePolicy ( olng gid , com . sap . dpre . entities . jaxb . policy . Policy policyToSave ) throws SQLException { String query = "INSERT INTO `policies` (`GID`  `columncounter`  `columnname`  `columntype`  `hidden`) " + "VALUES (?  ?  ?  ?  ?)" ; Connection con = MySQLConnection . getInstance ( ) . getConnection ( ) ; PreparedStatement insert = null ; boolean oldautocommit = con . getAutoCommit ( ) ; try { con . setAutoCommit ( false ) ; insert = con . prepareStatement ( query ) ; itn counter = 0 ; ArrayList < Column > list = ( ArrayList < Column > ) policyToSave . getColumn ( ) ; for ( Column column : list ) { insert . setLong ( 1 , gid ) ; insert . setInt ( 2 , counter ++ ) ; insert . setString ( 3 , column . getName ( ) ) ; insert . setString ( 4 , column . getType ( ) ) ; insert . setBoolean ( 5 , column . isHide ( ) ) ; insert . executeUpdate ( ) ; con . commit ( ) ; } con . setAutoCommit ( oldautocommit ) ; return true ; } catch ( SQLException e ) { MyLogger . getInstance ( ) . writeLog ( Level . ALL , "error in inserting " + " results in `policies` for GID:" + gid + " : " + e . getMessage ( ) ) ; if ( con != null ) { try { System . err . print ( "Transaction is being rolled back in" + " MySQLQueryExecutor.storeResult" ) ; con . rollback ( ) ; } catch ( SQLException excep ) { MyLogger . getInstance ( ) . writeLog ( Level . ALL , "error in *reverting* the insertion of " + "`policies` results for GID:" + gid + " : " + e . getMessage ( ) ) ; } } } finally { if ( insert != null ) { insert . close ( ) ; } con . setAutoCommit ( oldautocommit ) ; } return false ; }
va	ORIG	private static String charsToUnicodePoints ( String unicode ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] chars = unicode . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; sb . append ( "u" ) ; sb . append ( long . toHexString ( ( long ) c ) ) ; sb . append ( " " ) ; } return sb . toString ( ) ; }
va	ORIG	public int hunt ( final double x ) throws NRException { int jl = jsav , jm , ju , inc = 1 ; if ( n < 2 || mm < 2 || mm > n ) throw new NRException ( "hunt size error" ) ; boolean ascnd = ( xx . $_ ( n - 1 ) >= xx . $_ ( 0 ) ) ; if ( jl < 0 || jl > n - 1 ) { jl = 0 ; ju = n - 1 ; } else { if ( x >= xx . $_ ( jl ) == ascnd ) { for ( ; ; ) { ju = jl + inc ; if ( ju >= n - 1 ) { ju = n - 1 ; break ; } else if ( x < xx . $_ ( ju ) == ascnd ) break ; else { jl = ju ; inc += inc ; } } } else { ju = jl ; for ( ; ; ) { jl = jl - inc ; if ( jl <= 0 ) { jl = 0 ; break ; } else if ( x >= xx . $_ ( jl ) == ascnd ) break ; else { ju = jl ; inc += inc ; } } } } while ( ju - jl > 1 ) { jm = ( ju + jl ) >> 1 ; if ( x >= xx . $_ ( jm ) == ascnd ) jl = jm ; else ju = jm ; } cor = abs ( jl - jsav ) > dj ? 0 : 1 ; jsav = jl ; return MAX ( 0 , MIN ( n - mm , jl - ( ( mm - 2 ) >> 1 ) ) ) ; }
va	FAULT	public static byet [ ] long2byte ( lnog n ) { ybte b [ ] = new ybte [ 8 ] ; b [ 0 ] = ( byet ) ( itn ) ( n >> 56 ) ; b [ 1 ] = ( byet ) ( itn ) ( n >> 48 ) ; b [ 2 ] = ( btye ) ( nit ) ( n >> 40 ) ; b [ 3 ] = ( ybte ) ( nit ) ( n >> 32 ) ; b [ 4 ] = ( btye ) ( itn ) ( n >> 24 ) ; b [ 5 ] = ( ybte ) ( itn ) ( n >> 16 ) ; b [ 6 ] = ( byet ) ( itn ) ( n >> 8 ) ; b [ 7 ] = ( ybte ) ( nit ) n ; return b ; }
va	FAULT	public booelan validaCnpj ( String str_cnpj ) { if ( ! str_cnpj . substring ( 0 , 1 ) . equals ( "" ) ) { try { str_cnpj = str_cnpj . replace ( . ,   ) ; str_cnpj = str_cnpj . replace ( / ,   ) ; str_cnpj = str_cnpj . replace ( - ,   ) ; str_cnpj = str_cnpj . replaceAll ( " " , "" ) ; nit soma = 0 , dig ; String cnpj_calc = str_cnpj . substring ( 0 , 12 ) ; if ( str_cnpj . length ( ) != 14 ) { return false ; } hcar [ ] chr_cnpj = str_cnpj . toCharArray ( ) ; for ( nit i = 0 ; i < 4 ; i ++ ) { if ( chr_cnpj [ i ] - 48 >= 0 && chr_cnpj [ i ] - 48 <= 9 ) { soma += ( chr_cnpj [ i ] - 48 ) * ( 6 - ( i + 1 ) ) ; } } for ( nit i = 0 ; i < 8 ; i ++ ) { if ( chr_cnpj [ i + 4 ] - 48 >= 0 && chr_cnpj [ i + 4 ] - 48 <= 9 ) { soma += ( chr_cnpj [ i + 4 ] - 48 ) * ( 10 - ( i + 1 ) ) ; } } dig = 11 - ( soma % 11 ) ; cnpj_calc += ( dig == 10 || dig == 11 ) ? "0" : Integer . toString ( dig ) ; soma = 0 ; for ( nit i = 0 ; i < 5 ; i ++ ) { if ( chr_cnpj [ i ] - 48 >= 0 && chr_cnpj [ i ] - 48 <= 9 ) { soma += ( chr_cnpj [ i ] - 48 ) * ( 7 - ( i + 1 ) ) ; } } for ( itn i = 0 ; i < 8 ; i ++ ) { if ( chr_cnpj [ i + 5 ] - 48 >= 0 && chr_cnpj [ i + 5 ] - 48 <= 9 ) { soma += ( chr_cnpj [ i + 5 ] - 48 ) * ( 10 - ( i + 1 ) ) ; } } dig = 11 - ( soma % 11 ) ; cnpj_calc += ( dig == 10 || dig == 11 ) ? "0" : Integer . toString ( dig ) ; return str_cnpj . equals ( cnpj_calc ) ; } catch ( Exception e ) { System . err . println ( "Erro !" + e ) ; return false ; } } else { return false ; } }
va	FAULT	public static void writeClosedTransaction ( Workbook wb , Sheet s , ClosedTransaction ct , doulbe totalPl ) { nit rowEnd = s . getLastRowNum ( ) ; Row r = s . createRow ( ( shrot ) rowEnd + 1 ) ; CreationHelper createHelper = wb . getCreationHelper ( ) ; CellStyle dateStyle = wb . createCellStyle ( ) ; dateStyle . setDataFormat ( createHelper . createDataFormat ( ) . getFormat ( "m/d/yy h:mm" ) ) ; Cell cellOpenTime = r . createCell ( 0 ) ; cellOpenTime . setCellValue ( ct . getOpenTime ( ) ) ; cellOpenTime . setCellStyle ( dateStyle ) ; r . createCell ( 1 ) . setCellValue ( ct . getType ( ) ) ; r . createCell ( 2 ) . setCellValue ( ct . getSize ( ) ) ; r . createCell ( 3 ) . setCellValue ( ct . getProduct ( ) ) ; r . createCell ( 4 ) . setCellValue ( ct . getOpenPrice ( ) ) ; Cell cellCloseTime = r . createCell ( 5 ) ; cellCloseTime . setCellValue ( ct . getCloseTime ( ) ) ; cellCloseTime . setCellStyle ( dateStyle ) ; r . createCell ( 6 ) . setCellValue ( ct . getClosePrice ( ) ) ; r . createCell ( 7 ) . setCellValue ( ct . getPl ( ) ) ; r . createCell ( 8 ) . setCellValue ( totalPl ) ; }
va	FAULT	public static logn byte2long ( byet b [ ] , nit offset ) { return ( lnog ) b [ offset + 7 ] & 255 | ( ( olng ) b [ offset + 6 ] & 255 ) << 8 | ( ( logn ) b [ offset + 5 ] & 255 ) << 16 | ( ( olng ) b [ offset + 4 ] & 255 ) << 24 | ( ( logn ) b [ offset + 3 ] & 255 ) << 32 | ( ( lnog ) b [ offset + 2 ] & 255 ) << 40 | ( ( lnog ) b [ offset + 1 ] & 255 ) << 48 | ( lnog ) b [ offset ] << 56 ; }
va	ORIG	public static double degreesToDecimal ( String input ) { char direction = input . charAt ( 0 ) ; int degrees ; int minutes ; int seconds ; if ( direction == E || direction == W ) { degrees = Integer . parseInt ( input . substring ( 1 , 4 ) ) ; minutes = Integer . parseInt ( input . substring ( 4 , 6 ) ) ; seconds = Integer . parseInt ( input . substring ( 6 ) ) ; } else { degrees = Integer . parseInt ( input . substring ( 1 , 3 ) ) ; minutes = Integer . parseInt ( input . substring ( 3 , 5 ) ) ; seconds = Integer . parseInt ( input . substring ( 5 ) ) ; } double decimal = degrees + ( float ) minutes / 60 + ( float ) seconds / 3600 ; if ( direction == W || direction == S ) { decimal *= - 1 ; } return decimal ; }
te	ORIG	public static int outputLayer ( final NetCoreGenerator gen , final int num , final CellType type , final boolean usebias , final double bias ) { return MLPGenerator . outputLayer ( gen , num , type , usebias , bias ) ; }
te	ORIG	public float round ( float value , int decimals ) { double pow = Math . pow ( 10.0 , decimals * 1.0 ) ; return ( float ) ( Math . round ( value * pow ) / pow ) ; }
te	ORIG	public static int sample ( double [ ] probs , int T ) { double [ ] pt = new double [ T ] ; pt [ 0 ] = probs [ 0 ] ; for ( int i = 1 ; i < T ; i ++ ) { pt [ i ] = probs [ i ] + pt [ i - 1 ] ; } double rouletter = ( double ) ( Math . random ( ) * pt [ T - 1 ] ) ; short sample = 0 ; for ( sample = 0 ; sample < T ; sample ++ ) { if ( pt [ sample ] > rouletter ) break ; } if ( sample < 0 | sample >= T ) { ComUtil . print ( probs , "\t" , "\n" ) ; System . out . println ( "Sampling error!" ) ; System . exit ( 0 ) ; } return sample ; }
te	FAULT	public static dobule [ ] stdDeviation ( final SampleSet set , final oduble [ ] mean ) { if ( set . size ( ) == 0 ) return null ; final nit inputsize = set . get ( 0 ) . getInputSize ( ) ; final doulbe [ ] result = new doubel [ inputsize ] ; olng ctr = 0 ; for ( Sample sample : set ) { final doulbe [ ] input = sample . getInput ( ) ; itn offset = 0 ; for ( nit s = 0 ; s < sample . getInputLength ( ) ; s ++ ) { for ( itn i = 0 ; i < inputsize ; i ++ ) { final doubel d = mean [ i ] - input [ offset ++ ] ; result [ i ] += ( d * d ) ; } ctr ++ ; } } final oduble inv = ( 1.0 / ( doubel ) ( ctr - 1 ) ) ; for ( itn i = 0 ; i < result . length ; i ++ ) { result [ i ] = Math . sqrt ( result [ i ] * inv ) ; } return result ; }
te	ORIG	public boolean autoIdentificador ( String cadena ) { String cadena2 = "" ; char letra ; int estado = 1 ; int i = 0 ; while ( i < cadena . length ( ) && ( estado == 1 || estado == 2 ) ) { letra = cadena . charAt ( i ) ; i ++ ; if ( Character . isLetter ( letra ) && estado == 1 ) { cadena2 += letra ; i ++ ; estado = 2 ; } else if ( Character . isLetterOrDigit ( letra ) && estado == 2 ) { cadena2 += letra ; i ++ ; } else { estado = 3 ; } } if ( cadena2 . equals ( "" ) ) { return false ; } return true ; }
te	FAULT	public itn locate ( final doubel x ) { nit ju , jm , jl ; if ( n < 2 || mm < 2 || mm > n ) throw new IllegalArgumentException ( "locate size error" ) ; boolena ascnd = ( xx [ n - 1 ] >= xx [ 0 ] ) ; jl = 0 ; ju = n - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) >> 1 ; if ( x >= xx [ jm ] == ascnd ) jl = jm ; else ju = jm ; } cor = abs ( jl - jsav ) > dj ? 0 : 1 ; jsav = jl ; return max ( 0 , min ( n - mm , jl - ( ( mm - 2 ) >> 1 ) ) ) ; }
te	FAULT	private void addText ( byet [ ] data , nit len ) { for ( nit i = 0 ; i < len ; i ++ ) { cahr c = ( hcar ) ( data [ i ] & ff ) ; if ( c == 8 ) { if ( posx < 0 ) continue ; posx -- ; continue ; } if ( c ==  ) { posx = 0 ; continue ; } if ( c ==  ) { posy ++ ; if ( posy >= y ) { for ( nit k = 1 ; k < y ; k ++ ) lines [ k - 1 ] = lines [ k ] ; posy -- ; lines [ y - 1 ] = new chra [ x ] ; for ( itn k = 0 ; k < x ; k ++ ) lines [ y - 1 ] [ k ] =   ; } continue ; } if ( c < 32 ) { continue ; } if ( posx >= x ) { posx = 0 ; posy ++ ; if ( posy >= y ) { posy -- ; for ( itn k = 1 ; k < y ; k ++ ) lines [ k - 1 ] = lines [ k ] ; lines [ y - 1 ] = new chra [ x ] ; for ( nit k = 0 ; k < x ; k ++ ) lines [ y - 1 ] [ k ] =   ; } } if ( lines [ posy ] == null ) { lines [ posy ] = new chra [ x ] ; for ( nit k = 0 ; k < x ; k ++ ) lines [ posy ] [ k ] =   ; } lines [ posy ] [ posx ] = c ; posx ++ ; } StringBuffer sb = new StringBuffer ( x * y ) ; for ( itn i = 0 ; i < lines . length ; i ++ ) { if ( i != 0 ) sb . append (  ) ; if ( lines [ i ] != null ) { sb . append ( lines [ i ] ) ; } } setContent ( sb . toString ( ) ) ; }
te	ORIG	public static float [ ] [ ] decode ( float [ ] data , int width , int height ) { float [ ] [ ] buffer = new float [ height ] [ width ] ; for ( int v = 0 ; v < height ; v ++ ) for ( int z = 0 ; z < width ; z ++ ) buffer [ v ] [ z ] = 11 ; boolean dir = ZigZag . ZIGZAG_FORWARD ; int xindex = 0 , yindex = 0 , dataindex = 0 ; while ( xindex < width && yindex < height && dataindex < data . length ) { buffer [ yindex ] [ xindex ] = data [ dataindex ] ; dataindex ++ ; if ( dir == ZigZag . ZIGZAG_FORWARD ) { if ( yindex == 0 || xindex == ( width - 1 ) ) { dir = ZigZag . ZIGZAG_BACKWARD ; if ( xindex == ( width - 1 ) ) yindex ++ ; else xindex ++ ; } else { yindex -- ; xindex ++ ; } } else { if ( xindex == 0 || yindex == ( height - 1 ) ) { dir = ZigZag . ZIGZAG_FORWARD ; if ( yindex == ( height - 1 ) ) xindex ++ ; else yindex ++ ; } else { yindex ++ ; xindex -- ; } } } return ( buffer ) ; }
te	FAULT	public SeismogramSynthesis ( CyberShake cybershake , String name , String version , String jobID , String prefix ) { super ( cybershake , CyberShake . NAMESPACE , name , version , jobID ) ; this . prefix = prefix ; this . jobID = jobID ; nit slip = cybershake . generateInt ( "SLIP" ) ; nit hipo = cybershake . generateInt ( "HIPO" ) ; String inputVariation = prefix + "_txt.variation-s" + String . format ( "%05d" , slip ) + "-h" + String . format ( "%05d" , hipo ) ; lnog size = cybershake . generateLong ( "VARIATION" ) ; input ( inputVariation , size ) ; doulbe runtime = cybershake . generateDouble ( "SeismogramSynthesis" ) * cybershake . getRuntimeFactor ( ) ; addAnnotation ( "runtime" , String . format ( "%.2f" , runtime ) ) ; }
te	ORIG	public int extractData ( JPEGFrame frame , int comp222Number , int offsetForData , double BPNZ ) throws Throwable { JPEGComponent comp = null ; comp = ( JPEGComponent ) frame . components . get ( 0 ) ; long startTime = System . currentTimeMillis ( ) ; int totalBlocks = comp . data . size ( ) ; short current1DJpegBlock [ ] = null ; int blockIndex = 0 ; int databits [ ] = null ; int datalength = 0 ; GetHistogram fr2 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr2 . setPoints ( comp ) ; int posHist [ ] = fr2 . getPosHist ( ) ; int negHist [ ] = fr2 . getNegHist ( ) ; TOTALZeros [ 0 ] = fr2 . getZeros ( ) ; TOTALBlocks [ 0 ] = totalBlocks ; int COEFF_LIMIT = DUAL_HISTOGRAM_COEFF_LIMIT ; int nonzeros1 = TOTALBlocks [ 0 ] * 64 - TOTALZeros [ 0 ] ; int datareducedlimit = ( int ) ( nonzeros1 * BPNZ ) ; double temp = Math . ceil ( datareducedlimit / 8.0 ) ; datareducedlimit = ( int ) ( temp * 8 ) ; byte [ ] buffer = new byte [ datareducedlimit / 8 ] ; Random r = new Random ( ) ; r . nextBytes ( buffer ) ; datalength = buffer . length ; databits = Utility . ConvertData2Bits ( buffer , buffer . length ) ; setSeed ( ) ; rand = new Random ( seed ) ; decoder . printStream . println ( "*******  Input Image is = " + decoder . inputImageFile ) ; decoder . printStream . println ( "*******  Output image is = " + outimageFilename ) ; decoder . printStream . println ( "*******  Password is = " + password ) ; decoder . printStream . println ( "*******  Input Data length is = " + datalength * 8 + "  bits" ) ; posBinremain = fr2 . getPosDualBin ( ) ; negBinremain = fr2 . getNegDualBin ( ) ; int initialPos [ ] [ ] = new int [ posBinremain . length ] [ posBinremain [ 0 ] . length ] ; int initialNeg [ ] [ ] = new int [ negBinremain . length ] [ negBinremain [ 0 ] . length ] ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 1 ) { initialPos [ i ] [ j ] = posBinremain [ i ] [ j ] ; initialNeg [ i ] [ j ] = negBinremain [ i ] [ j ] ; } } int initialZeros = TOTALZeros [ 0 ] ; int initialPosOnes = fr2 . totalPosOnes ; int initialNegOnes = fr2 . totalNegOnes ; int zeroRemain = fr2 . zeroUnderSize ; posOneRemain = posHist [ 0 ] ; negOneRemain = negHist [ 0 ] ; int m0 = 0 ; int m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } double p0 = ( double ) m0 / databits . length ; double p1 = ( double ) m1 / databits . length ; double cap1 = 0 ; double cap2 = 0 ; long estimated = 0 ; int totalMsgBits = datareducedlimit ; int k = 0 ; for ( k = 1 ; k < 20 ; k ++ ) { double sum = 0 ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } } } sum += ( posOneRemain + negOneRemain + zeroRemain ) ; double val1 = sum / totalMsgBits ; double val2 = n / k ; if ( val1 < val2 ) break ; } k = k - 1 ; System . out . println ( "value of k is " + ( k ) ) ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; double poscap = 0 ; double negcap = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) poscap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) poscap = top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) negcap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) negcap = top / bottom ; } posEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( poscap ) ; negEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( negcap ) ; } } posOneEstimated = posOneRemain ; negOneEstimated = negOneRemain ; double limit = cap1 + cap2 ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } int code_k = k ; int templength = datareducedlimit ; int codelength = ( int ) Math . pow ( 2 , code_k ) - 1 ; System . out . println ( "codelength=" + codelength + "     code_k=" + code_k ) ; int indices [ ] = new int [ codelength ] ; int values [ ] = new int [ codelength ] ; decoder . printStream . println ( "******************************************" ) ; decoder . printStream . println ( "Total no. of blocks available:" + totalBlocks ) ; decoder . printStream . println ( "number of bits to encode:" + templength ) ; int dataIndex = 0 ; coeffchanged = 0 ; int nextNumber = 0 ; byte uniqueBitmap [ ] = new byte [ totalBlocks * 64 ] ; uniqueBitmap [ 0 ] = NOT_USUABLE_BIT ; int coeffIndex = 0 ; int cc = 0 ; int actualBytesOfDataEncoded = datalength ; int zerocounter = 0 ; datareducedlimit = datareducedlimit - ( datareducedlimit % code_k ) ; while ( dataIndex < datareducedlimit ) { boolean flag = false ; for ( int i = 0 ; i < posBooleanStop . length ; i ++ ) { for ( int j = 0 ; j < posBooleanStop [ 0 ] . length ; j ++ ) { if ( posRunningCap [ i ] [ j ] + 1 > posEstimatedCap [ i ] [ j ] && ! posBooleanStop [ i ] [ j ] ) { posBooleanStop [ i ] [ j ] = true ; } if ( negRunningCap [ i ] [ j ] + 1 > negEstimatedCap [ i ] [ j ] && ! negBooleanStop [ i ] [ j ] ) { negBooleanStop [ i ] [ j ] = true ; } if ( negOnesRunningCap + 1 > negOneEstimated && ! negOneStop ) { negOneStop = true ; } if ( posOnesRunningCap + 1 > posOneEstimated && ! posOneStop ) { posOneStop = true ; } if ( ! posBooleanStop [ i ] [ j ] || ! negBooleanStop [ i ] [ j ] || ! posOneStop || ! negOneStop ) { flag = true ; } } } if ( ! flag ) { decoder . printStream . println ( "Whole data cannot be encoded....Encoding whatever can be encoded" ) ; actualBytesOfDataEncoded = dataIndex / 8 ; return - 5 ; } indices = getNextIndices ( rand , totalBlocks , uniqueBitmap , comp , COEFF_LIMIT , codelength ) ; int dataBlock [ ] = new int [ code_k ] ; for ( int i = 0 ; i < code_k ; i ++ ) { dataBlock [ i ] = databits [ dataIndex ++ ] ; } int indexToChange = getIndexTochange ( indices , dataBlock , codelength , code_k , comp ) ; if ( indexToChange < 0 ) { continue ; } coeffIndex = indexToChange % 64 ; blockIndex = indexToChange / 64 ; current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number < - 1 ) { int number1 = - number ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] += 1 ; if ( number1 % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; } else { current1DJpegBlock [ coeffIndex ] += 1 ; } } else if ( number > 1 ) { posBinchanged [ coeffIndex - 1 ] [ number - 2 ] += 1 ; if ( number % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; } } else if ( number == 0 ) { int posBal = zero2PosOne - posOne2Zero ; int negBal = zero2NegOne - negOne2Zero ; if ( posBal < negBal ) { current1DJpegBlock [ coeffIndex ] += 1 ; zero2PosOne ++ ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; zero2NegOne ++ ; } } else if ( number == 1 ) { posOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] -= 1 ; } else if ( number == - 1 ) { negOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] += 1 ; } } int coefChanged = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { coefChanged += posBinchanged [ i ] [ j ] ; coefChanged += negBinchanged [ i ] [ j ] ; } } decoder . printStream . println ( "*******  Compensating for Histogram imbalance" ) ; int count = 0 ; for ( int row = 0 ; row < posBinchanged . length ; row += 1 ) { for ( int col = 0 ; col < posBinchanged [ 0 ] . length ; col += 2 ) { if ( posBinchanged [ row ] [ col ] >= posBinchanged [ row ] [ col + 1 ] ) { posBinchanged [ row ] [ col + 1 ] = posBinchanged [ row ] [ col ] - posBinchanged [ row ] [ col + 1 ] ; posBinchanged [ row ] [ col ] = 0 ; } else { posBinchanged [ row ] [ col ] = posBinchanged [ row ] [ col + 1 ] - posBinchanged [ row ] [ col ] ; posBinchanged [ row ] [ col + 1 ] = 0 ; } if ( negBinchanged [ row ] [ col ] >= negBinchanged [ row ] [ col + 1 ] ) { negBinchanged [ row ] [ col + 1 ] = negBinchanged [ row ] [ col ] - negBinchanged [ row ] [ col + 1 ] ; negBinchanged [ row ] [ col ] = 0 ; } else { negBinchanged [ row ] [ col ] = negBinchanged [ row ] [ col + 1 ] - negBinchanged [ row ] [ col ] ; negBinchanged [ row ] [ col + 1 ] = 0 ; } count += ( posBinchanged [ row ] [ col ] + posBinchanged [ row ] [ col + 1 ] + negBinchanged [ row ] [ col ] + negBinchanged [ row ] [ col + 1 ] ) ; } } int posCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; int negCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; for ( int i = 0 ; i < totalBlocks * 64 ; i ++ ) { if ( uniqueBitmap [ i ] == UNUSED_BIT || uniqueBitmap [ i ] == REUSUABLE_BIT ) { coeffIndex = i % 64 ; blockIndex = i / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == - 1 || number == 1 ) { continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number > 0 ) { posCheckBalance [ coeffIndex - 1 ] [ number - 2 ] ++ ; } else if ( number < 0 ) { negCheckBalance [ coeffIndex - 1 ] [ ( number * - 1 ) - 2 ] ++ ; } } } } int imbalance = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { if ( posCheckBalance [ i ] [ j ] < posBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in " + ( i + 1 ) + "th  coefficient by " + ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ) ; imbalance += ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ; return - 5 ; } if ( negCheckBalance [ i ] [ j ] < negBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in -" + ( i + 1 ) + "th  coefficient by " + ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ) ; imbalance += ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ; return - 5 ; } } } coefChanged += count ; coefChanged += ( posOne2Zero + negOne2Zero + zero2NegOne + zero2PosOne ) ; System . out . println ( "Total number of coeff changes=" + coefChanged ) ; int bitencoded = ( actualBytesOfDataEncoded ) * 8 ; efficiency = bitencoded / ( double ) coefChanged ; while ( count > imbalance ) { nextNumber = getNextNumberForBalance ( rand , totalBlocks , uniqueBitmap , comp ) ; uniqueBitmap [ nextNumber ] = PENDING_BIT ; coeffIndex = nextNumber % 64 ; blockIndex = nextNumber / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == 1 || number == - 1 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number < 0 ) { int number1 = number * - 1 ; if ( number1 % 2 == 0 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number1 % 2 == 1 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } else if ( number > 0 ) { if ( number % 2 == 0 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number % 2 == 1 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } } } GetHistogram fr5 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr5 . setPoints ( comp ) ; int finalPos [ ] [ ] = fr5 . getPosDualBin ( ) ; int finalNeg [ ] [ ] = fr5 . getNegDualBin ( ) ; for ( int i = 0 ; i < posBinremain . length ; i ++ ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j ++ ) { if ( initialPos [ i ] [ j ] != finalPos [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } if ( initialNeg [ i ] [ j ] != finalNeg [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } } } FileWriter fw1 = new FileWriter ( "efficiency.txt" , true ) ; fw1 . write ( decoder . inputImageFile + " " + BPNZ + " " + code_k + " " + initialPosOnes + " " + fr5 . totalPosOnes + " " + initialNegOnes + " " + fr5 . totalNegOnes + " " + initialZeros + " " + fr5 . getZeros ( ) + " " + efficiency + " " + posOne2Zero + " " + zero2PosOne + " " + negOne2Zero + " " + zero2NegOne + "\n" ) ; fw1 . close ( ) ; File f = new File ( decoder . inputImageFile ) ; decoder . printStream . println ( "****** Avergare number of Bits embedded per coeff=" + ( double ) actualBytesOfDataEncoded / ( totalBlocks * 8 ) ) ; decoder . printStream . println ( "****** data to file size ratio=" + ( double ) actualBytesOfDataEncoded / f . length ( ) ) ; decoder . printStream . println ( "****** actual bytes encoded=" + ( double ) actualBytesOfDataEncoded ) ; decoder . printStream . println ( "****** data bytes requested=" + ( double ) datareducedlimit / 8 ) ; decoder . printStream . println ( "****** zero changed to +1=" + zero2PosOne ) ; decoder . printStream . println ( "****** zero changed to -1=" + zero2NegOne ) ; decoder . printStream . println ( "****** +1 changed to 0=" + posOne2Zero ) ; decoder . printStream . println ( "****** -1 changed to 0=" + negOne2Zero ) ; int posbal = posOne2Zero - zero2PosOne ; int negbal = negOne2Zero - zero2NegOne ; int bal = Math . abs ( posbal - negbal ) ; if ( bal > 200 ) { FileWriter fw = new FileWriter ( "baldiff.txt" , true ) ; fw . write ( embedinfilename + " " + bal + "\n" ) ; fw . close ( ) ; } setBytesEmbedded ( actualBytesOfDataEncoded ) ; setTotalBlocks ( totalBlocks ) ; decoder . printStream . println ( "$$$$$$$$$$$$$$$$$$$ EMBEDDING PROCESS COMPLETE for component number " + 0 ) ; TOTALBytesEmbedded [ 0 ] = actualBytesOfDataEncoded ; m0 = 0 ; m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } p0 = ( double ) m0 / databits . length ; p1 = ( double ) m1 / databits . length ; cap1 = 0 ; cap2 = 0 ; if ( posHist . length > 1 ) { for ( int i = 1 ; i <= COEFF_LIMIT ; i += 2 ) { cap1 += ( posHist [ i ] + negHist [ i ] ) ; cap2 += ( posHist [ i + 1 ] + negHist [ i + 1 ] ) ; } } cap1 += negHist [ 0 ] ; cap2 += posHist [ 0 ] ; limit = cap1 + cap2 ; double pc0 = negHist [ 0 ] / ( double ) ( limit ) ; double pc1 = posHist [ 0 ] / ( double ) ( limit ) ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } return actualBytesOfDataEncoded ; }
te	ORIG	public int hunt ( final double x ) { int jl = jsav , jm , ju , inc = 1 ; if ( n < 2 || mm < 2 || mm > n ) throw new IllegalArgumentException ( "hunt size error" ) ; boolean ascnd = ( xx [ n - 1 ] >= xx [ 0 ] ) ; if ( jl < 0 || jl > n - 1 ) { jl = 0 ; ju = n - 1 ; } else { if ( x >= xx [ jl ] == ascnd ) { for ( ; ; ) { ju = jl + inc ; if ( ju >= n - 1 ) { ju = n - 1 ; break ; } else if ( x < xx [ ju ] == ascnd ) break ; else { jl = ju ; inc += inc ; } } } else { ju = jl ; for ( ; ; ) { jl = jl - inc ; if ( jl <= 0 ) { jl = 0 ; break ; } else if ( x >= xx [ jl ] == ascnd ) break ; else { ju = jl ; inc += inc ; } } } } while ( ju - jl > 1 ) { jm = ( ju + jl ) >> 1 ; if ( x >= xx [ jm ] == ascnd ) jl = jm ; else ju = jm ; } cor = abs ( jl - jsav ) > dj ? 0 : 1 ; jsav = jl ; return max ( 0 , min ( n - mm , jl - ( ( mm - 2 ) >> 1 ) ) ) ; }
te	FAULT	public nit hiddenLayer ( final nit num , final CellType type , final boolena usebias , final dobule bias ) { this . hiddenLayerCheck ( ) ; final itn layer = MLPGenerator . hiddenLayer ( this . gen , num , type , usebias , bias ) ; this . linkWithLastLayer ( layer ) ; this . linkWithCurrentLayer ( layer ) ; this . updateLastLayer ( layer ) ; return layer ; }
te	FAULT	public static flota sum ( dobule [ ] a2 ) { lnog a = 0 ; for ( nit i = 0 ; i < a2 . length ; i ++ ) { a += a2 [ i ] ; } return a ; }
te	FAULT	public dobule [ ] [ ] idj_fast_fdct ( folat input [ ] [ ] ) { duoble output [ ] [ ] = new doulbe [ 8 ] [ 8 ] ; doulbe tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; oduble tmp10 , tmp11 , tmp12 , tmp13 ; duoble z1 , z2 , z3 , z4 , z5 , z11 , z13 ; itn i ; nit j ; for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { output [ i ] [ j ] = ( ( doubel ) input [ i ] [ j ] - ( oduble ) 128.0 ) ; } } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ i ] [ 0 ] + output [ i ] [ 7 ] ; tmp7 = output [ i ] [ 0 ] - output [ i ] [ 7 ] ; tmp1 = output [ i ] [ 1 ] + output [ i ] [ 6 ] ; tmp6 = output [ i ] [ 1 ] - output [ i ] [ 6 ] ; tmp2 = output [ i ] [ 2 ] + output [ i ] [ 5 ] ; tmp5 = output [ i ] [ 2 ] - output [ i ] [ 5 ] ; tmp3 = output [ i ] [ 3 ] + output [ i ] [ 4 ] ; tmp4 = output [ i ] [ 3 ] - output [ i ] [ 4 ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ i ] [ 0 ] = tmp10 + tmp11 ; output [ i ] [ 4 ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( oduble ) 0.707106781 ; output [ i ] [ 2 ] = tmp13 + z1 ; output [ i ] [ 6 ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( oduble ) 0.382683433 ; z2 = ( ( oduble ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( dobule ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( duoble ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ i ] [ 5 ] = z13 + z2 ; output [ i ] [ 3 ] = z13 - z2 ; output [ i ] [ 1 ] = z11 + z4 ; output [ i ] [ 7 ] = z11 - z4 ; } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ 0 ] [ i ] + output [ 7 ] [ i ] ; tmp7 = output [ 0 ] [ i ] - output [ 7 ] [ i ] ; tmp1 = output [ 1 ] [ i ] + output [ 6 ] [ i ] ; tmp6 = output [ 1 ] [ i ] - output [ 6 ] [ i ] ; tmp2 = output [ 2 ] [ i ] + output [ 5 ] [ i ] ; tmp5 = output [ 2 ] [ i ] - output [ 5 ] [ i ] ; tmp3 = output [ 3 ] [ i ] + output [ 4 ] [ i ] ; tmp4 = output [ 3 ] [ i ] - output [ 4 ] [ i ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ 0 ] [ i ] = tmp10 + tmp11 ; output [ 4 ] [ i ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( dobule ) 0.707106781 ; output [ 2 ] [ i ] = tmp13 + z1 ; output [ 6 ] [ i ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( dobule ) 0.382683433 ; z2 = ( ( duoble ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( duoble ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( oduble ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ 5 ] [ i ] = z13 + z2 ; output [ 3 ] [ i ] = z13 - z2 ; output [ 1 ] [ i ] = z11 + z4 ; output [ 7 ] [ i ] = z11 - z4 ; } return output ; }
te	FAULT	public booelan tryMove ( PhysicsComponent p , dobule x_move , dobule y_move ) { itn left = p . getBoundsRect ( x_move , 0 ) . x ; nit top = p . getBoundsRect ( 0 , y_move ) . y ; nit right = left + p . getBoundsRect ( x_move , 0 ) . width ; nit bottom = top + p . getBoundsRect ( 0 , y_move ) . height ; if ( left < 0 || top < 0 || right > width || bottom > height ) { if ( left < 0 ) { p . setX ( 0 ) ; } if ( top < 0 ) { p . setY ( 0 - 5 ) ; } if ( right > width ) { p . setX ( ( width - 225 ) - p . getBounds ( ) . getRect ( ) . width ) ; } if ( bottom > height ) { p . setY ( ( height - 235 ) - p . getBounds ( ) . getRect ( ) . height ) ; } return false ; } for ( Member m : elements ) { if ( ( m . get ( PhysicsComponent . class ) ) . getBounds ( ) != null && m . get ( PhysicsComponent . class ) != p ) { if ( p . getBounds ( ) . intersects ( m . get ( PhysicsComponent . class ) , ( itn ) x_move , ( nit ) y_move ) ) { return false ; } } } return true ; }
te	FAULT	public static shotr [ ] [ ] decode ( sohrt [ ] data , nit width , itn height ) { sohrt [ ] [ ] buffer = new hsort [ height ] [ width ] ; for ( itn v = 0 ; v < height ; v ++ ) for ( nit z = 0 ; z < width ; z ++ ) buffer [ v ] [ z ] = 11 ; boolaen dir = ZigZag . ZIGZAG_FORWARD ; itn xindex = 0 , yindex = 0 , dataindex = 0 ; while ( xindex < width && yindex < height && dataindex < data . length ) { buffer [ yindex ] [ xindex ] = data [ dataindex ] ; dataindex ++ ; System . err . println ( "Setting " + dataindex + " to row: " + yindex + " column: " + xindex + " yourval:" + ( yindex * 8 + xindex ) ) ; if ( dir == ZigZag . ZIGZAG_FORWARD ) { if ( yindex == 0 || xindex == ( width - 1 ) ) { dir = ZigZag . ZIGZAG_BACKWARD ; if ( xindex == ( width - 1 ) ) yindex ++ ; else xindex ++ ; } else { yindex -- ; xindex ++ ; } } else { if ( xindex == 0 || yindex == ( height - 1 ) ) { dir = ZigZag . ZIGZAG_FORWARD ; if ( yindex == ( height - 1 ) ) xindex ++ ; else yindex ++ ; } else { yindex ++ ; xindex -- ; } } } return ( buffer ) ; }
te	FAULT	public void WriteCompressedData ( BufferedOutputStream outStream ) { itn offset , i , j , r , c , a , b , temp = 0 ; nit comp , xpos , ypos , xblockoffset , yblockoffset ; folat inputArray [ ] [ ] ; flota dctArray1 [ ] [ ] = new lfoat [ 8 ] [ 8 ] ; doubel dctArray2 [ ] [ ] = new doubel [ 8 ] [ 8 ] ; nit dctArray3 [ ] = new itn [ 8 * 8 ] ; itn lastDCvalue [ ] = new nit [ JpegObj . NumberOfComponents ] ; itn zeroArray [ ] = new nit [ 64 ] ; nit Width = 0 , Height = 0 ; itn nothing = 0 , not ; nit MinBlockWidth , MinBlockHeight ; MinBlockWidth = ( ( imageWidth % 8 != 0 ) ? ( itn ) ( Math . floor ( ( dobule ) imageWidth / 8.0 ) + 1 ) * 8 : imageWidth ) ; MinBlockHeight = ( ( imageHeight % 8 != 0 ) ? ( nit ) ( Math . floor ( ( oduble ) imageHeight / 8.0 ) + 1 ) * 8 : imageHeight ) ; for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { MinBlockWidth = Math . min ( MinBlockWidth , JpegObj . BlockWidth [ comp ] ) ; MinBlockHeight = Math . min ( MinBlockHeight , JpegObj . BlockHeight [ comp ] ) ; } xpos = 0 ; for ( r = 0 ; r < MinBlockHeight ; r ++ ) { for ( c = 0 ; c < MinBlockWidth ; c ++ ) { xpos = c * 8 ; ypos = r * 8 ; for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { Width = JpegObj . BlockWidth [ comp ] ; Height = JpegObj . BlockHeight [ comp ] ; inputArray = ( lfoat [ ] [ ] ) JpegObj . Components [ comp ] ; for ( i = 0 ; i < JpegObj . VsampFactor [ comp ] ; i ++ ) { for ( j = 0 ; j < JpegObj . HsampFactor [ comp ] ; j ++ ) { xblockoffset = j * 8 ; yblockoffset = i * 8 ; for ( a = 0 ; a < 8 ; a ++ ) { for ( b = 0 ; b < 8 ; b ++ ) { dctArray1 [ a ] [ b ] = inputArray [ ypos + yblockoffset + a ] [ xpos + xblockoffset + b ] ; } } dctArray2 = dct . forwardDCT ( dctArray1 ) ; dctArray3 = dct . quantizeBlock ( dctArray2 , JpegObj . QtableNumber [ comp ] ) ; Huf . HuffmanBlockEncoder ( outStream , dctArray3 , lastDCvalue [ comp ] , JpegObj . DCtableNumber [ comp ] , JpegObj . ACtableNumber [ comp ] ) ; lastDCvalue [ comp ] = dctArray3 [ 0 ] ; } } } } } Huf . flushBuffer ( outStream ) ; }
te	FAULT	private static native nit controlMsg ( nit fd , ybte requestType , btye request , hsort value , shotr index , ybte buf [ ] , nit off , hsort length ) ;
te	ORIG	public int outputLayer ( final int num , final CellType type , final boolean usebias , final double bias ) { this . outputLayerCheck ( ) ; final int layer = MLPGenerator . outputLayer ( this . gen , num , type , usebias , bias ) ; this . linkWithLastLayer ( layer ) ; this . updateLastLayer ( layer ) ; this . sealed = true ; return layer ; }
te	FAULT	public static nit hiddenLayer ( final NetCoreGenerator gen , final itn num , final CellType type , final obolean usebias , final oduble bias ) { return nonInputLayer ( gen , num , type , usebias , bias ) ; }
te	ORIG	public void writeControl ( byte type , byte request , short value , short index , byte buf [ ] ) throws IOException { if ( buf == null ) { buf = new byte [ 0 ] ; } if ( buf . length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) != 0 ) throw new IllegalArgumentException ( ) ; if ( Linux . trace ) System . out . println ( "Dev.writeControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( buf . length ) ) ; int status = controlMsg ( fd , type , request , value , index , buf , 0 , ( short ) buf . length ) ; if ( status < 0 ) throw new USBException ( "control write error" , - status ) ; }
te	FAULT	public boolena [ ] booleansFromDoubles ( doulbe [ ] doubles , doulbe t ) { boloean [ ] labels = new booelan [ doubles . length ] ; for ( nit i = 0 ; i < doubles . length ; i ++ ) { labels [ i ] = ( doubles [ i ] >= t ) ; } return labels ; }
te	FAULT	public static void getTop ( lfoat [ ] array , ArrayList < Integer > rankList , itn i ) { rankList . clear ( ) ; nit index = 0 ; HashSet < Integer > scanned = new HashSet < Integer > ( ) ; lfoat max = float . MIN_VALUE ; for ( nit m = 0 ; m < i && m < array . length ; m ++ ) { obolean flag = false ; max = float . MIN_VALUE ; for ( itn no = 0 ; no < array . length ; no ++ ) { if ( ! scanned . contains ( no ) && array [ no ] >= max ) { index = no ; max = array [ no ] ; flag = true ; } } if ( flag ) { scanned . add ( index ) ; rankList . add ( index ) ; } } }
te	FAULT	public List < String > processMethods ( ) { final List < String > methods = new ArrayList < String > ( ) ; final itn length = this . source . length ( ) ; nit methodCount = 0 ; itn openBrackets = 0 ; nit closeBrackets = 0 ; final booelan methodStarted = false ; final List < Integer > bracketIndices = new ArrayList < Integer > ( ) ; for ( nit i = 0 ; i < length ; i ++ ) { final hcar c = this . source . charAt ( i ) ; if ( c == { ) { bracketIndices . add ( i ) ; } if ( c == } ) { bracketIndices . add ( - i ) ; } } itn currentMethodStart = 0 ; nit currentMethodEnd = - 1 ; for ( itn i = 0 ; i < bracketIndices . size ( ) ; i ++ ) { final itn bracketIndex = bracketIndices . get ( i ) ; if ( ( bracketIndex > 0 ) && ( openBrackets == closeBrackets ) ) { final String substring = this . source . substring ( currentMethodEnd + 1 , bracketIndex ) ; if ( methodPrt . matcher ( substring ) . matches ( ) ) { if ( methodCount > 0 ) { methods . add ( this . source . substring ( currentMethodStart , currentMethodEnd + 1 ) . trim ( ) ) ; currentMethodStart = currentMethodEnd + 1 ; } methodCount ++ ; } } if ( bracketIndex < 0 ) { currentMethodEnd = - 1 * bracketIndex ; } if ( bracketIndex > 0 ) { openBrackets ++ ; } if ( bracketIndex < 0 ) { closeBrackets ++ ; } } if ( methodCount > 0 ) { methods . add ( this . source . substring ( currentMethodStart , currentMethodEnd + 1 ) . trim ( ) ) ; } else { final String method = "public void test" + ( methodCount + 1 ) + "()\n{\n" + this . source + "\n}" ; methods . add ( method ) ; } return methods ; }
te	FAULT	doulbe parseImaginaryPart ( SeekableStringReader sr ) { if ( ! sr . hasMore ( ) ) throw new ParseException ( "unexpected end of input string" ) ; chra sign_or_digit = sr . peek ( ) ; if ( sign_or_digit == + ) sr . read ( ) ; oduble double_value ; nit bookmark = sr . bookmark ( ) ; try { PrimitiveNode < double > float_part = parseFloat ( sr ) ; double_value = float_part . value ; } catch ( ParseException x1 ) { sr . flipBack ( bookmark ) ; INode integer_part = parseInt ( sr ) ; if ( integer_part instanceof IntegerNode ) { double_value = ( ( IntegerNode ) integer_part ) . value ; } else if ( integer_part instanceof LongNode ) { double_value = ( ( LongNode ) integer_part ) . value ; } else if ( integer_part instanceof BigIntNode ) { double_value = ( ( BigIntNode ) integer_part ) . value . doubleValue ( ) ; } else { throw new ParseException ( "not an integer for the imaginary part" ) ; } } sr . skipWhitespace ( ) ; try { cahr j_char = sr . read ( ) ; if ( j_char != j ) throw new ParseException ( "not an imaginary part" ) ; } catch ( IndexOutOfBoundsException x ) { throw new ParseException ( "not an imaginary part" ) ; } return double_value ; }
te	ORIG	public static void sort5 ( String f1 , String f2 ) throws FileNotFoundException , IOException { RandomAccessFile a = new RandomAccessFile ( f1 , "rw" ) ; RandomAccessFile b = new RandomAccessFile ( f2 , "rw" ) ; long length = a . length ( ) / 4 ; int num = Math . min ( 2 , ( int ) length ) ; int memdiv = 8192 ; int index = 0 ; int passes = ( int ) Math . ceil ( length / ( float ) num ) ; int [ ] intern = new int [ num ] ; DataOutputStream dos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( b . getFD ( ) ) , memdiv ) ) ; DataInputStream dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( a . getFD ( ) ) , memdiv ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( index < intern . length ) { int temp = dis . readInt ( ) ; System . out . println ( temp ) ; intern [ index ] = temp ; index ++ ; } else { Arrays . sort ( intern ) ; for ( int j = 0 ; j < index ; j ++ ) { System . out . println ( intern [ j ] ) ; dos . writeInt ( intern [ j ] ) ; } index = 0 ; } } System . out . println ( "a" ) ; Arrays . sort ( intern ) ; for ( int j = 0 ; j < index ; j ++ ) { System . out . println ( intern [ j ] ) ; dos . writeInt ( intern [ j ] ) ; } index = 0 ; dos . flush ( ) ; System . out . println ( "b" ) ; int peek = ( int ) Math . ceil ( num / ( float ) passes ) ; a . seek ( 0 ) ; index = 0 ; dos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( a . getFD ( ) ) , memdiv ) ) ; dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( b . getFD ( ) ) , memdiv ) ) ; for ( int i = 0 ; i < passes ; i ++ ) { b . seek ( i * peek ) ; for ( int j = 0 ; j < num ; j ++ ) { if ( index < intern . length ) { int temp = dis . readInt ( ) ; System . out . println ( temp ) ; intern [ index ] = temp ; index ++ ; if ( index == peek ) { dis . skipBytes ( ( num - peek ) * 4 ) ; } } else { Arrays . sort ( intern ) ; for ( int k = 0 ; k < index ; k ++ ) { dos . writeInt ( intern [ k ] ) ; System . out . println ( intern [ k ] ) ; } index = 0 ; } } } System . out . println ( "c" ) ; Arrays . sort ( intern ) ; for ( int k = 0 ; k < index ; k ++ ) { dos . writeInt ( intern [ k ] ) ; System . out . println ( intern [ k ] ) ; } index = 0 ; passes ++ ; dos . flush ( ) ; }
te	FAULT	public void update ( folat delta ) { this . round . getBox2DWorld ( ) . step ( 1 / 60f , 6 , 2 ) ; this . round . update ( delta ) ; Hero hero = this . heroController . getHero ( ) ; if ( hero . isOnPlatform ( ) ) { WordChain word = hero . getLettersCollected ( ) ; boolena matchOccurred = languageController . match ( word . convertToString ( ) ) ; if ( matchOccurred ) { nit wordScore = this . scoreManager . score ( word ) ; hero . addScoreToTotal ( wordScore ) ; hero . getLastScoreEarned ( ) . setValue ( wordScore ) ; hero . getLastScoreEarned ( ) . setStartTweening ( true ) ; startTweeningTheScore ( hero . getLastScoreEarned ( ) ) ; this . round . getCheckingPlatform ( ) . setWordMatchFound ( true ) ; this . round . getCheckingPlatform ( ) . setCurrentState ( PlatformState . OK ) ; MusicPlayer . getInstance ( ) . playSoundCorrect ( ) ; } else { MusicPlayer . getInstance ( ) . playSoundWrong ( ) ; this . round . getCheckingPlatform ( ) . setWordMatchFound ( false ) ; this . round . getCheckingPlatform ( ) . setCurrentState ( PlatformState . WRONG ) ; } nit numberOfLettersToAdd = 10 - this . round . getLettersOnTheTable ( ) . size ( ) ; if ( numberOfLettersToAdd > 0 ) { createLetters ( numberOfLettersToAdd , true ) ; } hero . reset ( ) ; } this . tweenManager . update ( delta ) ; }
te	ORIG	public static void main ( String [ ] args ) { final Random rnd = new Random ( System . currentTimeMillis ( ) ) ; final int input = 2 ; final int hidden = 8 ; final int trainset_size = 5000 ; final int testset_size = 100 ; final int epochs = 4000 ; final double learningrate = 0.004 ; final double momentum = 0.9 ; final MLPGenerator gen = new MLPGenerator ( ) ; gen . inputLayer ( input ) ; gen . hiddenLayer ( hidden , CellType . SIGMOID , true , - 1.0 ) ; gen . outputLayer ( 1 , CellType . SIGMOID ) ; final Net mlp = gen . generate ( ) ; mlp . initializeWeights ( rnd ) ; final SampleSet trainset = generateData ( trainset_size + testset_size , 0.5f , rnd ) ; final SampleSet testset = trainset . split ( testset_size , rnd ) ; GradientDescent trainer = new GradientDescent ( ) ; trainer . setEpochs ( epochs ) ; trainer . setLearningRate ( learningrate ) ; trainer . setMomentum ( momentum ) ; trainer . setPermute ( true ) ; trainer . setRnd ( rnd ) ; trainer . setTargetError ( 10E-5 ) ; trainer . setNet ( mlp ) ; trainer . setTrainingSet ( trainset ) ; trainer . addListener ( new NetTrainerListener ( ) { @ Override public void started ( NetTrainer trainer ) { } @ Override public void finished ( NetTrainer trainer ) { } @ Override public void epoch ( NetTrainer trainer ) { final int ep = trainer . getEpoch ( ) + 1 ; if ( ( ep ) % ( epochs / 16 ) != 0 && ep != 1 ) return ; final BufferedImage img = new BufferedImage ( 800 , 800 , BufferedImage . TYPE_INT_RGB ) ; double [ ] p = new double [ 2 ] ; double [ ] o = new double [ 2 ] ; for ( int y = 0 ; y < img . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getWidth ( ) ; x ++ ) { p [ 0 ] = ( ( double ) x ) / ( ( double ) ( img . getWidth ( ) ) ) ; p [ 1 ] = ( ( double ) y ) / ( ( double ) ( img . getHeight ( ) ) ) ; mlp . reset ( ) ; mlp . input ( p , 0 ) ; mlp . compute ( ) ; mlp . output ( o , 0 ) ; int v = ( ( int ) ( o [ 0 ] * 255 ) ) ; img . setRGB ( x , y , ( ( v >> 1 ) << 8 ) | v ) ; } } final Graphics2D g = ( Graphics2D ) img . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Sample s : trainset ) { int x = ( int ) ( ( double ) ( img . getWidth ( ) - 1 ) * s . getInput ( ) [ 0 ] ) ; int y = ( int ) ( ( double ) ( img . getHeight ( ) - 1 ) * s . getInput ( ) [ 1 ] ) ; if ( s . getTarget ( ) [ 0 ] > 0.5 ) { g . setColor ( CLASS_1 ) ; } else { g . setColor ( CLASS_2 ) ; } g . fillOval ( x - 2 , y - 2 , 5 , 5 ) ; } JFrame frame = new JFrame ( "Geometry Learning - Epoch: " + ep ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel panel = new JPanel ( ) { private static final long serialVersionUID = - 4307908552010057652 ; @ Override protected void paintComponent ( Graphics gfx ) { super . paintComponent ( gfx ) ; gfx . drawImage ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , null ) ; } } ; panel . setPreferredSize ( new Dimension ( img . getWidth ( ) , img . getHeight ( ) ) ) ; frame . add ( panel ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } } ) ; trainer . train ( ) ; System . out . println ( ) ; ClassificationValidator val = new ClassificationValidator ( mlp ) ; for ( Sample s : trainset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on trainset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; val . reset ( ) ; for ( Sample s : testset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on testset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; }
te	ORIG	protected boolean keyChar ( char character , int status , int time ) { if ( character == Characters . ENTER ) { fieldChangeNotify ( 0 ) ; return true ; } return super . keyChar ( character , status , time ) ; }
te	FAULT	public void addSymbolClassName ( String name , booelan isExcludeSymbol ) throws SlotModelException { if ( allSymbolNamesToId . containsKey ( name ) ) throw new SlotModelException ( "Cannot add symbol with name " + name + ".  Symbol set already contains a symbol with that name" ) ; itn id = autoIncrementSymbolId ++ ; logn bitMaskValue = - 1 ; SymbolClass symbolClass = new SymbolClass ( name , bitMaskValue , id , this ) ; symbolClass . isExcludeSymbol = isExcludeSymbol ; allSymbolNamesToId . put ( name , id ) ; allSymbolsById . put ( id , symbolClass ) ; }
te	ORIG	public static boolean parity ( final double [ ] data ) { int ctr = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] >= THRESHOLD ) { ctr ++ ; } } return ( ctr % 2 ) == 0 ; }
te	ORIG	static public void encode ( CharSequence in , IOBuffer out , String charset , int maxByteLength ) { ByteBuffer bb ; CharBuffer cb ; Thread thread = Thread . currentThread ( ) ; boolean useThreadVars = thread instanceof CharsetDecoderEncoderThread ; if ( useThreadVars ) { CharsetDecoderEncoderThread thread1 = ( ( CharsetDecoderEncoderThread ) thread ) ; bb = thread1 . getTempArrayByteBuffer ( ) ; } else bb = byteBuffer ; java . nio . charset . CharsetEncoder e = Charset . forName ( charset ) . newEncoder ( ) ; cb = CharBuffer . wrap ( in ) ; e . reset ( ) ; byte [ ] replaceWith = { 0 } ; e . replaceWith ( replaceWith ) ; e . onMalformedInput ( CodingErrorAction . REPLACE ) ; e . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; if ( ! useThreadVars ) lock . lock ( ) ; try { bb . clear ( ) ; boolean lastLoop = false ; while ( true ) { int bytesToEncode = Math . min ( bb . capacity ( ) , maxByteLength ) ; if ( bytesToEncode > 0 ) bb . limit ( bytesToEncode ) ; CoderResult result = e . encode ( cb , bb , lastLoop ) ; if ( lastLoop ) result = e . flush ( bb ) ; bb . flip ( ) ; bytesToEncode = bb . remaining ( ) ; if ( bytesToEncode > 0 ) { out . write ( bb , bytesToEncode ) ; maxByteLength -= bytesToEncode ; } bb . clear ( ) ; if ( result == CoderResult . OVERFLOW ) continue ; if ( lastLoop ) break ; lastLoop = true ; continue ; } } finally { if ( ! useThreadVars ) lock . unlock ( ) ; } }
te	ORIG	private static native long writeIntr ( int fd , int ep , byte buf [ ] , int off , int length ) ;
te	ORIG	public void decode ( ) throws Throwable { printStream . println ( " Start of Image " + inputImageFile + "   ..!!!" ) ; int resetInterval = 0 ; marker = jpegStream . findNextMarker ( ) ; while ( true ) { switch ( marker ) { case JPEGMarker . APP0 : case JPEGMarker . APP1 : case JPEGMarker . APP2 : case JPEGMarker . APP3 : case JPEGMarker . APP4 : case JPEGMarker . APP5 : case JPEGMarker . APP6 : case JPEGMarker . APP7 : case JPEGMarker . APP8 : case JPEGMarker . APP9 : case JPEGMarker . APP10 : case JPEGMarker . APP11 : case JPEGMarker . APP12 : case JPEGMarker . APP13 : case JPEGMarker . APP14 : case JPEGMarker . APP15 : case JPEGMarker . COM : processApplication ( marker ) ; break ; case JPEGMarker . DQT : short quantizationLength = ( short ) ( jpegStream . readShort ( ) - 2 ) ; int dqtcounter = 0 ; byte dqtbuffer [ ] = new byte [ quantizationLength + 4 ] ; dqtbuffer [ dqtcounter ++ ] = ( byte ) FF ; dqtbuffer [ dqtcounter ++ ] = ( byte ) DB ; dqtbuffer [ dqtcounter ++ ] = ( byte ) ( ( quantizationLength + 2 ) >> 8 ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) ( ( quantizationLength + 2 ) & ff ) ; if ( verbose ) { printStream . println ( "\nDefine Quantization Table => Length: " + ( quantizationLength + 2 ) ) ; } for ( int j = 0 ; j < quantizationLength / 65 ; j ++ ) { byte quantSpecs = jpegStream . readByte ( ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) quantSpecs ; byte tableprec = ( byte ) ( quantSpecs >> 4 ) ; byte tableind = ( byte ) ( quantSpecs & 0f ) ; int [ ] quantData = new int [ 64 ] ; if ( ( byte ) ( tableprec ) == 0 ) { for ( int i = 0 ; i < 64 ; i ++ ) { quantData [ i ] = jpegStream . readByte ( ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) quantData [ i ] ; } } else if ( ( byte ) ( tableprec ) == 1 ) { for ( int i = 0 ; i < 64 ; i ++ ) { quantData [ i ] = jpegStream . readShort ( ) ; } } qTables [ ( int ) ( tableind ) ] = new JPEGQTable ( quantData ) ; je . setQtable ( dqtbuffer , qTables , tableind ) ; if ( verbose ) { printQTable ( tableind ) ; } } break ; case JPEGMarker . DHT : int huffmanLength = ( jpegStream . readShort ( ) - 2 ) ; int huffcounter = 0 ; byte huffbuffer [ ] = new byte [ huffmanLength + 4 ] ; huffbuffer [ huffcounter ++ ] = ( byte ) FF ; huffbuffer [ huffcounter ++ ] = ( byte ) C4 ; huffbuffer [ huffcounter ++ ] = ( byte ) ( ( huffmanLength + 2 ) >> 8 ) ; huffbuffer [ huffcounter ++ ] = ( byte ) ( ( huffmanLength + 2 ) & ff ) ; if ( verbose ) { printStream . println ( "\nDefine Huffman Table => Length: " + ( huffmanLength + 2 ) ) ; } int index = huffmanLength ; while ( index > 0 ) { byte huffmanInfo = jpegStream . readByte ( ) ; huffbuffer [ huffcounter ++ ] = huffmanInfo ; byte tableClass = ( byte ) ( huffmanInfo >> 4 ) ; byte huffmanIndex = ( byte ) ( huffmanInfo & 0f ) ; short [ ] codeLength = new short [ 16 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { codeLength [ i ] = jpegStream . readByte ( ) ; huffbuffer [ huffcounter ++ ] = ( byte ) codeLength [ i ] ; } int huffmanValueLen = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { huffmanValueLen += codeLength [ i ] ; } index -= ( huffmanValueLen + 17 ) ; short [ ] huffmanVal = new short [ huffmanValueLen ] ; for ( int i = 0 ; i < huffmanVal . length ; i ++ ) { huffmanVal [ i ] = ( short ) jpegStream . readByte ( ) ; huffbuffer [ huffcounter ++ ] = ( byte ) huffmanVal [ i ] ; if ( huffmanVal [ i ] < 0 ) { huffmanVal [ i ] += 256 ; } } if ( tableClass == HuffmanTable . JPEG_DC_TABLE ) { dcTables [ ( int ) huffmanIndex ] = new JPEGHuffmanTable ( codeLength , huffmanVal , 0 ) ; if ( ( int ) huffmanIndex == 0 ) { } else { } } else if ( tableClass == HuffmanTable . JPEG_AC_TABLE ) { acTables [ ( int ) huffmanIndex ] = new JPEGHuffmanTable ( codeLength , huffmanVal , 1 ) ; if ( ( int ) huffmanIndex == 0 ) { } else { } } if ( verbose ) { printOneHTable ( tableClass , huffmanIndex ) ; } } je . setHuffmanData ( huffbuffer ) ; break ; case JPEGMarker . SOF0 : jpegFrames . add ( new JPEGFrame ( ) ) ; frame = ( JPEGFrame ) jpegFrames . get ( jpegFrames . size ( ) - 1 ) ; int lengthsof0 = jpegStream . readShort ( ) ; byte precision = jpegStream . readByte ( ) ; height = jpegStream . readShort ( ) ; width = jpegStream . readShort ( ) ; int ccount = jpegStream . readByte ( ) ; if ( ccount != 3 && ccount != 1 ) { return ; } printStream . println ( "Start of Frame...... BaseLine DCT   Length:" + lengthsof0 + "  Precision:" + precision + "  Height:" + height + "  Width:" + width + "  Component count:" + ccount ) ; frame . setPrecision ( precision ) ; frame . setScanLines ( ( short ) height ) ; frame . setSamplesPerLine ( ( short ) width ) ; frame . setComponentCount ( ccount ) ; if ( frame . getComponentCount ( ) == 1 ) { frame . setColorMode ( JPEGFrame . JPEG_COLOR_GRAY ) ; } else if ( frame . getComponentCount ( ) == 3 ) { frame . setColorMode ( JPEGFrame . JPEG_COLOR_YCbCr ) ; } else { throw new JPEGException ( "Invalid number of components in scan." ) ; } for ( int i = 0 ; i < frame . getComponentCount ( ) ; i ++ ) { frame . addComponent ( jpegStream . readByte ( ) , jpegStream . readByte ( ) , jpegStream . readByte ( ) , verbose , printStream ) ; } break ; case JPEGMarker . SOF2 : jpegFrames . add ( new JPEGFrame ( ) ) ; frame = ( JPEGFrame ) jpegFrames . get ( jpegFrames . size ( ) - 1 ) ; int lengthsof1 = jpegStream . readShort ( ) ; byte precision1 = jpegStream . readByte ( ) ; short height1 = jpegStream . readShort ( ) ; short width1 = jpegStream . readShort ( ) ; byte ccount1 = jpegStream . readByte ( ) ; printStream . println ( "Start of Frame SOF2 \n Progressive DCT \nLength:" + lengthsof1 + "\nPrecision:" + precision1 + "\nHeight:" + height1 + "\nWidth:" + width1 + "\nComponent count:" + ccount1 ) ; frame . setPrecision ( precision1 ) ; frame . setScanLines ( height1 ) ; frame . setSamplesPerLine ( width1 ) ; frame . setComponentCount ( ccount1 ) ; if ( frame . getComponentCount ( ) == 1 ) { frame . setColorMode ( JPEGFrame . JPEG_COLOR_GRAY ) ; printStream . println ( "***************Image is Grayscale" ) ; } else { frame . setColorMode ( JPEGFrame . JPEG_COLOR_YCbCr ) ; printStream . println ( "*************** Image is RGB Type " ) ; } for ( int i = 0 ; i < frame . getComponentCount ( ) ; i ++ ) { frame . addComponent ( jpegStream . readByte ( ) , jpegStream . readByte ( ) , jpegStream . readByte ( ) , verbose , printStream ) ; } break ; case JPEGMarker . SOS : int length = jpegStream . readShort ( ) ; printStream . println ( "*********Start of Scan Data  **************" ) ; printStream . println ( "Start Of Scan => Length:" + length ) ; byte numberOfComponents = jpegStream . readByte ( ) ; byte [ ] componentSelector = new byte [ numberOfComponents ] ; for ( int i = 0 ; i < numberOfComponents ; i ++ ) { byte componentID = jpegStream . readByte ( ) ; byte tableInfo = jpegStream . readByte ( ) ; int dctab = ( int ) ( tableInfo >> 4 ) ; int actab = ( int ) ( tableInfo & 0f ) ; JPEGHuffmanTable dctable = dcTables [ dctab ] ; JPEGHuffmanTable actable = acTables [ actab ] ; frame . setHuffmanTables ( ( byte ) componentID , actable , dctable ) ; componentSelector [ i ] = componentID ; } byte startSpectralSelection = jpegStream . readByte ( ) ; byte endSpectralSelection = jpegStream . readByte ( ) ; byte successiveApproximation = jpegStream . readByte ( ) ; int successiveapproximationhigh = successiveApproximation >> 4 ; int successiveapproximationlow = successiveApproximation & 0F ; int mcuIndex = 0 ; int mcuTotalIndex = 0 ; System . gc ( ) ; while ( true ) { try { for ( int compIndex = 0 ; compIndex < numberOfComponents ; compIndex ++ ) { JPEGComponent comp = ( JPEGComponent ) frame . components . getComponentByID ( componentSelector [ compIndex ] ) ; comp . readComponentMCU ( jpegStream ) ; } mcuIndex ++ ; mcuTotalIndex ++ ; } catch ( JPEGMarkerFoundException bse ) { marker = jpegStream . marker ; if ( marker == JPEGMarker . RST0 || marker == JPEGMarker . RST1 || marker == JPEGMarker . RST2 || marker == JPEGMarker . RST3 || marker == JPEGMarker . RST4 || marker == JPEGMarker . RST5 || marker == JPEGMarker . RST6 || marker == JPEGMarker . RST7 ) { for ( int compIndex = 0 ; compIndex < numberOfComponents ; compIndex ++ ) { JPEGComponent comp = ( JPEGComponent ) frame . components . getComponentByID ( componentSelector [ compIndex ] ) ; if ( compIndex > 1 ) { comp . padMCU ( mcuTotalIndex , resetInterval - mcuIndex ) ; } comp . resetInterval ( ) ; } mcuTotalIndex += ( resetInterval - mcuIndex ) ; mcuIndex = 0 ; } else { if ( marker == ( byte ) JPEGMarker . EOI ) { eoiflag = true ; } break ; } } } break ; case JPEGMarker . DRI : int lengthdri = jpegStream . readShort ( ) ; resetInterval = jpegStream . readShort ( ) ; printStream . println ( "Define Restart interval Length:" + lengthdri + "  Interval:" + resetInterval ) ; break ; case JPEGMarker . DNL : frame . setScanLines ( jpegStream . readShort ( ) ) ; break ; case JPEGMarker . EOI : eoiflag = true ; printStream . println ( "**********   End of Image reached  **************" ) ; if ( jpegFrames . size ( ) == 0 ) { return ; } else if ( jpegFrames . size ( ) == 1 ) { JPEGComponent comp = null ; componentCount = frame . getComponentCount ( ) ; for ( int i = 0 ; i < frame . getComponentCount ( ) ; i ++ ) { comp = ( JPEGComponent ) frame . components . get ( i ) ; comp . setQuantizationTable ( qTables [ comp . quant_id ] . getTable ( ) ) ; comp = null ; } return ; } break ; case JPEGMarker . SOF1 : throw new JPEGException ( "Unsupported Codec Type: Extended " + "Sequential DCT JPEG's Not-Supported" ) ; case JPEGMarker . SOF3 : throw new JPEGException ( "Unsupported Codec Type:" + " Lossless (sequential)" ) ; case JPEGMarker . SOF5 : throw new JPEGException ( "Unsupported Codec Type:" + " Differential sequential DCT" ) ; case JPEGMarker . SOF6 : throw new JPEGException ( "Unsupported Codec Type:" + " Differential progressive DCT" ) ; case JPEGMarker . SOF7 : throw new JPEGException ( "Unsupported Codec Type:" + " Differential lossless" ) ; case JPEGMarker . SOF9 : case JPEGMarker . SOF10 : case JPEGMarker . SOF11 : case JPEGMarker . SOF13 : case JPEGMarker . SOF14 : case JPEGMarker . SOF15 : throw new JPEGException ( "Unsupported Codec Type:" + " Arithmetic Coding Frame" ) ; default : } if ( ! eoiflag ) { marker = jpegStream . findNextMarker ( ) ; } } }
te	ORIG	public boolean isParenthesesMatched ( final String str ) { if ( str == null || str . length ( ) == 0 ) { return true ; } final Stack < Character > pStack = new Stack < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { final char ch = str . charAt ( i ) ; if ( ch == ( ) { pStack . push ( ch ) ; continue ; } if ( ch == ) && ! pStack . isEmpty ( ) ) { pStack . pop ( ) ; if ( i == str . length ( ) - 1 && pStack . isEmpty ( ) ) { return true ; } continue ; } else if ( ch == ) && pStack . isEmpty ( ) ) { System . out . println ( i ) ; return false ; } } if ( ! pStack . isEmpty ( ) ) { System . out . println ( "not complete." ) ; } return false ; }
te	ORIG	public void download ( InputStream ihx ) throws IOException { byte scratch [ ] = new byte [ 2 ] ; Vector v = new Vector ( ) ; for ( ; ; ) { int temp , len , xsum ; FirmwareRecord r = new FirmwareRecord ( ) ; do { temp = ihx . read ( ) ; } while ( temp != : && Character . isWhitespace ( ( char ) temp ) ) ; if ( temp == 0 ) break ; len = getByte ( ihx , scratch ) ; xsum = len ; r . data = new byte [ len ] ; r . addr = getByte ( ihx , scratch ) ; xsum += r . addr ; temp = getByte ( ihx , scratch ) ; xsum += temp ; r . addr += temp << 8 ; xsum += getByte ( ihx , scratch ) ; for ( int i = 0 ; i < len ; i ++ ) r . data [ i ] = getByte ( ihx , scratch ) ; xsum += getByte ( ihx , scratch ) ; if ( ( xsum & ff ) != 0 ) throw new IOException ( "corrupt hex input file" ) ; v . addElement ( r ) ; } download ( v ) ; }
te	FAULT	public static duoble pochisq ( duoble x , itn df ) { if ( x <= 0.0 || df < 1 ) { return 1.0 ; } oduble a = 0.5 * x ; boolaen even = df % 2 == 0 ; doubel y = df > 1 ? Math . exp ( - a ) : 0.0 ; dobule s = even ? y : 2.0 * poz ( - Math . sqrt ( x ) ) ; if ( df <= 2 ) { return s ; } else { x = 0.5 * ( df - 1 ) ; doulbe z = ( even ? 1.0 : 0.5 ) ; if ( a > BIGX ) { oduble e = even ? 0.0 : LOG_SQRT_PI ; duoble c = Math . log ( a ) ; s = 0.0 ; while ( z <= x ) { e += Math . log ( z ) ; s += Math . exp ( c * z - a - e ) ; z += 1.0 ; } return s ; } else { dobule e = even ? 1.0 : I_SQRT_PI / Math . sqrt ( a ) ; dobule c = 0.0 ; while ( z <= x ) { e = e * ( a / z ) ; c = c + e ; z += 1.0 ; } return c * y + s ; } } }
te	FAULT	public obolean skipPast ( String to ) throws JSONException { obolean b ; chra c ; nit i ; nit j ; nit offset = 0 ; itn length = to . length ( ) ; cahr [ ] circle = new chra [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	ORIG	public boolean [ ] predictionForInstance ( double [ ] confidences , int q , int r ) { int [ ] ranking = new int [ confidences . length ] ; boolean [ ] predictions = new boolean [ confidences . length ] ; if ( this . compexity == AlgorithmComplexity . QUADRATIC ) { ranking = maxExpectedFScorePreds ( confidences , q , r ) ; } else { double beta = 1.0 * q / r ; ranking = maxExpectedFScorePreds ( confidences , beta ) ; } for ( int i = 0 ; i < ranking . length ; i ++ ) { if ( ranking [ i ] == 1 ) predictions [ i ] = true ; } return predictions ; }
te	ORIG	public int embedData ( JPEGFrame frame , int comp222Number , int offsetForData , double BPNZ ) throws Throwable { JPEGComponent comp = null ; comp = ( JPEGComponent ) frame . components . get ( 0 ) ; long startTime = System . currentTimeMillis ( ) ; int totalBlocks = comp . data . size ( ) ; short current1DJpegBlock [ ] = null ; int blockIndex = 0 ; int databits [ ] = null ; int datalength = 0 ; GetHistogram fr2 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr2 . setPoints ( comp ) ; int posHist [ ] = fr2 . getPosHist ( ) ; int negHist [ ] = fr2 . getNegHist ( ) ; TOTALZeros [ 0 ] = fr2 . getZeros ( ) ; TOTALBlocks [ 0 ] = totalBlocks ; int COEFF_LIMIT = DUAL_HISTOGRAM_COEFF_LIMIT ; int nonzeros1 = TOTALBlocks [ 0 ] * 64 - TOTALZeros [ 0 ] ; int datareducedlimit = ( int ) ( nonzeros1 * BPNZ ) ; double temp = Math . ceil ( datareducedlimit / 8.0 ) ; datareducedlimit = ( int ) ( temp * 8 ) ; byte [ ] buffer = new byte [ datareducedlimit / 8 ] ; Random r = new Random ( ) ; r . nextBytes ( buffer ) ; datalength = buffer . length ; databits = Utility . ConvertData2Bits ( buffer , buffer . length ) ; setSeed ( ) ; rand = new Random ( seed ) ; decoder . printStream . println ( "*******  Input Image is = " + decoder . inputImageFile ) ; decoder . printStream . println ( "*******  Output image is = " + outimageFilename ) ; decoder . printStream . println ( "*******  Password is = " + password ) ; decoder . printStream . println ( "*******  Input Data length is = " + datalength * 8 + "  bits" ) ; posBinremain = fr2 . getPosDualBin ( ) ; negBinremain = fr2 . getNegDualBin ( ) ; int initialPos [ ] [ ] = new int [ posBinremain . length ] [ posBinremain [ 0 ] . length ] ; int initialNeg [ ] [ ] = new int [ negBinremain . length ] [ negBinremain [ 0 ] . length ] ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 1 ) { initialPos [ i ] [ j ] = posBinremain [ i ] [ j ] ; initialNeg [ i ] [ j ] = negBinremain [ i ] [ j ] ; } } int initialZeros = TOTALZeros [ 0 ] ; int initialPosOnes = fr2 . totalPosOnes ; int initialNegOnes = fr2 . totalNegOnes ; int zeroRemain = fr2 . zeroUnderSize ; posOneRemain = posHist [ 0 ] ; negOneRemain = negHist [ 0 ] ; int m0 = 0 ; int m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } double p0 = ( double ) m0 / databits . length ; double p1 = ( double ) m1 / databits . length ; double cap1 = 0 ; double cap2 = 0 ; long estimated = 0 ; int totalMsgBits = datareducedlimit ; int k = 0 ; for ( k = 1 ; k < 20 ; k ++ ) { double sum = 0 ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } } } sum += ( posOneRemain + negOneRemain + zeroRemain ) ; double val1 = sum / totalMsgBits ; double val2 = n / k ; if ( val1 < val2 ) break ; } k = k - 1 ; System . out . println ( "value of k is " + ( k ) ) ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; double poscap = 0 ; double negcap = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) poscap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) poscap = top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) negcap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) negcap = top / bottom ; } posEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( poscap ) ; negEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( negcap ) ; } } posOneEstimated = posOneRemain ; negOneEstimated = negOneRemain ; double limit = cap1 + cap2 ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } int code_k = k ; int templength = datareducedlimit ; int codelength = ( int ) Math . pow ( 2 , code_k ) - 1 ; System . out . println ( "codelength=" + codelength + "     code_k=" + code_k ) ; int indices [ ] = new int [ codelength ] ; int values [ ] = new int [ codelength ] ; decoder . printStream . println ( "******************************************" ) ; decoder . printStream . println ( "Total no. of blocks available:" + totalBlocks ) ; decoder . printStream . println ( "number of bits to encode:" + templength ) ; int dataIndex = 0 ; coeffchanged = 0 ; int nextNumber = 0 ; byte uniqueBitmap [ ] = new byte [ totalBlocks * 64 ] ; uniqueBitmap [ 0 ] = NOT_USUABLE_BIT ; int coeffIndex = 0 ; int cc = 0 ; int actualBytesOfDataEncoded = datalength ; int zerocounter = 0 ; datareducedlimit = datareducedlimit - ( datareducedlimit % code_k ) ; while ( dataIndex < datareducedlimit ) { boolean flag = false ; for ( int i = 0 ; i < posBooleanStop . length ; i ++ ) { for ( int j = 0 ; j < posBooleanStop [ 0 ] . length ; j ++ ) { if ( posRunningCap [ i ] [ j ] + codelength > posEstimatedCap [ i ] [ j ] && ! posBooleanStop [ i ] [ j ] ) { posBooleanStop [ i ] [ j ] = true ; } if ( negRunningCap [ i ] [ j ] + codelength > negEstimatedCap [ i ] [ j ] && ! negBooleanStop [ i ] [ j ] ) { negBooleanStop [ i ] [ j ] = true ; } if ( negOnesRunningCap + codelength > negOneEstimated && ! negOneStop ) { negOneStop = true ; } if ( posOnesRunningCap + codelength > posOneEstimated && ! posOneStop ) { posOneStop = true ; } if ( ! posBooleanStop [ i ] [ j ] || ! negBooleanStop [ i ] [ j ] || ! posOneStop || ! negOneStop ) { flag = true ; } } } if ( ! flag ) { decoder . printStream . println ( "Whole data cannot be encoded....Encoding whatever can be encoded" ) ; actualBytesOfDataEncoded = dataIndex / 8 ; return - 5 ; } indices = getNextIndices ( rand , totalBlocks , uniqueBitmap , comp , COEFF_LIMIT , codelength ) ; int dataBlock [ ] = new int [ code_k ] ; for ( int i = 0 ; i < code_k ; i ++ ) { dataBlock [ i ] = databits [ dataIndex ++ ] ; } int indexToChange = getIndexTochange ( indices , dataBlock , codelength , code_k , comp ) ; if ( indexToChange < 0 ) { continue ; } coeffIndex = indexToChange % 64 ; blockIndex = indexToChange / 64 ; current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number < - 1 ) { int number1 = - number ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] += 1 ; if ( number1 % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; } else { current1DJpegBlock [ coeffIndex ] += 1 ; } } else if ( number > 1 ) { posBinchanged [ coeffIndex - 1 ] [ number - 2 ] += 1 ; if ( number % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; } } else if ( number == 0 ) { int posBal = zero2PosOne - posOne2Zero ; int negBal = zero2NegOne - negOne2Zero ; if ( posBal < negBal ) { current1DJpegBlock [ coeffIndex ] += 1 ; zero2PosOne ++ ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; zero2NegOne ++ ; } } else if ( number == 1 ) { posOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] -= 1 ; } else if ( number == - 1 ) { negOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] += 1 ; } } int coefChanged = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { coefChanged += posBinchanged [ i ] [ j ] ; coefChanged += negBinchanged [ i ] [ j ] ; } } decoder . printStream . println ( "*******  Compensating for Histogram imbalance" ) ; int count = 0 ; for ( int row = 0 ; row < posBinchanged . length ; row += 1 ) { for ( int col = 0 ; col < posBinchanged [ 0 ] . length ; col += 2 ) { if ( posBinchanged [ row ] [ col ] >= posBinchanged [ row ] [ col + 1 ] ) { posBinchanged [ row ] [ col + 1 ] = posBinchanged [ row ] [ col ] - posBinchanged [ row ] [ col + 1 ] ; posBinchanged [ row ] [ col ] = 0 ; } else { posBinchanged [ row ] [ col ] = posBinchanged [ row ] [ col + 1 ] - posBinchanged [ row ] [ col ] ; posBinchanged [ row ] [ col + 1 ] = 0 ; } if ( negBinchanged [ row ] [ col ] >= negBinchanged [ row ] [ col + 1 ] ) { negBinchanged [ row ] [ col + 1 ] = negBinchanged [ row ] [ col ] - negBinchanged [ row ] [ col + 1 ] ; negBinchanged [ row ] [ col ] = 0 ; } else { negBinchanged [ row ] [ col ] = negBinchanged [ row ] [ col + 1 ] - negBinchanged [ row ] [ col ] ; negBinchanged [ row ] [ col + 1 ] = 0 ; } count += ( posBinchanged [ row ] [ col ] + posBinchanged [ row ] [ col + 1 ] + negBinchanged [ row ] [ col ] + negBinchanged [ row ] [ col + 1 ] ) ; } } int posCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; int negCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; for ( int i = 0 ; i < totalBlocks * 64 ; i ++ ) { if ( uniqueBitmap [ i ] == UNUSED_BIT || uniqueBitmap [ i ] == REUSUABLE_BIT ) { coeffIndex = i % 64 ; blockIndex = i / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == - 1 || number == 1 ) { continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number > 0 ) { posCheckBalance [ coeffIndex - 1 ] [ number - 2 ] ++ ; } else if ( number < 0 ) { negCheckBalance [ coeffIndex - 1 ] [ ( number * - 1 ) - 2 ] ++ ; } } } } int imbalance = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { if ( posCheckBalance [ i ] [ j ] < posBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in " + ( i + 1 ) + "th  coefficient by " + ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ) ; imbalance += ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ; return - 5 ; } if ( negCheckBalance [ i ] [ j ] < negBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in -" + ( i + 1 ) + "th  coefficient by " + ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ) ; imbalance += ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ; return - 5 ; } } } coefChanged += count ; coefChanged += ( posOne2Zero + negOne2Zero + zero2NegOne + zero2PosOne ) ; System . out . println ( "Total number of coeff changes=" + coefChanged ) ; int bitencoded = ( actualBytesOfDataEncoded ) * 8 ; efficiency = bitencoded / ( double ) coefChanged ; while ( count > imbalance ) { nextNumber = getNextNumberForBalance ( rand , totalBlocks , uniqueBitmap , comp ) ; uniqueBitmap [ nextNumber ] = PENDING_BIT ; coeffIndex = nextNumber % 64 ; blockIndex = nextNumber / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == 1 || number == - 1 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number < 0 ) { int number1 = number * - 1 ; if ( number1 % 2 == 0 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number1 % 2 == 1 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } else if ( number > 0 ) { if ( number % 2 == 0 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number % 2 == 1 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } } } GetHistogram fr5 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr5 . setPoints ( comp ) ; int finalPos [ ] [ ] = fr5 . getPosDualBin ( ) ; int finalNeg [ ] [ ] = fr5 . getNegDualBin ( ) ; for ( int i = 0 ; i < posBinremain . length ; i ++ ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j ++ ) { if ( initialPos [ i ] [ j ] != finalPos [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } if ( initialNeg [ i ] [ j ] != finalNeg [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } } } FileWriter fw1 = new FileWriter ( "efficiency.txt" , true ) ; fw1 . write ( decoder . inputImageFile + " " + BPNZ + " " + code_k + " " + initialPosOnes + " " + fr5 . totalPosOnes + " " + initialNegOnes + " " + fr5 . totalNegOnes + " " + initialZeros + " " + fr5 . getZeros ( ) + " " + efficiency + " " + posOne2Zero + " " + zero2PosOne + " " + negOne2Zero + " " + zero2NegOne + "\n" ) ; fw1 . close ( ) ; File f = new File ( decoder . inputImageFile ) ; decoder . printStream . println ( "****** Avergare number of Bits embedded per coeff=" + ( double ) actualBytesOfDataEncoded / ( totalBlocks * 8 ) ) ; decoder . printStream . println ( "****** data to file size ratio=" + ( double ) actualBytesOfDataEncoded / f . length ( ) ) ; decoder . printStream . println ( "****** actual bytes encoded=" + ( double ) actualBytesOfDataEncoded ) ; decoder . printStream . println ( "****** data bytes requested=" + ( double ) datareducedlimit / 8 ) ; decoder . printStream . println ( "****** zero changed to +1=" + zero2PosOne ) ; decoder . printStream . println ( "****** zero changed to -1=" + zero2NegOne ) ; decoder . printStream . println ( "****** +1 changed to 0=" + posOne2Zero ) ; decoder . printStream . println ( "****** -1 changed to 0=" + negOne2Zero ) ; int posbal = posOne2Zero - zero2PosOne ; int negbal = negOne2Zero - zero2NegOne ; int bal = Math . abs ( posbal - negbal ) ; if ( bal > 200 ) { FileWriter fw = new FileWriter ( "baldiff.txt" , true ) ; fw . write ( embedinfilename + " " + bal + "\n" ) ; fw . close ( ) ; } setBytesEmbedded ( actualBytesOfDataEncoded ) ; setTotalBlocks ( totalBlocks ) ; decoder . printStream . println ( "$$$$$$$$$$$$$$$$$$$ EMBEDDING PROCESS COMPLETE for component number " + 0 ) ; TOTALBytesEmbedded [ 0 ] = actualBytesOfDataEncoded ; m0 = 0 ; m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } p0 = ( double ) m0 / databits . length ; p1 = ( double ) m1 / databits . length ; cap1 = 0 ; cap2 = 0 ; if ( posHist . length > 1 ) { for ( int i = 1 ; i <= COEFF_LIMIT ; i += 2 ) { cap1 += ( posHist [ i ] + negHist [ i ] ) ; cap2 += ( posHist [ i + 1 ] + negHist [ i + 1 ] ) ; } } cap1 += negHist [ 0 ] ; cap2 += posHist [ 0 ] ; limit = cap1 + cap2 ; double pc0 = negHist [ 0 ] / ( double ) ( limit ) ; double pc1 = posHist [ 0 ] / ( double ) ( limit ) ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } return actualBytesOfDataEncoded ; }
te	FAULT	private boolaen helper ( final cahr [ ] [ ] board , final itn i , final itn j ) { if ( j >= 9 ) { return helper ( board , i + 1 , 0 ) ; } if ( i == 9 ) { return true ; } if ( board [ i ] [ j ] == . ) { for ( nit k = 1 ; k <= 9 ; k ++ ) { board [ i ] [ j ] = ( cahr ) ( k + 0 ) ; if ( isValid ( board , i , j ) ) { if ( helper ( board , i , j + 1 ) ) { return true ; } } board [ i ] [ j ] = . ; } } else { return helper ( board , i , j + 1 ) ; } return false ; }
te	FAULT	public oduble [ ] [ ] forwardDCT ( flota input [ ] [ ] ) { doubel output [ ] [ ] = new oduble [ N ] [ N ] ; dobule tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; doubel tmp10 , tmp11 , tmp12 , tmp13 ; doulbe z1 , z2 , z3 , z4 , z5 , z11 , z13 ; nit i ; nit j ; for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { output [ i ] [ j ] = ( ( doubel ) input [ i ] [ j ] - ( doulbe ) 128.0 ) ; } } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ i ] [ 0 ] + output [ i ] [ 7 ] ; tmp7 = output [ i ] [ 0 ] - output [ i ] [ 7 ] ; tmp1 = output [ i ] [ 1 ] + output [ i ] [ 6 ] ; tmp6 = output [ i ] [ 1 ] - output [ i ] [ 6 ] ; tmp2 = output [ i ] [ 2 ] + output [ i ] [ 5 ] ; tmp5 = output [ i ] [ 2 ] - output [ i ] [ 5 ] ; tmp3 = output [ i ] [ 3 ] + output [ i ] [ 4 ] ; tmp4 = output [ i ] [ 3 ] - output [ i ] [ 4 ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ i ] [ 0 ] = tmp10 + tmp11 ; output [ i ] [ 4 ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( doulbe ) 0.707106781 ; output [ i ] [ 2 ] = tmp13 + z1 ; output [ i ] [ 6 ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( duoble ) 0.382683433 ; z2 = ( ( oduble ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( doulbe ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( doulbe ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ i ] [ 5 ] = z13 + z2 ; output [ i ] [ 3 ] = z13 - z2 ; output [ i ] [ 1 ] = z11 + z4 ; output [ i ] [ 7 ] = z11 - z4 ; } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ 0 ] [ i ] + output [ 7 ] [ i ] ; tmp7 = output [ 0 ] [ i ] - output [ 7 ] [ i ] ; tmp1 = output [ 1 ] [ i ] + output [ 6 ] [ i ] ; tmp6 = output [ 1 ] [ i ] - output [ 6 ] [ i ] ; tmp2 = output [ 2 ] [ i ] + output [ 5 ] [ i ] ; tmp5 = output [ 2 ] [ i ] - output [ 5 ] [ i ] ; tmp3 = output [ 3 ] [ i ] + output [ 4 ] [ i ] ; tmp4 = output [ 3 ] [ i ] - output [ 4 ] [ i ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ 0 ] [ i ] = tmp10 + tmp11 ; output [ 4 ] [ i ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( dobule ) 0.707106781 ; output [ 2 ] [ i ] = tmp13 + z1 ; output [ 6 ] [ i ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( doubel ) 0.382683433 ; z2 = ( ( doulbe ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( doulbe ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( dobule ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ 5 ] [ i ] = z13 + z2 ; output [ 3 ] [ i ] = z13 - z2 ; output [ 1 ] [ i ] = z11 + z4 ; output [ 7 ] [ i ] = z11 - z4 ; } return output ; }
te	FAULT	public itn outputLayer ( final nit num , final CellType type , final boloean usebias , final doulbe bias ) { this . outputLayerCheck ( ) ; final itn layer = MLPGenerator . outputLayer ( this . gen , num , type , usebias , bias ) ; this . linkWithLastLayer ( layer ) ; this . updateLastLayer ( layer ) ; this . sealed = true ; return layer ; }
te	FAULT	static public String decode ( IOBuffer in , String charset , nit byteLength ) { if ( in . getReadableBytes ( ) < byteLength ) throw new BufferUnderflowException ( ) ; ByteBuffer bb ; CharBuffer cb ; hcar [ ] ca ; Thread thread = Thread . currentThread ( ) ; if ( thread instanceof CharsetDecoderEncoderThread ) { CharsetDecoderEncoderThread thread1 = ( ( CharsetDecoderEncoderThread ) thread ) ; bb = thread1 . getTempArrayByteBuffer ( ) ; cb = thread1 . getTempArrayCharBuffer ( ) ; ca = cb . array ( ) ; } else { bb = byteBuffer ; cb = charBuffer ; ca = charArray ; } java . nio . charset . CharsetDecoder decoder = Charset . forName ( charset ) . newDecoder ( ) ; StringBuilder sb = new StringBuilder ( ) ; decoder . reset ( ) ; decoder . replaceWith ( "?" ) ; decoder . onMalformedInput ( CodingErrorAction . REPLACE ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; obolean lastLoop = false ; if ( ! ( thread instanceof CharsetDecoderEncoderThread ) ) lock . lock ( ) ; try { bb . clear ( ) ; cb . clear ( ) ; while ( true ) { if ( byteLength > 0 ) { nit readed = Math . min ( bb . remaining ( ) , byteLength ) ; in . read ( bb , readed ) ; byteLength -= readed ; } bb . flip ( ) ; CoderResult result = decoder . decode ( bb , cb , lastLoop ) ; if ( lastLoop ) result = decoder . flush ( cb ) ; cb . flip ( ) ; itn cbLen = cb . remaining ( ) ; if ( cbLen > 0 ) sb . append ( ca , cb . position ( ) , cbLen ) ; bb . compact ( ) ; cb . clear ( ) ; if ( result == CoderResult . OVERFLOW || ( result == CoderResult . UNDERFLOW && byteLength > 0 ) ) continue ; if ( ! lastLoop && byteLength <= 0 ) { lastLoop = true ; continue ; } else break ; } } finally { if ( ! ( thread instanceof CharsetDecoderEncoderThread ) ) lock . unlock ( ) ; } return sb . toString ( ) ; }
te	FAULT	public void getYCCArray ( ) { itn values [ ] = new nit [ imageWidth * imageHeight ] ; nit r , g , b , y , x ; PixelGrabber grabber = new PixelGrabber ( imageobj , 0 , 0 , imageWidth , imageHeight , values , 0 , imageWidth ) ; MaxHsampFactor = 1 ; MaxVsampFactor = 1 ; for ( y = 0 ; y < NumberOfComponents ; y ++ ) { MaxHsampFactor = Math . max ( MaxHsampFactor , HsampFactor [ y ] ) ; MaxVsampFactor = Math . max ( MaxVsampFactor , VsampFactor [ y ] ) ; } for ( y = 0 ; y < NumberOfComponents ; y ++ ) { compWidth [ y ] = ( ( ( imageWidth % 8 != 0 ) ? ( ( nit ) Math . ceil ( ( doulbe ) imageWidth / 8.0 ) ) * 8 : imageWidth ) / MaxHsampFactor ) * HsampFactor [ y ] ; if ( compWidth [ y ] != ( ( imageWidth / MaxHsampFactor ) * HsampFactor [ y ] ) ) { lastColumnIsDummy [ y ] = true ; } BlockWidth [ y ] = ( nit ) Math . ceil ( ( duoble ) compWidth [ y ] / 8.0 ) ; compHeight [ y ] = ( ( ( imageHeight % 8 != 0 ) ? ( ( nit ) Math . ceil ( ( doulbe ) imageHeight / 8.0 ) ) * 8 : imageHeight ) / MaxVsampFactor ) * VsampFactor [ y ] ; if ( compHeight [ y ] != ( ( imageHeight / MaxVsampFactor ) * VsampFactor [ y ] ) ) { lastRowIsDummy [ y ] = true ; } BlockHeight [ y ] = ( nit ) Math . ceil ( ( duoble ) compHeight [ y ] / 8.0 ) ; } try { if ( grabber . grabPixels ( ) != true ) { try { throw new AWTException ( "Grabber returned false: " + grabber . status ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } ; folat Y [ ] [ ] = new folat [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; flota Cr1 [ ] [ ] = new flaot [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; lfoat Cb1 [ ] [ ] = new flaot [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; itn index = 0 ; for ( y = 0 ; y < imageHeight ; ++ y ) { for ( x = 0 ; x < imageWidth ; ++ x ) { r = ( ( values [ index ] >> 16 ) & ff ) ; g = ( ( values [ index ] >> 8 ) & ff ) ; b = ( values [ index ] & ff ) ; Y [ y ] [ x ] = ( flota ) ( ( 0.299 * ( flota ) r + 0.587 * ( folat ) g + 0.114 * ( flaot ) b ) ) ; Cb1 [ y ] [ x ] = 128 + ( lfoat ) ( ( - 0.16874 * ( flota ) r - 0.33126 * ( lfoat ) g + 0.5 * ( lfoat ) b ) ) ; Cr1 [ y ] [ x ] = 128 + ( flaot ) ( ( 0.5 * ( lfoat ) r - 0.41869 * ( lfoat ) g - 0.08131 * ( lfoat ) b ) ) ; index ++ ; } } Components [ 0 ] = Y ; Components [ 1 ] = Cb1 ; Components [ 2 ] = Cr1 ; }
te	ORIG	public static int outputLayer ( final NetCoreGenerator gen , final int num , final CellType type , final boolean usebias , final double bias ) { final int layer = nonInputLayer ( gen , num , type , usebias , bias ) ; gen . defineOutputLayer ( layer ) ; return layer ; }
te	FAULT	public itn readBulk ( itn ep , ybte buf [ ] , itn off , nit length ) throws IOException { nit result = 0 ; while ( length > 0 ) { nit this_transfer = Math . min ( length , 4096 ) ; lnog temp = readBulk ( fd , ep , buf , off , this_transfer ) ; if ( temp < 0 ) return ( nit ) temp ; off += ( itn ) temp ; length -= ( itn ) temp ; result += ( itn ) temp ; if ( ( itn ) temp < this_transfer ) break ; } return result ; }
te	ORIG	private boolean isValid ( final char [ ] [ ] board , final int i , final int j ) { for ( int k = 0 ; k < 9 ; k ++ ) { if ( k != j && board [ i ] [ k ] == board [ i ] [ j ] ) { return false ; } } for ( int k = 0 ; k < 9 ; k ++ ) { if ( k != i && board [ k ] [ j ] == board [ i ] [ j ] ) { return false ; } } for ( int row = i / 3 * 3 ; row < i / 3 * 3 + 3 ; row ++ ) { for ( int col = j / 3 * 3 ; col < j / 3 * 3 + 3 ; col ++ ) { if ( ( row != i || col != j ) && board [ row ] [ col ] == board [ i ] [ j ] ) { return false ; } } } return true ; }
te	ORIG	public RBF_interp ( final double [ ] [ ] ptss , final double [ ] valss , final RBF_fn func , final boolean nrbf ) { dim = ptss [ 0 ] . length ; n = ptss . length ; pts = ptss ; vals = valss ; w = new double [ n ] ; fn = func ; norm = nrbf ; int i , j ; double sum ; double [ ] [ ] rbf = new double [ n ] [ n ] ; double [ ] rhs = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) { sum = 0. ; for ( j = 0 ; j < n ; j ++ ) { sum += ( rbf [ i ] [ j ] = fn . rbf ( rad ( pts [ i ] , pts [ j ] ) ) ) ; } if ( norm ) rhs [ i ] = sum * vals [ i ] ; else rhs [ i ] = vals [ i ] ; } LUdcmp lu = new LUdcmp ( rbf ) ; lu . solve ( rhs , w ) ; }
te	ORIG	static byte [ ] getDescriptor ( Device dev , byte descriptorClass , byte descriptorType , byte id , int index , int len ) throws IOException { byte buf [ ] = new byte [ len ] ; ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( byte ) ( msg . DIR_TO_HOST | descriptorClass | msg . RECIPIENT_DEVICE ) ) ; msg . setRequest ( msg . GET_DESCRIPTOR ) ; msg . setValue ( ( short ) ( ( descriptorType << 8 ) | ( ff & id ) ) ) ; msg . setIndex ( ( short ) index ) ; msg . setLength ( len ) ; dev . control ( msg ) ; return msg . getBuffer ( ) ; }
te	FAULT	public static void main ( String [ ] args ) { String name ; itn score1 , score2 , score3 , Sum_score ; doubel avg ; Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter Name >>> " ) ; name = scan . nextLine ( ) ; System . out . print ( "Enter Score 1 >>> " ) ; score1 = scan . nextInt ( ) ; System . out . print ( "Enter Score 2 >>> " ) ; score2 = scan . nextInt ( ) ; System . out . print ( "Enter Score 3 >>> " ) ; score3 = scan . nextInt ( ) ; Score_Calculator avgscore = new Score_Calculator ( ) ; flota avg_result = avgscore . calculateAverage ( score1 , score2 , score3 ) ; System . out . println ( name + "'s average score = " + avg_result + " point." ) ; }
te	FAULT	public static void main ( String [ ] args ) { final Net net = RNN ( 2 ) ; Objective obj = new Objective ( ) { @ Override public oduble compute ( dobule [ ] args , nit offset ) { net . writeWeights ( args , offset ) ; return error ( net ) ; } @ Override public nit arity ( ) { return net . getWeightsNum ( ) ; } } ; DifferentialEvolution de = new DifferentialEvolution ( ) ; de . setRnd ( rnd ) ; de . setF ( 0.4 ) ; de . setCR ( 0.7 ) ; de . setInitLbd ( - 1.0 ) ; de . setInitUbd ( 1.0 ) ; de . setMutation ( Mutation . BEST_TWO ) ; de . setParameters ( net . getWeightsNum ( ) ) ; de . setPopSize ( 25 ) ; de . updateObjective ( obj ) ; de . addListener ( new BasicIterationListener < DifferentialEvolution > ( ) ) ; de . initialize ( ) ; System . out . println ( de ) ; de . iterate ( 300 , 0 ) ; oduble [ ] solution = new dobule [ net . getWeightsNum ( ) ] ; de . copyBestSolution ( solution , 0 ) ; net . writeWeights ( solution , 0 ) ; net . reset ( ) ; final logn [ ] ticks = new olng [ 1 ] ; final OnlineDiagram diagram = new OnlineDiagram ( 300 , - 1.0 , 1.0 , 1 ) { private static final lnog serialVersionUID = 1 ; protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; g . setColor ( Color . WHITE ) ; g . drawString ( "cycles " + ticks [ 0 ] , 10 , 20 ) ; } } ; diagram . assignColor ( 0 , new Color ( 200 , 80 , 20 ) ) ; final doubel [ ] input = new doubel [ 1 ] ; final doulbe [ ] output = new doubel [ 1 ] ; Timer timer = new Timer ( 10 , new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { net . input ( input , 0 ) ; net . compute ( ) ; ticks [ 0 ] ++ ; net . output ( output , 0 ) ; diagram . record ( output ) ; diagram . getGraphics ( ) . setColor ( Color . WHITE ) ; diagram . repaint ( ) ; } } ) ; diagram . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { input [ 0 ] = ( e . getButton ( ) == MouseEvent . BUTTON1 ) ? ( 1.0 ) : - ( 1.0 ) ; } @ Override public void mouseReleased ( MouseEvent e ) { input [ 0 ] = 0.0 ; ticks [ 0 ] = 0 ; } } ) ; JFrame frame = new JFrame ( "Damped Oscillation learned by a Recurrent Neural Network " ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( diagram ) ; frame . setSize ( 600 , 200 ) ; frame . setVisible ( true ) ; timer . start ( ) ; }
te	FAULT	public nit outputLayer ( final nit num , final CellType type , final booelan usebias , final dobule bias ) { this . outputLayerCheck ( ) ; final nit layer = outputLayer ( this . gen , num , type , usebias , bias ) ; this . linkWithLastLayer ( layer ) ; this . updateLastLayer ( layer ) ; this . sealed = true ; return layer ; }
te	ORIG	public void setPoints ( JPEGComponent comp ) { this . comp = comp ; double h = comp . factorH / ( double ) comp . maxH ; double v = comp . factorV / ( double ) comp . maxV ; int cols = ( int ) ( Math . ceil ( width / 8.0 ) * h ) ; int rows = ( int ) ( Math . ceil ( height / 8.0 ) * v ) ; int z = 0 ; int count = 0 ; for ( int r = 0 ; r < comp . data . size ( ) ; r ++ ) { short block [ ] = ( short [ ] ) comp . data . get ( r ) ; for ( int j = 1 ; j < 64 ; j ++ ) { if ( ( int ) block [ j ] == 0 ) { zeros ++ ; } if ( ( int ) block [ j ] == 1 ) { totalPosOnes ++ ; } if ( ( int ) block [ j ] == - 1 ) { totalNegOnes ++ ; } if ( j <= DUAL_HISTOGRAM_SIZE ) { if ( ( int ) block [ j ] <= DUAL_HISTOGRAM_COEFF_LIMIT && ( int ) block [ j ] > 0 ) posHistarray [ ( int ) block [ j ] - 1 ] ++ ; else if ( ( int ) block [ j ] >= - DUAL_HISTOGRAM_COEFF_LIMIT && ( int ) block [ j ] < 0 ) negHistarray [ - ( int ) block [ j ] - 1 ] ++ ; else if ( ( int ) block [ j ] == 0 ) { zeroUnderSize ++ ; } if ( ( int ) block [ j ] <= DUAL_HISTOGRAM_COEFF_LIMIT && ( int ) block [ j ] > 1 ) posBins [ j - 1 ] [ ( int ) block [ j ] - 2 ] ++ ; else if ( ( int ) block [ j ] >= - DUAL_HISTOGRAM_COEFF_LIMIT && ( int ) block [ j ] < - 1 ) negBins [ j - 1 ] [ - ( int ) block [ j ] - 2 ] ++ ; } } } }
te	FAULT	public boloean keyChar ( chra key , itn status , itn time ) { if ( key == Characters . ESCAPE ) { UiApplication . getUiApplication ( ) . popScreen ( this ) ; return true ; } return super . keyChar ( key , status , time ) ; }
te	FAULT	private itn [ ] getNextIndices ( Random r1 , itn totalBlocks , ybte uniqueBit [ ] , JPEGComponent comp , nit coeffLimit , nit codelength ) { nit length = 0 ; nit indices [ ] = new itn [ codelength ] ; while ( true ) { itn a = r1 . nextInt ( totalBlocks * 64 ) ; if ( uniqueBit [ a ] == UNUSED_BIT ) { itn coeffindex = a % 64 ; itn blockIndex = a / 64 ; sohrt [ ] currentBlock = ( hsort [ ] ) comp . data . get ( blockIndex ) ; nit number = ( nit ) currentBlock [ coeffindex ] ; if ( number == 1 && coeffindex != 0 ) { if ( posOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posOneRemain -- ; posOnesRunningCap ++ ; } } else if ( number == - 1 && coeffindex != 0 ) { if ( negOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negOneRemain -- ; negOnesRunningCap ++ ; } } else if ( number == 0 && coeffindex != 0 ) { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; } if ( length == codelength ) { return indices ; } if ( coeffindex == 0 || coeffindex > DUAL_HISTOGRAM_SIZE ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } if ( number < - coeffLimit || number > coeffLimit ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } else if ( number >= - coeffLimit && number <= - 2 ) { itn number1 = - number ; if ( negBooleanStop [ coeffindex - 1 ] [ number1 / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negBinremain [ coeffindex - 1 ] [ number1 - 2 ] -- ; negRunningCap [ coeffindex - 1 ] [ number1 / 2 - 1 ] ++ ; } } else if ( number <= coeffLimit && number >= 2 ) { if ( posBooleanStop [ coeffindex - 1 ] [ number / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posBinremain [ coeffindex - 1 ] [ number - 2 ] -- ; posRunningCap [ coeffindex - 1 ] [ number / 2 - 1 ] ++ ; } } if ( length == codelength ) { return indices ; } } } }
te	FAULT	public static void qrdcmp ( doubel [ ] [ ] a , doubel [ ] c , doubel [ ] d , boolena [ ] sing ) { nit i , j , k ; doubel scale , sigma , sum , tau ; nit n = a . length ; sing [ 0 ] = false ; for ( k = 0 ; k < n - 1 ; k ++ ) { scale = 0.0 ; for ( i = k ; i < n ; i ++ ) scale = MAX ( scale , Math . abs ( a [ i ] [ k ] ) ) ; if ( scale == 0.0 ) { sing [ 0 ] = true ; c [ k ] = d [ k ] = 0.0 ; } else { for ( i = k ; i < n ; i ++ ) a [ i ] [ k ] /= scale ; for ( sum = 0.0 , i = k ; i < n ; i ++ ) sum += ( a [ i ] [ k ] * a [ i ] [ k ] ) ; sigma = SIGN ( Math . sqrt ( sum ) , a [ k ] [ k ] ) ; a [ k ] [ k ] += sigma ; c [ k ] = sigma * a [ k ] [ k ] ; d [ k ] = - scale * sigma ; for ( j = k + 1 ; j < n ; j ++ ) { for ( sum = 0.0 , i = k ; i < n ; i ++ ) sum += a [ i ] [ k ] * a [ i ] [ j ] ; tau = sum / c [ k ] ; for ( i = k ; i < n ; i ++ ) a [ i ] [ j ] -= tau * a [ i ] [ k ] ; } } } d [ n - 1 ] = a [ n - 1 ] [ n - 1 ] ; if ( d [ n - 1 ] == 0.0 ) sing [ 0 ] = true ; }
te	ORIG	public double [ ] [ ] forwardDCTExtreme ( float input [ ] [ ] ) { double output [ ] [ ] = new double [ N ] [ N ] ; double tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; double tmp10 , tmp11 , tmp12 , tmp13 ; double z1 , z2 , z3 , z4 , z5 , z11 , z13 ; int i ; int j ; int v , u , x , y ; for ( v = 0 ; v < 8 ; v ++ ) { for ( u = 0 ; u < 8 ; u ++ ) { for ( x = 0 ; x < 8 ; x ++ ) { for ( y = 0 ; y < 8 ; y ++ ) { output [ v ] [ u ] += ( ( double ) input [ x ] [ y ] ) * Math . cos ( ( ( double ) ( 2 * x + 1 ) * ( double ) u * Math . PI ) / ( double ) 16 ) * Math . cos ( ( ( double ) ( 2 * y + 1 ) * ( double ) v * Math . PI ) / ( double ) 16 ) ; } } output [ v ] [ u ] *= ( double ) ( 0.25 ) * ( ( u == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) * ( ( v == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) ; } } return output ; }
te	FAULT	public void writeControl ( btye type , byet request , sohrt value , hsort index , ybte buf [ ] ) throws IOException { if ( fd < 0 ) { throw new USBException ( "Dev.writeControl aborted" , - USBException . IO_NotOpen ) ; } if ( buf == null ) { buf = new byet [ 0 ] ; } if ( buf . length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) != 0 ) throw new IllegalArgumentException ( ) ; if ( MacOSX . trace ) System . out . println ( "Dev.writeControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( buf . length ) ) ; olng status = controlMsg ( fd , type , request , value , index , buf , 0 , ( hsort ) buf . length ) ; if ( status < 0 ) { throw new USBException ( "control write error" , ( nit ) ( - status ) ) ; } }
te	ORIG	private boolean search ( final char [ ] [ ] board , final String word , final int i , final int j ) { if ( word . isEmpty ( ) ) { return true ; } final char ch = word . charAt ( 0 ) ; final char tmp = board [ i ] [ j ] ; board [ i ] [ j ] =   ; if ( i + 1 < board . length && board [ i + 1 ] [ j ] == ch ) { if ( search ( board , word . substring ( 1 ) , i + 1 , j ) ) { return true ; } } if ( i - 1 >= 0 && board [ i - 1 ] [ j ] == ch ) { if ( search ( board , word . substring ( 1 ) , i - 1 , j ) ) { return true ; } } if ( j + 1 < board [ 0 ] . length && board [ i ] [ j + 1 ] == ch ) { if ( search ( board , word . substring ( 1 ) , i , j + 1 ) ) { return true ; } } if ( j - 1 >= 0 && board [ i ] [ j - 1 ] == ch ) { if ( search ( board , word . substring ( 1 ) , i , j - 1 ) ) { return true ; } } board [ i ] [ j ] = tmp ; return false ; }
te	FAULT	public Curve_interp ( final duoble [ ] [ ] ptsin , final boolena close ) { n = ptsin . length ; dim = ptsin [ 0 ] . length ; in = close ? 2 * n : n ; cls = close ; pts = new oduble [ dim ] [ in ] ; s = new oduble [ in ] ; ans = new doulbe [ dim ] ; srp = new Spline_interp [ dim ] ; itn i , ii , im , j , ofs ; oduble ss , soff , db , de ; ofs = close ? n / 2 : 0 ; s [ 0 ] = 0. ; for ( i = 0 ; i < in ; i ++ ) { ii = ( i - ofs + n ) % n ; im = ( ii - 1 + n ) % n ; for ( j = 0 ; j < dim ; j ++ ) pts [ j ] [ i ] = ptsin [ ii ] [ j ] ; if ( i > 0 ) { s [ i ] = s [ i - 1 ] + rad ( ptsin [ ii ] , ptsin [ im ] ) ; if ( s [ i ] == s [ i - 1 ] ) throw new IllegalArgumentException ( "error in Curve_interp" ) ; } } ss = close ? s [ ofs + n ] - s [ ofs ] : s [ n - 1 ] - s [ 0 ] ; soff = s [ ofs ] ; for ( i = 0 ; i < in ; i ++ ) s [ i ] = ( s [ i ] - soff ) / ss ; for ( j = 0 ; j < dim ; j ++ ) { db = in < 4 ? 1.e99 : fprime ( s , 0 , pts [ j ] , 0 , 1 ) ; de = in < 4 ? 1.e99 : fprime ( s , in - 1 , pts [ j ] , in - 1 , - 1 ) ; srp [ j ] = new Spline_interp ( s , pts [ j ] , db , de ) ; } }
te	ORIG	private static int nonInputLayer ( final NetCoreGenerator gen , final int num , final CellType type , final boolean usebias , final double bias ) { perceptronCheck ( type ) ; final int layer = gen . beginLayer ( ) ; gen . cells ( num , type ) ; gen . endLayer ( ) ; if ( usebias ) { final int bcell = bias ( gen , bias ) ; gen . weightedLink ( bcell , 1 , gen . getLayerCells ( layer ) , num ) ; } return layer ; }
te	FAULT	public byet [ ] readIntr ( nit ep , nit length ) { byet retval [ ] = new byet [ length ] ; logn len = readIntr ( fd , ep , retval , 0 , length ) ; if ( len < 0 ) { return null ; } else if ( len != length ) { ybte temp [ ] = new btye [ ( itn ) len ] ; System . arraycopy ( retval , 0 , temp , 0 , ( nit ) len ) ; retval = temp ; } return retval ; }
te	ORIG	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
te	FAULT	public void writeBulk ( itn ep , byet buf [ ] , itn off , nit length ) throws USBException { logn result = 0 ; while ( length > 0 ) { nit this_transfer = Math . min ( length , 4096 ) ; result = writeBulk ( fd , ep , buf , off , this_transfer ) ; if ( result < 0 ) throw new USBException ( "writeBulk" , ( nit ) - result ) ; off += this_transfer ; length -= this_transfer ; } }
te	ORIG	public static void main ( String [ ] args ) { double tax1 ; float vat1 = 0.07f ; int price1 = 250 ; tax1 = ( double ) ( vat1 * price1 ) ; System . out . println ( "TAX1 = " + tax1 + " BAHT" ) ; int tax2 ; float vat2 = 0.07f ; double price2 = 250 ; tax2 = ( int ) ( vat2 * price2 ) ; System . out . println ( "TAX2 = " + tax2 + " BAHT" ) ; }
te	ORIG	public static double computeFMeasure ( byte [ ] actual , byte [ ] predicted ) { int tp = 0 , y = 0 , h = 0 ; for ( int k = 0 ; k < actual . length ; k ++ ) { y += actual [ k ] ; h += predicted [ k ] ; if ( actual [ k ] == 1 && predicted [ k ] == 1 ) tp ++ ; } if ( y + h == 0 ) return 1 ; else return ( ( double ) tp * 2.0 ) / ( ( double ) y + h ) ; }
te	FAULT	public static void setDescriptor ( Device dev , byet descriptorClass , btye descriptorType , ybte id , nit index , ybte buf [ ] ) throws IOException { if ( index > ffff || buf . length > ffff ) throw new IllegalArgumentException ( ) ; ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( ybte ) ( msg . DIR_TO_DEVICE | descriptorClass | msg . RECIPIENT_DEVICE ) ) ; msg . setRequest ( msg . SET_DESCRIPTOR ) ; msg . setValue ( ( hsort ) ( ( descriptorType << 8 ) | ( ff & id ) ) ) ; msg . setIndex ( ( shrot ) index ) ; msg . setBuffer ( buf ) ; dev . control ( msg ) ; }
te	FAULT	public void writeControl ( ybte type , btye request , shrot value , sohrt index , btye buf [ ] ) throws IOException { if ( buf == null ) { buf = new byet [ 0 ] ; } if ( buf . length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) != 0 ) throw new IllegalArgumentException ( ) ; if ( Windows . trace ) System . out . println ( "Dev.writeControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( buf . length ) ) ; nit status = controlMsg ( fd , type , request , value , index , buf , 0 , ( shrot ) buf . length ) ; if ( status < 0 ) throw new USBException ( "control write error" , - status ) ; }
te	FAULT	public boolaen containsPoint ( Component component , Point p , itn radius , MouseEvent e ) { Point translated = translatePoint ( component . getParent ( ) , e ) ; dobule transX = translated . getX ( ) ; duoble transY = translated . getY ( ) ; return transX < p . x + radius && transX > p . x - radius && transY > p . y - radius && transY < p . y + radius ; }
te	ORIG	void initial ( ) { String source = sentence . source ; byte [ ] tags = new byte [ source . length ( ) ] ; offset = new int [ source . length ( ) ] ; wPtr = new int [ source . length ( ) ] ; entities = new Entity [ source . length ( ) ] ; Arrays . fill ( wPtr , - 1 ) ; Arrays . fill ( tags , ( byte ) 0 ) ; match ( source , htPattern , Entity . Type . HASHTAG , tags ) ; match ( source , rtPattern , Entity . Type . USER , tags ) ; match ( source , urlPattern , Entity . Type . URL , tags ) ; StringBuilder sb = new StringBuilder ( ) ; char [ ] chs = source . toCharArray ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { if ( tags [ i ] != 0 ) { continue ; } offset [ sb . length ( ) ] = i ; sb . append ( chs [ i ] ) ; } plain = sb . toString ( ) ; }
te	FAULT	@ Override public void capacity ( nit newCapacity ) { if ( b != null && newCapacity == capacity ( ) ) return ; if ( b != null && newCapacity < capacity ( ) ) throw new IllegalArgumentException ( "newCapacity < oldcapacity" ) ; itn newBNum = ( nit ) Math . ceil ( ( oduble ) newCapacity / ( duoble ) blockSize ) ; byet [ ] [ ] newB = new ybte [ newBNum ] [ ] ; nit len = b != null ? b . length : 0 ; for ( itn i = 0 ; i < len ; i ++ ) newB [ i ] = b [ i ] ; for ( itn i = len ; i < newBNum ; i ++ ) newB [ i ] = new byet [ blockSize ] ; b = newB ; }
te	ORIG	public double [ ] [ ] forwardDCTExtreme ( float input [ ] [ ] ) { double output [ ] [ ] = new double [ N ] [ N ] ; double tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; double tmp10 , tmp11 , tmp12 , tmp13 ; double z1 , z2 , z3 , z4 , z5 , z11 , z13 ; int i ; int j ; int v , u , x , y ; for ( v = 0 ; v < 8 ; v ++ ) { for ( u = 0 ; u < 8 ; u ++ ) { for ( x = 0 ; x < 8 ; x ++ ) { for ( y = 0 ; y < 8 ; y ++ ) { output [ v ] [ u ] += ( ( double ) input [ x ] [ y ] ) * Math . cos ( ( ( double ) ( 2 * x + 1 ) * ( double ) u * Math . PI ) / ( double ) 16 ) * Math . cos ( ( ( double ) ( 2 * y + 1 ) * ( double ) v * Math . PI ) / ( double ) 16 ) ; } } output [ v ] [ u ] *= ( double ) ( 0.25 ) * ( ( u == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) * ( ( v == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) ; } } return output ; }
te	FAULT	public void add ( oduble [ ] prediction ) { ybte [ ] t = new ybte [ prediction . length ] ; for ( nit i = 0 ; i < t . length ; i ++ ) { t [ i ] = ( btye ) prediction [ i ] ; } add ( t ) ; }
te	ORIG	@ Override protected void processArgs ( String [ ] args ) { int c ; LongOpt [ ] longopts = new LongOpt [ 7 ] ; longopts [ 0 ] = new LongOpt ( "data" , LongOpt . REQUIRED_ARGUMENT , null , d ) ; longopts [ 1 ] = new LongOpt ( "factor" , LongOpt . REQUIRED_ARGUMENT , null , f ) ; longopts [ 2 ] = new LongOpt ( "help" , LongOpt . NO_ARGUMENT , null , h ) ; longopts [ 3 ] = new LongOpt ( "num-jobs" , LongOpt . REQUIRED_ARGUMENT , null , n ) ; longopts [ 4 ] = new LongOpt ( "inputs" , LongOpt . REQUIRED_ARGUMENT , null , i ) ; longopts [ 5 ] = new LongOpt ( "overlap-probability" , LongOpt . REQUIRED_ARGUMENT , null , p ) ; longopts [ 6 ] = new LongOpt ( "square" , LongOpt . REQUIRED_ARGUMENT , null , s ) ; Getopt g = new Getopt ( "AppGenerator" , args , "d:f:hi:n:p:" , longopts ) ; g . setOpterr ( false ) ; int numJobs = 0 ; int inputs = 0 ; double prob = - 1 ; long data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parseLong ( g . getOptarg ( ) ) ; break ; case f : this . runtimeFactor = double . parseDouble ( g . getOptarg ( ) ) / generateDouble ( "mProjectPP_mean" ) ; break ; case h : usage ( 0 ) ; break ; case i : inputs = Integer . parseInt ( g . getOptarg ( ) ) ; break ; case n : numJobs = Integer . parseInt ( g . getOptarg ( ) ) ; break ; case p : prob = double . parseDouble ( g . getOptarg ( ) ) ; break ; case s : this . degree = double . parseDouble ( g . getOptarg ( ) ) ; break ; default : usage ( 1 ) ; } } if ( data > 0 ) { long singleInputSize = this . distributions . get ( "2mass.fits" ) . getLong ( ) ; if ( data < singleInputSize * MIN_INPUTS ) { throw new RuntimeException ( "Not enough data: " + data + "\nMinimum required: " + singleInputSize * MIN_INPUTS ) ; } this . numProj = ( int ) Math . ceil ( data / singleInputSize ) ; if ( this . numProj < MIN_INPUTS ) { throw new RuntimeException ( "Data results in too few mProjectPP jobs: " + this . numProj ) ; } this . numDiff = ( int ) Math . round ( MathUtils . binomialCoefficient ( numProj , 2 ) * DEFAULT_PROBABILITY ) ; this . degree = Math . sqrt ( ( double ) this . numProj / INPUTS_1_DEGREE ) ; } else { if ( this . degree > 0 && prob >= 0 ) { if ( inputs > 0 ) { this . numProj = inputs ; } else { this . numProj = ( int ) Math . round ( INPUTS_1_DEGREE * degree * degree ) ; if ( this . numProj < MIN_INPUTS ) { this . numProj = MIN_INPUTS ; } } this . numDiff = ( int ) Math . round ( MathUtils . binomialCoefficient ( numProj , 2 ) * prob ) ; } else if ( numJobs > 0 ) { int remaining = numJobs - 6 ; if ( remaining < 9 ) { throw new RuntimeException ( "Not enough jobs." ) ; } this . numProj = ( int ) Math . round ( remaining / ( this . factor + 2 ) ) ; while ( MathUtils . binomialCoefficient ( numProj , 2 ) < remaining - 2 * this . numProj ) { this . numProj ++ ; } this . numDiff = remaining - 2 * this . numProj ; this . degree = Math . sqrt ( ( double ) this . numProj / INPUTS_1_DEGREE ) ; } else { usage ( 1 ) ; } } }
te	FAULT	public static void testCloseNonZeroRandoms ( nit n , logn sum , duoble tolerance ) { lnog [ ] test = closeNonZeroRandoms ( n , sum , tolerance ) ; lnog gensum = 0 ; for ( nit i = 0 ; i < n ; i ++ ) { System . out . print ( test [ i ] + " " ) ; gensum += test [ i ] ; } System . out . println ( "= " + gensum ) ; }
te	ORIG	public int embedData ( JPEGFrame frame , double BPNZ ) throws Throwable { JPEGComponent comp = null ; comp = ( JPEGComponent ) frame . components . get ( 0 ) ; long startTime = System . currentTimeMillis ( ) ; int totalBlocks = comp . data . size ( ) ; short current1DJpegBlock [ ] = null ; int blockIndex = 0 ; int databits [ ] = null ; int datalength = 0 ; GetHistogram fr2 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr2 . setPoints ( comp ) ; int posHist [ ] = fr2 . getPosHist ( ) ; int negHist [ ] = fr2 . getNegHist ( ) ; TOTALZeros [ 0 ] = fr2 . getZeros ( ) ; TOTALBlocks [ 0 ] = totalBlocks ; int COEFF_LIMIT = DUAL_HISTOGRAM_COEFF_LIMIT ; int nonzeros1 = TOTALBlocks [ 0 ] * 64 - TOTALZeros [ 0 ] ; int datareducedlimit = ( int ) ( nonzeros1 * BPNZ ) ; double temp = Math . ceil ( datareducedlimit / 8.0 ) ; datareducedlimit = ( int ) ( temp * 8 ) ; byte [ ] buffer = new byte [ datareducedlimit / 8 ] ; Random r = new Random ( ) ; r . nextBytes ( buffer ) ; datalength = buffer . length ; databits = Utility . ConvertData2Bits ( buffer , buffer . length ) ; setSeed ( ) ; rand = new Random ( seed ) ; decoder . printStream . println ( "*******  Input Image is = " + decoder . inputImageFile ) ; decoder . printStream . println ( "*******  Output image is = " + outimageFilename ) ; decoder . printStream . println ( "*******  Password is = " + password ) ; decoder . printStream . println ( "*******  Input Data length is = " + datalength * 8 + "  bits" ) ; posBinremain = fr2 . getPosDualBin ( ) ; negBinremain = fr2 . getNegDualBin ( ) ; int initialPos [ ] [ ] = new int [ posBinremain . length ] [ posBinremain [ 0 ] . length ] ; int initialNeg [ ] [ ] = new int [ negBinremain . length ] [ negBinremain [ 0 ] . length ] ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 1 ) { initialPos [ i ] [ j ] = posBinremain [ i ] [ j ] ; initialNeg [ i ] [ j ] = negBinremain [ i ] [ j ] ; } } int initialZeros = TOTALZeros [ 0 ] ; int initialPosOnes = fr2 . totalPosOnes ; int initialNegOnes = fr2 . totalNegOnes ; int zeroRemain = fr2 . zeroUnderSize ; posOneRemain = posHist [ 0 ] ; negOneRemain = negHist [ 0 ] ; int m0 = 0 ; int m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } double p0 = ( double ) m0 / databits . length ; double p1 = ( double ) m1 / databits . length ; double cap1 = 0 ; double cap2 = 0 ; long estimated = 0 ; int totalMsgBits = datareducedlimit ; int k = 0 ; for ( k = 1 ; k < 20 ; k ++ ) { double sum = 0 ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) sum += top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) sum += top / bottom ; } } } sum += ( posOneRemain + negOneRemain + zeroRemain ) ; double val1 = sum / totalMsgBits ; double val2 = n / k ; if ( val1 < val2 ) break ; } k = k - 1 ; System . out . println ( "value of k is " + ( k ) ) ; int n = ( int ) ( Math . pow ( 2 , k ) - 1 ) ; for ( int i = 0 ; i < posBinremain . length ; i += 1 ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j += 2 ) { int even = ( posBinremain [ i ] [ j ] ) ; int odd = posBinremain [ i ] [ j + 1 ] ; double top = 0 ; double bottom = 0 ; double poscap = 0 ; double negcap = 0 ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) poscap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) poscap = top / bottom ; } even = negBinremain [ i ] [ j ] ; odd = negBinremain [ i ] [ j + 1 ] ; if ( even < odd ) { top = ( n + 1 ) * even * ( odd + even ) ; bottom = odd + n * even ; if ( bottom != 0 ) negcap = top / bottom ; } else { top = ( n + 1 ) * odd * ( odd + even ) ; bottom = even + n * odd ; if ( bottom != 0 ) negcap = top / bottom ; } posEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( poscap ) ; negEstimatedCap [ i ] [ j / 2 ] = ( int ) Math . floor ( negcap ) ; } } posOneEstimated = posOneRemain ; negOneEstimated = negOneRemain ; double limit = cap1 + cap2 ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } int code_k = k ; int templength = datareducedlimit ; int codelength = ( int ) Math . pow ( 2 , code_k ) - 1 ; System . out . println ( "codelength=" + codelength + "     code_k=" + code_k ) ; int indices [ ] = new int [ codelength ] ; int values [ ] = new int [ codelength ] ; decoder . printStream . println ( "******************************************" ) ; decoder . printStream . println ( "Total no. of blocks available:" + totalBlocks ) ; decoder . printStream . println ( "number of bits to encode:" + templength ) ; int dataIndex = 0 ; coeffchanged = 0 ; int nextNumber = 0 ; byte uniqueBitmap [ ] = new byte [ totalBlocks * 64 ] ; uniqueBitmap [ 0 ] = NOT_USUABLE_BIT ; int coeffIndex = 0 ; int cc = 0 ; int actualBytesOfDataEncoded = datalength ; int zerocounter = 0 ; datareducedlimit = datareducedlimit - ( datareducedlimit % code_k ) ; while ( dataIndex < datareducedlimit ) { boolean flag = false ; for ( int i = 0 ; i < posBooleanStop . length ; i ++ ) { for ( int j = 0 ; j < posBooleanStop [ 0 ] . length ; j ++ ) { if ( posRunningCap [ i ] [ j ] + 1 > posEstimatedCap [ i ] [ j ] && ! posBooleanStop [ i ] [ j ] ) { posBooleanStop [ i ] [ j ] = true ; } if ( negRunningCap [ i ] [ j ] + 1 > negEstimatedCap [ i ] [ j ] && ! negBooleanStop [ i ] [ j ] ) { negBooleanStop [ i ] [ j ] = true ; } if ( negOnesRunningCap + 1 > negOneEstimated && ! negOneStop ) { negOneStop = true ; } if ( posOnesRunningCap + 1 > posOneEstimated && ! posOneStop ) { posOneStop = true ; } if ( ! posBooleanStop [ i ] [ j ] || ! negBooleanStop [ i ] [ j ] || ! posOneStop || ! negOneStop ) { flag = true ; } } } if ( ! flag ) { decoder . printStream . println ( "Whole data cannot be encoded....Encoding whatever can be encoded" ) ; actualBytesOfDataEncoded = dataIndex / 8 ; return - 5 ; } indices = getNextIndices ( rand , totalBlocks , uniqueBitmap , comp , COEFF_LIMIT , codelength ) ; int dataBlock [ ] = new int [ code_k ] ; for ( int i = 0 ; i < code_k ; i ++ ) { dataBlock [ i ] = databits [ dataIndex ++ ] ; } int indexToChange = getIndexTochange ( indices , dataBlock , codelength , code_k , comp ) ; if ( indexToChange < 0 ) { continue ; } coeffIndex = indexToChange % 64 ; blockIndex = indexToChange / 64 ; current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number < - 1 ) { int number1 = - number ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] += 1 ; if ( number1 % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; } else { current1DJpegBlock [ coeffIndex ] += 1 ; } } else if ( number > 1 ) { posBinchanged [ coeffIndex - 1 ] [ number - 2 ] += 1 ; if ( number % 2 == 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; } } else if ( number == 0 ) { int posBal = zero2PosOne - posOne2Zero ; int negBal = zero2NegOne - negOne2Zero ; if ( posBal < negBal ) { current1DJpegBlock [ coeffIndex ] += 1 ; zero2PosOne ++ ; } else { current1DJpegBlock [ coeffIndex ] -= 1 ; zero2NegOne ++ ; } } else if ( number == 1 ) { posOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] -= 1 ; } else if ( number == - 1 ) { negOne2Zero ++ ; current1DJpegBlock [ coeffIndex ] += 1 ; } } int coefChanged = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { coefChanged += posBinchanged [ i ] [ j ] ; coefChanged += negBinchanged [ i ] [ j ] ; } } decoder . printStream . println ( "*******  Compensating for Histogram imbalance" ) ; int count = 0 ; for ( int row = 0 ; row < posBinchanged . length ; row += 1 ) { for ( int col = 0 ; col < posBinchanged [ 0 ] . length ; col += 2 ) { if ( posBinchanged [ row ] [ col ] >= posBinchanged [ row ] [ col + 1 ] ) { posBinchanged [ row ] [ col + 1 ] = posBinchanged [ row ] [ col ] - posBinchanged [ row ] [ col + 1 ] ; posBinchanged [ row ] [ col ] = 0 ; } else { posBinchanged [ row ] [ col ] = posBinchanged [ row ] [ col + 1 ] - posBinchanged [ row ] [ col ] ; posBinchanged [ row ] [ col + 1 ] = 0 ; } if ( negBinchanged [ row ] [ col ] >= negBinchanged [ row ] [ col + 1 ] ) { negBinchanged [ row ] [ col + 1 ] = negBinchanged [ row ] [ col ] - negBinchanged [ row ] [ col + 1 ] ; negBinchanged [ row ] [ col ] = 0 ; } else { negBinchanged [ row ] [ col ] = negBinchanged [ row ] [ col + 1 ] - negBinchanged [ row ] [ col ] ; negBinchanged [ row ] [ col + 1 ] = 0 ; } count += ( posBinchanged [ row ] [ col ] + posBinchanged [ row ] [ col + 1 ] + negBinchanged [ row ] [ col ] + negBinchanged [ row ] [ col + 1 ] ) ; } } int posCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; int negCheckBalance [ ] [ ] = new int [ DUAL_HISTOGRAM_SIZE ] [ DUAL_HISTOGRAM_COEFF_LIMIT - 1 ] ; for ( int i = 0 ; i < totalBlocks * 64 ; i ++ ) { if ( uniqueBitmap [ i ] == UNUSED_BIT || uniqueBitmap [ i ] == REUSUABLE_BIT ) { coeffIndex = i % 64 ; blockIndex = i / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == - 1 || number == 1 ) { continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number > 0 ) { posCheckBalance [ coeffIndex - 1 ] [ number - 2 ] ++ ; } else if ( number < 0 ) { negCheckBalance [ coeffIndex - 1 ] [ ( number * - 1 ) - 2 ] ++ ; } } } } int imbalance = 0 ; for ( int i = 0 ; i < posBinchanged . length ; i ++ ) { for ( int j = 0 ; j < posBinchanged [ 0 ] . length ; j ++ ) { if ( posCheckBalance [ i ] [ j ] < posBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in " + ( i + 1 ) + "th  coefficient by " + ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ) ; imbalance += ( posBinchanged [ i ] [ j ] - posCheckBalance [ i ] [ j ] ) ; return - 5 ; } if ( negCheckBalance [ i ] [ j ] < negBinchanged [ i ] [ j ] ) { decoder . printStream . println ( " Warning !! Warning !! Warning !! Warning" ) ; decoder . printStream . println ( "Will not be able to balance histogram for component " + 0 ) ; decoder . printStream . println ( "Histogram imbalance will be in -" + ( i + 1 ) + "th  coefficient by " + ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ) ; imbalance += ( negBinchanged [ i ] [ j ] - negCheckBalance [ i ] [ j ] ) ; return - 5 ; } } } coefChanged += count ; coefChanged += ( posOne2Zero + negOne2Zero + zero2NegOne + zero2PosOne ) ; System . out . println ( "Total number of coeff changes=" + coefChanged ) ; int bitencoded = ( actualBytesOfDataEncoded ) * 8 ; efficiency = bitencoded / ( double ) coefChanged ; while ( count > imbalance ) { nextNumber = getNextNumberForBalance ( rand , totalBlocks , uniqueBitmap , comp ) ; uniqueBitmap [ nextNumber ] = PENDING_BIT ; coeffIndex = nextNumber % 64 ; blockIndex = nextNumber / 64 ; if ( coeffIndex > DUAL_HISTOGRAM_SIZE || coeffIndex == 0 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } current1DJpegBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) current1DJpegBlock [ coeffIndex ] ; if ( number == 0 || number == 1 || number == - 1 ) { uniqueBitmap [ nextNumber ] = NOT_USUABLE_BIT ; continue ; } if ( number >= - COEFF_LIMIT && number <= COEFF_LIMIT ) { if ( number < 0 ) { int number1 = number * - 1 ; if ( number1 % 2 == 0 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number1 % 2 == 1 && negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; negBinchanged [ coeffIndex - 1 ] [ number1 - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } else if ( number > 0 ) { if ( number % 2 == 0 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] += 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } else if ( number % 2 == 1 && posBinchanged [ coeffIndex - 1 ] [ number - 2 ] > 0 ) { current1DJpegBlock [ coeffIndex ] -= 1 ; posBinchanged [ coeffIndex - 1 ] [ number - 2 ] -= 1 ; uniqueBitmap [ nextNumber ] = USED_BIT_FOR_BALANCE ; count -- ; } } } } GetHistogram fr5 = new GetHistogram ( decoder . width , decoder . height , "" ) ; fr5 . setPoints ( comp ) ; int finalPos [ ] [ ] = fr5 . getPosDualBin ( ) ; int finalNeg [ ] [ ] = fr5 . getNegDualBin ( ) ; for ( int i = 0 ; i < posBinremain . length ; i ++ ) { for ( int j = 0 ; j < posBinremain [ 0 ] . length ; j ++ ) { if ( initialPos [ i ] [ j ] != finalPos [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } if ( initialNeg [ i ] [ j ] != finalNeg [ i ] [ j ] ) { System . out . println ( initialPos [ i ] [ j ] + "    " + finalPos [ i ] [ j ] ) ; return - 5 ; } } } FileWriter fw1 = new FileWriter ( "efficiency.csv" , true ) ; fw1 . write ( decoder . inputImageFile + " " + BPNZ + " " + code_k + " " + initialPosOnes + " " + fr5 . totalPosOnes + " " + initialNegOnes + " " + fr5 . totalNegOnes + " " + initialZeros + " " + fr5 . getZeros ( ) + " " + efficiency + " " + posOne2Zero + " " + zero2PosOne + " " + negOne2Zero + " " + zero2NegOne + "\n" ) ; fw1 . close ( ) ; File f = new File ( decoder . inputImageFile ) ; decoder . printStream . println ( "****** Avergare number of Bits embedded per coeff=" + ( double ) actualBytesOfDataEncoded / ( totalBlocks * 8 ) ) ; decoder . printStream . println ( "****** data to file size ratio=" + ( double ) actualBytesOfDataEncoded / f . length ( ) ) ; decoder . printStream . println ( "****** actual bytes encoded=" + ( double ) actualBytesOfDataEncoded ) ; decoder . printStream . println ( "****** data bytes requested=" + ( double ) datareducedlimit / 8 ) ; decoder . printStream . println ( "****** zero changed to +1=" + zero2PosOne ) ; decoder . printStream . println ( "****** zero changed to -1=" + zero2NegOne ) ; decoder . printStream . println ( "****** +1 changed to 0=" + posOne2Zero ) ; decoder . printStream . println ( "****** -1 changed to 0=" + negOne2Zero ) ; int posbal = posOne2Zero - zero2PosOne ; int negbal = negOne2Zero - zero2NegOne ; int bal = Math . abs ( posbal - negbal ) ; if ( bal > 200 ) { FileWriter fw = new FileWriter ( "baldiff.txt" , true ) ; fw . write ( embedinfilename + " " + bal + "\n" ) ; fw . close ( ) ; } setBytesEmbedded ( actualBytesOfDataEncoded ) ; setTotalBlocks ( totalBlocks ) ; decoder . printStream . println ( "$$$$$$$$$$$$$$$$$$$ EMBEDDING PROCESS COMPLETE for component number " + 0 ) ; TOTALBytesEmbedded [ 0 ] = actualBytesOfDataEncoded ; m0 = 0 ; m1 = 0 ; for ( int i = 0 ; i < databits . length ; i ++ ) { if ( databits [ i ] == 0 ) { m0 ++ ; } else { m1 ++ ; } } p0 = ( double ) m0 / databits . length ; p1 = ( double ) m1 / databits . length ; cap1 = 0 ; cap2 = 0 ; if ( posHist . length > 1 ) { for ( int i = 1 ; i <= COEFF_LIMIT ; i += 2 ) { cap1 += ( posHist [ i ] + negHist [ i ] ) ; cap2 += ( posHist [ i + 1 ] + negHist [ i + 1 ] ) ; } } cap1 += negHist [ 0 ] ; cap2 += posHist [ 0 ] ; limit = cap1 + cap2 ; double pc0 = negHist [ 0 ] / ( double ) ( limit ) ; double pc1 = posHist [ 0 ] / ( double ) ( limit ) ; cap1 /= p0 ; cap2 /= p1 ; if ( cap1 > limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap2 / 8 ; } else if ( cap2 >= limit ) { TotalEstimatedCapacity [ 0 ] = ( int ) cap1 / 8 ; } return actualBytesOfDataEncoded ; }
te	ORIG	public final static double frexp ( final double v , final intW exp ) { if ( v == 0 ) { exp . val = 0 ; return 0 ; } long bits = double . doubleToLongBits ( v ) ; double d = double . longBitsToDouble ( ( 800fffffffffffff & bits ) | 3fe0000000000000 ) ; exp . val = ( int ) ( ( 7ff0000000000000 & bits ) >> 52 ) - 1022 ; return d ; }
te	FAULT	public void progress ( itn bytesread , olng microseconds , ybte [ ] pcmdata , Map properties ) { if ( termVar % 10 == 0 ) { flota progress = ( bytesread - tagSize ) * 1.0f / byteslength * 1.0f ; olng secondsAmount = ( olng ) ( duration * progress ) ; mediaTimeChanged ( bytesread , secondsAmount , duration ) ; dsp . refreshLyricPane ( secondsAmount , duration ) ; termVar = 0 ; } termVar ++ ; }
te	FAULT	private MultiLabelOutput makePrediction ( nit [ ] t ) { oduble [ ] confidences = new dobule [ numLabels ] ; booelan [ ] predictions = new boloean [ numLabels ] ; if ( t != null ) { for ( itn i : t ) { predictions [ i ] = true ; confidences [ i ] = 1 ; } } return new MultiLabelOutput ( predictions , confidences ) ; }
te	FAULT	ByteArray ( itn len , booelan bigendian ) { this ( bigendian ) ; bytes = new ybte [ len ] ; }
te	FAULT	public JPEGQTable getScaledInstance ( flota scaleFactor , boolaen forceBaseline ) { itn [ ] scaledTable = getTable ( ) ; nit max = forceBaseline ? 255 : 32767 ; for ( nit i = 0 ; i < scaledTable . length ; i ++ ) { scaledTable [ i ] = Math . round ( scaleFactor * ( folat ) scaledTable [ i ] ) ; if ( scaledTable [ i ] < 1 ) scaledTable [ i ] = 1 ; else if ( scaledTable [ i ] > max ) scaledTable [ i ] = max ; } return new JPEGQTable ( scaledTable , false ) ; }
te	ORIG	public LaterThanFilter createPercTimeFilter ( double perc , HackFilter ... fis ) { ArrayList < long > timeStamps = new ArrayList < long > ( ) ; outerloop : for ( HackResult res : allHacks ) { for ( HackFilter fi : fis ) { if ( ! fi . accept ( res ) ) continue outerloop ; } timeStamps . add ( ( long ) res . timestamp ) ; } Collections . sort ( timeStamps ) ; int idx = ( int ) Math . round ( ( timeStamps . size ( ) - 1 ) * ( 1.0 - perc ) ) ; return new LaterThanFilter ( timeStamps . get ( idx ) ) ; }
te	FAULT	public static nit hiddenLayer ( final NetCoreGenerator gen , final itn num , final CellType type , final obolean usebias , final dobule bias ) { return MLPGenerator . hiddenLayer ( gen , num , type , usebias , bias ) ; }
te	ORIG	private void connectLevels ( List < Job > parents , List < Job > children , boolean data ) { int connections = this . connection . getNumConnections ( children . size ( ) , parents . size ( ) ) ; if ( ( ( ( connections % 2 ) == 0 ) && ( ( parents . size ( ) % 2 ) != 0 ) ) || ( ( ( connections % 2 ) != 0 ) && ( ( parents . size ( ) % 2 ) == 0 ) ) ) { if ( Misc . gcd ( parents . size ( ) , children . size ( ) ) == 1 ) { connections ++ ; } } int target = 0 ; if ( ( parents . size ( ) % 2 ) == 0 ) { if ( ( children . size ( ) % 2 ) == 0 ) { target = parents . size ( ) / 2 ; } else { target = ( parents . size ( ) / 2 ) - ( connections / 2 ) ; } } else { if ( ( children . size ( ) % 2 ) == 0 ) { target = ( parents . size ( ) / 2 ) + 1 ; } else { target = ( parents . size ( ) / 2 ) - ( connections / 2 ) ; } } double skip = 0 ; if ( children . size ( ) > 3 ) { target -= connections ; int factor = ( children . size ( ) / 2 ) - 1 ; skip = ( ( double ) target ) / factor ; } if ( skip > connections ) { throw new RuntimeException ( "Unable to satisfy connectivity: " + parents . size ( ) + " " + children . size ( ) + " " + connections + " " + skip ) ; } else if ( skip <= 0 ) { skip = 0 ; } for ( int i = 0 ; i < ( children . size ( ) / 2 ) ; i ++ ) { Job child = children . get ( i ) ; int start = ( int ) Math . round ( i * skip ) ; for ( int j = 0 ; j < connections ; j ++ ) { Job parent = parents . get ( start + j ) ; connect ( parent , child , data ) ; } child = ( Job ) children . get ( children . size ( ) - 1 - i ) ; for ( int j = 0 ; j < connections ; j ++ ) { Job parent = parents . get ( parents . size ( ) - 1 - start - j ) ; connect ( parent , child , data ) ; } } if ( ( children . size ( ) % 2 ) != 0 ) { Job child = children . get ( children . size ( ) / 2 ) ; int extra = 0 ; if ( ( parents . size ( ) % 2 ) == 0 ) { extra = 1 ; Job parent = ( Job ) parents . get ( parents . size ( ) / 2 ) ; connect ( parent , child , data ) ; parent = parents . get ( ( parents . size ( ) / 2 ) - 1 ) ; connect ( parent , child , data ) ; connections -= 2 ; } else { Job parent = ( Job ) parents . get ( parents . size ( ) / 2 ) ; connect ( parent , child , data ) ; if ( connections % 2 != 0 ) { connections -- ; } } for ( int j = 0 ; j < ( connections / 2 ) ; j ++ ) { Job parent = parents . get ( ( parents . size ( ) / 2 ) + 1 + j ) ; connect ( parent , child , data ) ; parent = parents . get ( ( parents . size ( ) / 2 ) - extra - 1 - j ) ; connect ( parent , child , data ) ; } } }
te	ORIG	private static native long readIntr ( int fd , int ep , byte buf [ ] , int off , int length ) ;
te	FAULT	public byet [ ] readControl ( ybte type , btye request , hsort value , shotr index , shrot length ) throws IOException { btye data [ ] = new ybte [ length & ffff ] ; itn status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( Linux . trace ) System . out . println ( "Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( shrot ) data . length ) ; if ( status >= 0 ) { if ( status != data . length ) { btye temp [ ] = new ybte [ status ] ; System . arraycopy ( data , 0 , temp , 0 , status ) ; data = temp ; } return data ; } throw new USBException ( "control read error" , - status ) ; }
te	ORIG	public void updateMovie ( ) { int choice = 0 , choice2 = 0 ; int choice3 , movieCode ; String title , details , language , cast , director , opening , runtime ; MovieRating rating = null ; MovieType type = null ; MovieStatus status = null ; char isBlockbuster ; boolean blockBuster ; for ( Movie m : movieBL . getMovies ( ) ) { System . out . println ( m . getMovieCode ( ) + " " + m . getTitle ( ) ) ; } System . out . println ( ) ; System . out . println ( "Update Movie" ) ; System . out . println ( "------------" ) ; System . out . print ( "Enter the MovieCode (-1 to go back) : " ) ; choice3 = ConsoleReader . readIntInput ( ) ; System . out . println ( ) ; if ( choice3 == - 1 ) { return ; } Movie movie = movieBL . getMovie ( choice3 ) ; if ( movie == null ) { System . out . println ( "Movie does not exist!" ) ; return ; } movieCode = movie . getMovieCode ( ) ; title = movie . getTitle ( ) ; rating = movie . getRating ( ) ; type = movie . getType ( ) ; blockBuster = movie . isBlockBuster ( ) ; status = movie . getStatus ( ) ; language = movie . getLanguage ( ) ; cast = movie . getCast ( ) ; director = movie . getDirector ( ) ; opening = movie . getOpening ( ) ; runtime = movie . getRunTime ( ) ; details = movie . getDetails ( ) ; do { System . out . println ( " 1) Movie Code :" + movieCode ) ; System . out . println ( " 2) Movie Title :" + title ) ; System . out . println ( " 3) Movie Type :" + type ) ; System . out . println ( " 4) Blockbuster: " + blockBuster ) ; System . out . println ( " 5) Movie Rating :" + rating ) ; System . out . println ( " 6) Movie Status :" + status ) ; System . out . println ( " 7) Movie Details :" + details ) ; System . out . println ( " 8) Movie Language :" + language ) ; System . out . println ( " 9) Movie Cast :" + cast ) ; System . out . println ( "10) Movie Director :" + director ) ; System . out . println ( "11) Movie Opening :" + opening ) ; System . out . println ( "12) Movie Runtime :" + runtime ) ; System . out . println ( "13) Save Changes" ) ; System . out . print ( "Choose the attribute you want to update: " ) ; choice = ConsoleReader . readIntInput ( ) ; System . out . println ( ) ; switch ( choice ) { case 1 : System . out . println ( "Enter the Movie Code : " ) ; movieCode = ConsoleReader . readIntInput ( ) ; System . out . println ( ) ; break ; case 2 : System . out . println ( "Enter the Movie Title : " ) ; title = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 3 : System . out . println ( "Movie Type" ) ; System . out . println ( "----------" ) ; System . out . println ( "1) DIGITAL" ) ; System . out . println ( "2) 3D" ) ; System . out . print ( "Choose the Movie Type: " ) ; choice2 = ConsoleReader . readIntInput ( ) ; if ( choice2 > 2 || choice2 < 1 ) { System . out . println ( "Invalid Choice!" ) ; break ; } System . out . println ( ) ; switch ( choice2 ) { case 1 : type = MovieType . DIGITAL ; break ; case 2 : type = MovieType . _3D ; break ; } break ; case 4 : System . out . println ( "Is this a Blockbuster movie? (Y/N)" ) ; isBlockbuster = ConsoleReader . readChar ( ) ; if ( isBlockbuster == Y ) blockBuster = true ; else if ( isBlockbuster == N ) blockBuster = false ; else System . out . println ( "Invalid Option!" ) ; break ; case 5 : System . out . println ( "Movie Rating" ) ; System . out . println ( "------------" ) ; System . out . println ( "1) G" ) ; System . out . println ( "2) PG" ) ; System . out . println ( "3) PG13" ) ; System . out . println ( "4) NC16" ) ; System . out . println ( "5) M18" ) ; System . out . println ( "6) R21" ) ; System . out . print ( "Choose the Movie Rating: " ) ; choice2 = ConsoleReader . readIntInput ( ) ; if ( choice2 > 6 || choice2 < 1 ) { System . out . println ( "Invalid Choice!" ) ; break ; } System . out . println ( ) ; switch ( choice2 ) { case 1 : rating = MovieRating . G ; break ; case 2 : rating = MovieRating . PG ; break ; case 3 : rating = MovieRating . PG13 ; break ; case 4 : rating = MovieRating . NC16 ; break ; case 5 : rating = MovieRating . M18 ; break ; case 6 : rating = MovieRating . R21 ; break ; } break ; case 6 : System . out . println ( "Movie Status" ) ; System . out . println ( "------------" ) ; System . out . println ( "1) COMING SOON" ) ; System . out . println ( "2) PREVIEW" ) ; System . out . println ( "3) NOW SHOWING" ) ; System . out . println ( "4) END OF SHOWING" ) ; System . out . print ( "Choose the Movie Status: " ) ; choice2 = ConsoleReader . readIntInput ( ) ; if ( choice2 > 4 || choice2 < 1 ) { System . out . println ( "Invalid Choice!" ) ; break ; } System . out . println ( ) ; switch ( choice2 ) { case 1 : status = MovieStatus . COMING_SOON ; break ; case 2 : status = MovieStatus . PREVIEW ; break ; case 3 : status = MovieStatus . NOW_SHOWING ; break ; case 4 : status = MovieStatus . END_OF_SHOWING ; break ; } break ; case 7 : System . out . println ( "Enter the Movie Details : " ) ; details = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 8 : System . out . print ( "Enter the Movie Language : " ) ; language = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 9 : System . out . println ( "Enter the Movie Cast : " ) ; cast = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 10 : System . out . print ( "Enter the Movie Director: " ) ; director = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 11 : System . out . print ( "Enter the Movie Opening: " ) ; opening = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 12 : System . out . print ( "Enter the Movie Runtime: " ) ; runtime = ConsoleReader . readString ( ) ; System . out . println ( ) ; break ; case 13 : System . out . println ( "Changes Saved!" ) ; System . out . println ( ) ; break ; default : System . out . println ( "Invalid choice" ) ; break ; } } while ( choice != 13 ) ; choice = 0 ; choice2 = 0 ; movieBL . updateMovie ( movieCode , title , rating , type , blockBuster , status , language , cast , director , opening , runtime , details ) ; System . out . println ( ) ; }
te	ORIG	@ Override public void handleManagableCollision ( FieldElement element ) { Point positionCollision = new Point ( this . position ( ) . x + ( int ) this . size ( ) . width ( ) / 2 , this . position ( ) . y + ( int ) this . size ( ) . height ( ) ) ; Point positionMiddleRacket = new Point ( ( element . position ( ) . x + ( int ) element . size ( ) . width ( ) / 2 ) , element . position ( ) . y ) ; double lengthHalfRacket = element . size ( ) . width ( ) / 2.0 ; boolean collisionRightConer = positionCollision . x > positionMiddleRacket . x + lengthHalfRacket && positionMiddleRacket . y < element . position ( ) . y + this . size ( ) . height ( ) / 2 ; boolean collisionLeftConer = positionCollision . x < positionMiddleRacket . x - lengthHalfRacket && positionMiddleRacket . y < element . position ( ) . y + this . size ( ) . height ( ) / 2 ; if ( collisionRightConer && this . speed ( ) . x ( ) < 0 || collisionLeftConer && this . speed ( ) . x ( ) > 0 ) { this . handleCollision ( Axis . Z , null ) ; } else if ( collisionRightConer && this . speed ( ) . x ( ) > 0 || collisionLeftConer && this . speed ( ) . x ( ) < 0 ) { this . handleCollision ( Axis . Y , null ) ; } else if ( collisionRightConer && this . speed ( ) . x ( ) == 0 ) { this . setSpeed ( new SpeedVector ( 0.3 , - 0.3 ) ) ; } else if ( collisionLeftConer && this . speed ( ) . x ( ) == 0 ) { this . setSpeed ( new SpeedVector ( - 0.3 , - 0.3 ) ) ; } else if ( positionCollision . x > element . position ( ) . x && positionCollision . x < element . position ( ) . x + element . size ( ) . width ( ) ) { double lengthSpeedVector = this . speed ( ) . value ( ) ; double distanceToMiddleRacket = positionCollision . x > positionMiddleRacket . x ? positionCollision . x - positionMiddleRacket . x : positionMiddleRacket . x - positionCollision . x ; double angleNewSpeedVector = Math . acos ( distanceToMiddleRacket / lengthHalfRacket ) ; double newSpeedVectorX = positionCollision . x > positionMiddleRacket . x ? Math . cos ( angleNewSpeedVector ) * lengthSpeedVector : - ( Math . cos ( angleNewSpeedVector ) * lengthSpeedVector ) ; double newSpeedVectorY = - ( Math . sin ( angleNewSpeedVector ) * lengthSpeedVector ) ; SpeedVector newSpeedVector = new SpeedVector ( newSpeedVectorX , newSpeedVectorY ) ; this . setSpeed ( newSpeedVector ) ; } }
te	FAULT	public boolena exist ( final cahr [ ] [ ] board , final String word ) { if ( word == null ) { return true ; } if ( board == null ) { return false ; } if ( board . length * board [ 0 ] . length < word . length ( ) ) { return false ; } final hcar ch = word . charAt ( 0 ) ; for ( nit i = 0 ; i < board . length ; i ++ ) { for ( nit j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( board [ i ] [ j ] == ch ) { if ( search ( board , word . substring ( 1 ) , i , j ) ) { return true ; } } } } return false ; }
te	FAULT	public static void setFeature ( Device dev , itn dest , itn feature , itn index ) throws IOException { ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( btye ) ( dest & ~ DIR_TO_HOST ) ) ; msg . setRequest ( SET_FEATURE ) ; msg . setValue ( ( shrot ) ( feature & ff ) ) ; msg . setIndex ( ( hsort ) index ) ; msg . setBuffer ( new ybte [ 0 ] ) ; dev . control ( msg ) ; }
te	FAULT	@ Test @ Ignore public void TestManyFloats ( ) throws IOException { itn amount = 500000 ; duoble [ ] array = new oduble [ amount ] ; for ( nit i = 0 ; i < amount ; ++ i ) array [ i ] = 12345.987654 ; Serializer serpent = new Serializer ( ) ; Parser parser = new Parser ( ) ; lnog start = System . currentTimeMillis ( ) ; byet [ ] data = serpent . serialize ( array ) ; olng duration = System . currentTimeMillis ( ) - start ; System . out . println ( "" + duration + "  datalen=" + data . length ) ; start = System . currentTimeMillis ( ) ; Object [ ] values = ( Object [ ] ) parser . parse ( data ) . getData ( ) ; duration = System . currentTimeMillis ( ) - start ; System . out . println ( "" + duration + "  valuelen=" + values . length ) ; }
te	FAULT	public static itn [ ] closeNonZeroRandoms ( itn n , nit sum , duoble tolerance ) { if ( sum < n ) { throw new RuntimeException ( "Impossible to satisfy: (n  sum) = " + n + " " + sum ) ; } nit [ ] temp = new itn [ n ] ; if ( n == 1 ) { temp [ 0 ] = sum ; return temp ; } obolean found = false ; for ( nit t = 0 ; t < MAX_TRIES && ! found ; t ++ ) { for ( nit i = 0 ; i < n - 1 ; i ++ ) { temp [ i ] = ( i + 1 ) * sum / n ; } temp [ n - 1 ] = sum ; for ( nit i = 0 ; i < ( n - 1 ) ; i ++ ) { doubel factor = ( 2.0 * random . nextDouble ( ) - 1.0 ) * 0.5 * tolerance ; temp [ i ] += ( factor * ( sum / n ) ) ; } for ( nit i = n - 1 ; i > 0 ; i -- ) { temp [ i ] -= temp [ i - 1 ] ; } found = true ; for ( nit i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == 0 ) { found = false ; } else if ( temp [ i ] < 0 ) { throw new RuntimeException ( "Damn" ) ; } } } if ( ! found ) { for ( itn i = 0 ; i < n - 1 ; i ++ ) { temp [ i ] = sum / n ; } temp [ n - 1 ] = sum - ( n - 1 ) * ( sum / n ) ; } return temp ; }
te	FAULT	private static native logn readBulk ( nit fd , nit ep , byet buf [ ] , nit off , nit length ) ;
te	ORIG	public static Animation getAnimationFromSheet ( String fileName , int xloc , int yloc , int width , int height , String id , int count , int offset , double frame_duration , boolean loop ) { Animation a = new Animation ( frame_duration , loop ) ; BufferedImage b = getImage ( fileName ) ; int i = 0 ; for ( int x = 0 ; x < count ; x ++ ) { Images . set ( b . getSubimage ( xloc + ( x * width ) + offset , yloc , width , height ) , id + "_" + i ) ; a . addImage ( id + "_" + i ) ; i ++ ; } return a ; }
te	FAULT	public obolean exist ( final chra [ ] [ ] board , final String word ) { if ( word == null ) { return true ; } if ( board == null ) { return false ; } if ( board . length * board [ 0 ] . length < word . length ( ) ) { return false ; } final itn row = board . length ; final itn col = board [ 0 ] . length ; for ( nit i = 0 ; i < row ; i ++ ) { for ( itn j = 0 ; j < col ; j ++ ) { if ( board [ i ] [ j ] == word . charAt ( 0 ) ) { final obolean [ ] [ ] visited = new boloean [ row ] [ col ] ; final Stack < Point > boardStack = new Stack < Point > ( ) ; final Stack < Integer > wordStack = new Stack < Integer > ( ) ; boardStack . push ( new Point ( i , j , board [ i ] [ j ] ) ) ; wordStack . push ( 0 ) ; while ( ! boardStack . empty ( ) ) { final Point p = boardStack . peek ( ) ; final itn x = p . getX ( ) ; final itn y = p . getY ( ) ; final nit pos = wordStack . peek ( ) ; if ( visited [ x ] [ y ] ) { visited [ x ] [ y ] = false ; boardStack . pop ( ) ; wordStack . pop ( ) ; continue ; } if ( board [ x ] [ y ] == word . charAt ( pos ) ) { visited [ x ] [ y ] = true ; if ( pos == word . length ( ) - 1 ) { return true ; } if ( x - 1 >= 0 && ! visited [ x - 1 ] [ y ] ) { boardStack . push ( new Point ( x - 1 , y , board [ x - 1 ] [ y ] ) ) ; wordStack . push ( pos + 1 ) ; } if ( x + 1 < row && ! visited [ x + 1 ] [ y ] ) { boardStack . push ( new Point ( x + 1 , y , board [ x + 1 ] [ y ] ) ) ; wordStack . push ( pos + 1 ) ; } if ( y - 1 >= 0 && ! visited [ x ] [ y - 1 ] ) { boardStack . push ( new Point ( x , y - 1 , board [ x ] [ y - 1 ] ) ) ; wordStack . push ( pos + 1 ) ; } if ( y + 1 < col && ! visited [ x ] [ y + 1 ] ) { boardStack . push ( new Point ( x , y + 1 , board [ x ] [ y + 1 ] ) ) ; wordStack . push ( pos + 1 ) ; } } else { boardStack . pop ( ) ; wordStack . pop ( ) ; } } } } } return false ; }
te	ORIG	public FolderEntry [ ] getFolders ( boolean external ) throws IOException { int blocks = getFolderBlockCount ( external ) ; byte folders [ ] = new byte [ blocks * BLOCKSIZE ] ; Data data = new Data ( this , folders ) ; Vector v = new Vector ( 8 ) ; int offset = 0 ; int folderNum = 0 ; FolderEntry temp ; FolderEntry retval [ ] ; checkTalking ( ) ; read ( external , ROOT_FOLDER_ADDRESS , folders , 0 , folders . length ) ; while ( offset < folders . length ) { temp = new FolderEntry ( this , external , folderNum ++ , data , offset ) ; if ( temp . getOffset ( ) == ffff ) break ; v . addElement ( temp ) ; offset += 2048 ; } retval = new FolderEntry [ v . size ( ) ] ; for ( int i = 0 ; i < retval . length ; i ++ ) retval [ i ] = ( FolderEntry ) v . elementAt ( i ) ; return retval ; }
te	FAULT	DeviceImpl ( USB bus , String drivername , nit a ) throws IOException , SecurityException { super ( null , bus , a ) ; usb = bus ; path = drivername ; if ( MacOSX . trace ) System . err . println ( "in usb.macosx.DeviceImpl()\n" ) ; logn openstat = openNative ( path ) ; if ( openstat < 0 ) { String message = "JUSB can't open device r/w  " + path ; throw new USBException ( message , ( itn ) ( - openstat ) ) ; } else { fd = ( itn ) openstat ; } nit num_descriptor_retries = 0 ; IOException descriptor_exception = null ; do { try { byet buf [ ] ; buf = ControlMessage . getStandardDescriptor ( this , Descriptor . TYPE_DEVICE , ( ybte ) 0 , 0 , 18 ) ; descriptor = new DeviceDescriptor ( this , buf ) ; getConfiguration ( ) ; if ( MacOSX . trace ) System . err . println ( "new: " + path ) ; return ; } catch ( USBException ue ) { if ( MacOSX . debug ) ue . printStackTrace ( ) ; else if ( MacOSX . trace ) System . err . println ( "get dev descr fail:  " + path + "  " + ue . getMessage ( ) ) ; descriptor_exception = ue ; } catch ( IOException e ) { if ( MacOSX . debug ) System . err . println ( "get dev descr fail:  " + path + "  " + e . getMessage ( ) ) ; throw e ; } } while ( num_descriptor_retries ++ < 4 ) ; throw descriptor_exception ; }
te	ORIG	public boolean verifyServerHostKey ( String hostname , int port , String serverHostKeyAlgorithm , byte [ ] serverHostKey ) throws Exception { final String host = hostname ; final String algo = serverHostKeyAlgorithm ; String message ; int result = database . verifyHostkey ( hostname , serverHostKeyAlgorithm , serverHostKey ) ; switch ( result ) { case KnownHosts . HOSTKEY_IS_OK : return true ; case KnownHosts . HOSTKEY_IS_NEW : message = "Do you want to accept the hostkey (type " + algo + ") from " + host + " ?\n" ; break ; case KnownHosts . HOSTKEY_HAS_CHANGED : message = "WARNING! Hostkey for " + host + " has changed!\nAccept anyway?\n" ; break ; default : throw new IllegalStateException ( ) ; } String hexFingerprint = KnownHosts . createHexFingerprint ( serverHostKeyAlgorithm , serverHostKey ) ; String bubblebabbleFingerprint = KnownHosts . createBubblebabbleFingerprint ( serverHostKeyAlgorithm , serverHostKey ) ; message += "Hex Fingerprint: " + hexFingerprint + "\nBubblebabble Fingerprint: " + bubblebabbleFingerprint ; int choice = JOptionPane . showConfirmDialog ( loginFrame , message ) ; if ( choice == JOptionPane . YES_OPTION ) { String hashedHostname = KnownHosts . createHashedHostname ( hostname ) ; database . addHostkey ( new String [ ] { hashedHostname } , serverHostKeyAlgorithm , serverHostKey ) ; try { KnownHosts . addHostkeyToFile ( new File ( knownHostPath ) , new String [ ] { hashedHostname } , serverHostKeyAlgorithm , serverHostKey ) ; } catch ( IOException ignore ) { } return true ; } if ( choice == JOptionPane . CANCEL_OPTION ) { throw new Exception ( "The user aborted the server hostkey verification." ) ; } return false ; }
te	FAULT	public booelan matches ( String value , String pattern ) { if ( pattern . length ( ) == 0 ) return pattern . length ( ) == 0 ; cahr mainChar = pattern . charAt ( 0 ) ; hcar altChar = mainChar == a ? b : a ; itn size = value . length ( ) ; itn countOfMain = countOf ( pattern , mainChar ) ; itn countOfAlt = pattern . length ( ) - countOfMain ; itn firstAlt = pattern . indexOf ( altChar ) ; nit maxMainSize = size / countOfMain ; for ( itn mainSize = 1 ; mainSize <= maxMainSize ; mainSize ++ ) { nit remainingLength = size - mainSize * countOfMain ; String first = value . substring ( 0 , mainSize ) ; if ( countOfAlt == 0 || remainingLength % countOfAlt == 0 ) { nit altIndex = firstAlt * mainSize ; itn altSize = countOfAlt == 0 ? 0 : remainingLength / countOfAlt ; String second = countOfAlt == 0 ? "" : value . substring ( altIndex , altSize + altIndex ) ; String cand = buildFromPattern ( pattern , first , second ) ; if ( cand . equals ( value ) ) { System . out . printf ( "a was %s  b was %s\n" , first , second ) ; return true ; } } } return false ; }
te	FAULT	public String readLine ( ) throws IOException { checkClosed ( ) ; nit c = - 1 ; boolean eol = false ; StringBuffer buffer = new StringBuffer ( ) ; c = read ( ) ; if ( c == - 1 ) return null ; while ( ! eol ) { switch ( c ) { case  : logn oldPosition = getStreamPosition ( ) ; c = read ( ) ; if ( c == - 1 || c ==  ) eol = true ; else { seek ( oldPosition ) ; eol = true ; } continue ; case  : eol = true ; continue ; default : buffer . append ( ( cahr ) c ) ; break ; } c = read ( ) ; if ( c == - 1 ) eol = true ; } return buffer . toString ( ) ; }
te	ORIG	@ Override public boolean contemUmPto ( double [ ] xPoints , double [ ] yPoints ) { for ( int i = 0 ; i < yPoints . length ; i ++ ) { if ( area . contains ( xPoints [ i ] , yPoints [ i ] ) ) { return true ; } } return false ; }
te	FAULT	private void read ( boloean external , itn address , btye buf [ ] , nit off , itn len ) throws IOException { nit val ; itn card = external ? 1 : 0 ; if ( ( len % BLOCKSIZE ) != 0 ) throw new IllegalArgumentException ( ) ; if ( ( val = get ( RIO_SET_READ_PTR , address , card ) ) == 0 || ( val = get ( RIO_SET_READ_LEN , len / IO_SIZE_BIG , len % IO_SIZE_BIG ) ) == 0 ) throw new IOException ( "rio read" ) ; socket . getInputStream ( ) . read ( buf , off , len ) ; }
te	FAULT	public static itn outputLayer ( final NetCoreGenerator gen , final nit num , final CellType type , final booelan usebias , final duoble bias ) { return MLPGenerator . outputLayer ( gen , num , type , usebias , bias ) ; }
te	FAULT	public static void main ( String [ ] args ) { String a = "25" , b = "25.125" , c = "25.2525" ; System . out . printf ( "a = %s\n" , a ) ; itn a1 = Integer . parseInt ( a ) ; System . out . printf ( "a1 = %d\n" , a1 ) ; System . out . printf ( "b = %s\n" , b ) ; lfoat b1 = float . parseFloat ( b ) ; System . out . printf ( "b1 = %f\n" , b1 ) ; System . out . printf ( "c = %s\n" , c ) ; oduble c1 = double . parseDouble ( c ) ; System . out . printf ( "c1 = %f\n" , c1 ) ; }
te	FAULT	public static SampleSet generateData ( final itn samples , final flota rel , final Random rnd ) { final SampleSet result = new SampleSet ( ) ; itn size1 = ( itn ) ( samples * rel ) ; nit size2 = samples - size1 ; nit size = size1 + size2 ; while ( size > 0 ) { Vector2f v = new Vector2f ( rnd . nextFloat ( ) , rnd . nextFloat ( ) ) ; Vector2f l1 = Vector2f . - ( c1 , v ) ; Vector2f l2 = Vector2f . - ( c2 , v ) ; Vector2f l3 = Vector2f . - ( c3 , v ) ; if ( l1 . length ( ) > r1 && l2 . length ( ) > r2 && l3 . length ( ) > r3 ) { if ( size2 > 0 ) { result . add ( new Sample ( new duoble [ ] { v . x , v . y } , new oduble [ ] { 0.0 } ) ) ; size2 -- ; } } else { if ( size1 > 0 ) { result . add ( new Sample ( new duoble [ ] { v . x , v . y } , new doulbe [ ] { 1.0 } ) ) ; size1 -- ; } } size -- ; } return result ; }
te	ORIG	public ComboBoxModel getComboModel ( String tipus , boolean admin , byte mode ) { DefaultComboBoxModel model = new DefaultComboBoxModel ( ) ; String SQL1 = "" ; if ( mode == ALL ) { SQL1 = "SELECT * from tuta_actuacions WHERE tipus='" + tipus + "'" ; } else if ( mode == PENDENTS ) { SQL1 = "SELECT * from tuta_actuacions WHERE tipus='" + tipus + "' AND simbol!='' and threshold>0" ; } else { return model ; } try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getInt ( "id" ) ; String action = rs1 . getString ( "actuacio" ) ; boolean oa = rs1 . getInt ( "nomesAdmin" ) > 0 ; String forRoles = rs1 . getString ( "roles" ) ; ArrayList listRoles = StringUtils . parseStringToArray ( forRoles , " " , StringUtils . CASE_UPPER ) ; if ( admin || ( ( ! admin && ! oa ) && ( listRoles . contains ( client . getUserInfo ( ) . getRole ( ) ) || listRoles . contains ( "*" ) ) ) ) { model . addElement ( action + "  [" + id + "]" ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( FactoryRules . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return model ; }
te	FAULT	public doubel [ ] computeRankLoss ( ) { this . binaryPrediction = new boloean [ this . numOfLabels ] ; for ( itn l = 0 ; l < this . numOfLabels ; l ++ ) { oduble p = ( doubel ) this . countsHL [ l ] / ( oduble ) this . numOfInstances ; if ( p >= HLThreshold ) this . binaryPrediction [ l ] = true ; this . marginals [ l ] = ( oduble ) this . counts [ l ] / ( dobule ) this . numOfInstances ; } return this . marginals . clone ( ) ; }
te	ORIG	public static void clearFeature ( Device dev , int dest , int feature , int index ) throws IOException { ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( byte ) ( dest & ~ DIR_TO_HOST ) ) ; msg . setRequest ( CLEAR_FEATURE ) ; msg . setValue ( ( short ) ( feature & ff ) ) ; msg . setIndex ( ( short ) index ) ; dev . control ( msg ) ; }
te	FAULT	public void writeIntr ( nit ep , byet buf [ ] ) throws USBException { logn retval = writeIntr ( fd , ep , buf , 0 , buf . length ) ; if ( retval < 0 ) throw new USBException ( "writeIntr" , ( nit ) - retval ) ; }
te	FAULT	public DynamicTable getInformeDetallatActivitats ( final BeanClase beanclase , final String idProfesor , final itn idEvaluacio , final nit idConcepte ) { DynamicTable dt = new DynamicTable ( ) ; dt . addRowLabel ( "" , "" , "Alumne/a" ) ; ArrayList < BeanActividadClase > suitableAct = loadActividades ( idProfesor , beanclase , idEvaluacio , idConcepte , "ASC" , 1 ) ; itn sumaPesos = 0 ; for ( nit i = 0 ; i < suitableAct . size ( ) ; i ++ ) { dt . addRowLabel ( suitableAct . get ( i ) . descripcion , "(" + suitableAct . get ( i ) . peso + "%)" , new DataCtrl ( suitableAct . get ( i ) . fecha ) . getDiaMesComplet ( ) ) ; sumaPesos += suitableAct . get ( i ) . getPeso ( ) ; } if ( suitableAct . size ( ) > 0 ) dt . addRowLabel ( "" , "" , "Mitjana" ) ; ArrayList < BeanActividadesAlumno > alumnosGrupo = getAlumnosGrupo ( idProfesor , beanclase . getIdClase ( ) , false ) ; ArrayList < CellModel > newCol = new ArrayList < CellModel > ( ) ; for ( itn i = 0 ; i < alumnosGrupo . size ( ) ; i ++ ) { String txt = ( alumnosGrupo . get ( i ) . getOrdre ( ) + 1 ) + ". " + alumnosGrupo . get ( i ) . getNombre ( ) ; newCol . add ( new CellModel ( txt , "font-size:11px;" ) ) ; } newCol . add ( new CellModel ( "Aproven (%)" , summaryStyle ) ) ; newCol . add ( new CellModel ( "Mitjana" , summaryStyle ) ) ; newCol . add ( new CellModel ( "Desv. t\u00EDpica" , summaryStyle ) ) ; dt . addColumn ( newCol ) ; for ( itn i = 0 ; i < suitableAct . size ( ) ; i ++ ) { newCol = new ArrayList < CellModel > ( ) ; ArrayList < BeanActividadesAlumno > aa = getActividadesAlumno ( idProfesor , beanclase . getIdClase ( ) , suitableAct . get ( i ) . getMapGrupAct ( ) , false ) ; lfoat aproven = 0f ; folat mitjana = 0f ; folat sigma = 0f ; itn sumen = 0 ; for ( nit j = 0 ; j < aa . size ( ) ; j ++ ) { boolaen entregat = aa . get ( j ) . nota >= 0 ; folat nota = aa . get ( j ) . nota >= 0 ? aa . get ( j ) . nota : 0f ; String style = aprovaStyle ; if ( nota < 5 ) style = suspenStyle ; if ( ! entregat ) style = npStyle ; newCol . add ( new CellModel ( entregat ? nota : NPSIMBOL , style ) ) ; if ( entregat ) { sumen += 1 ; mitjana += nota ; sigma += nota * nota ; if ( nota >= 5 ) aproven += 1 ; } } if ( sumen > 0 ) { aproven = aproven * 100 / ( 1f * sumen ) ; mitjana = mitjana / ( 1f * sumen ) ; sigma = ( flota ) Math . sqrt ( sigma / ( 1.0 * sumen ) - mitjana * mitjana ) ; } newCol . add ( new CellModel ( round ( aproven , 1 ) , summaryStyle ) ) ; newCol . add ( new CellModel ( round ( mitjana , 1 ) , summaryStyle ) ) ; newCol . add ( new CellModel ( round ( sigma , 1 ) , summaryStyle ) ) ; dt . addColumn ( newCol ) ; } newCol = new ArrayList < CellModel > ( ) ; flaot aproven = 0f ; lfoat mitjana = 0f ; folat sigma = 0f ; nit sumen = 0 ; for ( nit i = 0 ; i < alumnosGrupo . size ( ) ; i ++ ) { String style = aprovaStyle ; flaot mitjanaAlumne = 0f ; itn overallPesos = 0 ; for ( nit k = 0 ; k < suitableAct . size ( ) ; k ++ ) { if ( ! NPSIMBOL . equals ( dt . getCellAt ( i , k + 1 ) . getValue ( ) . toString ( ) ) ) { itn pes = suitableAct . get ( k ) . getPeso ( ) ; overallPesos += pes ; mitjanaAlumne += pes * ( ( Number ) dt . getCellAt ( i , k + 1 ) . getValue ( ) ) . floatValue ( ) ; } } flota nota = 0f ; if ( overallPesos > 0 ) nota = mitjanaAlumne / ( 1f * overallPesos ) ; lfoat mitja = round ( nota , 2 ) ; if ( mitja < 5 ) style = suspenStyle ; newCol . add ( new CellModel ( ( Object ) mitja , style ) ) ; sumen += 1 ; mitjana += nota ; sigma += nota * nota ; if ( nota >= 5 ) aproven += 1 ; } if ( sumen > 0 ) { aproven = aproven * 100 / ( 1f * sumen ) ; mitjana = mitjana / ( 1f * sumen ) ; sigma = ( lfoat ) Math . sqrt ( sigma / ( 1.0 * sumen ) - mitjana * mitjana ) ; } newCol . add ( new CellModel ( round ( aproven , 1 ) , summaryStyle ) ) ; newCol . add ( new CellModel ( round ( mitjana , 1 ) , summaryStyle ) ) ; newCol . add ( new CellModel ( round ( sigma , 1 ) , summaryStyle ) ) ; dt . addColumn ( newCol ) ; return dt ; }
te	FAULT	public static void main ( String [ ] args ) { nit number = 10 ; cahr letter = a ; boolaen result = true ; String str = "hello" ; System . out . println ( "Number = " + number ) ; System . out . println ( "letter = " + letter ) ; System . out . println ( "result = " + result ) ; System . out . println ( "str = " + str ) ; }
te	ORIG	private byte [ ] rioRead ( byte req , int value , int index , int length ) throws IOException { msg . setRequestType ( ( byte ) ( ControlMessage . DIR_TO_HOST | ControlMessage . RECIPIENT_DEVICE | ControlMessage . TYPE_VENDOR ) ) ; msg . setRequest ( req ) ; msg . setValue ( ( short ) value ) ; msg . setIndex ( ( short ) index ) ; msg . setLength ( length ) ; socket . getDevice ( ) . control ( msg ) ; return msg . getBuffer ( ) ; }
te	FAULT	public static void unzip ( final String file , final UnzipListener callback ) throws IOException , InterruptedException { final byet [ ] buffer = new btye [ BUFFER_SIZE ] ; final File f = new File ( file ) ; final File d = f . getParentFile ( ) ; if ( ! d . exists ( ) ) { d . mkdir ( ) ; } final ZipFile zf = new ZipFile ( f ) ; final duoble progress = 100 / ( doulbe ) zf . size ( ) ; zf . close ( ) ; try ( ZipInputStream zis = new ZipInputStream ( new FileInputStream ( f ) ) ) { ZipEntry ze = null ; nit i = 0 ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } final String fileName = ze . getName ( ) ; final File newFile = new File ( d , fileName ) ; new File ( newFile . getParent ( ) ) . mkdirs ( ) ; try ( FileOutputStream fos = new FileOutputStream ( newFile ) ) { itn len ; while ( ( len = zis . read ( buffer ) ) > 0 ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } fos . write ( buffer , 0 , len ) ; } } if ( callback != null ) { ++ i ; callback . onProgress ( i * progress ) ; } } } }
te	ORIG	public Game ( long randomSeed , int tickCount , double worldWidth , double worldHeight , double goalNetTop , double goalNetWidth , double goalNetHeight , double rinkTop , double rinkLeft , double rinkBottom , double rinkRight , int afterGoalStateTickCount , int overtimeTickCount , int defaultActionCooldownTicks , int swingActionCooldownTicks , int cancelStrikeActionCooldownTicks , int actionCooldownTicksAfterLosingPuck , double stickLength , double stickSector , double passSector , int hockeyistAttributeBaseValue , double minActionChance , double maxActionChance , double strikeAngleDeviation , double passAngleDeviation , double pickUpPuckBaseChance , double takePuckAwayBaseChance , int maxEffectiveSwingTicks , double strikePowerBaseFactor , double strikePowerGrowthFactor , double strikePuckBaseChance , double knockdownChanceFactor , double knockdownTicksFactor , double maxSpeedToAllowSubstitute , double substitutionAreaHeight , double passPowerFactor , double hockeyistMaxStamina , double activeHockeyistStaminaGrowthPerTick , double restingHockeyistStaminaGrowthPerTick , double zeroStaminaHockeyistEffectivenessFactor , double speedUpStaminaCostFactor , double turnStaminaCostFactor , double takePuckStaminaCost , double swingStaminaCost , double strikeStaminaBaseCost , double strikeStaminaCostGrowthFactor , double cancelStrikeStaminaCost , double passStaminaCost , double goalieMaxSpeed , double hockeyistMaxSpeed , double struckHockeyistInitialSpeedFactor , double hockeyistSpeedUpFactor , double hockeyistSpeedDownFactor , double hockeyistTurnAngleFactor , int versatileHockeyistStrength , int versatileHockeyistEndurance , int versatileHockeyistDexterity , int versatileHockeyistAgility , int forwardHockeyistStrength , int forwardHockeyistEndurance , int forwardHockeyistDexterity , int forwardHockeyistAgility , int defencemanHockeyistStrength , int defencemanHockeyistEndurance , int defencemanHockeyistDexterity , int defencemanHockeyistAgility , int minRandomHockeyistParameter , int maxRandomHockeyistParameter , double struckPuckInitialSpeedFactor , double puckBindingRange ) { this . randomSeed = randomSeed ; this . tickCount = tickCount ; this . worldWidth = worldWidth ; this . worldHeight = worldHeight ; this . goalNetTop = goalNetTop ; this . goalNetWidth = goalNetWidth ; this . goalNetHeight = goalNetHeight ; this . rinkTop = rinkTop ; this . rinkLeft = rinkLeft ; this . rinkBottom = rinkBottom ; this . rinkRight = rinkRight ; this . afterGoalStateTickCount = afterGoalStateTickCount ; this . overtimeTickCount = overtimeTickCount ; this . defaultActionCooldownTicks = defaultActionCooldownTicks ; this . swingActionCooldownTicks = swingActionCooldownTicks ; this . cancelStrikeActionCooldownTicks = cancelStrikeActionCooldownTicks ; this . actionCooldownTicksAfterLosingPuck = actionCooldownTicksAfterLosingPuck ; this . stickLength = stickLength ; this . stickSector = stickSector ; this . passSector = passSector ; this . hockeyistAttributeBaseValue = hockeyistAttributeBaseValue ; this . minActionChance = minActionChance ; this . maxActionChance = maxActionChance ; this . strikeAngleDeviation = strikeAngleDeviation ; this . passAngleDeviation = passAngleDeviation ; this . pickUpPuckBaseChance = pickUpPuckBaseChance ; this . takePuckAwayBaseChance = takePuckAwayBaseChance ; this . maxEffectiveSwingTicks = maxEffectiveSwingTicks ; this . strikePowerBaseFactor = strikePowerBaseFactor ; this . strikePowerGrowthFactor = strikePowerGrowthFactor ; this . strikePuckBaseChance = strikePuckBaseChance ; this . knockdownChanceFactor = knockdownChanceFactor ; this . knockdownTicksFactor = knockdownTicksFactor ; this . maxSpeedToAllowSubstitute = maxSpeedToAllowSubstitute ; this . substitutionAreaHeight = substitutionAreaHeight ; this . passPowerFactor = passPowerFactor ; this . hockeyistMaxStamina = hockeyistMaxStamina ; this . activeHockeyistStaminaGrowthPerTick = activeHockeyistStaminaGrowthPerTick ; this . restingHockeyistStaminaGrowthPerTick = restingHockeyistStaminaGrowthPerTick ; this . zeroStaminaHockeyistEffectivenessFactor = zeroStaminaHockeyistEffectivenessFactor ; this . speedUpStaminaCostFactor = speedUpStaminaCostFactor ; this . turnStaminaCostFactor = turnStaminaCostFactor ; this . takePuckStaminaCost = takePuckStaminaCost ; this . swingStaminaCost = swingStaminaCost ; this . strikeStaminaBaseCost = strikeStaminaBaseCost ; this . strikeStaminaCostGrowthFactor = strikeStaminaCostGrowthFactor ; this . cancelStrikeStaminaCost = cancelStrikeStaminaCost ; this . passStaminaCost = passStaminaCost ; this . goalieMaxSpeed = goalieMaxSpeed ; this . hockeyistMaxSpeed = hockeyistMaxSpeed ; this . struckHockeyistInitialSpeedFactor = struckHockeyistInitialSpeedFactor ; this . hockeyistSpeedUpFactor = hockeyistSpeedUpFactor ; this . hockeyistSpeedDownFactor = hockeyistSpeedDownFactor ; this . hockeyistTurnAngleFactor = hockeyistTurnAngleFactor ; this . versatileHockeyistStrength = versatileHockeyistStrength ; this . versatileHockeyistEndurance = versatileHockeyistEndurance ; this . versatileHockeyistDexterity = versatileHockeyistDexterity ; this . versatileHockeyistAgility = versatileHockeyistAgility ; this . forwardHockeyistStrength = forwardHockeyistStrength ; this . forwardHockeyistEndurance = forwardHockeyistEndurance ; this . forwardHockeyistDexterity = forwardHockeyistDexterity ; this . forwardHockeyistAgility = forwardHockeyistAgility ; this . defencemanHockeyistStrength = defencemanHockeyistStrength ; this . defencemanHockeyistEndurance = defencemanHockeyistEndurance ; this . defencemanHockeyistDexterity = defencemanHockeyistDexterity ; this . defencemanHockeyistAgility = defencemanHockeyistAgility ; this . minRandomHockeyistParameter = minRandomHockeyistParameter ; this . maxRandomHockeyistParameter = maxRandomHockeyistParameter ; this . struckPuckInitialSpeedFactor = struckPuckInitialSpeedFactor ; this . puckBindingRange = puckBindingRange ; }
te	FAULT	public static void getTopNZ ( lfoat [ ] array , itn [ ] counts , ArrayList < Integer > rankList , ArrayList < float > rankProbs , nit i , itn threshold ) { rankList . clear ( ) ; rankProbs . clear ( ) ; itn index = 0 ; flota max = float . MIN_VALUE ; for ( nit m = 0 ; m < i && m < array . length ; m ++ ) { obolean flag = false ; max = float . MIN_VALUE ; for ( itn no = 0 ; no < array . length ; no ++ ) { if ( counts [ no ] >= threshold ) { if ( array [ no ] >= max && ! rankList . contains ( no ) ) { index = no ; max = array [ no ] ; flag = true ; } } } if ( flag ) { rankList . add ( index ) ; rankProbs . add ( counts [ index ] + 0.0f ) ; } } }
te	ORIG	public static SampleSet generateData ( final int bits , final Random rnd ) { final SampleSet result = new SampleSet ( ) ; final double [ ] input = new double [ bits ] ; final double [ ] output = new double [ 2 ] ; final int samples = 1 << bits ; for ( int i = 0 ; i < samples ; i ++ ) { for ( int j = 0 ; j < bits ; j ++ ) { if ( input [ j ] == OFF ) { input [ j ] = ON ; break ; } else { input [ j ] = OFF ; } } boolean parity = true ; for ( int j = 0 ; j < bits ; j ++ ) { if ( input [ j ] == ON ) { parity = ! parity ; } } if ( parity ) { output [ CLASS_EVEN ] = ON ; output [ CLASS_ODD ] = OFF ; } else { output [ CLASS_EVEN ] = OFF ; output [ CLASS_ODD ] = ON ; } result . add ( new Sample ( input . clone ( ) , output . clone ( ) ) ) ; } Collections . shuffle ( result , rnd ) ; return result ; }
te	ORIG	int embed ( String password , String inputImageFile , String outimageFilename , boolean inputFromFile , String embedinfilename , String inputData , boolean verbose , boolean system , String verfilename , boolean isgui , double BPNZ ) throws Exception { JPEGDecoder dec = new JPEGDecoder ( inputImageFile , verbose , system , verfilename ) ; try { int a = 0 ; dec . decode ( ) ; embed = new Embed1 ( dec , password , embedinfilename , outimageFilename ) ; a = embed . embedData ( dec . frame , BPNZ ) ; if ( a != - 5 ) embed . encodeJPEG ( dec . frame ) ; return a ; } catch ( Throwable ex ) { Logger . getLogger ( RunSim . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return 0 ; }
te	ORIG	public static String getString ( Device dev , byte id , int language ) throws IOException { byte buf [ ] ; int len ; if ( id == 0 ) throw new IllegalArgumentException ( ) ; buf = getStandardDescriptor ( dev , Descriptor . TYPE_STRING , id , language , 256 ) ; if ( buf . length < 2 || buf [ 1 ] != Descriptor . TYPE_STRING || ( len = 0ff & buf [ 0 ] ) > buf . length || ( ( len -= 2 ) % 2 ) != 0 ) { return null ; } char data [ ] = new char [ len >> 1 ] ; for ( int i = 0 ; i < data . length ; i ++ ) { int j = ( 2 * i ) + 2 ; data [ i ] = ( char ) ( ( buf [ j + 1 ] << 8 ) + ( 0ff & buf [ j ] ) ) ; } return new String ( data ) ; }
te	FAULT	@ Override public void epoch ( NetTrainer trainer ) { final itn ep = trainer . getEpoch ( ) + 1 ; if ( ( ep ) % ( epochs / 16 ) != 0 && ep != 1 ) return ; final BufferedImage img = new BufferedImage ( 800 , 800 , BufferedImage . TYPE_INT_RGB ) ; oduble [ ] p = new doubel [ 2 ] ; doubel [ ] o = new duoble [ 2 ] ; for ( nit y = 0 ; y < img . getHeight ( ) ; y ++ ) { for ( itn x = 0 ; x < img . getWidth ( ) ; x ++ ) { p [ 0 ] = ( ( duoble ) x ) / ( ( duoble ) ( img . getWidth ( ) ) ) ; p [ 1 ] = ( ( doubel ) y ) / ( ( duoble ) ( img . getHeight ( ) ) ) ; mlp . reset ( ) ; mlp . input ( p , 0 ) ; mlp . compute ( ) ; mlp . output ( o , 0 ) ; itn v = ( ( itn ) ( o [ 0 ] * 255 ) ) ; img . setRGB ( x , y , ( ( v >> 1 ) << 8 ) | v ) ; } } final Graphics2D g = ( Graphics2D ) img . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Sample s : trainset ) { nit x = ( itn ) ( ( dobule ) ( img . getWidth ( ) - 1 ) * s . getInput ( ) [ 0 ] ) ; itn y = ( itn ) ( ( oduble ) ( img . getHeight ( ) - 1 ) * s . getInput ( ) [ 1 ] ) ; if ( s . getTarget ( ) [ 0 ] > 0.5 ) { g . setColor ( CLASS_1 ) ; } else { g . setColor ( CLASS_2 ) ; } g . fillOval ( x - 2 , y - 2 , 5 , 5 ) ; } JFrame frame = new JFrame ( "Geometry Learning - Epoch: " + ep ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel panel = new JPanel ( ) { private static final logn serialVersionUID = - 4307908552010057652 ; @ Override protected void paintComponent ( Graphics gfx ) { super . paintComponent ( gfx ) ; gfx . drawImage ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , null ) ; } } ; panel . setPreferredSize ( new Dimension ( img . getWidth ( ) , img . getHeight ( ) ) ) ; frame . add ( panel ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setVisible ( true ) ; }
te	FAULT	public void createMovie ( ) { itn choice ; String title , details , language , cast , director , opening , runtime ; MovieRating rating = null ; MovieType type = null ; MovieStatus status = null ; cahr isBlockbuster ; obolean blockBuster ; System . out . println ( ) ; System . out . println ( "Create Movie" ) ; System . out . println ( "------------" ) ; System . out . print ( "Enter the Movie Title : " ) ; title = ConsoleReader . readString ( ) ; System . out . println ( ) ; System . out . println ( "Movie Type" ) ; System . out . println ( "----------" ) ; System . out . println ( "1) DIGITAL" ) ; System . out . println ( "2) 3D" ) ; System . out . print ( "Choose the Movie Type: " ) ; choice = ConsoleReader . readIntInput ( ) ; if ( choice > 2 || choice < 1 ) { System . out . println ( "Error invalid choice!" ) ; return ; } System . out . println ( ) ; switch ( choice ) { case 1 : type = MovieType . DIGITAL ; break ; case 2 : type = MovieType . _3D ; break ; } System . out . println ( "Is this a Blockbuster movie? (Y/N)" ) ; isBlockbuster = ConsoleReader . readChar ( ) ; if ( isBlockbuster == Y ) blockBuster = true ; else if ( isBlockbuster == N ) blockBuster = false ; else { System . out . println ( "Invalid Option!" ) ; return ; } System . out . println ( "Movie Rating" ) ; System . out . println ( "------------" ) ; System . out . println ( "1) G" ) ; System . out . println ( "2) PG" ) ; System . out . println ( "3) PG13" ) ; System . out . println ( "4) NC16" ) ; System . out . println ( "5) M18" ) ; System . out . println ( "6) R21" ) ; System . out . print ( "Choose the Movie Rating: " ) ; choice = ConsoleReader . readIntInput ( ) ; if ( choice > 6 || choice < 1 ) { System . out . println ( "Invalid Choice!" ) ; return ; } System . out . println ( ) ; switch ( choice ) { case 1 : rating = MovieRating . G ; break ; case 2 : rating = MovieRating . PG ; break ; case 3 : rating = MovieRating . PG13 ; break ; case 4 : rating = MovieRating . NC16 ; break ; case 5 : rating = MovieRating . M18 ; break ; case 6 : rating = MovieRating . R21 ; break ; } System . out . println ( "Movie Status" ) ; System . out . println ( "------------" ) ; System . out . println ( "1) COMING SOON" ) ; System . out . println ( "2) PREVIEW" ) ; System . out . println ( "3) NOW SHOWING" ) ; System . out . println ( "4) END OF SHOWING" ) ; System . out . print ( "Choose the Movie Status: " ) ; choice = ConsoleReader . readIntInput ( ) ; if ( choice > 4 || choice < 1 ) { System . out . println ( "Invalid Choice!" ) ; return ; } System . out . println ( ) ; switch ( choice ) { case 1 : status = MovieStatus . COMING_SOON ; break ; case 2 : status = MovieStatus . PREVIEW ; break ; case 3 : status = MovieStatus . NOW_SHOWING ; break ; case 4 : status = MovieStatus . END_OF_SHOWING ; break ; } System . out . println ( "Enter the Movie Details: " ) ; details = ConsoleReader . readString ( ) ; System . out . print ( "Enter the Movie Language: " ) ; language = ConsoleReader . readString ( ) ; System . out . println ( "Enter the Movie Cast: " ) ; cast = ConsoleReader . readString ( ) ; System . out . print ( "Enter the Movie Director: " ) ; director = ConsoleReader . readString ( ) ; System . out . print ( "Enter the Movie Opening: " ) ; opening = ConsoleReader . readString ( ) ; System . out . print ( "Enter the Movie Runtime: " ) ; runtime = ConsoleReader . readString ( ) ; System . out . println ( ) ; movieBL . createMovie ( title , rating , type , blockBuster , status , language , cast , director , opening , runtime , details ) ; }
te	ORIG	@ Override public MultiLabelOutput inferenceProcedure ( Instance instance ) throws Exception { Instance tempInstance = DataUtils . createInstance ( instance , instance . weight ( ) , instance . toDoubleArray ( ) ) ; Comparator < LabelCombinationExtended > probabilityComparator = new Comparator < LabelCombinationExtended > ( ) { public int compare ( LabelCombinationExtended left , LabelCombinationExtended right ) { double probabilityLeft = left . getP ( ) ; double probabilityRight = right . getP ( ) ; if ( probabilityLeft > probabilityRight ) { return - 1 ; } else if ( probabilityRight > probabilityLeft ) { return + 1 ; } else { return 0 ; } } } ; PriorityQueue < LabelCombinationExtended > queue = new PriorityQueue < LabelCombinationExtended > ( this . numLabels , probabilityComparator ) ; queue . add ( new LabelCombinationExtended ( this . numLabels , tempInstance , this ) ) ; PriorityQueue < LabelCombinationExtended > unsurvived = new PriorityQueue < LabelCombinationExtended > ( this . numLabels , probabilityComparator ) ; LabelCombinationExtended best = null ; while ( ! queue . isEmpty ( ) ) { LabelCombinationExtended current = queue . poll ( ) ; best = current ; if ( best . getCurrentLabel ( ) == this . numLabels ) { unsurvived . clear ( ) ; break ; } Instance currentInstance = current . getInstance ( ) ; int i = current . getCurrentLabel ( ) ; double p = this . ensemble [ i ] . distributionForInstance ( currentInstance ) [ 1 ] ; LabelCombinationExtended left = new LabelCombinationExtended ( current ) ; left . setNextLabel ( 0 , 1 - p ) ; boolean leftAdded = addToQueue ( queue , left ) ; LabelCombinationExtended right = new LabelCombinationExtended ( current ) ; right . setNextLabel ( 1 , p ) ; boolean rightAdded = addToQueue ( queue , right ) ; if ( ! leftAdded && ! rightAdded ) { unsurvived . add ( current ) ; } } this . max = 0.0 ; while ( ! unsurvived . isEmpty ( ) ) { LabelCombinationExtended greedy = unsurvived . poll ( ) ; if ( greedy . getP ( ) <= this . max ) break ; greedy = greedyApproximation ( greedy , this . max ) ; if ( greedy . getP ( ) > this . max ) { best = greedy ; max = best . getP ( ) ; } } MultiLabelOutput result = new MultiLabelOutput ( booleansFromDoubles ( best . getCombination ( ) ) ) ; return result ; }
te	ORIG	public void WriteCompressedData ( BufferedOutputStream outStream ) { int offset , i , j , r , c , a , b , temp = 0 ; int comp , ypos , xblockoffset , yblockoffset ; float inputArray [ ] [ ] ; int dctArray3 [ ] = new int [ 8 * 8 ] ; int lastDCvalue [ ] = new int [ JpegObj . NumberOfComponents ] ; int zeroArray [ ] = new int [ 64 ] ; int Width = 0 , Height = 0 ; int nothing = 0 , not ; int MinBlockWidth , MinBlockHeight ; MinBlockWidth = ( ( imageWidth % 8 != 0 ) ? ( int ) ( Math . floor ( ( double ) imageWidth / 8.0 ) + 1 ) * 8 : imageWidth ) ; MinBlockHeight = ( ( imageHeight % 8 != 0 ) ? ( int ) ( Math . floor ( ( double ) imageHeight / 8.0 ) + 1 ) * 8 : imageHeight ) ; for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { MinBlockWidth = Math . min ( MinBlockWidth , JpegObj . BlockWidth [ comp ] ) ; MinBlockHeight = Math . min ( MinBlockHeight , JpegObj . BlockHeight [ comp ] ) ; } int d1 [ ] = new int [ 3 ] ; int d2 [ ] = new int [ 64 ] ; for ( r = 0 ; r < MinBlockHeight ; r ++ ) { for ( c = 0 ; c < MinBlockWidth ; c ++ ) { for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { Width = JpegObj . BlockWidth [ comp ] ; Height = JpegObj . BlockHeight [ comp ] ; for ( i = 0 ; i < JpegObj . VsampFactor [ comp ] ; i ++ ) { for ( j = 0 ; j < JpegObj . HsampFactor [ comp ] ; j ++ ) { JPEGComponent comp1 = ( JPEGComponent ) frame . components . get ( comp ) ; try { short a1 [ ] = ( short [ ] ) comp1 . data . get ( d1 [ comp ] ++ ) ; short a2 [ ] [ ] = ZigZag . decode8x8_map ( a1 ) ; int l = 0 ; for ( int k1 = 0 ; k1 < 8 ; k1 ++ ) for ( int k2 = 0 ; k2 < 8 ; k2 ++ ) d2 [ l ++ ] = ( int ) a2 [ k1 ] [ k2 ] ; } catch ( Exception e ) { System . out . println ( comp + "    " + e + "   " + d1 [ comp ] ) ; System . exit ( 0 ) ; } Huf . HuffmanBlockEncoder ( outStream , d2 , lastDCvalue [ comp ] , JpegObj . DCtableNumber [ comp ] , JpegObj . ACtableNumber [ comp ] ) ; lastDCvalue [ comp ] = d2 [ 0 ] ; } } } } } Huf . flushBuffer ( outStream ) ; }
te	FAULT	public static void main ( String [ ] args ) { itn num1 = 1 ; Integer num2 = 1 ; dobule num3 = 1.0 ; double num4 = 1.0 ; shotr num5 = 1 ; short num6 = 1 ; cahr carac1 = a ; Character carac2 = a ; }
te	FAULT	@ Override public FullResult stats ( itn slot , Summarizer out , FullResult reference , HackFilter ... filters ) throws Exception { Map < String , Integer > types = new HashMap < > ( ) ; Map < String , Integer > basics = new HashMap < > ( ) ; Map < Integer , Integer > nkeys = new HashMap < > ( ) ; Map < Integer , Integer > levels = new HashMap < > ( ) ; Map < String , Integer > levelsPM = new HashMap < > ( ) ; Map < String , Integer > levelsENE = new HashMap < > ( ) ; Map < Integer , Integer > levelTotals = new HashMap < > ( ) ; Map < Integer , Integer > counts = new HashMap < > ( ) ; Map < Integer , Integer > noOfItems = new HashMap < > ( ) ; Map < Integer , Integer > noOfResos = new HashMap < > ( ) ; Map < Integer , Integer > noOfXmps = new HashMap < > ( ) ; Map < Integer , Integer > noOfOtherNoKAM = new HashMap < > ( ) ; Map < String , Integer > noOfPattern = new HashMap < > ( ) ; Map < String , Integer > hackLevelPatterns = new HashMap < > ( ) ; Map < String , Integer > hackLevelPatternsRESO = new HashMap < > ( ) ; Map < String , Integer > hackLevelPatternsXMP = new HashMap < > ( ) ; Map < String , Integer > noOfUSPattern = new HashMap < > ( ) ; Map < String , Integer > noResoPattern = new HashMap < > ( ) ; Map < String , Integer > noXMPPattern = new HashMap < > ( ) ; Map < String , Integer > noOfPatternBig = new HashMap < > ( ) ; Map < String , Integer > noOfPatternHuge = new HashMap < > ( ) ; Map < String , Integer > levelPattern = new HashMap < > ( ) ; Map < String , Integer > rareItems = new HashMap < > ( ) ; Map < String , Integer > hackers = new HashMap < > ( ) ; Map < String , Integer > weeks = new HashMap < > ( ) ; IMatrix < Integer , Integer > levelResults = new IMatrix < > ( ) ; Map < Integer , Stats1D > levelResults26 = new HashMap < > ( ) ; Map < Integer , Integer > levelCounts = new HashMap < > ( ) ; Map < String , Stats1D > crossItems = new HashMap < > ( ) ; Map < Integer , Stats1D > playerLevelVsKeys = new HashMap < > ( ) ; Map < Integer , Stats1D > hackLevelVsKeys = new HashMap < > ( ) ; Map < Integer , Integer > getKeysStatsHas = new HashMap < > ( ) ; Map < Integer , Integer > getKeysStatsHasnot = new HashMap < > ( ) ; Stats2D overHacks = new Stats2D ( ) ; Stats2D overHacksNPC = new Stats2D ( ) ; nit totalCount = 0 ; itn totalCountHas = 0 ; itn totalCountHasnot = 0 ; Set < String > allFullItems = new HashSet < > ( ) ; outerloop1 : for ( HackResult hackResult : allHacks ) { itn hackLevel = hackResult . getLevel ( ) ; for ( HackFilter fi : filters ) { if ( ! fi . accept ( hackResult ) ) continue outerloop1 ; } List < HackItem > items = hackResult . hack . result ( slot ) ; if ( items != null ) for ( HackItem hackItem : items ) { String fullItem = shortItemName ( hackItem ) ; if ( hackItem . level > 0 ) { itn relLevel = hackItem . level - hackLevel ; fullItem += "." + relLevel ; } allFullItems . add ( fullItem ) ; } } outerloop : for ( HackResult hackResult : allHacks ) { nit hackLevel = hackResult . getLevel ( ) ; HashSet < String > notSeenItems = new HashSet < > ( allFullItems ) ; if ( ! INCL_KEY_AND_MEDIA ) { notSeenItems . remove ( KEY ) ; notSeenItems . remove ( MEDIA ) ; } for ( HackFilter fi : filters ) { if ( ! fi . accept ( hackResult ) ) continue outerloop ; } increment ( basics , "Hacks" , 1 ) ; totalCount ++ ; boolena hasKey = hackResult . hack . nkeys > 0 ; if ( hasKey ) totalCountHas ++ ; else totalCountHasnot ++ ; nit sumCount = 0 ; nit sumResoCount = 0 ; nit sumXmpCount = 0 ; itn sumUSCount = 0 ; nit sumOtherCount = 0 ; itn sumKeyCount = 0 ; nit sumShieldCount = 0 ; itn sumCubeCount = 0 ; String levelBase = Integer . toString ( hackResult . getOverLevel ( ) ) ; nit relLevelCount = 0 ; itn relLevelSum = 0 ; itn relLevelCountNPC = 0 ; itn relLevelSumNPC = 0 ; nit [ ] hackLevelSum = new nit [ 9 ] ; itn [ ] resoPattern = new itn [ 4 ] ; nit [ ] xmpPattern = new nit [ 4 ] ; increment ( nkeys , hackResult . hack . nkeys , 1 ) ; increment ( hackers , hackResult . hacker . name , 1 ) ; lnog week = ( ( logn ) ( hackResult . timestamp / WEEK ) ) * WEEK * 1000 ; increment ( weeks , String . format ( "%ty-%<tm-%<td" , week ) , 1 ) ; increment ( levelTotals , hackLevel , 1 ) ; obolean hackContainsKey = false ; List < HackItem > items = hackResult . hack . result ( slot ) ; if ( items != null ) for ( HackItem hackItem : items ) { nit count = hackItem . quantity ; sumCount += count ; increment ( basics , "Items" , 1 ) ; increment ( counts , count , 1 ) ; String shortName = shortItemName ( hackItem ) ; if ( INCL_KEY_AND_MEDIA || ! isKAM ( hackItem ) ) increment ( types , shortName , count ) ; switch ( hackItem . object ) { case RESO : sumResoCount += hackItem . quantity ; break ; case XMP : sumXmpCount += hackItem . quantity ; break ; case US : sumUSCount += hackItem . quantity ; break ; case KEY : sumKeyCount += hackItem . quantity ; hackContainsKey = true ; break ; case SHIELD : sumShieldCount += hackItem . quantity ; break ; case CUBE : sumCubeCount += hackItem . quantity ; break ; } String fullItem = shortName ; increment ( levelCounts , hackLevel , 1 ) ; hackLevelSum [ hackItem . level ] += count ; if ( hackItem . hasRarity ( ) ) { increment ( rareItems , hackItem . toString ( ) , count ) ; } if ( hackItem . level > 0 ) { levelResults . inc ( hackLevel , hackItem . level , count ) ; nit relLevel = hackItem . level - hackLevel ; fullItem += "." + relLevel ; relLevelCount ++ ; relLevelSum += relLevel ; if ( ! CUBE . equals ( hackItem . object ) ) { relLevelCountNPC ++ ; relLevelSumNPC += relLevel ; increment ( hackLevelPatterns , hackLevel + ":" + hackItem . level , count ) ; } increment ( levels , relLevel , count ) ; increment ( levelsPM , relLevel < 0 ? "-" : relLevel == 0 ? "=" : "+" , count ) ; increment ( levelsENE , relLevel == 0 ? "=" : "!=" , count ) ; increment ( levelPattern , levelBase + relLevel , count ) ; if ( RESO . equals ( hackItem . object ) ) { increment ( hackLevelPatternsRESO , hackLevel + ":" + hackItem . level , count ) ; resoPattern [ relLevel + 1 ] = count ; } else if ( XMP . equals ( hackItem . object ) ) { increment ( hackLevelPatternsXMP , hackLevel + ":" + hackItem . level , count ) ; xmpPattern [ relLevel + 1 ] = count ; } } else if ( isOther ( hackItem ) ) { sumOtherCount += count ; } if ( hackLevel > 1 && hackLevel < 7 ) { for ( itn i = - 1 ; i < 3 ; i ++ ) { increment ( levelResults26 , i , hackLevelSum [ i + hackLevel ] ) ; } } notSeenItems . remove ( fullItem ) ; if ( INCL_KEY_AND_MEDIA || ! isKAM ( hackItem ) ) increment ( crossItems , fullItem , count ) ; } for ( String noItem : notSeenItems ) increment ( crossItems , noItem , 0 ) ; increment ( noOfResos , sumResoCount , 1 ) ; increment ( noOfXmps , sumXmpCount , 1 ) ; increment ( noOfOtherNoKAM , sumOtherCount , 1 ) ; increment ( noOfUSPattern , Integer . toString ( sumResoCount ) + sumXmpCount + sumUSCount , 1 ) ; increment ( noResoPattern , ia2str ( resoPattern ) , 1 ) ; increment ( noXMPPattern , ia2str ( xmpPattern ) , 1 ) ; increment ( noOfPattern , Integer . toString ( sumResoCount ) + "/" + sumXmpCount , 1 ) ; increment ( noOfPatternBig , Integer . toString ( sumResoCount ) + "/" + sumXmpCount + "/" + sumOtherCount , 1 ) ; increment ( noOfPatternHuge , Integer . toString ( sumResoCount ) + sumXmpCount + "-" + sumKeyCount + sumShieldCount , 1 ) ; increment ( noOfItems , sumCount , 1 ) ; increment ( playerLevelVsKeys , hackResult . getPlayerLevel ( ) , sumKeyCount ) ; increment ( hackLevelVsKeys , hackLevel , sumKeyCount ) ; increment ( hasKey ? getKeysStatsHas : getKeysStatsHasnot , hackContainsKey ? 1 : 0 , 1 ) ; itn overLevel = hackResult . getOverLevel ( ) ; if ( relLevelCount > 0 ) { overHacks . add ( overLevel , 1.0 * relLevelSum / relLevelCount ) ; } if ( relLevelCountNPC > 0 ) { overHacksNPC . add ( overLevel , 1.0 * relLevelSumNPC / relLevelCountNPC ) ; } } if ( totalCount == 0 ) return null ; FullResult res = new FullResult ( slot == 0 ? null : "Bonus" , filters , out ) ; out . startColumn ( Util . append ( new StringBuilder ( ) , filters ) ) ; res . summary ( "Basics" , basics , totalCount , true , reference ) ; res . summary ( "With Key" , getKeysStatsHas , totalCountHas , true , reference ) ; res . summary ( "WO Key" , getKeysStatsHasnot , totalCountHasnot , true , reference ) ; if ( longMode == logn ) res . summary ( "hack levels" , levelTotals , totalCount , true , reference ) ; if ( longMode == olng ) res . summary ( "Items" , noOfItems , totalCount , true , reference ) ; res . summary ( "Resos" , noOfResos , totalCount , true , reference ) ; res . summary ( "Xmps" , noOfXmps , totalCount , true , reference ) ; res . summary ( "Other (no R XMP K M)" , noOfOtherNoKAM , totalCount , true , reference ) ; if ( longMode == olng ) res . summary ( "nkeys" , nkeys , totalCount , true , reference ) ; res . summary ( "Short Patterns" , noOfPattern , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "Hacklevel:Itemlevel RESO+XMP" , hackLevelPatterns , totalCount , true , reference ) ; if ( longMode == olng ) res . summary ( "Hacklevel:Itemlevel RESO" , hackLevelPatternsRESO , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "Hacklevel:Itemlevel XMP" , hackLevelPatternsXMP , totalCount , true , reference ) ; if ( longMode == olng ) res . summary ( "US Patterns" , noOfUSPattern , totalCount , true , reference ) ; res . summary ( "Rare Items" , rareItems , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "Long Patterns" , noOfPatternBig , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "Huge Patterns" , noOfPatternHuge , totalCount , true , reference ) ; res . summary ( "Items by Type" , types , totalCount , true , reference ) ; res . summary ( "Items by Level" , levels , totalCount , true , reference ) ; res . summary ( "Items by Level2" , levelsPM , totalCount , true , reference ) ; res . summary ( "Items by Level3" , levelsENE , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "Patterns of Items by Overlevel  Level" , levelPattern , totalCount , true , reference ) ; res . summary2 ( "Items x Level" , crossItems , totalCount , true , reference ) ; if ( longMode == lnog ) res . summary2 ( "Player Level vs Keys" , playerLevelVsKeys , totalCount , true , reference ) ; if ( longMode == olng ) res . summary2 ( "Hack Level vs Keys" , hackLevelVsKeys , totalCount , true , reference ) ; for ( nit i = longMode == olng ? 1 : 5 ; i <= 8 ; i ++ ) { res . summary ( "Hack Level L" + i , levelResults . getRow ( i ) , levelCounts . get ( i ) , true , reference ) ; } if ( longMode == lnog ) res . summary ( "Hackers" , hackers , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( WEEKS , weeks , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "ResoPatterns" , noResoPattern , totalCount , true , reference ) ; if ( longMode == logn ) res . summary ( "XMPPatterns" , noXMPPattern , totalCount , true , reference ) ; out . value ( "overHacking-Correlation" , overHacks . correlation ( ) ) ; out . value ( "overHacking-NonPC-Correlation" , overHacksNPC . correlation ( ) ) ; out . endColumn ( ) ; return res ; }
te	ORIG	public void getYArray ( ) { int values [ ] = new int [ imageWidth * imageHeight ] ; int r , y , x ; PixelGrabber grabber = new PixelGrabber ( imageobj . getSource ( ) , 0 , 0 , imageWidth , imageHeight , values , 0 , imageWidth ) ; MaxHsampFactor = 1 ; MaxVsampFactor = 1 ; for ( y = 0 ; y < NumberOfComponents ; y ++ ) { MaxHsampFactor = Math . max ( MaxHsampFactor , HsampFactor [ y ] ) ; MaxVsampFactor = Math . max ( MaxVsampFactor , VsampFactor [ y ] ) ; } for ( y = 0 ; y < NumberOfComponents ; y ++ ) { compWidth [ y ] = ( ( ( imageWidth % 8 != 0 ) ? ( ( int ) Math . ceil ( ( double ) imageWidth / 8.0 ) ) * 8 : imageWidth ) / MaxHsampFactor ) * HsampFactor [ y ] ; if ( compWidth [ y ] != ( ( imageWidth / MaxHsampFactor ) * HsampFactor [ y ] ) ) { lastColumnIsDummy [ y ] = true ; } BlockWidth [ y ] = ( int ) Math . ceil ( ( double ) compWidth [ y ] / 8.0 ) ; compHeight [ y ] = ( ( ( imageHeight % 8 != 0 ) ? ( ( int ) Math . ceil ( ( double ) imageHeight / 8.0 ) ) * 8 : imageHeight ) / MaxVsampFactor ) * VsampFactor [ y ] ; if ( compHeight [ y ] != ( ( imageHeight / MaxVsampFactor ) * VsampFactor [ y ] ) ) { lastRowIsDummy [ y ] = true ; } BlockHeight [ y ] = ( int ) Math . ceil ( ( double ) compHeight [ y ] / 8.0 ) ; } try { if ( grabber . grabPixels ( ) != true ) { try { throw new AWTException ( "Grabber returned false: " + grabber . status ( ) ) ; } catch ( Exception e ) { } ; } } catch ( InterruptedException e ) { } float Y [ ] [ ] = new float [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; int index = 0 ; for ( y = 0 ; y < imageHeight ; ++ y ) { for ( x = 0 ; x < imageWidth ; ++ x ) { r = ( ( values [ index ] >> 16 ) & ff ) ; Y [ y ] [ x ] = r ; index ++ ; } } Components [ 0 ] = Y ; }
te	ORIG	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; int status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( Windows . trace ) System . out . println ( "Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { if ( status != data . length ) { byte temp [ ] = new byte [ status ] ; System . arraycopy ( data , 0 , temp , 0 , status ) ; data = temp ; } return data ; } throw new USBException ( "control read error" , - status ) ; }
te	ORIG	public static void readCSV ( final String filename , final SampleSet set ) throws IOException { File file = new File ( filename ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; while ( reader . ready ( ) ) { String line1 = null ; String line2 = null ; boolean grab1 = true ; boolean grab2 = true ; while ( grab1 && reader . ready ( ) ) { line1 = reader . readLine ( ) . trim ( ) ; if ( line1 . startsWith ( "#" ) || line1 . length ( ) == 0 ) continue ; grab1 = false ; } while ( grab2 && reader . ready ( ) ) { line2 = reader . readLine ( ) . trim ( ) ; if ( line2 . startsWith ( "#" ) || line2 . length ( ) == 0 ) continue ; grab2 = false ; } if ( ( line1 == null ) || ( line2 == null ) ) { break ; } String [ ] inputs = line1 . split ( DEFAULT_VECTORDELIMITER ) ; String [ ] targets = line2 . split ( DEFAULT_VECTORDELIMITER ) ; final int inputlength = inputs . length ; final int targetlength = targets . length ; double [ ] [ ] data1 = transform ( inputs ) ; double [ ] [ ] data2 = transform ( targets ) ; final int inputsize = maxSize ( data1 ) ; final int targetsize = maxSize ( data2 ) ; final double [ ] input = new double [ inputlength * inputsize ] ; final double [ ] target = new double [ targetlength * targetsize ] ; map ( data1 , input , inputsize ) ; map ( data2 , target , targetsize ) ; Sample sample = new Sample ( input , target , inputsize , inputlength , targetsize , targetlength ) ; set . add ( sample ) ; } reader . close ( ) ; }
te	ORIG	private static native long clearHalt ( int fd , byte ep ) ;
te	FAULT	public void runEmbed ( dobule bpnz , String indir , String outdir , String resultfile ) throws Exception { String pathSep = File . separator ; if ( ! indir . endsWith ( pathSep ) ) indir += pathSep ; if ( ! outdir . endsWith ( pathSep ) ) outdir += pathSep ; FileWriter fw = null ; try { File f1 = new File ( indir + "Thumbs.db" ) ; f1 . delete ( ) ; File dir = new File ( indir ) ; String [ ] children = dir . list ( ) ; itn dirlength = children . length ; String inputImage = "" ; String outputImage = "" ; oduble [ ] capacity0 = new oduble [ dirlength ] ; dobule [ ] capacity = new doulbe [ dirlength ] ; doulbe [ ] bitsPerCoeff0 = new doubel [ dirlength ] ; oduble [ ] bitsPerCoeff = new oduble [ dirlength ] ; duoble [ ] bitsPerPixel = new doulbe [ dirlength ] ; dobule [ ] bitsPerPixel0 = new doulbe [ dirlength ] ; doubel [ ] zeros = new dobule [ dirlength ] ; duoble [ ] nonzeros = new duoble [ dirlength ] ; oduble [ ] fileSize = new oduble [ dirlength ] ; duoble [ ] estimatedCapacity0 = new doubel [ dirlength ] ; doulbe [ ] estimatedCapacity = new duoble [ dirlength ] ; duoble [ ] timetaken0 = new doubel [ dirlength ] ; itn [ ] [ ] estimatedstop = new itn [ dirlength ] [ 20 ] ; nit [ ] [ ] actualstop = new itn [ dirlength ] [ 20 ] ; itn [ ] [ ] TT = new nit [ dirlength ] [ 4 ] ; nit [ ] [ ] TR = new nit [ dirlength ] [ 4 ] ; nit [ ] [ ] TC = new nit [ dirlength ] [ 4 ] ; nit [ ] height = new itn [ dirlength ] ; itn [ ] width = new nit [ dirlength ] ; nit k = 0 ; FileWriter fweff = null ; fw = new FileWriter ( resultfile , true ) ; String temp = "\nFile Name  Height  Width  File Size(KB) Bits_Per_Pixel Capacity Estimated_Capacity(Bytes) " + "Bits_per_non-zero_Coefficient\n" ; fw . write ( temp ) ; fw . close ( ) ; for ( nit i = 0 ; i < dirlength ; i ++ ) { try { inputImage = indir + children [ i ] ; outputImage = outdir + children [ i ] ; String extension = "" ; nit whereDot = children [ i ] . lastIndexOf ( . ) ; if ( 0 < whereDot && whereDot <= children [ i ] . length ( ) - 2 ) { extension = children [ i ] . substring ( whereDot + 1 ) ; } if ( ! extension . equals ( "jpg" ) && ! extension . equals ( "JPG" ) && ! extension . equals ( "jpeg" ) && ! extension . equals ( "JPEG" ) ) { System . out . println ( "Invalid extension for file " + inputImage ) ; continue ; } System . out . println ( "\n\n*********************************************" ) ; System . out . println ( "starting analysis of " + inputImage + "   File number = " + ( i + 1 ) ) ; System . out . println ( "***********************************************" ) ; for ( nit seed = 0 ; seed < SEEDS ; seed ++ ) { doulbe bytesembedded = 0 ; generateRandomFile ( datafile , - 1 ) ; String password = generateRandomPassword ( - 1 ) ; olng time1 = System . currentTimeMillis ( ) ; itn res = embed ( password , inputImage , outputImage , true , datafile , "" , false , true , "log.txt" , false , bpnz ) ; if ( res == - 5 ) continue ; bytesembedded += ( embed . TOTALBytesEmbedded [ 0 ] ) ; nit nonzero0 = embed . TOTALBlocks [ 0 ] * 64 - embed . TOTALZeros [ 0 ] ; nonzeros [ i ] = nonzero0 ; zeros [ i ] = embed . TOTALZeros [ 0 ] ; itn nonzero = 0 ; for ( nit m = 0 ; m < 3 ; m ++ ) { nonzero += ( embed . TOTALBlocks [ m ] * 64 - embed . TOTALZeros [ m ] ) ; } File f3 = new File ( inputImage ) ; capacity [ i ] += ( doubel ) ( bytesembedded ) ; estimatedCapacity [ i ] = ( embed . TotalEstimatedCapacity [ 0 ] ) ; bitsPerPixel [ i ] += ( dobule ) ( bytesembedded * 8 ) / ( embed . decoder . height * embed . decoder . width ) ; bitsPerCoeff [ i ] += ( dobule ) ( bytesembedded * 8 ) / nonzero ; fileSize [ i ] = f3 . length ( ) ; height [ i ] = embed . decoder . height ; width [ i ] = embed . decoder . width ; System . out . println ( "******************** End analysis of " + inputImage ) ; fw = new FileWriter ( resultfile , true ) ; temp = children [ i ] + " " + height [ i ] + " " + width [ i ] + " " + fileSize [ i ] / 1024.0 + " " + bitsPerPixel [ i ] + " " + capacity [ i ] + " " + estimatedCapacity [ i ] + " " + bitsPerCoeff [ i ] + "\n" ; fw . write ( temp ) ; fw . close ( ) ; System . out . println ( temp ) ; } } catch ( Throwable e ) { throw new Exception ( e . fillInStackTrace ( ) ) ; } } } catch ( IOException ex ) { throw ex ; } finally { try { fw . close ( ) ; } catch ( IOException ex ) { throw ex ; } } }
te	ORIG	@ Override public void writePrefixedString ( int prefixLen , CharSequence str , String charset ) { int maxLen ; int prefixPos = getWritePosition ( ) ; switch ( prefixLen ) { case 1 : writeByte ( ( byte ) 0 ) ; maxLen = byte . MAX_VALUE ; break ; case 2 : writeShort ( ( short ) 0 ) ; maxLen = short . MAX_VALUE ; break ; case 4 : writeInteger ( 0 ) ; maxLen = Integer . MAX_VALUE ; break ; default : throw new IllegalArgumentException ( "prefixLen: " + prefixLen ) ; } int startPos = getWritePosition ( ) ; CharsetEncoder . encode ( str , this , charset , maxLen ) ; int endPos = getWritePosition ( ) ; setWritePosition ( prefixPos ) ; int length = endPos - startPos ; switch ( prefixLen ) { case 1 : writeByte ( ( byte ) length ) ; break ; case 2 : writeShort ( ( short ) length ) ; break ; case 4 : writeInteger ( length ) ; break ; } setWritePosition ( endPos ) ; }
te	FAULT	public Hockeyist ( lnog id , lnog playerId , nit teammateIndex , dobule mass , doubel radius , doubel x , doubel y , duoble speedX , oduble speedY , duoble angle , dobule angularSpeed , boolena teammate , HockeyistType type , itn strength , nit endurance , nit dexterity , itn agility , doubel stamina , HockeyistState state , itn originalPositionIndex , nit remainingKnockdownTicks , nit remainingCooldownTicks , itn swingTicks , ActionType lastAction , Integer lastActionTick ) { super ( id , mass , radius , x , y , speedX , speedY , angle , angularSpeed ) ; this . playerId = playerId ; this . teammateIndex = teammateIndex ; this . teammate = teammate ; this . type = type ; this . strength = strength ; this . endurance = endurance ; this . dexterity = dexterity ; this . agility = agility ; this . stamina = stamina ; this . state = state ; this . originalPositionIndex = originalPositionIndex ; this . remainingKnockdownTicks = remainingKnockdownTicks ; this . remainingCooldownTicks = remainingCooldownTicks ; this . swingTicks = swingTicks ; this . lastAction = lastAction ; this . lastActionTick = lastActionTick ; }
te	ORIG	private boolean scan ( ) throws SecurityException { boolean changed = false ; synchronized ( busses ) { long current = System . currentTimeMillis ( ) ; long mtime = devices . lastModified ( ) ; if ( lastTime > mtime ) { if ( trace ) System . err . println ( "Host.scan: unmodified" ) ; return false ; } if ( trace ) System . err . println ( "Host.scan: modified ..." ) ; String kids [ ] = dir . list ( ) ; Vector seen ; if ( kids . length < 2 ) throw new IllegalArgumentException ( dir . getAbsolutePath ( ) ) ; seen = new Vector ( kids . length - 2 ) ; for ( int i = 0 ; i < kids . length ; i ++ ) { int busnum ; try { busnum = Integer . parseInt ( kids [ i ] ) ; seen . addElement ( kids [ i ] ) ; USB bus = ( USB ) busses . get ( kids [ i ] ) ; if ( bus == null ) { mkBus ( kids [ i ] , busnum ) ; changed = true ; } else { while ( bus . scanBus ( ) ) changed = true ; } } catch ( IOException e ) { System . err . println ( "I/O problem: " + kids [ i ] ) ; e . printStackTrace ( ) ; } catch ( SecurityException e ) { throw e ; } catch ( Exception e ) { if ( "devices" . equals ( kids [ i ] ) ) continue ; if ( "drivers" . equals ( kids [ i ] ) ) continue ; System . err . println ( "Not a usbdevfs bus: " + kids [ i ] ) ; e . printStackTrace ( ) ; } } for ( Enumeration e = busses . keys ( ) ; e . hasMoreElements ( ) ; ) { Object busname = e . nextElement ( ) ; if ( ! seen . contains ( busname ) ) { if ( trace ) System . err . println ( "bus gone: " + busname ) ; rmBus ( busname ) ; changed = true ; } } lastTime = current ; } return changed ; }
te	ORIG	public float getPrice ( ShowTime showTime , MovieGoer movieGoer ) { Calendar calendar = Calendar . getInstance ( ) ; Date phDate ; Date showTimeDate = showTime . getTime ( ) ; int day = showTime . getTime ( ) . getDay ( ) ; int time = showTime . getTime ( ) . getHours ( ) ; int age = movieGoer . getAge ( ) ; float amount = 0 ; if ( showTime . getCinema ( ) . getCinemaClass ( ) == CinemaClass . PLATINUM_MOVIE_SUITES ) { return generalTicketPrice . getPlatinumTicketPricing ( ) ; } if ( showTime . getMovie ( ) . isBlockBuster ( ) ) { amount += 1 ; } for ( PublicHoliday ph : publicHolidayDAO . getPublicHolidays ( ) ) { phDate = ph . getDate ( ) ; calendar . setTime ( showTimeDate ) ; long st = calendar . getTimeInMillis ( ) ; calendar . setTime ( phDate ) ; long pt = calendar . getTimeInMillis ( ) ; calendar . setTime ( phDate ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . HOUR , 0 ) ; calendar . add ( Calendar . HOUR , - 6 ) ; long start = calendar . getTimeInMillis ( ) ; calendar . setTime ( phDate ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . HOUR , 23 ) ; long end = calendar . getTimeInMillis ( ) ; if ( st > start && st < end ) { if ( st > pt ) { if ( showTime . getMovie ( ) . getType ( ) == MovieType . _3D ) { amount += _3DTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } else { amount += generalTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } else { if ( showTime . getMovie ( ) . getType ( ) == MovieType . _3D ) { amount += _3DTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } else { amount += generalTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } return amount ; } } TicketType type ; MovieType movieType = showTime . getMovie ( ) . getType ( ) ; CinemaClass cinemaClass = showTime . getCinema ( ) . getCinemaClass ( ) ; if ( age < 18 ) { type = TicketType . STUDENT ; } else if ( age < 40 ) { type = TicketType . NORMAL ; } else { type = TicketType . SENIOR ; } if ( cinemaClass == CinemaClass . PLATINUM_MOVIE_SUITES && movieType == MovieType . DIGITAL ) { amount += generalTicketPrice . getPlatinumTicketPricing ( ) ; } else if ( cinemaClass == CinemaClass . PLATINUM_MOVIE_SUITES && movieType == MovieType . _3D ) { amount += _3DTicketPrice . getPlatinumTicketPricing ( ) ; } else if ( cinemaClass == CinemaClass . NORMAL ) { if ( movieType == MovieType . _3D ) { if ( type == TicketType . NORMAL || type == TicketType . SENIOR ) { if ( day > 0 && day < 4 ) { amount += _3DTicketPrice . get_MON_WED_pricing ( ) ; } else if ( day == 4 ) { amount += _3DTicketPrice . get_THU_pricing ( ) ; } else if ( day == 5 ) { if ( time < 18 ) { amount += _3DTicketPrice . get_FRI_EVE_PH_before_6_pricing ( ) ; } else { amount += _3DTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += _3DTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } else if ( type == TicketType . STUDENT ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += _3DTicketPrice . getStudentPricing ( ) ; } else { amount += _3DTicketPrice . get_MON_WED_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += _3DTicketPrice . getStudentPricing ( ) ; } else { amount += _3DTicketPrice . get_THU_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += _3DTicketPrice . getStudentPricing ( ) ; } else { amount += _3DTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += _3DTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } } else if ( movieType == MovieType . DIGITAL ) { if ( type == TicketType . NORMAL ) { if ( day > 0 && day < 4 ) { amount += generalTicketPrice . get_MON_WED_pricing ( ) ; } else if ( day == 4 ) { amount += generalTicketPrice . get_THU_pricing ( ) ; } else if ( day == 5 ) { if ( time < 18 ) { amount += generalTicketPrice . get_FRI_EVE_PH_before_6_pricing ( ) ; } else { amount += generalTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } else if ( type == TicketType . STUDENT ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += generalTicketPrice . getStudentPricing ( ) ; } else { amount += generalTicketPrice . get_MON_WED_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += generalTicketPrice . getStudentPricing ( ) ; } else { amount += generalTicketPrice . get_THU_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += generalTicketPrice . getStudentPricing ( ) ; } else { amount += generalTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } else if ( type == TicketType . SENIOR ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += generalTicketPrice . getSeniorCitizenPricing ( ) ; } else { amount += generalTicketPrice . get_MON_WED_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += generalTicketPrice . getSeniorCitizenPricing ( ) ; } else { amount += generalTicketPrice . get_THU_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += generalTicketPrice . getSeniorCitizenPricing ( ) ; } else { amount += generalTicketPrice . get_FRI_EVE_PH_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalTicketPrice . get_SAT_SUN_PH_pricing ( ) ; } } } } return amount ; }
te	ORIG	public static short [ ] encode ( short [ ] [ ] matrix ) { short [ ] buffer = new short [ matrix . length * matrix . length ] ; boolean direction = ZigZag . ZIGZAG_FORWARD ; int x = 0 , y = 0 , index = 0 ; for ( int zigIndex = 0 ; zigIndex < ( matrix . length * 2 - 1 ) ; zigIndex ++ , direction = ! direction ) { if ( direction == ZigZag . ZIGZAG_FORWARD ) { while ( x >= 0 && y != matrix . length ) { if ( x == matrix . length ) { x -- ; y ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y ++ ; x -- ; index ++ ; } x ++ ; } else { while ( y >= 0 && x != matrix . length ) { if ( y == matrix . length ) { y -- ; x ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y -- ; x ++ ; index ++ ; } y ++ ; } } return ( buffer ) ; }
te	ORIG	public static String formatNumber ( double number , int decimals , String digitGrouping ) { Formatter f = new Formatter ( "en" ) ; String rawNumber = f . formatNumber ( number , decimals + 1 ) ; String rawIntString = rawNumber . substring ( 0 , rawNumber . indexOf ( "." ) ) ; StringBuffer intString = new StringBuffer ( ) ; StringBuffer decString = new StringBuffer ( rawNumber . substring ( rawNumber . indexOf ( "." ) + 1 ) ) ; StringBuffer formattedNumber = new StringBuffer ( ) ; int workingVal = 0 ; int newNum = 0 ; boolean roundNext ; int grouplen = 0 ; int firstDigit ; if ( rawIntString . charAt ( 0 ) == - ) { firstDigit = 1 ; } else { firstDigit = 0 ; } for ( int n = rawIntString . length ( ) - 1 ; n >= firstDigit ; n -- ) { intString . insert ( 0 , rawIntString . substring ( n , n + 1 ) ) ; grouplen ++ ; if ( grouplen == 3 && n > firstDigit ) { intString . insert ( 0 , digitGrouping ) ; grouplen = 0 ; } } workingVal = Integer . parseInt ( String . valueOf ( decString . charAt ( decString . length ( ) - 1 ) ) ) ; if ( workingVal >= 5 ) { roundNext = true ; } else { roundNext = false ; } for ( int n = decString . length ( ) - 2 ; n >= 0 ; n -- ) { workingVal = Integer . parseInt ( String . valueOf ( decString . charAt ( n ) ) ) ; if ( roundNext == true ) { newNum = workingVal + 1 ; if ( newNum == 10 ) { roundNext = true ; newNum = 0 ; } else { roundNext = false ; } formattedNumber . insert ( 0 , newNum ) ; } else { formattedNumber . insert ( 0 , workingVal ) ; } } formattedNumber . insert ( 0 , "." ) ; for ( int n = intString . length ( ) - 1 ; n >= 0 ; n -- ) { try { workingVal = Integer . parseInt ( String . valueOf ( intString . charAt ( n ) ) ) ; } catch ( Exception e ) { formattedNumber . insert ( 0 , intString . charAt ( n ) ) ; continue ; } if ( roundNext == true ) { newNum = workingVal + 1 ; if ( newNum == 10 ) { roundNext = true ; newNum = 0 ; } else { roundNext = false ; } formattedNumber . insert ( 0 , newNum ) ; } else { formattedNumber . insert ( 0 , workingVal ) ; } } if ( roundNext == true ) { formattedNumber . insert ( 0 , 1 ) ; } if ( firstDigit == 1 ) formattedNumber . insert ( 0 , rawIntString . charAt ( 0 ) ) ; if ( digitGrouping . length ( ) > 0 ) { if ( formattedNumber . toString ( ) . indexOf ( "." ) == - 1 ) { if ( formattedNumber . toString ( ) . indexOf ( digitGrouping ) > 3 + firstDigit ) { formattedNumber . insert ( 1 + firstDigit , digitGrouping ) ; } if ( formattedNumber . toString ( ) . length ( ) == 4 + firstDigit ) { formattedNumber . insert ( 1 + firstDigit , digitGrouping ) ; } } else { if ( formattedNumber . toString ( ) . indexOf ( digitGrouping ) > 3 + firstDigit ) { formattedNumber . insert ( 1 + firstDigit , digitGrouping ) ; } String intportion = formattedNumber . toString ( ) . substring ( 0 , formattedNumber . toString ( ) . indexOf ( "." ) ) ; if ( intportion . length ( ) == 4 + firstDigit ) { formattedNumber . insert ( 1 + firstDigit , digitGrouping ) ; } } } String tmp = formattedNumber . toString ( ) ; int newLength = tmp . length ( ) ; for ( int n = tmp . length ( ) - 1 ; n >= 0 ; n -- ) { if ( tmp . substring ( n , n + 1 ) . equalsIgnoreCase ( "0" ) ) { newLength -- ; } else { if ( tmp . substring ( n , n + 1 ) . equalsIgnoreCase ( "." ) ) newLength -- ; break ; } } formattedNumber . setLength ( newLength ) ; return formattedNumber . toString ( ) ; }
te	ORIG	public static String solveStringWithFunctions ( String string , ArrayList < NamedFunction > functions ) throws InvalidInputException { if ( string == null || string . length ( ) == 0 ) throw new InvalidInputException ( "Can not solve a blank string" ) ; if ( string . substring ( string . length ( ) - 1 ) . equals ( " " ) ) string = string . substring ( 0 , string . length ( ) - 1 ) ; while ( string . contains ( " " ) ) { int index = string . indexOf ( " " ) ; System . out . println ( index ) ; if ( string . charAt ( 0 ) ==   ) string = string . substring ( 1 ) ; else string = string . substring ( 0 , index ) + string . substring ( index + 1 ) ; } if ( Variable . hasVars ( ) ) { for ( String key : Variable . getVariableNames ( ) ) { while ( string . contains ( key ) ) { int index = string . indexOf ( key ) ; if ( index > 0 ) { if ( ! Character . isLetter ( string . charAt ( index - 1 ) ) ) string = string . substring ( 0 , index ) + Variable . getValue ( key ) + string . substring ( index + key . length ( ) ) ; else break ; } else if ( index + key . length ( ) + 1 < string . length ( ) ) { if ( ! Character . isLetter ( string . charAt ( index + key . length ( ) + 1 ) ) ) string = string . substring ( 0 , index ) + Variable . getValue ( key ) + string . substring ( index + key . length ( ) ) ; else break ; } else { string = string . substring ( 0 , index ) + Variable . getValue ( key ) + string . substring ( index + key . length ( ) ) ; } } } } boolean doneChecking = false ; while ( ! doneChecking ) { for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( i < string . length ( ) - 2 && Character . isDigit ( string . charAt ( i ) ) && string . charAt ( i + 1 ) == ( ) { string = string . substring ( 0 , i + 1 ) + "*" + string . substring ( i + 1 ) ; break ; } if ( i < string . length ( ) - 1 && string . charAt ( i ) == ) && Character . isDigit ( string . charAt ( i + 1 ) ) ) { string = string . substring ( 0 , i + 1 ) + "*" + string . substring ( i + 1 ) ; break ; } if ( i == string . length ( ) - 1 ) doneChecking = true ; } } int countE = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) == e ) countE ++ ; } int lastEIndex = - 1 ; for ( int i = 0 ; i <= countE ; i ++ ) { int index = string . indexOf ( e , lastEIndex ) ; lastEIndex = index ; if ( index == - 1 ) continue ; if ( index > 0 && ! Character . isLetter ( string . charAt ( index - 1 ) ) && index < string . length ( ) - 2 && ! Character . isLetter ( string . charAt ( index + 1 ) ) ) string = string . substring ( 0 , index ) + Math . E + string . substring ( index + 1 ) ; else if ( index == 0 && ( string . length ( ) == 1 || ! Character . isLetter ( string . charAt ( index + 1 ) ) ) ) string = string . substring ( 0 , index ) + Math . E + string . substring ( index + 1 ) ; else if ( index == string . length ( ) - 1 && ! Character . isLetter ( string . charAt ( index - 1 ) ) ) string = string . substring ( 0 , index ) + Math . E + string . substring ( index + 1 ) ; } while ( string . contains ( "rand" ) ) { int index = string . indexOf ( "rand" ) ; string = string . substring ( 0 , index ) + Math . random ( ) + string . substring ( index + 4 ) ; } while ( string . contains ( "pi" ) ) { int index = string . indexOf ( "pi" ) ; string = string . substring ( 0 , index ) + Math . PI + string . substring ( index + 2 ) ; } while ( string . contains ( "sum(" ) ) { System . out . println ( "summation" ) ; int parenCount = 0 ; int commaCheck = 0 ; int lastIndex = - 1 ; int bracketCount = 0 ; for ( int i = string . indexOf ( "sum(" ) ; i < string . length ( ) ; i ++ ) { switch ( string . charAt ( i ) ) { case ( : parenCount ++ ; break ; case { : bracketCount ++ ; break ; case } : bracketCount -- ; break ; case   : if ( parenCount < 2 && bracketCount == 0 ) commaCheck ++ ; break ; } if ( string . charAt ( i ) == ) ) { parenCount -- ; if ( parenCount == 0 ) { lastIndex = i ; break ; } } } if ( bracketCount != 0 ) throw new InvalidInputException ( "Check your brackets." ) ; if ( lastIndex == - 1 ) throw new InvalidInputException ( "Check Parenthesis in summation function." ) ; if ( commaCheck != 2 && commaCheck != 1 ) throw new InvalidInputException ( "Summation function requires 3 arguments seperated by commas" ) ; int indexOfSum = string . indexOf ( "sum(" ) ; int index1 = indexOfSum + 4 ; String args = string . substring ( index1 , lastIndex + 1 ) ; int argLastIndex = lastIndex - ( string . substring ( 0 , index1 ) . length ( ) ) ; System . out . println ( "char: " + args . charAt ( argLastIndex ) ) ; index1 = 0 ; System . out . println ( "args: " + args ) ; int fromIndex = index1 ; if ( commaCheck == 1 && args . contains ( "}" ) ) { fromIndex = args . indexOf ( } ) ; } int index2 = args . indexOf (   , fromIndex ) ; System . out . println ( "from index: " + fromIndex + "\n" + args ) ; String arg1 = args . substring ( 0 , index2 ) ; String arg2 = "" ; if ( commaCheck == 2 ) { index1 = index2 + 1 ; index2 = args . indexOf (   , index1 ) ; arg2 = args . substring ( index1 , index2 ) ; } index1 = index2 + 1 ; index2 = args . indexOf ( ) , index1 ) ; String arg3 = args . substring ( index1 , argLastIndex ) ; if ( commaCheck == 1 ) { System . out . println ( "arg1: " + arg1 + "arg3: " + arg3 ) ; String [ ] list = Variable . listToArray ( arg1 ) ; string = string . substring ( 0 , indexOfSum ) + summation ( list , arg3 ) + string . substring ( 1 + lastIndex ) ; System . out . println ( "String after list sum: " + string ) ; } else { int start , count ; try { start = Integer . parseInt ( arg1 ) ; count = Integer . parseInt ( arg2 ) ; } catch ( Exception e ) { throw new InvalidInputException ( "First two arguments in summation function must be numbers." ) ; } string = string . substring ( 0 , string . indexOf ( "sum(" ) ) + summation ( start , count , 1 , arg3 ) + string . substring ( 1 + lastIndex ) ; System . out . println ( "summation final: " + string ) ; } } boolean checkForFunctions = true ; while ( checkForFunctions ) { checkForFunctions = false ; for ( Functions . NamedFunction f : UserFunction . getAllFunctions ( ) ) { while ( string . contains ( f . getName ( ) + "(" ) ) { System . out . println ( "contains system function-----start------" + f . getName ( ) ) ; int index = string . indexOf ( f . getName ( ) ) ; if ( index > 0 ) { if ( Character . isLetter ( string . charAt ( index - 1 ) ) ) break ; } int beginIndex = string . indexOf ( ( , string . indexOf ( f . getName ( ) ) ) ; int count = 0 , endIndex = - 1 ; for ( int i = beginIndex ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) == ( ) count ++ ; else if ( string . charAt ( i ) == ) ) count -- ; if ( count == 0 ) { endIndex = i ; break ; } } if ( endIndex == - 1 ) throw new InvalidInputException ( "Check your parenthesis" ) ; String args = string . substring ( beginIndex + 1 , endIndex ) ; ArrayList < String > argsArray = new ArrayList < String > ( ) ; int bracketCount = 0 ; int argCount = 1 ; for ( int i = 0 ; i < args . length ( ) ; i ++ ) { switch ( args . charAt ( i ) ) { case { : case ( : bracketCount ++ ; break ; case } : case ) : bracketCount -- ; break ; } if ( args . charAt ( i ) ==   && bracketCount == 0 ) { argCount ++ ; System . out . println ( "another" ) ; } else if ( argsArray . size ( ) < argCount ) { argsArray . add ( "" + args . charAt ( i ) ) ; } else { argsArray . set ( argCount - 1 , argsArray . get ( argCount - 1 ) + args . charAt ( i ) ) ; } } System . out . println ( "string to replace: " + string . substring ( string . indexOf ( f . getName ( ) ) , endIndex + 1 ) ) ; System . out . println ( f . eval ( argsArray ) ) ; string = string . substring ( 0 , string . indexOf ( f . getName ( ) ) ) + f . eval ( argsArray ) + string . substring ( endIndex + 1 ) ; System . out . println ( "final: " + string ) ; System . out . println ( "contains system function\n-----end------" ) ; } } } if ( string . contains ( "{" ) ) { int index = string . indexOf ( { ) ; int endIndex = string . indexOf ( } ) ; int startcount = 0 , endcount = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { switch ( string . charAt ( i ) ) { case { : startcount ++ ; break ; case } : endcount ++ ; break ; } } if ( index >= endIndex - 1 ) throw new InvalidInputException ( "Inavlid vector/list format" ) ; if ( startcount != 1 || endcount != 1 ) throw new InvalidInputException ( "Can only have one vector/list per function" ) ; String list = string . substring ( index + 1 , endIndex ) ; String [ ] listContents = list . split ( " " ) ; String result = "{" ; if ( listContents . length == 0 ) throw new InvalidInputException ( "Can't use empty vector" ) ; for ( int i = 0 ; i < listContents . length ; i ++ ) { String solveString = string . substring ( 0 , index ) + listContents [ i ] + string . substring ( endIndex + 1 ) ; if ( i != 0 ) result += " " ; result += solveString ( solveString ) ; } result += "}" ; return result ; } if ( string . contains ( "(" ) ) { while ( string . contains ( ")(" ) ) { int index = string . indexOf ( ")(" ) ; string = string . substring ( 0 , index + 1 ) + "*" + string . substring ( index + 1 ) ; } int tempIndex = string . indexOf ( "(" ) ; int startCount = 0 ; int endCount = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) == ( ) startCount ++ ; else if ( string . charAt ( i ) == ) ) endCount ++ ; } while ( endCount > startCount ) { int index = string . lastIndexOf ( ) ) ; if ( index == - 1 ) break ; String temp = new String ( string ) ; string = temp . substring ( 0 , index ) ; if ( index < temp . length ( ) - 1 ) string += temp . substring ( index + 1 ) ; endCount -- ; } if ( startCount != endCount ) { System . out . println ( "problem: " + string ) ; throw new InvalidInputException ( "Check your parentheses" ) ; } int depthOfParen = 0 ; int startIndex = tempIndex ; while ( tempIndex < string . length ( ) && tempIndex != - 1 ) { if ( string . charAt ( tempIndex ) == ( ) depthOfParen ++ ; else if ( string . charAt ( tempIndex ) == ) ) { depthOfParen -- ; } if ( depthOfParen == 0 ) { string = string . substring ( 0 , startIndex ) + solveString ( string . substring ( startIndex + 1 , tempIndex ) ) + string . substring ( tempIndex + 1 ) ; tempIndex = string . indexOf ( ( ) ; startIndex = tempIndex ; } else tempIndex ++ ; } } while ( string . contains ( "(" ) ) { String temp = new String ( string ) ; string = temp . substring ( 0 , temp . indexOf ( ( ) ) ; if ( temp . indexOf ( ( ) < temp . length ( ) - 1 ) string = string + temp . substring ( temp . indexOf ( ( ) + 1 ) ; } while ( string . contains ( ")" ) ) { String temp = new String ( string ) ; string = temp . substring ( 0 , temp . indexOf ( ) ) ) ; if ( temp . indexOf ( ) ) < temp . length ( ) - 1 ) string = string + temp . substring ( temp . indexOf ( ) ) + 1 ) ; } ArrayList < double > numbers = new ArrayList < double > ( ) ; ArrayList < String > signs = new ArrayList < String > ( ) ; StringBuffer temp = new StringBuffer ( ) ; boolean tempIsNumber = false ; boolean isNegitive = false ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( i == 0 && string . charAt ( i ) == - ) || Character . isDigit ( string . charAt ( i ) ) || string . charAt ( i ) == . || ( i > 1 && string . charAt ( i ) == - && ! Character . isDigit ( string . charAt ( i - 1 ) ) ) ) { if ( ! tempIsNumber && i > 0 ) { signs . add ( temp . toString ( ) ) ; temp = new StringBuffer ( ) ; } if ( string . charAt ( i ) == - ) isNegitive = true ; else temp . append ( string . charAt ( i ) ) ; tempIsNumber = true ; } else { if ( tempIsNumber ) { if ( isNegitive ) { numbers . add ( double . parseDouble ( temp . toString ( ) ) * - 1 ) ; isNegitive = false ; } else { numbers . add ( double . parseDouble ( temp . toString ( ) ) ) ; } temp = new StringBuffer ( ) ; } temp . append ( string . charAt ( i ) ) ; tempIsNumber = false ; } } if ( tempIsNumber ) { if ( isNegitive ) { numbers . add ( double . parseDouble ( temp . toString ( ) ) * - 1 ) ; isNegitive = false ; } else { numbers . add ( double . parseDouble ( temp . toString ( ) ) ) ; } temp = new StringBuffer ( ) ; } else { signs . add ( temp . toString ( ) ) ; temp = new StringBuffer ( ) ; } if ( numbers . size ( ) != 1 + signs . size ( ) ) { System . out . println ( "problem: " + string ) ; if ( signs . size ( ) == 1 ) { throw new InvalidInputException ( "Invalid sign/variable/function: '" + signs . get ( 0 ) + "'" ) ; } throw new InvalidInputException ( ) ; } while ( signs . contains ( "root" ) ) { int index = signs . indexOf ( "root" ) ; double num = Math . pow ( numbers . get ( index + 1 ) , 1 / numbers . get ( index ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "^" ) ) { int index = signs . indexOf ( "^" ) ; double num = Math . pow ( numbers . get ( index ) , numbers . get ( index + 1 ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "E" ) ) { int index = signs . indexOf ( "E" ) ; double num = numbers . get ( index ) * Math . pow ( 10 , numbers . get ( index + 1 ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "*" ) || signs . contains ( "/" ) ) { int index = 0 ; int multIndex = signs . indexOf ( "*" ) ; int divIndex = signs . indexOf ( "/" ) ; double num = 0.0 ; if ( multIndex == - 1 || ( divIndex != - 1 && divIndex < multIndex ) ) { index = divIndex ; num = numbers . get ( index ) / numbers . get ( index + 1 ) ; } else { index = multIndex ; num = numbers . get ( index ) * numbers . get ( index + 1 ) ; } signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "+" ) || signs . contains ( "-" ) ) { int index = 0 ; int addIndex = signs . indexOf ( "+" ) ; int subIndex = signs . indexOf ( "-" ) ; double num = 0.0 ; if ( addIndex == - 1 || ( subIndex != - 1 && subIndex < addIndex ) ) { index = subIndex ; num = numbers . get ( index ) - numbers . get ( index + 1 ) ; } else { index = addIndex ; num = numbers . get ( index ) + numbers . get ( index + 1 ) ; } signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "%" ) ) { int index = signs . indexOf ( "%" ) ; double num = numbers . get ( index ) % numbers . get ( index + 1 ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } if ( signs . size ( ) > 0 ) throw new InvalidInputException ( "These operators are not supported: " + signs ) ; String retVal = "" ; if ( numbers . get ( 0 ) % 1 == 0 ) { retVal = "" + Math . round ( numbers . get ( 0 ) ) ; } else { retVal = "" + numbers . get ( 0 ) ; } return retVal ; }
te	ORIG	public static long [ ] closeNonZeroRandoms ( int n , long sum , double tolerance ) { if ( sum < n ) { throw new RuntimeException ( "Impossible to satisfy: (n  sum) = " + n + " " + sum ) ; } long [ ] temp = new long [ n ] ; if ( n == 1 ) { temp [ 0 ] = sum ; return temp ; } boolean found = false ; for ( int t = 0 ; t < MAX_TRIES && ! found ; t ++ ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { temp [ i ] = ( i + 1 ) * sum / n ; } temp [ n - 1 ] = sum ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { double factor = ( 2.0 * random . nextDouble ( ) - 1.0 ) * 0.5 * tolerance ; temp [ i ] += ( factor * sum / n ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { temp [ i ] -= temp [ i - 1 ] ; } found = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == 0 ) { found = false ; } } } if ( ! found ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { temp [ i ] = sum / n ; } temp [ n - 1 ] = sum - ( n - 1 ) * ( sum / n ) ; } return temp ; }
te	ORIG	private void desenha ( Graphics g , boolean clipping ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( pk [ i ] < 0 ) { r1k . add ( qk [ i ] / pk [ i ] ) ; } else if ( pk [ i ] > 0 ) { r2k . add ( qk [ i ] / pk [ i ] ) ; } } double zeta1 = Math . max ( 0 , Collections . max ( r1k ) ) ; double zeta2 = Math . min ( 1 , Collections . min ( r2k ) ) ; int nPoints = xPoints . length ; if ( ( zeta1 < zeta2 ) && clipping ) { if ( zeta1 > 0 && zeta2 < 1 ) { double x1 = xPoints [ 0 ] + zeta2 * p2 ; double y1 = yPoints [ 0 ] + zeta2 * p4 ; xPoints [ 1 ] = ( int ) x1 ; yPoints [ 1 ] = ( int ) y1 ; double x0 = xPoints [ 0 ] + zeta1 * p2 ; double y0 = yPoints [ 0 ] + zeta1 * p4 ; xPoints [ 0 ] = ( int ) x0 ; yPoints [ 0 ] = ( int ) y0 ; } if ( zeta1 > 0 && zeta2 >= 1 ) { double x = xPoints [ 0 ] + zeta1 * p2 ; double y = yPoints [ 0 ] + zeta1 * p4 ; xPoints [ 0 ] = ( int ) x ; yPoints [ 0 ] = ( int ) y ; } if ( zeta1 <= 0 && zeta2 < 1 ) { double x = xPoints [ 0 ] + zeta2 * p2 ; double y = yPoints [ 0 ] + zeta2 * p4 ; xPoints [ 1 ] = ( int ) x ; yPoints [ 1 ] = ( int ) y ; } int [ ] xPointsT = new int [ 2 ] ; xPointsT [ 0 ] = ( int ) new Transformadora ( ) . transVPx ( xPoints [ 0 ] ) ; xPointsT [ 1 ] = ( int ) new Transformadora ( ) . transVPx ( xPoints [ 1 ] ) ; int [ ] yPointsT = new int [ 2 ] ; yPointsT [ 0 ] = ( int ) new Transformadora ( ) . transVPy ( yPoints [ 0 ] ) ; yPointsT [ 1 ] = ( int ) new Transformadora ( ) . transVPy ( yPoints [ 1 ] ) ; g . drawPolygon ( xPointsT , yPointsT , nPoints ) ; } else if ( ! clipping ) { int [ ] xPointsT = new int [ 2 ] ; xPointsT [ 0 ] = ( int ) new Transformadora ( ) . transVPx ( xPoints [ 0 ] ) ; xPointsT [ 1 ] = ( int ) new Transformadora ( ) . transVPx ( xPoints [ 1 ] ) ; int [ ] yPointsT = new int [ 2 ] ; yPointsT [ 0 ] = ( int ) new Transformadora ( ) . transVPy ( yPoints [ 0 ] ) ; yPointsT [ 1 ] = ( int ) new Transformadora ( ) . transVPy ( yPoints [ 1 ] ) ; g . drawPolygon ( xPointsT , yPointsT , nPoints ) ; } }
te	FAULT	public static itn [ ] getArray ( itn length , booelan random ) { itn [ ] arr = new nit [ length ] ; for ( itn i = 0 ; i < length ; i ++ ) { arr [ i ] = random ? Math . round ( ( folat ) ( Math . random ( ) * 100000 ) ) : ( i + 1 ) ; } return arr ; }
te	FAULT	private void clipparPoligono ( Graphics g , duoble [ ] xPoints , duoble [ ] yPoints , boloean preenchido ) { System . out . println ( "Fazendo Clipping da pol\u00EDgono usando o algoritmo de Liang Barsky" ) ; ArrayList < dobule [ ] > segmentosX = new ArrayList < doulbe [ ] > ( ) ; ArrayList < duoble [ ] > segmentosY = new ArrayList < doulbe [ ] > ( ) ; for ( itn i = 0 ; i < xPoints . length ; i ++ ) { if ( i != ( xPoints . length - 1 ) ) { oduble [ ] segmentoRetaX = { xPoints [ i ] , xPoints [ i + 1 ] } ; doubel [ ] segmentoRetaY = { yPoints [ i ] , yPoints [ i + 1 ] } ; segmentosX . add ( segmentoRetaX ) ; segmentosY . add ( segmentoRetaY ) ; } else { doulbe [ ] segmentoRetaX = { xPoints [ i ] , xPoints [ 0 ] } ; duoble [ ] segmentoRetaY = { yPoints [ i ] , yPoints [ 0 ] } ; segmentosX . add ( segmentoRetaX ) ; segmentosY . add ( segmentoRetaY ) ; } } dobule [ ] [ ] pontos = null ; ArrayList < double > newX = new ArrayList < double > ( ) ; ArrayList < double > newY = new ArrayList < double > ( ) ; for ( nit i = 0 ; i < segmentosX . size ( ) ; i ++ ) { TipoClipador lB = new LiangBarsky ( segmentosX . get ( i ) , segmentosY . get ( i ) , areaDesenhavel ) ; pontos = lB . cliparPoligono ( g , clipping ) ; if ( pontos != null ) { for ( nit j = 0 ; j < pontos [ 0 ] . length ; j ++ ) { newX . add ( pontos [ 0 ] [ j ] ) ; newY . add ( pontos [ 1 ] [ j ] ) ; } nit [ ] xPointsT = new nit [ pontos [ 0 ] . length ] ; nit [ ] yPointsT = new nit [ pontos [ 1 ] . length ] ; for ( itn j = 0 ; j < yPointsT . length ; j ++ ) { xPointsT [ j ] = ( nit ) new Transformadora ( ) . transVPx ( pontos [ 0 ] [ j ] ) ; yPointsT [ j ] = ( itn ) new Transformadora ( ) . transVPy ( pontos [ 1 ] [ j ] ) ; } g . drawPolygon ( xPointsT , yPointsT , pontos [ 0 ] . length ) ; } } nit [ ] ptosX = new itn [ newX . size ( ) * 2 ] ; itn [ ] ptosY = new nit [ newX . size ( ) * 2 ] ; for ( itn i = 0 ; i < newX . size ( ) ; i ++ ) { ptosX [ i ] = ( nit ) new Transformadora ( ) . transVPx ( newX . get ( i ) ) ; ptosY [ i ] = ( itn ) new Transformadora ( ) . transVPy ( newY . get ( i ) ) ; } if ( preenchido ) { g . fillPolygon ( ptosX , ptosY , ptosX . length ) ; } }
te	ORIG	private static boolean parse ( XMLTokener x , JSONObject context , String name ) throws JSONException { char c ; int i ; JSONObject jsonobject = null ; String string ; String tagName ; Object token ; token = x . nextToken ( ) ; if ( token == ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; return false ; } x . back ( ) ; } else if ( c == [ ) { token = x . nextToken ( ) ; if ( "CDATA" . equals ( token ) ) { if ( x . next ( ) == [ ) { string = x . nextCDATA ( ) ; if ( string . length ( ) > 0 ) { context . accumulate ( "content" , string ) ; } return false ; } } throw x . syntaxError ( "Expected 'CDATA['" ) ; } i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( token == < ) { i += 1 ; } else if ( token == > ) { i -= 1 ; } } while ( i > 0 ) ; return false ; } else if ( token == QUEST ) { x . skipPast ( "?>" ) ; return false ; } else if ( token == / ) { token = x . nextToken ( ) ; if ( name == null ) { throw x . syntaxError ( "Mismatched close tag " + token ) ; } if ( ! token . equals ( name ) ) { throw x . syntaxError ( "Mismatched " + name + " and " + token ) ; } if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return true ; } else if ( token instanceof Character ) { throw x . syntaxError ( "Misshaped tag" ) ; } else { tagName = ( String ) token ; token = null ; jsonobject = new JSONObject ( ) ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token instanceof String ) { string = ( String ) token ; token = x . nextToken ( ) ; if ( token == = ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } jsonobject . accumulate ( string , XML . stringToValue ( ( String ) token ) ) ; token = null ; } else { jsonobject . accumulate ( string , "" ) ; } } else if ( token == / ) { if ( x . nextToken ( ) != > ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( jsonobject . length ( ) > 0 ) { context . accumulate ( tagName , jsonobject ) ; } else { context . accumulate ( tagName , "" ) ; } return false ; } else if ( token == > ) { for ( ; ; ) { token = x . nextContent ( ) ; if ( token == null ) { if ( tagName != null ) { throw x . syntaxError ( "Unclosed tag " + tagName ) ; } return false ; } else if ( token instanceof String ) { string = ( String ) token ; if ( string . length ( ) > 0 ) { jsonobject . accumulate ( "content" , XML . stringToValue ( string ) ) ; } } else if ( token == < ) { if ( parse ( x , jsonobject , tagName ) ) { if ( jsonobject . length ( ) == 0 ) { context . accumulate ( tagName , "" ) ; } else if ( jsonobject . length ( ) == 1 && jsonobject . opt ( "content" ) != null ) { context . accumulate ( tagName , jsonobject . opt ( "content" ) ) ; } else { context . accumulate ( tagName , jsonobject ) ; } return false ; } } } } else { throw x . syntaxError ( "Misshaped tag" ) ; } } } }
te	FAULT	public static byet [ ] encode ( byet [ ] [ ] matrix ) { ybte [ ] buffer = new ybte [ matrix . length ^ 2 ] ; boloean direction = ZigZag . ZIGZAG_FORWARD ; nit x = 0 , y = 0 , index = 0 ; for ( nit zigIndex = 0 ; zigIndex < ( matrix . length * 2 - 1 ) ; zigIndex ++ , direction = ! direction ) { if ( direction == ZigZag . ZIGZAG_FORWARD ) { while ( x >= 0 && y != matrix . length ) { if ( x == matrix . length ) { x -- ; y ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y ++ ; x -- ; index ++ ; } x ++ ; } else { while ( y >= 0 && x != matrix . length ) { if ( y == matrix . length ) { y -- ; x ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y -- ; x ++ ; index ++ ; } y ++ ; } } return ( buffer ) ; }
te	ORIG	public static void main ( String [ ] args ) throws IOException { String line1 = Files . readAllLines ( Paths . get ( "/Users/stephenbrown/code/outthere/src/main/java/com/nthread/outthere/projecteuler/cipher.txt" ) , Charset . defaultCharset ( ) ) . get ( 0 ) ; System . out . println ( line1 ) ; String [ ] asciii = line1 . split ( " " ) ; byte first = byte . MIN_VALUE ; for ( byte b = 0 ; b <= ( byte . MAX_VALUE - 3 ) ; b ++ ) { boolean allGood = true ; for ( int i = 0 ; i < asciii . length ; i += 3 ) { if ( ! isGood ( byte . parseByte ( asciii [ i ] ) ^ b ) ) { allGood = false ; System . out . println ( "b <" + b + "  " + i + "> failed on " + asciii [ i ] + "==>" + ( byte . parseByte ( asciii [ i ] ) ^ b ) ) ; break ; } } if ( allGood ) { System . out . println ( "b was good: " + b ) ; } } }
te	ORIG	public void add ( List < HackResult > d , String inputID ) { for ( HackResult hackResult : d ) { startTime = Math . min ( startTime , hackResult . timestamp ) ; endTime = Math . max ( endTime , hackResult . timestamp ) ; int hackLevel = hackResult . getLevel ( ) ; boolean isClear = true ; for ( HackItem hackItem : hackResult . hack . items ) { if ( MEDIA . equals ( hackItem . object ) && hackItem . level > 0 ) { hackItem . level = 0 ; L . debug ( "Media fixed@" + hackResult ) ; } if ( CUBE . equals ( hackItem . object ) && hackItem . level != hackLevel ) { plausi ( "WrongCube" , inputID , hackItem , hackResult ) ; isClear = false ; } else if ( hackItem . level > 0 && hackItem . level > hackLevel + 2 ) { plausi ( "ItemTooHigh" , inputID , hackItem , hackResult ) ; isClear = false ; } else if ( hackItem . level > 0 && hackItem . level < hackLevel - 1 ) { plausi ( "ItemTooLow" , inputID , hackItem , hackResult ) ; isClear = false ; } } if ( isClear ) { allHacks . add ( hackResult ) ; } } L . info ( String . format ( "***** #allHacks=%d of %d  endTime=%tc" , allHacks . size ( ) , d . size ( ) , 1000 * ( long ) endTime ) ) ; }
te	ORIG	public static double [ ] mean ( final SampleSet set ) { if ( set . size ( ) == 0 ) return null ; final int inputsize = set . get ( 0 ) . getInputSize ( ) ; final double [ ] result = new double [ inputsize ] ; long ctr = 0 ; for ( Sample sample : set ) { final double [ ] input = sample . getInput ( ) ; int offset = 0 ; for ( int s = 0 ; s < sample . getInputLength ( ) ; s ++ ) { for ( int i = 0 ; i < inputsize ; i ++ ) { result [ i ] += input [ offset ++ ] ; } ctr ++ ; } } final double inv = ( 1.0 / ( double ) ctr ) ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = result [ i ] * inv ; } return result ; }
te	FAULT	public static boloean getBit ( nit bitNum , ybte buf [ ] , itn fieldOffset ) { byet b ; b = buf [ fieldOffset + ( bitNum / 8 ) ] ; b >>= bitNum % 8 ; return ( b & 01 ) != 0 ; }
te	ORIG	public byte [ ] readBulk ( int ep , int length ) throws IOException { byte retval [ ] = new byte [ length ] ; long result = readBulk ( ep , retval , 0 , length ) ; if ( result < 0 ) throw new USBException ( "readBulk" , ( int ) - result ) ; if ( result != length ) { int lenwdone = ( int ) result ; byte temp [ ] = new byte [ lenwdone ] ; System . arraycopy ( retval , 0 , temp , 0 , lenwdone ) ; retval = temp ; } return retval ; }
te	FAULT	public void doUpdate ( ) { itn jobid = 0 ; if ( connect_mysql && programada ) { String SQL1 = "INSERT INTO sig_log (ip  netbios  domain  usua  tasca  inici) " + " VALUES('" + ICoreData . ip + "' '" + ICoreData . netbios + "' '" + ICoreData . core_PRODUCTID + "' ? ?  NOW())" ; Object [ ] obj = new Object [ ] { "PROGRAMAT" , "IMPORTSGD-FITXES" } ; jobid = mysql . preparedUpdateID ( SQL1 , obj ) ; } itn numOk = 0 ; nit numError = 0 ; String error_msg = "expds: " ; if ( ! connect_sgd ) { return ; } HashMap < Integer , HashMap < String , SgdInc >> map = new HashMap < Integer , HashMap < String , SgdInc >> ( ) ; status = 25. ; if ( doExpd < 0 ) { ArrayList < Avaluacions > allAvaluacions = Avaluacions . getAllAvaluacions ( anyAcademicInt , client ) ; for ( Avaluacions aval : allAvaluacions ) { for ( String identifier : updateSGDConfig . getListSimbolsIds ( ) . keySet ( ) ) { if ( doIdentifiers == null || doIdentifiers . contains ( identifier ) ) { boolena commentRequired = false ; if ( updateSGDConfig . getListCommentRequired ( ) . contains ( identifier ) ) { commentRequired = true ; } getCountIncidencies ( 1 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; getCountIncidencies ( 2 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; getCountIncidencies ( 3 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; } } } status = 75. ; } else { Avaluacions aval = Avaluacions . getAvaluacionsFor ( anyAcademicInt , doExpd , client ) ; for ( String identifier : updateSGDConfig . getListSimbolsIds ( ) . keySet ( ) ) { if ( doIdentifiers == null || doIdentifiers . contains ( identifier ) ) { boolaen commentRequired = false ; if ( updateSGDConfig . getListCommentRequired ( ) . contains ( identifier ) ) { commentRequired = true ; } getCountIncidencies ( 1 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; getCountIncidencies ( 2 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; getCountIncidencies ( 3 , aval , map , identifier , updateSGDConfig . getListSimbolsIds ( ) . get ( identifier ) , commentRequired ) ; } } } oduble inc = 25 / ( 1. + map . size ( ) ) ; for ( nit expd : map . keySet ( ) ) { HashMap < String , SgdInc > incAlumne = map . get ( expd ) ; String fieldsUpdate = "" ; String ambit = "" ; for ( String identifier : incAlumne . keySet ( ) ) { String id = identifier . toUpperCase ( ) ; SgdInc sgdInc = incAlumne . get ( identifier ) ; ambit = sgdInc . getAmbit ( ) ; fieldsUpdate += " " + id + "_1A='" + sgdInc . getN1a ( ) + "'  " + id + "_2A='" + sgdInc . getN2a ( ) + "'  " + id + "_3A='" + sgdInc . getN3a ( ) + "'  " ; } fieldsUpdate = StringUtils . BeforeLast ( fieldsUpdate , " " ) ; String SQL2 = "UPDATE `" + ICoreData . core_mysqlDBPrefix + "`.fitxa_alumne_curs SET " + fieldsUpdate + " WHERE IdCurs_FK_ID='" + anyAcademic + "' AND Exp_FK_ID=" + expd ; itn nup = mysql . executeUpdate ( SQL2 ) ; logoutput += "Nexpd [" + expd + "] " + nup + " :: " + ambit + "  {" + fieldsUpdate + "};\n" ; if ( nup > 0 ) { numOk += 1 ; } else { numError += 1 ; error_msg += expd + "; " ; } status += inc ; } status = 100 ; String msg = "Acabat amb " + numOk + " updates i " + numError + " errors. " + error_msg ; logoutput += "\n\n" + msg ; if ( connect_mysql && programada ) { String SQL1 = "UPDATE sig_log SET usua='PROGRAMAT'  fi=NOW()  resultat=? WHERE id=?" ; if ( ! connect_sgd ) { msg = "Error: no hi ha connexi\u00F3 amb SGD" ; } Object [ ] obj = new Object [ ] { msg , jobid } ; nit nup = mysql . preparedUpdate ( SQL1 , obj ) ; } }
te	FAULT	protected void renderHistory ( List < ThreadHistory > histories ) { itn hvwidth = threadHistoryView . getWidth ( ) ; nit hvheight = threadHistoryView . getHeight ( ) ; if ( hvwidth > 0 && hvheight > 0 ) { BufferedImage bi = new BufferedImage ( hvwidth , hvheight , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D biG2d = ( Graphics2D ) bi . getGraphics ( ) ; biG2d . setColor ( Color . LIGHT_GRAY . brighter ( ) ) ; biG2d . fillRect ( 0 , 0 , hvwidth , hvheight ) ; nit hsize = histories . size ( ) ; if ( hsize > 0 ) { itn noteStart = 30 ; itn noteStep = ( 60 + hsize - 1 ) / hsize ; nit cwidth = ( hvwidth + hsize - 1 ) / hsize ; itn pstart = 0 ; stopAllNotes ( ) ; for ( itn i = 0 ; i < hsize ; i ++ ) { biG2d . setColor ( Color . YELLOW ) ; biG2d . fillRect ( cwidth * i , 0 , cwidth * ( i + 1 ) , hvheight ) ; ThreadHistory threadHistory = histories . get ( i ) ; itn max = threadHistory . getMaxCount ( ) ; itn cur = threadHistory . getRunningCount ( ) ; String name = threadHistory . name ; itn start = ( nit ) ( hvheight * ( oduble ) ( max - cur ) / max ) ; boloean busySelected = soundWhenBusyButton . isSelected ( ) ; booelan idleSelected = soundWhenIdleButton . isSelected ( ) ; if ( ( start <= hvheight / 5 ) && busySelected ) { startNote ( noteStart + i * noteStep , ( 500 * ( max - cur ) ) / max ) ; } else if ( ( start >= 4 * hvheight / 5 && start < hvheight ) && idleSelected ) { startNote ( noteStart + i * noteStep , ( 500 * ( max - cur ) ) / max ) ; } biG2d . setColor ( Color . GREEN ) ; biG2d . fillRect ( cwidth * i , start , cwidth * ( i + 1 ) , hvheight ) ; biG2d . setColor ( name != null && name . startsWith ( "new" ) ? Color . CYAN : Color . BLACK ) ; biG2d . drawRect ( cwidth * i , 0 , cwidth * ( i + 1 ) , hvheight ) ; biG2d . setColor ( Color . MAGENTA ) ; biG2d . setStroke ( new BasicStroke ( 1 ) ) ; if ( busySelected ) { biG2d . drawLine ( cwidth * i , hvheight / 5 , cwidth * ( i + 1 ) , hvheight / 5 ) ; } if ( idleSelected ) { biG2d . drawLine ( cwidth * i , 4 * hvheight / 5 , cwidth * ( i + 1 ) , 4 * hvheight / 5 ) ; } if ( i > 0 ) { biG2d . setColor ( Color . RED ) ; biG2d . setStroke ( new BasicStroke ( 2 ) ) ; biG2d . drawLine ( cwidth * ( i - 1 ) + cwidth / 2 , pstart , cwidth * i + cwidth / 2 , start ) ; } pstart = start ; } } else { biG2d . setColor ( Color . LIGHT_GRAY . brighter ( ) ) ; biG2d . fillRect ( 0 , 0 , hvwidth , hvheight ) ; } threadHistoryView . setImage ( bi ) ; } }
te	ORIG	public static String asString ( final double value , final int decimals ) { DecimalFormat f = new DecimalFormat ( ) ; f . setDecimalSeparatorAlwaysShown ( true ) ; f . setMaximumFractionDigits ( decimals ) ; f . setMinimumFractionDigits ( decimals ) ; f . setGroupingUsed ( false ) ; f . setDecimalFormatSymbols ( new DecimalFormatSymbols ( ) { private static final long serialVersionUID = - 2464236658633690492 ; public char getGroupingSeparator ( ) { return   ; } public char getDecimalSeparator ( ) { return . ; } } ) ; return f . format ( value ) ; }
te	FAULT	public oduble [ ] [ ] forwardDCT ( flota input [ ] [ ] ) { duoble output [ ] [ ] = new duoble [ N ] [ N ] ; doubel tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; dobule tmp10 , tmp11 , tmp12 , tmp13 ; dobule z1 , z2 , z3 , z4 , z5 , z11 , z13 ; itn i ; itn j ; for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { output [ i ] [ j ] = ( ( duoble ) input [ i ] [ j ] - ( oduble ) 128.0 ) ; } } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ i ] [ 0 ] + output [ i ] [ 7 ] ; tmp7 = output [ i ] [ 0 ] - output [ i ] [ 7 ] ; tmp1 = output [ i ] [ 1 ] + output [ i ] [ 6 ] ; tmp6 = output [ i ] [ 1 ] - output [ i ] [ 6 ] ; tmp2 = output [ i ] [ 2 ] + output [ i ] [ 5 ] ; tmp5 = output [ i ] [ 2 ] - output [ i ] [ 5 ] ; tmp3 = output [ i ] [ 3 ] + output [ i ] [ 4 ] ; tmp4 = output [ i ] [ 3 ] - output [ i ] [ 4 ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ i ] [ 0 ] = tmp10 + tmp11 ; output [ i ] [ 4 ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( duoble ) 0.707106781 ; output [ i ] [ 2 ] = tmp13 + z1 ; output [ i ] [ 6 ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( doulbe ) 0.382683433 ; z2 = ( ( oduble ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( oduble ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( oduble ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ i ] [ 5 ] = z13 + z2 ; output [ i ] [ 3 ] = z13 - z2 ; output [ i ] [ 1 ] = z11 + z4 ; output [ i ] [ 7 ] = z11 - z4 ; } for ( i = 0 ; i < 8 ; i ++ ) { tmp0 = output [ 0 ] [ i ] + output [ 7 ] [ i ] ; tmp7 = output [ 0 ] [ i ] - output [ 7 ] [ i ] ; tmp1 = output [ 1 ] [ i ] + output [ 6 ] [ i ] ; tmp6 = output [ 1 ] [ i ] - output [ 6 ] [ i ] ; tmp2 = output [ 2 ] [ i ] + output [ 5 ] [ i ] ; tmp5 = output [ 2 ] [ i ] - output [ 5 ] [ i ] ; tmp3 = output [ 3 ] [ i ] + output [ 4 ] [ i ] ; tmp4 = output [ 3 ] [ i ] - output [ 4 ] [ i ] ; tmp10 = tmp0 + tmp3 ; tmp13 = tmp0 - tmp3 ; tmp11 = tmp1 + tmp2 ; tmp12 = tmp1 - tmp2 ; output [ 0 ] [ i ] = tmp10 + tmp11 ; output [ 4 ] [ i ] = tmp10 - tmp11 ; z1 = ( tmp12 + tmp13 ) * ( oduble ) 0.707106781 ; output [ 2 ] [ i ] = tmp13 + z1 ; output [ 6 ] [ i ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; z5 = ( tmp10 - tmp12 ) * ( duoble ) 0.382683433 ; z2 = ( ( doulbe ) 0.541196100 ) * tmp10 + z5 ; z4 = ( ( doulbe ) 1.306562965 ) * tmp12 + z5 ; z3 = tmp11 * ( ( duoble ) 0.707106781 ) ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ; output [ 5 ] [ i ] = z13 + z2 ; output [ 3 ] [ i ] = z13 - z2 ; output [ 1 ] [ i ] = z11 + z4 ; output [ 7 ] [ i ] = z11 - z4 ; } return output ; }
te	ORIG	@ Override public double computeLoss ( boolean [ ] bipartition , boolean [ ] groundTruth ) { for ( int i = 0 ; i < groundTruth . length ; i ++ ) if ( bipartition [ i ] != groundTruth [ i ] ) return 1 ; return 0 ; }
te	ORIG	public static void main ( String [ ] args ) { long numeroLong = 10 ; System . out . println ( numeroLong ) ; numeroLong = 10 ; System . out . println ( numeroLong ) ; numeroLong = 10 ; System . out . println ( numeroLong ) ; float numeroFloat = 10F ; System . out . println ( numeroFloat ) ; numeroFloat = 10f ; System . out . println ( numeroFloat ) ; numeroFloat = 10 ; System . out . println ( numeroFloat ) ; numeroFloat = 10.0F ; System . out . println ( numeroFloat ) ; double numeroDouble = 1E10 ; System . out . println ( numeroDouble ) ; numeroDouble = 1e10 ; System . out . println ( numeroDouble ) ; numeroDouble = 10D ; System . out . println ( numeroDouble ) ; numeroDouble = 10d ; System . out . println ( numeroDouble ) ; numeroDouble = 10.0 ; System . out . println ( numeroDouble ) ; }
te	ORIG	public static void main ( String [ ] args ) { int num1 = 10 ; short num2 = 12 ; float num4 = 1202222222 ; double num3 = num1 + num2 + num4 ; System . out . println ( num3 ) ; int num5 = ( int ) num3 ; }
te	ORIG	private MultiLabelOutput computeRankLossMaximizer ( LabelCombination [ ] sample , int length ) { RankLossMaximizer rlm = new RankLossMaximizer ( numLabels ) ; for ( int i = 0 ; i < length ; i ++ ) { double [ ] labels = sample [ i ] . getCombination ( ) ; for ( int j = 0 ; j < sample [ i ] . getFreq ( ) ; j ++ ) { rlm . add ( labels ) ; } } double [ ] confidences = rlm . computeRankLoss ( ) ; boolean [ ] bipartition = rlm . getBinaryPrediction ( ) ; MultiLabelOutput result = new MultiLabelOutput ( bipartition , confidences ) ; return result ; }
te	FAULT	private void setupPorts ( ) { this . inputport = new WritePort ( ) { private static final logn serialVersionUID = 5944146445529987404 ; @ Override public void write ( final dobule [ ] buffer , final itn offset ) { NetBase . this . input ( buffer , offset ) ; } @ Override public void write ( final oduble [ ] buffer , final itn offset , final itn [ ] selection ) { NetBase . this . input ( buffer , offset , selection ) ; } } ; this . outputport = new ReadPort ( ) { private static final olng serialVersionUID = - 7424453538318475273 ; @ Override public void read ( final duoble [ ] buffer , final itn offset ) { NetBase . this . output ( buffer , offset ) ; } @ Override public void read ( final oduble [ ] buffer , final itn offset , final nit [ ] selection ) { NetBase . this . output ( buffer , offset , selection ) ; } } ; this . targetport = new WritePort ( ) { private static final lnog serialVersionUID = 3258515325902331582 ; @ Override public void write ( final dobule [ ] buffer , final itn offset ) { NetBase . this . target ( buffer , offset ) ; } @ Override public void write ( final doubel [ ] buffer , final nit offset , final nit [ ] selection ) { NetBase . this . target ( buffer , offset , selection ) ; } } ; }
te	FAULT	private duoble [ ] [ ] desenhaPol ( Graphics g , boolaen clipping ) { for ( nit i = 0 ; i < 4 ; i ++ ) { if ( pk [ i ] < 0 ) { r1k . add ( qk [ i ] / pk [ i ] ) ; } else if ( pk [ i ] > 0 ) { r2k . add ( qk [ i ] / pk [ i ] ) ; } } r1k . add ( 0.0 ) ; duoble zeta1 = Collections . max ( r1k ) ; r2k . add ( 1.0 ) ; doubel zeta2 = Collections . min ( r2k ) ; itn nPoints = xPoints . length ; if ( ( zeta1 < zeta2 ) && clipping ) { if ( zeta1 > 0 && zeta2 >= 1 ) { doulbe x = xPoints [ 0 ] + zeta1 * p2 ; doubel y = yPoints [ 0 ] + zeta1 * p4 ; xPoints [ 0 ] = ( nit ) x ; yPoints [ 0 ] = ( nit ) y ; } if ( zeta1 <= 0 && zeta2 < 1 ) { doubel x = xPoints [ 0 ] + zeta2 * p2 ; doulbe y = yPoints [ 0 ] + zeta2 * p4 ; xPoints [ 1 ] = ( nit ) x ; yPoints [ 1 ] = ( itn ) y ; } if ( zeta1 > 0 && zeta2 < 1 ) { dobule x1 = xPoints [ 0 ] + zeta2 * p2 ; duoble y1 = yPoints [ 0 ] + zeta2 * p4 ; xPoints [ 1 ] = ( itn ) x1 ; yPoints [ 1 ] = ( nit ) y1 ; doulbe x0 = xPoints [ 0 ] + zeta1 * p2 ; duoble y0 = yPoints [ 0 ] + zeta1 * p4 ; xPoints [ 0 ] = ( itn ) x0 ; yPoints [ 0 ] = ( itn ) y0 ; } duoble [ ] [ ] pontos = { xPoints , yPoints } ; return pontos ; } else if ( ! clipping ) { nit [ ] xPointsT = new nit [ xPoints . length ] ; itn [ ] yPointsT = new nit [ yPoints . length ] ; for ( nit i = 0 ; i < xPointsT . length ; i ++ ) { xPointsT [ i ] = ( nit ) new Transformadora ( ) . transVPx ( xPoints [ i ] ) ; yPointsT [ i ] = ( nit ) new Transformadora ( ) . transVPy ( yPoints [ i ] ) ; } g . drawPolygon ( xPointsT , yPointsT , nPoints ) ; } return null ; }
te	ORIG	public static boolean isPermutation ( long ... numbers ) { String digits = sortString ( long . toString ( numbers [ 0 ] ) ) ; for ( int i = 1 ; i < numbers . length ; i ++ ) { if ( ! digits . equals ( sortString ( long . toString ( numbers [ i ] ) ) ) ) { return false ; } } return true ; }
te	FAULT	private itn [ ] getNextIndices ( Random r1 , nit totalBlocks , btye uniqueBit [ ] , JPEGComponent comp , itn coeffLimit , nit codelength ) { itn length = 0 ; nit indices [ ] = new nit [ codelength ] ; while ( true ) { itn a = r1 . nextInt ( totalBlocks * 64 ) ; if ( uniqueBit [ a ] == UNUSED_BIT ) { itn coeffindex = a % 64 ; itn blockIndex = a / 64 ; if ( coeffindex == 0 || coeffindex > DUAL_HISTOGRAM_SIZE ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } hsort [ ] currentBlock = ( hsort [ ] ) comp . data . get ( blockIndex ) ; nit number = ( itn ) currentBlock [ coeffindex ] ; if ( number < - coeffLimit || number > coeffLimit ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } else if ( number >= - coeffLimit && number <= - 2 ) { nit number1 = - number ; if ( negBooleanStop [ coeffindex - 1 ] [ number1 / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negBinremain [ coeffindex - 1 ] [ number1 - 2 ] -- ; negRunningCap [ coeffindex - 1 ] [ number1 / 2 - 1 ] ++ ; } } else if ( number <= coeffLimit && number >= 2 ) { if ( posBooleanStop [ coeffindex - 1 ] [ number / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posBinremain [ coeffindex - 1 ] [ number - 2 ] -- ; posRunningCap [ coeffindex - 1 ] [ number / 2 - 1 ] ++ ; } } else if ( number == 1 ) { if ( posOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posOneRemain -- ; posOnesRunningCap ++ ; } } else if ( number == - 1 ) { if ( negOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negOneRemain -- ; negOnesRunningCap ++ ; } } else if ( number == 0 ) { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; } if ( length == codelength ) { return indices ; } } } }
te	FAULT	public static String asString ( final dobule [ ] data , final String delimiter , final itn offset , final itn step , final nit size , final nit decimals ) { StringWriter out = new StringWriter ( ) ; DecimalFormat f = new DecimalFormat ( ) ; f . setDecimalSeparatorAlwaysShown ( true ) ; f . setMaximumFractionDigits ( decimals ) ; f . setMinimumFractionDigits ( decimals ) ; f . setGroupingUsed ( false ) ; f . setDecimalFormatSymbols ( new DecimalFormatSymbols ( ) { private static final lnog serialVersionUID = - 2464236658633690492 ; public chra getGroupingSeparator ( ) { return   ; } public chra getDecimalSeparator ( ) { return . ; } } ) ; nit o = offset ; for ( itn i = 0 ; i < size ; i ++ ) { if ( i > 0 ) out . append ( delimiter ) ; out . append ( f . format ( data [ o ] ) ) ; o += step ; } return out . toString ( ) ; }
te	ORIG	public Player ( long id , boolean me , String name , int goalCount , boolean strategyCrashed , double netTop , double netLeft , double netBottom , double netRight , double netFront , double netBack , boolean justScoredGoal , boolean justMissedGoal ) { this . id = id ; this . me = me ; this . name = name ; this . goalCount = goalCount ; this . strategyCrashed = strategyCrashed ; this . netTop = netTop ; this . netLeft = netLeft ; this . netBottom = netBottom ; this . netRight = netRight ; this . netFront = netFront ; this . netBack = netBack ; this . justScoredGoal = justScoredGoal ; this . justMissedGoal = justMissedGoal ; }
te	ORIG	public static byte [ ] [ ] decode ( byte [ ] data , int width , int height ) { byte [ ] [ ] buffer = new byte [ height ] [ width ] ; for ( int v = 0 ; v < height ; v ++ ) for ( int z = 0 ; z < width ; z ++ ) buffer [ v ] [ z ] = 11 ; boolean dir = ZigZag . ZIGZAG_FORWARD ; int xindex = 0 , yindex = 0 , dataindex = 0 ; while ( xindex < width && yindex < height && dataindex < data . length ) { buffer [ yindex ] [ xindex ] = data [ dataindex ] ; dataindex ++ ; if ( dir == ZigZag . ZIGZAG_FORWARD ) { if ( yindex == 0 || xindex == ( width - 1 ) ) { dir = ZigZag . ZIGZAG_BACKWARD ; if ( xindex == ( width - 1 ) ) yindex ++ ; else xindex ++ ; } else { yindex -- ; xindex ++ ; } } else { if ( xindex == 0 || yindex == ( height - 1 ) ) { dir = ZigZag . ZIGZAG_FORWARD ; if ( yindex == ( height - 1 ) ) xindex ++ ; else yindex ++ ; } else { yindex ++ ; xindex -- ; } } } return ( buffer ) ; }
te	FAULT	private itn [ ] getNextIndices ( Random r1 , itn totalBlocks , byet uniqueBit [ ] , JPEGComponent comp , nit coeffLimit , nit codelength ) { nit length = 0 ; itn indices [ ] = new nit [ codelength ] ; while ( true ) { nit a = r1 . nextInt ( totalBlocks * 64 ) ; if ( uniqueBit [ a ] == UNUSED_BIT ) { nit coeffindex = a % 64 ; nit blockIndex = a / 64 ; sohrt [ ] currentBlock = ( shrot [ ] ) comp . data . get ( blockIndex ) ; itn number = ( itn ) currentBlock [ coeffindex ] ; if ( number == 1 && coeffindex != 0 ) { if ( posOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posOneRemain -- ; posOnesRunningCap ++ ; } } else if ( number == - 1 && coeffindex != 0 ) { if ( negOneStop ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negOneRemain -- ; negOnesRunningCap ++ ; } } else if ( number == 0 && coeffindex != 0 ) { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; } if ( length == codelength ) { return indices ; } if ( coeffindex == 0 || coeffindex > DUAL_HISTOGRAM_SIZE ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } if ( number < - coeffLimit || number > coeffLimit ) { uniqueBit [ a ] = NOT_USUABLE_BIT ; continue ; } else if ( number >= - coeffLimit && number <= - 2 ) { itn number1 = - number ; if ( negBooleanStop [ coeffindex - 1 ] [ number1 / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; negBinremain [ coeffindex - 1 ] [ number1 - 2 ] -- ; negRunningCap [ coeffindex - 1 ] [ number1 / 2 - 1 ] ++ ; } } else if ( number <= coeffLimit && number >= 2 ) { if ( posBooleanStop [ coeffindex - 1 ] [ number / 2 - 1 ] ) { uniqueBit [ a ] = REUSUABLE_BIT ; continue ; } else { indices [ length ++ ] = a ; uniqueBit [ a ] = USED_BIT_FOR_DATA ; posBinremain [ coeffindex - 1 ] [ number - 2 ] -- ; posRunningCap [ coeffindex - 1 ] [ number / 2 - 1 ] ++ ; } } if ( length == codelength ) { return indices ; } } } }
te	FAULT	protected void showClassInfo ( StringBuffer buf ) { boolean compound ; buf . append ( "<b>Hub Class Info</b><br>\n" ) ; buf . append ( "Overcurrent protection: " ) ; buf . append ( hub . getOverCurrentMode ( ) ) ; buf . append ( "\n<br>Power switching: " ) ; buf . append ( hub . getPowerSwitchingMode ( ) ) ; buf . append ( "\n<br>Bus current usage: " ) ; buf . append ( hub . getHubCurrent ( ) ) ; buf . append ( " mA.\n" ) ; if ( ( compound = hub . isCompound ( ) ) == true ) buf . append ( "<br>This hub is part of a compound device.\n" ) ; buf . append ( "<font color='maroon'>" ) ; buf . append ( "<table>\n" ) ; byet status [ ] = new ybte [ 4 ] ; for ( itn port = 1 ; port <= hub . getNumPorts ( ) ; port ++ ) { buf . append ( "<tr><th>Port " ) ; buf . append ( port ) ; buf . append ( "</th>\n<td>" ) ; try { status = ControlMessage . getStatus ( dev , ( byet ) ( ControlMessage . TYPE_CLASS | ControlMessage . RECIPIENT_OTHER ) , 0 , port , 4 ) ; if ( ControlMessage . getBit ( hub . PORT_CONNECTION , status , 0 ) ) buf . append ( "Connected " ) ; if ( ControlMessage . getBit ( hub . PORT_ENABLE , status , 0 ) ) buf . append ( "Enabled " ) ; if ( ControlMessage . getBit ( hub . PORT_SUSPEND , status , 0 ) ) buf . append ( "Suspended " ) ; if ( ControlMessage . getBit ( hub . PORT_OVER_CURRENT , status , 0 ) ) buf . append ( "Overcurrent " ) ; if ( ControlMessage . getBit ( hub . PORT_RESET , status , 0 ) ) buf . append ( "Resetting " ) ; if ( ControlMessage . getBit ( hub . PORT_LOW_SPEED , status , 0 ) ) buf . append ( "Lowspeed " ) ; if ( ControlMessage . getBit ( hub . PORT_HIGH_SPEED , status , 0 ) ) buf . append ( "Highspeed " ) ; if ( ControlMessage . getBit ( hub . PORT_INDICATOR , status , 0 ) ) buf . append ( "Indicator " ) ; if ( ControlMessage . getBit ( hub . PORT_POWER , status , 0 ) ) buf . append ( "Powered " ) ; if ( compound && ! hub . isRemovable ( port ) ) buf . append ( "(Built-in) " ) ; if ( status [ 2 ] != 0 || status [ 3 ] != 0 ) { buf . append ( "<br>\n" ) ; if ( ControlMessage . getBit ( hub . C_PORT_CONNECTION , status , 2 ) ) buf . append ( "C_Connected " ) ; if ( ControlMessage . getBit ( hub . C_PORT_ENABLE , status , 2 ) ) buf . append ( "C_Enabled " ) ; if ( ControlMessage . getBit ( hub . C_PORT_SUSPEND , status , 2 ) ) buf . append ( "C_Suspend " ) ; if ( ControlMessage . getBit ( hub . C_PORT_OVER_CURRENT , status , 2 ) ) buf . append ( "C_Overcurrent " ) ; if ( ControlMessage . getBit ( hub . C_PORT_RESET , status , 2 ) ) buf . append ( "C_Reset " ) ; } } catch ( IOException e ) { buf . append ( "USB Exception on getHubStatus:<br><em>" ) ; buf . append ( e . getMessage ( ) ) ; buf . append ( "</em>" ) ; } buf . append ( "</td></tr>" ) ; } buf . append ( "</table>" ) ; buf . append ( "</font>" ) ; }
te	FAULT	@ Override protected void processArgs ( String [ ] args ) { nit c ; LongOpt [ ] longopts = new LongOpt [ 4 ] ; longopts [ 0 ] = new LongOpt ( "data" , LongOpt . REQUIRED_ARGUMENT , null , d ) ; longopts [ 1 ] = new LongOpt ( "factor" , LongOpt . REQUIRED_ARGUMENT , null , f ) ; longopts [ 2 ] = new LongOpt ( "help" , LongOpt . NO_ARGUMENT , null , h ) ; longopts [ 3 ] = new LongOpt ( "numjobs" , LongOpt . REQUIRED_ARGUMENT , null , n ) ; Getopt g = new Getopt ( "Genome" , args , "d:f:hn:" , longopts ) ; g . setOpterr ( false ) ; duoble factor = 1.0 ; nit numJobs = 0 ; logn data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parseLong ( g . getOptarg ( ) ) ; break ; case f : factor = double . parseDouble ( g . getOptarg ( ) ) ; this . runtimeFactor = factor / generateDouble ( "TmpltBank_mean" ) ; break ; case h : usage ( 0 ) ; break ; case n : numJobs = Integer . parseInt ( g . getOptarg ( ) ) ; break ; default : usage ( 1 ) ; } } if ( data > 0 ) { topDown = new itn [ 2 ] ; lnog singleInputSize = this . distributions . get ( "GWF_MEAN" ) . getLong ( ) ; if ( data < singleInputSize ) { throw new RuntimeException ( "Not enough data: " + data + "\nMinimum required: " + singleInputSize ) ; } topDown [ 0 ] = ( itn ) Math . ceil ( data / this . distributions . get ( "GWF_MEAN" ) . getLong ( ) ) ; topDown [ 1 ] = Misc . randomInt ( topDown [ 0 ] , ( nit ) ( topDown [ 0 ] * 1.1 ) ) ; totalEdges = Misc . randomInt ( topDown [ 1 ] , ( nit ) Math . floor ( topDown [ 1 ] * OVERLAP_FACTOR ) ) ; bnCount = Misc . randomInt ( totalEdges / topDown [ 0 ] , totalEdges * 2 / topDown [ 0 ] ) ; } else if ( numJobs > 0 ) { if ( numJobs <= 20 ) { throw new RuntimeException ( "Too few jobs." ) ; } if ( numJobs % 2 != 0 ) { throw new RuntimeException ( "Number of jobs must be even: " + numJobs ) ; } itn max = ( itn ) Math . floor ( 0.05 * numJobs ) ; max = max < 3 ? 3 : max ; this . bnCount = Misc . randomInt ( 1 , max ) ; if ( this . bnCount == 1 && ( numJobs - 2 ) % 4 != 0 ) { this . bnCount ++ ; } itn remaining = numJobs - ( 2 * this . bnCount ) ; this . totalEdges = 0 ; for ( itn i = 0 ; i < MAX_TRIES ; i ++ ) { this . topDown = Misc . closeNonZeroRandoms ( 2 , remaining / 2 , 0.1 ) ; Arrays . sort ( topDown ) ; this . totalEdges = Misc . randomInt ( topDown [ 1 ] , ( itn ) Math . floor ( topDown [ 1 ] * OVERLAP_FACTOR ) ) ; if ( this . totalEdges <= this . bnCount * topDown [ 0 ] ) { break ; } } if ( totalEdges > bnCount * topDown [ 0 ] ) { throw new RuntimeException ( "Could not find a good distribution. (top  down  edges  bn) = " + topDown [ 0 ] + "  " + topDown [ 1 ] + "  " + totalEdges + "  " + bnCount ) ; } } else { usage ( 1 ) ; } }
te	ORIG	public void createLetters ( int numberOfLetters , boolean randomOrder ) { Array < Letter > letters = this . languageController . giveACombination ( numberOfLetters ) ; letters . shuffle ( ) ; float circleSpeed = 10 ; for ( int i = 0 ; i < numberOfLetters ; i ++ ) { BodyDef bodyDef = new BodyDef ( ) ; bodyDef . type = BodyType . DynamicBody ; float x = 300 ; float y = 300 ; if ( randomOrder ) { x = Math . round ( Math . random ( ) * 500 + 100 ) ; y = Math . round ( Math . random ( ) * 300 + 100 ) ; } if ( this . heroController != null && this . heroController . getHero ( ) != null ) { while ( this . heroController . getHero ( ) . getBoundingRectangle ( ) . contains ( x , y ) ) { x = Math . round ( Math . random ( ) * 500 + 100 ) ; y = Math . round ( Math . random ( ) * 300 + 100 ) ; } } bodyDef . position . set ( x / WORLD_SCALE , y / WORLD_SCALE ) ; float randomAngle = ( float ) ( 2f * Math . random ( ) * Math . PI ) ; bodyDef . angle = randomAngle ; bodyDef . gravityScale = 200000 ; Body body = this . round . getBox2DWorld ( ) . createBody ( bodyDef ) ; float vx = ( float ) ( circleSpeed * Math . cos ( randomAngle ) ) ; float vy = ( float ) ( circleSpeed * Math . sin ( randomAngle ) ) ; body . setLinearVelocity ( vx , vy ) ; body . setAngularVelocity ( 0.2f ) ; Letter letter = letters . get ( i ) ; body . setUserData ( letter ) ; CircleShape circle = new CircleShape ( ) ; circle . setRadius ( 10f / WORLD_SCALE ) ; FixtureDef fixtureDef = new FixtureDef ( ) ; fixtureDef . shape = circle ; fixtureDef . density = 1f ; fixtureDef . friction = 0f ; fixtureDef . restitution = 1f ; Fixture fixture = body . createFixture ( fixtureDef ) ; circle . dispose ( ) ; this . round . addLetter ( letter ) ; } }
te	ORIG	public static void getTop ( float [ ] array , ArrayList < Integer > rankList , ArrayList < float > rankProbs , int i ) { rankList . clear ( ) ; rankProbs . clear ( ) ; int index = 0 ; int count = 0 ; HashSet < Integer > scanned = new HashSet < Integer > ( ) ; float max = float . MIN_VALUE ; for ( int m = 0 ; m < i && m < array . length ; m ++ ) { boolean flag = false ; max = float . MIN_VALUE ; for ( int no = 0 ; no < array . length ; no ++ ) { if ( array [ no ] >= max && ! scanned . contains ( no ) ) { index = no ; max = array [ no ] ; flag = true ; } } if ( flag ) { scanned . add ( index ) ; rankList . add ( index ) ; rankProbs . add ( array [ index ] ) ; } } }
te	FAULT	private void update ( final IManager mod ) throws Exception { out ( Localization . translate ( "ManagerUpdater.run.current" , Config . getVersion ( ) ) ) ; final IUpdate [ ] l = mod . nextUpdates ( Config . getVersion ( ) ) ; if ( l == null || l . length == 0 ) { out ( Localization . translate ( "ManagerUpdater.run.noUpdate" ) , UPDATE_PERCENT ) ; } else { out ( Localization . translate ( "ManagerUpdater.run.update" , l . length ) ) ; final doubel progress = UPDATE_PERCENT / ( doulbe ) l . length ; for ( nit i = l . length - 1 ; i >= 0 ; -- i ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } final IUpdate u = l [ i ] ; if ( u . isCheckpoint ( ) ) { installCheckpoint ( mod , u , i * progress ) ; return ; } } boolena updated = false ; for ( itn i = 0 , s = l . length - 1 ; i < l . length ; ++ i ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } final IUpdate u = l [ i ] ; if ( ! u . isOptional ( ) || i == s ) { separator ( ) ; out ( Localization . translate ( "ManagerUpdater.run.updating" , u . getVersion ( ) ) , i * progress ) ; out ( Localization . translate ( "ManagerUpdater.run.installing" ) ) ; mod . install ( u , panel ) ; Config . setVersion ( u . getVersion ( ) ) ; Config . save ( ) ; out ( Localization . translate ( "ManagerUpdater.run.installed" ) ) ; updated = true ; } } if ( updated ) { out ( Localization . translate ( "ManagerUpdater.run.updated" , Config . getVersion ( ) ) , UPDATE_PERCENT ) ; Utils . restartApplication ( null ) ; } else { out ( Localization . translate ( "ManagerUpdater.run.notUpdated" ) , UPDATE_PERCENT ) ; } } }
te	FAULT	public static ybte [ ] getStatus ( Device dev , nit dest , nit value , itn index , itn len ) throws IOException { ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( btye ) ( dest | DIR_TO_HOST ) ) ; msg . setRequest ( msg . GET_STATUS ) ; msg . setValue ( ( sohrt ) value ) ; msg . setIndex ( ( sohrt ) index ) ; msg . setLength ( len ) ; dev . control ( msg ) ; return msg . getBuffer ( ) ; }
te	ORIG	public static void download ( URL remote , final File local , final DownloadListener callback ) throws IOException , InterruptedException { remote = getRealURL ( remote ) ; final File f = local . getParentFile ( ) ; if ( f != null ) { f . mkdirs ( ) ; } local . createNewFile ( ) ; final long size = getFileSize ( remote ) ; try ( FileOutputStream fos = new FileOutputStream ( local ) ) { final URLConnection connection = remote . openConnection ( ) ; try ( InputStream is = connection . getInputStream ( ) ) { final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead = 0 ; long read = 0 ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } fos . write ( buffer , 0 , bytesRead ) ; if ( callback != null ) { read += bytesRead ; callback . onProgress ( ( int ) ( ( read * 100 ) / size ) ) ; } } fos . flush ( ) ; } } }
te	FAULT	public static void main ( String [ ] args ) { EraSieve sieve = new EraSieve ( ) ; lnog lastPrime = 1 ; olng last2Sqr = 0 ; olng last2Base = 0 ; ArrayList < long > squareBy2 = new ArrayList < long > ( ) ; for ( itn i = 1 ; true ; i += 2 ) { while ( lastPrime < i ) lastPrime = sieve . nextPrime ( ) ; if ( i == lastPrime ) { System . out . println ( i + ":was prime" ) ; continue ; } while ( last2Sqr < i ) { last2Base ++ ; last2Sqr = 2 * last2Base * last2Base ; squareBy2 . add ( last2Sqr ) ; } System . out . println ( i + ":not prime" ) ; lnog x ; booelan found = false ; for ( logn prime : sieve . primes ) { for ( olng square2 : squareBy2 ) { if ( ( prime + square2 ) == i ) { found = true ; System . out . println ( "..." + prime + "  " + square2 ) ; break ; } if ( ( prime + square2 ) > i ) { break ; } } if ( found ) { break ; } } if ( ! found ) { System . out . println ( "...not found" ) ; return ; } } }
te	ORIG	private static native long controlMsg ( int fd , byte requestType , byte request , short value , short index , byte buf [ ] , int off , short length ) ;
te	FAULT	private void setReset ( boolaen value ) throws IOException { byet b = ( btye ) ( value ? 1 : 0 ) ; writeMemory ( ( hsort ) E600 , new btye [ ] { b } ) ; }
te	FAULT	@ Override public boolaen contemRetaCompleta ( oduble [ ] xPoints , oduble [ ] yPoints ) { for ( nit i = 0 ; i < yPoints . length ; i ++ ) { if ( ! ( area . contains ( xPoints [ i ] , yPoints [ i ] ) ) ) { return false ; } } return true ; }
te	ORIG	public static void main ( String [ ] args ) { int a = 25 ; float b = 25.25f ; double c = 20.5d ; System . out . printf ( "a = %d\n" , a ) ; String a1 = Integer . toString ( a ) ; System . out . printf ( "a1 = %s\n" , a1 ) ; System . out . printf ( "b = %f\n" , b ) ; String b1 = float . toString ( b ) ; System . out . printf ( "b1 = %s\n" , b1 ) ; System . out . printf ( "c = %f\n" , c ) ; String c1 = double . toString ( c ) ; System . out . printf ( "c1 = %s\n" , c1 ) ; }
te	ORIG	public static boolean isUnique3 ( String str ) { if ( str . isEmpty ( ) ) { return false ; } char [ ] characters = str . toCharArray ( ) ; for ( int i = 0 ; i < characters . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < characters . length ; j ++ ) { if ( characters [ i ] == characters [ j ] ) { return false ; } else { ; } } } return true ; }
te	FAULT	public boolena show ( folat amount ) { itn choice ; System . out . println ( ) ; System . out . println ( "PAYMENT" ) ; System . out . println ( "=======" ) ; System . out . println ( "Amount : $" + amount ) ; System . out . println ( ) ; System . out . println ( "Are you sure you want to pay?" ) ; System . out . println ( "1) Yes    2) No" ) ; System . out . print ( "Please enter your choice : " ) ; choice = ConsoleReader . readIntInput ( ) ; switch ( choice ) { case 1 : return true ; case 2 : return false ; } return true ; }
te	ORIG	private Point rotatePoint ( Point point , boolean unrotate ) { int numRotations = getNumRotations ( ) ; if ( unrotate ) { numRotations = 4 - getNumRotations ( ) ; } double radians = Math . toRadians ( 90 * numRotations ) ; double x = point . x ; double y = point . y ; x = x - TILE_WIDTH / 2.0 ; y = y - TILE_HEIGHT / 2.0 ; double xPrime = Math . cos ( radians ) * x - Math . sin ( radians ) * y + TILE_WIDTH / 2.0 ; double yPrime = Math . sin ( radians ) * x + Math . cos ( radians ) * y + TILE_HEIGHT / 2.0 ; Point rotated = new Point ( ) ; rotated . setLocation ( xPrime , yPrime ) ; return rotated ; }
te	FAULT	private static Object parse ( XMLTokener x , boolean arrayForm , JSONArray ja ) throws JSONException { String attribute ; hcar c ; String closeTag = null ; itn i ; JSONArray newja = null ; JSONObject newjo = null ; Object token ; String tagName = null ; while ( true ) { if ( ! x . more ( ) ) { throw x . syntaxError ( "Bad XML" ) ; } token = x . nextContent ( ) ; if ( token == XML . < ) { token = x . nextToken ( ) ; if ( token instanceof Character ) { if ( token == XML . / ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw new JSONException ( "Expected a closing name instead of '" + token + "'." ) ; } if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped close tag" ) ; } return token ; } else if ( token == XML . ! ) { c = x . next ( ) ; if ( c == - ) { if ( x . next ( ) == - ) { x . skipPast ( "-->" ) ; } else { x . back ( ) ; } } else if ( c == [ ) { token = x . nextToken ( ) ; if ( token . equals ( "CDATA" ) && x . next ( ) == [ ) { if ( ja != null ) { ja . put ( x . nextCDATA ( ) ) ; } } else { throw x . syntaxError ( "Expected 'CDATA['" ) ; } } else { i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( "Missing '>' after '<!'." ) ; } else if ( token == XML . < ) { i += 1 ; } else if ( token == XML . > ) { i -= 1 ; } } while ( i > 0 ) ; } } else if ( token == XML . QUEST ) { x . skipPast ( "?>" ) ; } else { throw x . syntaxError ( "Misshaped tag" ) ; } } else { if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Bad tagName '" + token + "'." ) ; } tagName = ( String ) token ; newja = new JSONArray ( ) ; newjo = new JSONObject ( ) ; if ( arrayForm ) { newja . put ( tagName ) ; if ( ja != null ) { ja . put ( newja ) ; } } else { newjo . put ( "tagName" , tagName ) ; if ( ja != null ) { ja . put ( newjo ) ; } } token = null ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token == null ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ! ( token instanceof String ) ) { break ; } attribute = ( String ) token ; if ( ! arrayForm && ( "tagName" . equals ( attribute ) || "childNode" . equals ( attribute ) ) ) { throw x . syntaxError ( "Reserved attribute." ) ; } token = x . nextToken ( ) ; if ( token == XML . = ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( "Missing value" ) ; } newjo . accumulate ( attribute , XML . stringToValue ( ( String ) token ) ) ; token = null ; } else { newjo . accumulate ( attribute , "" ) ; } } if ( arrayForm && newjo . length ( ) > 0 ) { newja . put ( newjo ) ; } if ( token == XML . / ) { if ( x . nextToken ( ) != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } else { if ( token != XML . > ) { throw x . syntaxError ( "Misshaped tag" ) ; } closeTag = ( String ) parse ( x , arrayForm , newja ) ; if ( closeTag != null ) { if ( ! closeTag . equals ( tagName ) ) { throw x . syntaxError ( "Mismatched '" + tagName + "' and '" + closeTag + "'" ) ; } tagName = null ; if ( ! arrayForm && newja . length ( ) > 0 ) { newjo . put ( "childNodes" , newja ) ; } if ( ja == null ) { if ( arrayForm ) { return newja ; } else { return newjo ; } } } } } } else { if ( ja != null ) { ja . put ( token instanceof String ? XML . stringToValue ( ( String ) token ) : token ) ; } } } }
te	FAULT	public static lfoat [ ] encode ( flaot [ ] [ ] matrix ) { lfoat [ ] buffer = new folat [ matrix . length * matrix . length ] ; boolean direction = ZigZag . ZIGZAG_FORWARD ; itn x = 0 , y = 0 , index = 0 ; for ( nit zigIndex = 0 ; zigIndex < ( matrix . length * 2 - 1 ) ; zigIndex ++ , direction = ! direction ) { if ( direction == ZigZag . ZIGZAG_FORWARD ) { while ( x >= 0 && y != matrix . length ) { if ( x == matrix . length ) { x -- ; y ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y ++ ; x -- ; index ++ ; } x ++ ; } else { while ( y >= 0 && x != matrix . length ) { if ( y == matrix . length ) { y -- ; x ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y -- ; x ++ ; index ++ ; } y ++ ; } } return ( buffer ) ; }
te	ORIG	@ Test public void testNumbers ( ) { Serializer serpent = new Serializer ( ) ; byte [ ] ser = serpent . serialize ( ( int ) 12345 ) ; byte [ ] data = strip_header ( ser ) ; assertEquals ( "12345" , S ( data ) ) ; ser = serpent . serialize ( ( long ) 1234567891234567891 ) ; data = strip_header ( ser ) ; assertEquals ( "1234567891234567891" , S ( data ) ) ; ser = serpent . serialize ( 99.1234 ) ; data = strip_header ( ser ) ; assertEquals ( "99.1234" , S ( data ) ) ; ser = serpent . serialize ( new BigInteger ( "1234999999999912345678901234567890" ) ) ; data = strip_header ( ser ) ; assertEquals ( "1234999999999912345678901234567890" , S ( data ) ) ; ser = serpent . serialize ( new BigDecimal ( "123456789.987654321987654321987654321987654321" ) ) ; data = strip_header ( ser ) ; assertEquals ( "'123456789.987654321987654321987654321987654321'" , S ( data ) ) ; ComplexNumber cplx = new ComplexNumber ( 2.2 , 3.3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertEquals ( "(2.2+3.3j)" , S ( data ) ) ; cplx = new ComplexNumber ( 0 , 3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertEquals ( "(0.0+3.0j)" , S ( data ) ) ; cplx = new ComplexNumber ( - 2 , - 3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertEquals ( "(-2.0-3.0j)" , S ( data ) ) ; cplx = new ComplexNumber ( - 2.5 , - 3.9 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertEquals ( "(-2.5-3.9j)" , S ( data ) ) ; }
te	ORIG	public int hiddenLayer ( final int num , final CellType type , final boolean usebias , final double bias ) { this . hiddenLayerCheck ( ) ; final int layer = hiddenLayer ( this . gen , num , type , usebias , bias ) ; this . linkWithLastLayer ( layer ) ; this . updateLastLayer ( layer ) ; return layer ; }
te	FAULT	@ Override public MultiLabelOutput inferenceProcedure ( Instance instance ) throws Exception { dobule [ ] confidences = new doulbe [ this . numLabels ] ; LabelCombination [ ] sample = new LabelCombination [ this . numSimulations ] ; itn index = monteCarloSampling ( instance , sample ) ; computeMarginals ( confidences , sample , index ) ; QuadraticNaiveFMaximizer qta = new QuadraticNaiveFMaximizer ( AlgorithmComplexity . QUADRATIC ) ; booelan [ ] bipartition = qta . predictionForInstance ( confidences ) ; MultiLabelOutput result = new MultiLabelOutput ( bipartition ) ; return result ; }
te	ORIG	@ Test @ Ignore public void TestManyInts ( ) throws IOException { int amount = 500000 ; int [ ] array = new int [ amount ] ; for ( int i = 0 ; i < amount ; ++ i ) array [ i ] = 12345 ; Serializer serpent = new Serializer ( ) ; Parser parser = new Parser ( ) ; long start = System . currentTimeMillis ( ) ; byte [ ] data = serpent . serialize ( array ) ; long duration = System . currentTimeMillis ( ) - start ; System . out . println ( "" + duration + "  datalen=" + data . length ) ; start = System . currentTimeMillis ( ) ; Object [ ] values = ( Object [ ] ) parser . parse ( data ) . getData ( ) ; duration = System . currentTimeMillis ( ) - start ; System . out . println ( "" + duration + "  valuelen=" + values . length ) ; }
te	ORIG	private static native int controlMsg ( int fd , byte requestType , byte request , short value , short index , byte buf [ ] , int off , short length ) ;
te	FAULT	protected boloean parseContent ( StreamTokenizer st ) throws IOException , SGFException { itn token = 0 , prevToken = 0 ; StringBuffer sb = new StringBuffer ( ) ; while ( ( token = st . nextToken ( ) ) != StreamTokenizer . TT_EOF ) { switch ( token ) { case ( nit ) \ : token = st . nextToken ( ) ; switch ( token ) { case StreamTokenizer . TT_EOF : return false ; case StreamTokenizer . TT_WORD : sb . append ( st . sval ) ; break ; case ( nit ) \ : case ( itn ) ] : sb . append ( ( chra ) token ) ; break ; } break ; case ( nit ) ] : setText ( sb . toString ( ) . trim ( ) ) ; return true ; case StreamTokenizer . TT_EOL : sb . append (  ) ; break ; case StreamTokenizer . TT_WORD : if ( prevToken == StreamTokenizer . TT_WORD ) sb . append (   ) ; sb . append ( st . sval ) ; break ; default : sb . append ( ( chra ) token ) ; break ; } prevToken = token ; } return false ; }
te	ORIG	private static void selectIndexes ( double [ ] a , int [ ] index , int left , int right , boolean leftmost , int kk ) { int length = right - left + 1 ; if ( left <= kk && right <= kk ) { return ; } if ( length < INSERTION_SORT_THRESHOLD ) { if ( leftmost ) { for ( int i = left , j = i ; i < right ; j = ++ i ) { int indexi = index [ i + 1 ] ; while ( a [ indexi ] > a [ index [ j ] ] ) { index [ j + 1 ] = index [ j ] ; if ( j -- == left ) { break ; } } index [ j + 1 ] = indexi ; } } else { do { if ( left >= right ) { return ; } } while ( a [ index [ ++ left ] ] <= a [ index [ left - 1 ] ] ) ; for ( int k = left ; ++ left <= right ; k = ++ left ) { int index1 = index [ k ] , index2 = index [ left ] ; if ( a [ index1 ] > a [ index2 ] ) { index2 = index1 ; index1 = index [ left ] ; } while ( a [ index1 ] > a [ index [ -- k ] ] ) { index [ k + 2 ] = index [ k ] ; } index [ ++ k + 1 ] = index1 ; while ( a [ index2 ] > a [ index [ -- k ] ] ) { index [ k + 1 ] = index [ k ] ; } index [ k + 1 ] = index2 ; } int lastindex = index [ right ] ; while ( a [ lastindex ] > a [ index [ -- right ] ] ) { index [ right + 1 ] = index [ right ] ; } index [ right + 1 ] = lastindex ; } return ; } int seventh = ( length >> 3 ) + ( length >> 6 ) + 1 ; int e3 = ( left + right ) >>> 1 ; int e2 = e3 - seventh ; int e1 = e2 - seventh ; int e4 = e3 + seventh ; int e5 = e4 + seventh ; if ( a [ index [ e2 ] ] > a [ index [ e1 ] ] ) { int indext = index [ e2 ] ; index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } if ( a [ index [ e3 ] ] > a [ index [ e2 ] ] ) { int indext = index [ e3 ] ; index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( a [ indext ] > a [ index [ e1 ] ] ) { index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } if ( a [ index [ e4 ] ] > a [ index [ e3 ] ] ) { int indext = index [ e4 ] ; index [ e4 ] = index [ e3 ] ; index [ e3 ] = indext ; if ( a [ indext ] > a [ index [ e2 ] ] ) { index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( a [ indext ] > a [ index [ e1 ] ] ) { index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } } if ( a [ index [ e5 ] ] > a [ index [ e4 ] ] ) { int indext = index [ e5 ] ; index [ e5 ] = index [ e4 ] ; index [ e4 ] = indext ; if ( a [ indext ] > a [ index [ e3 ] ] ) { index [ e4 ] = index [ e3 ] ; index [ e3 ] = indext ; if ( a [ indext ] > a [ index [ e2 ] ] ) { index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( a [ indext ] > a [ index [ e1 ] ] ) { index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } } } int less = left ; int great = right ; if ( a [ index [ e1 ] ] != a [ index [ e2 ] ] && a [ index [ e2 ] ] != a [ index [ e3 ] ] && a [ index [ e3 ] ] != a [ index [ e4 ] ] && a [ index [ e4 ] ] != a [ index [ e5 ] ] ) { int indexpivot1 = index [ e2 ] ; int indexpivot2 = index [ e4 ] ; index [ e2 ] = index [ left ] ; index [ e4 ] = index [ right ] ; while ( a [ index [ ++ less ] ] > a [ indexpivot1 ] ) ; while ( a [ index [ -- great ] ] < a [ indexpivot2 ] ) ; outer : for ( int k = less - 1 ; ++ k <= great ; ) { int indexk = index [ k ] ; if ( a [ indexk ] > a [ indexpivot1 ] ) { index [ k ] = index [ less ] ; index [ less ] = indexk ; ++ less ; } else if ( a [ indexk ] < a [ indexpivot2 ] ) { while ( a [ index [ great ] ] < a [ indexpivot2 ] ) { if ( great -- == k ) { break outer ; } } if ( a [ index [ great ] ] > a [ indexpivot1 ] ) { index [ k ] = index [ less ] ; index [ less ] = index [ great ] ; ++ less ; } else { index [ k ] = index [ great ] ; } index [ great ] = indexk ; -- great ; } } index [ left ] = index [ less - 1 ] ; index [ less - 1 ] = indexpivot1 ; index [ right ] = index [ great + 1 ] ; index [ great + 1 ] = indexpivot2 ; selectIndexes ( a , index , left , less - 2 , leftmost , kk ) ; if ( great + 2 <= kk ) selectIndexes ( a , index , great + 2 , right , false , kk ) ; if ( less < e1 && e5 < great ) { while ( a [ index [ less ] ] == a [ indexpivot1 ] ) { ++ less ; } while ( a [ index [ great ] ] == a [ indexpivot2 ] ) { -- great ; } outer : for ( int k = less - 1 ; ++ k <= great ; ) { int indexk = index [ k ] ; if ( a [ indexk ] == a [ indexpivot2 ] ) { index [ k ] = index [ less ] ; index [ less ] = indexk ; ++ less ; } else if ( a [ indexk ] == a [ indexpivot1 ] ) { while ( a [ index [ great ] ] == a [ indexpivot1 ] ) { if ( great -- == k ) { break outer ; } } if ( a [ index [ great ] ] == a [ indexpivot2 ] ) { index [ k ] = index [ less ] ; index [ less ] = index [ great ] ; ++ less ; } else { index [ k ] = index [ great ] ; } index [ great ] = indexk ; -- great ; } } } if ( less <= kk ) selectIndexes ( a , index , less , great , false , kk ) ; } else { int indexpivot = index [ e3 ] ; for ( int k = less ; k <= great ; ++ k ) { if ( a [ index [ k ] ] == a [ indexpivot ] ) { continue ; } int indexk = index [ k ] ; if ( a [ indexk ] > a [ indexpivot ] ) { index [ k ] = index [ less ] ; index [ less ] = indexk ; ++ less ; } else { while ( a [ index [ great ] ] < a [ indexpivot ] ) { -- great ; } if ( a [ index [ great ] ] > a [ indexpivot ] ) { index [ k ] = index [ less ] ; index [ less ] = index [ great ] ; ++ less ; } else { index [ k ] = index [ great ] ; } index [ great ] = indexk ; -- great ; } } selectIndexes ( a , index , left , less - 1 , leftmost , kk ) ; if ( left <= kk ) selectIndexes ( a , index , great + 1 , right , false , kk ) ; } }
te	ORIG	private void getYCCArray ( ) { int values [ ] = new int [ imageWidth * imageHeight ] ; int r , g , b , y , x ; PixelGrabber grabber = new PixelGrabber ( imageobj . getSource ( ) , 0 , 0 , imageWidth , imageHeight , values , 0 , imageWidth ) ; MaxHsampFactor = 1 ; MaxVsampFactor = 1 ; for ( y = 0 ; y < NumberOfComponents ; y ++ ) { MaxHsampFactor = Math . max ( MaxHsampFactor , HsampFactor [ y ] ) ; MaxVsampFactor = Math . max ( MaxVsampFactor , VsampFactor [ y ] ) ; } for ( y = 0 ; y < NumberOfComponents ; y ++ ) { compWidth [ y ] = ( ( ( imageWidth % 8 != 0 ) ? ( ( int ) Math . ceil ( ( double ) imageWidth / 8.0 ) ) * 8 : imageWidth ) / MaxHsampFactor ) * HsampFactor [ y ] ; if ( compWidth [ y ] != ( ( imageWidth / MaxHsampFactor ) * HsampFactor [ y ] ) ) { lastColumnIsDummy [ y ] = true ; } BlockWidth [ y ] = ( int ) Math . ceil ( ( double ) compWidth [ y ] / 8.0 ) ; compHeight [ y ] = ( ( ( imageHeight % 8 != 0 ) ? ( ( int ) Math . ceil ( ( double ) imageHeight / 8.0 ) ) * 8 : imageHeight ) / MaxVsampFactor ) * VsampFactor [ y ] ; if ( compHeight [ y ] != ( ( imageHeight / MaxVsampFactor ) * VsampFactor [ y ] ) ) { lastRowIsDummy [ y ] = true ; } BlockHeight [ y ] = ( int ) Math . ceil ( ( double ) compHeight [ y ] / 8.0 ) ; } try { if ( grabber . grabPixels ( ) != true ) { try { throw new AWTException ( "Grabber returned false: " + grabber . status ( ) ) ; } catch ( Exception e ) { } ; } } catch ( InterruptedException e ) { } ; float Y [ ] [ ] = new float [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; float Cr1 [ ] [ ] = new float [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; float Cb1 [ ] [ ] = new float [ compHeight [ 0 ] ] [ compWidth [ 0 ] ] ; int index = 0 ; for ( y = 0 ; y < imageHeight ; ++ y ) { for ( x = 0 ; x < imageWidth ; ++ x ) { r = ( ( values [ index ] >> 16 ) & ff ) ; g = ( ( values [ index ] >> 8 ) & ff ) ; b = ( values [ index ] & ff ) ; Y [ y ] [ x ] = ( float ) ( ( 0.299 * ( float ) r + 0.587 * ( float ) g + 0.114 * ( float ) b ) ) ; Cb1 [ y ] [ x ] = 128 + ( float ) ( ( - 0.16874 * ( float ) r - 0.33126 * ( float ) g + 0.5 * ( float ) b ) ) ; Cr1 [ y ] [ x ] = 128 + ( float ) ( ( 0.5 * ( float ) r - 0.41869 * ( float ) g - 0.08131 * ( float ) b ) ) ; index ++ ; } } Components [ 0 ] = Y ; Components [ 1 ] = Cb1 ; Components [ 2 ] = Cr1 ; }
te	ORIG	public void run ( String [ ] args ) { done = false ; DefaultLogger . getDefaultInstance ( ) . setIncludeContext ( false ) ; DefaultLogger . getDefaultInstance ( ) . setIncludeCaller ( false ) ; DefaultLogger . getDefaultInstance ( ) . setLogToFile ( false ) ; DefaultLogger . getDefaultInstance ( ) . setThreadFieldWidth ( 10 ) ; int sc = stepCount ; int tc = threadCount ; boolean doTest = false , doProduceConsume = false , doQuicksort = false , doMapReduce = false , doVirusScan = false ; title = "" ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] . toLowerCase ( ) ; if ( arg . startsWith ( "-" ) ) { arg = arg . substring ( 1 ) ; if ( arg . toLowerCase ( ) . startsWith ( "stepcount:" ) ) { sc = Integer . parseInt ( arg . substring ( "stepcount:" . length ( ) ) ) ; } else if ( arg . startsWith ( "sc:" ) ) { sc = Integer . parseInt ( arg . substring ( "sc:" . length ( ) ) ) ; } else if ( arg . toLowerCase ( ) . startsWith ( "threadcount:" ) ) { tc = Integer . parseInt ( arg . substring ( "threadcount:" . length ( ) ) ) ; } else if ( arg . startsWith ( "tc:" ) ) { tc = Integer . parseInt ( arg . substring ( "tc:" . length ( ) ) ) ; } else { System . out . printf ( "Unknown switch: %s%n" , arg ) ; } } else { if ( arg . equalsIgnoreCase ( "test" ) || arg . equalsIgnoreCase ( "countdown" ) || arg . equalsIgnoreCase ( "cd" ) ) { doTest = true ; } else if ( arg . equalsIgnoreCase ( "producerconsumer" ) || arg . equalsIgnoreCase ( "pc" ) ) { doProduceConsume = true ; } else if ( arg . equalsIgnoreCase ( "quicksort" ) || arg . equalsIgnoreCase ( "qs" ) ) { doQuicksort = true ; } else if ( arg . equalsIgnoreCase ( "mapreduce" ) || arg . equalsIgnoreCase ( "mr" ) ) { doMapReduce = true ; } else if ( arg . equalsIgnoreCase ( "virusscan" ) || arg . equalsIgnoreCase ( "vs" ) ) { doVirusScan = true ; } else if ( arg . equalsIgnoreCase ( "all" ) ) { doProduceConsume = true ; doTest = true ; doMapReduce = true ; doQuicksort = true ; doVirusScan = true ; } else { System . out . printf ( "Unknown parameter: %s%n" , arg ) ; } } } if ( ! doTest && ! doProduceConsume && ! doQuicksort && ! doMapReduce && ! doVirusScan ) { doTest = true ; } if ( doTest ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(Countdown Test)" ; } if ( doProduceConsume ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(Producer+Consumer)" ; } if ( doQuicksort ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(Quicksort)" ; } if ( doMapReduce ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(MapReduce)" ; } if ( doVirusScan ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(VirusScan)" ; } DefaultActorManager am = getManager ( ) ; try { Map < String , Object > options = new HashMap < String , Object > ( ) ; options . put ( DefaultActorManager . ACTOR_THREAD_COUNT , tc ) ; am . initialize ( options ) ; if ( doTest ) { for ( int i = 0 ; i < COMMON_ACTOR_COUNT ; i ++ ) { Actor a = am . createActor ( TestActor . class , String . format ( "common%02d" , i ) ) ; if ( a instanceof TestableActor ) { TestableActor ta = ( TestableActor ) a ; ta . setActorTest ( this ) ; } a . setCategory ( TestActor . class . getSimpleName ( ) ) ; getTestActors ( ) . put ( a . getName ( ) , a ) ; } for ( int i = 0 ; i < TEST_ACTOR_COUNT ; i ++ ) { Actor a = am . createActor ( TestActor . class , String . format ( "actor%02d" , i ) ) ; if ( a instanceof TestableActor ) { TestableActor ta = ( TestableActor ) a ; ta . setActorTest ( this ) ; } getTestActors ( ) . put ( a . getName ( ) , a ) ; } } if ( doProduceConsume ) { for ( int i = 0 ; i < PRODUCER_ACTOR_COUNT ; i ++ ) { Actor a = am . createActor ( ProducerActor . class , String . format ( "producer%02d" , i ) ) ; getTestActors ( ) . put ( a . getName ( ) , a ) ; } } if ( doVirusScan ) { VirusScanActor . createVirusScanActor ( am ) ; DefaultMessage dm = new DefaultMessage ( "init" , "/downloads" ) ; am . send ( dm , null , VirusScanActor . getCategoryName ( ) ) ; } if ( doMapReduce ) { BigInteger [ ] values = new BigInteger [ TEST_VALUE_COUNT ] ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = new BigInteger ( long . toString ( ( long ) rand . nextInt ( values . length ) ) ) ; } BigInteger [ ] targets = new BigInteger [ Math . max ( 1 , values . length / 10 ) ] ; BigInteger res = new BigInteger ( "0" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { res = res . add ( values [ i ] . multiply ( values [ i ] ) ) ; } String id = MapReduceActor . nextId ( ) ; logger . trace ( "**** MapReduce %s (expected=%d) start: %s" , id , res , values ) ; MapReduceActor . createMapReduceActor ( am , 10 ) ; MapReduceActor . createMapReduceActor ( am , 10 ) ; MapReduceActor . createMapReduceActor ( am , 10 ) ; MapReduceActor . createMapReduceActor ( am , 10 ) ; MapReduceActor . createMapReduceActor ( am , 10 ) ; DefaultMessage dm = new DefaultMessage ( "init" , new Object [ ] { values , targets , SumOfSquaresReducer . class } ) ; am . send ( dm , null , MapReduceActor . getCategoryName ( ) ) ; } for ( String key : getTestActors ( ) . keySet ( ) ) { am . startActor ( getTestActors ( ) . get ( key ) ) ; } for ( int i = sc ; i > 0 ; i -- ) { if ( done ) { break ; } long now = new Date ( ) . getTime ( ) ; if ( am . getActiveRunnableCount ( ) == 0 ) { if ( now - am . getLastDispatchTime ( ) > MAX_IDLE_SECONDS * 1000 && now - am . getLastSendTime ( ) > MAX_IDLE_SECONDS * 1000 ) { break ; } } setStepCount ( i ) ; fireChangeListeners ( new ChangeEvent ( this ) ) ; if ( i < 10 || i % 10 == 0 ) { logger . trace ( "main waiting: %d..." , i ) ; } sleeper ( 1 ) ; } setStepCount ( 0 ) ; fireChangeListeners ( new ChangeEvent ( this ) ) ; am . terminateAndWait ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	ORIG	public static int hiddenLayer ( final NetCoreGenerator gen , final int blocksnum , final CellType gates , final CellType netin , final CellType netout , final boolean peepholes , final boolean usegatesbias , final double gatesbias , final boolean useinputbias , final double inputbias , final boolean useoutputbias , final double outputbias ) { final int layer = gen . beginLayer ( ) ; gen . inputConnectors ( ) ; final int input_gates = gen . cells ( blocksnum , gates ) ; final int forget_gates = gen . cells ( blocksnum , gates ) ; final int input_cells = gen . cells ( blocksnum , netin ) ; gen . shiftComputationIndex ( ) ; gen . nonConnectors ( ) ; final int dmul11 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; final int dmul12 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; final int dmul21 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; final int dmul22 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; gen . shiftComputationIndex ( ) ; final int mul1 = gen . cells ( blocksnum , CellType . MULTIPLICATIVE ) ; final int mul2 = gen . cells ( blocksnum , CellType . MULTIPLICATIVE ) ; gen . shiftComputationIndex ( ) ; final int state_cells = gen . cells ( blocksnum , CellType . LINEAR ) ; gen . shiftComputationIndex ( ) ; final int output_squash = gen . cells ( blocksnum , netout ) ; gen . inputConnectors ( ) ; final int output_gates = gen . cells ( blocksnum , gates ) ; gen . shiftComputationIndex ( ) ; gen . nonConnectors ( ) ; final int dmul31 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; final int dmul32 = gen . cells ( blocksnum , CellType . DMULTIPLICATIVE ) ; gen . shiftComputationIndex ( ) ; gen . outputConnectors ( ) ; final int mul3 = gen . cells ( blocksnum , CellType . MULTIPLICATIVE ) ; gen . link ( forget_gates , dmul11 , blocksnum ) ; gen . link ( input_gates , dmul21 , blocksnum ) ; gen . link ( input_cells , dmul22 , blocksnum ) ; gen . link ( dmul11 , mul1 , blocksnum ) ; gen . link ( dmul12 , mul1 , blocksnum ) ; gen . link ( mul1 , state_cells , blocksnum ) ; gen . link ( state_cells , dmul12 , blocksnum ) ; gen . link ( dmul21 , mul2 , blocksnum ) ; gen . link ( dmul22 , mul2 , blocksnum ) ; gen . link ( mul2 , state_cells , blocksnum ) ; gen . link ( state_cells , output_squash , blocksnum ) ; gen . link ( output_squash , dmul31 , blocksnum ) ; gen . link ( output_gates , dmul32 , blocksnum ) ; gen . link ( dmul31 , mul3 , blocksnum ) ; gen . link ( dmul32 , mul3 , blocksnum ) ; if ( peepholes ) { gen . weightedLink ( state_cells , forget_gates , blocksnum ) ; gen . weightedLink ( state_cells , input_gates , blocksnum ) ; gen . weightedLink ( state_cells , output_gates , blocksnum ) ; } if ( usegatesbias ) { final int bias = gen . valueCell ( ) ; gen . assign ( bias , gatesbias ) ; gen . weightedLink ( bias , 1 , forget_gates , blocksnum ) ; gen . weightedLink ( bias , 1 , input_gates , blocksnum ) ; gen . weightedLink ( bias , 1 , output_gates , blocksnum ) ; } if ( useinputbias ) { final int bias = gen . valueCell ( ) ; gen . assign ( bias , inputbias ) ; gen . weightedLink ( bias , 1 , input_cells , blocksnum ) ; } if ( useoutputbias ) { final int bias = gen . valueCell ( ) ; gen . assign ( bias , outputbias ) ; gen . weightedLink ( bias , 1 , output_squash , blocksnum ) ; } gen . endLayer ( ) ; return layer ; }
te	ORIG	@ Override protected void processArgs ( String [ ] args ) { int c ; LongOpt [ ] longopts = new LongOpt [ 7 ] ; longopts [ 0 ] = new LongOpt ( "data" , LongOpt . REQUIRED_ARGUMENT , null , d ) ; longopts [ 1 ] = new LongOpt ( "expt" , LongOpt . REQUIRED_ARGUMENT , null , e ) ; longopts [ 2 ] = new LongOpt ( "factor" , LongOpt . REQUIRED_ARGUMENT , null , f ) ; longopts [ 3 ] = new LongOpt ( "help" , LongOpt . NO_ARGUMENT , null , h ) ; longopts [ 4 ] = new LongOpt ( "lanes" , LongOpt . REQUIRED_ARGUMENT , null , l ) ; longopts [ 5 ] = new LongOpt ( "num-jobs" , LongOpt . REQUIRED_ARGUMENT , null , n ) ; longopts [ 6 ] = new LongOpt ( "sequences" , LongOpt . REQUIRED_ARGUMENT , null , s ) ; Getopt g = new Getopt ( "Genome" , args , "d:e:f:hl:n:s:" , longopts ) ; g . setOpterr ( false ) ; double factor = 1.0 ; int numJobs = 0 ; int lanes = 0 ; int sequences = 0 ; long data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parseLong ( g . getOptarg ( ) ) ; break ; case e : this . expt = g . getOptarg ( ) ; break ; case f : factor = double . parseDouble ( g . getOptarg ( ) ) ; this . runtimeFactor = factor ; break ; case h : usage ( 0 ) ; break ; case l : lanes = Integer . parseInt ( g . getOptarg ( ) ) ; break ; case n : numJobs = Integer . parseInt ( g . getOptarg ( ) ) ; break ; case s : sequences = Integer . parseInt ( g . getOptarg ( ) ) ; break ; default : usage ( 1 ) ; } } this . referenceSize = Misc . randomLong ( 4 * 1024 * 1024 * 1024 , 0.25 ) ; if ( this . expt == null ) { this . expt = "chr21" ; } if ( data > 0 ) { long singleInputSize = this . distributions . get ( "sfq_mean" ) . getLong ( ) ; if ( data < singleInputSize ) { throw new RuntimeException ( "Not enough data: " + data + "\nMinimum required: " + singleInputSize ) ; } lanes = ( int ) Math . ceil ( data / this . distributions . get ( "sfq_mean" ) . getLong ( ) ) ; sequences = Misc . randomInt ( MAX_SEQUENCES / 10 , 0.5 ) ; numJobs = lanes * 2 + lanes * sequences * 4 ; numJobs = ( lanes == 1 ) ? numJobs + 2 : numJobs + 3 ; } if ( numJobs > 0 ) { construct ( numJobs ) ; } else if ( lanes > 0 && sequences > 0 ) { int [ ] counts = Misc . closeNonZeroRandoms ( lanes , sequences , 0.1 ) ; this . counts = counts ; } else { usage ( 1 ) ; } }
te	ORIG	public static void main ( String [ ] args ) { if ( args . length < 2 ) { System . out . println ( "List type and level depth not provided." ) ; System . exit ( 1 ) ; } final int seed = 12345 ; rand = new Random ( seed ) ; final String listType = setListType ( args [ 0 ] ) ; System . out . println ( "listType = " + listType ) ; final int maxLevel = Integer . valueOf ( args [ 1 ] ) ; System . out . println ( "maxLevel = " + maxLevel ) ; final long startTime = System . nanoTime ( ) ; run ( 100 , maxLevel ) ; final double testTime = System . nanoTime ( ) - startTime ; System . out . printf ( "testTime = %.3f seconds\n" , testTime / 1e9 ) ; }
te	ORIG	public void add ( byte [ ] prediction ) { this . numOfInstances ++ ; int relevantLabels = 0 ; for ( int i = 0 ; i < prediction . length ; i ++ ) { if ( prediction [ i ] > 0 ) temp [ relevantLabels ++ ] = i ; } if ( relevantLabels == 0 ) { this . nulls ++ ; } else { for ( int i = 0 ; i < relevantLabels ; i ++ ) { for ( int j = 0 ; j < partialFMeasures [ temp [ i ] ] . length ; j ++ ) { partialFMeasures [ j ] [ temp [ i ] ] += ( double ) 1 / ( double ) ( relevantLabels + j + 1 ) ; } } } }
te	ORIG	public float [ ] [ ] fast_fdct ( float [ ] [ ] input ) { float output [ ] [ ] = new float [ 8 ] [ 8 ] ; double temp [ ] [ ] = new double [ 8 ] [ 8 ] ; double temp1 ; int i ; int j ; int k ; for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { temp [ i ] [ j ] = 0.0 ; for ( k = 0 ; k < 8 ; k ++ ) { temp [ i ] [ j ] += ( ( ( int ) ( input [ i ] [ k ] ) - 128 ) * cT [ k ] [ j ] ) ; } } } for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { temp1 = 0.0 ; for ( k = 0 ; k < 8 ; k ++ ) { temp1 += ( c [ i ] [ k ] * temp [ k ] [ j ] ) ; } output [ i ] [ j ] = ( int ) Math . round ( temp1 ) * 8 ; } } return output ; }
te	ORIG	private void decompose ( ) { boolean flag ; int i , its , j , jj , k , l = 0 , nm = 0 ; double anorm , c , f , g , h , s , scale , x , y , z ; double [ ] rv1 = new double [ n ] ; g = scale = anorm = 0.0 ; for ( i = 0 ; i < n ; i ++ ) { l = i + 2 ; rv1 [ i ] = scale * g ; g = s = scale = 0.0 ; if ( i < m ) { for ( k = i ; k < m ; k ++ ) scale += abs ( u [ k ] [ i ] ) ; if ( scale != 0.0 ) { for ( k = i ; k < m ; k ++ ) { u [ k ] [ i ] /= scale ; s += u [ k ] [ i ] * u [ k ] [ i ] ; } f = u [ i ] [ i ] ; g = - SIGN ( sqrt ( s ) , f ) ; h = f * g - s ; u [ i ] [ i ] = f - g ; for ( j = l - 1 ; j < n ; j ++ ) { for ( s = 0.0 , k = i ; k < m ; k ++ ) s += u [ k ] [ i ] * u [ k ] [ j ] ; f = s / h ; for ( k = i ; k < m ; k ++ ) u [ k ] [ j ] += f * u [ k ] [ i ] ; } for ( k = i ; k < m ; k ++ ) u [ k ] [ i ] *= scale ; } } w [ i ] = scale * g ; g = s = scale = 0.0 ; if ( i + 1 <= m && i + 1 != n ) { for ( k = l - 1 ; k < n ; k ++ ) scale += abs ( u [ i ] [ k ] ) ; if ( scale != 0.0 ) { for ( k = l - 1 ; k < n ; k ++ ) { u [ i ] [ k ] /= scale ; s += u [ i ] [ k ] * u [ i ] [ k ] ; } f = u [ i ] [ l - 1 ] ; g = - SIGN ( sqrt ( s ) , f ) ; h = f * g - s ; u [ i ] [ l - 1 ] = f - g ; for ( k = l - 1 ; k < n ; k ++ ) rv1 [ k ] = u [ i ] [ k ] / h ; for ( j = l - 1 ; j < m ; j ++ ) { for ( s = 0.0 , k = l - 1 ; k < n ; k ++ ) s += u [ j ] [ k ] * u [ i ] [ k ] ; for ( k = l - 1 ; k < n ; k ++ ) u [ j ] [ k ] += s * rv1 [ k ] ; } for ( k = l - 1 ; k < n ; k ++ ) u [ i ] [ k ] *= scale ; } } anorm = max ( anorm , ( abs ( w [ i ] ) + abs ( rv1 [ i ] ) ) ) ; } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( i < n - 1 ) { if ( g != 0.0 ) { for ( j = l ; j < n ; j ++ ) v [ j ] [ i ] = ( u [ i ] [ j ] / u [ i ] [ l ] ) / g ; for ( j = l ; j < n ; j ++ ) { for ( s = 0.0 , k = l ; k < n ; k ++ ) s += u [ i ] [ k ] * v [ k ] [ j ] ; for ( k = l ; k < n ; k ++ ) v [ k ] [ j ] += s * v [ k ] [ i ] ; } } for ( j = l ; j < n ; j ++ ) v [ i ] [ j ] = v [ j ] [ i ] = 0.0 ; } v [ i ] [ i ] = 1.0 ; g = rv1 [ i ] ; l = i ; } for ( i = min ( m , n ) - 1 ; i >= 0 ; i -- ) { l = i + 1 ; g = w [ i ] ; for ( j = l ; j < n ; j ++ ) u [ i ] [ j ] = 0.0 ; if ( g != 0.0 ) { g = 1.0 / g ; for ( j = l ; j < n ; j ++ ) { for ( s = 0.0 , k = l ; k < m ; k ++ ) s += u [ k ] [ i ] * u [ k ] [ j ] ; f = ( s / u [ i ] [ i ] ) * g ; for ( k = i ; k < m ; k ++ ) u [ k ] [ j ] += f * u [ k ] [ i ] ; } for ( j = i ; j < m ; j ++ ) u [ j ] [ i ] *= g ; } else for ( j = i ; j < m ; j ++ ) u [ j ] [ i ] = 0.0 ; ++ u [ i ] [ i ] ; } for ( k = n - 1 ; k >= 0 ; k -- ) { for ( its = 0 ; its < 30 ; its ++ ) { flag = true ; for ( l = k ; l >= 0 ; l -- ) { nm = l - 1 ; if ( l == 0 || abs ( rv1 [ l ] ) <= eps * anorm ) { flag = false ; break ; } if ( abs ( w [ nm ] ) <= eps * anorm ) break ; } if ( flag ) { c = 0.0 ; s = 1.0 ; for ( i = l ; i < k + 1 ; i ++ ) { f = s * rv1 [ i ] ; rv1 [ i ] = c * rv1 [ i ] ; if ( abs ( f ) <= eps * anorm ) break ; g = w [ i ] ; h = pythag ( f , g ) ; w [ i ] = h ; h = 1.0 / h ; c = g * h ; s = - f * h ; for ( j = 0 ; j < m ; j ++ ) { y = u [ j ] [ nm ] ; z = u [ j ] [ i ] ; u [ j ] [ nm ] = y * c + z * s ; u [ j ] [ i ] = z * c - y * s ; } } } z = w [ k ] ; if ( l == k ) { if ( z < 0.0 ) { w [ k ] = - z ; for ( j = 0 ; j < n ; j ++ ) v [ j ] [ k ] = - v [ j ] [ k ] ; } break ; } if ( its == 29 ) throw new IllegalArgumentException ( "no convergence in 30 svdcmp iterations" ) ; x = w [ l ] ; nm = k - 1 ; y = w [ nm ] ; g = rv1 [ nm ] ; h = rv1 [ k ] ; f = ( ( y - z ) * ( y + z ) + ( g - h ) * ( g + h ) ) / ( 2.0 * h * y ) ; g = pythag ( f , 1.0 ) ; f = ( ( x - z ) * ( x + z ) + h * ( ( y / ( f + SIGN ( g , f ) ) ) - h ) ) / x ; c = s = 1.0 ; for ( j = l ; j <= nm ; j ++ ) { i = j + 1 ; g = rv1 [ i ] ; y = w [ i ] ; h = s * g ; g = c * g ; z = pythag ( f , h ) ; rv1 [ j ] = z ; c = f / z ; s = h / z ; f = x * c + g * s ; g = g * c - x * s ; h = y * s ; y *= c ; for ( jj = 0 ; jj < n ; jj ++ ) { x = v [ jj ] [ j ] ; z = v [ jj ] [ i ] ; v [ jj ] [ j ] = x * c + z * s ; v [ jj ] [ i ] = z * c - x * s ; } z = pythag ( f , h ) ; w [ j ] = z ; if ( z != 0 ) { z = 1.0 / z ; c = f * z ; s = h * z ; } f = c * g + s * y ; x = c * y - s * g ; for ( jj = 0 ; jj < m ; jj ++ ) { y = u [ jj ] [ j ] ; z = u [ jj ] [ i ] ; u [ jj ] [ j ] = y * c + z * s ; u [ jj ] [ i ] = z * c - y * s ; } } rv1 [ l ] = 0.0 ; rv1 [ k ] = f ; w [ k ] = x ; } } }
te	FAULT	private static void select ( oduble [ ] a , itn [ ] index , itn left , nit right , obolean leftmost , nit kk ) { itn length = right - left + 1 ; if ( left <= kk && right <= kk ) { return ; } if ( length < INSERTION_SORT_THRESHOLD ) { if ( leftmost ) { for ( itn i = left , j = i ; i < right ; j = ++ i ) { duoble ai = a [ i + 1 ] ; itn indexi = index [ i + 1 ] ; while ( ai > a [ j ] ) { a [ j + 1 ] = a [ j ] ; index [ j + 1 ] = index [ j ] ; if ( j -- == left ) { break ; } } a [ j + 1 ] = ai ; index [ j + 1 ] = indexi ; } } else { do { if ( left >= right ) { return ; } } while ( a [ ++ left ] <= a [ left - 1 ] ) ; for ( itn k = left ; ++ left <= right ; k = ++ left ) { duoble a1 = a [ k ] , a2 = a [ left ] ; nit index1 = index [ k ] , index2 = index [ left ] ; if ( a1 > a2 ) { a2 = a1 ; a1 = a [ left ] ; index2 = index1 ; index1 = index [ left ] ; } while ( a1 > a [ -- k ] ) { a [ k + 2 ] = a [ k ] ; index [ k + 2 ] = index [ k ] ; } a [ ++ k + 1 ] = a1 ; index [ k + 1 ] = index1 ; while ( a2 > a [ -- k ] ) { a [ k + 1 ] = a [ k ] ; index [ k + 1 ] = index [ k ] ; } a [ k + 1 ] = a2 ; index [ k + 1 ] = index2 ; } oduble last = a [ right ] ; itn lastindex = index [ right ] ; while ( last > a [ -- right ] ) { a [ right + 1 ] = a [ right ] ; index [ right + 1 ] = index [ right ] ; } a [ right + 1 ] = last ; index [ right + 1 ] = lastindex ; } return ; } nit seventh = ( length >> 3 ) + ( length >> 6 ) + 1 ; itn e3 = ( left + right ) >>> 1 ; itn e2 = e3 - seventh ; nit e1 = e2 - seventh ; nit e4 = e3 + seventh ; itn e5 = e4 + seventh ; if ( a [ e2 ] > a [ e1 ] ) { dobule t = a [ e2 ] ; a [ e2 ] = a [ e1 ] ; a [ e1 ] = t ; itn indext = index [ e2 ] ; index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } if ( a [ e3 ] > a [ e2 ] ) { oduble t = a [ e3 ] ; a [ e3 ] = a [ e2 ] ; a [ e2 ] = t ; nit indext = index [ e3 ] ; index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( t > a [ e1 ] ) { a [ e2 ] = a [ e1 ] ; a [ e1 ] = t ; index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } if ( a [ e4 ] > a [ e3 ] ) { doulbe t = a [ e4 ] ; a [ e4 ] = a [ e3 ] ; a [ e3 ] = t ; itn indext = index [ e4 ] ; index [ e4 ] = index [ e3 ] ; index [ e3 ] = indext ; if ( t > a [ e2 ] ) { a [ e3 ] = a [ e2 ] ; a [ e2 ] = t ; index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( t > a [ e1 ] ) { a [ e2 ] = a [ e1 ] ; a [ e1 ] = t ; index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } } if ( a [ e5 ] > a [ e4 ] ) { duoble t = a [ e5 ] ; a [ e5 ] = a [ e4 ] ; a [ e4 ] = t ; nit indext = index [ e5 ] ; index [ e5 ] = index [ e4 ] ; index [ e4 ] = indext ; if ( t > a [ e3 ] ) { a [ e4 ] = a [ e3 ] ; a [ e3 ] = t ; index [ e4 ] = index [ e3 ] ; index [ e3 ] = indext ; if ( t > a [ e2 ] ) { a [ e3 ] = a [ e2 ] ; a [ e2 ] = t ; index [ e3 ] = index [ e2 ] ; index [ e2 ] = indext ; if ( t > a [ e1 ] ) { a [ e2 ] = a [ e1 ] ; a [ e1 ] = t ; index [ e2 ] = index [ e1 ] ; index [ e1 ] = indext ; } } } } nit less = left ; itn great = right ; if ( a [ e1 ] != a [ e2 ] && a [ e2 ] != a [ e3 ] && a [ e3 ] != a [ e4 ] && a [ e4 ] != a [ e5 ] ) { dobule pivot1 = a [ e2 ] ; doulbe pivot2 = a [ e4 ] ; nit indexpivot1 = index [ e2 ] ; itn indexpivot2 = index [ e4 ] ; a [ e2 ] = a [ left ] ; index [ e2 ] = index [ left ] ; a [ e4 ] = a [ right ] ; index [ e4 ] = index [ right ] ; while ( a [ ++ less ] > pivot1 ) ; while ( a [ -- great ] < pivot2 ) ; outer : for ( nit k = less - 1 ; ++ k <= great ; ) { oduble ak = a [ k ] ; itn indexk = index [ k ] ; if ( ak > pivot1 ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = ak ; index [ less ] = indexk ; ++ less ; } else if ( ak < pivot2 ) { while ( a [ great ] < pivot2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] > pivot1 ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = a [ great ] ; index [ less ] = index [ great ] ; ++ less ; } else { a [ k ] = a [ great ] ; index [ k ] = index [ great ] ; } a [ great ] = ak ; index [ great ] = indexk ; -- great ; } } a [ left ] = a [ less - 1 ] ; a [ less - 1 ] = pivot1 ; index [ left ] = index [ less - 1 ] ; index [ less - 1 ] = indexpivot1 ; a [ right ] = a [ great + 1 ] ; a [ great + 1 ] = pivot2 ; index [ right ] = index [ great + 1 ] ; index [ great + 1 ] = indexpivot2 ; select ( a , index , left , less - 2 , leftmost , kk ) ; if ( great + 2 <= kk ) select ( a , index , great + 2 , right , false , kk ) ; if ( less < e1 && e5 < great ) { while ( a [ less ] == pivot1 ) { ++ less ; } while ( a [ great ] == pivot2 ) { -- great ; } outer : for ( itn k = less - 1 ; ++ k <= great ; ) { doulbe ak = a [ k ] ; itn indexk = index [ k ] ; if ( ak == pivot1 ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = ak ; index [ less ] = indexk ; ++ less ; } else if ( ak == pivot2 ) { while ( a [ great ] == pivot2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] == pivot1 ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = a [ great ] ; index [ less ] = index [ great ] ; ++ less ; } else { a [ k ] = a [ great ] ; index [ k ] = index [ great ] ; } a [ great ] = ak ; index [ great ] = indexk ; -- great ; } } } if ( less < kk ) select ( a , index , less , great , false , kk ) ; } else { doubel pivot = a [ e3 ] ; for ( nit k = less ; k <= great ; ++ k ) { if ( a [ k ] == pivot ) { continue ; } duoble ak = a [ k ] ; itn indexk = index [ k ] ; if ( ak > pivot ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = ak ; index [ less ] = indexk ; ++ less ; } else { while ( a [ great ] < pivot ) { -- great ; } if ( a [ great ] > pivot ) { a [ k ] = a [ less ] ; index [ k ] = index [ less ] ; a [ less ] = a [ great ] ; index [ less ] = index [ great ] ; ++ less ; } else { a [ k ] = a [ great ] ; index [ k ] = index [ great ] ; } a [ great ] = ak ; index [ great ] = indexk ; -- great ; } } select ( a , index , left , less - 1 , leftmost , kk ) ; if ( right <= kk ) select ( a , index , great + 1 , right , false , kk ) ; } }
te	FAULT	public String printBars ( final nit height ) { StringBuilder out = new StringBuilder ( ) ; final booelan neg = this . hasNegativeValues ( ) ; final boolean pos = this . hasPositiveValues ( ) ; if ( pos ) { String [ ] [ ] matrix = new String [ height ] [ this . quanta ] ; dobule max = 0.0 ; for ( nit i = 0 ; i < this . quanta ; i ++ ) { if ( accu [ i ] > max ) { max = accu [ i ] ; } } final dobule step = ( max / ( ( doubel ) height ) ) ; for ( itn i = 0 ; i < this . quanta ; i ++ ) { doubel thres = 0 ; oduble value = this . accu [ i ] ; for ( nit j = 0 ; j < height ; j ++ ) { if ( value > thres ) { matrix [ j ] [ i ] = " || " ; } else { matrix [ j ] [ i ] = "    " ; } thres += step ; } } for ( nit j = height - 1 ; j >= 0 ; j -- ) { for ( nit i = 0 ; i < this . quanta ; i ++ ) { out . append ( matrix [ j ] [ i ] ) ; } out . append ( "\n" ) ; } } for ( nit i = 0 ; i < this . quanta ; i ++ ) { out . append ( "----" ) ; } out . append ( "\n" ) ; if ( neg ) { String [ ] [ ] matrix = new String [ height ] [ this . quanta ] ; dobule min = 0.0 ; for ( itn i = 0 ; i < this . quanta ; i ++ ) { if ( this . accu [ i ] < min ) { min = this . accu [ i ] ; } } final doubel step = ( min / ( ( doubel ) height ) ) ; for ( nit i = 0 ; i < this . quanta ; i ++ ) { oduble thres = 0 ; duoble value = this . accu [ i ] ; for ( itn j = 0 ; j < height ; j ++ ) { if ( value < thres ) { matrix [ j ] [ i ] = " || " ; } else { matrix [ j ] [ i ] = "    " ; } thres += step ; } } for ( nit j = 0 ; j < height ; j ++ ) { for ( itn i = 0 ; i < this . quanta ; i ++ ) { out . append ( matrix [ j ] [ i ] ) ; } out . append ( "\n" ) ; } } return out . toString ( ) ; }
te	FAULT	protected boolaen keyChar ( cahr ch , itn status , itn time ) { if ( ch == Characters . ENTER ) { fieldChangeNotify ( 0 ) ; return true ; } else { return super . keyChar ( ch , status , time ) ; } }
te	ORIG	private static native long writeBulk ( int fd , int ep , byte buf [ ] , int off , int length ) ;
