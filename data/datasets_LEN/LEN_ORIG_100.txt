tr	A	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	A	public void setDbClass ( String adbclass ) { try { class . forName ( adbclass ) ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error loading class:" , e ) ; } }
tr	E	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
tr	E	public int [ ] searchRange0 ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] == target ) { for ( int i = mid - 1 ; i >= - 1 ; i -- ) { if ( i == - 1 || nums [ i ] != target ) { pos [ 0 ] = i + 1 ; break ; } } for ( int i = mid + 1 ; i <= nums . length ; i ++ ) { if ( i == nums . length || nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
tr	E	public int checkStatus ( String serviceName ) { try { Process process = Runtime . getRuntime ( ) . exec ( "sc query " + serviceName ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "STATE" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return 0 ; }
tr	B	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	E	@ Test public void testGetTransaction ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; CardPaymentRequest paymentRequest = new CardPaymentRequest ( ) ; paymentRequest . setAmount ( 30.00 ) . setOrderNumber ( getRandomOrderId ( "get" ) ) ; paymentRequest . getCard ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; assert . assertTrue ( response . isApproved ( ) ) ; if ( response . isApproved ( ) ) { Transaction transaction = beanstream . reports ( ) . getTransaction ( response . id ) ; System . out . println ( "Transaction: " + transaction . getAmount ( ) + " approved? " + transaction . getApproved ( ) ) ; } } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	A	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	D	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	D	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; ErrMsgEcho = props . getProperty ( "ErrMsgEcho" ) . equals ( "true" ) ; ConfDir = AppDir + props . getProperty ( "ConfDir" ) ; LogDir = AppDir + props . getProperty ( "LogDir" ) ; ImportDir = AppDir + props . getProperty ( "ImportDir" ) ; ErrorLogFile = LogDir + props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	A	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	B	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	A	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	D	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	E	public void manageSecurityEnvironment ( int mode , byte [ ] keyId , byte algSpec ) throws CardServiceException { try { byte p2 = 0 ; switch ( mode ) { case MSE_AUTH : p2 = ( byte ) a4 ; break ; case MSE_SIGN : p2 = ( byte ) b6 ; break ; case MSE_DEC : p2 = ( byte ) b8 ; break ; default : throw new CardServiceException ( "Wrong mode." ) ; } ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( ( byte ) 84 ) ; apduData . write ( ( byte ) keyId . length ) ; apduData . write ( keyId ) ; apduData . write ( ( byte ) 80 ) ; apduData . write ( 01 ) ; apduData . write ( algSpec ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_MSE , 41 , p2 , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "manageSecureEnvironment failed: " ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	D	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	E	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category != response . category ) { return false ; } if ( code != response . code ) { return false ; } if ( httpStatusCode != response . httpStatusCode ) { return false ; } if ( message != null ? ! message . equals ( response . message ) : response . message != null ) { return false ; } if ( reference != null ? ! reference . equals ( response . reference ) : response . reference != null ) { return false ; } if ( details != null ? ! details . equals ( response . details ) : response . details != null ) { return false ; } if ( responseBody != null ? ! responseBody . equals ( response . responseBody ) : response . responseBody != null ) { return false ; } return true ; }
tr	C	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	C	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	C	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	B	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	B	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . doFinal ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return null ; } }
tr	E	@ Override protected void setTextPosition ( Graphics2D g2d ) { FontMetrics fm = g2d . getFontMetrics ( ) ; fm . stringWidth ( componentText ) ; Rectangle2D r = fm . getStringBounds ( componentText , g2d ) ; int shape = LCARS . getShape ( style ) ; switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_NW : textY = ( int ) ( scaledArea . getBounds ( ) . height - textInsetY * scaleFactor ) ; break ; case LCARS . ES_SHAPE_SE : case LCARS . ES_SHAPE_SW : textY = ( int ) ( scaledArea . getBounds ( ) . y + r . getHeight ( ) ) ; break ; default : break ; } switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_SE : textX = ( int ) ( scaledArea . getBounds ( ) . width - barV * scaleFactor + textInsetX * scaleFactor ) ; break ; case LCARS . ES_SHAPE_NW : case LCARS . ES_SHAPE_SW : textX = ( int ) ( barV * scaleFactor - r . getWidth ( ) - textInsetX * scaleFactor ) ; break ; default : break ; } }
tr	D	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt == null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	B	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	D	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	B	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	C	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { String qstr = "Select PassHash From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { curhash = rset . getString ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	A	public boolean isRoleAdmin ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) ) ; }
tr	A	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	B	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	A	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	C	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	E	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	C	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	C	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; DbConfigFile = props . getProperty ( "DbConfigFile" ) ; RemConfigFile = props . getProperty ( "RemConfigFile" ) ; DebugLogFile = props . getProperty ( "DebugLogFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	D	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	D	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	A	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	B	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	C	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	E	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	E	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) ; advanceSolution ( newOne , ore , mineral , yield , tax ) ; if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addAll ( solveForMineral ( newOne , nextOne , ores , yield , tax ) ) ; } } } return solutions ; } else if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveForMineral ( input , nextOne , ores , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	C	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	E	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR , int endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	D	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	A	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { astream . defaultReadObject ( ) ; theConnection = null ; }
tr	C	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	B	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	E	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	C	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	B	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	D	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	D	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	C	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	B	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	A	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	B	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr . length ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	D	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	A	public void setDbUrl ( String aurl ) { if ( ! dbUrl . equals ( aurl ) ) { shutDown ( ) ; dbUrl = aurl ; } }
va	E	private JPanel createButtons ( ) { final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _submitButton = new JButton ( "Submit" ) ; springLayout . putConstraint ( SpringLayout . WEST , _submitButton , SPACING , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , _submitButton , 0 , SpringLayout . NORTH , jPanel ) ; _submitButton . addActionListener ( this ) ; _submitButton . setEnabled ( true ) ; jPanel . add ( _submitButton ) ; _nextButton = new JButton ( "Next" ) ; springLayout . putConstraint ( SpringLayout . WEST , _nextButton , SPACING , SpringLayout . EAST , _submitButton ) ; springLayout . putConstraint ( SpringLayout . NORTH , _nextButton , 0 , SpringLayout . NORTH , jPanel ) ; _nextButton . addActionListener ( this ) ; _nextButton . setEnabled ( false ) ; jPanel . add ( _nextButton ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , SPACING , SpringLayout . EAST , _nextButton ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , SPACING , SpringLayout . SOUTH , _nextButton ) ; return jPanel ; }
va	D	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
va	B	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
va	A	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" , "" , "" , "" ) ; }
va	D	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
va	B	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
va	A	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; }
va	E	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
va	C	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
va	E	private static void removeDuplicates ( char [ ] s ) { if ( s == null ) { return ; } int length = s . length ; if ( length < 2 ) { return ; } int tail = 1 ; for ( int i = 1 ; i < length ; i ++ ) { System . out . println ( "i = " + i + "  tail = " + tail ) ; int j ; for ( j = 0 ; j < tail ; j ++ ) { System . out . println ( "\tj = " + j ) ; if ( s [ i ] == s [ j ] ) { System . out . println ( "\tfound duplicate  skipping: s[" + i + "] == s[" + j + "]" ) ; break ; } } if ( j == tail ) { System . out . println ( "\tj = " + j + "  tail = " + tail + "; copy s[" + i + "] to s[" + tail + "]" ) ; s [ tail ] = s [ i ] ; ++ tail ; } } if ( tail < length ) { s [ tail ] = 0 ; } }
va	C	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
va	C	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
va	D	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
va	B	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures >= loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
va	B	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
va	E	public int insertQuestion ( final AbstractQuestion aq ) { final Type type = aq . getType ( ) ; if ( type . equals ( Type . RadioButton ) ) { final DatabaseRadioButton drb = new DatabaseRadioButton ( _databaseName ) ; return drb . set ( ( RadioButton ) aq ) ; } else if ( type . equals ( Type . CheckBox ) ) { final DatabaseCheckBox dcb = new DatabaseCheckBox ( _databaseName ) ; return dcb . set ( ( CheckBox ) aq ) ; } else if ( type . equals ( Type . BlankAnswer ) ) { final DatabaseBlankAnswer dba = new DatabaseBlankAnswer ( _databaseName ) ; return dba . set ( ( BlankAnswer ) aq ) ; } else if ( type . equals ( Type . FillInTheBlanks ) ) { final DatabaseFillInTheBlanks dba = new DatabaseFillInTheBlanks ( _databaseName ) ; return dba . set ( ( FillInTheBlanks ) aq ) ; } else if ( type . equals ( Type . ShortCut ) ) { final DatabaseShortCut dba = new DatabaseShortCut ( _databaseName ) ; return dba . set ( ( ShortCut ) aq ) ; } throw new RuntimeException ( "TYPE NOT SUPPORTED" ) ; }
va	D	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
va	C	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbUpdateItem error: " , ex ) ; } }
va	A	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
va	A	public void reset ( ) { try { valid = false ; theConnection . close ( ) ; theConnection = makeConnection ( ) ; valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , e ) ; } }
te	A	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort , String amasttbl , String amastfld ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , amasttbl , amastfld ) ; dbReadList ( aconn ) ; }
te	C	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
te	E	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	C	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
te	E	private void initComponents ( ) { add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_TO . toString ( ) ) ) ) ; add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_FROM . toString ( ) ) ) , "wrap" ) ; fromListModel = new DefaultListModel ( ) ; fromFileList = new JList ( fromListModel ) ; fromFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane fromScrollPane = new JScrollPane ( fromFileList ) ; add ( fromScrollPane ) ; toListModel = new DefaultListModel ( ) ; toFileList = new JList ( toListModel ) ; toFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane toScrollPane = new JScrollPane ( toFileList ) ; add ( toScrollPane ) ; toFiles = new ArrayList < File > ( ) ; result = frm . preview ( replacer , fromFiles ) ; for ( Entry < File , File > entry : result . entrySet ( ) ) { fromListModel . addElement ( entry . getKey ( ) ) ; toListModel . addElement ( entry . getValue ( ) ) ; toFiles . add ( entry . getValue ( ) ) ; } }
te	E	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	A	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
te	B	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
te	D	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
te	D	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
te	A	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
te	B	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
te	B	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
te	C	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
te	B	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
te	D	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
te	C	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
te	E	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	D	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
te	A	public String getDescByCode ( String acode ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
