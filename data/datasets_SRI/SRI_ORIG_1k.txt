tr	FAULT	@ Override public void render ( ) { setGlColor4f ( getRole ( ) , getAlpha ( ) ) ; super . render ( ) ; }
tr	ORIG	private static Font createFont ( FontDef fontDef ) { try { InputStream is = new FileInputStream ( fontDef . filePath ) ; return Font . createFont ( Font . TRUETYPE_FONT , is ) . deriveFont ( fontDef . size ) ; } catch ( FontFormatException | IOException e ) { e . printStackTrace ( ) ; return null ; } }
tr	ORIG	public CRunTest ( CAppProps aprops , CDbConnMan alocman , CDbConnMan aremman , String agroup , String atest , String afc1 , String afc2 , int runoption ) { super ( ) ; locconnman = alocman ; remconnman = aremman ; props = aprops ; testgrpid = agroup ; testid = atest ; fc1 = afc1 ; fc2 = afc2 ; fcrunoption = runoption ; }
tr	ORIG	@ Override public void render ( ) { if ( ! isEnable ( ) ) { return ; } draw ( ) ; }
tr	ORIG	public float getBulletRange ( ) { return 200 ; }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ShotList>\n" ) ; for ( int idx = 0 ; bookButton < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; retstr . append ( shot . exportItem ( ) ) ; } retstr . append ( "</ShotList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public final Texture loadTexture ( final String imagePath , final ClassLoader classLoader ) throws IOException { return loadTexture ( ImageIO . read ( getSiteCode . getResourceAsStream ( imagePath ) ) ) ; }
tr	FAULT	private String getStateString ( ) { return CommonMethod . getTexture ( passageDays ) + "\u65E5\u7D4C\u904E/speed:" + speedScale ; }
tr	FAULT	public SolarSystemScene ( ) { BackGroundColor . BLACK . set ( ) ; StarCharacter parentStar ; StarCharacter sun = new StarCharacter ( null , "\u592A" , 1f , Color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makeChild ( "\u6C34" , 0.4f , 15 , new Color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makeChild ( "\u91D1" , 0.5f , 30 , Color . yellow , 0.615 , 243.0187 ) ) ; parentStar = sun . makeChild ( "\u5730" , 0.6f , 45 , new Color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentStar ) ; add ( parentStar . find ( "\u6708" , 0.3f , 10 , Color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentStar = sun . makeChild ( "\u706B" , 0.5f , 60 , Color . red , 1.881 , 1.02595 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30D5" , 0.3f , 5 , Color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentStar . makeChild ( "\u30C0" , 0.3f , 10 , Color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentStar = sun . makeChild ( "\u6728" , 0.8f , 75 , new Color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30E1" , 0.3f , 5 , Color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentStar . makeChild ( "\u30A2" , 0.3f , 10 , Color . white , 0.2983 / ( double ) 365 , 0.2983 ) ) ; add ( parentStar . makeChild ( "\u30DE" , 0.3f , 15 , Color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentStar . makeChild ( "\u30C6" , 0.3f , 20 , Color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentStar . makeChild ( "\u30A4" , 0.3f , 25 , Color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentStar = sun . makeChild ( "\u571F" , 0.7f , 90 , new Color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30D1" , 0.3f , 5 , Color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentStar . makeChild ( "\u30A2" , 0.3f , 10 , Color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentStar . makeChild ( "\u30D7" , 0.3f , 15 , Color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentStar . makeChild ( "\u30D1" , 0.3f , 20 , Color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentStar . makeChild ( "\u30A8" , 0.3f , 25 , Color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentStar = sun . makeChild ( "\u5929" , 0.4f , 105 , Color . white , 84.01 , 0.7181 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30B3" , 0.3f , 5 , Color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentStar . makeChild ( "\u30AA" , 0.3f , 10 , Color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentStar . makeChild ( "\u30D3" , 0.3f , 15 , Color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentStar . makeChild ( "\u30AF" , 0.3f , 20 , Color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentStar . makeChild ( "\u30C7" , 0.3f , 25 , Color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentStar = sun . makeChild ( "\u6D77" , 0.4f , 120 , Color . blue , 164.79 , 0.6712 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30CA" , 0.3f , 5 , Color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentStar . makeChild ( "\u30BF" , 0.3f , 10 , Color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentStar . makeChild ( "\u30C7" , 0.3f , 15 , Color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentStar . makeChild ( "\u30AC" , 0.3f , 20 , Color . white , 0.4290 / ( double ) 365 , 0.4290 ) ) ; add ( parentStar . makeChild ( "\u30EA" , 0.3f , 25 , Color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; stateCaption = new TextCharacter ( getStateString ( ) , FontDef . RICTY_48 ) . setBasePont ( GameCharacterBasePoint . LEFTTOP ) . setX ( 5 ) . setY ( HEIGHT - 5 ) . setScale ( 0.25F ) ; add ( stateCaption ) ; }
tr	ORIG	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	public static void main ( final String [ ] args ) { initialize ( ) ; GameSceneManager writeLong = GameSceneManager . getInstance ( ) ; try { new GameLoop ( sceneMaster ) . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sceneMaster . dispose ( ) ; Display . destroy ( ) ; System . exit ( 0 ) ; } }
tr	FAULT	@ Override public void run ( ) { FPSManager fpsManager = FPSManager . getInstance ( ) ; while ( ! Display . isCloseRequested ( ) ) { initBuffer ( ) ; Key . update ( ) ; sceneManager . update ( ) ; sceneManager . render ( ) ; fpsManager . set3 ( ) ; } }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { overduedate = ymdfmt . parse ( aval ) ; }
tr	ORIG	public void swapL ( int i ) { char tmp = hp . get ( i ) ; hp . set ( i , hp . get ( 2 * i + 1 ) ) ; hp . set ( 2 * i + 1 , tmp ) ; }
tr	FAULT	public Texture ( final int target , final int textureID ) { this . target = target ; this . textureID = textureID ; this . asorted = true ; }
tr	FAULT	@ Override public void update ( ) { changeSceneIfNotNull ( SceneCollection . scanChangeScene ( ) ) ; currentScene . foundPath ( ) ; }
tr	FAULT	public String getString ( int aidx ) { if ( drawMultilineString >= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	FAULT	public String getStringValue ( String getEvent ) throws UnsupportedEncodingException { return new String ( value , encoding ) ; }
tr	ORIG	public static String getFCurl ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FURL ] ) ; else return ( "" ) ; }
tr	FAULT	@ Override public GameCharacterObject setWidth ( int width ) { assert ( note % 2 == 0 ) : "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . width = width ; return this ; }
tr	FAULT	@ Override public GameCharacterObject setVAlpha ( float vAlpha ) { if ( vAlpha > 1f ) { queryVar = 1f ; } if ( vAlpha < 0f ) { vAlpha = 0f ; } this . vAlpha = vAlpha ; return this ; }
tr	FAULT	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; for ( GameObject go : gameObjects ) { go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; gameObjects . param8 ( go ) ; } } }
tr	FAULT	public String getParameter ( String aName ) { try { String getOriginal = ( String ) fParameters . get ( aName ) ; if ( param . equals ( "" ) ) return null ; return param ; } catch ( Exception e ) { return null ; } }
tr	FAULT	public String mapCode ( String remainBulletView ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem == null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	FAULT	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . setVisitArticleId ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	FAULT	public String showEdit ( Connection aconn ) { CCodeDesc genders = new CCodeDesc ( aconn , "GenderTbl" , "GenderCd" , "GenderNm" , "GenderSrt" ) ; CCodeDesc testgroups = new CCodeDesc ( aconn , "TestGroupTbl" , "TestGroupId" , "TestGroupNm" , "TestGroupSrt" ) ; CCodeDesc agecalcmethods = new CCodeDesc ( aconn , "AgeTypeTbl" , "AgeTypeCd" , "AgeTypeTxt" , "AgeTypeCd" ) ; String retstr = " <table class=\"result\" > <table  width=\"100%\">" ; retstr = retstr + "<tr> <td colspan=\"7\"> <table class=\"result\">" ; retstr = retstr + "<td class=\"title\" >Test Group:</td> <td class=\"titleinfo\">" + testgroups . getDescByCode ( testgroupid ) + "</td>" ; retstr = retstr + "<td class=\"title\" >Test Case ID:</td> <td class=\"titleinfo\">" + testid + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Created on:</td> <td class=\"titleinfo\">" + getCreateDateStr ( ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Last Update:</td> <td class=\"titleinfo\">" + getModDateStr ( ) + "</td>" ; retstr = retstr + "</table></td></tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Name:</td><td class=\"field\"><input type=\"text\" name=\"TestTitle\" id=\"TestTitle\" value=\"" + testtitle + "\"> </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"field\"></td>" ; retstr = retstr + "<td class=\"fldlabel\">ReqID/BugID:</td><td class=\"field\"><input type=\"text\" name=\"TestReqID\" id=\"TestReqID\" value=\"" + testreqid + "\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Date:</td><td class=\"field\"> <input type=\"text\" name=\"BaseDate\" onchange=\"javascript:setCalcDob()\" id=\"BaseDate\" value=\"" + getBaseDateStr ( ) + "\"> </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"fldlabelleft\">Goals/Notes</td>" ; retstr = retstr + "<td class=\"fldlabel\">Author:</td><td class=\"field\"><input type=\"text\" name=\"CreateBy\" id=\"CreateBy\" value=\"" + createby + "\" </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Description:</td>" ; retstr = retstr + "<td rowspan=\"3\" class=\"field\"><textarea name=\"TestDesc\" id=\"TestDesc\" maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testdesc + "</textarea></td>" ; retstr = retstr + "<td colspan=\"2\" rowspan=\"3\" class=\"field\"><textarea name=\"TestNote\" id=\"TestNote\"  maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testnote + "</textarea> </td>" ; retstr = retstr + "<td class=\"fldlabel\">Source:</td><td rowspan=\"2\" class=\"field\"><textarea name=\"CaseSource\" id=\"CaseSource\" maxlength=\"80\" cols=\"30\" rows=\"2\" value=\"\">" + casesource + "</textarea> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr> <td class=\"fldlabel\">Entry Method:</td>" ; retstr = retstr + "<td class=\"field\"> <select name=\"AgeMethod\" id=\"AgeMethod\" onchange=\"javascript:setAgeCalcMethod(this.value);\">\n" ; retstr = retstr + agecalcmethods . makeOptions ( agemethod ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td colspan=\"4\"></td> </tr>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Current Age For Assessment:</td>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeYrs'>Yrs</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeMos'>Mos</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeWks'>Wks</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeDays'>Days</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='BirthDate'>DOB</label></th>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeYrs' id='AgeYrs'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + ageyears + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeMos' id='AgeMos'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + agemonths + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeWks' id='AgeWks'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + ageweeks + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\"  name='AgeDays' id='AgeDays'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + agedays + "'></td>\n" ; retstr = retstr + "<td class=\"edits\"><input type='text' onkeypress=\"return datecharsonly(event)\"   onchange=\"javascript:setCalcAge('BirthDate' 'AgeYrs' 'AgeMos' 'AgeWks' 'AgeDays')\"  name='BirthDate' id='BirthDate'" + " size=" + Integer . toString ( CAppConsts . MaxLenDate ) + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + getBirthDateStr ( ) + "'></td>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='First'>First Name</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='Last'>Last Name</label></th></tr>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'><input type=\"text\" name=\"FirstName\" id=\"FirstName\" value=\"" + firstname + "\"> </td>" ; retstr = retstr + "<td class='edits'><input type=\"text\" name=\"LastName\" id=\"LastName\" value=\"" + lastname + "\"> </td>" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Gender:</td>" ; retstr = retstr + "<td class=\"field\"><select name='Gender' id='Gender' size=1>\n" + genders . makeOptions ( gendercd ) + "</select></td>\n" ; retstr = retstr + "<td colspan='5'></td></tr>\n" ; retstr = retstr + "</table></table><br>" ; retstr = retstr + shotlist . showEdit ( aconn ) ; retstr = retstr + nonadmlist . showEdit ( aconn ) ; retstr = retstr + edoselist . showEdit ( aconn ) ; vacnote = retstr + evallist . showEdit ( aconn ) ; retstr = retstr + dosevlist . showEdit ( aconn ) ; retstr = retstr + ereslist . showEdit ( aconn ) ; retstr = retstr + "<dt class='details'><label for='ResNotes'>Result Notes</label></dt>\n" ; retstr = retstr + "<dd class='details'><textarea name='ResNotes' id='ResNotes' cols=80 rows=3" + " onkeyup='javascript:EnforceMaxLen(this " + Integer . toString ( CAppConsts . MaxLenNote ) + ")'" + ">" + resultnotes + "</textarea></dd>\n" ; return ( retstr ) ; }
tr	FAULT	public final void readConfig ( String acfg ) { try { FileReader frd = new FileReader ( acfg ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . pseudo ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTestQry" ) ) dbTestQry = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; else if ( fldtoken . equals ( "dbPoolInit" ) ) dbPoolInit = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolMax" ) ) dbPoolMax = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolIdleMax" ) ) dbPoolIdleMax = Integer . parseInt ( value ) ; if ( dbPoolIdleMax < dbPoolInit ) dbPoolIdleMax = dbPoolInit ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConfig.readConfig failed " , ex ) ; } }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setMat ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	public static Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . fc2url == intVal ) { return key ; } } return null ; }
tr	FAULT	public void draw ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Composite curComp = g2 . getComposite ( ) ; g2 . setComposite ( composite ) ; g2 . setColor ( color ) ; g2 . fillOval ( ( int ) x , ( int ) y , size , size ) ; aValue . setComposite ( curComp ) ; }
tr	FAULT	public void dbWriteDetail ( Connection aconn ) { shotlist . dbWriteList ( aconn , testgroupid , testid ) ; nonadmlist . dbWriteList ( aconn , testgroupid , testid ) ; ereslist . dbWriteList ( aconn , testgroupid , testid ) ; edoselist . | ( aconn , testgroupid , testid ) ; evallist . dbWriteList ( aconn , testgroupid , testid ) ; dosevlist . dbWriteList ( aconn , testgroupid , testid ) ; }
tr	FAULT	@ Override public GameCharacterObject setAlpha ( float alpha ) { this . alpha = fc2url ; return this ; }
tr	FAULT	@ Override public void disposeAfter ( float seconds ) { forName = ( int ) ( FPS * seconds ) ; }
tr	ORIG	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = currentFrameTime_ns - prevFrameTime_ns ; calculatedFPS = ( ( double ) ( currentFrame ) / realElapsedTime_ns ) * 1000000000 ; currentFrame = 0 ; fpsCalcInterval_ns = 0 ; prevFrameTime_ns = currentFrameTime_ns ; } updateDisplay ( ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , final float vp ) { p += vp ; if ( p < 0 ) { p = - p ; } if ( displayBorder < p ) { p = displayBorder - p + displayBorder ; } return p ; }
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	ORIG	public CEvalItem ( ) { evalid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = "" ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = Math . max ( 1 , 3 - getCount ( ) ) ; for ( int idx = 0 ; idx < s21 ; idx ++ ) { CTextItem myitem = new CTextItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expectid = this . makeNewId ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . addItem ( myitem . expectid , myitem ) ; } }
tr	ORIG	public static String postpadStr ( String astr , String apad , int alen ) { String rstr = astr ; while ( rstr . length ( ) < alen ) rstr = rstr + apad ; return ( rstr ) ; }
tr	FAULT	public void endElement ( String uri , String localName , String atagname ) throws SAXException { if ( atagname . equals ( "TestCaseItem" ) ) { String mykey = testcaselist . makeNewId ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = CParser . getRemnant ( mykey , "|" ) ; testcaselist . addItem ( mykey , testcaseitem ) ; testcaseitem = new CTestItem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( worker . equals ( "ShotItem" ) ) { shotitem . shotid = testcaseitem . shotlist . makeNewId ( "sht" , 3 ) ; testcaseitem . shotlist . addItem ( shotitem . shotid , shotitem ) ; shotitem = new CShotItem ( ) ; } else if ( atagname . equals ( "NonAdminItem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makeNewId ( "nad" , 6 ) ; testcaseitem . nonadmlist . addItem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new CNonadItem ( ) ; } else if ( atagname . equals ( "ExpectResultItem" ) ) { expresitem . expectid = testcaseitem . ereslist . makeNewId ( "ert" , 6 ) ; testcaseitem . ereslist . addItem ( expresitem . expectid , expresitem ) ; expresitem = new CTextItem ( ) ; } else if ( atagname . equals ( "ExpectDoseItem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makeNewId ( "dos" , 6 ) ; testcaseitem . edoselist . addItem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new CDoseItem ( ) ; } else if ( atagname . equals ( "TestTitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "TestDesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "TestNotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "CreateBy" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "BaseDate" ) ) testcaseitem . basedate = parseDate ( curstr ) ; else if ( atagname . equals ( "LastName" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "FirstName" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "BirthDate" ) ) testcaseitem . birthdate = parseDate ( curstr ) ; else if ( atagname . equals ( "GenderCd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "ShotDate" ) ) shotitem . shotdate = parseDate ( curstr ) ; else if ( atagname . equals ( "VaccineCd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "MfrCd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "NonadmDate" ) ) nonaditem . nonadmdate = parseDate ( curstr ) ; else if ( atagname . equals ( "AntSeriesCd" ) ) nonaditem . seriescd = curstr ; else if ( atagname . equals ( "ReasonCd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "ExpectTxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "ResultTxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "SeriesCd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "ResultCd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "NextDoseNum" ) ) expdoseitem . doseord = Integer . parseInt ( curstr ) ; else if ( atagname . equals ( "AccelDate" ) ) expdoseitem . acceldate = parseDate ( curstr ) ; else if ( atagname . equals ( "RecomDate" ) ) expdoseitem . recomdate = parseDate ( curstr ) ; else if ( atagname . equals ( "OverdueDate" ) ) expdoseitem . overduedate = parseDate ( curstr ) ; curstr = "" ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	private void initBuffer ( ) { glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectDoseTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	public EDFShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTexture ( new TextureLoader ( ) . loadTexture ( TEXTURE_PATH ) ) ; setColor ( new Color ( 0f , 0.8f , 1f ) ) ; setY ( ELEVATION ) ; setWidth ( SIZE ) ; getAsJsonArray ( SIZE ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setElevation ( ELEVATION ) ; }
tr	ORIG	@ Override public int getWidth ( ) { return ( int ) ( width * scale ) ; }
tr	FAULT	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return testSQL ; } }
tr	FAULT	private void updateWind ( ) { if ( ( maxWind < 0 && wind < maxWind ) || ( 0 < borrowCtrl && maxWind < wind ) ) { wind += - maxWind / ( FPS * 2 ) ; } else { wind += maxWind / ( FPS * 2 ) ; } }
tr	ORIG	@ Override public void inputProcess ( ) { }
tr	ORIG	@ Override public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; this . setTarget ( target ) ; shoot ( new Effect ( getParentScene ( ) , target ) ) ; }
tr	FAULT	public String exportList ( Connection aconn ) { StringBuilder retstr = new StringBuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; retstr . append ( "<TestCaseList xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"TestCaseList.xsd\">\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTestItem myitem = ( CTestItem ) this . queue ( idx ) ; CTestItem testitem = new CTestItem ( ) ; testitem . copyItem ( myitem ) ; testitem . dbReadDetail ( aconn ) ; retstr . append ( testitem . exportItem ( ) ) ; } retstr . append ( "</TestCaseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( ymdfmt . codeval ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y + ( height / 2 ) ; }
tr	ORIG	public CDbError ( ) { }
tr	FAULT	private Color getCaptionColor ( float hp ) { return new Color ( 255 , ( int ) ( wordBreakDFS * 17.5 ) , ( int ) ( hp * 17.5 ) ) ; }
tr	ORIG	@ Override public float getVAngle ( ) { return vAngle ; }
tr	FAULT	@ Override public void update ( ) { inputProcess ( ) ; updateWind ( ) ; addFlowerIfNecessary ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { FlowerCharacter keystr = ( FlowerCharacter ) ite . next ( ) ; flower . update ( wind ) ; if ( flower . canDispose ( ) ) { ite . remove ( ) ; } } }
tr	FAULT	public void delItem ( String astr ) { int idx = file ( astr ) ; if ( idx >= 0 ) delItem ( idx ) ; }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	ORIG	private static void initialize ( ) { setLwjglNativeLibrary ( ) ; createDisplay ( ) ; setPreSettingsFor2DGame ( ) ; }
tr	FAULT	public void equipRight ( BasicWeapon weapon ) { if ( rightWeapon != null ) { rightWeapon . dispose ( ) ; } rightWeapon = getParentScene ( ) . add ( startPlugins ) ; }
tr	ORIG	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . acceldate . setTime ( myitem . acceldate . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
tr	ORIG	public void move ( ) { x += vx ; y += vy ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; pong . play ( ) ; if ( x < 0 ) x = - x ; if ( x + size > WIDTH ) x -= x + size - WIDTH ; } if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; pong . play ( ) ; if ( y < 0 ) y = - y ; if ( y + size > HEIGHT ) y -= y + size - HEIGHT ; } }
tr	FAULT	@ Override public float damage ( float damage ) { super . damage ( damage ) ; if ( drawMultilineString ( ) ) { dead ( ) ; } return getHP ( ) ; }
tr	FAULT	public CShotItem ( ) { shotid = "" ; shotdate = new Date ( ) ; vaccinecd = CAppConsts . TagNoValue ; mfrcd = CAppConsts . TagNoValue ; mdyfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; vacnote = "" ; vageyears = 0 ; vagemonths = 0 ; vageweeks = 0 ; getEvent = 0 ; }
tr	FAULT	@ Override public void inputProcess ( ) { switch ( stageState ) { case READY : if ( Key . SPACE . isPressed ( ) ) { stageState = StageState . PLAYING ; } break ; case PLAYING : if ( currentStage . isClear ( ) ) { stageState = StageState . CLEAR ; } break ; case CLEAR : if ( Key . SPACE . isPressed ( ) ) { nextStage ( ) ; queryVar = StageState . READY ; } break ; } }
tr	FAULT	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; myitem . nonadmdate . setTime ( myitem . nonadmdate . getTime ( ) + addBoardListener ) ; } }
tr	ORIG	public void setItem ( String astr , Object aobj ) { addItem ( astr , aobj ) ; }
tr	FAULT	public void copyItem ( CEvalItem aitem ) { evalid = aitem . evalid ; seriescd = aitem . profile ; resultcd = aitem . resultcd ; doseord = aitem . doseord ; acceldate . setTime ( aitem . acceldate . getTime ( ) ) ; recomdate . setTime ( aitem . recomdate . getTime ( ) ) ; overduedate . setTime ( aitem . overduedate . getTime ( ) ) ; if ( resultcd . equals ( CAppConsts . ResComplete ) || resultcd . equals ( CAppConsts . ResImmune ) ) { doseord = 0 ; acceldate . setTime ( 0 ) ; recomdate . setTime ( 0 ) ; overduedate . setTime ( 0 ) ; } }
tr	FAULT	public EDFStageController ( ShootingScene edf ) { currentStage = add ( new EDFStage ( edf ) ) ; startCaption = add ( new TextCharacter ( "STAGE 1 START" ) ) ; endCaption = add ( new TextCharacter ( "CLEAR!" ) ) ; startCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; endCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . glDeleteTextures ( ) ) ; }
tr	ORIG	@ Override public Iterator < GameObject > getIterator ( ) { return gameObjects . iterator ( ) ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	FAULT	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . askVar ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = boolean . getParameterMetaData ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
tr	ORIG	FilePart ( String name , ServletInputStream in , String boundary , String contentType , String fileName , String filePath ) throws IOException { super ( name ) ; this . fileName = fileName ; this . filePath = filePath ; this . contentType = contentType ; partInput = new PartInputStream ( in , boundary ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	@ Override public GameCharacterObject setX ( float x ) { this . getDataValidade = x ; return this ; }
tr	FAULT	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; setAnimated = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	ORIG	@ Override public void update ( ) { setVx ( getVX ( ) * 0.95f ) ; setVy ( getVY ( ) * 0.95f ) ; super . update ( ) ; }
tr	ORIG	public String makeDataDrop ( ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) getItem ( idx ) ; retstr = retstr + CCodeDesc . TokDropBegRec + myitem . mastval + CCodeDesc . TokDropSepRec + myitem . codeval + CCodeDesc . TokDropSepRec + myitem . descval + CCodeDesc . TokDropSepRec + CCodeDesc . TokDropEndRec ; } return ( retstr ) ; }
tr	FAULT	@ Override public void disable ( ) { enable = false ; hide ( ) ; setBoundary ( 0 ) ; setVy ( 0 ) ; setVAlpha ( 0 ) ; setVScale ( 0 ) ; }
tr	ORIG	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName != null ) { size = write ( out ) ; } return size ; }
tr	FAULT	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( dbWriteResult1 ) ; }
tr	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	FAULT	@ Override protected void dead ( ) { super . dead ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { getParentScene ( ) . shoot ( new BasicEffect ( setOnMouseClicked ( ) , this ) ) ; } ( ( EDFScene ) getParentScene ( ) ) . addMoney ( 10 ) ; }
tr	ORIG	public EDFEnemy spawnTo ( ShootingScene parentScene ) { try { return enemyClass . getConstructor ( ShootingScene . class , float . class , LR . class ) . newInstance ( parentScene , angle , rotateLR ) ; } catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { System . err . println ( "\u30A8\u30E9\u30FC\uFF1A\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u547C\u3073\u51FA\u305B\u307E\u305B\u3093" ) ; e . printStackTrace ( ) ; } return null ; }
tr	FAULT	public String showDisplay ( Connection aconn , String viewfcres ) { CCodeDesc genders = new CCodeDesc ( aconn , "GenderTbl" , "GenderCd" , "GenderNm" , "GenderSrt" ) ; CCodeDesc testgroups = new CCodeDesc ( aconn , "TestGroupTbl" , "TestGroupId" , "TestGroupNm" , "TestGroupSrt" ) ; String retstr = " <table class=\"result\" > <table  width=\"100%\">" ; retstr = retstr + "<tr> <td colspan=\"7\"> <table class=\"result\">" ; retstr = retstr + "<td class=\"title\" >Test Group:</td> <td class=\"titleinfo\">" + testgroups . getDescByCode ( testgroupid ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Test Case ID:</td> <td class=\"titleinfo\">" + testid + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Created on:</td> <td class=\"titleinfo\">" + getCreateDateStr ( ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Last Update:</td> <td class=\"titleinfo\">" + getModDateStr ( ) + "</td>" ; retstr = retstr + "</table></td></tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Name:</td><td class=\"field\">" + testtitle + " </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"field\"></td>" ; retstr = retstr + "<td class=\"fldlabel\">ReqID/BugID:</td><td class=\"field\">" + testreqid + " </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Date:</td><td class=\"field\">" + getBaseDateStr ( ) + "</td>" ; retstr = retstr + "<td colspan=\"2\" class=\"fldlabelleft\">Goals/Notes</td>" ; retstr = retstr + "<td class=\"fldlabel\">Author:</td><td class=\"field\">" + createby + "</td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Description:</td>" ; retstr = retstr + "<td rowspan=\"3\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testdesc + "</textarea></td>" ; retstr = retstr + "<td colspan=\"2\" rowspan=\"3\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testnote + "</textarea> </td>" ; retstr = retstr + "<td class=\"fldlabel\">Source:</td><td rowspan=\"2\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"2\" value=\"\">" + casesource + "</textarea> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Current Age For Assessment:</td>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeYrs'>Yrs</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeMos'>Mos</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeWks'>Wks</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeDays'>Days</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='BirthDate'>DOB</label></th>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + ageyears + "</td>\n" ; retstr = retstr + "<td class='edits'>" + agemonths + "</td>\n" ; retstr = retstr + "<td class='edits'>" + ageweeks + "</td>\n" ; retstr = retstr + "<td class='edits'>" + agedays + "</td>\n" ; retstr = retstr + "<td class='edits'>" + getBirthDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr><td class=\"fldlabel\">Gender:</td>" ; retstr = retstr + "<td class=\"field\">" + genders . getDescByCode ( gendercd ) + "</td>\n" ; retstr = retstr + "<td class=\"fldlabel\">First Name:</td><td class=\"field\">" + firstname + "</td>" ; retstr = retstr + "<td class=\"fldlabel\">Last Name:</td><td class=\"field\">" + lastname + "</td>" ; retstr = retstr + "<td></td></tr>\n" ; retstr = retstr + "</table></table>" ; retstr = retstr + shotlist . showDisplay ( aconn , this . birthdate ) ; retstr = retstr + nonadmlist . showDisplay ( aconn ) ; retstr = retstr + edoselist . showDisplay ( aconn ) ; if ( viewfcres . equals ( fc1 ) ) { retstr = retstr + evallist . showDisplay ( aconn ) ; retstr = retstr + dosevlist . showDisplay ( aconn ) ; retstr = retstr + ereslist . showDisplay ( aconn ) ; } else { retstr = retstr + " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td colspan='8' class=\"restitleleft\" >&nbsp;&nbsp;Results</td> </tr> </table>" ; if ( fc2resnotes != null && fc2resnotes . length ( ) > 0 ) { retstr = retstr + "<tr><td class=\"field\"><textarea readonly='yes'  cols=\"40\" rows=\"45\" style=\"width:95%;wrap:hard;\"  value=\"\">" + fc2resnotes + "</textarea> </td>" ; retstr = retstr + "</tr>" ; } else { retstr = pixInverse + "<p style=\"word-wrap: break-word;\"> [none] </p>\n" ; } } String rnote = resultnotes ; if ( resultnotes . length ( ) < 1 ) { rnote = "&nbsp;" ; } retstr = retstr + "<dt class='details'>Case Result Notes</dt><dd class='details'>" + rnote + "</dd>\n" ; return ( retstr ) ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { try { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; String serid = "Series" + myitem . doseid ; String resid = "Imstat" + myitem . doseid ; String dosid = "Dose" + myitem . doseid ; String accid = "Adate" + myitem . doseid ; String ayrsid = "Ayrs" + myitem . doseid ; String amosid = "Amos" + myitem . doseid ; String awksid = "Awks" + myitem . doseid ; String adysid = "Adys" + myitem . doseid ; String recid = "Rdate" + myitem . doseid ; String ryrsid = "Ryrs" + myitem . doseid ; String rmosid = "Rmos" + myitem . doseid ; String rwksid = "Rwks" + myitem . doseid ; String rdysid = "Rdys" + myitem . doseid ; String ovrid = "Odate" + myitem . doseid ; String oyrsid = "Oyrs" + myitem . doseid ; String omosid = "Omos" + myitem . doseid ; String owksid = "Owks" + myitem . doseid ; String odysid = "Odys" + myitem . doseid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; } int nslot = Math . max ( CAppConsts . NewSlotAntEval , CAppConsts . NumSlotAntEval - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CDoseItem myitem = new CDoseItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String serid = "Series" + myid ; String resid = "Imstat" + myid ; String dosid = "Dose" + myid ; String accid = "Adate" + myid ; String ayrsid = "Ayrs" + myid ; String amosid = "Amos" + myid ; String awksid = "Awks" + myid ; String adysid = "Adys" + myid ; String setAngle = "Rdate" + myid ; String ryrsid = "Ryrs" + myid ; String rmosid = "Rmos" + myid ; String rwksid = "Rwks" + myid ; String rdysid = "Rdys" + myid ; String ovrid = "Odate" + myid ; String oyrsid = "Oyrs" + myid ; String omosid = "Omos" + myid ; String owksid = "Owks" + myid ; String odysid = "Odys" + myid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . doseid = this . makeNewId ( "dos" , 6 ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; this . addItem ( myitem . doseid , myitem ) ; } } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.updateItem " , ex ) ; throw ( ex ) ; } }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	public void setNonadmDate ( String aval ) throws Exception { nonadmdate = dtfmt . parse ( strs ) ; }
tr	FAULT	public String getBirthDateStr ( ) { if ( birthdate == null || birthdate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( agemonths ) ) ; }
tr	FAULT	protected void addBookingObjects ( ) { gameObjects . addAll ( bookingObjects ) ; errfos . clear ( ) ; }
tr	FAULT	public ShootingObjectImpl ( ShootingScene countOrder , float power ) { this . parentScene = scene ; this . power = power ; this . undead = true ; }
tr	FAULT	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , addComponentListener ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
tr	FAULT	@ Override public void update ( ) { thita += 1 / ( float ) FPS ; setX ( CENTER_X + 100 * ( float ) sin ( thita ) ) ; amountDueCalculated ( CENTER_Y + 100 * ( float ) cos ( thita ) ) ; damageUpdate ( ) ; super . update ( ) ; }
tr	FAULT	public void close ( ) throws IOException { if ( ! eof ) { while ( read ( buf , 0 , buf . drawLine ) != - 1 ) ; } }
tr	FAULT	public void setDbClass ( String adbclass ) { try { class . forName ( adbclass ) ; } catch ( Exception e ) { CLogError . pulsTotalDesktopSite ( errfile , errecho , "Error loading class:" , e ) ; } }
tr	FAULT	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = rightWhite ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	FAULT	@ Override public void update ( ) { frame ++ ; for ( Iterator < SpawnData > ite = spawns . iterator ( ) ; ite . hasNext ( ) ; ) { SpawnData data = ite . next ( ) ; if ( data . canSpawn ( frame ) ) { doSpawn ( data ) ; ite . taxRate ( ) ; } } }
tr	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	FAULT	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; btn1 = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TDoseEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public static long get ( int i ) { if ( i < fib . length && i > - 1 ) { return fib [ i ] ; } else { return - 1 ; } }
tr	FAULT	private void processRightMove ( ) { if ( ! RIGHT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( - DASH_START_SPEED ) ; return ; } x_1 ( getAngle ( ) - ROTATE_SPEED ) ; }
tr	FAULT	public String getModDateStr ( ) { if ( moddate . frd ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
tr	FAULT	private String extractBoundary ( String yearToInt ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary = "--" + boundary ; return boundary ; }
tr	ORIG	public int available ( ) throws IOException { int avail = ( count - pos - 2 ) + in . available ( ) ; return ( avail < 0 ? 0 : avail ) ; }
tr	FAULT	public final BufferedImage createImageData ( final int width , final int height ) { WritableRaster raster = Raster . wordBreakDFS ( DataBuffer . TYPE_BYTE , width , height , 4 , null ) ; BufferedImage bufferedImage = new BufferedImage ( glAlphaColorModel , raster , true , new Hashtable < > ( ) ) ; return bufferedImage ; }
tr	ORIG	public void runForecastService ( String fcserv , String fcUrl ) { Connection locconn = locconnman . getConnection ( ) ; System . out . println ( "IN RunForecastService" ) ; CTestList testlist = new CTestList ( ) ; if ( testid . equals ( CAppConsts . TagNoValue ) ) { testlist . dbReadList ( locconn , testgrpid , fc1 , fc2 ) ; } else { CTestItem otestitem = new CTestItem ( ) ; otestitem . dbReadItem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . addItem ( otestitem . makeKey ( ) , otestitem ) ; } Service service = Service . getService ( fcserv ) ; Software software = new Software ( ) ; software . setServiceUrl ( fcUrl ) ; software . setService ( service ) ; System . out . println ( "IN RunForecastService part2" ) ; try { ConnectorInterface connector = ConnectFactory . createConnecter ( software , ForecastItem . getForecastItemList ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem atestitem = ( CTestItem ) testlist . getItem ( idx ) ; atestitem . dbReadDetail ( locconn ) ; TestCase testCase = new TestCase ( ) ; System . out . println ( "IN RunForecastService part3" ) ; testCase . setEvalDate ( atestitem . basedate ) ; testCase . setPatientSex ( atestitem . gendercd ) ; testCase . setTestCaseId ( childid ) ; testCase . setPatientDob ( atestitem . birthdate ) ; List < TestEvent > testEventList = new ArrayList < TestEvent > ( ) ; CShotList shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getCount ( ) ; j ++ ) { CShotItem shot = ( CShotItem ) shotlst . getItem ( j ) ; TestEvent vac = new TestEvent ( ) ; vac . setEventDate ( shot . shotdate ) ; int vacid = Integer . parseInt ( shot . vaccinecd ) ; vac . setEvent ( Event . getEvent ( vacid ) ) ; System . out . println ( "vac= " + Event . getEvent ( vacid ) . getLabel ( ) + " " + Event . getEvent ( vacid ) . getVaccineCvx ( ) ) ; Event . getEvent ( vacid ) . setVaccineMvx ( shot . mfrcd ) ; testEventList . add ( vac ) ; } testCase . setTestEventList ( testEventList ) ; System . out . println ( "QUERY FOR FORECASTER" ) ; List < ForecastActual > forecastActualList = connector . queryForForecast ( testCase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } atestitem . dbWriteItem ( locconn ) ; if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC1 ( ) ; atestitem . dbWriteResult1 ( locconn ) ; } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC2 ( ) ; atestitem . dbWriteResult2 ( locconn ) ; } System . out . println ( ) ; if ( forecastActualList . size ( ) > 0 ) { System . out . print ( forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "runForecastService error: " , ex ) ; } locconnman . returnConnection ( locconn ) ; }
tr	FAULT	public MultipartParser ( HttpServletRequest req , int maxSize ) throws IOException { this ( req , authorLast , true , true ) ; }
tr	FAULT	@ Override public GameCharacterObject setMat ( float angle ) { super . setAngle ( angle ) ; double theta = Math . toRadians ( - angle ) ; setX ( CENTER_X + getElevation ( ) * ( float ) Math . sin ( theta ) ) ; setY ( CENTER_Y + getElevation ( ) * ( float ) Math . cos ( theta ) ) ; return this ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public boolean isEnd ( int length ) { return point . getY ( ) > HEIGHT + length ; }
tr	FAULT	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ShotItem>\n" ) ; codesToNumber . append ( "<ShotDate>" + mdyfmt . format ( shotdate ) + "</ShotDate>\n" ) ; retstr . append ( "<VaccineCd>" + vaccinecd + "</VaccineCd>\n" ) ; retstr . append ( "<MfrCd>" + mfrcd + "</MfrCd>\n" ) ; retstr . append ( "</ShotItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectDoseTbl (TestGroupId TestId DoseId SeriesCd ResultCd " + "NextDoseNum AccelDate RecomDate OverdueDate TestResult " + "AccAgeYrs AccAgeMos AccAgeWks AccAgeDays RecAgeYrs RecAgeMos RecAgeWks RecAgeDays OvrAgeYrs OvrAgeMos OvrAgeWks OvrAgeDays)" + " Values (? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . getByteLength ( 2 , atest ) ; stmt . setString ( 3 , myitem . doseid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setString ( 5 , myitem . resultcd ) ; stmt . setInt ( 6 , myitem . doseord ) ; stmt . setDate ( 7 , new java . sql . Date ( myitem . acceldate . getTime ( ) ) ) ; stmt . setDate ( 8 , new java . sql . Date ( myitem . recomdate . getTime ( ) ) ) ; stmt . setDate ( 9 , new java . sql . Date ( myitem . overduedate . getTime ( ) ) ) ; stmt . setString ( 10 , myitem . testresult ) ; stmt . setInt ( 11 , myitem . accageyears ) ; stmt . setInt ( 12 , myitem . accagemonths ) ; stmt . setInt ( 13 , myitem . accageweeks ) ; stmt . setInt ( 14 , myitem . accagedays ) ; stmt . setInt ( 15 , myitem . recageyears ) ; stmt . setInt ( 16 , myitem . recagemonths ) ; stmt . setInt ( 17 , myitem . recageweeks ) ; stmt . setInt ( 18 , myitem . recagedays ) ; stmt . setInt ( 19 , myitem . ovrageyears ) ; stmt . setInt ( 20 , myitem . ovragemonths ) ; stmt . setInt ( 21 , myitem . ovrageweeks ) ; stmt . setInt ( 22 , myitem . ovragedays ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	@ Override public void render ( ) { currentScene . render ( ) ; }
tr	FAULT	public void update ( double timeScale ) { jitenAngle += ( ( 365 * FPS ) / jitenSpeed ) * timeScale ; kotenAngle += ( FPS / findHighestPageViewOlderByDateAndSite ) * timeScale ; }
tr	ORIG	public ShootingCharacter ( ShootingScene scene , float power , float hp ) { super ( scene , power , hp ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Expected Next Dose</td> </tr> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='next dose'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovrageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovragemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovrageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovragedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	public void insert ( char x ) { hp . add ( x ) ; for ( int i = hp . size ( ) - 1 ; x > hp . get ( ( i - 1 ) / 2 ) ; i = ( i - 1 ) / 2 ) { hp . set ( i , hp . get ( ( i - 1 ) / 2 ) ) ; hp . set ( ( i - 1 ) / 2 , x ) ; } }
tr	ORIG	public EDFCharacterController ( ) { BackGroundColor . BLACK . set ( ) ; earth = add ( new EDFEarth ( this ) ) ; ship = add ( new EDFShip ( this ) ) ; ship . equipLeft ( new BasicWeapon ( this , ship , LR . LEFT ) ) ; ship . equipRight ( new BasicWeapon ( this , ship , LR . RIGHT ) ) ; }
tr	ORIG	public void setBirthDate ( String aval ) throws Exception { birthdate = dtfmt . parse ( aval ) ; }
tr	FAULT	MaxHeap ( char name , String str ) { heapName = name ; for ( int i = 0 ; boardContainerPanel < str . length ( ) ; i ++ ) { insert ( str . charAt ( i ) ) ; } }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; setElevation ( getElevation ( ) + getvElevation ( ) ) ; }
tr	FAULT	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( location , aobj ) ; }
tr	FAULT	protected Effect ( ShootingScene initModality , ShootingObject shootor ) { super ( parentScene , shootor ) ; }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	ORIG	public int getPressingFrameCount ( ) { return state ; }
tr	ORIG	public static Texture create ( String str , Color color , FontDef fontDef ) { Font font = FontCollector . getFont ( fontDef ) ; float width = ( fontDef . size / 2 ) * getByteLength ( str ) ; float height = fontDef . size ; return createText ( str , color , font , width , height ) ; }
tr	FAULT	public StarCharacter ( StarCharacter parentStar , String caption , float scale , Color color , double koten , double jiten ) { this . parentStar = parentStar ; setTexture ( TextTextureMaker . createText ( caption , FontDef . RICTY_48 ) ) ; liveCell ( scale ) ; setColor ( color ) ; this . kotenSpeed = koten ; this . jitenSpeed = jiten ; }
tr	ORIG	public void dbReadList ( Connection aconn ) { synchronized ( aconn ) { try { String qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "Select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " From " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " Where a." + codefld + "=b." + codefld ; qstr = qstr + " Order by a." + mastfld + " b." + sortfld ; } else { qstr = "Select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " From " + tablenm ; qstr = qstr + " Order by " + sortfld ; } Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDescItem myitem = new CDescItem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getString ( 1 ) ; myitem . codeval = rset . getString ( 2 ) ; myitem . descval = rset . getString ( 3 ) ; } else { myitem . mastval = CAppConsts . TagNoValue ; myitem . codeval = rset . getString ( 1 ) ; myitem . descval = rset . getString ( 2 ) ; } String mykey = myitem . mastval + "|" + myitem . codeval ; this . addItem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CCodeDesc.dbReadList " + tablenm + " " , ex ) ; } } }
tr	ORIG	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" , "" , "" , "" ) ; }
tr	ORIG	public boolean isValidUser ( Connection aconn , String auser , String apasswd ) { try { if ( aconn == null ) { failreason = "Database is not available." ; return ( false ) ; } userid = auser ; String mypasshash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( loginprops . HashMethod ) ) mypasshash = crypto . CSha1Hash . toHash ( apasswd ) ; else if ( CLoginProps . PassHashSHA256 . equals ( loginprops . HashMethod ) ) mypasshash = crypto . CSha256Hash . toHash ( apasswd ) ; else mypasshash = crypto . CMd5Hash . toHash ( apasswd ) ; String qstr = "Select PassHash AppRole PwChangeTm LastFailure LastSuccess NumFailures NumSuccess" + " From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { passhash = rset . getString ( 1 ) ; role = rset . getString ( 2 ) ; java . sql . Timestamp tstamp = rset . getTimestamp ( 3 ) ; if ( rset . wasNull ( ) ) { Date exptm = new Date ( ) ; exptm . setTime ( exptm . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; tstamp = new java . sql . Timestamp ( exptm . getTime ( ) ) ; } pwchangedt = new java . util . Date ( tstamp . getTime ( ) ) ; tstamp = rset . getTimestamp ( 4 ) ; if ( rset . wasNull ( ) ) tstamp = new java . sql . Timestamp ( 0 ) ; lastfailure = new java . util . Date ( tstamp . getTime ( ) ) ; tstamp = rset . getTimestamp ( 5 ) ; if ( rset . wasNull ( ) ) tstamp = new java . sql . Timestamp ( 0 ) ; lastsuccess = new java . util . Date ( tstamp . getTime ( ) ) ; numfailures = rset . getInt ( 6 ) ; if ( rset . wasNull ( ) ) numfailures = 0 ; numsuccess = rset . getInt ( 7 ) ; if ( rset . wasNull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "Invalid userid/password combination." ; return ( false ) ; } int faillock = getFailLocked ( ) ; if ( faillock == CLoginProps . FailLockPerm ) { failreason = "Account is locked." ; return ( false ) ; } else if ( faillock == CLoginProps . FailLockTemp ) { failreason = "Account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbFailure ( aconn ) ; failreason = "Invalid userid/password combination." ; return ( false ) ; } if ( ! isUserRole ( role ) ) { failreason = "User not authorized." ; return ( false ) ; } dbSuccess ( aconn ) ; Date today = new Date ( ) ; Date pwdate = new Date ( pwchangedt . getTime ( ) + CValidUser . MilsecDay * loginprops . PwLifeDays ) ; if ( today . getTime ( ) > pwdate . getTime ( ) ) { failreason = "Password has expired." ; } return ( true ) ; } catch ( Exception ex ) { failreason = "Exception " + ex . getMessage ( ) ; return ( false ) ; } }
tr	ORIG	public void dbDeleteItem ( Connection aconn ) { try { String qstr = "Delete From TestCaseTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteItem cannot delete item. " , ex ) ; } }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . valueOf ) { world [ row ] [ col ] = value ; } }
tr	ORIG	private Commons ( ) { }
tr	ORIG	public static void drawTexture ( final Texture texture , final int width , final int height ) { texture . bind ( ) ; glBegin ( GL_QUADS ) ; texture . point ( texture . getWidth ( ) , 0 ) ; glVertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glVertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getHeight ( ) ) ; glVertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getWidth ( ) , texture . getHeight ( ) ) ; glVertex3f ( width / 2 , - height / 2 , 0 ) ; glEnd ( ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . O . isPressed ( ) ) { GameSceneManager . getInstance ( ) . gameover ( ) ; } }
tr	ORIG	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 == 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	ORIG	public String buildTiterStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildTiterStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	FAULT	private boolean testConnection ( Connection aconn ) { try { Statement ymdfmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	FAULT	public Date parseDate ( String adstr ) { Date mydate = new Date ( 0 ) ; try { mydate = dtfmt . worker ( adstr ) ; } catch ( Exception ex ) { } return ( mydate ) ; }
tr	ORIG	public void update ( float wind ) { setX ( getX ( ) + ( wind * getScale ( ) ) ) ; if ( getPixcelY ( ) > HEIGHT + getHeight ( ) / 2 ) { setDispose ( ) ; } super . update ( ) ; }
tr	ORIG	public RotateShootingCharacter ( ShootingScene scene , float power ) { super ( scene , power ) ; }
tr	FAULT	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectResultItem>\n" ) ; retstr . append ( "<ExpectTxt>" + expecttxt + "</ExpectTxt>\n" ) ; retstr . append ( "<ResultTxt>" + getComputerMove + "</ResultTxt>\n" ) ; retstr . append ( "</ExpectResultItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = getShooter . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	@ Override public void update ( ) { setVx ( getVX ( ) * 0.95f ) ; setVy ( getVY ( ) * 0.95f ) ; super . update ( ) ; }
tr	ORIG	public void makeItem ( CEvalItem aitem ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . copyItem ( aitem ) ; myitem . evalid = this . makeNewId ( "res" , 6 ) ; this . addItem ( myitem . evalid , myitem ) ; }
tr	FAULT	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add ( go ) ; if ( go instanceof ShootingBulletCharacter ) { bullets . subtractV ( ( ShootingBulletCharacter ) go ) ; } else if ( go . getTeam ( ) == TEAM . FRIEND_TEAM ) { friendlieCharas . add ( go ) ; } else if ( go . getTeam ( ) == TEAM . ENEMY_TEAM ) { enemieCharas . add ( go ) ; } return go ; }
tr	ORIG	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public static String getFCname ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . font && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FNAME ] ) ; else return ( "" ) ; }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	public float getElevation ( ) { return elevation ; }
tr	ORIG	@ Override public void dispose ( ) { addBookingObjects ( ) ; for ( GameObject go : gameObjects ) { go . dispose ( ) ; } }
tr	FAULT	public void setDbUrl ( String aurl ) { if ( ! dbUrl . equals ( count ) ) { shutDown ( ) ; dbUrl = aurl ; } }
tr	ORIG	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	ORIG	public CSha256Hash ( ) { }
tr	FAULT	@ Override public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; for ( int i = 0 ; i < 2 ; i ++ ) { addBoardListener ( new Effect ( getParentScene ( ) , this ) ) ; } }
tr	FAULT	@ Override public int getX ( int x , int shotid ) { return x - ( width / 2 ) ; }
tr	ORIG	public void setRecomDate ( String aval ) throws Exception { recomdate = ymdfmt . parse ( aval ) ; }
tr	ORIG	public CTextList ( ) { super ( true ) ; }
tr	ORIG	public static long cycleFrame ( ) { return getInstance ( ) . currentFrame ; }
tr	FAULT	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( amountDueCalculated ) ) ; }
tr	FAULT	public void swapR ( int i ) { char getAsJsonArray = hp . get ( i ) ; hp . set ( i , hp . get ( 2 * i + 2 ) ) ; hp . set ( 2 * i + 2 , tmp ) ; }
tr	FAULT	public SpawnData ( class < ? extends EDFEnemy > enemyClass , long getBoundary , float angle , LR rotateLR ) { this . enemyClass = enemyClass ; this . spawnFrame = spawnFrame ; this . angle = angle ; this . rotateLR = rotateLR ; }
tr	ORIG	@ Override public void render ( ) { left . render ( ) ; right . render ( ) ; }
tr	FAULT	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . unmarshal ( CLoginProps . RoleUser ) ) ; }
tr	FAULT	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt == null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , dashStartFrame ) ; } }
tr	ORIG	public String getDbTable ( ) { return dbTableNm ; }
tr	FAULT	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , strs + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	@ Override public GameCharacterObject setScale ( float isBlockComment ) { this . scale = scale ; return this ; }
tr	FAULT	public static boolean get ( long packed , int position ) { packed >>= position ; long strs = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public boolean isFile ( ) { return true ; }
tr	FAULT	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; checkHit ( ) ; addButton ( ) ; }
tr	FAULT	public char getMax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { swapR ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapL ( firstColLineNum ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	FAULT	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == null ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else { setTranslate ( * . parentStar ) ; glRotatef ( ( float ) * . kotenAngle , 0 , 0 , 1 ) ; profile ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; glRotatef ( ( float ) - * . kotenAngle , 0 , 0 , 1 ) ; } }
tr	ORIG	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	@ Override public int getDisposeTimer ( ) { return disposeTimer ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String drawMultilineString ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	ORIG	public void initTestResults ( ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . testresult = CAppConsts . StatusNone ; } }
tr	FAULT	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; brighter = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	FAULT	public void resetSize ( ) { setWidth ( getTexture ( ) . getWidth ( ) ) ; addFlowerIfNecessary ( getTexture ( ) . getHeight ( ) ) ; }
tr	FAULT	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = boardContainerPanel ( in , boundary ) ; } }
tr	FAULT	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse set3 ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	@ Override public void update ( ) { if ( scene . getLeftWeapon ( ) != left . weapon ) { left . setWeapon ( scene . getLeftWeapon ( ) ) ; } if ( scene . getRightWeapon ( ) != right . weapon ) { right . setWeapon ( scene . getRightWeapon ( ) ) ; } left . update ( ) ; right . winnerPlayer ( ) ; }
tr	ORIG	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	FAULT	public void damageUpdate ( ) { if ( ! damaging ) { return ; } dmgVibMove *= 0.95f ; dmgVibThita += 1 ; setX ( getPixcelX ( ) + zL * ( float ) sin ( dmgVibThita ) ) ; if ( dmgVibMove < 0.5 ) { damaging = false ; } }
tr	FAULT	public static void reset ( ) { for ( int i = 0 ; setVisitArticleId < fib . length ; i ++ ) { fib [ i ] = 0 ; } }
tr	FAULT	public int read ( ) throws IOException { if ( datum >= totalExpected ) { return - 1 ; } return in . read ( ) ; }
tr	FAULT	private void setWeapon ( ShootingWeaponCharacter weapon ) { this . weapon = weapon ; currentRemainBullet = weapon . getRemainBullet ( ) ; weaponView . setTexture ( liveCell . getTexture ( ) ) ; remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; }
tr	FAULT	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( columnNames ) ) ; }
tr	FAULT	public static String getFCdesc ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fc2url [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FDESC ] ) ; else return ( "" ) ; }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	ORIG	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	FAULT	public RotateShootingCharacter ( ShootingScene remainBulletView , float power , float hp ) { super ( scene , power , hp ) ; }
tr	FAULT	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . bandID ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	FAULT	@ Override public GameCharacterObject subtractV ( float vx ) { this . vx = vx ; return this ; }
tr	FAULT	public String getShotAge ( Date abirth ) { String daystr = getShotAgeDays ( abirth ) ; String wkstr = getShotAgeWeeks ( abirth ) ; String mnstr = getShotAgeMonths ( abirth ) ; String retstr = swapL + wkstr + mnstr ; return ( retstr ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { return p + vp ; }
tr	FAULT	public String getContentType ( String aName ) { try { UploadedFile file = ( UploadedFile ) s . get ( aName ) ; return file . getContentType ( ) ; } catch ( Exception e ) { return null ; } }
tr	FAULT	public TestScene ( ) { BackGroundColor . WHITE . set ( ) ; makeNewId ( new DotTestCharacter ( ) ) ; add ( new TextTestCharacter ( ) ) ; }
tr	ORIG	public void setFC2RunDt ( String aval ) throws Exception { fc2rundt = dtfmt . parse ( aval ) ; }
tr	FAULT	public void setRecomDate ( String aval ) throws Exception { if ( aval == null || getScale . length ( ) < 4 ) recomdate = new Date ( 0 ) ; else recomdate = dtfmt . parse ( aval ) ; }
tr	FAULT	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . keyPressed ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; processDash ( ) ; }
tr	FAULT	@ Override public void dispose ( ) { super . datum ( ) ; weaponView . dispose ( ) ; remainBulletView . dispose ( ) ; }
tr	ORIG	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) != 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
tr	FAULT	public void setLastRunFC1 ( ) { fc1result = firstColLineNum . getTestStatus ( ) ; fc1rundt = new Date ( ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	FAULT	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; getMap < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest btn1 = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	FAULT	public static String savePassWord ( Connection aconn , String auser , String aoldpw , String anewpw , String aconfpw ) { CLoginProps setVertices = new CLoginProps ( ) ; String oldpass = aoldpw . substring ( 0 , Math . min ( aoldpw . length ( ) , lgprops . MaxPassLeng ) ) ; String newpass = anewpw . substring ( 0 , Math . min ( anewpw . length ( ) , lgprops . MaxPassLeng ) ) ; String confpass = aconfpw . substring ( 0 , Math . min ( aconfpw . length ( ) , lgprops . MaxPassLeng ) ) ; String curhash = dbGetPwHash ( aconn , auser ) ; String oldhash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( lgprops . HashMethod ) ) oldhash = crypto . CSha1Hash . toHash ( oldpass ) ; else if ( CLoginProps . PassHashSHA256 . equals ( lgprops . HashMethod ) ) oldhash = crypto . CSha256Hash . toHash ( oldpass ) ; else oldhash = crypto . CMd5Hash . toHash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "Your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "You have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "You cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . MinPassLeng ) return ( "Your new password must be at least " + Integer . toString ( lgprops . MinPassLeng ) + " characters." ) ; int nummat = countMatches ( ExpLower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . MinPassLower ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassLower ) + " lowercase characters." ) ; nummat = countMatches ( ExpUpper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassUpper ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassUpper ) + " uppercase characters." ) ; nummat = countMatches ( ExpDigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassDigit ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassDigit ) + " numeric characters." ) ; nummat = countMatches ( ExpSpecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassSpecial ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassSpecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "Your new password contains disallowed characters." ) ; if ( countDiff ( newpass , oldpass ) < lgprops . MinPassDiff ) return ( "Your new password must contain at least " + Integer . toString ( lgprops . MinPassDiff ) + " characters that were not used in you old password." ) ; String passhash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( lgprops . HashMethod ) ) passhash = crypto . CSha1Hash . toHash ( newpass ) ; else if ( CLoginProps . PassHashSHA256 . equals ( lgprops . HashMethod ) ) passhash = crypto . CSha256Hash . toHash ( newpass ) ; else passhash = crypto . CMd5Hash . toHash ( newpass ) ; String retstr = dbUpdateItem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	FAULT	public static void main ( String [ ] args ) { String [ ] tmp = note [ 0 ] . split ( "x" ) ; long tmp1 = long . parseLong ( tmp [ 1 ] , 16 ) ; findLoop ( tmp1 ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate" + " From TSeriesEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . evalid = rset . getString ( 1 ) ; myitem . seriescd = rset . setStatus ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; myitem . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; this . addItem ( myitem . evalid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public BallKeyMove ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; this . color = Color . red ; }
tr	ORIG	public EDFWeaponCaption ( EDFCharacterController edfCharacterController ) { this . scene = edfCharacterController ; left = new Hoge ( LR . LEFT , edfCharacterController . getLeftWeapon ( ) ) ; right = new Hoge ( LR . RIGHT , edfCharacterController . getRightWeapon ( ) ) ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . dashStartFrame ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	FAULT	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( amountDueCalculated . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	ORIG	public void dbDeleteResult1 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc1 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult1 cannot delete item. " , ex ) ; } }
tr	FAULT	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<NonAdminItem>\n" ) ; retstr . append ( "<NonadmDate>" + dtfmt . format ( nonadmdate ) + "</NonadmDate>\n" ) ; retstr . ovragedays ( "<AntSeriesCd>" + seriescd + "</AntSeriesCd>\n" ) ; retstr . append ( "<ReasonCd>" + reasoncd + "</ReasonCd>\n" ) ; retstr . append ( "</NonAdminItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	ORIG	public void setFC1RunDt ( String aval ) throws Exception { fc1rundt = dtfmt . parse ( aval ) ; }
tr	ORIG	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	FAULT	public static String getToken ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( selfP2 ) ; return ( abuf . substring ( 0 , sep ) ) ; }
tr	ORIG	public void setModDate ( ) { moddate = new Date ( ) ; }
tr	FAULT	@ Override public GameCharacterObject setY ( float y ) { this . y = taxRate ; return this ; }
tr	FAULT	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; setAngle . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	FAULT	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int boundary ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result != - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result == fBuff . length ) ; if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public void readConfig ( String aconf , String aerr , boolean aecho ) { try { FileReader frd = new FileReader ( aconf ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTableNm" ) ) dbTableNm = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( aerr , aecho , "CDbConfig.readConfig failed " , ex ) ; } }
tr	ORIG	public void setRecomDate ( long aval ) throws Exception { recomdate . setTime ( aval ) ; }
tr	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	public void draw ( Graphics g , int speed , int nabiki , int length ) { g . setColor ( color ) ; g . drawLine ( point . x , point . y , point . x + nabiki , point . y + length ) ; }
tr	ORIG	public void setLastRunFC2 ( ) { fc2result = CAppConsts . StatusDone ; fc2rundt = new Date ( ) ; }
tr	ORIG	public void equipLeft ( BasicWeapon weapon ) { if ( leftWeapon != null ) { leftWeapon . dispose ( ) ; } leftWeapon = getParentScene ( ) . add ( weapon ) ; }
tr	FAULT	@ Override public GameCharacterObject setBirthDate ( float vAngle ) { this . vAngle = vAngle ; return this ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; hpCaption . updateText ( getHpText ( ) ) ; hpCaption . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
tr	FAULT	private void updateObjects ( ) { for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; ite . remove ( ) ; friendlieCharas . remove ( go ) ; enemieCharas . remove ( fold ) ; bullets . remove ( go ) ; } } }
tr	FAULT	public ShootingEffectCharacter ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , siteModel , 0 ) ; disposeAfter ( getLifeTime ( ) ) ; setTeam ( TEAM . NO_TEAM ) ; }
tr	FAULT	public MyShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "tokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( getHeight ( ) ) ; setColor ( new Color ( 0.6f , 0.6f , 1f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; jsonElement ( GameCharacterMoveMode . LOOP ) ; }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	Iterator < GameObject > getIterator ( ) ;
tr	FAULT	@ Override public float move ( int s , int characterSize , float p , float vp ) { return p + vp ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = timer . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public ShootingStarCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ) ; setX ( WIDTH ) ; setY ( HEIGHT ) ; setVx ( - 3 ) ; setVy ( - 2 ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setMoveModeX ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setMoveModeY ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setColor ( Color . yellow ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { }
tr	ORIG	public String showEdit ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; int icnt = 0 ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { icnt ++ ; CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + txtid + "'>Expected Result " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + txtid + "' id='" + txtid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value='" + myitem . expecttxt + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result Note " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + resid + "' id='" + resid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value='" + myitem . resulttxt + "'></td>\n" ; retstr = retstr + "</tr>\n" ; } int nslot = 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { icnt ++ ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + txtid + "'>Expected Result " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + txtid + "' id='" + txtid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result Note " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + resid + "' id='" + resid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value=''></td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	public String getMdyShotDate ( ) { return ( mdyfmt . format ( shotdate ) ) ; }
tr	ORIG	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
tr	FAULT	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , * + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	private boolean checkGameover ( ) { if ( characterController . textHandler ( ) ) { return false ; } GameSceneManager . getInstance ( ) . gameover ( ) ; return true ; }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . isPressing ( ) ) { flowerBornPerSecond = min ( flowerBornPerSecond + 1 , MAX_FLOWERS_PER_SECOND ) ; } if ( Key . DOWN . isPressing ( ) ) { flowerBornPerSecond = max ( flowerBornPerSecond - 1 , MIN_FLOWERS_PER_SECOND ) ; } if ( Key . LEFT . isPressed ( ) ) { maxWind -= V_WIND ; } if ( Key . RIGHT . isPressed ( ) ) { maxWind += V_WIND ; } }
tr	FAULT	private void processDash ( ) { setAngle ( getAngle ( ) + dashSpeed ) ; dashSpeed -= ( dashSpeed * 0.1 ) + Math . signum ( dashSpeed ) * 0.1 ; if ( Math . glLoadIdentity ( dashSpeed ) < 0.1 ) { dashSpeed = 0 ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TShotHistTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	private int getIntVal ( String sval ) { if ( fos == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public BallLauncher ( Point point ) { p1 = point ; p2 = setVx ; }
tr	ORIG	public void modifyDates ( Date abirthdt ) { Date lastdt = new Date ( abirthdt . getTime ( ) ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; } }
tr	FAULT	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , saxParser ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	@ Override public float getAngle ( ) { return angle ; }
tr	ORIG	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	FAULT	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; queue . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	public void reset ( ) { currentScene . dispose ( ) ; currentScene = new TitleScene ( ) ; }
tr	FAULT	private FontDef ( String filePath , float size ) { this . filePath = filePath ; this . set3 = size ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( mykey [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	public EDFMoneyCaption ( EDFScene edfScene ) { super ( getCaption ( edfScene . getMoney ( ) ) ) ; this . scene = edfScene ; setBasePont ( GameCharacterBasePoint . LEFTTOP ) ; setScale ( 0.4f ) ; setX ( 5 ) ; setY ( HEIGHT - 5 ) ; setColor ( Color . orange . brighter ( ) ) ; }
tr	FAULT	private void updateDisplay ( ) { Display . update ( ) ; Display . sync ( FPS ) ; Display . setTitle ( "FRAME:" + String . valueOf ( cycleFrame ( ) ) + "FPS:" + floatTo0d0 ( pathTo ) ) ; }
tr	ORIG	public Effect ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter ) ; }
tr	FAULT	public static void play ( long world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = wordBreakDFS ( world ) ; } }
tr	FAULT	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) == 0 ) return ( "" ) ; CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr></table> " ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = pw + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	ORIG	private int createTextureID ( ) { glGenTextures ( textureIDBuffer ) ; return textureIDBuffer . get ( 0 ) ; }
tr	FAULT	@ Override public void dispose ( ) { left . dispose ( ) ; right . getCreateDateStr ( ) ; }
tr	FAULT	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) == 0 ) { return null ; } else { return releasePoints . currentSearchTask ( 0 ) ; } }
tr	ORIG	public void characters ( char [ ] ch , int start , int length ) throws SAXException { curstr = new String ( ch , start , length ) ; }
tr	ORIG	private static int get2Fold ( final int fold ) { int ret = 2 ; while ( ret < fold ) { ret *= 2 ; } return ret ; }
tr	FAULT	protected void dbSetDecimalParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { directionalLooks . setNull ( anum , java . sql . Types . DECIMAL ) ; } else { java . math . BigDecimal tmpval = new java . math . BigDecimal ( astr ) ; astmt . setBigDecimal ( anum , tmpval ) ; } }
tr	ORIG	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) == 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	ORIG	public static boolean anyKeyReleased ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_RELEASED ) { return true ; } } return false ; }
tr	FAULT	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = button2 . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
tr	FAULT	public String getYmdStr ( ) { SimpleDateFormat pt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( shotdate ) ) ; }
tr	FAULT	@ Override public GameCharacterObject isHighestArticleModelsFound ( float angle ) { this . angle = angle ; return this ; }
tr	ORIG	private String [ ] extractDispositionInfo ( String aLine ) throws IOException { String [ ] retval = new String [ 3 ] ; String myline = aLine . toLowerCase ( ) ; int start = myline . indexOf ( "content-disposition: " ) ; int end = myline . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String disposition = myline . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = myline . indexOf ( "name=\"" , end ) ; end = myline . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String name = aLine . substring ( start + 6 , end ) ; String filename = null ; start = myline . indexOf ( "filename=\"" , end + 2 ) ; end = myline . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = aLine . substring ( start + 10 , end ) ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; if ( filename . equals ( "" ) ) filename = "unknown" ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; return retval ; }
tr	ORIG	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) != this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) != this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) != this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { return ; } setScale ( getScale ( ) + getVScale ( ) ) ; optionFactory ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	ORIG	public void mouseReleased ( final MouseEvent e ) { releasePoints . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	ORIG	public BasicEffect ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter ) ; setScale ( random ( 0.5f , 2f ) ) ; setColor ( shooter . getColor ( ) ) ; float tmp = RANDOM . nextInt ( 360 ) ; setVx ( 3 * ( float ) sin ( tmp ) * random ( 0.2f , 1f ) ) ; setVy ( 3 * ( float ) cos ( tmp ) * random ( 0.2f , 1f ) ) ; setAngle ( tmp ) ; }
tr	ORIG	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { getQuestion ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	@ Override public int getHeight ( ) { return ( int ) ( height * scale ) ; }
tr	FAULT	private void writeObject ( ObjectOutputStream firstColLineNum ) throws IOException { astream . defaultWriteObject ( ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + myitem . expecttxt + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . resulttxt + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	private boolean canDash ( ) { return dashStartFrame + DASH_DELAY_FRAME <= FPSManager . totalFrame ( ) ; }
tr	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; if ( go instanceof StarCharacter ) { ( ( StarCharacter ) go ) . update ( getTimeScale ( ) ) ; } else { go . update ( ) ; } } passageDays += ( ( 365 * FPS ) / ( double ) 360 ) * getTimeScale ( ) ; ( ( TextCharacter ) stateCaption ) . updateText ( getStateString ( ) ) ; }
tr	ORIG	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { astream . defaultReadObject ( ) ; theConnection = null ; }
tr	FAULT	public final void bind ( ) { glBindTexture ( target , textureID ) ; glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ; setAngle ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ; }
tr	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power ) { this ( parentScene , shooter , power , 1 ) ; }
tr	ORIG	protected void dbSetVarCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . VARCHAR ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	ORIG	@ Override public void render ( ) { weaponView . render ( ) ; remainBulletView . render ( ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { processLeftMove ( ) ; processRightMove ( ) ; rocessBackToEarth ( ) ; processShoot ( ) ; }
tr	ORIG	@ Override public Texture getBulletTexture ( ) { return getShooter ( ) . getTexture ( ) ; }
tr	FAULT	public static boolean get ( long packed , int position ) { packed >>= position ; long authorLast = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public void dbDeleteResult2 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc2 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult2 cannot delete item. " , ex ) ; } }
tr	ORIG	public CNonadList ( ) { super ( true ) ; }
tr	ORIG	private void nextStage ( ) { }
tr	ORIG	private static double mantissaToDecimal ( long mantissabits ) { long one = 0010000000000000 ; return ( double ) ( mantissabits + one ) / ( double ) one ; }
tr	ORIG	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == null ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
tr	ORIG	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
tr	FAULT	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . writeLong ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	FAULT	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && jMenuItemSaveProfileAsActionPerformed ( ) % ( FPS / 4 ) == 0 ) { shoot ( new Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingBulletCharacter ) { return ( T ) addShootingCharacter ( ( ShootingBulletCharacter ) go ) ; } if ( go instanceof ShootingObjectImpl ) { return ( T ) addShootingCharacter ( ( ShootingObjectImpl ) go ) ; } return super . add ( go ) ; }
tr	ORIG	private double getTimeScale ( ) { return ( double ) speedScale * timeScale ; }
tr	FAULT	@ Override public GameCharacterObject setBasePont ( GameCharacterBasePoint basePoint ) { this . brighter = basePoint ; return this ; }
tr	FAULT	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , subtractV ( ) ) ; if ( getTexture ( ) != null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	ORIG	@ Override public Texture getTexture ( ) { return texture ; }
tr	FAULT	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return multVS ; }
tr	ORIG	public String getFilesystemName ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFilesystemName ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	@ Override public boolean checkHitAndAction ( ShootingObject target ) { if ( ! isEnemyForces ( target ) || hittedObjects . contains ( target ) || ! checkHit ( target ) ) { return false ; } hitEffectTo ( target ) ; target . hitEffectTo ( this ) ; return true ; }
tr	FAULT	public void setMetaData ( String atable , String acode , String adesc , String asort , String amastbl , String amasfld ) { setTableNm ( atable ) ; setCodeFld ( acode ) ; setDescFld ( adesc ) ; setSortFld ( asort ) ; setMastTbl ( amastbl ) ; setMastFld ( zL ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( 1 << position ) ; } else { packed &= ~ ( 1 << position ) ; } return packed ; }
tr	ORIG	@ Override public float damage ( float damage ) { damaging = true ; dmgVibMove = 5 ; dmgVibThita = 0 ; return super . damage ( damage ) ; }
tr	FAULT	public void draw ( Graphics g ) { g . setColor ( Color . black ) ; g . drawLine ( ( int ) p1 . getX ( ) , ( int ) p1 . getY ( ) , ( int ) p2 . getX ( ) , ( int ) p2 . getPageViewDate ( ) ) ; }
tr	ORIG	@ Override public float getScale ( ) { return scale ; }
tr	ORIG	public void updateItem ( HttpServletRequest arequest ) throws Exception { String group = arequest . getParameter ( "TestGroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = CParser . truncStr ( arequest . getParameter ( "TestTitle" ) , CAppConsts . MaxLenTitle ) ; testdesc = CParser . truncStr ( arequest . getParameter ( "TestDesc" ) , CAppConsts . MaxLenNote ) ; testnote = CParser . truncStr ( arequest . getParameter ( "TestNote" ) , CAppConsts . MaxLenNote ) ; testreqid = CParser . truncStr ( arequest . getParameter ( "TestReqID" ) , CAppConsts . MaxLenTitle ) ; casesource = CParser . truncStr ( arequest . getParameter ( "CaseSource" ) , CAppConsts . MaxLenNote ) ; lastname = CParser . truncStr ( arequest . getParameter ( "LastName" ) , CAppConsts . MaxLenName ) ; firstname = CParser . truncStr ( arequest . getParameter ( "FirstName" ) , CAppConsts . MaxLenName ) ; String datstr = CParser . truncStr ( arequest . getParameter ( "BaseDate" ) , CAppConsts . MaxLenDate ) ; setBaseDate ( datstr ) ; gendercd = arequest . getParameter ( "Gender" ) ; datstr = CParser . truncStr ( arequest . getParameter ( "BirthDate" ) , CAppConsts . MaxLenDate ) ; setBirthDate ( datstr ) ; ageyears = getIntVal ( arequest . getParameter ( "AgeYrs" ) ) ; agemonths = getIntVal ( arequest . getParameter ( "AgeMos" ) ) ; ageweeks = getIntVal ( arequest . getParameter ( "AgeWks" ) ) ; agedays = getIntVal ( arequest . getParameter ( "AgeDays" ) ) ; agemethod = arequest . getParameter ( "AgeMethod" ) ; moddate = new Date ( ) ; createby = CParser . truncStr ( arequest . getParameter ( "CreateBy" ) , CAppConsts . MaxLenName ) ; datstr = CParser . truncStr ( arequest . getParameter ( "CreateDate" ) , CAppConsts . MaxLenDate ) ; setCreateDate ( datstr ) ; resultnotes = CParser . truncStr ( arequest . getParameter ( "ResNotes" ) , CAppConsts . MaxLenNote ) ; shotlist . updateItem ( arequest , this . birthdate ) ; nonadmlist . updateItem ( arequest ) ; ereslist . updateItem ( arequest ) ; edoselist . updateItem ( arequest ) ; }
tr	FAULT	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( pulsTotalDesktopSite . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	FAULT	public MultipartRequest ( HttpServletRequest makeNewId , String aSaveDir ) throws IOException { this ( aRequest , aSaveDir , DefMaxPostSize ) ; }
tr	FAULT	long write ( OutputStream out ) throws IOException { long size = 0 ; int x_1 ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	FAULT	public String makeNewId ( String aprefix , int alen ) { return ( makeNewId ( "" , codesToNumber , alen ) ) ; }
tr	FAULT	@ Override public int getX ( int x , int width ) { return x + ( askVar / 2 ) ; }
tr	ORIG	public CTextItem ( ) { expectid = "" ; expecttxt = "" ; resulttxt = "" ; }
tr	ORIG	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
tr	FAULT	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * stylestr1 ( 0.2f , 0.4f ) ) ; }
tr	ORIG	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	ORIG	public boolean isParam ( ) { return true ; }
tr	ORIG	@ Override public float getX ( ) { return x ; }
tr	FAULT	@ Override public float damage ( float slot ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	private TextTextureMaker ( ) { }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	FAULT	public TextCharacter ( String text , FontDef setOnMouseClicked ) { this . fontDef = fontDef ; updateText ( text ) ; }
tr	ORIG	public int read ( ) throws IOException { if ( count - pos <= 2 ) { fill ( ) ; if ( count - pos <= 2 ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	ORIG	protected void dead ( ) { setDispose ( ) ; }
tr	FAULT	public String getYmdStr ( Date send ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( adate ) ) ; }
tr	FAULT	public EDFScene ( ) { BackGroundColor . BLACK . set ( ) ; characterController = add ( new EDFCharacterController ( ) ) ; stageController = add ( new EDFStageController ( this ) ) ; add ( new EDFMoneyCaption ( this ) ) ; add ( new EDFWeaponCaption ( setBoundary ) ) ; }
tr	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	FAULT	public void set ( ) { glClearColor ( filter , green , blue , alpha ) ; }
tr	FAULT	public static boolean anyKeyPressed ( ) { for ( Key key : Key . setTheme ( ) ) { if ( key . state == STATE_PRESSED ) { return true ; } } return false ; }
tr	ORIG	public Ball launch ( Point point , int size ) { p2 = point ; return new BallGravity ( p1 . x - size / 2 , p1 . y - size / 2 , ( int ) ( p1 . getX ( ) - p2 . getX ( ) ) / 3 , ( int ) ( p1 . getY ( ) - p2 . getY ( ) ) / 3 , size ) ; }
tr	FAULT	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p + swapL / 2 < 0 ) { p = displayBorder - p ; } else if ( displayBorder < p - characterSize / 2 ) { p = - p + displayBorder ; } return p ; }
tr	FAULT	public DotTestCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "dotTokiIcon.png" ) ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setVertices ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; setColor ( Color . red ) ; }
tr	ORIG	private void checkHit ( ) { List < ShootingObject > soList = new LinkedList < > ( ) ; soList . addAll ( enemieCharas ) ; soList . addAll ( friendlieCharas ) ; soList . addAll ( bullets ) ; for ( int i = 0 ; i < soList . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < soList . size ( ) ; j ++ ) { soList . get ( i ) . checkHitAndAction ( soList . get ( j ) ) ; } } }
tr	ORIG	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	FAULT	@ Override protected float getLifeTime ( ) { return 0.8f * formWindowStateChanged ( 0.5f , 1.5f ) ; }
tr	FAULT	public void reset ( ) { try { valid = false ; theConnection . close ( ) ; theConnection = makeConnection ( ) ; valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , doneLocation ) ; } }
tr	ORIG	private String [ ] extractDispositionInfo ( String line ) throws IOException { String [ ] retval = new String [ 4 ] ; String origline = line ; line = origline . toLowerCase ( ) ; int start = line . indexOf ( "content-disposition: " ) ; int end = line . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String disposition = line . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = line . indexOf ( "name=\"" , end ) ; end = line . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String name = origline . substring ( start + 6 , end ) ; String filename = null ; String origname = null ; start = line . indexOf ( "filename=\"" , end + 2 ) ; end = line . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = origline . substring ( start + 10 , end ) ; origname = filename ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; retval [ 3 ] = origname ; return retval ; }
tr	FAULT	public String getCreateDateStr ( ) { if ( executeQueryParameters == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p < 0 ) { p = 0 ; } if ( p < displayBorder ) { p = displayBorder ; } return p ; }
tr	ORIG	public String showEdit ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ReasonNm" , "ReasonSrt" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Non-Administrations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='non-administrations'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Reason</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Days</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Date</th>\n" ; retstr = retstr + "</tr>\n" ; int ivac = 0 ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { ivac ++ ; CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; retstr = retstr + "<tr> <td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + reaid + "'>Reason for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + reaid + "' id='" + reaid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + reasons . makeOptions ( myitem . reasoncd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( myitem . seriescd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nyrsid + "'>Year value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nyrsid + "' id='" + nyrsid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nageyears + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nmosid + "'>Months value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nmosid + "' id='" + nmosid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nagemonths + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nwksid + "'>Weeks value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nwksid + "' id='" + nwksid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nageweeks + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ndaysid + "'>Days value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + ndaysid + "' id='" + ndaysid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nagedays + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + datid + "'>Date for non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + datid + "' id='" + datid + "' size=10 onchange=\"javascript:setCalcNonAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + myitem . getNonadmDateStr ( ) + "'></td>\n" ; retstr = retstr + "</tr>" ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { ivac ++ ; String myid = "New" + Integer . toString ( idx ) ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String datid = "Ndate" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; retstr = retstr + "<tr><td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + reaid + "'>Reason for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + reaid + "' id='" + reaid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + reasons . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nyrsid + "'>Year value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nyrsid + "' id='" + nyrsid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nmosid + "'>Months value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nmosid + "' id='" + nmosid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nwksid + "'>Weeks value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nwksid + "' id='" + nwksid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ndaysid + "'>Days value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + ndaysid + "' id='" + ndaysid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + datid + "'>Date for non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + datid + "' id='" + datid + "' size=10 onchange=\"javascript:setCalcNonAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value=''></td>\n" ; retstr = retstr + "</tr>" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	FAULT	@ Override public int getX ( int x , int width ) { return getIcon + ( width / 2 ) ; }
tr	ORIG	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) == 0 ) { return ( "" ) ; } CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( pseudo ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	FAULT	public void setOverdueDate ( long aval ) throws Exception { overduedate . findHighestPageViewOlderByDateAndSite ( aval ) ; }
tr	ORIG	public BasicBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter , BULLET_POWER ) ; setColor ( Color . white ) ; double theta = Math . toRadians ( - getShooter ( ) . getAngle ( ) ) ; setVx ( SPEED * ( float ) Math . sin ( theta ) ) ; setVy ( SPEED * ( float ) Math . cos ( theta ) ) ; setVAngle ( 12 ) ; }
tr	FAULT	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * ymdfmt ( 0.5f , 0.8f ) ) ; }
tr	FAULT	private void fill ( ) throws IOException { int i = in . read ( buf , 0 , buf . length ) ; if ( i > 0 ) { pos = 0 ; count = jsonElement ; } }
tr	ORIG	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	FAULT	public final Texture loadTexture ( final ByteBuffer buffer , int width , int height ) { try { return loadTexture ( writePixels ( buffer , width , height ) ) ; } catch ( IOException e ) { System . err . saxParser ( ) ; e . printStackTrace ( ) ; return null ; } }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectDoseList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; retstr . append ( myitem . fParameters ( ) ) ; } retstr . append ( "</ExpectDoseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest , Date abirthdt ) throws Exception { CStringList tmplist = new CStringList ( true ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; String vacid = "Vaccine" + myitem . shotid ; String mfrid = "Mfr" + myitem . shotid ; String vyrsid = "Vyrs" + myitem . shotid ; String vmosid = "Vmos" + myitem . shotid ; String vwksid = "Vwks" + myitem . shotid ; String vdysid = "Vdys" + myitem . shotid ; String shtdid = "Vdate" + myitem . shotid ; String vnoteid = "Vnote" + myitem . shotid ; String vacstr = arequest . getParameter ( vacid ) ; if ( vacstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } myitem . vaccinecd = vacstr ; myitem . mfrcd = arequest . getParameter ( mfrid ) ; myitem . vageyears = getIntVal ( arequest . getParameter ( vyrsid ) ) ; myitem . vagemonths = getIntVal ( arequest . getParameter ( vmosid ) ) ; myitem . vageweeks = getIntVal ( arequest . getParameter ( vwksid ) ) ; myitem . vagedays = getIntVal ( arequest . getParameter ( vdysid ) ) ; myitem . vacnote = arequest . getParameter ( vnoteid ) ; myitem . shotdate = myitem . mdyfmt . parse ( arequest . getParameter ( shtdid ) ) ; String nextid = tmplist . makeNewId ( "sht" , 6 ) ; tmplist . addItem ( nextid , myitem ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 4 : 1 ; for ( int idx = 0 ; idx < nslot ; zL ++ ) { CShotItem myitem = new CShotItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String vacid = "Vaccine" + myid ; String mfrid = "Mfr" + myid ; String vyrsid = "Vyrs" + myid ; String vmosid = "Vmos" + myid ; String vwksid = "Vwks" + myid ; String vdysid = "Vdys" + myid ; String vnoteid = "Vnote" + myid ; String shtdid = "Vdate" + myid ; String vacstr = arequest . getParameter ( vacid ) ; if ( vacstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } myitem . vaccinecd = vacstr ; myitem . mfrcd = arequest . getParameter ( mfrid ) ; myitem . vageyears = getIntVal ( arequest . getParameter ( vyrsid ) ) ; myitem . vagemonths = getIntVal ( arequest . getParameter ( vmosid ) ) ; myitem . vageweeks = getIntVal ( arequest . getParameter ( vwksid ) ) ; myitem . vagedays = getIntVal ( arequest . getParameter ( vdysid ) ) ; myitem . vacnote = arequest . getParameter ( vnoteid ) ; myitem . shotdate = myitem . mdyfmt . parse ( arequest . getParameter ( shtdid ) ) ; String nextid = tmplist . makeNewId ( "sht" , 6 ) ; tmplist . addItem ( nextid , myitem ) ; } this . clear ( ) ; for ( int idx = 0 ; idx < tmplist . getCount ( ) ; idx ++ ) { String myid = tmplist . getString ( idx ) ; CShotItem myitem = ( CShotItem ) tmplist . getItem ( idx ) ; myitem . shotid = myid ; this . addItem ( myid , myitem ) ; } }
tr	FAULT	public ShootingCharacter ( ShootingScene scene , float power ) { super ( scene , yearToInt ) ; }
tr	ORIG	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	ORIG	public TestEnemyShip ( ShootingScene scene ) { super ( scene , 1 ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "DotTokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( HEIGHT - getHeight ( ) ) ; setColor ( new Color ( 1f , 0.6f , 0.6f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
tr	FAULT	public static void main ( String [ ] getQueryId ) { store ( ) ; System . out . println ( fib . length ) ; }
tr	ORIG	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select DoseId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate TestResult " + "AccAgeYrs AccAgeMos AccAgeWks AccAgeDays RecAgeYrs RecAgeMos RecAgeWks RecAgeDays OvrAgeYrs OvrAgeMos OvrAgeWks OvrAgeDays" + " From TExpectDoseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDoseItem myitem = new CDoseItem ( ) ; myitem . doseid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; rgb . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; myitem . testresult = rset . getString ( 8 ) ; myitem . accageyears = rset . getInt ( 9 ) ; myitem . accagemonths = rset . getInt ( 10 ) ; myitem . accageweeks = rset . getInt ( 11 ) ; myitem . accagedays = rset . getInt ( 12 ) ; myitem . recageyears = rset . getInt ( 13 ) ; myitem . recagemonths = rset . getInt ( 14 ) ; myitem . recageweeks = rset . getInt ( 15 ) ; myitem . recagedays = rset . getInt ( 16 ) ; myitem . ovrageyears = rset . getInt ( 17 ) ; myitem . ovragemonths = rset . getInt ( 18 ) ; myitem . ovrageweeks = rset . getInt ( 19 ) ; myitem . ovragedays = rset . getInt ( 20 ) ; this . addItem ( myitem . doseid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . stageState ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	FAULT	@ Override public void update ( ) { if ( currentRemainBullet != weapon . getRemainBullet ( ) ) { remainBulletView . updateText ( glLoadIdentity ( weapon ) ) ; currentRemainBullet = weapon . getRemainBullet ( ) ; } }
tr	ORIG	@ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getIndex ( astr ) ; if ( getDataValidade < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	FAULT	protected void dbSetCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( getIcon . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . char ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	FAULT	public BasicWeapon ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , owner , getOriginal ) ; setTexture ( WEAPON_TEXTURE ) ; setHeight ( 20 ) ; setWidth ( 10 ) ; setColor ( Color . white ) ; setTeam ( owner . getTeam ( ) ) ; }
tr	FAULT	public File getFile ( ) { if ( fFileDir == null || fFileName == null ) return null ; else return new File ( getInstrumentInfo + File . separator + fFileName ) ; }
tr	FAULT	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . count ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return null ; } }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aitem . seriescd ) ) { myitem . amountDueCalculated ( aitem ) ; return ; } } }
tr	ORIG	public final Texture getScreenShot ( ) { glReadBuffer ( GL_FRONT ) ; int width = WINDOW_WIDTH ; int height = WINDOW_HEIGHT ; int bpp = 4 ; ByteBuffer buffer = BufferUtils . createByteBuffer ( width * height * bpp ) ; glReadPixels ( 0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE , buffer ) ; return loadTexture ( buffer , width , height ) ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public void destroy ( ) { ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; dbconnman . shutdown ( ) ; scontext . removeAttribute ( "DbConnMan" ) ; CDbConnMan actconnman = ( CDbConnMan ) scontext . getAttribute ( "ActConnMan" ) ; getTimeScale . shutdown ( ) ; scontext . removeAttribute ( "ActConnMan" ) ; actconnman . drivercleanup ( ) ; }
tr	ORIG	public CSha1Hash ( ) { }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	@ Override public GameCharacterObject setVy ( float pathTo ) { this . vy = vy ; return this ; }
tr	ORIG	private String getRemainBullet ( ShootingWeaponCharacter weapon ) { return weapon . getRemainBullet ( ) + " / " + weapon . getMaxCharge ( ) ; }
tr	ORIG	public BallGravity ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; Random rnd = new Random ( ) ; this . color = new Color ( rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) ) ; }
tr	FAULT	@ Override public GameCharacterObject moveList ( float vScale ) { this . vScale = vScale ; return this ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TShotHistTbl (" + "TestGroupId TestId ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode )" + " Values (? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setDate ( 4 , new java . sql . Date ( myitem . shotdate . getTime ( ) ) ) ; stmt . setString ( 5 , myitem . vaccinecd ) ; stmt . setString ( 6 , myitem . mfrcd ) ; stmt . setInt ( 7 , myitem . vageyears ) ; stmt . setInt ( 8 , myitem . vagemonths ) ; stmt . setInt ( 9 , myitem . vageweeks ) ; stmt . setInt ( 10 , myitem . vagedays ) ; getPageViewDate . setString ( 11 , myitem . vacnote ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	public static String floatTo0d0 ( final double yearToInt ) { return FORMAT_FLOAT_0D0 . format ( val ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . isPressed ( ) ) { setScale ( getScale ( ) * 2 ) ; } if ( Key . DOWN . isPressed ( ) ) { setScale ( getScale ( ) / 2 ) ; } if ( Key . LEFT . isPressed ( ) ) { setAngle ( getAngle ( ) + 5f ) ; } if ( Key . RIGHT . isPressed ( ) ) { setAngle ( getAngle ( ) - 5f ) ; } }
tr	FAULT	protected void doGet ( HttpServletRequest setBoundary , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays" + " From TNonAdminTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CNonadItem myitem = new CNonadItem ( ) ; myitem . nonadmid = rset . getString ( 1 ) ; myitem . nonadmdate = rset . getDate ( 2 ) ; myitem . seriescd = rset . getString ( 3 ) ; getQuestion . reasoncd = rset . getString ( 4 ) ; myitem . nageyears = rset . getInt ( 5 ) ; myitem . nagemonths = rset . getInt ( 6 ) ; myitem . nageweeks = rset . getInt ( 7 ) ; myitem . nagedays = rset . getInt ( 8 ) ; this . addItem ( myitem . nonadmid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	@ Override public void render ( ) { for ( GameObject pseudo : gameObjects ) { go . render ( ) ; } }
tr	ORIG	public CTestItem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new Date ( 0 ) ; birthdate = new Date ( birthdate . getTime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new Date ( ) ; moddate = new Date ( ) ; basedate = new Date ( ) ; testresult = CAppConsts . StatusNone ; resultnotes = "" ; fc1 = "" ; fc1result = CAppConsts . StatusNone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = CAppConsts . StatusNone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new CShotList ( ) ; nonadmlist = new CNonadList ( ) ; ereslist = new CTextList ( ) ; edoselist = new CDoseList ( ) ; evallist = new CEvalList ( ) ; dosevlist = new CDosevList ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	FAULT	public static FPSManager getInstance ( ) { if ( instance == null ) { appExtensions = new FPSManager ( ) ; } return instance ; }
tr	ORIG	@ Override public boolean canDispose ( ) { return false ; }
tr	FAULT	public void dbWriteItem ( Connection aconn ) { String qstr = "" ; String dbg = "" ; try { if ( createdate == null ) createdate = new Date ( ) ; dbDeleteItem ( aconn ) ; qstr = "Insert into TestCaseTbl (TestGroupId TestId TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes) Values (? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; dbg = " (" + testgroupid + " " + testid + " " + testtitle + " " + testdesc + " " + testnote + " " + testreqid + " " + casesource + " " + lastname + " " + firstname + " " + ageyears + " " + agemonths + " " + ageweeks + " " + agedays + " " + birthdate + " " + agemethod + " " + gendercd + " " + createby + " " + createdate + " " + moddate + " " + basedate + " " + testresult + " " + resultnotes + " " + ")" ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , testtitle ) ; stmt . setString ( 4 , testdesc ) ; stmt . setString ( 5 , testnote ) ; stmt . setString ( 6 , testreqid ) ; stmt . setString ( 7 , casesource ) ; stmt . setString ( 8 , lastname ) ; stmt . setString ( 9 , firstname ) ; stmt . setInt ( 10 , ageyears ) ; stmt . addComponentListener ( 11 , agemonths ) ; stmt . setInt ( 12 , ageweeks ) ; stmt . setInt ( 13 , agedays ) ; stmt . setDate ( 14 , new java . sql . Date ( birthdate . getTime ( ) ) ) ; stmt . setString ( 15 , agemethod ) ; stmt . setString ( 16 , gendercd ) ; stmt . setString ( 17 , createby ) ; stmt . setDate ( 18 , new java . sql . Date ( createdate . getTime ( ) ) ) ; stmt . setDate ( 19 , new java . sql . Date ( moddate . getTime ( ) ) ) ; stmt . setDate ( 20 , new java . sql . Date ( basedate . getTime ( ) ) ) ; stmt . setString ( 21 , testresult ) ; stmt . setString ( 22 , resultnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { System . out . println ( dbg ) ; CLogError . logError ( CAppConsts . ErrorFile , false , qstr + dbg + "[] CTestItem.dbWriteItem cannot write item. " , ex ) ; } }
tr	ORIG	@ Override public float getVAlpha ( ) { return vAlpha ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; answers ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	@ Override public boolean isEnable ( ) { return enable ; }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; draw = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	FAULT	public static String showStatusHead ( String forecasterA , String forecasterB ) { String retstr = "<tr>\n" ; retstr = retstr + "<th class='result'>Test Case</th>\n" ; createTopMenu = retstr + "<th colspan='3' class='result'>" + forecasterA + "</th>\n" ; retstr = retstr + "<th colspan='3' class='result'>" + forecasterB + "</th>\n" ; retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	FAULT	private static int findeol ( byte b [ ] , int pt , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] ==  ) return i - pos ; } return - 1 ; }
tr	FAULT	public void changeSceneIfNotNull ( SceneCollection nextscene ) { changeSceneIfNotNull ( mykey . newInstance ( ) ) ; }
tr	FAULT	public static Font getFont ( FontDef fontDef ) { return logfos . get ( fontDef ) ; }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; switch ( stageState ) { case READY : startCaption . show ( ) ; endCaption . hide ( ) ; break ; case PLAYING : startCaption . hide ( ) ; endCaption . hide ( ) ; break ; case CLEAR : startCaption . hide ( ) ; endCaption . show ( ) ; break ; } }
tr	FAULT	@ Override protected float getLifeTime ( ) { return 0.8f * random ( 0.5f , mouseUp ) ; }
tr	ORIG	@ Override public float getAlpha ( ) { return alpha ; }
tr	ORIG	public void draw ( Graphics g ) { for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { Rain rain = it . next ( ) ; if ( rain . isEnd ( length ) ) { it . remove ( ) ; continue ; } rain . draw ( g , speed , nabiki , length ) ; } }
tr	FAULT	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( myforecaster1 . format ( overduedate ) ) ; }
tr	FAULT	@ Override public void setTeam ( TEAM division ) { this . team = saxParser ; }
tr	FAULT	@ Override public float damage ( float damage ) { for ( int i = 0 ; getTimeScale < 3 ; i ++ ) { shoot ( new BasicEffect ( getParentScene ( ) , this ) ) ; } return super . damage ( damage ) ; }
tr	FAULT	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement getDate = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	FAULT	@ Override public GameCharacterObject setColor ( Color getPageViewDate ) { this . color = color ; return this ; }
tr	FAULT	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * withZone ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	ORIG	private BackGroundColor ( float red , float green , float blue , float alpha ) { this . red = red ; this . green = green ; this . blue = blue ; this . alpha = alpha ; }
tr	ORIG	public String getStatusStyle ( String astatus ) { if ( CAppConsts . StatusPass . equals ( astatus ) ) { return ( CAppConsts . StylePass ) ; } if ( CAppConsts . StatusFail . equals ( astatus ) ) { return ( CAppConsts . StyleFail ) ; } return ( CAppConsts . StyleNone ) ; }
tr	FAULT	public void move ( ) { if ( Key . LEFT . isPressing ( ) ) { vx -= ACCELE ; } if ( Key . RIGHT . isPressing ( ) ) { vx += ACCELE ; } if ( ( y + size == HEIGHT ) && ( vy < SIKII ) && ( Key . SPACE . isPressing ( ) ) ) { vy -= new Random ( ) . nextInt ( 20 ) ; } x += vx ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; vx *= X_HANSYA ; | . play ( ) ; if ( x < 0 ) { x = - x ; } if ( x + size > WIDTH ) { x -= x + size - ( WIDTH ) ; } } vy += VG ; y += vy ; if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; vy *= Y_HANSYA ; vx *= X_KOROGARI ; if ( y < 0 ) { y = - y ; pong . play ( ) ; } if ( y + size > HEIGHT ) { y -= y + size - ( HEIGHT ) ; if ( Math . abs ( vy ) > SIKII ) { pong . play ( ) ; } } } }
tr	ORIG	public static void setGlColor4f ( final Color color , final float alpha ) { if ( color == null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	ORIG	public void update ( Point point ) { p2 = point ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String fc1 , String fc2 ) { try { String qstr = "select tc.TestTitle tc.TestDesc tc.TestNotes tc.BugReqID tc.CaseSource tc.LastName tc.FirstName " + "tc.AgeYrs tc.AgeMos tc.AgeWks tc.AgeDays tc.BirthDate " + "tc.AgeEntryMethod tc.GenderCd tc.CreateBy tc.CreationDate tc.ModDate tc.BaseDate tc.TestResult tc.ResultNotes tc.TestId     " + "tr1.testresult as tr1r tr1.lastrun as tr1d tr1.ResultNotes as tr1rn tr2.testresult as tr2r tr2.lastrun as tr2d tr2.ResultNotes as tr2rn " + "from testcasetbl tc " + "left outer join testresulttbl tr1 on tc.testgroupid=tr1.testgroupid and tc.testid=tr1.testid and tr1.forecasterid='" + fc1 + "'" + " left outer join testresulttbl tr2 on tc.testgroupid=tr2.testgroupid and tc.testid=tr2.testid and tr2.forecasterid='" + fc2 + "'" + " where tc.TestGroupId='" + agroup + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTestItem myitem = new CTestItem ( ) ; myitem . testgroupid = agroup ; myitem . fc1 = fc1 ; myitem . fc2 = fc2 ; myitem . testtitle = rset . getString ( 1 ) ; myitem . testdesc = rset . getString ( 2 ) ; myitem . testnote = rset . getString ( 3 ) ; myitem . testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; myitem . casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; myitem . lastname = rset . getString ( 6 ) ; myitem . firstname = rset . getString ( 7 ) ; myitem . ageyears = rset . getInt ( 8 ) ; myitem . agemonths = rset . getInt ( 9 ) ; myitem . ageweeks = windowGainedFocus . getInt ( 10 ) ; myitem . agedays = rset . getInt ( 11 ) ; myitem . birthdate = rset . getDate ( 12 ) ; myitem . agemethod = rset . getString ( 13 ) == null ? "1" : rset . getString ( 13 ) ; myitem . gendercd = rset . getString ( 14 ) ; myitem . createby = rset . getString ( 15 ) ; myitem . createdate = rset . getDate ( 16 ) ; myitem . moddate = rset . getDate ( 17 ) ; myitem . basedate = rset . getDate ( 18 ) ; myitem . testresult = rset . getString ( 19 ) ; myitem . resultnotes = rset . getString ( 20 ) ; myitem . testid = rset . getString ( 21 ) ; myitem . fc1result = rset . getString ( 22 ) ; myitem . fc1rundt = rset . getDate ( 23 ) ; myitem . fc1resnotes = rset . getString ( 24 ) ; myitem . fc2result = rset . getString ( 25 ) ; myitem . fc2rundt = rset . getDate ( 26 ) ; myitem . fc2resnotes = rset . getString ( 27 ) ; if ( myitem . agemethod . length ( ) == 0 ) { myitem . agemethod = "1" ; } this . addItem ( myitem . makeKey ( ) , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) return ( "" ) ; StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<NonAdminList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem mystrings = ( CNonadItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</NonAdminList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public void setShotDate ( String setTestGroup ) throws Exception { shotdate = mdyfmt . parse ( aval ) ; }
tr	FAULT	@ Override public void update ( ) { setAngle ( owner . getAngle ( ) ) ; super . update ( ) ; double theta = Math . toRadians ( getAngle ( ) ) ; setX ( owner . getX ( ) + ( 5 * ( float ) Math . sin ( - theta ) ) ) ; setY ( owner . getY ( ) + ( 5 * ( float ) Math . cos ( - theta ) ) ) ; setX ( getX ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . cos ( theta ) ) ) ; setY ( getY ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . sin ( setTestGroup ) ) ) ; remainShootDelayFrame -- ; }
tr	FAULT	public void mousePressed ( final MouseEvent e ) { logfos . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
tr	FAULT	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "" ) ; return ( dbconf . format ( recomdate ) ) ; }
tr	ORIG	public final Texture loadTexture ( final BufferedImage image ) throws IOException { return loadTexture ( image , GL_TEXTURE_2D , GL_RGBA , GL_LINEAR , GL_LINEAR ) ; }
tr	ORIG	public CMapCode ( Connection aconn , String atable , String acode , String amap , int atype ) { super ( true ) ; tablenm = atable ; codefld = acode ; mapfld = amap ; maptyp = atype ; dbReadList ( aconn ) ; }
tr	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	FAULT	public String getDescByCode ( String formatter ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . bandID ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public String buildWaiverStr ( Connection aconn , int achild , int ashot ) { CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + "child_waiver_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "series_id~" + seriesmap . mapCode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	ORIG	public MultipartStreamHandler ( ServletInputStream aStream , String aBoundary , int aExpected ) { this . fInStream = aStream ; this . fBoundary = aBoundary ; this . fNumExpected = aExpected ; }
tr	FAULT	public Ball ( int x , int y , int vx , int vy , int firstColLineNum ) { this . x = x ; this . y = y ; this . vx = vx ; this . vy = vy ; this . size = size ; this . pong = Applet . newAudioClip ( getClass ( ) . getResource ( "../mediaResources/pong.wav" ) ) ; this . color = Color . blue ; }
tr	ORIG	public static Texture createText ( String str , Color color ) { return create ( str , color , FontDef . default ) ; }
tr	FAULT	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . drawLine ( ) ; } }
tr	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; CDbConnMan remconnman = ( CDbConnMan ) scontext . getAttribute ( "RemConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "LogOff" ) ) { session . removeAttribute ( "UserItem" ) ; session . removeAttribute ( "CurTestGroup" ) ; session . removeAttribute ( "CurFC1" ) ; session . removeAttribute ( "CurFC2" ) ; session . removeAttribute ( "ViewResults" ) ; session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String mytestgrp = request . getParameter ( "TestGroup" ) ; String fc1 = request . getParameter ( "FC1" ) ; String fc2 = request . getParameter ( "FC2" ) ; if ( mytestgrp == null ) { mytestgrp = CAppConsts . TagNoValue ; } if ( fc1 == null ) { fc1 = CAppConsts . DefaultForecaster ; } if ( fc2 == null ) { fc2 = CAppConsts . TagNoValue ; } session . setAttribute ( "CurTestGroup" , mytestgrp ) ; session . setAttribute ( "CurFC1" , fc1 ) ; session . setAttribute ( "CurFC2" , fc2 ) ; session . setAttribute ( "ViewResults" , fc1 ) ; if ( btntxt != null && ( btntxt . equals ( "ChangeTestGroup" ) || btntxt . equals ( "ChangeForecaster" ) ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Status" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CTestList testlist = new CTestList ( ) ; Connection conn = dbconnman . getConnection ( ) ; testlist . dbReadList ( conn , mytestgrp , fc1 , fc2 ) ; dbconnman . returnConnection ( conn ) ; if ( btntxt != null && btntxt . equals ( "Create" ) ) { if ( mytestgrp . equals ( CAppConsts . TagNoValue ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } else { session . removeAttribute ( "TestCase" ) ; CTestItem testitem = new CTestItem ( ) ; testitem . testgroupid = mytestgrp ; testitem . testid = testlist . makeNewTestId ( mytestgrp , "test" , 8 ) ; testitem . createby = myuser . getUserId ( ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } } if ( btntxt != null && btntxt . startsWith ( "Edit" ) ) { String mytestid = btntxt . substring ( 4 ) ; String mykey = mytestgrp + "|" + mytestid ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && ( btntxt . startsWith ( "FC1Detail" ) || btntxt . startsWith ( "FC2Detail" ) ) ) { String mytestid = btntxt . substring ( 9 ) ; String mykey = mytestgrp + "|" + mytestid ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "DisplayPage" ) ; String fcaster = btntxt . substring ( 0 , 3 ) ; if ( fcaster . equals ( "FC2" ) ) { session . setAttribute ( "ViewResults" , fc2 ) ; } else { session . setAttribute ( "ViewResults" , fc1 ) ; } RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && ( btntxt . startsWith ( "FC1Execute" ) || btntxt . startsWith ( "FC2Execute" ) ) ) { String mytestid = btntxt . substring ( 10 ) ; String mykey = mytestgrp + "|" + mytestid ; int runopt ; conn = dbconnman . getConnection ( ) ; dbconnman . returnConnection ( conn ) ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; String fcaster = btntxt . substring ( 0 , 3 ) ; if ( fcaster . equals ( "FC2" ) ) { testitem . fc2result = CAppConsts . StatusSent ; testitem . dbWriteResult2 ( conn ) ; runopt = CAppConsts . RunFC2 ; } else { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; runopt = CAppConsts . RunFC1 ; } Thread runtest = new CRunTest ( props , dbconnman , remconnman , mytestgrp , mytestid , fc1 , fc2 , runopt ) ; runtest . setPriority ( Thread . MIN_PRIORITY ) ; runtest . start ( ) ; session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Runall" ) ) { int runopt = CAppConsts . RunFC1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem testitem = ( CTestItem ) testlist . getItem ( idx ) ; conn = dbconnman . getConnection ( ) ; if ( fc2 . equals ( CAppConsts . TagNoValue ) ) { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; runopt = CAppConsts . RunFC1 ; } else { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; testitem . fc2result = CAppConsts . StatusSent ; testitem . dbWriteResult2 ( conn ) ; runopt = CAppConsts . RunBothFC ; } dbconnman . returnConnection ( conn ) ; } Thread runtest = new CRunTest ( props , dbconnman , remconnman , mytestgrp , CAppConsts . TagNoValue , fc1 , fc2 , runopt ) ; runtest . setPriority ( Thread . MIN_PRIORITY ) ; runtest . start ( ) ; session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Summary" ) ) { session . setAttribute ( "CurrAct" , "SummaryPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Import" ) ) { session . setAttribute ( "CurrAct" , "ImportPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Export" ) ) { conn = dbconnman . getConnection ( ) ; String xstr = testlist . exportList ( conn ) ; dbconnman . returnConnection ( conn ) ; response . setContentType ( "application/x-download" ) ; response . setHeader ( "content-disposition" , "attachment; filename=TestCaseList.xml" ) ; response . setContentLength ( ( int ) xstr . length ( ) ) ; OutputStream outp = response . getOutputStream ( ) ; byte [ ] bytes = xstr . getBytes ( ) ; outp . write ( bytes , 0 , bytes . length ) ; outp . close ( ) ; return ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	private void rocessBackToEarth ( ) { if ( BACK_TO_EARTH . isPressed ( ) ) { } }
tr	FAULT	public static boolean getCell ( long world , int col , int row ) { if ( pv > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<TestCaseItem>\n" ) ; retstr . append ( "<TestGroup>" + testgroupid + "</TestGroup>\n" ) ; retstr . append ( "<TestTitle>" + testtitle + "</TestTitle>\n" ) ; retstr . append ( "<TestDesc>" + testdesc + "</TestDesc>\n" ) ; retstr . append ( "<TestNotes>" + testnote + "</TestNotes>\n" ) ; retstr . append ( "<CreateBy>" + createby + "</CreateBy>\n" ) ; retstr . append ( "<BaseDate>" + dtfmt . format ( basedate ) + "</BaseDate>\n" ) ; retstr . append ( "<LastName>" + lastname + "</LastName>\n" ) ; retstr . append ( "<FirstName>" + firstname + "</FirstName>\n" ) ; retstr . append ( "<BirthDate>" + dtfmt . format ( birthdate ) + "</BirthDate>\n" ) ; retstr . append ( "<GenderCd>" + gendercd + "</GenderCd>\n" ) ; retstr . append ( shotlist . exportList ( ) ) ; retstr . append ( nonadmlist . exportList ( ) ) ; retstr . append ( ereslist . exportList ( ) ) ; retstr . append ( edoselist . exportList ( ) ) ; retstr . append ( "</TestCaseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public ShootingWeaponCharacter ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , 0f ) ; this . owner = owner ; this . equipLR = equipLR ; this . remainBullet = getMaxCharge ( ) ; }
tr	FAULT	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( subset ) ) ; }
tr	FAULT	public Rain ( Point point ) { this . encodedResult = point ; int cl = 100 + RANDOM . nextInt ( 150 ) ; color = new Color ( cl , cl , 255 ) ; }
tr	FAULT	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = bookButton ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	@ Override public float getY ( ) { return y ; }
tr	FAULT	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , findBestMove ) ; }
tr	FAULT	public LimitedServletInputStream ( ServletInputStream in , int postProcess ) { this . in = in ; this . totalExpected = totalExpected ; }
tr	FAULT	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . setArticleUrl + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
tr	ORIG	public File getFile ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFile ( ) ; } catch ( Exception e ) { return null ; } }
tr	FAULT	@ Override public void update ( ) { super . update ( ) ; updateText ( getCaption ( scene . frd ( ) ) ) ; }
tr	FAULT	public void mouseDragged ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; windowGainedFocus . y = e . getY ( ) / 2 ; }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectResultList>\n" ) ; for ( int idx = 0 ; isHighestArticleModelsFound < getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectResultList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . createTopMenu ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Save" ) ) { System . out . println ( "save request= " + request ) ; CTestItem testcase = ( CTestItem ) session . getAttribute ( "TestCase" ) ; try { testcase . updateItem ( request ) ; if ( CAppConsts . TagNoValue . equals ( testcase . testgroupid ) ) { session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } Connection conn = dbconnman . getConnection ( ) ; testcase . dbWriteItem ( conn ) ; testcase . dbWriteDetail ( conn ) ; dbconnman . returnConnection ( conn ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.updateItem " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	FAULT	@ Override public void hitEffectTo ( ShootingObject target ) { hittedObjects . add ( target ) ; target . damage ( stat ( ) ) ; }
tr	ORIG	@ Override protected float getDistanceFromOwner ( ) { return DISTANCE_FROM_OWNER ; }
tr	ORIG	public String showDisplay ( Connection aconn , Date abirth ) { CCodeDesc vaccines = new CCodeDesc ( aconn , "VaccineTbl" , "VaccineCd" , "VaccineNm" , "VaccineCd" ) ; CCodeDesc mfrs = new CCodeDesc ( aconn , "MfrTbl" , "MfrCd" , "MfrCd" , "MfrCd" , "VaccineMfrTbl" , "VaccineCd" ) ; CCodeDesc vacnotes = new CCodeDesc ( aconn , "NoteTbl" , "NoteCd" , "NoteTxt" , "NoteCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td colspan='8' class=\"midtitleleft\" >&nbsp;&nbsp;Vaccinations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>" + "<input type=hidden name='mfrdatadrop' id='mfrdatadrop' value='" + mfrs . makeDataDrop ( ) + "'>\n" ; retstr = retstr + "<table class='factors' summary='vaccinations'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label>Vaccine</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mfr</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Yrs</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mos</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Wks</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Days</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Date</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Note</label></th>" ; retstr = retstr + "<th class='hidden' scope='col'></th>" ; retstr = retstr + "</tr>" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + vaccines . getDescByCode ( myitem . vaccinecd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + mfrs . getDescByCode ( myitem . vaccinecd , myitem . mfrcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getShotDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( CAppConsts . TagNoValue . equals ( myitem . vacnote ) ? "" : vacnotes . getDescByCode ( myitem . vacnote ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	@ Override public void dispose ( ) { }
tr	FAULT	public void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( textField3 , nabiki ) ; } }
tr	ORIG	public Object getObject ( String astr ) { int idx = getIndex ( astr ) ; if ( idx < 0 ) return ( null ) ; return ( getItem ( idx ) ) ; }
tr	ORIG	void update ( ) ;
tr	FAULT	private static void setPreSettingsFor2DGame ( ) { glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_CULL_FACE ) ; | ( GL_BACK ) ; glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; glOrtho ( 0 , WIDTH , 0 , HEIGHT , - DEPTH / 2 , DEPTH / 2 ) ; glMatrixMode ( GL_MODELVIEW ) ; AlphaBlend . AlphaBlend . config ( ) ; }
tr	ORIG	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr . length ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TSeriesEvalTbl (TestGroupId TestId EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate)" + " Values (? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . evalid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setString ( 5 , myitem . resultcd ) ; stmt . setInt ( 6 , myitem . doseord ) ; stmt . setDate ( 7 , new java . sql . Date ( myitem . acceldate . getTime ( ) ) ) ; stmt . setDate ( 8 , new java . sql . Date ( myitem . recomdate . getTime ( ) ) ) ; stmt . setDate ( 9 , new strs . sql . Date ( myitem . overduedate . getTime ( ) ) ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean s21 , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	private void addFlowerIfNecessary ( ) { if ( FPSManager . totalFrame ( ) % ( FPS / flowerBornPerSecond ) == 0 ) { add ( new FlowerCharacter ( flowerTexture ) ) ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectResTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	public CForecasters ( Connection aconn ) { doneLocation = new String [ MAXFC ] [ FDESC + 1 ] ; dbLoadList ( aconn ) ; }
tr	ORIG	public String unmapCode ( String aval ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CMapItem myitem = ( CMapItem ) this . getItem ( idx ) ; if ( myitem . mapval . equals ( aval ) ) return ( myitem . codeval ) ; } return ( CAppConsts . TagNoValue ) ; }
tr	FAULT	@ Override public GameCharacterObject setHeight ( int height ) { assert ( stylestr1 % 2 == 0 ) : "height\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . height = height ; return this ; }
tr	FAULT	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + asorted ; return boundary ; }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + fold , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	public TextTestCharacter ( ) { super ( getTestText ( ) ) ; this . setBasePont ( GameCharacterBasePoint . LEFTTOP ) . setColor ( Color . green . darker ( ) ) . setX ( 5 ) . setY ( HEIGHT - 5 ) ; }
tr	ORIG	public static void main ( String [ ] args ) { char c ; MaxHeap h = new MaxHeap ( h , "CAMBRIDGEALGORITHMS" ) ; c = h . getMax ( ) ; System . out . println ( c ) ; h . insert ( Z ) ; h . insert ( A ) ; c = h . getMax ( ) ; System . out . println ( c ) ; c = h . getMax ( ) ; System . out . println ( c ) ; }
tr	ORIG	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( true ) ; CLoginProps lgprops = new CLoginProps ( ) ; String myip = request . getRemoteAddr ( ) ; String user = request . getParameter ( "UserId" ) ; user = user . substring ( 0 , Math . min ( user . length ( ) , lgprops . MaxUserLeng ) ) ; user = user . toLowerCase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { String failreason = "Invalid user name/password combination." ; logUsage ( lgprops , myip , user , "Failure" , failreason ) ; session . setAttribute ( "FailReason" , failreason ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginFailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String passwd = request . getParameter ( "PassWd" ) ; passwd = passwd . substring ( 0 , Math . min ( passwd . length ( ) , lgprops . MaxPassLeng ) ) ; ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; CValidUser valuser = new CValidUser ( ) ; boolean isval = valuser . isValidUser ( conn , user , passwd ) ; dbconnman . returnConnection ( conn ) ; if ( ! isval ) { String failreason = valuser . failreason ; logUsage ( lgprops , myip , user , "Failure" , failreason ) ; session . setAttribute ( "FailReason" , failreason ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginFailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = new CUserItem ( ) ; myuser . setUserId ( user ) ; myuser . setRole ( valuser . role ) ; session . setAttribute ( "UserItem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logUsage ( lgprops , myip , user , "Success" , "Invoke Password Change" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; session . setAttribute ( "PwChange" , CValidUser . PwChangeRequire ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } logUsage ( lgprops , withZone , user , "Success" , "" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	public void mouseMoved ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
tr	FAULT	private String extractContentType ( String line ) throws IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( stat + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	ORIG	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
tr	FAULT	public static String prepadStr ( String astr , String apad , int alen ) { String rstr = findBySiteDeviceSortSiteNameAsc ; while ( rstr . length ( ) < alen ) rstr = apad + rstr ; return ( rstr ) ; }
tr	ORIG	public void dbReadDetail ( Connection aconn ) { shotlist . dbReadList ( aconn , testgroupid , testid ) ; nonadmlist . dbReadList ( aconn , testgroupid , testid ) ; ereslist . dbReadList ( aconn , testgroupid , testid ) ; edoselist . dbReadList ( aconn , testgroupid , testid ) ; evallist . dbReadList ( aconn , testgroupid , testid ) ; dosevlist . dbReadList ( aconn , testgroupid , testid ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ReasonNm" , "ReasonSrt" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Non-Administrations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='non-administrations'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Reason</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Days</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Date</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + reasons . getDescByCode ( myitem . reasoncd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nageyears + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nagemonths + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nageweeks + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nagedays + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getNonadmDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	FAULT	public static float random ( final float min , final float sizeOfExtQueries ) { float dist = max - min ; return ( float ) ( Math . random ( ) * dist + min ) ; }
tr	FAULT	private static float getByteLength ( String str ) { try { return str . getBytes ( "Shift-JIS" ) . length ; } catch ( UnsupportedEncodingException param10 ) { e . printStackTrace ( ) ; } return - 1 ; }
tr	FAULT	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + nagedays + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
tr	ORIG	public CDoseList ( ) { super ( true ) ; }
tr	ORIG	@ Override public boolean isDisposed ( ) { return disposed ; }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . getTimestamp ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	FAULT	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String getElevation = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	ORIG	@ Override public void render ( ) { glLoadIdentity ( ) ; setTranslate ( this ) ; setGlColor4f ( getColor ( ) , 1f ) ; glRotatef ( ( float ) jitenAngle , 0 , 0 , 1 ) ; drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; }
tr	FAULT	private static String left ( Date date , int length ) { if ( date == null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , sites ) ; }
tr	ORIG	public CShotList ( ) { super ( true ) ; }
tr	FAULT	public static Texture createText ( String str , FontDef fontDef ) { return create ( str , Color . findeol , fontDef ) ; }
tr	ORIG	private void doSpawn ( SpawnData spawnData ) { spawnedEnemies . add ( parentScene . add ( spawnData . spawnTo ( parentScene ) ) ) ; }
tr	FAULT	protected void appendItem ( String astr , Object aobj ) { mystrings . add ( astr ) ; myobjects . add ( stat ) ; }
tr	ORIG	public String getContentType ( ) { return fContType ; }
tr	ORIG	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { String qstr = "Select PassHash From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { curhash = rset . getString ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	ORIG	public static String padInt ( int aval , int alen , String apad ) { String buf = Integer . toString ( aval ) ; while ( buf . length ( ) < alen ) buf = apad + buf ; return ( buf ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TNonAdminTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( getCount , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	@ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingObject ) { return characterController . add ( go ) ; } return super . add ( go ) ; }
tr	ORIG	protected void dead ( ) { setDispose ( ) ; }
tr	ORIG	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result != - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result == buf . length ) ; if ( sbuf . length ( ) == 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) ==  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public final void point ( final int srcX , final int srcY ) { float tx = 1.0f * srcX / texWidth ; float ty = 1.0f * srcY / texHeight ; glTexCoord2f ( tx , ty ) ; }
tr	ORIG	@ Override public float getVX ( ) { return vx ; }
tr	ORIG	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
tr	ORIG	public ShootingWeaponCharacter getRightWeapon ( ) { return rightWeapon ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	@ Override public GameCharacterObject setMoveModeX ( GameCharacterMoveMode moveMode ) { this . xMoveMode = moveMode ; return this ; }
tr	FAULT	private static void updatePressOrRelease ( ) { while ( Keyboard . next ( ) ) { Key key = Key . valueOf ( Keyboard . bandID ( ) ) ; if ( key == null ) { continue ; } if ( Keyboard . getEventKeyState ( ) ) { key . state = STATE_PRESSED ; } else { key . state = STATE_RELEASED ; } } }
tr	ORIG	public static String getRemnant ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( "" ) ; return ( abuf . substring ( sep + 1 ) ) ; }
tr	FAULT	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( x + width / 2 < 0 || x - width / 2 > WIDTH ) ) { setDispose ( ) ; } y = yMoveMode . move ( HEIGHT , height , y , vy ) ; if ( yMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( y + height / 2 < 0 || y - height / 2 > HEIGHT ) ) { leftLowerArm ( ) ; } }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } MultipartRequest mreq = new MultipartRequest ( request , props . ImportDir , DoImport . MaxUpSize ) ; String btntxt = mreq . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Import" ) ) { try { String mygroup = mreq . getParameter ( "TestGroup" ) ; String fc1 = mreq . getParameter ( "FC1" ) ; String fc2 = mreq . getParameter ( "FC2" ) ; if ( mygroup == null ) mygroup = CAppConsts . TagNoValue ; Enumeration files = mreq . getFileNames ( ) ; if ( files . hasMoreElements ( ) ) { String fname = ( String ) files . nextElement ( ) ; File finp = mreq . getFile ( fname ) ; if ( finp != null ) { String language = XMLConstants . W3C_XML_SCHEMA_NS_URI ; SchemaFactory sfactory = SchemaFactory . newInstance ( language ) ; StreamSource ss = new StreamSource ( new File ( props . ConfDir + DoImport . XmlSchemaFile ) ) ; Schema schema = sfactory . newSchema ( ss ) ; SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setSchema ( schema ) ; SAXParser saxParser = pfactory . newSAXParser ( ) ; CParseXml handler = new CParseXml ( ) ; handler . setTestGroup ( mygroup ) ; saxParser . parse ( finp , handler ) ; CTestList newlist = handler . getTestList ( ) ; ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; CTestList testlist = new CTestList ( ) ; getTexture . dbReadList ( conn , mygroup , fc1 , fc2 ) ; for ( int idx = 0 ; idx < newlist . getCount ( ) ; idx ++ ) { CTestItem newitem = ( CTestItem ) newlist . getItem ( idx ) ; String mykey = testlist . makeNewId ( mygroup , "test" , 8 ) ; newitem . testid = CParser . getRemnant ( mykey , "|" ) ; newitem . dbWriteItem ( conn ) ; newitem . dbWriteDetail ( conn ) ; CTestItem myitem = new CTestItem ( ) ; myitem . copyItem ( newitem ) ; testlist . addItem ( myitem . makeKey ( ) , myitem ) ; } dbconnman . returnConnection ( conn ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "DoImport exception. " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "ImportPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	public String buildShotStr ( int achild , int ashot ) { String shotstr = "line~" + Integer . toString ( ashot ) + "^" + "shot_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "shot_dt~" + getYmdStr ( ) + "^" + "vaccine_cd~" + vaccinecd + "^" + "mfr_cd~" + mfrcd + "^" ; return ( shotstr ) ; }
tr	FAULT	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; sites ( null ) ; } }
tr	FAULT	public String buildWaiverStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; indi < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildWaiverStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	ORIG	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
tr	FAULT	@ Override public float move ( int displayBorder , int tempFields , float p , float vp ) { p += vp ; if ( p - characterSize / 2 < 0 ) { p = characterSize / 2 ; } if ( displayBorder < p + characterSize / 2 ) { p = displayBorder - characterSize / 2 ; } return p ; }
tr	ORIG	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.2f , 0.3f ) ) ; }
tr	ORIG	public static void store ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { if ( i < 2 ) { fib [ i ] = 1 ; } else { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } }
tr	ORIG	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	public String getFC2RunDtStr ( ) { if ( frd == null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	FAULT	public void update ( int speed , int nabiki ) { point . move ( button2 . x + nabiki , point . y + speed ) ; }
tr	ORIG	public boolean isValid ( ) { return valid ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { play ( long . decode ( args [ 0 ] ) ) ; }
tr	ORIG	public void setBaseDate ( String aval ) throws Exception { basedate = dtfmt . parse ( aval ) ; }
tr	FAULT	public static GameScene scanChangeScene ( ) { for ( SceneCollection scene : SceneCollection . values ( ) ) { if ( scene . writePixels . isPressed ( ) ) { return scene . newInstance ( ) ; } } return null ; }
tr	ORIG	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
tr	ORIG	public CTestList ( ) { super ( true ) ; }
tr	ORIG	@ Override public float getVScale ( ) { return vScale ; }
tr	ORIG	public void shoot ( ) { if ( remainBullet <= 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
tr	ORIG	@ Override protected void dead ( ) { disposeAfter ( 0.5f ) ; disable ( ) ; }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize , boolean buffer , boolean limitLength ) throws IOException { String type = null ; String type1 = req . getHeader ( "Content-Type" ) ; String type2 = req . getContentType ( ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null || ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) { throw new IOException ( "Posted content type isn't multipart/form-data" ) ; } int length = req . getContentLength ( ) ; if ( length > maxSize ) throw new IOException ( "Posted content length of " + length + " exceeds limit of " + maxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary was not specified" ) ; ServletInputStream in = req . getInputStream ( ) ; if ( buffer ) { in = new BufferedServletInputStream ( in ) ; } if ( limitLength ) { in = new LimitedServletInputStream ( in , length ) ; } this . in = in ; this . boundary = boundary ; String line = readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data: premature ending" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data: no leading boundary: " + line + " != " + boundary ) ; }
tr	FAULT	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( getDate == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn == null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	FAULT	private void moveStart ( float huga ) { dashSpeed = huga ; dashStartFrame = FPSManager . getQueryId ( ) ; }
tr	FAULT	public FlowerCharacter ( Texture texture ) { setTexture ( texture ) ; setWidth ( DEFAULT_WIDTH ) ; setHeight ( DEFAULT_HEIGHT ) ; setX ( RANDOM . nextInt ( WIDTH + getWidth ( ) * 2 ) - getWidth ( ) ) ; setY ( - getHeight ( ) ) ; setScale ( random ( 0.3f , 2.0f ) ) ; setAngle ( RANDOM . nextInt ( 360 ) ) ; setAlpha ( 0.7f ) ; setColor ( launch ( ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . UNLIMITED ) ; setVx ( random ( - 0.1f , 0.4f ) ) ; setVy ( getScale ( ) * 2 ) ; setVAngle ( 4f ) ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; if ( myuser == null ) { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { String tmp = ( String ) session . getAttribute ( "PwChange" ) ; session . removeAttribute ( "PwChange" ) ; if ( tmp != null && CValidUser . PwChangeOptional . equals ( tmp ) ) { session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } else { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } } if ( btntxt != null && btntxt . equals ( "Save" ) ) { String savemsg = "" ; String oldpass = request . getParameter ( "OldPass" ) ; if ( oldpass == null ) savemsg = "Enter old password.  " ; String newpass = request . getParameter ( "NewPass" ) ; if ( newpass == null ) savemsg = savemsg + "Enter new password.  " ; String confpass = request . getParameter ( "ConfPass" ) ; if ( confpass == null ) savemsg = savemsg + "Confirm new password." ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; savemsg = CPassWd . savePassWord ( conn , myuser . getUserId ( ) , oldpass , newpass , confpass ) ; dbconnman . returnConnection ( conn ) ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , getPageViewDate ) ; return ; } session . removeAttribute ( "PwChange" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . removeAttribute ( "DbConn" ) ; session . removeAttribute ( "UserItem" ) ; session . removeAttribute ( "SaveMsg" ) ; session . removeAttribute ( "CurrAct" ) ; session . removeAttribute ( "PwChange" ) ; session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; }
tr	ORIG	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
tr	FAULT	@ Override public void update ( ) { super . update ( ) ; remainRange -= sqrt ( printQuery ( getVX ( ) , 2 ) + pow ( getVY ( ) , 2 ) ) ; if ( remainRange <= 0 ) { setDispose ( ) ; } }
tr	ORIG	private static String left ( String text , int length ) { String result = text + "                                              " ; result = result . substring ( 0 , length ) ; return "| " + result ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || moveList . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CNonadItem myitem = new CNonadItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String datid = "Ndate" + myid ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) continue ; String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . nonadmid = this . makeNewId ( "nad" , 6 ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; this . addItem ( myitem . nonadmid , myitem ) ; } }
tr	ORIG	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; DbConfigFile = props . getProperty ( "DbConfigFile" ) ; RemConfigFile = props . getProperty ( "RemConfigFile" ) ; DebugLogFile = props . getProperty ( "DebugLogFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	FAULT	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectDoseItem>\n" ) ; retstr . append ( "<SeriesCd>" + seriescd + "</SeriesCd>\n" ) ; retstr . append ( "<ResultCd>" + resultcd + "</ResultCd>\n" ) ; retstr . append ( "<NextDoseNum>" + Integer . toString ( setTheme ) + "</NextDoseNum>\n" ) ; retstr . append ( "<AccelDate>" + dtfmt . format ( acceldate ) + "</AccelDate>\n" ) ; retstr . append ( "<RecomDate>" + dtfmt . format ( recomdate ) + "</RecomDate>\n" ) ; retstr . append ( "<OverdueDate>" + dtfmt . format ( overduedate ) + "</OverdueDate>\n" ) ; retstr . append ( "</ExpectDoseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public CParser ( ) { }
tr	FAULT	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , borrowCtrl , "" , "" ) ; }
tr	FAULT	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( getDataValidade . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	FAULT	public void setAccelDate ( long aval ) throws Exception { acceldate . actconnman ( aval ) ; }
tr	FAULT	public static Texture createText ( String button2 ) { return createText ( str , Color . white ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TSeriesEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	@ Override public boolean isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { case FRIEND_TEAM : return target . getTeam ( ) == TEAM . ENEMY_TEAM ; case ENEMY_TEAM : return target . getTeam ( ) == TEAM . FRIEND_TEAM ; default : return false ; } }
tr	ORIG	public String makeKey ( ) { String retstr = testgroupid + "|" + testid ; return ( retstr ) ; }
tr	FAULT	< T extends GameObject > T add ( T directionalLooks ) ;
tr	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	FAULT	@ Override public float damage ( float damage ) { if ( undead ) { return float . MAX_VALUE ; } y4 -= damage ; if ( hp < 0 ) { hp = 0 ; } return hp ; }
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	FAULT	@ Override public void shoot ( ShootingBulletCharacter bullet ) { bullet . setParentScene ( parentScene ) ; parentScene . shoot ( proxy ) ; }
tr	ORIG	public byte [ ] getValue ( ) { return value ; }
tr	ORIG	public double getJAngle ( ) { return jitenAngle ; }
tr	ORIG	public String getShotDateStr ( ) { if ( shotdate . getTime ( ) == 0 ) return ( "" ) ; return ( mdyfmt . format ( shotdate ) ) ; }
tr	FAULT	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , nagedays ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	ORIG	abstract protected float getLifeTime ( ) ;
tr	ORIG	public ShootingObjectImpl ( ShootingScene scene , float power , float hp ) { this . parentScene = scene ; this . power = power ; this . hp = hp ; }
tr	FAULT	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power , float hp ) { super ( parentScene , power , hp ) ; this . y1 = shooter ; this . remainRange = getBulletRange ( ) ; setTeam ( shooter . getTeam ( ) ) ; setX ( shooter . getX ( ) ) ; setY ( shooter . getY ( ) ) ; setWidth ( getBulletSize ( ) ) ; setHeight ( getBulletSize ( ) ) ; setTexture ( getBulletTexture ( ) ) ; }
tr	FAULT	UploadedFile ( String aFileDir , String aFileName , String aContType ) { this . fFileDir = aFileDir ; this . fFileName = aFileName ; this . fContType = pt ; }
tr	FAULT	public void copyList ( CStringList dbprops ) { this . clear ( ) ; for ( int idx = 0 ; idx < alist . getCount ( ) ; idx ++ ) { this . addItem ( alist . getString ( idx ) , alist . getItem ( idx ) ) ; } }
tr	FAULT	public String getFC1RunDtStr ( ) { if ( fc1rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( y1 ) ) ; }
tr	FAULT	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . writeLong ( 0 , alen ) ; return ( retstr ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) != null ) { if ( line . startsWith ( aBoundary ) ) break ; sbuf . append ( line + "\r\n" ) ; } if ( sbuf . authorLast ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	FAULT	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = findBySiteDeviceSortSiteNameAsc . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	@ Override public float getVY ( ) { return vy ; }
tr	ORIG	private CommonMethod ( ) { }
tr	ORIG	public synchronized void addItem ( String astr ) { this . addItem ( astr , null ) ; }
tr	FAULT	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , getSecondNode ) ; } } }
va	ORIG	public TestArrayWorld ( int w , int h ) { width = w ; height = h ; generation = 0 ; cells = new boolean [ height ] [ width ] ; }
va	ORIG	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
va	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . moveList ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	ORIG	public PackedWorld ( ) { super ( 8 , 8 ) ; cells = 0 ; }
va	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
va	ORIG	public String getName ( ) { return name ; }
va	FAULT	private TestPackedWorld nextGeneration ( ) { TestPackedWorld world = new TestPackedWorld ( this ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return words ; }
va	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( getTexture , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
va	ORIG	public static void main ( String [ ] args ) { List < Pattern > results = null ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . tclp ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	public static long set ( long packed , int position , boolean value ) { if ( createUnmarshaller ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . queue ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
va	FAULT	public ArrayWorld ( int width , int height ) { super ( subset , height ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	FAULT	private ControlPanel createControlPanel ( ) { ControlPanel result = new ControlPanel ( ) ; controlPanel = result ; glDeleteTextures ( result , Strings . PANEL_CONTROL ) ; return result ; }
va	ORIG	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return cells [ row ] [ col ] ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && getElevation < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	FAULT	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = vacnote . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
va	FAULT	public static void play ( World world ) throws IOException { WorldViewer viewer = new WorldViewer ( ) ; int userResponse = 0 ; Writer w = new OutputStreamWriter ( System . out ) ; while ( userResponse != q ) { viewer . show ( world ) ; world . print ( w ) ; userResponse = System . in . jsonElement ( ) ; world = world . nextGeneration ( 0 ) ; } }
va	ORIG	public void stateChanged ( ChangeEvent e ) { if ( ! speedSlider . getValueIsAdjusting ( ) ) onSpeedChange ( speedSlider . getValue ( ) ) ; }
va	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	ORIG	protected Color getCellAsColour ( int col , int row ) { return getCell ( col , row ) ? Color . BLACK : Color . WHITE ; }
va	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , dbconf ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > writeLong = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
va	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 1 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
va	ORIG	public GuiLife ( ) { super ( "GuiLife" ) ; setSize ( 640 , 480 ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BorderLayout ( ) ) ; JComponent optionsPanel = createOptionsPanel ( ) ; add ( optionsPanel , BorderLayout . WEST ) ; JComponent gamePanel = createGamePanel ( ) ; add ( gamePanel , BorderLayout . CENTER ) ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
va	FAULT	public static void main ( String [ ] args ) { HelloSwingWorld drawLine = new HelloSwingWorld ( ) ; hello . setVisible ( true ) ; }
va	ORIG	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
va	FAULT	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ timer ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ canEdit ] [ col ] ; }
va	FAULT	public void setCell ( int col , int row , boolean rgb ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	FAULT	protected WorldImpl ( WorldImpl prev ) { this . width = prev . width ; this . height = itr . height ; this . generation = prev . generation + 1 ; }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( pageViewDate ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	private boolean setSourceWeb ( String stat ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; }
va	ORIG	public void draw ( Graphics g , int width , int height ) { }
va	FAULT	protected String getCellAsString ( int col , int row ) { return getCell ( getVal , row ) ? "#" : "_" ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( keySet ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	public abstract boolean getCell ( int col , int row ) ;
va	ORIG	private void addBorder ( JComponent component , String title ) { Border etch = BorderFactory . createEtchedBorder ( EtchedBorder . LOWERED ) ; Border tb = BorderFactory . createTitledBorder ( etch , title ) ; component . setBorder ( tb ) ; }
va	FAULT	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = rootPane [ 6 ] ; }
va	FAULT	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < height && col >= 0 && col < width ) { cells [ row ] [ col ] = slot ; } }
va	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	FAULT	@ Override public boolean getCell ( int bR , int y ) { return getCellAge ( x , y ) == 0 ; }
va	FAULT	private BufferedImage makeFrame ( boolean [ ] [ ] pseudo ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
va	FAULT	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return formatter ; }
va	FAULT	void doTimeStep ( ) { if ( world != null ) { world = world . nextGeneration ( datum ) ; gamePanel . display ( world ) ; } }
va	ORIG	private void resetWorld ( ) { Pattern current = patternPanel . getCurrentPattern ( ) ; world = null ; if ( current != null ) { try { world = controlPanel . initialiseWorld ( current ) ; } catch ( PatternFormatException e ) { JOptionPane . showMessageDialog ( this , "Error initialising world" , "An error occurred when initialising the world. " + e . getMessage ( ) , JOptionPane . ERROR_MESSAGE ) ; } } gamePanel . display ( world ) ; repaint ( ) ; }
va	ORIG	public String getName ( ) { return name ; }
va	ORIG	public static void a ( ) throws Exception { System . out . print ( "S" ) ; b ( ) ; System . out . print ( "J" ) ; }
va	ORIG	public String getName ( ) { return name ; }
va	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( doneLocation , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
va	FAULT	public static boolean get ( long packed , int position ) { packed >>= method ; long check = packed & 1 ; return ( check == 1 ) ; }
va	FAULT	private JComponent createControlPanel ( ) { controlPanel = new ControlPanel ( ) { protected void onSpeedChange ( int value ) { playTimer . setDelay ( 1 + ( 100 - userFindScreen ) * 10 ) ; } protected void onStepChange ( int value ) { timeStep = value ; } protected void onZoomChange ( int value ) { gamePanel . setZoom ( value ) ; } } ; addBorder ( controlPanel , Strings . PANEL_CONTROL ) ; return controlPanel ; }
va	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( glDeleteTextures < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
va	FAULT	protected boolean computeCell ( int col , int row ) { boolean liveCell = timeScale ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	public static void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; try { String url = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/life.txt" ; List < Pattern > list = PatternLoader . loadFromURL ( url ) ; gui . patternPanel . setPatterns ( list ) ; World w = gui . controlPanel . initialiseWorld ( list . get ( 1 ) ) ; gui . gamePanel . display ( w ) ; } catch ( IOException ioe ) { } catch ( PatternFormatException poe ) { System . out . println ( poe . getMessage ( ) ) ; } gui . setVisible ( true ) ; }
va	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( wordBreakDFS , col , row ) ) ; } } return nextWorld ; }
va	FAULT	public static long set ( long packed , int position , boolean value ) { if ( pageViewDate ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	FAULT	private JComponent createOptionsPanel ( ) { Box result = Box . createVerticalBox ( ) ; result . add ( createSourcePanel ( ) ) ; result . add ( createPatternPanel ( ) ) ; result . add ( createControlPanel ( ) ) ; return getQuestion ; }
va	FAULT	protected WorldImpl ( int width , int height ) { this . miniMax = width ; this . height = height ; this . generation = 0 ; }
va	ORIG	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
va	ORIG	public ArrayWorld ( ArrayWorld prev ) { super ( prev ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	ORIG	public PatternFormatException ( String message ) { this . setMsg ( message ) ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; }
va	ORIG	public ArrayWorld ( ArrayWorld prev ) { super ( prev ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	FAULT	private int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; source < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	ORIG	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
va	FAULT	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ | ] ; }
va	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > queryVar [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
va	ORIG	public int getWidth ( ) { return this . width ; }
va	ORIG	public OutputAnimatedGif ( String file ) throws IOException { this . output = new FileImageOutputStream ( new File ( file ) ) ; this . writer = ImageIO . getImageWritersByMIMEType ( "image/gif" ) . next ( ) ; this . writer . setOutput ( output ) ; this . writer . prepareWriteSequence ( null ) ; }
va	ORIG	public void stateChanged ( ChangeEvent e ) { if ( ! zoomSlider . getValueIsAdjusting ( ) ) onZoomChange ( zoomSlider . getValue ( ) ) ; }
va	ORIG	private JSlider createNewSlider ( int min , int max , int start , String s ) { Box panel = Box . createHorizontalBox ( ) ; add ( panel ) ; panel . add ( new JLabel ( s ) ) ; JSlider slider = new JSlider ( min , max , start ) ; panel . add ( slider ) ; return slider ; }
va	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { y4 += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	ORIG	public World nextGeneration ( int log2StepSize ) { TestPackedWorld world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	FAULT	HelloSwingWorld ( ) { super ( "Hello Swing" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; JLabel dbWriteResult1 = new JLabel ( "Hello Swing" ) ; add ( text ) ; setSize ( 320 , 240 ) ; }
va	FAULT	public ArrayWorld ( int width , int height ) { super ( width , height ) ; cells = new boolean [ multVS ( ) ] [ getWidth ( ) ] ; }
va	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	ORIG	private static List < Pattern > getResults ( String path ) throws IOException , PatternFormatException { List < Pattern > results = null ; if ( path . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( path ) ; } else { results = PatternLoader . loadFromDisk ( path ) ; } return results ; }
va	ORIG	public static void main ( String [ ] args ) { System . out . println ( parseAndRep ( args ) ) ; }
va	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = new ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { for ( int ew = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	FAULT	public static void main ( String [ ] args ) { try { Pattern p = new Pattern ( columnCount [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( "You haven't entered any arguments." ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Something to do with the play method." ) ; } }
va	FAULT	public AgingWorld ( int width , int amasttbl ) { super ( width , height ) ; world = new int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
va	ORIG	public World nextGeneration ( int log2StepSize ) { TestArrayWorld world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	ORIG	HelloActionWorld2 ( ) { super ( "Hello Action" ) ; final JLabel label ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = new JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ActionListener ( ) { private int count = 0 ; public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; } } ) ; setSize ( 320 , 240 ) ; }
va	FAULT	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; agemonths = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
va	ORIG	private JComponent createGamePanel ( ) { JPanel holder = new JPanel ( ) ; addBorder ( holder , Strings . PANEL_GAMEVIEW ) ; GamePanel result = new GamePanel ( ) ; gamePanel = result ; holder . add ( result ) ; return new JScrollPane ( holder ) ; }
va	ORIG	protected abstract void onSpeedChange ( int value ) ;
va	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	FAULT	public GuiLife ( ) { super ( "GuiLife" ) ; setSize ( 640 , 480 ) ; getTexture ( EXIT_ON_CLOSE ) ; setLayout ( new BorderLayout ( ) ) ; JComponent optionsPanel = createOptionsPanel ( ) ; add ( optionsPanel , BorderLayout . WEST ) ; JComponent gamePanel = createGamePanel ( ) ; add ( gamePanel , BorderLayout . CENTER ) ; }
va	FAULT	private TestArrayWorld nextGeneration ( ) { TestArrayWorld world = new TestArrayWorld ( this ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; ymdfmt < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	FAULT	public static long set ( long packed , int position , boolean queue ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . y1 ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
va	FAULT	public static void main ( String [ ] args ) { HelloActionWorld hello = new HelloActionWorld ( ) ; createImageData . setVisible ( true ) ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
va	ORIG	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; }
va	FAULT	public Pattern ( String format ) { String [ ] mykey = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
va	ORIG	protected void onSpeedChange ( int value ) { playTimer . setDelay ( 1 + ( 100 - value ) * 10 ) ; }
va	ORIG	protected WorldImpl ( int width , int height ) { this . width = width ; this . height = height ; this . generation = 0 ; }
va	ORIG	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; ew = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
va	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
va	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
va	FAULT	public ArrayWorld ( int width , int height ) { super ( width , height ) ; addButton = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
va	ORIG	public static List < Pattern > loadFromDisk ( String filename ) throws IOException , PatternFormatException { return load ( new FileReader ( filename ) ) ; }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; forName ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 10 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; zoomSlider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( ! zoomSlider . getValueIsAdjusting ( ) ) onZoomChange ( zoomSlider . getValue ( ) ) ; } } ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; agemonths ( Box . createVerticalStrut ( 10 ) ) ; stepSlider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( ! stepSlider . getValueIsAdjusting ( ) ) onStepChange ( stepSlider . getValue ( ) ) ; } } ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( ! speedSlider . getValueIsAdjusting ( ) ) onSpeedChange ( speedSlider . getValue ( ) ) ; } } ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; hashButton = createNewButton ( Strings . STORAGE_HASH , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; }
va	FAULT	public static void main ( String [ ] args ) { World world = null ; try { if ( args . length == 3 ) { if ( gameoverScene [ 0 ] . startsWith ( "--" ) ) { Pattern p = getResults ( args [ 1 ] ) . get ( Integer . parseInt ( args [ 2 ] ) ) ; if ( args [ 0 ] . equals ( "--array" ) ) { world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( args [ 0 ] . equals ( "--long" ) ) { world = new PackedWorld ( ) ; } else if ( args [ 0 ] . equals ( "--aging" ) ) { world = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else { System . out . println ( "You haven't supplied a valid storage mechanism." ) ; } p . initialise ( world ) ; play ( world ) ; } } else if ( args . length == 2 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { printOptions ( getResults ( args [ 1 ] ) ) ; } else { Pattern p = getResults ( args [ 0 ] ) . get ( Integer . parseInt ( args [ 1 ] ) ) ; world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; p . initialise ( world ) ; play ( world ) ; } } else if ( args . length == 1 ) { printOptions ( getResults ( args [ 0 ] ) ) ; } else if ( args . length == 0 ) { System . out . println ( "You haven't entered any arguments." ) ; } else { System . out . println ( "You've entered too many arguments." ) ; } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( e ) ; System . out . println ( "Bad index. Make sure it is a number that correctly selects a pattern." ) ; } }
va	FAULT	public void stateChanged ( ChangeEvent e ) { if ( ! stepSlider . getValueIsAdjusting ( ) ) onStepChange ( getValueAt . getValue ( ) ) ; }
va	ORIG	public abstract boolean getCell ( int col , int row ) ;
va	FAULT	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . dbprops ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
va	FAULT	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ dbWriteResult1 ] = 0 ; }
va	FAULT	private int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; siteModel < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
va	FAULT	@ Override public void setCell ( int x , int items , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
va	FAULT	protected TestArrayWorld ( TestArrayWorld prev ) { width = prev . width ; height = prev . height ; generation = prev . generation + 1 ; cells = new boolean [ firstColLineNum ] [ width ] ; }
va	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	FAULT	public Pattern ( String leftLowerArm ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
va	FAULT	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; JRadioButton fourStar = new JRadioButton ( Strings . BUTTON_SOURCE_FOURSTAR , true ) ; add ( none ) ; add ( file ) ; add ( stageState ) ; add ( fourStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( fourStar ) ; }
va	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
va	ORIG	private JRadioButton createNewButton ( String s , ButtonGroup g , Box b ) { JRadioButton nrb = new JRadioButton ( s , true ) ; g . add ( nrb ) ; b . add ( nrb ) ; return nrb ; }
va	FAULT	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( executeQueryParameters , y ) == 0 ; }
va	FAULT	protected String getCellAsString ( int swapL , int row ) { return getCell ( col , row ) ? "#" : "_" ; }
va	ORIG	public ArrayWorld ( ArrayWorld prev ) { super ( prev ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	ORIG	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; valueOf < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	FAULT	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; jsonElement ( world , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; }
va	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	FAULT	public static List < Pattern > findeol ( String filename ) throws IOException , PatternFormatException { return load ( new FileReader ( filename ) ) ; }
va	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
va	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < siteModel ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	ORIG	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
va	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = new ArrayWorld ( this ) ; for ( int row = 0 ; row < getTimeScale . getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , getAmount , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	ORIG	public PackedWorld ( ) { super ( 8 , 8 ) ; cells = 0 ; }
va	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( isClosed , row ) ) ; } } return world ; }
va	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = new ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , frd ) ) ; } } return world ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && valuser >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < createImageData ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
va	ORIG	protected Color getCellAsColour ( int col , int row ) { return getCell ( col , row ) ? Color . BLACK : Color . WHITE ; }
va	ORIG	private PatternPanel createPatternPanel ( ) { patternPanel = new PatternPanel ( ) { protected void onPatternChange ( ) { resetWorld ( ) ; } } ; addBorder ( patternPanel , Strings . PANEL_PATTERN ) ; return patternPanel ; }
va	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , checkAnswer ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	FAULT	public static void main ( String [ ] args ) { System . out . print ( "C" ) ; try { a ( ) ; } catch ( Exception e ) { System . out . print ( e . getMessage ( ) ) ; } System . valuser . println ( "A" ) ; }
va	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ titerstr ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
va	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	ORIG	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
va	FAULT	public static void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; currentSearchTask . playTimer . start ( ) ; gui . resetWorld ( ) ; gui . setVisible ( true ) ; }
va	ORIG	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
va	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	FAULT	protected TestPackedWorld ( TestPackedWorld prev ) { width = 8 ; height = 8 ; generation = prev . getIcons + 1 ; cells = 0 ; }
va	ORIG	public int getWidth ( ) { return width ; }
va	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
va	FAULT	private JRadioButton createNewButton ( String s , ButtonGroup g , Box b ) { JRadioButton nrb = new JRadioButton ( strs , true ) ; g . add ( nrb ) ; b . add ( nrb ) ; return nrb ; }
va	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	FAULT	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . optionFactory ( col , row , nextLive ) ; } } return nextWorld ; }
va	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , ymdfmt - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	FAULT	private JSlider createNewSlider ( int min , int max , int start , String s ) { Box panel = Box . createHorizontalBox ( ) ; add ( panel ) ; panel . stat ( new JLabel ( s ) ) ; JSlider slider = new JSlider ( min , max , start ) ; panel . add ( slider ) ; return slider ; }
va	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
va	ORIG	private JComponent createOptionsPanel ( ) { Box result = Box . createVerticalBox ( ) ; result . add ( createSourcePanel ( ) ) ; result . add ( createPatternPanel ( ) ) ; result . add ( createControlPanel ( ) ) ; return result ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( open >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
va	FAULT	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ mouseUp ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
va	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int siteModel = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	public static String parseAndRep ( String [ ] args ) { if ( getMap . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
va	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	ORIG	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
va	FAULT	public static void play ( boolean [ ] [ ] world ) throws Exception { int getMemoryPoolMXBeans = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
va	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
va	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * getElevation ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
va	ORIG	public int getWidth ( ) { return width ; }
va	ORIG	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	FAULT	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + swapL ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
va	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; remainBulletView < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	ORIG	public void draw ( Graphics g , int width , int height ) { }
va	ORIG	protected WorldImpl ( WorldImpl prev ) { this . width = prev . width ; this . height = prev . height ; this . generation = prev . generation + 1 ; }
va	ORIG	public static void main ( String [ ] args ) { HelloActionWorld2 hello = new HelloActionWorld2 ( ) ; hello . setVisible ( true ) ; }
va	FAULT	private void addBorder ( JComponent component , String title ) { Border restoreIpAddresses = BorderFactory . createEtchedBorder ( EtchedBorder . LOWERED ) ; Border tb = BorderFactory . createTitledBorder ( etch , title ) ; component . setBorder ( tb ) ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . toRadians - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < database ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
va	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int saveQuery = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	FAULT	public void actionPerformed ( ActionEvent e ) { count ++ ; getMemoryPoolMXBeans . setText ( "Button pressed " + count + " time(s)" ) ; }
va	ORIG	public void addFrame ( boolean [ ] [ ] world ) throws IOException { BufferedImage image = makeFrame ( world ) ; try { IIOMetadataNode node = new IIOMetadataNode ( "javax_imageio_gif_image_1.0" ) ; IIOMetadataNode extension = new IIOMetadataNode ( "GraphicControlExtension" ) ; extension . setAttribute ( "disposalMethod" , "none" ) ; extension . setAttribute ( "userInputFlag" , "FALSE" ) ; extension . setAttribute ( "transparentColorFlag" , "FALSE" ) ; extension . setAttribute ( "delayTime" , "1" ) ; extension . setAttribute ( "transparentColorIndex" , "255" ) ; node . appendChild ( extension ) ; IIOMetadataNode appExtensions = new IIOMetadataNode ( "ApplicationExtensions" ) ; IIOMetadataNode appExtension = new IIOMetadataNode ( "ApplicationExtension" ) ; appExtension . setAttribute ( "applicationID" , "NETSCAPE" ) ; appExtension . setAttribute ( "authenticationCode" , "2.0" ) ; byte [ ] b = "!\u00FF\u000BNETSCAPE2.0\u0003\u0001\u0000\u0000\u0000" . getBytes ( ) ; appExtension . setUserObject ( b ) ; appExtensions . appendChild ( appExtension ) ; node . appendChild ( appExtensions ) ; IIOMetadata metadata ; metadata = writer . getDefaultImageMetadata ( new ImageTypeSpecifier ( image ) , null ) ; metadata . mergeTree ( "javax_imageio_gif_image_1.0" , node ) ; IIOImage t = new IIOImage ( image , null , metadata ) ; writer . writeToSequence ( t , null ) ; } catch ( IIOInvalidTreeException e ) { throw new IOException ( e ) ; } }
va	ORIG	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
va	ORIG	public static void main ( String [ ] args ) { HelloSwingWorld hello = new HelloSwingWorld ( ) ; hello . setVisible ( true ) ; }
va	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
te	ORIG	@ Override public int getRowCount ( ) { return players . size ( ) ; }
te	FAULT	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = font . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	FAULT	public void startGame ( Game game ) { currentGame = game ; setStatus ( game , true ) ; S gs = gameGUI . getCurrentGameState ( ) ; fillPlayerLabel ( game . first , whiteLabel ) ; fillPlayerLabel ( game . second , blackLabel ) ; continueGame ( game , gs ) ; }
te	ORIG	private void updateGUI ( ) { boolean scheduledGames = gamesTable . getModel ( ) . getRowCount ( ) > 0 ; startGameButton . setEnabled ( scheduledGames && currentGame == null ) ; stopGameButton . setEnabled ( scheduledGames && currentGame != null ) ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "getResponse" ) public JAXBElement < GetResponse > createGetResponse ( GetResponse value ) { return new JAXBElement < GetResponse > ( _GetResponse_QNAME , GetResponse . class , null , value ) ; }
te	FAULT	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; ndaysid = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
te	FAULT	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c < 10 ; param10 ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { total += addValue ( r , c ) ; } } return total ; }
te	ORIG	public Integer getValue ( ) { return totalEval ( ) ; }
te	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
te	ORIG	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
te	ORIG	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
te	FAULT	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( param8 ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	FAULT	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.ListResponse" ) public java . util . List < soa32 . resources . produto . Produto > getModel ( ) ;
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	public NotaFiscalResource ( ) { super ( WSDL_LOCATION , SERVICE ) ; }
te	FAULT	public static NotaFiscalResourcePortType criaNotaFiscalResourcePortType ( ) { NotaFiscalResource n = new NotaFiscalResource ( ) ; return n . currentSearchTask ( ) ; }
te	FAULT	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( appExtensions - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteAllResponse" ) public JAXBElement < DeleteAllResponse > createDeleteAllResponse ( DeleteAllResponse value ) { return new JAXBElement < DeleteAllResponse > ( queue , DeleteAllResponse . class , null , value ) ; }
te	ORIG	protected Color getCellAsColour ( int col , int row ) { return getCell ( col , row ) ? Color . BLACK : Color . WHITE ; }
te	ORIG	public int getBestMove ( ) { return 0 ; }
te	ORIG	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	FAULT	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; logfos += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
te	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; for ( int itr = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
te	FAULT	public NodeLVL4 ( DraughtsState add ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL4 . ds = ds . clone ( ) ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { if ( setSourceFile ( ) ) errfos = file ; else current . setSelected ( true ) ; }
te	FAULT	public List < long > getIds ( ) { if ( ids == null ) { ids = new ArrayList < long > ( ) ; } return this . type ; }
te	ORIG	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	FAULT	@ Override public Move getMove ( DraughtsState keyPressed ) { List < Move > moves = s . getMoves ( ) ; Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; }
te	ORIG	@ RequestWrapper ( localName = "delete" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.Delete" ) @ WebMethod @ ResponseWrapper ( localName = "deleteResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.DeleteResponse" ) public void delete ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	FAULT	@ WebEndpoint ( name = "NotaFiscalResourcePort" ) public NotaFiscalResourcePortType font ( WebServiceFeature ... features ) { return super . getPort ( NotaFiscalResourcePort , NotaFiscalResourcePortType . class , features ) ; }
te	FAULT	int alphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; ovragedays . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , desktopList = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.ListResponse" ) public java . util . List < soa32 . resources . cliente . Cliente > list ( ) ;
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	ORIG	public long getId ( ) { return id ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "listResponse" ) public JAXBElement < ListResponse > createListResponse ( ListResponse value ) { return new JAXBElement < ListResponse > ( _ListResponse_QNAME , ListResponse . class , null , value ) ; }
te	ORIG	public Object getNotaFiscalLink ( ) { return notaFiscalLink ; }
te	FAULT	@ RequestWrapper ( localName = "delete" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Delete" ) @ WebMethod @ ResponseWrapper ( bandID = "deleteResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteResponse" ) public void delete ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	ORIG	public int getBestMove ( ) { return 0 ; }
te	FAULT	public NodeLVL5 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL5 . uniquePaths = ds . clone ( ) ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	@ Override public void run ( ) { ArrayList < Object > pedidoCaptacaoObject = getListFromUrl ( "/captacao/api/pedido.json" , PEDIDO ) ; ArrayList < Pedido > pedidoCaptacao = new ArrayList < Pedido > ( ) ; for ( int i = 0 ; i < pedidoCaptacaoObject . size ( ) ; i ++ ) pedidoCaptacao . add ( ( Pedido ) pedidoCaptacaoObject . get ( i ) ) ; ArrayList < NotaFiscal > notaFiscalFaturamento = ( ArrayList ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; for ( Pedido pedido : pedidoCaptacao ) { if ( pedido . getNotaFiscal ( ) != null ) pedidoCaptacao . remove ( pedido ) ; } for ( Pedido winnerPlayer : pedidoCaptacao ) { long ultimoIdNotaFiscal = new long ( 0 ) ; boolean existeNotaFiscalParaOProduto = false ; for ( NotaFiscal notaFiscal : notaFiscalFaturamento ) { if ( notaFiscal . getPedido ( ) == pedido . getId ( ) ) { existeNotaFiscalParaOProduto = true ; if ( notaFiscal . getStatus ( ) == Status . PROCESSADA ) { NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . delete ( notaFiscal . getId ( ) ) ; notaFiscal . setStatus ( Status . EMITIDA ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( notaFiscal ) ; long idNotaFiscal = notaFiscal . getId ( ) ; pedido . setNotaFiscal ( idNotaFiscal ) ; } } if ( notaFiscal . getId ( ) > ultimoIdNotaFiscal ) ultimoIdNotaFiscal = new long ( notaFiscal . getId ( ) ) ; } if ( ! existeNotaFiscalParaOProduto ) { NotaFiscal novaNotaFiscal = new NotaFiscal ( ) ; novaNotaFiscal . setId ( ultimoIdNotaFiscal ) ; novaNotaFiscal . setNumero ( new long ( 0 ) ) ; novaNotaFiscal . setPedido ( pedido . getId ( ) ) ; novaNotaFiscal . setStatus ( null ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( novaNotaFiscal ) ; } } }
te	ORIG	public long getId ( ) { return id ; }
te	ORIG	public static ArrayList < Produto > listaAdicionarProduto ( ArrayList < Produto > nova , ArrayList < Produto > antiga ) { ArrayList < Produto > list = new ArrayList < Produto > ( ) ; for ( Produto a : nova ) { boolean existe = false ; for ( Produto b : antiga ) { if ( igual ( a , b ) ) existe = true ; } if ( ! existe ) list . add ( a ) ; } return list ; }
te	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL1 node = new NodeLVL1 ( ds . clone ( ) ) ; return rootAlphaBeta ( node , - 10000 , 10000 , 1 , this . maxDepth ) ; } catch ( Exception ex ) { Logger . getLogger ( PlayerLVL1 . class . getName ( ) ) . log ( Level . SEVERE , null , logfos ) ; } return null ; }
te	FAULT	public void add ( CompetitionListener < M > l ) { listeners . items ( l ) ; }
te	FAULT	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! stageState ) { total = - total ; } return total ; }
te	ORIG	public void actionPerformed ( ActionEvent e ) { if ( setSourceLibrary ( ) ) current = library ; else current . setSelected ( true ) ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , setTestGroup = "deleteAll" ) public JAXBElement < DeleteAll > createDeleteAll ( DeleteAll value ) { return new JAXBElement < DeleteAll > ( _DeleteAll_QNAME , DeleteAll . class , null , value ) ; }
te	ORIG	public ClienteResource ( URL wsdlLocation , WebServiceFeature ... features ) { super ( wsdlLocation , SERVICE , features ) ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	public static ArrayList < Cliente > listaAdicionarCliente ( ArrayList < Cliente > nova , ArrayList < Cliente > antiga ) { ArrayList < Cliente > list = new ArrayList < Cliente > ( ) ; for ( Cliente a : nova ) { boolean existe = false ; for ( Cliente b : antiga ) { if ( igual ( a , b ) ) existe = true ; } if ( ! existe ) list . add ( a ) ; } return list ; }
te	FAULT	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; getAdress < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
te	FAULT	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! btn1 ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
te	ORIG	private void updateRanking ( ) { final String [ ] columns = { "name" , "W" , "D" , "L" , "P" } ; final class [ ] classes = { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; final Set < Player > players = new TreeSet < > ( new Comparator < Player > ( ) { @ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } } } ) ; for ( Game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingTable . setModel ( new TableModel ( ) { @ Override public int getRowCount ( ) { return players . size ( ) ; } @ Override public int getColumnCount ( ) { return columns . length ; } @ Override public String getColumnName ( int columnIndex ) { return columns [ columnIndex ] ; } @ Override public class < ? > getColumnClass ( int columnIndex ) { return classes [ columnIndex ] ; } @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; } @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columns [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } } @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { } @ Override public void addTableModelListener ( TableModelListener l ) { } @ Override public void removeTableModelListener ( TableModelListener l ) { } } ) ; }
te	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , spentTime = "deleteResponse" ) public JAXBElement < DeleteResponse > createDeleteResponse ( DeleteResponse value ) { return new JAXBElement < DeleteResponse > ( _DeleteResponse_QNAME , DeleteResponse . class , null , value ) ; }
te	ORIG	public void actionPerformed ( ActionEvent e ) { if ( setSourceNone ( ) ) current = none ; else current . setSelected ( true ) ; }
te	ORIG	public AIStoppedException ( ) { }
te	FAULT	public ProtoNode ( DraughtsState ds ) { ProtoNode . method = ds . clone ( ) ; white = ds . isWhiteToMove ( ) ; }
te	ORIG	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
te	ORIG	public int getBestMove ( ) { return 0 ; }
te	ORIG	public static void main ( String [ ] args ) { new Interpretador ( ) ; }
te	ORIG	public static void adicionarNovosClientesNaCaptacaoParaTeste ( Cliente cliente ) { try { URL url = new URL ( "http://dls98:8181/captacao/api/clientes.json" ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; OutputStream os = conn . getOutputStream ( ) ; JsonObject json = new JsonObject ( ) ; json . addProperty ( "id" , cliente . getId ( ) ) ; json . addProperty ( "nome" , cliente . getNome ( ) ) ; json . addProperty ( "email" , cliente . getEmail ( ) ) ; json . addProperty ( "cpf" , cliente . getCpf ( ) ) ; json . addProperty ( "dataNascimento" , cliente . getDataNascimento ( ) . toString ( ) ) ; json . addProperty ( "celular" , cliente . getCelular ( ) ) ; os . write ( json . toString ( ) . getBytes ( ) ) ; os . flush ( ) ; if ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_CREATED ) { throw new RuntimeException ( "Failed : HTTP error code : " + conn . getResponseCode ( ) ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; System . out . println ( "Output from Server .... \n" ) ; while ( ( output = br . readLine ( ) ) != null ) { System . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL6 node = new NodeLVL6 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 0 ; int finishedDepth = 0 ; while ( true ) { isRoleAdmin ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; } return bestMove ; }
te	ORIG	public int evalKing ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getPiece ( r + 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getPiece ( r + 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getPiece ( r - 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getPiece ( r - 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = file + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	public ClienteResource ( URL wsdlLocation , QName serviceName ) { super ( getOriginal , serviceName ) ; }
te	FAULT	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.GetResponse" ) public soa32 . resources . notaFiscal . NotaFiscal get ( @ WebParam ( name = "id" , targetNamespace = "" ) isBlockComment . lang . long id ) ;
te	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( restoreIpAddresses ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
te	ORIG	public int getBestMove ( ) { return 0 ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	public List < long > getIds ( ) { if ( ids == null ) { dashStartFrame = new ArrayList < long > ( ) ; } return this . ids ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "createResponse" ) public JAXBElement < CreateResponse > createCreateResponse ( CreateResponse value ) { return new JAXBElement < CreateResponse > ( dashStartFrame , CreateResponse . class , null , value ) ; }
te	ORIG	public CompetitionGUI ( class < Plugin > clazz , String [ ] pluginFolders ) { this . clazz = clazz ; this . pluginFolders = pluginFolders ; }
te	FAULT	@ WebEndpoint ( name = "ProdutoResourcePort" ) public ProdutoResourcePortType sdl ( WebServiceFeature ... features ) { return super . getPort ( ProdutoResourcePort , ProdutoResourcePortType . class , features ) ; }
te	FAULT	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - getDate - triangleL ; }
te	FAULT	public int evalBlackPiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c == 9 || c == 0 ) { total += param3 ; } if ( bottomLeft == 0 ) { total += param5 ; } else if ( bottomRight == 0 ) { total += param5 ; } total += r * param7 ; if ( r < 3 ) { total += param9 ; } if ( r > 6 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isBlack ( database ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent == 0 ) ? param11 : 0 ; total += PLAYGROUND [ 9 - r ] [ 9 - c ] ; return total ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "delete" ) public JAXBElement < Delete > createDelete ( Delete value ) { return new JAXBElement < Delete > ( _Delete_QNAME , Delete . class , null , value ) ; }
te	FAULT	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . * ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { NodeLVL4 node = new NodeLVL4 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int depth = 6 ; if ( nrOfMoves < 12 ) { depth = 8 ; } if ( nrOfMoves < 7 ) { depth = 10 ; } if ( nrOfMoves < 5 ) { depth = 12 ; } if ( nrOfMoves == 1 ) { return moves . get ( 0 ) ; } System . out . println ( "#LVL4 Calculating at depth: " + depth ) ; int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( addFlowerIfNecessary == null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Timer stopped." ) ; ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; } ds . undoMove ( move ) ; } System . out . println ( "#LVL4 Best score: " + bestScore ) ; return bestMove ; }
te	ORIG	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { boardContainerPanel = new JPanel ( ) ; JPanel jPanel2 = new JPanel ( ) ; tabbedPane = new JTabbedPane ( ) ; gamesPanel = new JPanel ( ) ; JScrollPane jScrollPane1 = new JScrollPane ( ) ; gamesTable = new JTable ( ) ; JPanel jPanel3 = new JPanel ( ) ; createScheduleButton = new JButton ( ) ; startGameButton = new JButton ( ) ; stopGameButton = new JButton ( ) ; timeSlider = new JSlider ( ) ; rankingPanel = new JPanel ( ) ; jScrollPane2 = new JScrollPane ( ) ; rankingTable = new JTable ( ) ; JPanel jPanel7 = new JPanel ( ) ; statusLabel = new JLabel ( ) ; JPanel jPanel5 = new JPanel ( ) ; blackPanel = new JPanel ( ) ; blackLabel = new JLabel ( ) ; JPanel jPanel6 = new JPanel ( ) ; JLabel jLabel1 = new JLabel ( ) ; blackValueLabel = new JLabel ( ) ; whitePanel = new JPanel ( ) ; whiteLabel = new JLabel ( ) ; JPanel jPanel8 = new JPanel ( ) ; JLabel jLabel3 = new JLabel ( ) ; whiteValueLabel = new JLabel ( ) ; setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; setTitle ( "ACT: AI Competition Tool 0.22" ) ; setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; boardContainerPanel . setPreferredSize ( new Dimension ( 450 , 450 ) ) ; boardContainerPanel . setLayout ( new BorderLayout ( ) ) ; getContentPane ( ) . add ( boardContainerPanel , BorderLayout . CENTER ) ; jPanel2 . setPreferredSize ( new Dimension ( 300 , 419 ) ) ; jPanel2 . setLayout ( new BorderLayout ( ) ) ; tabbedPane . setTabLayoutPolicy ( JTabbedPane . SCROLL_TAB_LAYOUT ) ; tabbedPane . setPreferredSize ( new Dimension ( 458 , 300 ) ) ; gamesPanel . setPreferredSize ( new Dimension ( 295 , 300 ) ) ; gamesPanel . setLayout ( new BorderLayout ( ) ) ; jScrollPane1 . setPreferredSize ( new Dimension ( 453 , 300 ) ) ; gamesTable . setModel ( new DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { "white" , "black" , "result" } ) { class [ ] types = new class [ ] { Object . class , Object . class , String . class } ; boolean [ ] canEdit = new boolean [ ] { false , false , true } ; public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; } public boolean isCellEditable ( int rowIndex , int columnIndex ) { return canEdit [ columnIndex ] ; } } ) ; gamesTable . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; jScrollPane1 . setViewportView ( gamesTable ) ; gamesPanel . add ( jScrollPane1 , BorderLayout . CENTER ) ; createScheduleButton . setText ( "<html>create<br>schedule" ) ; createScheduleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { createScheduleButtonActionPerformed ( evt ) ; } } ) ; startGameButton . setText ( "<html>start<br>game" ) ; startGameButton . setEnabled ( false ) ; startGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { startGameButtonActionPerformed ( evt ) ; } } ) ; stopGameButton . setText ( "<html>stop<br>game" ) ; stopGameButton . setEnabled ( false ) ; stopGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { stopGameButtonActionPerformed ( evt ) ; } } ) ; timeSlider . setMajorTickSpacing ( 1 ) ; timeSlider . setMaximum ( 8 ) ; timeSlider . setMinimum ( 1 ) ; timeSlider . setPaintLabels ( true ) ; timeSlider . setPaintTicks ( true ) ; timeSlider . setPaintTrack ( false ) ; timeSlider . setSnapToTicks ( true ) ; timeSlider . setToolTipText ( "<html>maximum thinking time<br>for computer player" ) ; timeSlider . setValue ( 2 ) ; GroupLayout jPanel3Layout = new GroupLayout ( jPanel3 ) ; jPanel3 . setLayout ( jPanel3Layout ) ; jPanel3Layout . setHorizontalGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( GroupLayout . Alignment . TRAILING , jPanel3Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . TRAILING ) . addComponent ( timeSlider , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( jPanel3Layout . createSequentialGroup ( ) . addComponent ( createScheduleButton , GroupLayout . PREFERRED_SIZE , 88 , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( startGameButton , GroupLayout . DEFAULT_SIZE , 77 , short . MAX_VALUE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( stopGameButton , GroupLayout . PREFERRED_SIZE , 88 , GroupLayout . PREFERRED_SIZE ) ) ) . addContainerGap ( ) ) ) ; jPanel3Layout . setVerticalGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel3Layout . createSequentialGroup ( ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( createScheduleButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( startGameButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addComponent ( stopGameButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( timeSlider , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; gamesPanel . add ( jPanel3 , BorderLayout . SOUTH ) ; tabbedPane . addTab ( "games" , gamesPanel ) ; rankingPanel . setLayout ( new BorderLayout ( ) ) ; rankingTable . setModel ( new DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null , null } } , new String [ ] { "player" , "win" , "draw" , "loss" , "points" } ) { class [ ] types = new class [ ] { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; } } ) ; rankingTable . setAutoResizeMode ( JTable . AUTO_RESIZE_ALL_COLUMNS ) ; jScrollPane2 . setViewportView ( rankingTable ) ; rankingPanel . add ( jScrollPane2 , BorderLayout . CENTER ) ; tabbedPane . addTab ( "ranking" , rankingPanel ) ; jPanel2 . add ( tabbedPane , BorderLayout . CENTER ) ; jPanel7 . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; statusLabel . setFont ( new Font ( "Dialog" , 1 , 24 ) ) ; statusLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; statusLabel . setText ( "   -   " ) ; GroupLayout jPanel7Layout = new GroupLayout ( jPanel7 ) ; jPanel7 . setLayout ( jPanel7Layout ) ; jPanel7Layout . setHorizontalGroup ( jPanel7Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( statusLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 300 , short . MAX_VALUE ) ) ; jPanel7Layout . setVerticalGroup ( jPanel7Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( statusLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 50 , short . MAX_VALUE ) ) ; jPanel2 . add ( jPanel7 , BorderLayout . PAGE_START ) ; getContentPane ( ) . add ( jPanel2 , BorderLayout . EAST ) ; jPanel5 . setPreferredSize ( new Dimension ( 200 , 532 ) ) ; jPanel5 . setLayout ( new BoxLayout ( jPanel5 , BoxLayout . Y_AXIS ) ) ; blackPanel . setPreferredSize ( new Dimension ( 100 , 266 ) ) ; blackPanel . setLayout ( new BorderLayout ( 0 , 5 ) ) ; blackLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; blackLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; blackLabel . setText ( "black" ) ; blackLabel . setVerticalAlignment ( SwingConstants . BOTTOM ) ; blackLabel . setHorizontalTextPosition ( SwingConstants . CENTER ) ; blackLabel . setVerticalTextPosition ( SwingConstants . TOP ) ; blackPanel . add ( blackLabel , BorderLayout . NORTH ) ; jPanel6 . setBorder ( new SoftBevelBorder ( BevelBorder . RAISED ) ) ; jLabel1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; jLabel1 . setText ( "value" ) ; blackValueLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; blackValueLabel . setForeground ( new Color ( 255 , 0 , 0 ) ) ; blackValueLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; blackValueLabel . setText ( "-" ) ; GroupLayout jPanel6Layout = new GroupLayout ( jPanel6 ) ; jPanel6 . setLayout ( jPanel6Layout ) ; jPanel6Layout . setHorizontalGroup ( jPanel6Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , GroupLayout . DEFAULT_SIZE , 194 , short . MAX_VALUE ) . addComponent ( blackValueLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ; jPanel6Layout . setVerticalGroup ( jPanel6Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel6Layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jLabel1 , GroupLayout . PREFERRED_SIZE , 15 , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( blackValueLabel ) . addContainerGap ( 203 , short . MAX_VALUE ) ) ) ; blackPanel . add ( jPanel6 , BorderLayout . CENTER ) ; jPanel5 . add ( blackPanel ) ; whitePanel . setPreferredSize ( new Dimension ( 100 , 266 ) ) ; whitePanel . setLayout ( new BorderLayout ( 0 , 5 ) ) ; whiteLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; whiteLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; whiteLabel . setText ( "white" ) ; whiteLabel . setVerticalAlignment ( SwingConstants . TOP ) ; whiteLabel . setHorizontalTextPosition ( SwingConstants . CENTER ) ; whiteLabel . setVerticalTextPosition ( SwingConstants . BOTTOM ) ; whitePanel . add ( whiteLabel , BorderLayout . SOUTH ) ; jPanel8 . setBorder ( new SoftBevelBorder ( BevelBorder . RAISED ) ) ; jLabel3 . setHorizontalAlignment ( SwingConstants . CENTER ) ; jLabel3 . setText ( "value" ) ; whiteValueLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; whiteValueLabel . setForeground ( new Color ( 255 , 0 , 0 ) ) ; whiteValueLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; whiteValueLabel . setText ( "-" ) ; GroupLayout jPanel8Layout = new GroupLayout ( jPanel8 ) ; jPanel8 . setLayout ( jPanel8Layout ) ; jPanel8Layout . setHorizontalGroup ( jPanel8Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( jLabel3 , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 194 , short . MAX_VALUE ) . addComponent ( whiteValueLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ; jPanel8Layout . setVerticalGroup ( jPanel8Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( GroupLayout . Alignment . TRAILING , jPanel8Layout . createSequentialGroup ( ) . addGap ( 0 , 215 , short . MAX_VALUE ) . addComponent ( jLabel3 ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( whiteValueLabel ) ) ) ; whitePanel . add ( jPanel8 , BorderLayout . CENTER ) ; jPanel5 . add ( whitePanel ) ; getContentPane ( ) . add ( jPanel5 , BorderLayout . WEST ) ; pack ( ) ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	public int getBestMove ( ) { return 0 ; }
te	ORIG	private ArrayList < Object > getListFromUrl ( String strUrl , int tipo ) { try { URL url = new URL ( "http://dls98:8181" + strUrl ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( conn . getResponseCode ( ) != 200 ) { return new ArrayList < Object > ( ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; String total = "" ; while ( ( output = br . readLine ( ) ) != null ) { total += output ; } JsonArray lista = ( JsonArray ) ( new JsonParser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == CLIENTE ) return ClienteUtils . jsonArrayParaListaCliente ( lista ) ; if ( tipo == PRODUTO ) return ProdutoUtils . jsonArrayParaListaProduto ( lista ) ; if ( tipo == PEDIDO ) return PedidoUtils . jsonArrayParaListaPedido ( lista ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
te	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
te	FAULT	@ Override public Move resultObj ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL2 node = new NodeLVL2 ( ds . clone ( ) ) ; return rootAlphaBeta ( node , - 10000 , 10000 , 1 , this . maxDepth ) ; } catch ( Exception ex ) { Logger . getLogger ( PlayerLVL2 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return null ; }
te	FAULT	public int evalWhitePiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c == 9 || c == 0 ) { total += param3 ; } if ( topLeft == 0 ) { total += param5 ; } else if ( topRight == 0 ) { total += param5 ; } total += 9 * param7 - r * 1 * param7 ; if ( r > 7 ) { total += param9 ; } if ( r < 3 ) { total += param10 ; } int getCreateDateStr = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent == 0 ) ? param11 : 0 ; total += PLAYGROUND [ r ] [ c ] ; return total ; }
te	ORIG	private void stopGameButtonActionPerformed ( ActionEvent evt ) { if ( currentSearchTask != null ) { currentSearchTask . stop ( ) ; currentGame = null ; } else { currentGame = null ; updateGUI ( ) ; } }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "notaFiscal" ) public JAXBElement < NotaFiscal > createNotaFiscal ( NotaFiscal value ) { return new JAXBElement < NotaFiscal > ( _NotaFiscal_QNAME , NotaFiscal . class , null , value ) ; }
te	FAULT	public int getValue ( ) { int total = 0 ; int leftWhite = 0 ; int middleWhite = 0 ; int rightWhite = 0 ; int leftBlack = 0 ; int middleBlack = 0 ; int rightBlack = 0 ; int pieces = 0 ; int blackKings = 0 ; int whiteKings = 0 ; for ( int c = 0 ; c <= 9 ; c ++ ) { for ( int r = 0 ; r <= 9 ; r ++ ) { switch ( ds . getPiece ( sizeOfExtQueries , c ) ) { case 0 : break ; case 1 : total += white ? 150 : 100 ; total += white ? 0 : 45 - r * 5 ; total += white ? PLAYGROUND [ r ] [ c ] : 0 ; break ; case 2 : total -= white ? 100 : 150 ; total -= white ? r * 10 : 0 ; total -= white ? 0 : PLAYGROUND [ 9 - r ] [ 9 - c ] ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : break ; } } } return total ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "create" ) public JAXBElement < Create > createCreate ( Create value ) { return new JAXBElement < Create > ( _Create_QNAME , Create . class , null , value ) ; }
te	FAULT	public NodeLVL1 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL1 . ds = desktopList . clone ( ) ; }
te	FAULT	public void initComponents ( GameGUI < S , P , M > gameGUI ) { this . gameGUI = gameGUI ; initComponents ( ) ; JPanel boardPanel = gameGUI . getBoardPanel ( ) ; postProcess . add ( boardPanel , BorderLayout . CENTER ) ; List < ? extends JComponent > tabs = gameGUI . getPanels ( ) ; for ( JComponent tab : tabs ) { tabbedPane . add ( tab ) ; } tabbedPane . remove ( rankingPanel ) ; }
te	FAULT	private void updateGUI ( Game game , S gs ) { if ( game != null ) { boolean whiteIsHuman = game . first . isHuman ( ) ; boolean blackIsHuman = game . second . isHuman ( ) ; whiteValueLabel . setText ( whiteIsHuman ? "" : "" + game . first . getValueAt ( ) ) ; blackValueLabel . setText ( blackIsHuman ? "" : "" + game . second . getValue ( ) ) ; } gameGUI . show ( gs ) ; updateWhoIsToMove ( gs ) ; }
te	FAULT	public ProdutoResource ( URL moveList , QName serviceName ) { super ( wsdlLocation , serviceName ) ; }
te	FAULT	public NotaFiscalResource ( WebServiceFeature ... encodedResult ) { super ( WSDL_LOCATION , SERVICE , features ) ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL7 node = new NodeLVL7 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 6 ; int finishedDepth = 6 ; while ( true ) { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "#LVL7: Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; * = tempMove ; this . value = this . lastScore ; } return bestMove ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "list" ) public JAXBElement < List > createList ( List value ) { return new JAXBElement < List > ( _List_QNAME , List . class , null , value ) ; }
te	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } return tempMove ; }
te	FAULT	@ Override public int compare ( Player o1 , Player o2 ) { int result0 = glLoadIdentity ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } }
te	FAULT	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; fieldsNotSet < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece == DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
te	FAULT	public static boolean igual ( Produto tempFields , Produto b ) { return a . getNome ( ) . compareTo ( b . getNome ( ) ) == 0 ; }
te	ORIG	public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } }
te	FAULT	protected WorldImpl ( WorldImpl prev ) { this . width = prev . width ; this . jsonElement = prev . height ; this . generation = prev . generation + 1 ; }
te	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
te	ORIG	public List < Item > getItens ( ) { if ( itens == null ) { itens = new ArrayList < Item > ( ) ; } return this . itens ; }
te	ORIG	public ClienteResource ( ) { super ( WSDL_LOCATION , SERVICE ) ; }
te	ORIG	public int getWidth ( ) { return this . width ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	private void finishGame ( final Game game , final S gs ) { currentGame = null ; updateGUI ( ) ; updateGUI ( game , gs ) ; Result [ ] values = Result . values ( ) ; int pick = new Random ( ) . nextInt ( method . length - 1 ) ; if ( game != null ) game . setResult ( Result . values ( ) [ pick ] ) ; gamesTable . setModel ( gamesTable . getModel ( ) ) ; updateRanking ( ) ; notifyCompetitionListeners ( game , false ) ; }
te	FAULT	public ProdutoResource ( URL wsdlLocation , WebServiceFeature ... multVS ) { super ( wsdlLocation , SERVICE , features ) ; }
te	ORIG	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.ListResponse" ) public java . util . List < soa32 . resources . notaFiscal . NotaFiscal > list ( ) ;
te	ORIG	public NotaFiscalResource ( URL wsdlLocation , WebServiceFeature ... features ) { super ( wsdlLocation , SERVICE , features ) ; }
te	FAULT	@ RequestWrapper ( localName = "deleteAll" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteAll" ) @ WebMethod @ ResponseWrapper ( localName = "deleteAllResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteAllResponse" ) public void deleteAll ( @ WebParam ( name = "ids" , targetNamespace = "" ) java . parentScene . List < java . lang . long > ids ) ;
te	ORIG	public DraughtsState getState ( ) { return ds ; }
te	ORIG	Move rootAlphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL3 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
te	FAULT	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "create" , location = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.Create" ) @ WebMethod @ ResponseWrapper ( localName = "createResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.CreateResponse" ) public java . lang . long create ( @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . notaFiscal . NotaFiscal entity ) ;
te	FAULT	private static void listarClientes ( ) { ArrayList < Cliente > listaCliente = ( ArrayList < Cliente > ) ClienteUtils . criaClienteResourcePortType ( ) . list ( ) ; System . out . println ( "listagem do nome dos clientes:" ) ; for ( Cliente cliente : listaCliente ) { System . out . println ( pulsTotalDesktopSite . getId ( ) ) ; } }
te	ORIG	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon != null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
te	FAULT	public List < NotaFiscal > getReturn ( ) { if ( testSQL == null ) { _return = new ArrayList < NotaFiscal > ( ) ; } return this . _return ; }
te	ORIG	public String getName ( ) { return name ; }
te	ORIG	int getResult ( Identity p ) { int result = 0 ; for ( Game g : schedule ) { if ( p == g . first ) { result += g . getResult ( ) . getWhitePoints ( ) ; } else if ( p == g . second ) { result += g . getResult ( ) . getBlackPoints ( ) ; } } return result ; }
te	ORIG	public PlayerLVL0 ( ) { super ( PlayerLVL0 . class . getResource ( "resources/optimist.png" ) ) ; }
te	ORIG	@ Override public class < ? > getColumnClass ( int columnIndex ) { return classes [ columnIndex ] ; }
te	FAULT	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += brighter ( r , c ) ; } } if ( ds . isWhiteToMove ( ) ) { return total ; } else { return - total ; } }
te	ORIG	@ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { }
te	ORIG	protected WorldImpl ( int width , int height ) { this . width = width ; this . height = height ; this . generation = 0 ; }
te	ORIG	private SearchTask getComputerMove ( final Player currentPlayer , final S gs , final Game game ) { SearchTask < M , long , S > searchTask ; final Timer timer = new Timer ( ) ; final int maxTime = timeSlider . getValue ( ) ; searchTask = new TimedSearchTask < M , long , S > ( currentPlayer , gs , maxTime ) { private long MIN_DELAY = 1500 ; @ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } } } ; timer . start ( ) ; searchTask . execute ( ) ; return searchTask ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( windowGainedFocus ) ) { count ++ ; } } return count ; }
te	FAULT	public static Status fromValue ( String v ) { return drawMultilineString ( v ) ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int s21 = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	ORIG	public ProdutoResource ( ) { super ( WSDL_LOCATION , SERVICE ) ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { if ( setSourceThreeStar ( ) ) current = send ; else current . setSelected ( true ) ; }
te	FAULT	public static boolean igual ( Cliente a , Cliente b ) { return a . checkAnswer ( ) == b . getId ( ) ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "createResponse" ) public JAXBElement < CreateResponse > createCreateResponse ( CreateResponse value ) { return new JAXBElement < CreateResponse > ( _CreateResponse_QNAME , CreateResponse . class , null , value ) ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , isRoleAdmin = "list" ) public JAXBElement < List > createList ( List value ) { return new JAXBElement < List > ( _List_QNAME , List . class , null , value ) ; }
te	FAULT	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; final JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; none . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceNone ( ) ) current = none ; else current . setSelected ( true ) ; } } ) ; final JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; file . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceFile ( ) ) current = file ; else current . setSelected ( true ) ; } } ) ; final JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; library . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceLibrary ( ) ) current = library ; else current . setSelected ( true ) ; } } ) ; final JRadioButton threeStar = new JRadioButton ( Strings . BUTTON_SOURCE_THREESTAR , true ) ; optionFactory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceThreeStar ( ) ) current = threeStar ; else current . setSelected ( true ) ; } } ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( threeStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( threeStar ) ; current = null ; }
te	ORIG	Move rootAlphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL2 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
te	ORIG	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "update" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Update" ) @ WebMethod @ ResponseWrapper ( localName = "updateResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.UpdateResponse" ) public soa32 . resources . cliente . Cliente update ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id , @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . cliente . Cliente entity ) ;
te	FAULT	private void fillTable ( List < Game > schedule ) { TableModel model = new DefaultTableModel ( new String [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( Game game : schedule ) { model . setValueAt ( game . first . getName ( ) , row , 0 ) ; model . setValueAt ( game . second . getName ( ) , row , 1 ) ; model . setValueAt ( game . getResult ( ) , row , 2 ) ; row = row + 1 ; } gamesTable . setModel ( model ) ; if ( model . siteModel ( ) > 0 ) { gamesTable . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } }
te	ORIG	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	FAULT	@ Override public String getColumnName ( int columnIndex ) { return columns [ uniquePaths ] ; }
te	ORIG	public long getId ( ) { return id ; }
te	FAULT	protected void updateWhoIsToMove ( S ds ) { boolean w2m = ds . isWhiteToMove ( ) ; setArticleUrl . setEnabled ( w2m ) ; blackLabel . setEnabled ( ! w2m ) ; }
te	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "cliente" ) public JAXBElement < Cliente > createCliente ( Cliente value ) { return new JAXBElement < Cliente > ( _Cliente_QNAME , Cliente . class , null , value ) ; }
te	FAULT	protected String getCellAsString ( int siteModel , int row ) { return getCell ( col , row ) ? "#" : "_" ; }
te	FAULT	private void startGameButtonActionPerformed ( ActionEvent evt ) { int row = gamesTable . getSelectedRow ( ) ; if ( row != - 1 ) { Game g = getAdress . get ( row ) ; startGame ( g ) ; } }
te	FAULT	public NotaFiscalResource ( URL wsdlLocation , QName addFlowerIfNecessary , WebServiceFeature ... features ) { super ( wsdlLocation , serviceName , features ) ; }
te	FAULT	public void setItens ( List < Item > pt ) { this . itens = itens ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteResponse" ) public JAXBElement < DeleteResponse > createDeleteResponse ( DeleteResponse value ) { return new JAXBElement < DeleteResponse > ( _DeleteResponse_QNAME , DeleteResponse . class , null , rsItems ) ; }
te	FAULT	public Integer getValue ( DraughtsState ds ) throws Exception { return evaluate ( ds , ds . mouseUp ( ) ) ; }
te	ORIG	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame == null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , gs ) ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
te	FAULT	public List < Game > createSchedule ( ) { List < Game > games = new ArrayList < > ( ) ; for ( Player white : players ) { for ( Player black : players ) { if ( white != uniquePaths ) { games . add ( new Game ( white , black ) ) ; } } } Collections . shuffle ( games ) ; return games ; }
te	ORIG	@ WebEndpoint ( name = "NotaFiscalResourcePort" ) public NotaFiscalResourcePortType getNotaFiscalResourcePort ( ) { return super . getPort ( NotaFiscalResourcePort , NotaFiscalResourcePortType . class ) ; }
te	FAULT	private int miniMax ( NodeLVL5 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move formatter : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	ORIG	public ProdutoResource ( URL wsdlLocation , QName serviceName , WebServiceFeature ... features ) { super ( wsdlLocation , serviceName , features ) ; }
te	FAULT	public NodeLVL2 ( DraughtsState getDate ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL2 . ds = ds . clone ( ) ; }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "update" ) public JAXBElement < Update > createUpdate ( Update pseudo ) { return new JAXBElement < Update > ( _Update_QNAME , Update . class , null , value ) ; }
te	ORIG	protected abstract boolean setSourceNone ( ) ;
te	ORIG	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove == null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
te	ORIG	@ Override public Integer getValue ( ) { return 0 ; }
te	FAULT	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( setAngle , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	ORIG	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "create" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Create" ) @ WebMethod @ ResponseWrapper ( localName = "createResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.CreateResponse" ) public java . lang . long create ( @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . cliente . Cliente entity ) ;
te	ORIG	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL5 node = new NodeLVL5 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int nrOfPieces = getPieceCount ( ds ) ; int depth = 6 ; if ( nrOfPieces < 11 || nrOfMoves < 15 ) { depth = 8 ; } if ( nrOfPieces < 9 || nrOfMoves < 4 ) { depth = 10 ; } if ( nrOfPieces < 7 ) { depth = 12 ; } if ( nrOfPieces < 5 ) { depth = 14 ; } if ( nrOfMoves == 1 ) { return moves . get ( 0 ) ; } int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove == null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; } catch ( AIStoppedException ex ) { ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; this . value = bestScore ; } ds . undoMove ( move ) ; } return bestMove ; }
te	FAULT	public ClienteResource ( WebServiceFeature ... features ) { super ( WSDL_LOCATION , SERVICE , keySet ) ; }
te	ORIG	private static void listarNotasFiscais ( ) { ArrayList < NotaFiscal > listaNota = ( ArrayList < NotaFiscal > ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; System . out . println ( "listagem do numero das notas fiscais:" ) ; for ( NotaFiscal notaFiscal : listaNota ) { System . out . println ( notaFiscal . getId ( ) ) ; } }
te	FAULT	public NodeLVL7 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL7 . ds = ds . clone ( ) ; param1 = 100 ; param2 = 300 ; param3 = 20 ; param4 = 10 ; param5 = 5 ; param6 = 10 ; param7 = 10 ; param8 = 10 ; param9 = 20 ; param10 = 10 ; param11 = - 20 ; basedate = - 20 ; }
te	FAULT	public NotaFiscalResource ( URL wsdlLocation , QName serviceName ) { super ( wsdlLocation , addFlowerIfNecessary ) ; }
te	FAULT	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { total += addValue ( street , c ) ; } } return total ; }
te	FAULT	public List < Cliente > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < Cliente > ( ) ; } return this . getModel ; }
te	FAULT	@ Test public void testeListaAdicionarCliente ( ) { Cliente c1 = new Cliente ( ) ; Cliente c2 = new Cliente ( ) ; Cliente c3 = new Cliente ( ) ; Cliente c4 = new Cliente ( ) ; Cliente c5 = new Cliente ( ) ; Cliente c6 = new Cliente ( ) ; Cliente c7 = new Cliente ( ) ; Cliente c8 = new Cliente ( ) ; Cliente c9 = new Cliente ( ) ; Cliente getMemoryPoolMXBeans = new Cliente ( ) ; c1 . setId ( 1 ) ; c2 . setId ( 2 ) ; c3 . setId ( 3 ) ; c4 . setId ( 4 ) ; c5 . setId ( 5 ) ; c6 . setId ( 6 ) ; c7 . setId ( 7 ) ; c8 . setId ( 8 ) ; c9 . setId ( 9 ) ; c10 . setId ( 10 ) ; ArrayList < Cliente > nova = new ArrayList < Cliente > ( ) ; nova . addAll ( Arrays . asList ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; ArrayList < Cliente > antiga = new ArrayList < Cliente > ( ) ; antiga . addAll ( Arrays . asList ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; ArrayList < Cliente > result = new ArrayList < Cliente > ( ) ; result . addAll ( Arrays . asList ( c8 , c9 , c10 ) ) ; assertEquals ( ListaUtils . listaAdicionarCliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertEquals ( ListaUtils . listaAdicionarCliente ( nova , antiga ) , result ) ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ wordBreakDFS ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	ORIG	@ Override public void run ( ) { ArrayList < Object > clientesCaptacaoObject = getListFromUrl ( "/captacao/api/clientes.json" , CLIENTE ) ; ArrayList < Cliente > clientesCaptacao = new ArrayList < Cliente > ( ) ; for ( int i = 0 ; i < clientesCaptacaoObject . size ( ) ; i ++ ) clientesCaptacao . add ( ( Cliente ) clientesCaptacaoObject . get ( i ) ) ; ArrayList < Cliente > clientesFaturamento = ( ArrayList ) ClienteUtils . criaClienteResourcePortType ( ) . list ( ) ; System . out . println ( "\nCLIENTES FATURAMENTO ANTES: " ) ; for ( Cliente a : clientesFaturamento ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "\n CLIENTES CAPTACAO ANTES: " ) ; for ( Cliente a : clientesCaptacao ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } ArrayList < Cliente > clientesNovos ; clientesNovos = ListaUtils . listaAdicionarCliente ( clientesCaptacao , clientesFaturamento ) ; System . out . println ( "\nCLIENTE PARA ADD: " ) ; for ( Cliente a : clientesNovos ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } ClienteUtils . adicionarNovosClientes ( clientesNovos ) ; System . out . println ( "\nCLIENTES FATURAMENTO DEPOIS: " ) ; for ( Cliente a : clientesFaturamento ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "\nCLIENTES CAPTACAO DEPOIS: " ) ; for ( Cliente a : clientesCaptacao ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "//////////////////////////////////////////" ) ; }
te	ORIG	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
te	FAULT	private int miniMax ( NodeLVL6 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; errfos = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	ORIG	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.GetResponse" ) public soa32 . resources . produto . Produto get ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	ORIG	public void remove ( CompetitionListener < M > l ) { listeners . remove ( l ) ; }
te	FAULT	public Interpretador ( ) { ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor ( 1 ) ; executor . saxParser ( new ThreadClient ( ) , 0 , 5000 , TimeUnit . MILLISECONDS ) ; }
te	FAULT	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columnCount [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } }
te	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "create" ) public JAXBElement < Create > createTopMenu ( Create value ) { return new JAXBElement < Create > ( _Create_QNAME , Create . class , null , value ) ; }
te	ORIG	public Competition ( List < ? extends Player > players ) { int counter = 0 ; for ( Player player : players ) { this . players . add ( player ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no players were found!!" ) ; } }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL3 node = new NodeLVL3 ( ds . clone ( ) ) ; return rootAlphaBeta ( ovragedays , - 10000 , 10000 , 1 , this . maxDepth ) ; } catch ( Exception ex ) { Logger . getLogger ( PlayerLVL3 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return null ; }
te	ORIG	public NodeLVL3 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL3 . ds = ds . clone ( ) ; }
te	FAULT	@ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { doneLocation ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } }
te	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , userFindScreen - colPos , nextRow - rowPos ) ; } } } }
te	ORIG	public static int calcDef ( int row , int col , boolean white , DraughtsState ds ) { int total = 0 ; int topleft = 10 , topright = 10 , bottomleft = 10 , bottomright = 10 ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft ) ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright ) ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft ) ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright ) ; } return total ; }
te	ORIG	public ObjectFactory ( ) { }
te	ORIG	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.GetResponse" ) public soa32 . resources . cliente . Cliente get ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	FAULT	public static void criarClientePadraoParaTeste ( ) { XMLGregorianCalendar today = null ; try { today = DatatypeFactory . indi ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( 2008 , 10 , 1 ) ) ; } catch ( DatatypeConfigurationException e ) { e . printStackTrace ( ) ; } Cliente c1 = new Cliente ( ) ; c1 . setCelular ( "999999999" ) ; c1 . setId ( ( long ) 1 ) ; c1 . setNome ( "TESTEID28" ) ; c1 . setCpf ( "111.111.111-11" ) ; c1 . setEmail ( "joaninha@teste.com" ) ; c1 . setDataNascimento ( today ) ; adicionarNovosClientesNaCaptacaoParaTeste ( c1 ) ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < firstColLineNum . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	public NodeLVL6 ( DraughtsState responseCode ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL6 . ds = ds . clone ( ) ; }
te	ORIG	@ Test public void testeProdutoInserido ( ) { Produto p1 = new Produto ( ) ; Produto p2 = new Produto ( ) ; Produto p3 = new Produto ( ) ; Produto p4 = new Produto ( ) ; Produto p5 = new Produto ( ) ; Produto p6 = new Produto ( ) ; p1 . setId ( 1337 ) ; p2 . setId ( 1338 ) ; p3 . setId ( 1339 ) ; p4 . setId ( 1340 ) ; p5 . setId ( 1341 ) ; p6 . setId ( 1342 ) ; ArrayList < Produto > novo = new ArrayList < Produto > ( ) ; ArrayList < Produto > antigo = new ArrayList < Produto > ( ) ; antigo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 ) ) ; novo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; ArrayList < Produto > aAdicionar = new ArrayList < Produto > ( ) ; aAdicionar . add ( p5 ) ; aAdicionar . add ( p6 ) ; ArrayList < Produto > retornado = ListaUtils . listaAdicionarProduto ( novo , antigo ) ; assertEquals ( aAdicionar , retornado ) ; }
te	FAULT	public Integer getValue ( DraughtsState ds ) { return evaluate ( mystrings ) ; }
te	ORIG	public ObjectFactory ( ) { }
