tr	IDF	public Image getSmallerImage ( Image image , float scale ) { float f_invScale = 1 / scale ; int invScale = ( int ) f_invScale ; AffineTransform transform = new AffineTransform ( ) ; transform . scale ( scale , scale ) ; Image newImage = gc . createCompatibleImage ( image . getWidth ( null ) / invScale , image . getHeight ( null ) / invScale , Transparency . BITMASK ) ; Graphics2D g = ( Graphics2D ) newImage . getGraphics ( ) ; g . drawImage ( image , transform , null ) ; g . dispose ( ) ; return newImage ; }
tr	KEY	public void print ( ) ;
tr	KEY	public int getWorstHole ( ) { return worstHole ; }
tr	KEY	public FerramentaChamado ( ) { }
tr	KEY	public int getValor ( ) { return tipoPeca . getValor ( ) ; }
tr	KEY	public UpdateResult ( ) { this ( new ArrayList < > ( ) , new ArrayList < > ( ) ) ; }
tr	IDF	protected abstract void notifyDeviceListenersSetXXXVector ( INDIDevice device , Element xml ) ;
tr	KEY	public void printDescription ( ) { return ; }
tr	KEY	public long getId ( ) { return id ; }
tr	KEY	public void setDx ( int dx ) { this . dx = dx ; }
tr	KEY	protected void initialize ( ) { }
tr	KEY	@ Override public void onDartMissedPressed ( ) { }
tr	IDF	public static int getShiChenByHour ( int hour ) { if ( hour == 23 || hour == 24 || hour == 0 ) return 0 ; for ( int i = 1 ; i < startHour . length ; i ++ ) { if ( hour >= startHour [ i ] && hour < endHour [ i ] ) { return i ; } } return - 1 ; }
tr	KEY	public int getId ( ) { return id ; }
tr	KEY	public void run ( ) { new InterfazEmpleado ( ) . setVisible ( true ) ; }
tr	IDF	public int getWidth ( ) { Graphics context = this . getContext ( ) ; return context . getFontMetrics ( this . getFont ( ) ) . stringWidth ( this . text ) ; }
tr	IDF	private void reset ( Game game ) { BoardState bs = new BoardState ( 10 , 10 ) ; if ( beginStateCheckBox . isSelected ( ) ) { bs = new BoardState ( 10 , 10 ) ; bs . setBegin ( ) ; } else { bs = ( BoardState ) boardPanel . getBoard ( ) . getBoardState ( ) ; } reset ( game , bs , true ) ; }
tr	IDF	public void keyReleased ( KeyEvent e ) { if ( currentGame != null ) { userReleasedKey ( e ) ; } }
tr	KEY	float getAngle ( ) ;
tr	IDF	private int miniMax ( NodeLVL7 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	KEY	public RoomDAOImpl ( ) { super ( Room . class ) ; }
tr	KEY	public boolean isCellEditable ( int x , int y ) { return false ; }
tr	KEY	@ AfterClass public static void tearDownClass ( ) throws Exception { }
tr	KEY	public void setHeaderWrite ( boolean headerWrite ) { this . headerWrite = headerWrite ; }
tr	IDF	public double objectArea ( ABObject ob ) { double area = 0 ; if ( ob . shape == ABShape . Circle ) { Circle c = ( Circle ) ob ; area = c . area ; } else if ( ob . shape == ABShape . Rect ) { Rect r = ( Rect ) ob ; area = r . area ; } else { Poly p = ( Poly ) ob ; area = p . area ; } return area ; }
tr	KEY	public CMd5Hash ( ) { }
tr	IDF	@ Override public void visit ( Block block ) { System . out . print ( block + ":" ) ; block . first . accept ( this ) ; System . out . print (   ) ; block . second . accept ( this ) ; }
tr	KEY	@ Override public void run ( ) { new TelaLogin ( null , true ) . setVisible ( true ) ; }
tr	IDF	public Model ( Entity ent ) { fields . put ( "id" , ent . getId ( ) ) ; fields . put ( "model" , ent . getModel ( ) ) ; }
tr	IDF	public double update ( DependencyInstance gold , DependencyInstance pred , LocalFeatureData lfd , GlobalFeatureData gfd , SRLFeatureData sfd , int updCnt , int offset ) { int N = gold . length ; int [ ] actDeps = gold . heads ; int [ ] actLabs = gold . deplbids ; int [ ] predDeps = pred . heads ; int [ ] predLabs = pred . deplbids ; double Fi = getHammingDis ( actDeps , actLabs , predDeps , predLabs ) + getSRLCost ( gold , pred ) ; if ( Fi == 0 ) return 0.0 ; FeatureVector dt = lfd . getFeatureDifference ( gold , pred ) ; dt . addEntries ( gfd . getFeatureDifference ( gold , pred ) ) ; FeatureVector dtl = new FeatureVector ( size ) ; if ( options . learnLabel ) { dtl = lfd . getLabeledFeatureDifference ( gold , pred ) ; } FeatureVector dts = sfd . getFeatureDifference ( gold , pred ) ; double loss = - dt . dotProduct ( params ) * gamma - dtl . dotProduct ( params ) * gammaLabel - dts . dotProduct ( params2 ) * gamma2 + Fi ; double l2norm = dt . Squaredl2NormUnsafe ( ) * gamma * gamma + dtl . Squaredl2NormUnsafe ( ) * gammaLabel * gammaLabel + dts . Squaredl2NormUnsafe ( ) * gamma2 * gamma2 ; { for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dUk = getdU ( k , lfd , actDeps , predDeps ) ; l2norm += dUk . Squaredl2NormUnsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; loss -= dUk . dotProduct ( U [ k ] ) * ( 1 - gamma ) ; dU [ k ] = dUk ; } } { for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dVk = getdV ( k , lfd , actDeps , predDeps ) ; l2norm += dVk . Squaredl2NormUnsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; dV [ k ] = dVk ; } } { for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dWk = getdW ( k , lfd , actDeps , predDeps ) ; l2norm += dWk . Squaredl2NormUnsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; dW [ k ] = dWk ; } } for ( int k = 0 ; k < rank2 ; ++ k ) { FeatureVector dUk = getdU2 ( k , sfd , gold , pred ) ; FeatureVector dVk = getdV2 ( k , sfd , gold , pred ) ; FeatureVector dWk = getdW2 ( k , sfd , gold , pred ) ; l2norm += dUk . Squaredl2NormUnsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; l2norm += dVk . Squaredl2NormUnsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; l2norm += dWk . Squaredl2NormUnsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; loss -= dUk . dotProduct ( U2 [ k ] ) * ( 1 - gamma2 ) ; dU2 [ k ] = dUk ; dV2 [ k ] = dVk ; dW2 [ k ] = dWk ; } double alpha = loss / l2norm ; alpha = Math . min ( synC , alpha ) ; if ( alpha > 0 ) { { double coeff = alpha * gamma , coeff2 = coeff * updCnt ; for ( int i = 0 , K = dt . size ( ) ; i < K ; ++ i ) { int x = dt . x ( i ) ; double z = dt . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } coeff = alpha * gammaLabel ; coeff2 = coeff * updCnt ; for ( int i = 0 , K = dtl . size ( ) ; i < K ; ++ i ) { int x = dtl . x ( i ) ; double z = dtl . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } coeff = alpha * gamma2 ; coeff2 = coeff * updCnt ; for ( int i = 0 , K = dts . size ( ) ; i < K ; ++ i ) { int x = dts . x ( i ) ; double z = dts . value ( i ) ; params2 [ x ] += coeff * z ; total2 [ x ] += coeff2 * z ; } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dUk = dU [ k ] ; for ( int i = 0 , K = dUk . size ( ) ; i < K ; ++ i ) { int x = dUk . x ( i ) ; double z = dUk . value ( i ) ; U [ k ] [ x ] += coeff * z ; totalU [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dVk = dV [ k ] ; for ( int i = 0 , K = dVk . size ( ) ; i < K ; ++ i ) { int x = dVk . x ( i ) ; double z = dVk . value ( i ) ; V [ k ] [ x ] += coeff * z ; totalV [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank ; ++ k ) { FeatureVector dWk = dW [ k ] ; for ( int i = 0 , K = dWk . size ( ) ; i < K ; ++ i ) { int x = dWk . x ( i ) ; double z = dWk . value ( i ) ; W [ k ] [ x ] += coeff * z ; totalW [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { FeatureVector dUk = dU2 [ k ] ; for ( int i = 0 , K = dUk . size ( ) ; i < K ; ++ i ) { int x = dUk . x ( i ) ; double z = dUk . value ( i ) ; U2 [ k ] [ x ] += coeff * z ; totalU2 [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { FeatureVector dVk = dV2 [ k ] ; for ( int i = 0 , K = dVk . size ( ) ; i < K ; ++ i ) { int x = dVk . x ( i ) ; double z = dVk . value ( i ) ; V2 [ k ] [ x ] += coeff * z ; totalV2 [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updCnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { FeatureVector dWk = dW2 [ k ] ; for ( int i = 0 , K = dWk . size ( ) ; i < K ; ++ i ) { int x = dWk . x ( i ) ; double z = dWk . value ( i ) ; W2 [ k ] [ x ] += coeff * z ; totalW2 [ k ] [ x ] += coeff2 * z ; } } } } return loss ; }
tr	IDF	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	IDF	public static void installClipboardSupport ( JComponent target ) { Object oldActionBinding = target . getInputMap ( ) . get ( KEYSTROKE_CONTROL_V ) ; final Action oldAction = target . getActionMap ( ) . get ( oldActionBinding ) ; target . getInputMap ( ) . put ( KEYSTROKE_CONTROL_V , KEY_PASTE_FROM_CLIPBOARD ) ; target . getActionMap ( ) . put ( KEY_PASTE_FROM_CLIPBOARD , new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Transferable contents = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . getContents ( this ) ; if ( contents != null ) { EveIPHDualInput input = new EveIPHDualInput ( ) ; if ( input . canAccept ( contents ) ) { if ( input . parse ( contents ) ) { MineralInput mineralInput = input . getMineralInput ( ) ; System . out . println ( mineralInput . toString ( ) ) ; MineralClipboardInputListener [ ] listeners = getDefault ( ) . listenerList . getListeners ( MineralClipboardInputListener . class ) ; for ( MineralClipboardInputListener listener : listeners ) { listener . mineralInput ( mineralInput ) ; } return ; } } } if ( oldAction != null ) { System . out . println ( "Executing old action" ) ; oldAction . actionPerformed ( e ) ; } } } ) ; }
tr	KEY	public void cut ( ) { }
tr	IDF	public static HashMap < String , String > parseInfoResponse ( String response ) throws Exception { if ( response . length ( ) < 5 ) throw new Exception ( "Invalid server response. Must be at least 5 characters length" ) ; if ( response . substring ( 0 , 5 ) . toUpperCase ( ) . equals ( "ERROR" ) ) throw new Exception ( "Error receiving userlist." ) ; String [ ] parts = response . split ( "\\s" ) ; if ( parts . length < 2 ) throw new Exception ( "Invalid server response. Unable to parse." ) ; String command = parts [ 0 ] ; int count = Integer . valueOf ( parts [ 1 ] ) ; HashMap < String , String > userList = new HashMap < String , String > ( ) ; int base = 2 ; for ( int i = 0 ; i < count ; i ++ ) { if ( parts . length < base + 1 ) throw new Exception ( "Invalid server response. Odd amount of paramater." ) ; String host = parts [ base ] ; String username = parts [ base + 1 ] ; userList . put ( host , username ) ; base += 2 ; } return userList ; }
tr	IDF	public void setLayer ( String layer ) { this . layer = layer ; }
tr	IDF	@ Override protected String getXMLPropertyDefinitionInit ( ) { String xml = "<defLightVector device=\"" + getDriver ( ) . getName ( ) + "\" name=\"" + getName ( ) + "\" label=\"" + getLabel ( ) + "\" group=\"" + getGroup ( ) + "\" state=\"" + Constants . getPropertyStateAsString ( getState ( ) ) + "\" timestamp=\"" + INDIDateFormat . getCurrentTimestamp ( ) + "\">" ; return xml ; }
tr	KEY	public boolean isStarted ( ) { return started ; }
tr	IDF	public BoardController ( ) { _pieceNameColumn = new TableColumn < Piece , String > ( "Piece Name" ) ; _pieceNameColumn . setCellValueFactory ( new PropertyValueFactory < Piece , String > ( "Piece Name" ) ) ; _pieceTypeColumn = new TableColumn < Piece , String > ( "Piece Type" ) ; _pieceTypeColumn . setCellValueFactory ( new PropertyValueFactory < Piece , String > ( "Piece Type" ) ) ; _pieces = FXCollections . observableArrayList ( ) ; _pieceButtons = new ArrayList < PieceButton > ( ) ; }
tr	IDF	@ Override public void init ( ) { int num = this . getNumSquare ( ) ; Point p = new Point ( 2 , 0 ) ; sq [ 0 ] . setSqCoordinate ( p ) ; sq [ 0 ] . setColor ( this . getColor ( ) ) ; for ( int i = 0 ; i < num - 1 ; i ++ ) { p = new Point ( i , - 1 ) ; sq [ i + 1 ] . setSqCoordinate ( p ) ; sq [ i + 1 ] . setColor ( this . getColor ( ) ) ; } }
tr	KEY	public static void setLifeDegenSpeed ( int value ) { LIFE_DEGEN_SPEED = value ; }
tr	KEY	public double getValue ( ) { return value ; }
tr	KEY	public Matrix getInput ( ) { if ( source != null ) return source . getOutput ( ) ; else if ( dic != null ) return dic . getInput ( ) ; return null ; }
tr	IDF	public Object visitIntTree ( AST t ) { decorate ( t , intTree ) ; return intTree ; }
tr	KEY	public int getTotalLargeTime ( ) { return convertTime ( totalLargeTime ) ; }
tr	KEY	public ChampDeBataille getChampDeBataille ( ) { return this . champ_de_bataille ; }
tr	KEY	abstract public void render ( ) ;
tr	IDF	public boolean updateStatus ( Map < String , Object > param ) { boolean flg = false ; try { sqlMapClient . update ( SqlMap . USER_UPDATE_STATUS , param ) ; flg = true ; } catch ( Exception e ) { log . error ( "\u66F4\u65B0\u7528\u6237\u767B\u5F55\u72B6\u6001\u5931\u8D25" ) ; e . printStackTrace ( ) ; } return flg ; }
tr	IDF	public void setConfigService ( ConfigService configService ) { this . configService = configService ; }
tr	IDF	@ Override public void setPingTime ( long nPing ) { ping = nPing ; }
tr	KEY	public void startTurn ( ) { this . currentTurn = new Turn ( ) ; this . turns . add ( this . currentTurn ) ; }
tr	IDF	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i == j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	IDF	@ SkipValidation public String delete ( ) { if ( electiveId != null ) { electiveService . deleteElective ( electiveId ) ; return SUCCESS ; } return ERROR ; }
tr	IDF	private boolean equals ( Object subtree1 , int base1 , Object subtree2 , int base2 , int lo , int hi ) { if ( ( subtree1 == subtree2 && base1 == base2 ) || lo == hi ) return true ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) { Object [ ] ary1 = ( Object [ ] ) subtree1 , ary2 = ( Object [ ] ) subtree2 ; for ( int i = lo ; i < hi ; ++ i ) { Object key1 = ary1 [ i - base1 ] , key2 = ary2 [ i - base2 ] ; if ( ! eql ( key1 , key2 ) ) return false ; int nkeys1 = ary1 . length >> 1 , nkeys2 = ary2 . length >> 1 ; Object val1 = ary1 [ i - base1 + nkeys1 ] ; Object val2 = ary2 [ i - base2 + nkeys2 ] ; if ( ! eql ( val1 , val2 ) ) return false ; } return true ; } else return equals ( subtree2 , base2 , subtree1 , base1 , lo , hi ) ; } else { Node node1 = ( Node ) subtree1 ; Object left1 = node1 . left ; int l1size = treeSize ( left1 ) ; int new_hi = base1 + l1size ; RankTrimResult rtr1 = rankTrim ( left1 , base1 , lo , new_hi ) ; RankTrimResult rtr2 = rankTrim ( subtree2 , base2 , lo , new_hi ) ; if ( ! equals ( rtr1 . subtree , rtr1 . base , rtr2 . subtree , rtr2 . base , lo , new_hi ) ) return false ; else { Object key1 = node1 . key ; Object val1 = node1 . value ; Entry ent2 = rankEntry ( subtree2 , new_hi - base2 ) ; if ( ! equivEquals ( key1 , ent2 . key ) ) return false ; else if ( ! ( key1 instanceof EquivalentMap ) && ! eql ( val1 , ent2 . value ) ) return false ; else { int key1_size = keySize ( key1 ) ; int new_lo = base1 + l1size + key1_size ; RankTrimResult rtr3 = rankTrim ( node1 . right , new_lo , new_lo , hi ) ; RankTrimResult rtr4 = rankTrim ( subtree2 , base2 , new_lo , hi ) ; return equals ( rtr3 . subtree , rtr3 . base , rtr4 . subtree , rtr4 . base , new_lo , hi ) ; } } } }
tr	IDF	public Playlist ( String name ) { _name = name ; _playlist = new ArrayList < Song > ( ) ; _index = 0 ; }
tr	IDF	public LineType getLast ( ) { return lines . get ( size ( ) - 1 ) ; }
tr	IDF	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int j = 0 ; j < 3 ; j ++ ) { double temp = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) { temp = temp + matrix [ j ] [ k ] * src [ k ] ; } dst [ j ] = temp + matrix [ j ] [ 3 ] ; } }
tr	IDF	@ Override public Map < String , ColumnDefinition > getColumnDefinitions ( ) { return Collections . unmodifiableMap ( columnDefinitions ) ; }
tr	IDF	HousingType ( int id ) { this . id = id ; }
tr	KEY	public void setSpecular ( double [ ] specular ) { this . specular = specular ; }
tr	KEY	public void setDisponible ( boolean disponible ) { this . disponible = disponible ; }
tr	KEY	public GetGroupsResponse createGetGroupsResponse ( ) { return new GetGroupsResponse ( ) ; }
tr	IDF	private static void showExhaustiveGraphInGraphviz ( RequirementGraph req_model , int visualization ) throws IOException { String graph = "digraph G {\n" + "rankdir = BT;\n" ; for ( SecurityGoal sg : req_model . getSg_elem ( ) ) { String temp_graph = "" ; if ( sg . isCriticality ( ) ) { temp_graph += "sg_" + sg . getNameForShow ( ) + "[shape=ellipse  width=2  height=1.5  fixedsize = true  fontname=\"Helvetica-Bold\"  style = filled  color = red];\n" ; } else if ( sg . isNon_deterministic ( ) ) { temp_graph += "sg_" + sg . getNameForShow ( ) + "[shape=ellipse  fontname=\"Helvetica-Bold\"  style = filled  color = green];\n" ; } else { temp_graph += "sg_" + sg . getNameForShow ( ) + "[shape=ellipse  width=2  height=1.5  fixedsize = true  fontname=\"Helvetica-Bold\"" ; if ( sg . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { temp_graph += "  style = filled  color=blue" ; } temp_graph += "];\n" ; } if ( visualization != 2 ) { graph += temp_graph ; } else if ( sg . isCriticality ( ) || sg . getRemark ( ) . equals ( InfoEnum . ElementRemark . TOPSG . name ( ) ) || sg . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { graph += temp_graph ; } } for ( RequirementLink rl : req_model . getSg_links ( ) ) { String temp_graph = "" ; SecurityGoal sg_source = ( SecurityGoal ) rl . getSource ( ) ; SecurityGoal sg_target = ( SecurityGoal ) rl . getTarget ( ) ; temp_graph += "sg_" + sg_source . getNameForShow ( ) + " -> " + "sg_" + sg_target . getNameForShow ( ) ; if ( rl . refine_type . equals ( InfoEnum . RefineType . ATTRIBUTE . name ( ) ) ) { temp_graph += "[label=\"S\"" ; } else if ( rl . refine_type . equals ( InfoEnum . RefineType . ASSET . name ( ) ) ) { temp_graph += "[label=\"A\"" ; } else if ( rl . refine_type . equals ( InfoEnum . RefineType . INTERVAL . name ( ) ) ) { temp_graph += "[label=\"I\"" ; } else { CommandPanel . logger . severe ( "Refinement type of the graph has problems." ) ; } if ( rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { temp_graph += "  penwidth = 2.5  color=blue" ; } temp_graph += "];\n" ; if ( visualization != 2 ) { graph += temp_graph ; } else if ( rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { graph += temp_graph ; } else if ( ( ( SecurityGoal ) rl . getSource ( ) ) . isCriticality ( ) && ( ( SecurityGoal ) rl . getTarget ( ) ) . isCriticality ( ) ) { graph += temp_graph ; } } graph += "}" ; Func . writeFile ( InfoEnum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv" , graph , false ) ; }
tr	IDF	@ Override public String createTableSql ( ) { return CreateSQL ; }
tr	KEY	public abstract void handleCollsion ( Entity entity ) ;
tr	IDF	private Bond ( Builder b ) { this . years = b . years ; this . id = b . id ; }
tr	IDF	public Builder location ( String city ) { this . city = city ; return this ; }
tr	IDF	@ Override public String getColumnName ( int index ) { return header [ index ] ; }
tr	KEY	public void setRated ( boolean rated ) { this . rated = rated ; }
tr	IDF	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { this . main . hideView ( Main . view . Payment ) ; this . main . showView ( Main . view . PaymentCheck ) ; }
tr	IDF	private static void createProduct ( ) { ProductUI productMenu = new ProductUI ( ) ; ProductService productService = new ProductService ( new ProductDAO ( ) ) ; try { ProductModel newProduct = productMenu . createProduct ( ) ; newProduct = productService . createProduct ( newProduct ) ; productMenu . showCreateSuccess ( newProduct ) ; } catch ( WebshopAppException e ) { ExceptionUI . printException ( e ) ; } }
tr	KEY	public char getTestChr ( ) { return testChr ; }
tr	KEY	public void startThread ( ) { this . thread = new Thread ( this ) ; thread . start ( ) ; }
tr	IDF	private static ContactRelation CheckContactAngular ( ABObject obs1 , ABObject obs2 ) { if ( obs1 . shape != ABShape . Circle && obs2 . shape != ABShape . Circle ) { Rect ob1 = ( Rect ) obs1 ; Rect ob2 = ( Rect ) obs2 ; int [ ] ob1_x = null ; int [ ] ob2_x = null ; int [ ] ob1_y = null ; int [ ] ob2_y = null ; List < Point > points1 = new ArrayList < Point > ( ) ; List < Point > points2 = new ArrayList < Point > ( ) ; if ( ob1 . IsAngular ( ) && ob2 . IsAngular ( ) ) { ob1_x = ob1 . p . xpoints ; ob2_x = ob2 . p . xpoints ; ob1_y = ob1 . p . ypoints ; ob2_y = ob2 . p . ypoints ; } else if ( ob1 . IsAngular ( ) && ! ob2 . IsAngular ( ) ) { ob1_x = ob1 . p . xpoints ; ob1_y = ob1 . p . ypoints ; ob2_x = ob2 . GetBoundX ( ) ; ob2_y = ob2 . GetBoundY ( ) ; } else if ( ! ob1 . IsAngular ( ) && ob2 . IsAngular ( ) ) { ob1_x = ob1 . GetBoundX ( ) ; ob1_y = ob1 . GetBoundY ( ) ; ob2_x = ob2 . p . xpoints ; ob2_y = ob2 . p . ypoints ; } for ( int i = 0 ; i < ob1_x . length ; i ++ ) { points1 . add ( new Point ( ob1_x [ i ] , ob1_y [ i ] ) ) ; } for ( int i = 0 ; i < ob2_x . length ; i ++ ) { points2 . add ( new Point ( ob2_x [ i ] , ob2_y [ i ] ) ) ; } List < LineEquation > ob1LineEquations = MathFunctions . objectLineEquations ( points1 ) ; List < LineEquation > ob2LineEquations = MathFunctions . objectLineEquations ( points2 ) ; ContactRelation cr1 = CheckLineEquations ( ob2_x , ob2_y , ob1LineEquations ) ; ContactRelation cr2 = CheckLineEquations ( ob1_x , ob1_y , ob2LineEquations ) ; if ( cr1 != ContactRelation . null ) return cr1 ; if ( cr2 != ContactRelation . null ) return cr2 ; int size = 0 ; if ( ob1_x . length > ob2_x . length ) size = ob1_x . length ; else size = ob2_x . length ; for ( int i = 0 ; i < size ; i ++ ) { if ( i < ob1_x . length ) { if ( Arrays . asList ( ob2_x ) . contains ( ob1_x [ i ] ) && Arrays . asList ( ob2_y ) . contains ( ob1_y [ i ] ) ) return ContactRelation . POINT_TO_POINT ; } if ( i < ob2_x . length ) { if ( Arrays . asList ( ob1_x ) . contains ( ob2_x [ i ] ) && Arrays . asList ( ob1_y ) . contains ( ob2_y [ i ] ) ) return ContactRelation . POINT_TO_POINT ; } } } else return ContactRelation . SURFACE_TO_SURFACE ; return ContactRelation . null ; }
tr	KEY	public Builder depthOfTrees ( int depthOfTrees ) { this . depthOfTrees = depthOfTrees ; return this ; }
tr	KEY	public boolean simulate ( ) { return false ; }
tr	IDF	@ Override public Object parseOneValue ( Element xml ) { return new INDIBLOBValue ( xml ) ; }
tr	IDF	@ Override public int hashCode ( ) { int result = message . hashCode ( ) ; result = 31 * result + stackTrace . hashCode ( ) ; return result ; }
tr	KEY	public void setShippingCost ( double shippingCost ) { this . shippingCost = shippingCost ; }
tr	IDF	@ Override public float damage ( float damage ) { if ( undead ) { return float . MAX_VALUE ; } hp -= damage ; if ( hp < 0 ) { hp = 0 ; } return hp ; }
tr	KEY	public boolean canUseRice ( ) { return numOneRiceTile > 0 && getAvailableActionPoints ( true ) > 0 ; }
tr	IDF	@ Override public void onCommandReceived ( String commandName , List < CommandArgument < ? >> commandArgs , long commandId ) { synchronized ( mListeners ) { for ( CommandListener listener : mListeners ) { try { listener . onCommandReceived ( commandName , commandArgs , commandId ) ; } catch ( RuntimeException e ) { System . err . println ( "Error notifying listeners! " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } }
tr	KEY	public static Manager getInstance ( ) { if ( instance == null ) { instance = new Manager ( ) ; } return instance ; }
tr	KEY	public void paintDirtyRegions ( ) { }
tr	IDF	@ Override public SteeringBehaviorsV2 getSteering ( ) { return steering ; }
tr	IDF	public Bag getDiscsWithTurn ( int turn ) { LOGGER . log ( Level . INFO , "Getting discs with turn " + turn ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getTurn ( ) == turn ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with turn " + turn ) ; return discBag ; }
tr	KEY	public final AbstractFMap < Key , Val > clone ( ) { return this ; }
tr	KEY	protected void end ( ) { }
tr	KEY	public void setMaxResiduum ( double maxResiduum ) { this . maxResiduum = maxResiduum ; }
tr	KEY	public void setAssignedTo ( User assignedTo ) { if ( assignedTo == null ) { throw new IllegalArgumentException ( "\"Assigned to\" user cannot be null!" ) ; } this . assignedTo = assignedTo ; }
tr	IDF	public void setCheckInSql ( String checkInSql ) { this . checkInSql = checkInSql ; }
tr	KEY	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final PlayMenu other = ( PlayMenu ) obj ; if ( this . enabled != other . enabled ) { return false ; } if ( this . main != other . main ) { return false ; } if ( this . - != other . - ) { return false ; } if ( this . clear != other . clear ) { return false ; } if ( this . t1 != other . t1 ) { return false ; } if ( this . t2 != other . t2 ) { return false ; } if ( this . count != other . count ) { return false ; } if ( this . losses != other . losses ) { return false ; } if ( ! Objects . equals ( this . t , other . t ) ) { return false ; } if ( ! Objects . equals ( this . s , other . s ) ) { return false ; } return true ; }
tr	IDF	public void setNom_Equipo ( String Nom_Equipo ) { this . Nom_Equipo = Nom_Equipo ; }
tr	KEY	public JSONArray put ( int value ) { this . put ( new Integer ( value ) ) ; return this ; }
tr	IDF	public int getInt ( String key ) throws JSONException { Object o = get ( key ) ; return o instanceof Number ? ( ( Number ) o ) . intValue ( ) : ( int ) getDouble ( key ) ; }
tr	IDF	public String toString ( ) { return super . toString ( ) + " " + location + " " + varname ; }
tr	IDF	private void jPContrasenaKeyPressed ( java . awt . event . KeyEvent evt ) { Validaciones . CantidadCaracteres ( jPContrasena , 6 ) ; }
tr	KEY	public void setNaturalAC ( int naturalAC ) { this . naturalAC = naturalAC ; }
tr	KEY	public synchronized boolean isEnabled ( ) { return m_enabled ; }
tr	IDF	public CachedMap ( Map < K , V > map , int cacheSize ) { this . map = map ; if ( cacheSize < 10 ) this . cacheSize = 20 ; else this . cacheSize = cacheSize ; }
tr	KEY	public int getEnProcesoColorDestino ( ) { return enProcesoColorDestino ; }
tr	KEY	@ Override public GameCharacterObject hide ( ) { visible = false ; return this ; }
tr	KEY	public double getCurrentAxisY ( ) ;
tr	KEY	public void setId1 ( int id1 ) { this . id1 = id1 ; }
tr	KEY	public void setShowGridBlockBox ( boolean showGridBlockBox ) { this . showGridBlockBox = showGridBlockBox ; }
tr	IDF	public int getScore ( ) { int result = 0 ; for ( Integer i : throwz ) { result += i ; } return result ; }
tr	KEY	public long getOffset ( ) { return offset ; }
tr	IDF	protected void organiserCombat ( Salle s ) { if ( s . perso_dans_salle . size ( ) == 2 ) { s . combat ( s . perso_dans_salle . get ( 0 ) , s . perso_dans_salle . get ( 1 ) ) ; textLog . append ( "Le personnage gagnant est " + s . combat ( s . perso_dans_salle . get ( 0 ) , s . perso_dans_salle . get ( 1 ) ) . getNom ( ) ) ; } if ( s . perso_dans_salle . size ( ) == 3 ) { s . combat ( s . perso_dans_salle . get ( 0 ) , ( s . combat ( s . perso_dans_salle . get ( 0 ) , s . perso_dans_salle . get ( 1 ) ) ) ) ; textLog . append ( "Le personnage gagnant est " + s . combat ( s . perso_dans_salle . get ( 0 ) , ( s . combat ( s . perso_dans_salle . get ( 0 ) , s . perso_dans_salle . get ( 1 ) ) ) ) . getNom ( ) ) ; } if ( s . perso_dans_salle . size ( ) == 4 ) { Personnage vainqueur1 = s . combat ( s . perso_dans_salle . get ( 0 ) , s . perso_dans_salle . get ( 1 ) ) ; Personnage vainqueur2 = s . combat ( s . perso_dans_salle . get ( 2 ) , s . perso_dans_salle . get ( 3 ) ) ; s . combat ( vainqueur1 , vainqueur2 ) ; textLog . append ( "Le personnage gagnant est " + s . combat ( vainqueur1 , vainqueur2 ) . getNom ( ) ) ; } else { } }
tr	KEY	public void setDiscontinued ( boolean discontinued ) { this . discontinued = discontinued ; }
tr	KEY	public int getResult ( ) { return _result ; }
tr	KEY	public int id ( ) { return System . identityHashCode ( this ) % 256 ; }
tr	KEY	public boolean setSelectedAction ( MAction selectedAction ) { this . selectedAction = selectedAction ; return true ; }
tr	IDF	public String dump ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( String . format ( "[%02X]: " , id ( ) ) ) ; sb . append ( base . dump ( ) ) ; for ( Node node = base . top ; node != base ; node = node . top ) { sb . append ( node . dump ( ) +   ) ; } sb . append (  ) ; return sb . toString ( ) ; }
tr	IDF	private static double toDouble ( Tuple tuple , String columnName ) { return ( ( Number ) tuple . select ( columnName ) . getValue ( ) ) . doubleValue ( ) ; }
tr	IDF	private static void invert ( Node node ) { if ( node == null ) { return ; } Node left = node . left ; invert ( left ) ; Node right = node . right ; invert ( right ) ; node . right = left ; node . left = right ; }
tr	KEY	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof MsgTypePk ) ) { return false ; } final MsgTypePk _cast = ( MsgTypePk ) _other ; if ( msgType == null ? _cast . msgType != msgType : ! msgType . equals ( _cast . msgType ) ) { return false ; } return true ; }
tr	IDF	public void imageChangeBond ( int getList ) { if ( getList == 10 ) { return ; } imageFrames ++ ; if ( getList == 1 ) { loadImage = new GreenfootImage ( "Ranged//gunnerRun//gunnerRun" + imageFrames + ".png" ) ; imageFramesMax = 6 ; } else if ( getList == 2 ) { loadImage = new GreenfootImage ( "Ranged//gunnerNormal//gunnerNormal" + imageFrames + ".png" ) ; imageFramesMax = 4 ; } else if ( getList == 3 ) { loadImage = new GreenfootImage ( "Ranged//gunnerJump//gunnerJump" + imageFrames + ".png" ) ; imageFramesMax = 2 ; } else if ( getList == 4 ) { loadImage = new GreenfootImage ( "Ranged//gunnerDie//gunnerDie" + imageFrames + ".png" ) ; imageFramesMax = 20 ; } else if ( getList == 5 ) { loadImage = new GreenfootImage ( "Ranged//gunnerAttack//gunnerAttack" + imageFrames + ".png" ) ; imageFramesMax = 5 ; } else if ( getList == 6 ) { loadImage = new GreenfootImage ( "Ranged//gunnerAbilityT//gunnerAbilityT" + imageFrames + ".png" ) ; imageFramesMax = 25 ; } else if ( getList == 7 ) { loadImage = new GreenfootImage ( "Ranged//gunnerAbilityR//gunnerAbilityR" + imageFrames + ".png" ) ; imageFramesMax = 58 ; } else if ( getList == 8 ) { loadImage = new GreenfootImage ( "Ranged//gunnerAbility//gunnerAbilityH00" + imageFrames + ".png" ) ; imageFramesMax = 72 ; } else if ( getList == 9 ) { loadImage = new GreenfootImage ( "Ranged//explosive//explosive00" + imageFrames + ".png" ) ; imageFramesMax = 27 ; } if ( imageFrames == imageFramesMax ) { getList ++ ; imageFrames = 0 ; } setImage ( loadImage ) ; imageChangeNinja ( getList ) ; }
tr	KEY	public boolean pressTab ( ) { return false ; }
tr	KEY	public int [ ] getPlayerIDs ( ) { return playerIDs ; }
tr	IDF	public void mousePressed ( java . awt . event . MouseEvent evt ) { btnPlayRoundMousePressed ( evt ) ; }
tr	KEY	public double [ ] getMirrorColor ( ) { return mirrorColor ; }
tr	KEY	public void setMaxRows ( int maxRows ) ;
tr	KEY	public void initialize ( ) { }
tr	IDF	public Card setName ( String name ) { this . name = name ; return this ; }
tr	IDF	public void deleteHappening ( Calendar date , double amount ) { for ( int i = 0 ; i < happenings . size ( ) ; i ++ ) { Happening happening = happenings . elementAt ( i ) ; if ( happening . getDate ( ) . getTimeInMillis ( ) == date . getTimeInMillis ( ) ) if ( happening . getAmount ( ) == amount ) { happenings . removeElementAt ( i ) ; return ; } } }
tr	KEY	protected abstract void configureComponentActions ( ) ;
tr	IDF	public LockedException ( final String message , final Throwable caughtException ) { super ( message , caughtException ) ; }
tr	KEY	@ Override public boolean delete ( Administrator object ) { return false ; }
tr	IDF	public void setGrossMonthlyIncome ( LabeledTextField grossMonthlyIncome ) { this . grossMonthlyIncome = grossMonthlyIncome ; }
tr	KEY	public int getNumberOfMeasuresTrimmed ( ) { return trimmedMeasures . size ( ) ; }
tr	KEY	private FastMath ( ) { }
tr	IDF	public JFrameScreen ( boolean fullscreen ) { this ( fullscreen , ( int ) Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . getWidth ( ) , ( int ) Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . getHeight ( ) ) ; }
tr	IDF	@ Override public void go ( ) { super . go ( ) ; System . out . println ( ) ; }
tr	KEY	public void setPowered ( boolean powered ) { this . powered = powered ; }
tr	KEY	public int executePost ( int effectedRowCount ) throws EFrameWorkUserIsIdiotException { if ( effectedRowCount == 0 ) { throw new EFrameWorkUserIsIdiotException ( "Insert did not insert a row." ) ; } else if ( effectedRowCount != 1 ) { throw new EFrameWorkUserIsIdiotException ( "Insert inserted more then one row." ) ; } return effectedRowCount ; }
tr	KEY	public int getValue ( ) { return this . value ; }
tr	IDF	public void checkEnemy ( int x , int y ) { if ( sprites [ x ] [ y ] != null ) { numEnemies ++ ; difficulty ++ ; if ( this . type != Type . ENEMIES && numEnemies > getCurrentTypeCount ( ) ) { this . type = Type . ENEMIES ; } } }
tr	IDF	@ Override public String getErrorName ( ) { return super . getErrorName ( ) + "." + businessRuleViolated ; }
tr	KEY	void close ( ) throws IOException ;
tr	KEY	public boolean checkMatch2 ( String t1c , String t2c , int invoker ) { ASCII_Tiles t = new ASCII_Tiles ( ) ; int [ ] arrMatchedTiles = new int [ 2 ] ; boolean passedCheck = false ; if ( t1c . equals ( t2c ) ) { return true ; } else { return false ; } }
tr	IDF	public Bag ( ) { discs = new ArrayList < Disc > ( ) ; LOGGER = Logger . getLogger ( Bag . class . getName ( ) ) ; }
tr	KEY	@ Override public void updateModelFromView ( ) { throw new UnsupportedOperationException ( "Not implemented" ) ; }
tr	IDF	@ Override public void init ( FilterConfig config ) throws ServletException { this . config = config ; }
tr	IDF	public void setFuncionmedicamentos ( String funcionmedicamentos ) { String oldFuncionmedicamentos = this . funcionmedicamentos ; this . funcionmedicamentos = funcionmedicamentos ; changeSupport . firePropertyChange ( "funcionmedicamentos" , oldFuncionmedicamentos , funcionmedicamentos ) ; }
tr	IDF	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "checkBalance" , targetNamespace = "http://api.soap.mytxtbuddy.com/" , className = "com.dreamoval.mytxtbuddy.api.proxy.CheckBalance" ) @ WebMethod @ ResponseWrapper ( localName = "checkBalanceResponse" , targetNamespace = "http://api.soap.mytxtbuddy.com/" , className = "com.dreamoval.mytxtbuddy.api.proxy.CheckBalanceResponse" ) public java . lang . String checkBalance ( @ WebParam ( name = "username" , targetNamespace = "" ) java . lang . String username , @ WebParam ( name = "password" , targetNamespace = "" ) java . lang . String password ) ;
tr	KEY	public void extend ( int byHeight ) ;
tr	KEY	public SendMessageContactsResponse createSendMessageContactsResponse ( ) { return new SendMessageContactsResponse ( ) ; }
tr	KEY	public synchronized int xgetRBInitialDelay ( ) { return rbID ; }
tr	IDF	public void setTile8 ( String tile8 ) { this . tile8 = tile8 ; }
tr	IDF	@ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { processRequest ( request , response ) ; } catch ( Exception ex ) { Logger . getLogger ( Controller . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new ServletException ( "Controller: Error: ClassNotFoundException " + ex . getMessage ( ) ) ; } }
tr	KEY	@ Override public void connectionLost ( ) { }
tr	KEY	public final void setMonths ( int months ) { if ( ( months >= 0 ) && ( months < 60 ) ) { this . months = months ; } }
tr	IDF	public static Element getXMLRootElementByDom4j ( String fileName ) throws DocumentException { File file = new File ( fileName ) ; Document document = new SAXReader ( ) . read ( file ) ; return document . getRootElement ( ) ; }
tr	IDF	public static void setCadena ( String Cadena ) { Conexion . Cadena = Cadena ; }
tr	KEY	public void bumpCheck ( int xTile , int yTile ) { }
tr	IDF	public Product ( int productID , String productName , String description , String categoryName , double unitPrice , int unitsInStock , int unitsOnOrder , int reorderLevel , boolean discontinued , String imagePath ) { this . productID = productID ; this . productName = productName ; this . description = description ; this . categoryName = categoryName ; this . unitPrice = unitPrice ; this . unitsInStock = unitsInStock ; this . unitsOnOrder = unitsOnOrder ; this . reorderLevel = reorderLevel ; this . discontinued = discontinued ; this . imagePath = imagePath ; }
tr	IDF	public PlayerNames ( ) { initComponents ( ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; this . setLocation ( ( screenSize . width / 2 ) - ( this . getWidth ( ) / 2 ) , ( screenSize . height / 2 ) - ( this . getHeight ( ) / 2 ) ) ; }
tr	KEY	public int getMainUsageId ( ) { return mainUsageId ; }
tr	IDF	@ Override public void windowOpened ( WindowEvent e ) { loadProp ( ) ; }
tr	KEY	public abstract void reset ( ) ;
tr	IDF	@ Override public int hashCode ( ) { int hash = 3 ; hash = 29 * hash + this . averageWeather ; return hash ; }
tr	KEY	public void setValCob_DevCompra ( double ValCob_DevCompra ) { this . ValCob_DevCompra = ValCob_DevCompra ; }
tr	IDF	protected void processMouseMotionEvent ( MouseEvent e ) { e . consume ( ) ; }
tr	IDF	public void setCheckIn ( Collection < String > checkIn ) ;
tr	IDF	private void miHoleModeMousePressed ( java . awt . event . MouseEvent evt ) { JOptionPane . showMessageDialog ( null , "This feature has not yet been implemented." ) ; }
tr	KEY	public void setUnidades ( double unidades ) { this . unidades = unidades ; }
tr	IDF	public void translate ( float x , float y , float z ) { Vector3d vectTrans = new Vector3d ( x , y , z ) ; Transform3D oldT3D = new Transform3D ( ) ; this . get3DPresentation ( ) . getTransform ( oldT3D ) ; Transform3D localT3D = new Transform3D ( ) ; localT3D . setTranslation ( vectTrans ) ; Transform3D newT3D = new Transform3D ( ) ; newT3D . mul ( oldT3D , localT3D ) ; this . get3DPresentation ( ) . setTransform ( newT3D ) ; }
tr	IDF	public SelectionPanel ( ) { setBorder ( BorderFactory . createEtchedBorder ( ) ) ; setLayout ( new MigLayout ( "" , "[grow fill]" , "" ) ) ; initPanels ( ) ; initRadioButtons ( ) ; }
tr	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { closetabBtnActionPerformed ( evt ) ; }
tr	KEY	public boolean isOk ( ) { return ok ; }
tr	KEY	public void setEnabled ( boolean enabled ) { this . enabled = enabled ; }
tr	IDF	private boolean checkDeveloperOnCell ( JavaCell [ ] [ ] miniMap , Tile tile ) { TileType [ ] [ ] tileCells = tile . getTileCells ( ) ; for ( int i = 0 ; i < tileCells . length ; i ++ ) { for ( int j = 0 ; j < tileCells [ i ] . length ; j ++ ) { if ( tileCells [ i ] [ j ] != null ) { if ( miniMap [ i ] [ j ] != null && miniMap [ i ] [ j ] . hasDeveloper ( ) ) { return false ; } } } } return true ; }
tr	IDF	public static String [ ] enumToStringArray ( ) { String [ ] result = new String [ StatusCode . values ( ) . length ] ; int count = 0 ; for ( StatusCode code : StatusCode . values ( ) ) { result [ count ] = code . toString ( ) ; count ++ ; } return result ; }
tr	KEY	public static LiteralFactory getLiteralFactory ( ) { return LITERAL_FACTORY ; }
tr	IDF	@ Test public final void testCopy ( ) { final Directory rootDir = new Directory ( "testFolder" ) ; final File fileA1 = new File ( "testFolder" + File . separatorChar + "fileA1.txt" ) ; final File fileA2 = new File ( "testFolder" + File . separatorChar + "fileA2.txt" ) ; final Directory folderA1 = new Directory ( "testFolder" + File . separatorChar + "testFolderA1" ) ; final Directory folderA2 = new Directory ( "testFolder" + File . separatorChar + "testFolderA2" ) ; final Directory folderA3 = new Directory ( "testFolder" + File . separatorChar + "testFolderA3" ) ; final Directory folderA4 = new Directory ( "testFolder" + File . separatorChar + "testFolderA4" ) ; final File fileB1 = new File ( "testFolder" + File . separatorChar + "testFolderA2" + File . separatorChar + "fileB1.txt" ) ; final Directory folderB1 = new Directory ( "testFolder" + File . separatorChar + "testFolderA3" + File . separatorChar + "testFolderB1" ) ; final File fileB2 = new File ( "testFolder" + File . separatorChar + "testFolderA4" + File . separatorChar + "fileB2.txt" ) ; final File fileB3 = new File ( "testFolder" + File . separatorChar + "testFolderA4" + File . separatorChar + "fileB3.txt" ) ; final Directory folderB2 = new Directory ( "testFolder" + File . separatorChar + "testFolderA4" + File . separatorChar + "testFolderB2" ) ; final File fileB4 = new File ( "testFolder" + File . separatorChar + "testFolderA4" + File . separatorChar + "testFolderB2" + File . separatorChar + "fileB4.txt" ) ; assertTrue ( rootDir . exists ( ) ) ; assertTrue ( fileA1 . exists ( ) ) ; assertTrue ( fileA2 . exists ( ) ) ; assertTrue ( folderA1 . exists ( ) ) ; assertTrue ( folderA2 . exists ( ) ) ; assertTrue ( folderA3 . exists ( ) ) ; assertTrue ( folderA4 . exists ( ) ) ; assertTrue ( fileB1 . exists ( ) ) ; assertTrue ( folderB1 . exists ( ) ) ; assertTrue ( fileB1 . exists ( ) ) ; assertTrue ( fileB2 . exists ( ) ) ; assertTrue ( fileB3 . exists ( ) ) ; assertTrue ( folderB2 . exists ( ) ) ; assertTrue ( fileB4 . exists ( ) ) ; final Directory rootDir2 = new Directory ( "testFolder2" ) ; rootDir . copyContentsTo ( rootDir2 ) ; final List < DiskUnit > units = rootDir2 . getUnitsWithin ( ) ; assertEquals ( 6 , units . size ( ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "fileA1.txt" ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "fileA2.txt" ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "testFolderA1" ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "testFolderA2" ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "testFolderA3" ) ) ; assertTrue ( unitsContainsPath ( units , "testFolder2" + File . separatorChar + "testFolderA4" ) ) ; final List < DiskUnit > units2 = new Directory ( "testFolder2" + File . separatorChar + "testFolderA1" ) . getUnitsWithin ( ) ; assertEquals ( 0 , units2 . size ( ) ) ; final List < DiskUnit > units3 = new Directory ( "testFolder2" + File . separatorChar + "testFolderA2" ) . getUnitsWithin ( ) ; assertEquals ( 1 , units3 . size ( ) ) ; assertEquals ( File . CURRENT_DIR + File . separatorChar + "testFolder2" + File . separatorChar + "testFolderA2" + File . separatorChar + "fileB1.txt" , units3 . get ( 0 ) . getPath ( ) ) ; final List < DiskUnit > units4 = new Directory ( "testFolder2" + File . separatorChar + "testFolderA3" ) . getUnitsWithin ( ) ; assertEquals ( 1 , units4 . size ( ) ) ; assertEquals ( File . CURRENT_DIR + File . separatorChar + "testFolder2" + File . separatorChar + "testFolderA3" + File . separatorChar + "testFolderB1" , units4 . get ( 0 ) . getPath ( ) ) ; final List < DiskUnit > units5 = new Directory ( "testFolder2" + File . separatorChar + "testFolderA4" ) . getUnitsWithin ( ) ; assertEquals ( 3 , units5 . size ( ) ) ; assertTrue ( unitsContainsPath ( units5 , "testFolder2" + File . separatorChar + "testFolderA4" + File . separatorChar + "fileB2.txt" ) ) ; assertTrue ( unitsContainsPath ( units5 , "testFolder2" + File . separatorChar + "testFolderA4" + File . separatorChar + "fileB3.txt" ) ) ; assertTrue ( unitsContainsPath ( units5 , "testFolder2" + File . separatorChar + "testFolderA4" + File . separatorChar + "testFolderB2" ) ) ; final List < DiskUnit > units6 = new Directory ( "testFolder2" + File . separatorChar + "testFolderA4" + File . separatorChar + "testFolderB2" ) . getUnitsWithin ( ) ; assertEquals ( 1 , units6 . size ( ) ) ; assertEquals ( File . CURRENT_DIR + File . separatorChar + "testFolder2" + File . separatorChar + "testFolderA4" + File . separatorChar + "testFolderB2" + File . separatorChar + "fileB4.txt" , units6 . get ( 0 ) . getPath ( ) ) ; rootDir . delete ( ) ; rootDir2 . delete ( ) ; }
tr	KEY	public Table ( ) { }
tr	KEY	public void setSpecularPower ( double specularPower ) { this . specularPower = specularPower ; }
tr	KEY	public abstract int getDim ( ) ;
tr	IDF	@ Override public double [ ] getVariables ( ) { double [ ] variables = new double [ this . buildings . size ( ) ] ; for ( int i = 0 ; i < variables . length ; i ++ ) variables [ i ] = 1.0 ; return variables ; }
tr	IDF	public void setLabel ( String label ) { this . label = label ; }
tr	IDF	public void actionPerformed ( ActionEvent e ) { try { ArrayList < long > result = AppleScript . getSelectedGraph ( ) ; tfShowElementID . setText ( result . get ( 0 ) . toString ( ) ) ; } catch ( ScriptException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( null , "Finish showing elements!" ) ; }
tr	IDF	@ Override public void setPresenter ( TopicStatisticListPresenter presenter ) { this . presenter = presenter ; }
tr	KEY	public UTypeDaoImpl ( ) { }
tr	IDF	public FTreeMap ( Map < ? extends Key , ? extends Val > map , Comparator < ? super Key > c ) { comp = ( Comparator < Key > ) c ; tree = fromMap ( ( Map < Key , Val > ) map ) ; dflt = null ; }
tr	KEY	public static void cancelAction ( ) { GameRobot . pressEscape ( ) ; }
tr	KEY	public int getCount ( ) { return antal ; }
tr	IDF	private static EntityManager getEntityManager ( ) { return EMF . get ( ) . createEntityManager ( ) ; }
tr	KEY	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	IDF	public static String writeJsonToUserSpecifiedFile ( Component component , JSONObject json ) throws IOException , URISyntaxException { File choosedFile = null ; JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showSaveDialog ( component ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { choosedFile = chooser . getSelectedFile ( ) ; writeJsonToFile ( json , choosedFile . getPath ( ) ) ; return choosedFile . getPath ( ) ; } return null ; }
tr	KEY	public CreateResponse createCreateResponse ( ) { return new CreateResponse ( ) ; }
tr	IDF	private JTabbedPane createInputTabs ( ) { JTabbedPane tabManager = new JTabbedPane ( ) ; tabManager . addTab ( "brute force" , createBruteForceInputArea ( ) ) ; tabManager . addTab ( "puzzle" , createPuzzleInputArea ( ) ) ; return tabManager ; }
tr	IDF	private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
tr	IDF	public void print ( String s ) { this . out . print ( s ) ; }
tr	KEY	@ Override public void putCharWhileString ( char c ) throws ParsingException { throw new UnsupportedCharacterException ( c ) ; }
tr	KEY	public int getInstruction ( ) { return mInstruction ; }
tr	KEY	@ AfterMethod public void tearDownMethod ( ) throws Exception { }
tr	IDF	public void changeGameState ( final GameState state ) { super . changeGameState ( state ) ; switch ( state ) { case INITIALIZING : break ; case STARTING : soundManager . play ( BreakOutSoundKeys . GET_READY ) ; playingField . setupLevel ( ) ; camera . setMessage ( new InGameMessage ( "Get Ready!" , WHITE , 2000 ) ) ; break ; case LEVEL_CHANGE : camera . setMessage ( new InGameMessage ( "Great Job!" , WHITE , 2000 ) ) ; SharedGameData . getInstance ( ) . levelUp ( ) ; playingField . setupLevel ( ) ; break ; case LEVEL_RESET : soundManager . play ( BreakOutSoundKeys . GET_READY ) ; playingField . resetEntities ( ) ; camera . setMessage ( new InGameMessage ( "Get Ready!" , WHITE , 2000 ) ) ; break ; case OUT_OF_BOUNDS : soundManager . play ( BreakOutSoundKeys . OUT_OF_BOUNDS ) ; camera . setMessage ( new InGameMessage ( "Out Of Bounds" , WHITE , 1000 ) ) ; break ; case GAME_OVER : soundManager . play ( BreakOutSoundKeys . GAME_OVER ) ; camera . setMessage ( new InGameMessage ( "Game Over" , RED , Integer . MAX_VALUE ) ) ; break ; } }
tr	IDF	public static void main ( String [ ] args ) { CountDownLatch latch = new CountDownLatch ( SIZE ) ; Random r = new Random ( ) ; ExecutorService exec = Executors . newCachedThreadPool ( ) ; Controller controller = new Controller ( latch ) ; exec . execute ( controller ) ; for ( int i = 0 ; i < SIZE ; i ++ ) { exec . execute ( new Module ( latch , "\u6A21\u5757" + ( i + 1 ) , r . nextInt ( 2000 ) ) ) ; } exec . shutdown ( ) ; }
tr	IDF	public void setInput ( InputStream input ) { this . input = input ; }
tr	IDF	public void run ( ) { try { UIManager . setLookAndFeel ( UIManager . getCrossPlatformLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { System . out . println ( "Error setting Java LAF: " + e ) ; } createGui ( ) ; }
tr	IDF	public void run ( ) { try { System . out . println ( "Closing ActiveMQ connection" ) ; connection . close ( ) ; } catch ( JMSException e ) { } }
tr	IDF	@ Override public DivOperator getInstance ( AbstractMutableFormula left , AbstractMutableFormula right ) { return new DivOperator ( left , right ) ; }
tr	IDF	public UnitCreationEvent ( GameEntity u ) { super ( u ) ; }
tr	IDF	private void jBListarActionPerformed ( java . awt . event . ActionEvent evt ) { listar ( ) ; }
tr	KEY	public CardViewImpl ( ) { super ( "CardView" ) ; this . initComponents ( ) ; }
tr	IDF	public static void findAnyComboMatchSum ( List < Integer > arr , int sum , int start ) { if ( sum < 2 ) return ; for ( int i = start ; i < arr . size ( ) ; i ++ ) { int diff = sum - arr . get ( i ) ; log ( "look at " + arr . get ( i ) + " with sum " + sum ) ; if ( diff > 0 && arr . contains ( diff ) ) { log ( "found diff: " + diff + " with " + arr . get ( i ) ) ; } findAnyComboMatchSum ( arr , diff , i + i ) ; } }
tr	KEY	private boolean bool_sempred ( BoolContext _localctx , int predIndex ) { switch ( predIndex ) { case 3 : return 2 >= _localctx . _p ; } return true ; }
tr	IDF	static void isort ( float [ ] a , int off , int len ) { for ( int i = off + 1 , end = off + len ; i < end ; i ++ ) { float ai = a [ i ] ; int j = i - 1 ; for ( ; j >= off && a [ j ] > ai ; j -- ) { a [ j + 1 ] = a [ j ] ; } a [ j + 1 ] = ai ; } }
tr	IDF	private JLabel createPalaceCardJLabel ( String hashKey ) { JLabel label = new JLabel ( ) ; label . setIcon ( new ImageIcon ( imageSourceHashMap . get ( hashKey ) ) ) ; label . setPreferredSize ( new Dimension ( 80 , 110 ) ) ; label . setBorder ( BorderFactory . createEmptyBorder ( 0 , 5 , 10 , 5 ) ) ; return label ; }
tr	IDF	public void addContextFeature ( long code , FeatureVector fv ) { int id = contextAlphabet . lookupIndex ( code , numContextFeats ) ; if ( id >= 0 ) { fv . addEntry ( id , 1.0 ) ; if ( id == numContextFeats ) ++ numContextFeats ; } }
tr	KEY	public boolean isSeaPassable ( ) { return this == SEA ; }
tr	KEY	@ Override public Matrix transpose ( ) { return null ; }
tr	IDF	public void actionPerformed ( ActionEvent e ) { controller . centerMapEvent ( ) ; }
tr	IDF	@ Override public Set < String > characters ( ) { return outs . keySet ( ) ; }
tr	IDF	@ Override public void run ( ) { try { player . play ( ) ; } catch ( JavaLayerException ex ) { JOptionPane . showMessageDialog ( null , "Error" + ex ) ; } }
tr	KEY	@ Override public int hashCode ( ) { return 31 * id ; }
tr	IDF	public ArrayList < ArrayList < JavaPlayer >> getPalaceRanks ( JavaCell palace , LinkedList < Developer > gameDevelopers ) { ArrayList < JavaCell > city = getCityFromRootCell ( palace , visitedVillages ) ; HashMap < JavaPlayer , Integer > scores = new HashMap < JavaPlayer , Integer > ( ) ; for ( JavaCell c : city ) { if ( getDeveloperOnCell ( c , gameDevelopers ) != null ) { Developer d = getDeveloperOnCell ( c , gameDevelopers ) ; JavaPlayer p = d . getOwner ( ) ; int rank = c . getElevation ( ) ; if ( ! scores . containsKey ( p ) ) { scores . put ( p , rank ) ; } else { int newRank = c . getElevation ( ) ; if ( newRank > rank ) scores . put ( p , newRank ) ; } } } ArrayList < Integer > values = new ArrayList < Integer > ( ) ; for ( Integer i : scores . values ( ) ) values . add ( i ) ; Collections . sort ( values ) ; Collections . reverse ( values ) ; ArrayList < ArrayList < JavaPlayer >> players = new ArrayList < ArrayList < JavaPlayer >> ( ) ; for ( Integer i : values ) { ArrayList < JavaPlayer > rank = new ArrayList < JavaPlayer > ( ) ; for ( JavaPlayer p : scores . keySet ( ) ) { if ( scores . get ( p ) == i ) rank . add ( p ) ; } players . add ( rank ) ; } return players ; }
tr	IDF	public T visitASTExpMul ( ASTExpMul form , S state ) throws FractalException ;
tr	KEY	public void init ( ) { }
tr	KEY	public void onBroadcastSent ( ) ;
tr	KEY	public void setPixel ( int x , int y , int rgb [ ] ) { }
tr	KEY	protected boolean isFinished ( ) { return true ; }
tr	IDF	public void addLayer ( VGraphicLayer vgl ) { add_vgl . add ( vgl ) ; }
tr	KEY	public int size ( ) { return discs . size ( ) ; }
tr	KEY	public boolean getButtonStateRightStick ( ) { return getRawButton ( BUTTON_RIGHT_STICK ) ; }
tr	KEY	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Lesson other = ( Lesson ) obj ; if ( classRoom == null ) { if ( other . classRoom != null ) return false ; } else if ( ! classRoom . equals ( other . classRoom ) ) return false ; if ( schoolClass == null ) { if ( other . schoolClass != null ) return false ; } else if ( ! schoolClass . equals ( other . schoolClass ) ) return false ; if ( teacher == null ) { if ( other . teacher != null ) return false ; } else if ( ! teacher . equals ( other . teacher ) ) return false ; if ( teachingUnit == null ) { if ( other . teachingUnit != null ) return false ; } else if ( ! teachingUnit . equals ( other . teachingUnit ) ) return false ; return true ; }
tr	IDF	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 30 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 30 ) ; this . background = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . title = new TELabel ( "Game Over" , 0 , 50 , titleFont ) ; this . title . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels = new TECollectionVertical ( 0 , 0 , 15 ) ; ArrayList < Player > players = Board . getInstance ( ) . getPlayers ( ) ; Collections . sort ( players , new Comparator < Player > ( ) { @ Override public int compare ( Player player , Player player2 ) { int pos1 = player . getPosition ( ) ; int pos2 = player2 . getPosition ( ) ; if ( pos1 == 0 ) pos1 = 4 ; if ( pos2 == 0 ) pos2 = 4 ; return pos1 - pos2 ; } } ) ; for ( Player player : Board . getInstance ( ) . getPlayers ( ) ) { playerLabels . addView ( new TELabel ( player . scoreLabelStr ( ) , 0 , 0 , menuFont ) ) ; } playerLabels . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels . horizontalAlignCenter ( 0 , GameWindow . getInstance ( ) . getHeight ( ) ) ; }
tr	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { comboEstadoActionPerformed ( evt ) ; }
tr	KEY	public void setPreis ( double preis ) { this . preis = preis ; }
tr	IDF	@ Test public void testDate6 ( ) { Calendar beginCalendar = Calendar . getInstance ( ) ; Calendar endCalendar = Calendar . getInstance ( ) ; calendar_Obj . compareCalendar ( beginCalendar , endCalendar ) ; }
tr	IDF	public List < SentItem > findAll ( ) throws SQLException { try { return sentItemRepository . findAll ( ) ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; throw new SQLException ( ex . toString ( ) ) ; } }
tr	KEY	public void windowIconified ( final WindowEvent e ) { }
tr	KEY	public Animation ( ) { this ( new ArrayList ( ) , 0 ) ; }
tr	IDF	public CONLLReader ( Options options ) { this . options = options ; }
tr	IDF	public User addRemoteUser ( String username ) { User newUser = new User ( username ) ; remoteUsers . add ( newUser ) ; return newUser ; }
tr	IDF	private void loginToFBjButtonActionPerformed ( java . awt . event . ActionEvent evt ) { firstFacebookConnection ( ) ; }
tr	IDF	public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragFlip ( ) ; } }
tr	KEY	void pressMoveBackward ( ) ;
tr	KEY	public abstract void update ( ) ;
tr	IDF	public Sleep ( String character ) { this . character = character ; }
tr	IDF	@ Override public void render ( GameContainer gc , Graphics grphcs ) throws SlickException { }
tr	KEY	public int getColumnStart ( ) { return columnStart ; }
tr	KEY	private void initAnimations ( ) throws SlickException { Image [ ] arrayAnimation = { new Image ( "assets/game/items/objective/1.png" ) , new Image ( "assets/game/items/objective/2.png" ) , new Image ( "assets/game/items/objective/3.png" ) , new Image ( "assets/game/items/objective/4.png" ) , new Image ( "assets/game/items/objective/5.png" ) , new Image ( "assets/game/items/objective/6.png" ) , new Image ( "assets/game/items/objective/7.png" ) , new Image ( "assets/game/items/objective/8.png" ) } ; animation = new Animation ( arrayAnimation , new int [ ] { 100 , 100 , 100 , 100 , 100 , 100 , 100 , 100 } , false ) ; }
tr	KEY	public void update ( ) ;
tr	KEY	public int getPriority ( ) { return priority ; }
tr	KEY	public abstract ArrayList load ( ) throws SQLException ;
tr	KEY	TIPPTaskResponse ( ) { super ( ) ; }
tr	KEY	@ Override public LAProvider getProvider ( ) { return null ; }
tr	IDF	@ Override public String getMessage ( ) { return USR . getFAILED_AUTH ( ) ; }
tr	KEY	protected abstract String getXMLPropertySetEnd ( ) ;
tr	IDF	@ Override public A apply ( A a ) { if ( smap . containsKey ( a ) ) return smap . get ( a ) ; return a ; }
tr	IDF	String getKeyPath ( int num ) { if ( ! pathInputVerifier . verify ( keyPaths [ num ] ) ) return null ; return keyPaths [ num ] . getText ( ) ; }
tr	KEY	public LiuNianView ( ) { }
tr	KEY	public long getId ( ) { return id ; }
tr	IDF	public ExpressaoBinaria ( Expressao expressaoEsquerda , Expressao expressaoDireita , String operator ) { this . expressaoEsquerda = expressaoEsquerda ; this . expressaoDireita = expressaoDireita ; this . operador = operator ; }
tr	KEY	public List < long > getIds ( ) { if ( ids == null ) { ids = new ArrayList < long > ( ) ; } return this . ids ; }
tr	IDF	public void act ( ) { if ( this . down == true ) { move ( 20 ) ; dealtDamage ( this . getX ( ) , this . getY ( ) , 5 , 300 , 1 , 0 , 0.6 , 0 ) ; } else { if ( this . direction == true ) { setLocation ( this . getX ( ) + speed , getY ( ) ) ; dealtDamage ( this . getX ( ) , this . getY ( ) , 700 , 5 , 1 , 0 , 0.5 , 1 ) ; } else if ( this . direction == false ) { setLocation ( this . getX ( ) - speed , getY ( ) ) ; dealtDamage ( this . getX ( ) , this . getY ( ) , 700 , 5 , 1 , 0 , 0.5 , 1 ) ; } } if ( getX ( ) < 0 || getX ( ) > 1000 ) { getWorld ( ) . removeObject ( this ) ; } else if ( getY ( ) > 400 ) { getWorld ( ) . removeObject ( this ) ; } }
tr	IDF	public LevelScene ( GraphicsConfiguration graphicsConfiguration , MarioComponent renderer , long seed , int levelDifficulty , int type ) { this . graphicsConfiguration = graphicsConfiguration ; this . levelSeed = seed ; this . marioComponent = renderer ; this . levelDifficulty = levelDifficulty ; this . levelType = type ; widthArrow = 25 ; tipWidthArrow = 10 ; heightArrow = 20 ; xArrow = 160 ; yArrow = 40 ; xPositionsArrow = new int [ ] { xArrow + - widthArrow / 2 , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + widthArrow / 2 - tipWidthArrow , xArrow + - widthArrow / 2 } ; yPositionsArrow = new int [ ] { yArrow + - heightArrow / 4 , yArrow + - heightArrow / 4 , yArrow + - heightArrow / 2 , yArrow + 0 , yArrow + heightArrow / 2 , yArrow + heightArrow / 4 , yArrow + heightArrow / 4 } ; }
tr	KEY	public boolean aindaPossuiIrmao ( ) { int posicao = this . posicaoListaAdjacencia - 1 ; int i ; for ( i = 0 ; i < this . getNoPai ( ) . getListaAdjacencia ( ) . size ( ) ; i ++ ) if ( this . getNoPai ( ) . getListaAdjacencia ( ) . get ( i ) != null ) if ( posicao == 1 ) return false ; return true ; }
tr	IDF	public void startClock ( ) { this . resetClock ( ) ; this . timer = new Timer ( ) ; timer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { task ( ) ; } } , 1000 , 1000 ) ; }
tr	IDF	private Map < long , Map < long , long >> parse ( File directory ) throws IOException { URL shapeURL = new File ( table ) . toURI ( ) . toURL ( ) ; DataStore store = new ShapefileDataStore ( shapeURL ) ; String tname = store . getTypeNames ( ) [ 0 ] ; FeatureSource < SimpleFeatureType , SimpleFeature > source = store . getFeatureSource ( tname ) ; FeatureCollection < SimpleFeatureType , SimpleFeature > collection = source . getFeatures ( ) ; Map < long , Map < long , long >> sm = new TreeMap < long , Map < long , long >> ( ) ; FeatureIterator < SimpleFeature > iterator = collection . features ( ) ; SimpleFeature ft ; while ( iterator . hasNext ( ) ) { ft = iterator . next ( ) ; indexer . put ( ( String ) ft . getAttribute ( lookup ) , ( ( Number ) ft . getAttribute ( index ) ) . longValue ( ) ) ; } if ( ! directory . exists ( ) ) { System . out . println ( "ERROR:  Directory " + directory + " does not exist." ) ; System . exit ( 0 ) ; } Map < long , long > m ; for ( File f : directory . listFiles ( new EndsWithFilter ( extension ) ) ) { String name = f . getName ( ) . substring ( 0 , f . getName ( ) . lastIndexOf ( "." ) ) ; long where = - 1 ; try { where = indexer . get ( name ) ; } catch ( NullPointerException npe ) { System . out . print ( "No lookup match was found for " + name + " using field " + lookup + " in " + table ) ; System . out . println ( " - Continuing..." ) ; continue ; } if ( sm . get ( where ) == null ) { m = new TreeMap < long , long > ( ) ; } else { m = sm . get ( where ) ; } BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; stk = new StringTokenizer ( br . readLine ( ) , "[{  =}]" ) ; while ( stk . hasMoreTokens ( ) ) { m . put ( long . parseLong ( stk . nextToken ( ) ) , long . parseLong ( stk . nextToken ( ) ) ) ; } sm . put ( where , m ) ; br . close ( ) ; } return sm ; }
tr	IDF	private void printUser ( User user ) { System . out . println ( "--- bean user is ---" ) ; System . out . println ( user . toString ( ) ) ; }
tr	IDF	public static void main ( String [ ] args ) { HTTPBroker broker = new HTTPBroker ( 9999 ) ; broker . start ( ) ; broker . registerService ( "server" , new ServerServiceImpl ( ) , ServerService . class ) ; broker . join ( ) ; }
tr	IDF	public void set ( T value ) { m_object = value ; }
tr	KEY	public int getRowsAmount ( ) ;
tr	IDF	public void send ( String msg ) throws JMSException { ObjectMessage m = session . createObjectMessage ( ) ; m . setObject ( new ChatTextMessage ( id , clientName , msg ) ) ; m . setJMSReplyTo ( privateQueue ) ; m . setJMSCorrelationID ( createRandomString ( ) ) ; if ( currChatRoom == null ) { producer . send ( m ) ; } else { currChatRoomProducer . send ( m ) ; } }
tr	IDF	public Subject getSubject ( SubjectID subject ) { return this . subjects . get ( subject ) ; }
tr	KEY	protected abstract void setTextFieldValues ( ) ;
tr	KEY	public String add ( ) { return "addEvent.xhtml?faces-redirect=true" ; }
tr	KEY	public static FormulaCandidateFactory getInstance ( ) { if ( inst == null ) inst = new FormulaCandidateFactory ( 3 ) ; return inst ; }
tr	IDF	private void repaintButtons ( ) { < . repaint ( ) ; lb . repaint ( ) ; l1 . repaint ( ) ; l2 . repaint ( ) ; l3 . repaint ( ) ; l4 . repaint ( ) ; l5 . repaint ( ) ; d1 . repaint ( ) ; d2 . repaint ( ) ; d3 . repaint ( ) ; d4 . repaint ( ) ; s1 . repaint ( ) ; s2 . repaint ( ) ; r1 . repaint ( ) ; r2 . repaint ( ) ; r3 . repaint ( ) ; r4 . repaint ( ) ; r5 . repaint ( ) ; x . repaint ( ) ; y . repaint ( ) ; b . repaint ( ) ; a . repaint ( ) ; rb . repaint ( ) ; rt . repaint ( ) ; }
tr	KEY	@ Test public void test ( ) throws Exception { }
tr	IDF	public Matrix ( double [ ] [ ] transform ) { for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , transform [ i ] [ j ] ) ; } } }
tr	KEY	public void reset ( ) { this . actionPoints = testingActionPoints ; this . famePoints = 0 ; this . numOneRiceTile = 3 ; this . numOneVillageTile = 2 ; this . numTwoTile = 5 ; this . numActionTokens = 3 ; this . palaceCards = new ArrayList < PalaceCard > ( ) ; this . hasPlacedLandTile = false ; this . hasUsedActionToken = false ; this . developersArray = new Developer [ 12 ] ; this . palacesInteractedWith = new ArrayList < JavaCell > ( ) ; }
tr	IDF	public XYLayout ( ) { info = new Hashtable < Component , XYConstraints > ( ) ; }
tr	IDF	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	IDF	public void actionPerformed ( ActionEvent e ) { playerLeave ( ) ; }
tr	KEY	public void setNumFacCom_DevCompra ( int NumFacCom_DevCompra ) { this . NumFacCom_DevCompra = NumFacCom_DevCompra ; }
tr	IDF	public Crypto ( ) { supportedAlgorithms . add ( AES ) ; supportedAlgorithms . add ( DES ) ; supportedAlgorithms . add ( BLOWFISH ) ; supportedAlgorithms . add ( CAESAR ) ; }
tr	KEY	public VideoRequest createVideoRequest ( ) { return new VideoRequest ( ) ; }
tr	KEY	protected void interrupted ( ) { }
tr	KEY	public int getStage ( ) { return stage ; }
tr	IDF	@ Override public void onCommand ( POP3Session session , String argument1 , String argument2 ) throws POP3Exception { if ( session . getState ( ) != POP3State . TRANSACTION ) { throw new POP3Exception ( "-ERR auth first" ) ; } try { if ( argument1 != null && argument2 == null ) { int emailNum = Integer . parseInt ( argument1 ) ; dealOneArgument ( session , emailNum ) ; } else if ( argument1 != null && argument2 != null ) { int emailNum = Integer . parseInt ( argument1 ) ; int lineNum = Integer . parseInt ( argument2 ) ; dealTwoArgument ( session , emailNum , lineNum ) ; } else { throw new POP3Exception ( "-ERR syntax error" ) ; } } catch ( NumberFormatException e ) { throw new POP3Exception ( "-ERR syntax error" ) ; } }
tr	IDF	public String getNome ( ) { return nome . toUpperCase ( ) ; }
tr	KEY	public String getFileType ( ) { if ( this == IMAGE ) { return ".png" ; } else if ( this == SOUND ) { return ".wav" ; } else { return "" ; } }
tr	IDF	public String toString ( ) { String returnValue = "" ; if ( value != null || ! value . trim ( ) . equals ( "" ) ) { returnValue = "<constante value=\"" + value + "\"/>" ; } return returnValue ; }
tr	IDF	@ Override public void handleSocketEvent ( SocketEvent e ) { SocketThread source = ( SocketThread ) e . getSource ( ) ; Message m = source . getMessage ( ) ; if ( ! m . getSender ( ) . equals ( source . getName ( ) ) ) { source . setName ( m . getSender ( ) ) ; participants . elementChanged ( source ) ; } if ( m . isDisconnect ( ) ) { try { remove ( source ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } Message message = new Message ( ) ; message . setSender ( "Server" ) ; message . setText ( m . getSender ( ) + " disconnected." ) ; message . setColor ( "#000000" ) ; send ( message ) ; } else if ( m . getRequestReply ( ) != null ) { try { remove ( source ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } Message message = new Message ( ) ; message . setSender ( "Server" ) ; message . setText ( m . getSender ( ) + " declined connection. Message: " + m . getRequestMessage ( ) ) ; message . setColor ( "#000000" ) ; insert ( message ) ; } else if ( m . getFileResponse ( ) != null ) { handler . addResponse ( m ) ; System . out . println ( "Response received" ) ; } else if ( m . getFileName ( ) != null ) { handler . addRequest ( m , source ) ; System . out . println ( "Request received" ) ; } else if ( m . getKeyRequest ( ) != null ) { Message message = new Message ( ) ; message . setSender ( userInput . get ( "user_name" ) ) ; if ( crypto . getSupportedCryptoList ( ) . contains ( m . getKeyRequestType ( ) ) ) { message . setEncryptionAlgo ( m . getKeyRequestType ( ) ) ; message . setEncryptionKey ( crypto . getKey ( m . getKeyRequestType ( ) ) ) ; } else { message . setEncryptionAlgo ( Crypto . AES ) ; message . setEncryptionKey ( crypto . getKey ( Crypto . AES ) ) ; } source . send ( message ) ; Message msg = new Message ( ) ; msg . setSender ( "Server" ) ; msg . setText ( m . getSender ( ) + " requested a key of type " + m . getKeyRequestType ( ) + ". Message: " + m . getKeyRequest ( ) ) ; insert ( msg ) ; } else if ( m . getText ( ) != null ) { relay ( source , m ) ; insert ( m ) ; } else { } }
tr	IDF	public final void tickNoMove ( ) { xOld = x ; yOld = y ; }
tr	KEY	public int getAkku ( ) { return akku ; }
tr	KEY	public void read ( ) throws EOFException ;
tr	KEY	public int getYear ( ) { return year ; }
tr	KEY	public void setYear ( int year ) { this . year = year ; }
tr	IDF	@ Override public void update ( Observable arg0 , Object arg1 ) { int digit = model . getDigitAt ( row , col ) ; SudokuPart constraint = model . getCurrentConstraint ( ) ; if ( constraint != null && constraint . getRow ( ) == row && constraint . getCol ( ) == col ) { setBackground ( Color . GREEN ) ; } else { SudokuPart popped = model . getPopped ( ) ; if ( popped != null && popped . getRow ( ) == row && popped . getCol ( ) == col ) { setBackground ( Color . RED ) ; } else { setBackground ( Color . WHITE ) ; } } setText ( digit > 0 ? Integer . toString ( digit ) : "" ) ; }
tr	IDF	public void stateChanged ( javax . swing . event . ChangeEvent evt ) { jslideMatchPairsStateChanged ( evt ) ; }
tr	IDF	private byte tf ( Point p ) { return ( fow [ p . x ] [ p . y ] ) ; }
tr	IDF	public void setTakt ( String takt ) { this . takt = takt ; }
tr	KEY	public void setStk_Act ( boolean stk_Act ) { this . stk_Act = stk_Act ; }
tr	KEY	public double getValor ( ) { return valor ; }
tr	KEY	public void setSpecularPower ( double specularPower ) { this . specularPower = specularPower ; }
tr	KEY	public double getCountsRevs ( ) { return countsRevs ; }
tr	KEY	public void setLockedBySMTP ( boolean isLockedBySMTP ) { this . isLockedBySMTP = isLockedBySMTP ; }
tr	KEY	public void setFullWidth ( int width ) { this . width = width ; }
tr	KEY	public synchronized void xsetRBrepeatable ( boolean flag ) { isRBrepeatable = flag ; }
tr	KEY	public int getSizeX ( ) { return this . newSizeX ; }
tr	KEY	public synchronized boolean isD4repetitionEnabled ( ) { return isD4repeatable ; }
tr	IDF	public boolean applyTechnniqueNakedPairCol ( ) { boolean removedSomething = false ; try { int emptyNumber = getNextMostConstrainedEmptyElementNumber ( ) ; int puzzleSize = this . getSize ( ) ; int tmpNumber ; int tmpRowNumber ; boolean foundNakedPair = false ; Integer [ ] firstCandidateStorageArray = new Integer [ 2 ] ; Integer [ ] secondCandidateStorageArray = new Integer [ 2 ] ; while ( emptyNumber < puzzleSize * puzzleSize ) { if ( elementWithNumberIsEmpty ( emptyNumber ) && getValidValuesForElementWithNumber ( emptyNumber ) . size ( ) == 2 ) { firstCandidateStorageArray = this . validElementsCache . get ( emptyNumber ) . toArray ( firstCandidateStorageArray ) ; tmpRowNumber = emptyNumber ; tmpNumber = emptyNumber - ( ( emptyNumber / puzzleSize ) * puzzleSize ) ; for ( int i = 0 ; i < puzzleSize && ! foundNakedPair && tmpNumber < puzzleSize * puzzleSize ; i ++ ) { if ( elementWithNumberIsEmpty ( tmpNumber ) && getValidValuesForElementWithNumber ( tmpNumber ) . size ( ) == 2 && tmpNumber != emptyNumber ) { secondCandidateStorageArray = this . validElementsCache . get ( tmpNumber ) . toArray ( secondCandidateStorageArray ) ; if ( firstCandidateStorageArray [ 0 ] == secondCandidateStorageArray [ 0 ] && firstCandidateStorageArray [ 1 ] == secondCandidateStorageArray [ 1 ] ) { foundNakedPair = true ; int checkCellNumber = emptyNumber - ( ( emptyNumber / puzzleSize ) * puzzleSize ) ; for ( int j = 0 ; j < puzzleSize && checkCellNumber < puzzleSize * puzzleSize ; j ++ ) { if ( elementWithNumberIsEmpty ( checkCellNumber ) && checkCellNumber != tmpNumber && checkCellNumber != emptyNumber ) { Set < Integer > beforeRemove = new HashSet < Integer > ( this . validElementsCache . get ( checkCellNumber ) ) ; this . removeValueForElementWithNumber ( checkCellNumber , firstCandidateStorageArray [ 0 ] ) ; this . removeValueForElementWithNumber ( checkCellNumber , firstCandidateStorageArray [ 1 ] ) ; if ( ! beforeRemove . equals ( this . validElementsCache . get ( checkCellNumber ) ) ) { removedSomething = true ; } } checkCellNumber = checkCellNumber + puzzleSize ; } if ( removedSomething ) { return true ; } else { foundNakedPair = false ; } } } tmpNumber = tmpNumber + puzzleSize ; } while ( tmpRowNumber % puzzleSize != 0 ) { tmpRowNumber -- ; } for ( int i = 0 ; i < puzzleSize && ! foundNakedPair && tmpRowNumber < puzzleSize * puzzleSize ; i ++ ) { if ( elementWithNumberIsEmpty ( tmpRowNumber ) && getValidValuesForElementWithNumber ( tmpRowNumber ) . size ( ) == 2 && tmpRowNumber != emptyNumber ) { secondCandidateStorageArray = this . validElementsCache . get ( tmpRowNumber ) . toArray ( secondCandidateStorageArray ) ; if ( firstCandidateStorageArray [ 0 ] == secondCandidateStorageArray [ 0 ] && firstCandidateStorageArray [ 1 ] == secondCandidateStorageArray [ 1 ] ) { foundNakedPair = true ; int checkRowCellNumber = tmpRowNumber ; while ( checkRowCellNumber % puzzleSize != 0 ) { checkRowCellNumber -- ; } for ( int j = 0 ; j < puzzleSize && checkRowCellNumber < puzzleSize * puzzleSize ; j ++ ) { if ( elementWithNumberIsEmpty ( checkRowCellNumber ) && checkRowCellNumber != tmpRowNumber && checkRowCellNumber != emptyNumber ) { Set < Integer > beforeRemove = new HashSet < Integer > ( this . validElementsCache . get ( checkRowCellNumber ) ) ; this . removeValueForElementWithNumber ( checkRowCellNumber , firstCandidateStorageArray [ 0 ] ) ; this . removeValueForElementWithNumber ( checkRowCellNumber , firstCandidateStorageArray [ 1 ] ) ; if ( ! beforeRemove . equals ( this . validElementsCache . get ( checkRowCellNumber ) ) ) { removedSomething = true ; } } checkRowCellNumber ++ ; } if ( removedSomething ) { return true ; } else { foundNakedPair = false ; } } } tmpRowNumber ++ ; } } emptyNumber ++ ; } return false ; } catch ( NoElementsEmptyException e ) { return false ; } }
tr	KEY	@ Override public Object getParent ( ) { return null ; }
tr	IDF	public double lengthSq ( ) { return x * x + y * y ; }
tr	IDF	public void setMailZipCode ( LabeledTextField mailZipCode ) { this . mailZipCode = mailZipCode ; }
tr	IDF	@ Override public void setTeam ( TEAM division ) { this . team = division ; }
tr	IDF	private void editTf ( ) { int dim = fodTools . getFormula ( ) . length ; int oNum = outTools . getFormula ( ) . length ; TfDialog tf = new TfDialog ( title , dim , oNum , params , parent . getPanel ( ) . getParams ( ) ) ; if ( tf . isOk ( ) ) { String [ ] xf = makeSysEqn ( dim , tf ) ; fodTools . setFormula ( xf ) ; String [ ] of = makeOutputEqn ( dim , oNum , tf ) ; outTools . setFormula ( of ) ; } }
tr	KEY	public Pepperoni createPepperoni ( ) { return new SlicedPepperoni ( ) ; }
tr	IDF	public void setDialogKontak ( DialogKontak dialogKontak ) { this . dialogKontak = dialogKontak ; int row = dialogKontak . getjTable1 ( ) . getSelectedRow ( ) ; Kontak kontak = dialogKontak . getKontakTableModel ( ) . findOne ( row ) ; jTextFieldNama . setText ( kontak . getNama ( ) ) ; jTextFieldNomor . setText ( kontak . getNomor ( ) ) ; jComboBoxGrup . setSelectedItem ( kontak . getGrup ( ) ) ; }
tr	KEY	public boolean evaluerTransporteur ( ) { return false ; }
tr	IDF	@ HandlesEvent ( "OrderHistory" ) public Resolution orderHistory ( ) { Resolution r = new ForwardResolution ( "/" ) ; if ( ctx . getUser ( ) != null ) { try { this . orders = new dao . OrderDAO ( ) . getOrdersByUserID ( ctx . getUser ( ) . getUserID ( ) ) . toArray ( this . orders ) ; } catch ( SQLException | NamingException e ) { e . printStackTrace ( ) ; } r = new ForwardResolution ( "/orderhistory.jsp" ) ; } return r ; }
tr	IDF	@ Override public Bitmap createBitmap ( String input ) { try { return new BitmapSwing ( input ) ; } catch ( IOException ex ) { System . out . println ( "BitmapSwing Error." ) ; } return null ; }
tr	IDF	FSet < Val > range ( ) ;
tr	KEY	public static ShortUrlGenerator instance ( ) { if ( null == m_instance ) { m_instance = new ShortUrlGenerator ( ) ; } return m_instance ; }
tr	KEY	public void execute ( ) ;
tr	IDF	@ Override public Action loadObject ( JsonObject json ) { return null ; }
tr	KEY	public void setLevel ( final int level ) { this . level = level ; }
tr	KEY	public int getMaxRows ( ) { return maxRows ; }
tr	KEY	private String getAddressString ( int highByte , int lowByte ) { int iAddr = joinBytes ( highByte , lowByte ) ; switch ( iAddr ) { case VSYNC : return "VSYNC" ; case VBLANK : return "VBLANK" ; case WSYNC : return "WSYNC" ; case RSYNC : return "RSYNC" ; case NUSIZ0 : return "NUSIZ0" ; case NUSIZ1 : return "NUSIZ1" ; case COLUP0 : return "COLUP0" ; case COLUP1 : return "COLUP1" ; case COLUPF : return "COLUPF" ; case COLUBK : return "COLUBK" ; case CTRLPF : return "CTRLPF" ; case REFP0 : return "REFP0" ; case REFP1 : return "REFP1" ; case PF0 : return "PF0" ; case PF1 : return "PF1" ; case PF2 : return "PF2" ; case RESP0 : return "RESP0" ; case RESP1 : return "RESP1" ; case RESM0 : return "RESM0" ; case RESM1 : return "RESM1" ; case RESBL : return "RESBL" ; case AUDC0 : return "AUDC0" ; case AUDC1 : return "AUDC1" ; case AUDF0 : return "AUDF0" ; case AUDF1 : return "AUDF1" ; case AUDV0 : return "AUDV0" ; case AUDV1 : return "AUDV1" ; case GRP0 : return "GRP0" ; case GRP1 : return "GRP1" ; case ENAM0 : return "ENAM0" ; case ENAM1 : return "ENAM1" ; case ENABL : return "ENABL" ; case HMP0 : return "HMP0" ; case HMP1 : return "HMP1" ; case HMM0 : return "HMM0" ; case HMM1 : return "HMM1" ; case HMBL : return "HMBL" ; case VDELP0 : return "VDELP0" ; case VDELP1 : return "VDELP1" ; case VDELBL : return "VDELBL" ; case RESMP0 : return "RESMP0" ; case RESMP1 : return "RESMP1" ; case HMOVE : return "HMOVE" ; case HMCLR : return "HMCLR" ; case CXCLR : return "CXCLR" ; case CXM0P : return "CXM0P" ; case CXM1P : return "CXM1P" ; case CXP0FB : return "CXP0FB" ; case CXP1FB : return "CXP1FB" ; case CXM0FB : return "CXM0FB" ; case CXM1FB : return "CXM1FB" ; case CXBLPF : return "CXBLPF" ; case CXPPMM : return "CXPPMM" ; case INPT0 : return "INPT0" ; case INPT1 : return "INPT1" ; case INPT2 : return "INPT2" ; case INPT3 : return "INPT3" ; case INPT4 : return "INPT4" ; case INPT5 : return "INPT5" ; } return "$" + Integer . toHexString ( iAddr ) ; }
tr	KEY	public double getAlpha ( ) { return ( double ) Math . round ( ( ( double ) color . getAlpha ( ) / 255 ) * 100 ) / 100 ; }
tr	KEY	public abstract void copyParamaters ( int [ ] paramaters ) ;
tr	KEY	public String [ ] getColumnNames ( ) { return this . columnNames ; }
tr	KEY	public int getMatchSeconds ( ) { return matchSeconds ; }
tr	KEY	public NewsDAO ( ) { super ( News . class ) ; }
tr	KEY	private void loadGame ( ) { }
tr	IDF	@ Override public void processNewNumberValue ( INDINumberProperty property , Date timestamp , INDINumberElementAndValue [ ] elementsAndValues ) { if ( property == absFocusPositionP ) { int newVal = elementsAndValues [ 0 ] . getValue ( ) . intValue ( ) ; if ( ( newVal >= getMinimumAbsPos ( ) ) && ( newVal <= getMaximumAbsPos ( ) ) ) { if ( focusAbsolutePositionE . getValue ( ) . intValue ( ) != newVal ) { absFocusPositionP . setState ( PropertyStates . BUSY ) ; desiredAbsPosition = newVal ; try { updateProperty ( absFocusPositionP ) ; } catch ( INDIException e ) { } absolutePositionHasBeenChanged ( ) ; } else { absFocusPositionP . setState ( PropertyStates . OK ) ; try { updateProperty ( absFocusPositionP ) ; } catch ( INDIException e ) { } } } } if ( property == focusSpeedP ) { int newVal = elementsAndValues [ 0 ] . getValue ( ) . intValue ( ) ; if ( ( newVal >= 0 ) && ( newVal <= getMaximumSpeed ( ) ) ) { if ( focusSpeedValueE . getValue ( ) . intValue ( ) != newVal ) { focusSpeedP . setState ( PropertyStates . BUSY ) ; focusSpeedValueE . setValue ( "" + newVal ) ; try { updateProperty ( focusSpeedP ) ; } catch ( INDIException e ) { } speedHasBeenChanged ( ) ; } else { focusSpeedP . setState ( PropertyStates . OK ) ; try { updateProperty ( focusSpeedP ) ; } catch ( INDIException e ) { } } } } }
tr	KEY	public void setScore ( boolean score ) { this . score = score ; }
tr	KEY	@ Override public ClientID getClient ( ) { return null ; }
tr	IDF	@ Override public void parseFile ( ) { data = new ArrayList < > ( ) ; try { Scanner in = new Scanner ( new File ( filePath ) ) ; findClasses ( ) ; while ( in . hasNext ( ) ) { String [ ] split = in . nextLine ( ) . split ( " " ) ; List < double > featureList = new ArrayList < > ( ) ; for ( int featureIterator = 0 ; featureIterator < inputs ; featureIterator ++ ) { double featureValue = double . MAX_VALUE ; switch ( split [ featureIterator ] ) { case "x" : featureValue = 1 ; break ; case "o" : featureValue = - 1 ; break ; case "b" : featureValue = 0 ; break ; default : System . out . println ( "Invalid character in parseFile of tic tac toe" ) ; } featureList . add ( featureValue ) ; } List < double > output = getOutputVector ( split [ inputs ] ) ; data . add ( new DataPoint ( featureList , output ) ) ; } in . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found for poker dataset." ) ; e . printStackTrace ( ) ; } finally { findClasses ( ) ; } }
tr	KEY	public double getHeight ( ) { return height ; }
tr	IDF	public final long createArcCodeP ( FeatureTemplate . Arc temp , long x ) { return ( ( x << numArcFeatBits ) | temp . ordinal ( ) ) << flagBits ; }
tr	KEY	@ BeforeMethod public void setUpMethod ( ) throws Exception { }
tr	KEY	public ScriptSpecificationBuilder tickingEvery ( int seconds ) { this . frequencyInSeconds = seconds ; return this ; }
tr	IDF	public org . apache . axiom . om . OMElement getOMElement ( final javax . xml . namespace . QName parentQName , final org . apache . axiom . om . OMFactory factory ) throws org . apache . axis2 . databinding . ADBException { org . apache . axiom . om . OMDataSource dataSource = new org . apache . axis2 . databinding . ADBDataSource ( this , MY_QNAME ) ; return factory . createOMElement ( dataSource , MY_QNAME ) ; }
tr	KEY	public ProgramTree ( ) { }
tr	KEY	public int getX ( ) { return mX ; }
tr	KEY	public boolean isFile ( ) { return false ; }
tr	IDF	public void displayDbProperties ( ) { java . sql . DatabaseMetaData dm = null ; java . sql . ResultSet rs = null ; try { con = this . getConnection ( ) ; if ( con != null ) { dm = con . getMetaData ( ) ; LOGGER . finest ( "Driver Information" ) ; LOGGER . finest ( "\tDriver Name: " + dm . getDriverName ( ) ) ; LOGGER . finest ( "\tDriver Version: " + dm . getDriverVersion ( ) ) ; LOGGER . finest ( "\nDatabase Information " ) ; LOGGER . finest ( "\tDatabase Name: " + dm . getDatabaseProductName ( ) ) ; LOGGER . finest ( "\tDatabase Version: " + dm . getDatabaseProductVersion ( ) ) ; LOGGER . finest ( "Avalilable Catalogs " ) ; rs = dm . getCatalogs ( ) ; while ( rs . next ( ) ) { LOGGER . finest ( "\tcatalog: " + rs . getString ( 1 ) ) ; } rs . close ( ) ; rs = null ; closeConnection ( ) ; } else LOGGER . severe ( "Error: No active Connection" ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; } dm = null ; }
tr	KEY	public static final int getPAL ( int colorIndex , int luminanceIndex ) { if ( colorIndex > 15 || luminanceIndex > 15 ) return 000000 ; return PAL [ colorIndex * 16 + luminanceIndex ] ; }
tr	IDF	private void makeYStub ( ) { OutputStub yStub = new OutputStub ( ) ; yStub . setName ( "y" ) ; yStub . setXY ( 600 , 10 ) ; addOutputStub ( yStub ) ; }
tr	KEY	public void selectionScreen ( ) { if ( Greenfoot . isKeyDown ( "left" ) ) { selection = true ; } else if ( Greenfoot . isKeyDown ( "right" ) ) { selection = false ; } }
tr	IDF	public static void init ( final GameDisplayPane displayPane ) { gameManagers = new GameManager [ ] { new HangManGameManager ( displayPane ) , new ScrambleGameManager ( displayPane ) , new BreakOutGameManager ( displayPane ) , new OthelloGameManager ( displayPane ) } ; }
tr	KEY	public FontCollector ( ) { }
tr	IDF	public UpdaterWindow ( ) { setResizable ( false ) ; setTitle ( "DynQuiz Updater v1.6" ) ; setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 200 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; final JLabel lblStatus = new JLabel ( ) ; lblStatus . setFont ( new Font ( "Tahoma" , Font . PLAIN , 16 ) ) ; lblStatus . setIcon ( new ImageIcon ( UpdaterWindow . class . getResource ( "/de/codebucket/dynquiz/images/gif_load.gif" ) ) ) ; lblStatus . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblStatus . setBounds ( 12 , 12 , 420 , 80 ) ; contentPane . add ( lblStatus ) ; final JLabel lblDetails = new JLabel ( ) ; lblDetails . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblDetails . setFont ( new Font ( "Dialog" , Font . BOLD , 12 ) ) ; lblDetails . setBounds ( 12 , 104 , 420 , 17 ) ; contentPane . add ( lblDetails ) ; setVisible ( true ) ; final JProgressBar progressBar = new JProgressBar ( ) ; progressBar . setStringPainted ( true ) ; progressBar . setBounds ( 12 , 133 , 328 , 25 ) ; contentPane . add ( progressBar ) ; JButton btnCancel = new JButton ( "Cancel" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { cancelled = true ; if ( download != null && download . getStatus ( ) == Download . DOWNLOADING ) { download . cancel ( ) ; return ; } if ( getDefaultCloseOperation ( ) == DO_NOTHING_ON_CLOSE ) { return ; } new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } if ( getDefaultCloseOperation ( ) == DISPOSE_ON_CLOSE ) { dispose ( ) ; return ; } System . exit ( 1 ) ; } } ) . start ( ) ; } } ) ; btnCancel . setBounds ( 352 , 133 , 80 , 25 ) ; contentPane . add ( btnCancel ) ; FrameRunner . centerWindow ( this ) ; progressBar . setIndeterminate ( true ) ; lblStatus . setText ( "Checking for new Updates..." ) ; lblDetails . setText ( "Trying to fetch data from \"www.codebucket.de/downloads/dynquiz\"" ) ; new UpdateTask ( UUID . randomUUID ( ) , "http://www.codebucket.de/downloads/dynquiz/update.js" , UpdateTask . CURRENT_UPDATE ) { @ Override public void updateSucess ( Update update ) { if ( cancelled == true ) { return ; } if ( update == null ) { lblStatus . setIcon ( null ) ; lblStatus . setText ( "An error occurred while checking for new updates." ) ; lblDetails . setText ( "Nothing has been changed. You can close this window." ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; progressBar . setIndeterminate ( false ) ; JOptionPane . showMessageDialog ( null , "An error occurred while checking for new updates." , "DynQuiz Updater v1.6" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( update . getName ( ) . equals ( getCurrent ( ) . getName ( ) ) ) { if ( update . getVersion ( ) . equalsIgnoreCase ( getCurrent ( ) . getVersion ( ) ) ) { lblStatus . setIcon ( null ) ; lblStatus . setText ( "No Update found! You have already the newest version." ) ; lblDetails . setText ( "Nothing has been changed. You can close this window." ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; progressBar . setIndeterminate ( false ) ; JOptionPane . showMessageDialog ( null , "No Update found! You have already the newest version." , "DynQuiz Updater v1.6" , JOptionPane . INFORMATION_MESSAGE ) ; return ; } progressBar . setIndeterminate ( false ) ; lblStatus . setText ( "Waiting for user response..." ) ; lblDetails . setText ( "New Update found! Update version: " + update . getVersion ( ) ) ; int result = JOptionPane . showConfirmDialog ( null , "New Update found!\nUpdate version: " + update . getVersion ( ) + "\nYour version: " + getCurrent ( ) . getVersion ( ) + "\n\nDo you want to download the new Update?" , "DynQuiz Updater v1.6" , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { try { download = new Download ( new URL ( update . getUpdate ( ) ) ) ; new Thread ( new Runnable ( ) { public void run ( ) { lblStatus . setText ( "Downloading update... Please wait." ) ; while ( download . getStatus ( ) == Download . DOWNLOADING ) { progressBar . setValue ( ( int ) download . getProgress ( ) ) ; int downloaded = ( download . getDownloaded ( ) / 1024 ) ; int size = ( download . getSize ( ) / 1024 ) ; lblDetails . setText ( "Downloading file: " + downloaded + "kB /" + size + "kB (" + ( int ) download . getProgress ( ) + "%)" ) ; } if ( download . getStatus ( ) != Download . COMPLETE ) { lblStatus . setIcon ( null ) ; lblStatus . setText ( "Update has been cancelled by user." ) ; lblDetails . setText ( "Nothing has been changed. You can close this window." ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; File file = new File ( download . getFileName ( ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } return ; } System . gc ( ) ; File jar = getJarFile ( ) ; if ( jar . exists ( ) ) { jar . deleteOnExit ( ) ; } lblStatus . setIcon ( null ) ; lblStatus . setText ( "Finished! Update sucessfully downloaded." ) ; lblDetails . setText ( "File sucessfully downloaded!" ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; progressBar . setValue ( 100 ) ; int result = JOptionPane . showConfirmDialog ( null , "Update sucessfully downloaded!\nTo apply the changes  this program needs to be restarted.\nDo you like to restart this application?" , "DynQuiz Updater v1.6" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { try { restartApplication ( new File ( download . getFileName ( ) ) ) ; } catch ( Exception ex ) { System . exit ( 0 ) ; } } } } ) . start ( ) ; } catch ( Exception ex ) { } } else { lblStatus . setIcon ( null ) ; lblStatus . setText ( "Update has been cancelled by user." ) ; lblDetails . setText ( "Nothing has been changed. You can close this window." ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; } } } } . check ( ) ; }
tr	KEY	public synchronized void close ( ) { socket . close ( ) ; }
tr	KEY	public int getDim ( ) { return dim ; }
tr	KEY	public boolean checaTipo ( AmbienteCompilacao amb ) { return true ; }
tr	IDF	public MainWindow ( ) { setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; }
tr	IDF	public TurnToAttacker ( Movable subject , double coefficient , int priority ) { super ( subject , coefficient ) ; assert subject instanceof Unit ; u = ( Unit ) subject ; this . priority = priority ; }
tr	KEY	@ Override public int hashCode ( ) { return abonentId ; }
tr	IDF	@ Test ( groups = "MaSuite" ) public void getEnum ( ) { LOGGER . log ( Level . INFO , "Derby Stating" ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( "ORACLE" ) , SQLDatatbaseType . ORACLE ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( "DB2AS400" ) , SQLDatatbaseType . DB2AS400 ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( "SQLSERVER" ) , SQLDatatbaseType . SQLSERVER ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( "UNKNOW_DATABASE" ) , SQLDatatbaseType . UNKNOW_DATABASE ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( null ) , SQLDatatbaseType . UNKNOW_DATABASE ) ; assert . assertEquals ( SQLDatatbaseType . getEnum ( "" + Math . random ( ) ) , SQLDatatbaseType . UNKNOW_DATABASE ) ; }
tr	IDF	public static void envoyerModele ( ) { try { out . writeObject ( fenetre . getModele ( ) ) ; out . flush ( ) ; } catch ( Exception e ) { fenetre . changerVue ( new MessageView ( "Connexion rompu !" , new AccueilView ( ) , true ) ) ; } }
tr	IDF	public Album ( String name , int year , String artist ) { _name = name ; _year = year ; _artist = artist ; }
tr	KEY	public double getEps1 ( ) { return eps1 ; }
tr	KEY	public AbstractFractalEvaluator ( ) { this ( "FRACTAL Display" ) ; }
tr	KEY	public double getNumber ( ) { return this . aNumber ; }
tr	KEY	@ Override public void inputProcess ( ) { }
tr	KEY	public OthelloCell ( final int column , final int row ) { this . column = column ; this . row = row ; }
tr	KEY	public boolean getSignal ( ) { return mTVSignal ; }
tr	IDF	@ Override public void updateViewFromModel ( ) { this . topicname . setText ( this . presenter . getModel ( ) . getTopic ( ) . getName ( ) ) ; this . questionWord . setText ( this . presenter . getModel ( ) . getQuestion ( ) ) ; this . answerField . setText ( this . presenter . getModel ( ) . getAnswer ( ) ) ; this . questionWord . requestFocus ( ) ; }
tr	KEY	public double getGoal ( ) { return this . goal ; }
tr	IDF	public void dieRecord ( Sprite sprite ) { if ( sprite instanceof FlowerEnemy ) { detailedLog += "Die:  EnemyType = FlowerEnemy " ; detailedLog += "\n" ; deaths [ SpriteTemplate . JUMP_FLOWER ] ++ ; } else if ( sprite instanceof BulletBill ) { detailedLog += "Die:  EnemyType = BulletBill " ; detailedLog += "\n" ; deaths [ 5 ] ++ ; } else if ( sprite instanceof Shell ) { detailedLog += "Die:  EnemyType = TurtleShell " ; detailedLog += "\n" ; deaths [ 9 ] ++ ; } else if ( sprite instanceof Enemy ) { Enemy enemy = ( Enemy ) sprite ; deaths [ enemy . type ] ++ ; detailedLog += "Die:  EnemyType = " + enemy . type ; detailedLog += "\n" ; } }
tr	KEY	public void ready ( ) { ready = true ; }
tr	KEY	public double getEps2 ( ) { return eps2 ; }
tr	IDF	public void setFC1RunDt ( String aval ) throws Exception { fc1rundt = dtfmt . parse ( aval ) ; }
tr	KEY	public int getId ( ) { return id ; }
tr	IDF	public void restore ( Memento memento ) { this . state = memento . state ; this . code = memento . code ; this . parameters = memento . parameters ; }
tr	IDF	@ Test public void canAddProductToCart ( ) { Map < Integer , Integer > sc = new HashMap < > ( ) ; try { shoppingCart . addProductToCart ( user1 , prod_id1 , 20 ) ; sc = getShoppingCart ( user1 ) ; deleteShoppingCartUser ( user1 ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } assertEquals ( 20 , sc . get ( prod_id1 ) . intValue ( ) ) ; }
tr	IDF	ReprocessingPlantPanel ( Preferences preferences ) { super ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridy = 0 ; c . gridx = 0 ; c . weightx = 1.0 ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . BASELINE_LEADING ; mineralPanel = new MineralPanel ( preferences ) ; mineralPanel . setBorder ( BorderFactory . createTitledBorder ( "Minerals" ) ) ; add ( mineralPanel , c ) ; c . gridx = 1 ; c . weightx = 0.0 ; c . fill = GridBagConstraints . VERTICAL ; plantSettings = new UserPlantSettings ( preferences ) ; plantSettings . setBorder ( BorderFactory . createTitledBorder ( "Facility" ) ) ; add ( plantSettings , c ) ; plantSettings . setPreferredSize ( new Dimension ( 150 , 100 ) ) ; c . gridy = 1 ; c . gridx = 0 ; c . gridwidth = 2 ; c . fill = GridBagConstraints . HORIZONTAL ; sovereigntyPanel = new SovereigntyPanel ( preferences , new AbstractAction ( "Find solution" ) { @ Override public void actionPerformed ( ActionEvent e ) { SwingWorker < String , void > worker = new SwingWorker < String , void > ( ) { @ Override protected String doInBackground ( ) throws Exception { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { ReprocessingPlantPanel . this . setEnabled ( false ) ; } } ) ; EnumSet < Sovereignty > sovereignty = sovereigntyPanel . getSovereignty ( ) ; double securityStatus = sovereigntyPanel . getMinimumSecurityStatus ( ) ; ServiceLoader < ReprocessingService > serviceLoader = ServiceLoader . load ( ReprocessingService . class ) ; Iterator < ReprocessingService > iterator = serviceLoader . iterator ( ) ; if ( iterator . hasNext ( ) ) { ReprocessingService service = iterator . next ( ) ; ReprocessingPlant plant = service . getPlant ( sovereignty , securityStatus ) ; double yield = plantSettings . getYield ( ) ; double tax = plantSettings . getTax ( ) ; plant . setUserStatistics ( yield / 100 , tax / 100 ) ; ReprocessingSolution solution = plant . getMinimumOreVolume ( mineralPanel . getMinerals ( ) ) ; return toFormattedString ( solution , plantSettings . getCargo ( ) ) ; } else { return "No suitable reprocessing service found." ; } } @ Override protected void done ( ) { try { resultDocument . remove ( 0 , resultDocument . getLength ( ) ) ; resultDocument . insertString ( 0 , get ( ) , null ) ; } catch ( BadLocationException e1 ) { e1 . printStackTrace ( ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } catch ( ExecutionException e1 ) { e1 . printStackTrace ( ) ; } finally { ReprocessingPlantPanel . this . setEnabled ( true ) ; } } } ; worker . execute ( ) ; } } ) ; Border border = BorderFactory . createTitledBorder ( "Sovereignty" ) ; sovereigntyPanel . setBorder ( border ) ; add ( sovereigntyPanel , c ) ; c . gridy = 2 ; c . gridx = 0 ; c . gridwidth = 2 ; c . weightx = 1.0 ; c . weighty = 1.0 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; c . fill = GridBagConstraints . BOTH ; JTextArea resultArea = new JTextArea ( ) ; resultArea . setEditable ( false ) ; resultDocument = resultArea . getDocument ( ) ; JScrollPane scrollPane = new JScrollPane ( resultArea ) ; scrollPane . setBorder ( BorderFactory . createTitledBorder ( "Optimal ore volumes" ) ) ; add ( scrollPane , c ) ; }
tr	KEY	@ Override public void run ( ) { while ( true ) { try { t . sleep ( 30 ) ; } catch ( InterruptedException e ) { if ( ventana != null ) { ventana . dispose ( ) ; } break ; } } }
tr	IDF	void volume ( ) { System . out . println ( "volume:" + length * width * height ) ; }
tr	KEY	public boolean isLeaf ( ) { return this . getChildCount ( ) == 0 ; }
tr	IDF	Map < TIPPFile , String > getLocationMap ( ) { return locationMap ; }
tr	KEY	public int getPageSize ( ) { return pageSize ; }
tr	IDF	static void display ( ) { Iterator < String > itr = list . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . println ( itr . next ( ) ) ; } }
tr	KEY	public boolean isActive ( ) { return active ; }
tr	KEY	public int top ( ) { return stack . peek ( ) ; }
tr	KEY	public int getParameterCount ( ) { return this . getParameters ( ) . size ( ) ; }
tr	IDF	@ Override public void onMessageReceived ( Message < ServerProtocolParameters > message ) { if ( message instanceof ServerNodeCommandMessage ) { Message < ClientProtocolParameters > response = messageHandler . handleMessage ( ( ServerNodeCommandMessage ) message , null ) ; if ( response != null ) { messageManager . sendMessage ( response ) ; } } }
tr	KEY	public int getRightAnswer ( ) { return rightAnswer ; }
tr	KEY	public RotateShootingCharacter setVElevation ( float vElevation ) { this . vElevation = vElevation ; return this ; }
tr	KEY	@ Override public void isBeingDestroyed ( ) { }
tr	IDF	public static ArrayList getAllFilesPath ( File dir ) { if ( ! dir . isDirectory ( ) ) { String filePath = dir . getAbsolutePath ( ) ; System . out . println ( filePath ) ; allFilesPath . add ( filePath ) ; } else { File [ ] fs = dir . listFiles ( ) ; for ( int i = 0 ; i < fs . length ; i ++ ) { if ( fs [ i ] . isDirectory ( ) ) { try { getAllFilesPath ( fs [ i ] ) ; } catch ( Exception e ) { } } else { String filePath = fs [ i ] . getAbsolutePath ( ) ; System . out . println ( filePath ) ; allFilesPath . add ( filePath ) ; } } } System . out . println ( "Utils.getAllFilesPath-\u6587\u4EF6\u4E2A\u6570---->" + allFilesPath . size ( ) ) ; return allFilesPath ; }
tr	KEY	public GalleryDAO ( ) { super ( GalleryImage . class ) ; }
tr	IDF	public static List < String > getNonIncludeProperties ( ) throws DocumentException { return getProperties ( getXMLRootElementByDom4j ( RULE_CONFIG ) . element ( "non-include" ) ) ; }
tr	KEY	public double getWeightChange ( ) { return weightChange ; }
tr	KEY	public boolean isAlive ( ) { return true ; }
tr	IDF	private Object fromMap ( Map < Key , Val > map ) { if ( map instanceof FTreeMap && eql ( comp , ( ( FTreeMap ) map ) . comp ) ) return ( ( FTreeMap ) map ) . tree ; else { Object t = null ; for ( Map . Entry < Key , Val > ent : map . entrySet ( ) ) t = with ( t , ent . getKey ( ) , ent . getValue ( ) ) ; return t ; } }
tr	KEY	public byte [ ] [ ] getMap ( ) ;
tr	IDF	public void setUrl ( String value ) { this . url = value ; }
tr	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton2ActionPerformed ( evt ) ; }
tr	IDF	public FTreeSet ( Comparator < ? super Elt > c ) { tree = null ; comp = ( Comparator < Elt > ) c ; }
tr	KEY	protected int getListeningPort ( ) { return listeningPort ; }
tr	IDF	public void init ( ) { TileMapLoader loader = new TMXLoader ( ) ; tm = loader . load ( "Pangea.tmx" ) ; w = new World ( tm ) ; entities = new HashMap < > ( ) ; gameSem = new Semaphore ( 1 ) ; inputMan = new InputController ( this ) ; players = new ArrayList < > ( ) ; physics = new Physics ( this ) ; soundMan = new SoundManager ( this ) ; players . add ( new Player ( "Hannes" , 3 ) ) ; players . add ( new Player ( "Horst" , 1 ) ) ; nextId = 1 ; }
tr	KEY	public void marcaNo ( ) { this . marcado = true ; }
tr	KEY	public boolean ifDead ( ) { return dead ; }
tr	KEY	public void rotateZ ( double radians ) ;
tr	KEY	public Profile getProfile ( ) { return this . profile ; }
tr	IDF	public void setAux2 ( String aux2 ) { this . aux2 = aux2 ; }
tr	KEY	public void setDuration ( double duration ) { this . duration = duration ; }
tr	IDF	public PackedWorld ( PackedWorld prev ) { super ( prev ) ; cells = 0 ; }
tr	IDF	@ Test public void add ( ) throws SQLException { Date inicio = new Date ( 2013 , 1 , 1 ) ; Proyecto proyecto = new Proyecto ( "Prueba" , 2 , inicio , inicio ) ; mySQLDB = new MYSQLDB ( ) ; String sql = "insert into proyecto (descripcionproy  estadoproy  fechainicio  fechafinal)" + "values ('" + proyecto . getDescripcionProyecto ( ) + "'  " + proyecto . getEstadoProyecto ( ) + "  " + "'" + proyecto . getFechainicio ( ) + "' '" + proyecto . getFechafinal ( ) + "')" ; mySQLDB . execute ( sql ) ; mySQLDB . closeExecute ( ) ; }
tr	KEY	void setPageNumber ( long value ) ;
tr	KEY	public Tarea ( ) { }
tr	KEY	private static boolean less ( int v , int w ) { return v < w ; }
tr	IDF	private static void createAndShowGUI ( ) { GameFrame frame = new GameFrame ( WIDTH , HEIGHT ) ; @ SuppressWarnings ( "unused" ) GameController controller = new GameController ( frame ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	IDF	protected WorldImpl ( WorldImpl prev ) { this . width = prev . width ; this . height = prev . height ; this . generation = prev . generation + 1 ; }
tr	KEY	public static final int [ ] getTermRange ( ) { return termRange ; }
tr	KEY	@ Override public double [ ] getWeights ( ) { double [ ] result = { 5 , 5 , 5 , 5 } ; return result ; }
tr	KEY	public JMenuItem getItemMenuPrincipal ( ) { return this . item_fichier_menuPrincipal ; }
tr	IDF	public int pack ( double red , double grn , double blu ) { return 255 << 24 | clip ( red , 0 , 255 ) << 16 | clip ( grn , 0 , 255 ) << 8 | clip ( blu , 0 , 255 ) ; }
tr	IDF	public void setBilling ( Address billing ) { this . billing = billing ; }
tr	KEY	public abstract boolean isDevice ( String deviceIdentifier ) ;
tr	IDF	public void mousePressed ( java . awt . event . MouseEvent evt ) { buttonSair_MenuPrincipalMousePressed ( evt ) ; }
tr	KEY	public Object parseObjectFromString ( String value ) { if ( objType == String . class ) { return value ; } try { if ( objType == boolean . class ) { if ( value != null ) { if ( value . equalsIgnoreCase ( "true" ) ) { return true ; } else if ( value . equalsIgnoreCase ( "false" ) ) { return false ; } } } else if ( objType . isEnum ( ) ) { return enum . valueOf ( ( class < enum > ) objType , value ) ; } else if ( objType == byte . class || objType == byte . class ) { return byte . parseByte ( value ) ; } else if ( objType == short . class || objType == short . class ) { return short . parseShort ( value ) ; } else if ( objType == Integer . class || objType == int . class ) { return Integer . parseInt ( value ) ; } else if ( objType == long . class || objType == long . class ) { return long . parseLong ( value ) ; } else if ( objType == float . class || objType == float . class ) { return float . parseFloat ( value ) ; } else if ( objType == double . class || objType == double . class ) { return double . parseDouble ( value ) ; } else if ( objType == Character . class ) { return ( value . length ( ) == 1 ? value . charAt ( 0 ) : null ) ; } else { System . out . println ( "Unsupported object type to parse from String : " + getObjType ( ) . getName ( ) ) ; } } catch ( NumberFormatException nfe ) { } return null ; }
tr	KEY	public long getTime ( ) { return time ; }
tr	IDF	public ProfileRequest card ( Card card ) { this . card = card ; return this ; }
tr	KEY	public FunctionDeclTree ( ) { }
tr	KEY	public boolean getPodou ( ) { return podou ; }
tr	IDF	public void actionPerformed ( ActionEvent e ) { if ( closeLevel ( ) ) { frame . setVisible ( false ) ; frame . dispose ( ) ; System . exit ( 0 ) ; } }
tr	KEY	public RecompensaBean ( ) { }
tr	IDF	private boolean [ ] getMissileGraphics ( int index ) { int iSize = getMissileSize ( index ) ; boolean [ ] bGraphics = new boolean [ MISSILE_WIDTH * iSize ] ; for ( int i = 0 ; i < bGraphics . length ; i ++ ) { bGraphics [ i ] = true ; } return bGraphics ; }
tr	KEY	public int getDecimalDigits ( ) { return decimalDigits ; }
tr	KEY	public NewsRequest createNewsRequest ( ) { return new NewsRequest ( ) ; }
tr	KEY	public Customer ( ) { }
tr	IDF	public DocumentListener getDocumentListener ( String action ) { return new UserInputListener ( action ) ; }
tr	KEY	protected abstract WorldImpl nextGeneration ( ) ;
tr	IDF	public void setLanguage ( String language ) { this . language = language ; }
tr	KEY	public UpdateSDB ( ) { }
tr	IDF	@ Override public void exitEscreva ( @ NotNull EnquantoParser . EscrevaContext ctx ) { }
tr	KEY	protected void interrupted ( ) { }
tr	IDF	@ Override public String toString ( ) { return String . valueOf ( val ) ; }
tr	IDF	public void set_damageType ( DamageType damageType ) { _damageType = damageType ; }
tr	IDF	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
tr	KEY	public void setRow ( int row ) { this . row = row ; }
tr	KEY	public double getPriceLevel9 ( ) { return priceLevel9 ; }
tr	IDF	public void messageDois ( ) { System . out . println ( "Cria uma nova mensagem" ) ; }
tr	KEY	public JSONWriter endObject ( ) throws JSONException { return this . end ( k , } ) ; }
tr	KEY	public int getX ( ) { return x ; }
tr	KEY	public void rotateY ( double radians ) ;
tr	KEY	private Commons ( ) { }
tr	IDF	public static void assertOrderedRelationsEqual ( Relation actual , Relation expected ) { assertOrderedMapsEqual ( actual . getColumnDefinitions ( ) , expected . getColumnDefinitions ( ) ) ; List < ? extends Iterable < Value >> actualValues = actual . getValues ( ) . collect ( Collectors . < Iterable < Value >> toList ( ) ) ; List < ? extends Iterable < Value >> expectedValues = expected . getValues ( ) . collect ( Collectors . < Iterable < Value >> toList ( ) ) ; assertIterablesEqual ( actualValues , expectedValues ) ; }
tr	KEY	public final List < File > getFilesWithinIncSub ( ) throws DirectoryNotOnDiskException , DiskReadException { checkExists ( ) ; return this . deepListFiles ( null , this ) ; }
tr	KEY	public int getSourceCount ( ) { return sources . size ( ) ; }
tr	KEY	public ObjectFactory ( ) { }
tr	KEY	public HumanPlugin ( ) { super ( new HumanPlayer ( ) ) ; }
tr	IDF	private int calculateMinWidth ( Graphics g , int lSq ) { Font f = g . getFont ( ) ; Font f4Pause = new Font ( f . getFontName ( ) , Font . BOLD , f . getSize ( ) + TetrisCanvas . getFontsizelarger ( ) ) ; Dimension d = pauseBox . calculateMinSize ( f4Pause , g ) ; int wMB = mainBox . calculateMinWidth ( lSq , d . width ) ; int wRight = calculateMinWidthRight ( g , lSq ) ; int w = wMB + TMargin . getPixelLen ( ) * 2 + TPad . getPixelLen ( ) + wRight ; return w ; }
tr	IDF	private static void parseInputLine ( String line ) { String [ ] args = line . trim ( ) . split ( "\\s+" ) ; if ( args . length < 1 ) { return ; } if ( args [ 0 ] . equals ( "help" ) ) { printCommandHelp ( ) ; return ; } else if ( args [ 0 ] . equals ( "list" ) ) { server . listDevices ( ) ; return ; } else if ( args [ 0 ] . equals ( "stop" ) ) { server . stopServer ( ) ; return ; } else if ( args [ 0 ] . equals ( "start" ) ) { if ( server . isServerRunning ( ) ) { System . err . println ( "Server already started" ) ; } else { server . startListeningToClients ( ) ; } return ; } else if ( args [ 0 ] . equals ( "r" ) ) { ArrayList < String > copy = ( ArrayList < String > ) jarFiles . clone ( ) ; for ( int i = 0 ; i < copy . size ( ) ; i ++ ) { String jar = copy . get ( i ) ; server . reloadJava ( jar ) ; } return ; } if ( args . length < 2 ) { System . err . println ( "Command error. 'help' for help.\n" ) ; return ; } if ( args [ 0 ] . equals ( "add" ) ) { String f = args [ 1 ] ; server . loadJava ( f ) ; return ; } else if ( args [ 0 ] . equals ( "remove" ) ) { String f = args [ 1 ] ; server . unloadJava ( f ) ; return ; } else if ( args [ 0 ] . equals ( "reload" ) ) { String f = args [ 1 ] ; server . reloadJava ( f ) ; return ; } else if ( ( args [ 0 ] . equals ( "addN" ) ) || ( args [ 0 ] . equals ( "addn" ) ) ) { String f = args [ 1 ] ; server . loadNative ( f ) ; return ; } else if ( ( args [ 0 ] . equals ( "removeN" ) ) || ( args [ 0 ] . equals ( "removen" ) ) ) { String f = args [ 1 ] ; server . unloadNative ( f ) ; return ; } else if ( ( args [ 0 ] . equals ( "reloadN" ) ) || ( args [ 0 ] . equals ( "reloadn" ) ) ) { String f = args [ 1 ] ; server . unloadNative ( f ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } while ( server . isAlreadyLoaded ( f ) ) { System . err . println ( "Waiting for " + f + " to unload" ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } server . loadNative ( f ) ; return ; } else if ( ( args [ 0 ] . equals ( "connect" ) ) || ( args [ 0 ] . equals ( "disconnect" ) ) ) { String host = args [ 1 ] ; int port = 7624 ; if ( args . length > 2 ) { String p = args [ 2 ] ; try { port = Integer . parseInt ( p ) ; } catch ( NumberFormatException e ) { System . err . println ( "Port not valid." ) ; return ; } } if ( args [ 0 ] . equals ( "connect" ) ) { server . connect ( host , port ) ; } else if ( args [ 0 ] . equals ( "disconnect" ) ) { server . disconnect ( host , port ) ; } return ; } System . err . println ( "Command error. 'help' for help.\n" ) ; }
tr	KEY	public abstract String toBase ( ) ;
tr	KEY	public NotebookDao ( ) { super ( ) ; }
tr	IDF	public void setSize ( double getEnergy ) { energyBarBarImage = new GreenfootImage ( "SystemItem//EnergyBar.png" ) ; setImage ( energyBarBarImage ) ; setLocation ( x , y ) ; if ( getEnergy <= 0.0 ) { getEnergy = 0.01 ; } energyBarBarImage . scale ( ( int ) ( ( ( double ) 780 ) * getEnergy ) + 1 , 13 ) ; }
tr	IDF	public Object getElementAt ( int i ) { return publishers [ i ] ; }
tr	IDF	String dump ( ) { return dump ( tree ) ; }
tr	IDF	public void setMetodo ( String strMetodo ) { this . set ( "method" , strMetodo ) ; }
tr	IDF	public Paint transform ( Node node ) { return node . getColor ( ) ; }
tr	KEY	public double getPriceLevel5 ( ) { return priceLevel5 ; }
tr	KEY	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	KEY	public void run ( ) { new Promocion ( ) . setVisible ( true ) ; }
tr	KEY	public static int monthNumber ( String month ) { int monthnum = 0 ; switch ( month ) { case "Jan" : return 1 ; case "Feb" : return 2 ; case "Mar" : return 3 ; case "Apr" : return 4 ; case "May" : return 5 ; case "Jun" : return 6 ; case "Jul" : return 7 ; case "Aug" : return 8 ; case "Sep" : return 9 ; case "Oct" : return 10 ; case "Nov" : return 11 ; case "Dec" : return 12 ; default : return monthnum ; } }
tr	IDF	@ Override default GSalary S ( double salary ) { return new GSalary ( ) { public < Company , Dept , SubUnit , Employee , Person , Salary > Salary accept ( SybAlg < Company , Dept , SubUnit , Employee , Person , Salary > alg ) { return alg . S ( salary * 1.1 ) ; } } ; }
tr	KEY	public DateComparer ( boolean sortDown ) { super ( sortDown ) ; }
tr	KEY	public int getTipodoc ( ) { return tipodoc ; }
tr	IDF	public void setPermisos ( Integer permisos ) { this . permisos = permisos ; }
tr	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { quitButtonActionPerformed ( evt ) ; }
tr	IDF	public void update ( float alpha ) { for ( Iterator it = sounds . iterator ( ) ; it . hasNext ( ) ; ) { Sound sound = ( Sound ) it . next ( ) ; sound . update ( soundListener , alpha ) ; if ( ! sound . isLive ( ) ) { it . remove ( ) ; } } }
tr	IDF	public static void securityGoalSimplification ( RequirementGraph req_model , ActorAssociationGraph actor_model , int scope ) throws IOException , ScriptException { String req_model_file = req_model . generateFormalExpressionToFile ( scope ) ; String actor_model_file = InfoEnum . current_directory + "/dlv/models/actor_association_model.dl " ; if ( actor_model . getElements ( ) . size ( ) != 0 ) { actor_model_file = actor_model . generateFormalExpressionToFile ( ) ; } String inference_rule = "" ; if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_bus.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/business_process_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_app.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . PHYSICAL . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_phy.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/deployment_model.dl " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( inference_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { CommandPanel . logger . info ( s ) ; if ( s . startsWith ( "is_critical" ) ) { s = s . replaceAll ( "is\\_critical\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setCriticality ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "5" , "none" , "none" ) ; } else if ( s . startsWith ( "non_deterministic" ) ) { s = s . replaceAll ( "non\\_deterministic\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setNon_deterministic ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "3" , "none" , "none" ) ; } } } input . close ( ) ; }
tr	IDF	private static final long [ ] mk_tokenSet_4 ( ) { long [ ] data = new long [ 260 ] ; data [ 0 ] = - 71776119061217288 ; data [ 1 ] = - 72057594037927937 ; for ( int i = 2 ; i <= 3 ; i ++ ) { data [ i ] = - 1 ; } for ( int i = 64 ; i <= 127 ; i ++ ) { data [ i ] = - 1 ; } return data ; }
tr	IDF	@ Override public void runTest ( ) { String s1 = "tiger" ; String s2 = "tgrie" ; System . out . println ( checkCharCount ( s1 , s2 ) ) ; System . out . println ( isScramble ( s1 , s2 ) ) ; dbg ( "123" . substring ( 0 , 2 ) ) ; dbg ( "123" . substring ( 2 ) ) ; dbg ( "312" . substring ( 3 - 2 ) ) ; dbg ( "312" . substring ( 0 , 3 - 2 ) ) ; }
tr	IDF	@ Override public int compareTo ( ReadOnlyInts o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff != 0 ) return diff ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff != 0 ) return diff ; } return 0 ; }
tr	IDF	public int createUser ( User newUser ) throws SQLException { String sql = "INSERT INTO cart_comp461_db.User (idUser  name " + "address  city  state  zip  phone) VALUES" + "(?  ?  ?  ?  ?  ?  ?)" ; ResultSet rs = null ; PreparedStatement ps = con . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setNull ( 1 , java . sql . Types . INTEGER ) ; ps . setString ( 2 , newUser . getName ( ) ) ; ps . setString ( 3 , newUser . getAddress ( ) ) ; ps . setString ( 4 , newUser . getCity ( ) ) ; ps . setString ( 5 , newUser . getState ( ) ) ; ps . setString ( 6 , newUser . getZip ( ) ) ; ps . setString ( 7 , newUser . getPhone ( ) ) ; ps . executeUpdate ( ) ; rs = ps . getGeneratedKeys ( ) ; rs . last ( ) ; lastUserAutoKey = rs . getInt ( 1 ) ; return lastUserAutoKey ; }
tr	IDF	@ Test public void testProducerWorkflow ( ) throws InterruptedException { USBEventProducer prod = new USBEventProducer ( ) ; DummyListener dl = new DummyListener ( ) ; prod . registerEventListener ( dl ) ; prod . receiveData ( new byte [ ] { ( byte ) Integer . parseInt ( "02" , 16 ) , ( byte ) Integer . parseInt ( "04" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) } , 7 ) ; prod . receiveData ( confirmation , 7 ) ; prod . receiveData ( new byte [ ] { ( byte ) Integer . parseInt ( "02" , 16 ) , ( byte ) Integer . parseInt ( "03" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) } , 7 ) ; prod . receiveData ( confirmation , 7 ) ; prod . receiveData ( new byte [ ] { ( byte ) Integer . parseInt ( "02" , 16 ) , ( byte ) Integer . parseInt ( "01" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) } , 7 ) ; prod . receiveData ( confirmation , 7 ) ; Thread . sleep ( 2000 ) ; prod . removeEventListener ( dl ) ; prod . receiveData ( new byte [ ] { ( byte ) Integer . parseInt ( "02" , 16 ) , ( byte ) Integer . parseInt ( "8a" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) , ( byte ) Integer . parseInt ( "00" , 16 ) } , 7 ) ; prod . receiveData ( confirmation , 7 ) ; Thread . sleep ( 2000 ) ; assert . assertFalse ( dl . hitEvent ) ; assert . assertTrue ( dl . dartMissed ) ; assert . assertTrue ( dl . bounceOut ) ; assert . assertTrue ( dl . nextPlayer ) ; }
tr	IDF	@ Override public boolean signIn ( long nodeId , String password ) { this . nodeId = nodeId ; this . password = password ; ClientAuthenticationMessage message = new ClientAuthenticationMessage ( messageManager . getProtocolParameters ( ) , "$" + String . valueOf ( nodeId ) , password ) ; this . reconnect = true ; messageManager . sendMessage ( message ) ; return true ; }
tr	IDF	public Joueur [ ] getAdversairesEnVie ( ) { ArrayList < Joueur > liste_adversaires = new ArrayList < Joueur > ( ) ; for ( int i = 0 ; i < adversaires . size ( ) ; i ++ ) if ( ! adversaires . get ( i ) . aPerdu ( ) ) liste_adversaires . add ( adversaires . get ( i ) ) ; return liste_adversaires . toArray ( new Joueur [ liste_adversaires . size ( ) ] ) ; }
tr	KEY	public void setPixel ( int x , int y , int rgb [ ] ) { }
tr	IDF	public String cookieLogin ( ) throws Exception { logger . info ( "user cookieLogin start." ) ; user = CookieUtils . getCookie ( request ) ; if ( user != null ) { String login = userServiceImpl . cookieLogin ( user , session ) ; if ( login != null ) { this . setMsg ( login ) ; CookieUtils . cleanCookie ( request , response ) ; logger . info ( "user cookieLogin end." ) ; return ResultConstants . LOGIN_FAIL ; } User currUser = ( User ) session . get ( OtherConstants . CURRENT_USER ) ; if ( OtherConstants . ADMIN_GROUP_ID . equals ( currUser . getAuth ( ) ) ) { logger . info ( "Admin user login system !" ) ; return ResultConstants . LOGIN_SUCCESS_ADMIN ; } if ( OtherConstants . USER_GROUP_ID . equals ( currUser . getAuth ( ) ) ) { logger . info ( "A user login system !" ) ; return ResultConstants . LOGIN_SUCCESS_USER ; } } CookieUtils . cleanCookie ( request , response ) ; logger . info ( "user cookieLogin end." ) ; return ResultConstants . LOGIN_FAIL ; }
tr	IDF	private int readHeader ( ) throws IOException , JDBFException { byte abyte0 [ ] = new byte [ 16 ] ; try { stream . readFully ( abyte0 ) ; } catch ( EOFException eofexception ) { throw new JDBFException ( "Unexpected end of file reached." ) ; } int i = abyte0 [ 8 ] ; if ( i < 0 ) i += 256 ; i += 256 * abyte0 [ 9 ] ; i = -- i / 32 ; i -- ; try { stream . readFully ( abyte0 ) ; } catch ( EOFException eofexception1 ) { throw new JDBFException ( "Unexpected end of file reached." ) ; } return i ; }
tr	KEY	public void startGame ( ) { start = true ; }
tr	IDF	public OrderItemDAO ( ) throws NamingException , SQLException { lastOrderItemAutoKey = - 1 ; Context cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( "java:/comp/env/jdbc/CartDB" ) ; con = ds . getConnection ( ) ; }
tr	KEY	public void setCountsSec ( double countsSec ) { this . countsSec = countsSec ; }
tr	KEY	public void start ( ) { new Thread ( this ) . start ( ) ; }
tr	IDF	public void diffuseUpdateObject ( String objectId , Vector3d delatTrans , Vector3d delatRot ) ;
tr	IDF	public UnitOfWork using ( ICallBackDelegate delegateWork ) { this . delegate = delegateWork ; return this ; }
tr	IDF	public String print ( String whoOrWhat ) { if ( whoOrWhat . length ( ) > 3 ) { whoOrWhat = whoOrWhat . substring ( 0 , 3 ) ; } String show = "" ; for ( int row = localMap . height ( ) - 1 ; row >= 0 ; row -- ) { if ( row != lp . y ) { for ( int col = 0 ; col < localMap . width ( ) ; col ++ ) { show += "|" + STEP ; } show += "|\n" ; } else { for ( int col = 0 ; col < localMap . width ( ) ; col ++ ) { if ( col != lp . x ) { show += "|" + STEP ; } else { show += "|  " + whoOrWhat + "  " ; } } show += "|\n" ; } } return show ; }
tr	IDF	@ Override public void addCharacter ( String character , CharacterHandle handle ) { outs . put ( character , handle ) ; }
tr	KEY	@ Override protected void doInBackground ( ) throws Exception { clearTempFiles ( ) ; createTempVids ( ) ; return null ; }
tr	KEY	public int getStockDisponible ( ) { return stockDisponible ; }
tr	IDF	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c ==   || c == 	 ) ; switch ( c ) { case 0 : return null ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c ==  || c ==  ) { throw x . syntaxError ( "Missing close quote '" + q + "'." ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case   : x . back ( ) ; return "" ; default : x . back ( ) ; return x . nextTo (   ) ; } }
tr	IDF	public static void envoyerMessage ( String message ) { try { out . writeObject ( message ) ; out . flush ( ) ; } catch ( Exception e ) { fenetre . changerVue ( new MessageView ( "Connexion rompu !" , new AccueilView ( ) , true ) ) ; } }
tr	IDF	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
tr	IDF	private static boolean contains ( Node biggerTree , Node smallerTree ) { if ( biggerTree == null && smallerTree == null ) { return true ; } else if ( ( biggerTree == null && smallerTree != null ) || ( biggerTree != null && smallerTree == null ) ) { return false ; } if ( biggerTree . val == smallerTree . val ) { boolean a = contains ( biggerTree . left , smallerTree . left ) ; boolean b = contains ( biggerTree . right , smallerTree . right ) ; if ( a && b == true ) { return true ; } } boolean a = contains ( biggerTree . left , smallerTree ) ; boolean b = contains ( biggerTree . right , smallerTree ) ; return a || b ; }
tr	IDF	protected void switchUsable ( ) { if ( isUsable == true ) { isUsable = false ; _confirmAudio . setEnabled ( false ) ; _confirmVideo . setEnabled ( false ) ; _confirmBoth . setEnabled ( false ) ; } else { isUsable = true ; _confirmAudio . setEnabled ( true ) ; _confirmVideo . setEnabled ( true ) ; _confirmBoth . setEnabled ( true ) ; } }
tr	IDF	private void bSlideLeftActionPerformed ( java . awt . event . ActionEvent evt ) { _cuniv . p2cUpdateObject ( currentObjName , new Vector3d ( - Translation_Value , 0 , 0 ) , new Vector3d ( 0 , 0 , 0 ) ) ; }
tr	IDF	public String getStringValue ( String encoding ) throws UnsupportedEncodingException { return new String ( value , encoding ) ; }
tr	IDF	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) == view . getBoutonOrientation ( ) ) { orientation = ! ( orientation ) ; } else if ( arg0 . getSource ( ) == view . getBoutonAuto ( ) ) { autoPlacement ( ) ; } else if ( arg0 . getSource ( ) == view . getBoutonAnnuler ( ) ) { annulerPlacement ( ) ; } else if ( arg0 . getSource ( ) == view . getBoutonValider ( ) ) { validerPlacement ( ) ; } }
tr	KEY	protected boolean isServerRunning ( ) { return mainThreadRunning ; }
tr	KEY	public String [ ] getColumnNames ( ) { return this . columnNames ; }
tr	IDF	public FriendshDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
tr	KEY	public void setLastUpdate ( double lastUpdate ) { this . lastUpdate = lastUpdate ; }
tr	KEY	public final PathIterator getPathIterator ( AffineTransform at ) { if ( at == null ) { return new CopyIterator ( this ) ; } else { return new TxIterator ( this , at ) ; } }
tr	KEY	public int getGeneration ( ) { return this . generation ; }
tr	KEY	public void setSpeichergroesse ( int speichergroesse ) { this . speichergroesse = speichergroesse ; }
tr	KEY	public int getMaxRestarts ( ) { return maxRestarts ; }
tr	KEY	public synchronized void xsetRightThumbMouse ( ) { isLeftThumbMouse = false ; isRightThumbMouse = true ; }
tr	IDF	@ Override public void addParameter ( Token token ) throws ParsingException { String value = token . getStringAndReset ( ) ; value = Characters . convertColumnName ( value ) ; log . debug ( value ) ; this . tempMainQuery . parameters . add ( value ) ; }
tr	KEY	public synchronized void xassignL2KeyCode ( int code ) { l2 = code ; }
tr	KEY	@ Override public boolean isNatural ( ) { return false ; }
tr	KEY	public abstract void update ( ) ;
tr	IDF	public MenuSimulateur ( ) { init ( ) ; initJpanel ( ) ; initListener ( ) ; this . setVisible ( true ) ; }
tr	KEY	public ChoixModeView ( ) { super ( ) ; this . controleur = new ChoixModeController ( this ) ; }
tr	IDF	private void insertImageToWindow ( Image image , int index ) { if ( isIndexOutOfWindow ( index ) ) { return ; } windowTaskList . get ( index ) . image = image ; }
tr	IDF	public Player getPlayer ( ) { return player . clone ( ) ; }
tr	KEY	public void setBatchNumber ( int batchNumber ) { this . batchNumber = batchNumber ; }
tr	IDF	public XbpadBridge ( XbpadPresetContainer con ) { container = con ; if ( container == null ) { System . out . println ( "Error from bridge" ) ; } }
tr	IDF	@ Override public void handle ( ActionEvent e ) { screenController . setScreen ( "USER_FIND_SCREEN" ) ; }
tr	KEY	private static String getCodePath ( ) { if ( codePath != null ) { return codePath ; } else { return getPath ( "../programebrincando/src/plp/programebrincando/arduino/arduino.ino" ) ; } }
tr	KEY	public int getId ( ) { return id ; }
tr	IDF	private ExtQuery createExtQuery ( ) { ExtQuery extQuery = new ExtQuery ( id , text , parameters ) ; extQuery . setWhereItStarts ( startPosition , startParameter ) ; return extQuery ; }
tr	IDF	@ Override public void remove ( Geometry child ) { kids . remove ( child ) ; }
tr	KEY	public void setPlanIep ( boolean planIep ) { this . planIep = planIep ; }
tr	IDF	@ Override public User getUserByPK ( String email ) { try { IUserDao _dao = getIUserDao ( ) ; User _result = _dao . findByPrimaryKey ( email ) ; return _result ; } catch ( Exception _e ) { _e . printStackTrace ( ) ; } return null ; }
tr	KEY	public TBlock_LOpposite ( ) { super ( ) ; }
tr	IDF	public InviteRes findByPrimaryKey ( InviteResPk pk ) throws InviteResDaoException ;
tr	KEY	public Housing ( ) { this ( null , null , null , null , null , null ) ; }
tr	KEY	protected boolean editorHasChanged ( ) { return codeEditorChanged ; }
tr	IDF	public void refreshPanel ( ) { userLijst . clear ( ) ; userInfoPanel . clear ( ) ; }
tr	KEY	public void setTilePairs ( int tilePairs ) { this . tilePairs = tilePairs ; }
tr	IDF	@ Override public void actionPerformed ( ActionEvent e ) { JComboBox cb = ( JComboBox ) e . getSource ( ) ; String name = ( String ) cb . getSelectedItem ( ) ; container . setCurrentPreset ( name ) ; setupButtons ( ) ; repaintButtons ( ) ; }
tr	IDF	public Database ( String name ) { this . name = name ; }
tr	IDF	public static void newTesting ( ) throws IOException , ScriptException { CommandPanel . setup ( ) ; HolisticSecurityGoalModel hsgm = new HolisticSecurityGoalModel ( ) ; HSGMInference . importHolisticSecurityGoalModel ( hsgm , true ) ; LinkedList < String > result = HSGMInference . sanityCheckRepeat ( hsgm ) ; if ( result . size ( ) > 0 ) { System . out . println ( result . get ( 0 ) ) ; } }
tr	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jtPedidosBuscarActionPerformed ( evt ) ; }
tr	IDF	public ParsingException ( Exception e ) { super ( e ) ; }
tr	KEY	@ Override public void pathDone ( ) { }
tr	IDF	public ReceiveThread ( Connection connection ) { this . connection = connection ; }
tr	IDF	private void canonicalize ( ) { while ( true ) { if ( inode == null ) break ; else if ( inode . subtree == null ) { inode = inode . parent ; if ( inode == null ) break ; else ++ inode . index ; } else if ( ! ( inode . subtree instanceof Node ) ) { if ( inode . index < ( ( Object [ ] ) inode . subtree ) . length ) break ; else { inode = inode . parent ; if ( inode == null ) break ; else ++ inode . index ; } } else { Node node = ( Node ) inode . subtree ; if ( inode . index == 0 ) inode = new IteratorNode ( node . left , 0 , inode ) ; else if ( inode . index == elementSize ( node . element ) + 1 ) inode = new IteratorNode ( node . right , 0 , inode . parent ) ; else break ; } } }
tr	IDF	@ Override public OutputStream getOutputStream ( ) { return toDriver . getOutputStream ( ) ; }
tr	IDF	public boolean dansTirsSurJoueur ( Position p ) { Tir [ ] tirs = getTirsSurJoueur ( ) ; for ( int i = 0 ; i < tirs . length ; i ++ ) if ( tirs [ i ] . getPosition ( ) . equals ( p ) ) return true ; return false ; }
tr	IDF	public UserCreationScreen ( Stage primaryStage ) { this . primaryStage = primaryStage ; }
tr	KEY	public static IntervalManager getInstance ( ) { if ( instance == null ) { instance = new IntervalManager ( ) ; } return instance ; }
tr	IDF	private void addMessageToJsfContext ( FacesMessage facesMessage ) { FacesContext . getCurrentInstance ( ) . addMessage ( null , facesMessage ) ; }
tr	IDF	public void reset ( ) { clearRegisters ( ) ; setPosition ( 0 ) ; setScanline ( 0 ) ; setPictureScanline ( 0 ) ; setPosP0 ( 0 ) ; setPosP1 ( 0 ) ; setPosM0 ( 0 ) ; setPosM1 ( 0 ) ; setPosBL ( 0 ) ; mP0Visible = false ; mP1Visible = false ; mM0Visible = false ; mM1Visible = false ; mPFVisible = false ; mBLVisible = false ; mP0InPixel = false ; mP1InPixel = false ; mM0InPixel = false ; mM1InPixel = false ; mPFInPixel = false ; mBLInPixel = false ; mP0PixelFilled = false ; mP1PixelFilled = false ; mM0PixelFilled = false ; mM1PixelFilled = false ; mPFPixelFilled = false ; mBLPixelFilled = false ; mP0Graphics = getPlayerGraphics ( 0 ) ; mP1Graphics = getPlayerGraphics ( 1 ) ; mM0Graphics = getMissileGraphics ( 0 ) ; mM1Graphics = getMissileGraphics ( 1 ) ; mPFGraphics = getPlayfieldGraphics ( ) ; mBLGraphics = getBallGraphics ( ) ; mPM0Copies = 1 ; mPM1Copies = 1 ; mPM0CopySpacing = 1 ; mPM1CopySpacing = 1 ; mDGRP0 = 0 ; mDGRP1 = 0 ; mDENABL = 0 ; mVerticalDelayP0 = false ; mVerticalDelayP1 = false ; mVerticalDelayBL = false ; mRDY = false ; }
tr	KEY	public void setHasBigBlind ( boolean hasBigBlind ) { this . hasBigBlind = hasBigBlind ; }
tr	IDF	@ Override public ArrayList < UsuarioBean > getPage ( int intRegsPerPag , int intPage , ArrayList < FilterBean > hmFilter , HashMap < String , String > hmOrder ) throws Exception { ArrayList < Integer > arrId ; ArrayList < UsuarioBean > arrUsuario = new ArrayList < > ( ) ; try { oMysql . conexion ( enumTipoConexion ) ; arrId = oMysql . getPage ( "usuario" , intRegsPerPag , intPage , hmFilter , hmOrder ) ; Iterator < Integer > iterador = arrId . listIterator ( ) ; while ( iterador . hasNext ( ) ) { UsuarioBean oUsuarioBean = new UsuarioBean ( iterador . next ( ) ) ; arrUsuario . add ( this . get ( oUsuarioBean ) ) ; } oMysql . desconexion ( ) ; return arrUsuario ; } catch ( Exception e ) { throw new Exception ( "UsuarioDao.getPage: Error: " + e . getMessage ( ) ) ; } }
tr	KEY	float getPower ( ) ;
tr	IDF	@ Override public String toString ( ) { String data ; DecimalFormat df = new DecimalFormat ( "000000000000" ) ; data = df . format ( idremito ) ; return data ; }
tr	IDF	private void butRotXActionPerformed ( java . awt . event . ActionEvent evt ) { _cuniv . p2cUpdateObject ( currentObjName , new Vector3d ( 0 , 0 , 0 ) , new Vector3d ( Rotation_Value , 0 , 0 ) ) ; }
tr	KEY	public int getHeight ( ) { return this . height ; }
tr	IDF	@ Override public void render ( Graphics2D g ) { int o = 192 ; int h = 18 ; g . setColor ( Color . white ) ; g . drawString ( "Toggle debug mode: d" , 16 , o ) ; g . drawString ( "Add player A units (1/10): Q/W" , 16 , o + h ) ; g . drawString ( "Add player B units (1/10): A/S" , 16 , o + 2 * h ) ; g . drawString ( "Add Chuck Norris: X" , 16 , o + 3 * h ) ; g . drawString ( "Zoom: +  -" , 16 , o + 4 * h ) ; g . drawString ( "Units: " + gm . getGameEntityCount ( ) , 16 , o + 5 * h ) ; g . drawString ( String . format ( "FPS (logic/render): %.2f/%.2f" , gm . getLogicFPS ( ) , gm . getRenderFPS ( ) ) , 16 , o + 6 * h ) ; }
tr	IDF	public FTreeSet < Elt > union ( Collection < ? extends Elt > coll ) { if ( coll == this || coll . isEmpty ( ) ) return this ; else if ( coll instanceof FTreeSet && eql ( comp , ( ( FTreeSet ) coll ) . comp ) ) { FTreeSet < Elt > fts = ( FTreeSet < Elt > ) coll ; if ( isEmpty ( ) ) return fts ; Object t = union ( tree , fts . tree ) ; return make ( t , comp ) ; } else { FTreeSet < Elt > fts = new FTreeSet < Elt > ( coll , comp ) ; Object t = union ( tree , fts . tree ) ; return make ( t , comp ) ; } }
tr	KEY	public Wizard ( ) { this . name = "wizard" ; }
tr	IDF	ArrayList < TreeNode > combineTrees ( int val , ArrayList < TreeNode > leftTrees , ArrayList < TreeNode > rightTrees ) { ArrayList < TreeNode > result = new ArrayList < TreeNode > ( ) ; for ( TreeNode left : leftTrees ) { for ( TreeNode right : rightTrees ) { TreeNode node = new TreeNode ( val ) ; node . left = left ; node . right = right ; result . add ( node ) ; } } return result ; }
tr	KEY	public long getNumber ( ) { return number ; }
tr	KEY	public GetMessageStatusesByBatch createGetMessageStatusesByBatch ( ) { return new GetMessageStatusesByBatch ( ) ; }
tr	KEY	public abstract void delete ( T t ) ;
tr	IDF	public void ChessVanillaGraphical ( ) { JPanel panel = new JPanel ( ) ; Dimension boardSize = new Dimension ( 500 , 600 ) ; lPane = new JLayeredPane ( ) ; panel . add ( lPane ) ; lPane . setPreferredSize ( boardSize ) ; lPane . addMouseListener ( this ) ; lPane . addMouseMotionListener ( this ) ; chessBoard = new JPanel ( ) ; lPane . add ( chessBoard , JLayeredPane . DEFAULT_LAYER ) ; chessBoard . setLayout ( new GridLayout ( 8 , 8 ) ) ; chessBoard . setSize ( 500 , 500 ) ; chessBoard . setBounds ( 0 , 0 , 500 , 500 ) ; for ( int i = 0 ; i < 64 ; i ++ ) { JPanel tile = new JPanel ( new BorderLayout ( ) ) ; chessBoard . add ( tile ) ; int row = ( i / 8 ) % 2 ; if ( row == 0 ) { tile . setBackground ( i % 2 == 0 ? Color . gray : Color . white ) ; } else { tile . setBackground ( i % 2 == 0 ? Color . white : Color . gray ) ; } } initializeGame ( ) ; }
tr	IDF	public Pessoa getPessoa ( String nome , String sexo ) throws Exception { switch ( sexo ) { case "M" : sexo = "Masculino" ; return new Homem ( nome , sexo ) ; case "F" : sexo = "Feminino" ; return new Mulher ( nome , sexo ) ; default : throw new Exception ( "Sexo indefinido" ) ; } }
tr	KEY	public synchronized int xgetD1RepeatDelay ( ) { return d1RD ; }
tr	IDF	public static Set < Remito > getAll ( ) throws SQLException { Set < Remito > res = new HashSet < > ( ) ; sql = "SELECT * FROM CLIENTES_REMITOS " ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { while ( rs . next ( ) ) { res . add ( DbToObj ( rs ) ) ; } } return res ; }
tr	IDF	@ AfterClass public static void tearDownClass ( ) throws Exception { ic . unbind ( "java:/comp/env/jdbc/CartDB" ) ; ic . unbind ( "java:/comp/env/jdbc" ) ; ic . unbind ( "java:/comp/env" ) ; ic . unbind ( "java:/comp" ) ; ic . unbind ( "java:" ) ; }
tr	IDF	public void setPhoneNumber1 ( PhoneNumber phoneNumber1 ) { this . phoneNumber1 = phoneNumber1 ; }
tr	IDF	public void actionPerformed ( ActionEvent e ) { m_uiLoadState_actionPerformed ( e ) ; }
tr	KEY	public void setScroe ( int scroe ) { this . scroe = scroe ; }
tr	KEY	public int getVitesse ( ) { return vitesse ; }
tr	IDF	@ Override public void afterCommand ( VcsCommand < ? > command ) { for ( VcsCommand . Listener listener : listeners ) { listener . afterCommand ( command ) ; } }
tr	KEY	public void setaProcesar ( int aProcesar ) { this . aProcesar = aProcesar ; }
tr	KEY	public int getIntExit ( ) { return intExit ; }
tr	IDF	private static Object join ( Object left , Object right ) { if ( left == null ) return right ; else if ( right == null ) return left ; else { Object m = min ( right ) ; return concat ( m , hashCode ( m ) , left , lessMin ( right ) ) ; } }
tr	IDF	public Point ( int x , int y , int value ) { this . x = x ; this . y = y ; this . value = value ; }
tr	IDF	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( 5 , 5 , 9 , 4 ) ; Rectangle _rec = new Rectangle ( 10 , 10 , 9 , 4 ) ; Rectangle __rec = new Rectangle ( 15 , 15 , 9 , 4 ) ; ABObject ob = new ABObject ( rec , ABType . Wood ) ; ABObject _ob = new ABObject ( _rec , ABType . Wood ) ; ABObject __ob = new ABObject ( __rec , ABType . Wood ) ; List < Point2D > edge = QualitativeRep . UpperEdge ( ob ) ; List < ABObject > obs = new ArrayList < ABObject > ( ) ; obs . add ( ob ) ; obs . add ( _ob ) ; obs . add ( __ob ) ; List < ABObject > above = new ArrayList < ABObject > ( ) ; QualitativeRep . AboveRelation ( ob , obs , above ) ; for ( int i = 0 ; i < above . size ( ) ; i ++ ) { System . out . println ( "ABove ob: " + above . get ( i ) . getLocation ( ) ) ; } System . out . println ( QualitativeRep . TouchRelation ( _ob , __ob ) ) ; System . out . println ( QualitativeRep . RightPoint ( ob , _ob ) ) ; System . out . println ( QualitativeRep . LeftPoint ( ob , _ob ) ) ; System . out . println ( QualitativeRep . CenterPoint ( ob , _ob ) ) ; System . out . println ( QualitativeRep . AboveRelation ( __ob , _ob ) ) ; }
tr	KEY	public Builder hotel ( int starRating ) { this . starRating = starRating ; return this ; }
tr	KEY	public Map ( ) { super ( "Map" ) ; }
tr	KEY	static public int getYinYangByYear ( int year ) { return ( year - 4 ) % 60 % 2 ; }
tr	KEY	public abstract void parse ( String responseString ) ;
tr	IDF	public JSONArray put ( double value ) throws JSONException { double d = new double ( value ) ; JSONObject . testValidity ( d ) ; put ( d ) ; return this ; }
tr	IDF	public byte [ ] getEncoded ( ) { byte [ ] result = new byte [ 0 ] ; for ( AuthenticationObjectDirectoryEntry e : entries ) { result = ElementaryFileObjectDirectory . append ( result , e . getDERObject ( ) . getDEREncoded ( ) ) ; } return result ; }
tr	KEY	public SudokuPuzzle ( ) { super ( 0 , getRuleset ( ) ) ; }
tr	KEY	public void setWidth ( long value ) { this . width = value ; }
tr	IDF	@ Override protected void setEstadoEdicao ( ) { jTFChamado . setEditable ( true ) ; jTFFerramenta . setEditable ( true ) ; jTFChamado . requestFocusInWindow ( ) ; }
tr	KEY	public synchronized int xgetRepatDelay ( ) { return repeatDelay ; }
tr	IDF	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) ; advanceSolution ( newOne , ore , mineral , yield , tax ) ; if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addAll ( solveForMineral ( newOne , nextOne , ores , yield , tax ) ) ; } } } return solutions ; } else if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveForMineral ( input , nextOne , ores , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	IDF	public void merge ( String mp3Input1 , String mp3Input2 , String outFile ) { _processString = "avconv -i '" + mp3Input1 + "' -i '" + mp3Input2 + "' -filter_complex amix=inputs=2:duration=longest '" + outFile + "'" ; _isWorking = true ; this . execute ( ) ; }
tr	IDF	public static void main ( String [ ] args ) { System . out . println ( "-- ForkJoin ---------------------------------------" ) ; int [ ] items = new int [ 40 ] ; for ( int i = 0 ; i < 40 ; i ++ ) items [ i ] = i ; ForkJoinPool pool = new ForkJoinPool ( 10 ) ; pool . invoke ( new Task ( items ) ) ; System . out . println ( "*** All Done ***" ) ; }
tr	KEY	public final void putAll ( Map < ? extends Key , ? extends Val > m ) { throw new UnsupportedOperationException ( ) ; }
tr	KEY	public ImageResponse createImageResponse ( ) { return new ImageResponse ( ) ; }
tr	IDF	public static BLOBEnables parseBLOBEnable ( String BLOBEnable ) throws IllegalArgumentException { if ( BLOBEnable . compareTo ( "Never" ) == 0 ) { return BLOBEnables . NEVER ; } else if ( BLOBEnable . compareTo ( "Also" ) == 0 ) { return BLOBEnables . ALSO ; } else if ( BLOBEnable . compareTo ( "Only" ) == 0 ) { return BLOBEnables . ONLY ; } throw new IllegalArgumentException ( "Invalid BLOBEnable String: '" + BLOBEnable + "'" ) ; }
tr	KEY	public List createList ( ) { return new List ( ) ; }
tr	KEY	public boolean isComplete ( ) { return complete ; }
tr	IDF	public void makeTable ( String tableName ) { String sql ; try { if ( overwrite ) { if ( tableExists ( tableName ) ) { stmt = conn . createStatement ( ) ; stmt . executeUpdate ( "DROP TABLE " + tableName ) ; stmt . close ( ) ; conn . commit ( ) ; } stmt = conn . createStatement ( ) ; sql = "CREATE TABLE " + tableName + "(" + "SOURCE VARCHAR(25)  " + "RELDEPTH NUMBER  " + "ID NUMBER(19) NOT NULL  " + "TIME_ TIMESTAMP  " + "DURATION NUMBER  " + "DEPTH NUMBER  " + "LON NUMBER  " + "LAT NUMBER  " + "DISTANCE NUMBER  " + "STATUS VARCHAR(3)  " + "DESTINATION VARCHAR(25)  " + "NODATA NUMBER(1)  " + "RELEASE VARCHAR(25))" ; stmt . execute ( sql ) ; sql = "SELECT AddGeometryColumn ('public' " + tableName + " 'geom' 4326 'POINT' 3)" ; stmt . execute ( sql ) ; stmt . close ( ) ; conn . commit ( ) ; System . out . println ( "Trajectory table setup complete." ) ; } sql = "INSERT INTO " + tableName + "(" + "SOURCE  " + "RELDEPTH  " + "ID  " + "TIME_  " + "DURATION  " + "DEPTH  " + "LON  " + "LAT  " + "DISTANCE  " + "STATUS  " + "DESTINATION  " + "NODATA  " + "RELEASE  geom) " + "VALUES(? ? ? ? ? ? ? ? ? ? ? ? ? ST_SetSRID(ST_MakePoint(?  ?  ?)  4326));" ; ps1 = conn . prepareStatement ( sql ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	IDF	public List < String > getFilterList ( ) { if ( filterList == null ) { filterList = new ArrayList < String > ( ) ; } return filterList ; }
tr	IDF	@ Override public void paint ( Graphics graph ) { Date now = new Date ( ) ; if ( now . after ( end ) ) { if ( now . getTime ( ) < end . getTime ( ) + duration ) { die ( ( Graphics2D ) graph ) ; } } else { show ( ( Graphics2D ) graph ) ; } }
tr	KEY	protected Watcher ( ) { this ( true ) ; }
tr	IDF	public NodeLVL1 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL1 . ds = ds . clone ( ) ; }
tr	IDF	public void draw ( BufferedImage canvas , boolean drawEdge , boolean drawCorners ) { for ( int y = 2 ; y < _height - 2 ; y ++ ) for ( int x = 2 ; x < _width - 2 ; x ++ ) { if ( _image [ y ] [ x ] == FILLED ) { canvas . setRGB ( x + _left , y + _top , ImageSegmenter . _drawColor [ _type ] ) ; } else if ( drawEdge && _image [ y ] [ x ] == EDGE ) { canvas . setRGB ( x + _left , y + _top , 000000 ) ; } } if ( drawCorners ) { findLines ( ) ; if ( _lines != null ) for ( LineSegment line : _lines ) line . draw ( canvas . createGraphics ( ) , _left , _top ) ; } }
tr	IDF	public static INDISwitchProperty createSaveableSwitchProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission , int timeout , SwitchRules rule ) throws IllegalArgumentException { INDISwitchProperty sp = loadSwitchProperty ( driver , name ) ; if ( sp == null ) { sp = new INDISwitchProperty ( driver , name , label , group , state , permission , timeout , rule ) ; sp . setSaveable ( true ) ; } return sp ; }
tr	IDF	private static List < Integer > notIn ( int [ ] a , int [ ] b ) { List < Integer > result = new ArrayList < > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < b . length ; i ++ ) { int idx = Arrays . binarySearch ( a , b [ i ] ) ; if ( idx < 0 ) { result . add ( b [ i ] ) ; } } return result ; }
tr	IDF	private final String getChunk ( String s , int slength , int marker ) { StringBuilder chunk = new StringBuilder ( ) ; char c = s . charAt ( marker ) ; chunk . append ( c ) ; marker ++ ; if ( isDigit ( c ) ) { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( ! isDigit ( c ) ) break ; chunk . append ( c ) ; marker ++ ; } } else { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( isDigit ( c ) ) break ; chunk . append ( c ) ; marker ++ ; } } return chunk . toString ( ) ; }
tr	KEY	protected void end ( ) { }
tr	KEY	public boolean isSel ( ) { return sel ; }
va	KEY	public static double millisToSeconds ( double millis ) { return millis / 1000f ; }
va	KEY	public abstract Rectangle getNeighbourBounds ( ) ;
va	IDF	protected long playerCanWinInOneRound ( char playerColour , char enemyColour , Game game ) { return new PlayerCanWinInOneRound ( ) . evaluate ( playerColour , enemyColour , game , null ) ; }
va	IDF	@ Override public void error ( MediaPlayer arg0 ) { }
va	KEY	public void setLockedByPOP3 ( boolean isLockedByPOP3 ) { this . isLockedByPOP3 = isLockedByPOP3 ; }
va	KEY	public synchronized void xsetD4InitialDelay ( int a ) { d4ID = a ; }
va	IDF	public Tree ( Tree other ) { root = new Leaf ( other . getRoot ( ) ) ; title = other . getTitle ( ) ; geneticCount = other . getGeneticCount ( ) ; }
va	KEY	private static void createInfo ( ) { MainMenuUI mainMenu = new MainMenuUI ( ) ; int option = mainMenu . createInformation ( ) ; switch ( option ) { case 1 : createProduct ( ) ; break ; case 2 : createCategory ( ) ; break ; case 3 : createUser ( ) ; break ; case 0 : break ; default : mainMenu . showOptionNotValid ( ) ; } }
va	KEY	public int getStart ( ) { return start ; }
va	KEY	public void setUp ( ) { }
va	IDF	void visit ( Block block ) ;
va	IDF	public static < T > Subscription assertCount ( Observable < T > in , final int max ) { return assertCountThen ( in , new Action0 ( ) { @ Override public void call ( ) { } } , max ) ; }
va	IDF	protected int getTopLine ( int y ) { Dimension boardSize = getBoardSize ( ) ; Dimension windowSize = getWindowFavoriteSize ( ) ; return ( y * windowSize . height ) / boardSize . height + 1 ; }
va	IDF	public void winForm ( boolean clientWin ) { if ( isClient ) { MainApplication . ticTacToePlay . getPlayerOne ( ) . incrementNumberOfPlays ( ) ; if ( clientWin ) { MainApplication . ticTacToePlay . getPlayerOne ( ) . incrementNumberOfWins ( ) ; } else { MainApplication . ticTacToePlay . getPlayerTwo ( ) . incrementNumberOfWins ( ) ; } System . out . println ( "Number of plays: " + MainApplication . ticTacToePlay . getPlayerOne ( ) . getNumberOfPlays ( ) ) ; } resultsWindow = new ResultWindow ( this , isNetwork , network ) ; resultsWindow . setLocationRelativeTo ( null ) ; resultsWindow . setNetPop ( clientWin , isClient , false ) ; TicTacToeUIApp . getApplication ( ) . show ( resultsWindow ) ; resultsWindow . setResizable ( false ) ; resultsWindow . setSize ( 450 , 280 ) ; setNoneClickable ( ) ; }
va	KEY	public void setResolution ( double resolution ) { this . resolution = resolution ; }
va	IDF	public GameOverFrame ( Player player ) { this . player = player ; initComponents ( ) ; scoreValueLabel . setText ( Integer . toString ( player . getScore ( ) ) ) ; }
va	IDF	public void setBillingCountry ( String billingCountry ) { this . billingCountry = billingCountry ; }
va	IDF	public void run ( ) { try { Thread . sleep ( 1000 ) ; mn . waitToProceed ( ) ; } catch ( InterruptedException x ) { x . printStackTrace ( ) ; } }
va	KEY	public double getCountsSec ( ) { return countsSec ; }
va	IDF	@ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setName ( "GameEventBus-Thread" ) ; return t ; }
va	KEY	public static long min ( final long a , final long b ) { return ( a <= b ) ? a : b ; }
va	IDF	public void init ( ) { coreFiltersService . registerFilter ( vhostFilter ) ; }
va	IDF	OreMineralImpl toOreMineral ( Ore ore ) { return new OreMineralImpl ( mineral , ore , unitsPerCubicMeter , unitsPerBatch ) ; }
va	IDF	private Element requestTaskToElement ( TIPPTask task , Document doc ) { Element requestEl = doc . createElement ( TASK_REQUEST ) ; return addTaskData ( task , doc , requestEl ) ; }
va	IDF	@ Override public double value ( Individual < T > individual ) { double value = 0.0 ; double weight = 0.0 ; double [ ] variables = individual . getVariables ( ) ; double [ ] weights = individual . getWeight ( ) ; double [ ] profits = individual . getProfit ( ) ; for ( int i = 0 ; i < variables . length ; i ++ ) { weight += weights [ i ] * variables [ i ] ; value += profits [ i ] * variables [ i ] ; } if ( weight > maxWeight ) return double . MIN_VALUE ; else return value ; }
va	IDF	private void cargarListaPerfileColor ( ) { if ( jtColores . getSelectedRow ( ) != - 1 ) { new Thread ( new Runnable ( ) { @ Override public void run ( ) { frmEspera espera = new frmEspera ( ) ; try { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; Color c = ( Color ) jtColores . getValueAt ( jtColores . getSelectedRow ( ) , 0 ) ; jfOrden = new frmListadoPerfilesPorColor ( PedidosData . genOrdenPedidosPorColor ( pedidos , c ) ) ; jfOrden . setTitle ( "Perfiles pedidos en " + c . getColor ( ) ) ; jfOrden . setVisible ( true ) ; } finally { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; espera . close ( ) ; } } } ) . start ( ) ; } else { JOptionPane . showMessageDialog ( null , "Debe seleccionar un color!" , "Listar Perfiles..." , JOptionPane . WARNING_MESSAGE ) ; } }
va	IDF	private void addNewEntities ( ) { synchronized ( addQueue ) { if ( ! addQueue . isEmpty ( ) ) { synchronized ( entitySet ) { entitySet . addAll ( addQueue ) ; } addQueue . clear ( ) ; this . dirtyCache = true ; } } }
va	IDF	private void configIncludeAndNonInclude ( ) { try { StringBuilder includeSB = new StringBuilder ( ) ; int i = 0 ; for ( String include : FileUtils . getIncludeProperties ( ) ) { if ( i == 0 ) { includeSB . append ( include ) ; } else { includeSB . append ( SEPERATED_SYMBOL ) . append ( include ) ; } i ++ ; } includeTextField . setText ( includeSB . toString ( ) ) ; StringBuilder nonIncludeSB = new StringBuilder ( ) ; int j = 0 ; for ( String nonInclude : FileUtils . getNonIncludeProperties ( ) ) { if ( j == 0 ) { nonIncludeSB . append ( nonInclude ) ; } else { nonIncludeSB . append ( SEPERATED_SYMBOL ) . append ( nonInclude ) ; } j ++ ; } nonIncludeTextField . setText ( nonIncludeSB . toString ( ) ) ; } catch ( DocumentException e1 ) { UISupport . showMessage ( "Include and Non-include configuration error!" ) ; } }
va	IDF	@ Override public void setNumSquare ( int numSquare ) { super . setNumSquare ( numSquare ) ; sqNumWidth = 3 ; sqNumHeight = 2 ; }
va	KEY	protected abstract String getXMLPropertyDefinitionEnd ( ) ;
va	KEY	public void testApp ( ) { assertTrue ( true ) ; }
va	IDF	public ArrayList < String > restoreIpAddresses ( String s ) { cache . clear ( ) ; return dfs ( s , 4 ) ; }
va	KEY	public boolean hasNext ( ) { return inode != null ; }
va	IDF	@ SuppressWarnings ( "rawtypes" ) public static String valueToString ( Object value ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof JSONString ) { Object object ; try { object = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "Bad value from toJSONString: " + object ) ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; }
va	KEY	public void postTurn ( ) { }
va	KEY	public void setTimeEstimate ( double timeEstimate ) { if ( timeEstimate < 0 ) { throw new IllegalArgumentException ( "Time estimate cannot be less than 0!" ) ; } this . timeEstimate = timeEstimate ; }
va	IDF	private static boolean isValid ( Node actual , Node expected ) { if ( actual == null && expected == null ) { return true ; } if ( ( actual == null && expected != null ) || ( actual != null && expected == null ) ) { return false ; } if ( actual . value != expected . value ) { return false ; } boolean valid1 = isValid ( actual . left , expected . left ) ; boolean valid2 = isValid ( actual . right , expected . right ) ; return valid1 && valid2 ; }
va	KEY	public int getMax ( ) { return max ; }
va	KEY	public OptionsView ( ) { super ( ) ; this . controleur = new OptionsController ( this ) ; }
va	IDF	static boolean isSubset ( Object subtree1 , Object subtree2 ) { return isSubset ( subtree1 , subtree2 , NEGATIVE_INFINITY , POSITIVE_INFINITY ) ; }
va	KEY	public int unpack ( int packedRGB , int component ) { return packedRGB >> 8 * ( 2 - component ) & 255 ; }
va	KEY	public RequirementLink ( ) { super ( ) ; }
va	IDF	public void setTile10 ( String tile10 ) { this . tile10 = tile10 ; }
va	IDF	private static Object buildNode ( Object elt , int ehash , Object left , Object right ) { if ( ( left == null || ! ( left instanceof Node ) ) && ( right == null || ! ( right instanceof Node ) ) ) { Object [ ] lary = ( Object [ ] ) left , rary = ( Object [ ] ) right ; if ( ! ( elt instanceof EquivalentSet ) && ( left == null ? 0 : lary . length ) + ( right == null ? 0 : rary . length ) < MAX_LEAF_ARRAY_LENGTH ) return concat ( elt , lary , rary ) ; else return makeNode ( elt , ehash , left , right ) ; } else { int sizl = treeSize ( left ) ; int sizr = treeSize ( right ) ; if ( right instanceof Node && sizr > sizl * BALANCE_FACTOR ) { Node r = ( Node ) right ; Object rl = r . left ; Object rr = r . right ; if ( ! ( rl instanceof Node ) || treeSize ( rl ) <= treeSize ( rr ) ) return makeNode ( r . element , r . ehash , buildNode ( elt , ehash , left , rl ) , rr ) ; else { Node rln = ( Node ) rl ; return makeNode ( rln . element , rln . ehash , buildNode ( elt , ehash , left , rln . left ) , buildNode ( r . element , r . ehash , rln . right , rr ) ) ; } } else if ( left instanceof Node && sizl > sizr * BALANCE_FACTOR ) { Node l = ( Node ) left ; Object ll = l . left ; Object lr = l . right ; if ( ! ( lr instanceof Node ) || treeSize ( lr ) <= treeSize ( ll ) ) return makeNode ( l . element , l . ehash , ll , buildNode ( elt , ehash , lr , right ) ) ; else { Node lrn = ( Node ) lr ; return makeNode ( lrn . element , lrn . ehash , buildNode ( l . element , l . ehash , ll , lrn . left ) , buildNode ( elt , ehash , lrn . right , right ) ) ; } } else return makeNode ( elt , ehash , left , right ) ; } }
va	IDF	@ Override public void runTest ( ) { TreeNode root = new TreeNode ( 8 ) ; TreeNode tmp = root ; tmp . left = new TreeNode ( 3 ) ; tmp = tmp . left ; tmp . left = new TreeNode ( 3 ) ; tmp = tmp . left ; tmp . left = new TreeNode ( 3 ) ; tmp = tmp . left ; tmp . left = new TreeNode ( 3 ) ; tmp = tmp . left ; tmp . left = new TreeNode ( 3 ) ; tmp = tmp . left ; }
va	KEY	boolean isReplyToThisMessage ( ) ;
va	KEY	public int getTilePairs ( ) { return tilePairs ; }
va	KEY	public String toString ( ) { return " at " + this . index + " [character " + this . character + " line " + this . line + "]" ; }
va	KEY	public int getTaille ( ) { return tab_cases . length ; }
va	KEY	public ProfileManager ( ) { super ( ) ; this . profile = new ProfileImpl ( ) ; this . profilePath = "" ; }
va	KEY	protected abstract String idColumnName ( ) ;
va	KEY	public void setOverlap ( boolean overlap ) { this . overlap = overlap ; }
va	IDF	public void setName ( String name ) { this . name = name ; }
va	IDF	public void setProductId ( String productId ) { this . productId = productId ; }
va	IDF	protected Collection < OthelloCellCapturePath > placePiece ( final int column , final int row , final OthelloPiece piece ) { final Collection < OthelloCellCapturePath > paths = new LinkedList < OthelloCellCapturePath > ( ) ; if ( grid [ column ] [ row ] != null ) { Logger . error ( "A piece already exists at {%d %d}\n" , column , row ) ; return paths ; } final OthelloPiece opponent = opposite ( piece ) ; boolean ok ; int x , y ; x = column + 1 ; ok = false ; while ( ( x < COLUMNS ) && ( grid [ x ] [ row ] == opponent ) ) { ok = true ; x ++ ; } if ( ok && ( x < COLUMNS ) && ( grid [ x ] [ row ] == piece ) ) { paths . add ( new OthelloCellCapturePath ( column , row , x , row , piece ) ) ; } x = column - 1 ; ok = false ; while ( ( x >= 0 ) && ( grid [ x ] [ row ] == opponent ) ) { ok = true ; x -- ; } if ( ok && ( x >= 0 ) && grid [ x ] [ row ] == piece ) { paths . add ( new OthelloCellCapturePath ( x , row , column , row , piece ) ) ; } y = row + 1 ; ok = false ; while ( ( y < ROWS ) && ( grid [ column ] [ y ] == opponent ) ) { ok = true ; y ++ ; } if ( ok && ( y < ROWS ) && grid [ column ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , column , y , piece ) ) ; } y = row - 1 ; ok = false ; while ( ( y >= 0 ) && ( grid [ column ] [ y ] == opponent ) ) { ok = true ; y -- ; } if ( ok && ( y >= 0 ) && grid [ column ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , column , y , piece ) ) ; } x = column + 1 ; y = row + 1 ; ok = false ; while ( ( x < COLUMNS ) && ( y < ROWS ) && ( grid [ x ] [ y ] == opponent ) ) { ok = true ; x ++ ; y ++ ; } if ( ok && ( x < COLUMNS ) && ( y < ROWS ) && grid [ x ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , x , y , piece ) ) ; } x = column + 1 ; y = row - 1 ; ok = false ; while ( ( x < COLUMNS ) && ( y >= 0 ) && ( grid [ x ] [ y ] == opponent ) ) { ok = true ; x ++ ; y -- ; } if ( ok && ( x < COLUMNS ) && ( y >= 0 ) && grid [ x ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , x , y , piece ) ) ; } x = column - 1 ; y = row + 1 ; ok = false ; while ( ( x >= 0 ) && ( y < ROWS ) && ( grid [ x ] [ y ] == opponent ) ) { ok = true ; x -- ; y ++ ; } if ( ok && ( x >= 0 ) && ( y < ROWS ) && grid [ x ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , x , y , piece ) ) ; } x = column - 1 ; y = row - 1 ; ok = false ; while ( ( x >= 0 ) && ( y >= 0 ) && ( grid [ x ] [ y ] == opponent ) ) { ok = true ; x -- ; y -- ; } if ( ok && ( x >= 0 ) && ( y >= 0 ) && grid [ x ] [ y ] == piece ) { paths . add ( new OthelloCellCapturePath ( column , row , x , y , piece ) ) ; } for ( final OthelloCellCapturePath path : paths ) { path . execute ( grid ) ; } return paths ; }
va	IDF	public RationalNumber mlt ( RationalNumber r ) ;
va	IDF	public void setTitle ( String value ) { this . title = value ; }
va	KEY	@ Override public void updateModelFromView ( ) { }
va	IDF	public String readMessage ( ) throws InterruptedException { boolean myLock = false ; myLock = lock . readLock ( ) . tryLock ( ) ; try { if ( myLock ) { TimeUnit . SECONDS . sleep ( 1 ) ; return this . message ; } else { TimeUnit . SECONDS . sleep ( 1 ) ; return "Could not get lock" ; } } finally { if ( myLock ) lock . readLock ( ) . unlock ( ) ; } }
va	KEY	public int getElementWithNumber ( int elementNumber ) { return elements [ elementNumber ] ; }
va	KEY	public void setValPenPag_Entrega ( double ValPenPag_Entrega ) { this . ValPenPag_Entrega = ValPenPag_Entrega ; }
va	KEY	public static void main ( String [ ] argv ) { new AppletFrame ( "svm_toy" , new svm_toy ( ) , 500 , 500 + 50 ) ; }
va	IDF	public long createLinkCodePATHPP ( FeatureTemplate . Link temp , long x , long y , long z ) { return ( ( ( ( ( ( x << tagNumBits ) | y ) << tagNumBits ) | z ) << numLinkFeatBits ) | temp . ordinal ( ) ) << ( auglbNumBits * 2 ) ; }
va	KEY	public void answerRight ( ) ;
va	KEY	public boolean unlock ( ) { System . out . println ( "You need to use a key to unlock the cell door." ) ; return true ; }
va	KEY	public void destroy ( ) { }
va	KEY	public void setAdApiVersion ( double value ) { this . adApiVersion = value ; }
va	IDF	@ Before public void setUp ( ) { vars = new HashMap < String , double > ( ) ; vars . put ( "x" , 3.0 ) ; }
va	IDF	Point move ( Point position , long time ) { return new Point ( moveX ( position . x , time ) , moveY ( position . y , time ) ) ; }
va	KEY	@ Override public void aim ( double x , double y , double z ) { }
va	IDF	public void run ( ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } FrameRunner . run ( ConverterWindow . class ) ; }
va	IDF	public static void main ( String aa [ ] ) { Thread_3 ob = new Thread_3 ( ) ; Thread_3 ob1 = new Thread_3 ( ) ; Thread_3 ob2 = new Thread_3 ( ) ; ob . setDaemon ( true ) ; ob . setName ( "number one" ) ; ob1 . setName ( "number two" ) ; ob2 . setName ( "number three" ) ; ob . start ( ) ; ob1 . start ( ) ; ob2 . start ( ) ; }
va	KEY	private void handleGameOver ( ) { }
va	IDF	Vector crossProduct ( Vector v ) ;
va	KEY	public boolean isPodeAndar ( ) { return podeAndar ; }
va	KEY	public void incrementNumberOfPlays ( ) ;
va	KEY	public void duplicateTopic ( ) ;
va	KEY	private boolean formatCheck ( boolean isAudio ) { if ( isAudio == true ) { if ( _outFileT . getText ( ) . endsWith ( ".mp3" ) ) { return true ; } else { return false ; } } else { if ( _outFileT . getText ( ) . endsWith ( ".mp4" ) ) { return true ; } else { return false ; } } }
va	KEY	public boolean getNoData ( ) { return NODATA ; }
va	IDF	@ Override public void actionPerformed ( ActionEvent e ) { if ( list . getSelectedIndex ( ) == - 1 ) { } else { setInputField ( listModel . elementAt ( list . getSelectedIndex ( ) ) ) ; _player . playMedia ( getInputField ( ) ) ; } }
va	IDF	public PageInfoPanel ( MainFrame main ) { super ( main ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridheight = 1 ; c . gridwidth = 1 ; c . weightx = 1 ; c . weighty = 0 ; c . ipady = 10 ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . FIRST_LINE_START ; c . gridx = 0 ; c . gridy = 0 ; columnsLabel = new JLabel ( "Columns per page: " ) ; add ( columnsLabel , c ) ; c . gridx = 1 ; columnsSpinner = new JSpinner ( ) ; SpinnerModel spinnerModel = new SpinnerNumberModel ( settings . columnsPerPage , MIN_COLUMNS_PER_PAGE , MAX_COLUMNS_PER_PAGE , 1 ) ; columnsSpinner . setModel ( spinnerModel ) ; columnsSpinner . addChangeListener ( this ) ; add ( columnsSpinner , c ) ; c . gridx = 0 ; c . gridy = 1 ; measuresLabel = new JLabel ( "Measure per column: " ) ; add ( measuresLabel , c ) ; c . gridx = 1 ; measuresSpinner = new JSpinner ( ) ; spinnerModel = new SpinnerNumberModel ( settings . measuresPerColumn , MIN_MEASURES_PER_COLUMN , MAX_MEASURES_PER_COLUMN , 1 ) ; measuresSpinner . setModel ( spinnerModel ) ; measuresSpinner . addChangeListener ( this ) ; add ( measuresSpinner , c ) ; c . gridx = 0 ; c . gridy = 2 ; pagesLabel = new JLabel ( "Total pages: " ) ; add ( pagesLabel , c ) ; c . gridx = 1 ; pagesFieldLabel = new JLabel ( ) ; add ( pagesFieldLabel , c ) ; }
va	IDF	public void bind ( T listener ) { if ( mBindAllowed ) { synchronized ( mListeners ) { if ( listener != null ) { mListeners . add ( listener ) ; performInitialUpdate ( listener ) ; listener . onBind ( mListenerClass ) ; } else { System . out . println ( getClass ( ) . getName ( ) + " - Attempt to add null listener object." ) ; } } } }
va	KEY	public Request getRequest ( ) { return this . request ; }
va	KEY	public abstract int read ( int addr ) ;
va	IDF	public BlankAnswerPanel ( final AnswerLocationPanel topPanel ) { this . setTopPanel ( topPanel ) ; this . createOptionsPanel ( ) ; }
va	KEY	public double getDistance ( ) { return DISTANCE ; }
va	KEY	protected abstract Iterable < ? extends IDrawable > getDrawables ( ) ;
va	KEY	public int boardCols ( ) { return maskCols ( getBoard ( ) ) ; }
va	KEY	public boolean isOpen ( ) { return service . isOpen ( ) ; }
va	IDF	public ACOClustering ( List < DataPoint > data , GraphFitness fitnessEvaluation ) { super ( data , fitnessEvaluation ) ; aco = new ACO ( data ) ; jungHandler . setDimensions ( aco . getXSpace ( ) , aco . getYSpace ( ) ) ; }
va	IDF	public void toggleAmrs ( ) { if ( arms . get ( ) == DoubleSolenoid . Value . kForward ) arms . set ( DoubleSolenoid . Value . kReverse ) ; else if ( arms . get ( ) == DoubleSolenoid . Value . kReverse ) arms . set ( DoubleSolenoid . Value . kForward ) ; }
va	IDF	private void defineEstruturaTabela ( ) { try { estruturaTabela = dao . getEstrutura ( tabela ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Modulo Listagem" , JOptionPane . ERROR_MESSAGE ) ; this . dispose ( ) ; } }
va	KEY	public abstract void undoEvent ( ) ;
va	KEY	public SendMessageVerbose createSendMessageVerbose ( ) { return new SendMessageVerbose ( ) ; }
va	KEY	public void act ( ) { control ( ) ; }
va	KEY	public String toString ( ) { return "table atan" ; }
va	KEY	public float getMaxSpeed ( ) { return ( float ) this . dMaxSpeed ; }
va	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnConsultarActionPerformed ( evt ) ; }
va	KEY	@ JsonProperty ( "rating" ) public long getRating ( ) { return rating ; }
va	KEY	public double neb ( ) { if ( level . BLOCKS_EMPTY != 0 ) return getBlocksEmptyDestroyed ( ) / level . BLOCKS_EMPTY ; else return 0 ; }
va	IDF	@ Override public void set ( int col , int row , double value ) { this . matrix [ row ] [ col ] = value ; }
va	IDF	public static int getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( name . equals ( "int" ) || name . equals ( "java.lang.Integer" ) ) return INTEGER ; if ( name . equals ( "double" ) || name . equals ( "java.lang.Double" ) ) return double ; if ( name . equals ( "long" ) || name . equals ( "java.lang.Long" ) ) return long ; if ( name . equals ( "float" ) || name . equals ( "java.lang.Float" ) ) return float ; if ( name . equals ( "java.util.Date" ) ) return DATE ; if ( name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return boolean ; return - 1 ; }
va	KEY	public JavaBean ( ) { }
va	IDF	public void setThreat ( String threat ) { this . threat = threat ; }
va	IDF	static float sRGB_to_RGB ( float c ) { if ( c <= 0f ) { return 0f ; } if ( c >= 1f ) { return 1f ; } if ( c <= 0.04045f ) { return c / 12.92f ; } else { return ( float ) ( Math . pow ( ( c + 0.055f ) / 1.055f , 2.4 ) ) ; } }
va	IDF	public LinkedList < JavaCell > getPath ( ) { return path ; }
va	IDF	@ Override public void update ( ) { inputProcess ( ) ; processDash ( ) ; }
va	KEY	public int getAverageWeather ( ) { return averageWeather ; }
va	IDF	void onRemainingScoreForPlayer ( Player player , Score score ) ;
va	IDF	public static void main ( String [ ] args ) { int count = 0 ; count += numberOfCombinations ( NUMBEROFDAYS , "  " ) ; for ( int i = 0 ; i < NUMBEROFDAYS ; i ++ ) count += numberOfCombinations ( i , "  " ) * numberOfCombinations ( NUMBEROFDAYS - i - 1 , "  " ) ; System . out . print ( count ) ; }
va	IDF	public ChildrenConstructor ( ) { System . out . println ( "in children default constructor" ) ; }
va	KEY	public void setId ( int id ) { this . id = id ; }
va	KEY	public void setRows ( int rows ) { this . rows = rows ; }
va	IDF	public void setTitle ( String title ) { this . title = title ; }
va	IDF	public MessageManager ( IPacketManager packetManager , IConnectionManager connectionManager , IncomingMessageParser < ServerProtocolParameters > incomingMessageParser , int majorVersion , int minorVersion ) { super ( MessageListener . class ) ; this . packetManager = packetManager ; this . connectionManager = connectionManager ; this . incomingMessageParser = incomingMessageParser ; this . majorVersion = majorVersion ; this . minorVersion = minorVersion ; }
va	KEY	public boolean isEmptyOrNullBuffer ( ) ;
va	KEY	@ Override public int getUnitsPerBatch ( ) { return unitsPerBatch ; }
va	IDF	@ Override public IKey consulta ( String chave ) throws SQLException { Chamado chamado = null ; String sql = "SELECT * FROM chamado WHERE codigo = '" + chave + "'" ; Statement stmt = connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { chamado = new Chamado ( ) ; chamado . setCodigo ( rs . getString ( "codigo" ) ) ; chamado . setCodigoTecnico ( rs . getString ( "tecnico_codigo" ) ) ; chamado . setCodigoMaquina ( rs . getString ( "maquina_codigo" ) ) ; chamado . setTitulo ( rs . getString ( "titulo" ) ) ; chamado . setDescricao ( rs . getString ( "descricao" ) ) ; chamado . setData ( rs . getTimestamp ( "data" ) ) ; } return chamado ; }
va	IDF	@ Override public void actionPerformed ( ActionEvent e ) { String s = ( String ) speed . getSelectedItem ( ) ; if ( s . equals ( SPEED_FAST ) ) { adapter . newGameSpeedIs ( 2 ) ; } else if ( s . equals ( SPEED_MEDIUM ) ) { adapter . newGameSpeedIs ( 1 ) ; } else if ( s . equals ( SPEED_SLOW ) ) { adapter . newGameSpeedIs ( 0 ) ; } }
va	IDF	@ Override public void setAttribute ( String name , Object value ) { if ( "model" . equals ( name ) ) { nextModel = ( String ) value ; } if ( "ammo" . equals ( name ) ) { try { int tmp = Integer . parseInt ( ( String ) value ) ; if ( tmp >= 0 && tmp <= 4 ) nextAmmo = tmp ; } catch ( Exception e ) { } } if ( "Kill" . equals ( name ) ) { if ( hp > 0 ) takeHp ( hp , this ) ; } super . setAttribute ( name , value ) ; }
va	IDF	public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ROOT ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( i > 32 && i < 127 || i > 160 ) { System . out . printf ( "Character # %3d -> %s\n" , i , ( char ) i ) ; } else { System . out . printf ( "Character # %3d -> Unprintable symbol or space !\n" , i ) ; } } }
va	IDF	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
va	KEY	public float getuStepRA ( ) { return uStepHA ; }
va	IDF	public static double angleBetween ( Vector2D v0 , Vector2D v1 ) { double denom = FastMath . sqrt ( v0 . x * v0 . x + v0 . y * v0 . y ) * FastMath . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y ) ; if ( denom > double . MIN_VALUE ) { double a = FastMath . acos ( ( v0 . x * v1 . x + v0 . y * v1 . y ) / denom ) ; if ( a != a ) return 0 ; else return a ; } return 0 ; }
va	KEY	public boolean isValidValueForElementWithNumber ( int elementNumber , int value ) { if ( value == EMPTY_ELEMENT_VALUE ) { return false ; } else if ( elements [ elementNumber ] == value ) { return true ; } else { for ( int validElement : getValidValuesForElementWithNumber ( elementNumber ) ) { if ( validElement == value ) { return true ; } } return false ; } }
va	IDF	@ Override default GPerson P ( String name , String address ) { return new GPerson ( ) { public < Company , Dept , SubUnit , Employee , Person , Salary > Person accept ( SybAlg < Company , Dept , SubUnit , Employee , Person , Salary > alg ) { return alg . P ( name , address ) ; } } ; }
va	IDF	@ Override public void setDim ( int dim ) throws ConnectException { this . dim = dim ; makeDynaSys ( ) ; outputY . setDim ( dim * ( order + 1 ) ) ; }
va	KEY	public TranslationResult createTranslationResult ( ) { return new TranslationResult ( ) ; }
va	IDF	public static INDISwitchOneOrNoneProperty createSaveableSwitchOneOrNoneProperty ( INDIDriver driver , String name , String label , PropertyStates state , PropertyPermissions permission , String option , SwitchStatus initialStatus ) throws IllegalArgumentException { INDISwitchOneOrNoneProperty sp = loadSwitchOneOrNoneProperty ( driver , name ) ; if ( sp == null ) { sp = new INDISwitchOneOrNoneProperty ( driver , name , label , state , permission , option , initialStatus ) ; sp . setSaveable ( true ) ; } return sp ; }
va	IDF	public void setJslideMatchPairs ( JSlider jslideMatchPairs ) { this . jslideMatchPairs = jslideMatchPairs ; }
va	KEY	public final String getTitle ( ) { return title ; }
va	IDF	public void addItem ( String item ) { print ( "in addItem() - entering" ) ; synchronized ( list ) { list . add ( item ) ; print ( "in addItem() - just added: '" + item + "'" ) ; list . notifyAll ( ) ; print ( "in addItem() - just notified" ) ; } print ( "in addItem() - leaving" ) ; }
va	KEY	public void setxFood ( int [ ] xFood ) { this . xFood = xFood ; }
va	IDF	public void setChatRoom ( String name ) { currChatRoomName = name ; setDestination ( chatRooms . get ( name ) ) ; System . out . println ( "NEW CHATROOM (" + name + "  " + currChatRoom + ")" ) ; }
va	IDF	public void setEst_Producto ( String Est_Producto ) { this . Est_Producto = Est_Producto ; }
va	IDF	public TextCharacter ( String text ) { updateText ( text ) ; }
va	IDF	private void readObject ( ObjectInputStream strm ) throws IOException , ClassNotFoundException { hash_code = Integer . MIN_VALUE ; strm . defaultReadObject ( ) ; int size = strm . readInt ( ) ; Object t = null ; for ( int i = 0 ; i < size ; ++ i ) t = with ( t , ( Elt ) strm . readObject ( ) ) ; try { TreeField . set ( this , t ) ; } catch ( IllegalAccessException ia ) { throw new RuntimeException ( "FTreeSet deserialization failed" , ia ) ; } }
va	IDF	private void updateInventoryActionPerformed ( java . awt . event . ActionEvent evt ) { this . main . hideView ( Main . view . Inventory ) ; this . main . showView ( Main . view . UpdateInventory ) ; }
va	IDF	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( int ) ( id ^ ( id >>> 32 ) ) ; return result ; }
va	KEY	public void setNullableError ( boolean nullableError ) { this . nullableError = nullableError ; }
va	KEY	public int getId ( ) { return id ; }
va	KEY	public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; }
va	IDF	private static void checkSplits ( int [ ] indexes ) { int splits = 0 ; for ( int split1 = 1 ; split1 < indexes . length - 1 ; split1 ++ ) { for ( int split2 = split1 + 1 ; split2 < indexes . length ; split2 ++ ) { splits ++ ; System . out . print ( "# split (" + split1 + "  " + split2 + "):" ) ; for ( int i = 0 ; i < split1 ; i ++ ) { System . out . print ( indexes [ i ] ) ; } System . out . print ( " - " ) ; for ( int j = split1 ; j < split2 ; j ++ ) { System . out . print ( indexes [ j ] ) ; } System . out . print ( " - " ) ; for ( int k = split2 ; k < indexes . length ; k ++ ) { System . out . print ( indexes [ k ] ) ; } } } System . out . println ( "# number of splits = " + splits ) ; }
va	IDF	protected int getCurrentYear ( ) { SimpleDateFormat yearformat = new SimpleDateFormat ( "yyyy" ) ; yearformat . setTimeZone ( timezone ) ; return Integer . parseInt ( yearformat . format ( Calendar . getInstance ( ) . getTime ( ) ) ) ; }
va	IDF	@ Override public void handle ( ActionEvent arg0 ) { primaryStage . close ( ) ; }
va	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { buttonVoltar_HistoriaActionPerformed ( evt ) ; }
va	IDF	@ Override boolean offerStop ( ) { if ( getPoints ( ) >= 17 ) { setStop ( true ) ; System . out . println ( "AI stopped" ) ; } else System . out . println ( "AI refused to stop" ) ; return isStop ( ) ; }
va	KEY	@ Override public int getLineLength ( ) { return 10 ; }
va	IDF	public T description ( String description ) { this . description = description ; return self ( ) ; }
va	KEY	public abstract boolean setSpeedSlow ( ) ;
va	KEY	public void setTipodoc ( int tipodoc ) { this . tipodoc = tipodoc ; }
va	KEY	public int hoursWorked ( ) { return d . hoursWorked ( ) ; }
va	IDF	public void init ( FilterConfig fConfig ) throws ServletException { IS_OPEN_VALUE = fConfig . getInitParameter ( IS_OPEN ) ; INDEX_PAGE_VALUE = fConfig . getInitParameter ( INDEX_PAGE ) ; LOGIN_PAGE_VALUE = fConfig . getInitParameter ( LOGIN_PAGE ) ; SIGN_PAGE_VALUE = fConfig . getInitParameter ( SIGN_PAGE ) ; HELP_PAGE_VALUE = fConfig . getInitParameter ( HELP_PAGE ) ; FINDPWD_PAGE_VALUE = fConfig . getInitParameter ( FINDPWD_PAGE ) ; }
va	IDF	public void updateItem ( HttpServletRequest arequest ) throws Exception { try { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; String serid = "Series" + myitem . doseid ; String resid = "Imstat" + myitem . doseid ; String dosid = "Dose" + myitem . doseid ; String accid = "Adate" + myitem . doseid ; String ayrsid = "Ayrs" + myitem . doseid ; String amosid = "Amos" + myitem . doseid ; String awksid = "Awks" + myitem . doseid ; String adysid = "Adys" + myitem . doseid ; String recid = "Rdate" + myitem . doseid ; String ryrsid = "Ryrs" + myitem . doseid ; String rmosid = "Rmos" + myitem . doseid ; String rwksid = "Rwks" + myitem . doseid ; String rdysid = "Rdys" + myitem . doseid ; String ovrid = "Odate" + myitem . doseid ; String oyrsid = "Oyrs" + myitem . doseid ; String omosid = "Omos" + myitem . doseid ; String owksid = "Owks" + myitem . doseid ; String odysid = "Odys" + myitem . doseid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; } int nslot = Math . max ( CAppConsts . NewSlotAntEval , CAppConsts . NumSlotAntEval - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CDoseItem myitem = new CDoseItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String serid = "Series" + myid ; String resid = "Imstat" + myid ; String dosid = "Dose" + myid ; String accid = "Adate" + myid ; String ayrsid = "Ayrs" + myid ; String amosid = "Amos" + myid ; String awksid = "Awks" + myid ; String adysid = "Adys" + myid ; String recid = "Rdate" + myid ; String ryrsid = "Ryrs" + myid ; String rmosid = "Rmos" + myid ; String rwksid = "Rwks" + myid ; String rdysid = "Rdys" + myid ; String ovrid = "Odate" + myid ; String oyrsid = "Oyrs" + myid ; String omosid = "Omos" + myid ; String owksid = "Owks" + myid ; String odysid = "Odys" + myid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . doseid = this . makeNewId ( "dos" , 6 ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; this . addItem ( myitem . doseid , myitem ) ; } } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.updateItem " , ex ) ; throw ( ex ) ; } }
va	KEY	public double getPrice ( ) { return price ; }
va	KEY	public void updateViewFromModel ( ) ;
va	KEY	public double getX ( ) { return x ; }
va	KEY	public void setDes_blanco ( double des_blanco ) { this . des_blanco = des_blanco ; }
va	IDF	public NetworkReader ( Socket s , Connections activeConnections , MessageProtocol msgProto ) { isRunning = true ; this . msgProto = msgProto ; this . activeConnections = activeConnections ; try { ois = new ObjectInputStream ( s . getInputStream ( ) ) ; } catch ( IOException e ) { System . out . println ( "Could not create ObjectInputStream" ) ; } activeConnections . registerOIS ( s , ois ) ; }
va	KEY	public void initDefaultCommand ( ) { }
va	IDF	public void dropNew ( ) { String [ ] playerItems = player . getInventory ( ) . getItemTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to drop." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JCheckBox [ ] checkBoxes = new JCheckBox [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JCheckBox newBox = new JCheckBox ( f ) ; newBox . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newBox . getActionMap ( ) . put ( f , charAction ) ; checkBoxes [ itemCount ] = newBox ; panel . add ( newBox ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to drop?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JCheckBox box : checkBoxes ) { if ( box . isSelected ( ) ) { Character id = box . getText ( ) . charAt ( 0 ) ; Holdable item ; try { item = player . getInventory ( ) . getItem ( id ) ; if ( item . isStackable ( ) ) item = player . getInventory ( ) . removeStackedItem ( id , 1 ) ; else item = player . getInventory ( ) . removeItem ( id ) ; player . getLocation ( ) . addItem ( item ) ; println ( "You drop the " + item . properName ( ) + " on the floor." ) ; } catch ( InvalidKeyException e ) { log . println ( "The item you picked was invalid" ) ; } } } } updateTile ( player . getLocation ( ) . getColumn ( ) , player . getLocation ( ) . getRow ( ) ) ; }
va	KEY	public void setHga ( int hga ) { this . hga = hga ; }
va	KEY	public void attack ( boolean state ) ;
va	IDF	void exitExiba ( @ NotNull EnquantoParser . ExibaContext ctx ) ;
va	IDF	private void handleGamePlaying ( ) { final long startTime = System . currentTimeMillis ( ) ; camera . renderScene ( this , world ) ; final long elapsedTime = System . currentTimeMillis ( ) - startTime ; final double ct = ( double ) elapsedTime / 33.33d ; world . update ( ct ) ; }
va	KEY	public LSPViolationTest ( ) { }
va	IDF	void show ( Graphics2D g2d ) ;
va	IDF	private void handleGameStarting ( ) { if ( System . currentTimeMillis ( ) - gameStateChangeTime >= 1000 ) { changeGameState ( GameState . PLAYING ) ; } }
va	IDF	public boolean intersects ( final double x , final double y ) { final double x1 = this . x - ( ( double ) width / 2 ) ; final double y1 = this . y - ( ( double ) height / 2 ) ; final double x2 = x1 + width ; final double y2 = y1 + height ; return ( x >= x1 ) && ( x <= x2 ) && ( y >= y1 ) && ( y <= y2 ) ; }
va	KEY	public double Recall ( ) { return corr / ( totg + 1e-20 ) ; }
va	KEY	public int getyExit ( ) ;
va	KEY	public boolean isPagado ( ) { return pagado ; }
va	KEY	public int getTopY ( ) { int mostTopY = ( int ) this . getBlkCoordinate ( ) . getY ( ) ; return mostTopY ; }
va	KEY	public synchronized void xassignL4KeyCode ( int code ) { l4 = code ; }
va	IDF	public void doPut ( HttpServletRequest req , HttpServletResponse resp ) throws IOException { this . __doPut ( req , resp ) ; }
va	IDF	public static ConstraintPuzzle getCopy ( ConstraintPuzzle p ) { try { ConstraintPuzzle c = p . getClass ( ) . newInstance ( ) ; c . setRandomNumberGeneratorSeed ( p . randomNumberGeneratorSeed ) ; c . setSize ( p . getSize ( ) ) ; c . setRuleset ( new Ruleset ( p . ruleSet ) ) ; for ( int i = 0 ; i < c . elements . length ; i ++ ) { if ( p . getElementWithNumber ( i ) != ConstraintPuzzle . EMPTY_ELEMENT_VALUE ) { c . setElementWithNumber ( i , p . getElementWithNumber ( i ) ) ; } } return c ; } catch ( Exception e ) { return null ; } }
va	KEY	private void setTxtComponent ( JTextComponent txtComponent2 ) { if ( txtComponent2 == null ) throw new IllegalArgumentException ( "Text component cannot be null!" ) ; this . txtComponent = txtComponent2 ; }
va	KEY	public String toString ( ) { return this . name ; }
va	KEY	public void close ( ) { try { if ( this . in != null ) { this . in . close ( ) ; this . in = null ; } if ( this . out != null ) { this . out . close ( ) ; this . out = null ; } } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } }
va	IDF	public void setDescuento ( Descuento descuento ) { this . ObDecuento = descuento ; }
va	KEY	public synchronized int xgetBRepeatDelay ( ) { return bRD ; }
va	IDF	public void mouseReleased ( java . awt . event . MouseEvent evt ) { mainMenuBtnMouseReleased ( evt ) ; }
va	IDF	public List < String > restoreIpAddresses ( String s ) { List < String > current = new ArrayList < String > ( ) ; List < String > result = new ArrayList < String > ( ) ; parseIP ( s , 0 , current , result ) ; return result ; }
va	KEY	public long getTime ( ) { return TIME ; }
va	KEY	protected int getNumOfRows ( ) { return t . size ( ) ; }
va	KEY	protected void finalize ( ) { this . close ( ) ; }
va	KEY	public long getLastCollideTime ( ) { return lastCollideTime ; }
va	IDF	static boolean equals ( Object tree1 , Object tree2 ) { if ( tree1 == tree2 ) return true ; int size1 = treeSize ( tree1 ) , size2 = treeSize ( tree2 ) ; if ( size1 != size2 ) return false ; else return equals ( tree1 , 0 , tree2 , 0 , 0 , size1 ) ; }
va	IDF	@ Override public void setDim ( int dim ) throws ConnectException { super . setDim ( dim ) ; ip . setDim ( dim ) ; }
va	IDF	private void updateHMM0 ( int data ) { setRegister ( HMM0 , data ) ; }
va	KEY	public synchronized int xgetL1RepeatDelay ( ) { return l1RD ; }
va	IDF	@ Override public void displayBorder ( ) { System . out . println ( "\t-----------------------------------------------------------------------------" ) ; }
va	IDF	public void build ( ) { puzzle = PuzzleFactory . INSTANCE . getPuzzleReader ( puzzleType ) . read ( input ) ; solutionSet = PuzzleFactory . INSTANCE . getSolutionSet ( this , puzzleType , puzzle ) ; algorithm = AlgorithmFactory . INSTANCE . get ( algorithmType , puzzle ) ; }
va	KEY	@ Override public double getWeight ( ) { return 5 ; }
va	KEY	private int getMissileSize ( int index ) { int iMissileFactorIndex = 0 ; if ( index == 0 ) iMissileFactorIndex = ( getRegister ( NUSIZ0 ) & 18 ) >> 4 ; else if ( index == 1 ) iMissileFactorIndex = ( getRegister ( NUSIZ1 ) & 18 ) >> 4 ; else return 1 ; switch ( iMissileFactorIndex ) { case 0 : return MISSILE_SINGLE_SIZE ; case 1 : return MISSILE_DOUBLE_SIZE ; case 2 : return MISSILE_QUAD_SIZE ; case 3 : return MISSILE_OCTA_SIZE ; } return 1 ; }
va	KEY	private void initAnimations ( ) throws SlickException { Image [ ] arrayAnimation = { new Image ( "assets/game/items/esfera/img1.png" ) , new Image ( "assets/game/items/esfera/img2.png" ) , new Image ( "assets/game/items/esfera/img3.png" ) } ; animation = new Animation ( arrayAnimation , new int [ ] { 200 , 200 , 200 } , false ) ; }
va	KEY	public double getP ( ) { return kP . getDouble ( ) ; }
va	IDF	protected int [ ] parseResponse ( String responseString ) { int [ ] result ; try { String [ ] values = responseString . split ( " " ) [ 1 ] . split ( "\r" ) ; result = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) result [ values . length - 1 - i ] = Integer . parseInt ( values [ i ] ) ; return result ; } catch ( Exception e ) { setCorrupted ( true ) ; return null ; } }
va	KEY	public long getOffset ( ) { return offset ; }
va	KEY	public void initialize ( ) { }
te	IDF	public void mouseClicked ( java . awt . event . MouseEvent evt ) { jButton2MouseClicked ( evt ) ; }
te	KEY	@ Override public void CALL ( int i , long l ) { }
te	KEY	public void setTotal ( long value ) { this . total = value ; }
te	KEY	public static boolean isValidBLOBEnable ( String BLOBEnable ) { try { parseBLOBEnable ( BLOBEnable ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
te	IDF	private void setHeight ( AVLNode current ) { int left_height = ( current . left == null ) ? - 1 : ( ( AVLNode ) current . left ) . height ; int right_height = ( current . right == null ) ? - 1 : ( ( AVLNode ) current . right ) . height ; current . height = 1 + Math . max ( left_height , right_height ) ; }
te	KEY	public static GitSettings defaults ( ) { return new GitSettings ( "git" , CharsetUtil . UTF8 , true ) ; }
te	KEY	public static void setDirectionToRight ( ) { InfoCenter . sentido = 1 ; }
te	IDF	public static Vector2D vec2DRotateAroundOrigin ( Vector2D v , double ang ) { Matrix2D mat = new Matrix2D ( ) ; ; mat . rotate ( ang ) ; return mat . transformVector2D ( v ) ; }
te	KEY	float getVX ( ) ;
te	IDF	public RedirectionException ( int code , int category , String message , int httpStatusCode ) { super ( code , category , message , httpStatusCode ) ; }
te	KEY	@ Override public void setFocus ( ) { }
te	IDF	@ Override public void mouseEntered ( MouseEvent arg0 ) { }
te	IDF	public void dieSprite ( Sprite sprite ) { die ( ) ; if ( world . recorder != null ) { world . recorder . dieRecord ( sprite ) ; } }
te	IDF	@ Test public void testDelete ( ) { SimpleMap < String , long > map = getMapInstance ( 16 ) ; assertNull ( map . get ( "1" ) ) ; long first = new long ( 10 ) ; long second = new long ( 11 ) ; assertTrue ( map . put ( "1" , first ) ) ; assertEquals ( first , map . get ( "1" ) ) ; assertTrue ( map . putIfAbsent ( "2" , second ) ) ; assertEquals ( second , map . get ( "2" ) ) ; assertEquals ( first , map . remove ( "1" ) ) ; assertNull ( map . remove ( "1" ) ) ; assertEquals ( second , map . remove ( "2" ) ) ; assertNull ( map . remove ( "2" ) ) ; map = getMapInstance ( 3 ) ; map . put ( "foo" , 1 ) ; map . put ( "bar" , 2 ) ; assertEquals ( 2 , map . size ( ) ) ; assertEquals ( new long ( 1 ) , map . get ( "foo" ) ) ; assertEquals ( new long ( 2 ) , map . get ( "bar" ) ) ; assertEquals ( 2 , map . size ( ) ) ; assertEquals ( new long ( 1 ) , map . get ( "foo" ) ) ; assertEquals ( new long ( 2 ) , map . get ( "bar" ) ) ; assertTrue ( map . putIfAbsent ( "foobar" , 3 ) ) ; assertTrue ( map . put ( "foo" , 4 ) ) ; assertEquals ( new long ( 2 ) , map . remove ( "bar" ) ) ; }
te	IDF	@ Override public void actionPerformed ( ActionEvent e ) { System . exit ( 0 ) ; }
te	KEY	public static boolean createFile ( File file ) { try { return file . createNewFile ( ) ; } catch ( IOException e ) { } return false ; }
te	IDF	public StereoOffCommand ( Stereo stereo ) { this . stereo = stereo ; }
te	IDF	@ Override public V get ( K key ) { int offset = offset ( key ) ; while ( keys [ offset ] != null ) { if ( keys [ offset ] . equals ( key ) ) { return ( V ) values [ offset ] ; } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return null ; } } return null ; }
te	IDF	@ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) public int getId ( ) { return id ; }
te	IDF	public FontfaceButton ( ImageIcon icon , final String tag , final String endTag ) { JLabel label = new JLabel ( icon ) ; add ( label ) ; addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { if ( messageInput . getSelectionEnd ( ) != messageInput . getSelectionStart ( ) ) { messageInput . insert ( endTag , messageInput . getSelectionEnd ( ) ) ; messageInput . insert ( tag , messageInput . getSelectionStart ( ) ) ; } else { messageInput . insert ( tag + endTag , messageInput . getCaretPosition ( ) ) ; messageInput . setCaretPosition ( messageInput . getCaretPosition ( ) - endTag . length ( ) ) ; } } } ) ; }
te	KEY	public abstract void displace ( double x , double y ) ;
te	IDF	void addSection ( TIPPSection section ) { sections . put ( section . getType ( ) , section ) ; }
te	IDF	public void setStatus ( String status ) { this . status = status ; }
te	IDF	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Cat . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Cat . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Cat . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Cat . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new Cat ( ) . setVisible ( true ) ; } catch ( SQLException ex ) { Logger . getLogger ( Cat . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
te	IDF	public void off ( ) { System . out . println ( location + " light is off" ) ; }
te	KEY	public void setTime ( long time ) ;
te	KEY	public boolean isOnThisXY ( int x , int y ) { return x == this . getX ( ) && y == this . getY ( ) ; }
te	IDF	public boolean examine ( ) { System . out . println ( "A steel broadsword. The hilt is wrapped in leather." ) ; if ( this . name . contains ( "vorpal" ) ) { System . out . println ( "The edge seems very sharp." ) ; } return true ; }
te	IDF	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
te	IDF	private MailQueue ( ) { logger = EmailServerStart . sendLog ; }
te	KEY	public NotaFiscal createNotaFiscal ( ) { return new NotaFiscal ( ) ; }
te	IDF	void exitBloco ( @ NotNull EnquantoParser . BlocoContext ctx ) ;
te	KEY	boolean isEndState ( ) ;
te	KEY	public int getMaxusers ( ) { return maxusers ; }
te	KEY	public Delete createDelete ( ) { return new Delete ( ) ; }
te	KEY	public int getId ( ) { return id ; }
te	KEY	private SimpleParameterMapper ( ) { }
te	IDF	public void assignLTKeyCode ( XbpadButton button , String text , int keycode ) { container . xgetCurrentPreset ( ) . xassignLTKeyCode ( keycode ) ; button . setText ( text ) ; button . repaint ( ) ; }
te	IDF	private Entity getEntityObject ( EFPersistable obj ) { for ( Entity e : entities ) { if ( e . getObject ( ) . getId ( ) . equals ( obj . getId ( ) ) && e . getObject ( ) . getClass ( ) . equals ( obj . getClass ( ) ) ) return e ; } return null ; }
te	IDF	public DisplayPlayersPalaceCardsFrame ( JavaPlayer player , HashMap < String , String > imageHash ) { this . imageSourceHashMap = imageHash ; setTitle ( "Your Secret Palace Cards" ) ; setSize ( width , height ) ; setResizable ( false ) ; addKeyListener ( new KeyListener ( ) { @ Override public void keyTyped ( KeyEvent e ) { } @ Override public void keyReleased ( KeyEvent e ) { if ( e . getKeyCode ( ) == 70 ) { dispose ( ) ; } } @ Override public void keyPressed ( KeyEvent e ) { } } ) ; setFocusTraversalKeysEnabled ( false ) ; initPanels ( player ) ; }
te	KEY	public int getWheelRotation ( ) { if ( e instanceof MouseWheelEvent ) { return ( ( MouseWheelEvent ) e ) . getWheelRotation ( ) ; } else { return 0 ; } }
te	IDF	public StoreActivity ( Main main ) { initComponents ( ) ; this . main = main ; this . setVisible ( false ) ; }
te	KEY	public int getSize ( ) { return size ; }
te	IDF	@ Override public Result callWithResult ( String param1 , int param2 ) { return new Result ( param1 , param2 ) ; }
te	IDF	@ JsonProperty ( "name" ) public String getName ( ) { return name ; }
te	KEY	public boolean isCriticality ( ) { return criticality ; }
te	KEY	public HumanPlayer ( ) { }
te	IDF	public Date getStart ( ) { return ( Date ) start . clone ( ) ; }
te	KEY	public DummyBoardEventProducer ( ) { }
te	KEY	public FLinkedHashMap ( ) { map_tree = null ; list_tree = null ; dflt = null ; }
te	KEY	public int getIdproveedor ( ) { return idproveedor ; }
te	KEY	int getColNum ( ) ;
te	KEY	public void setCompletions ( double completions ) { this . completions = completions ; }
te	IDF	public void declare ( ) { Set < String > hashSet = new HashSet < String > ( ) ; Set < String > treeSet = new TreeSet < String > ( ) ; System . out . println ( "" + hashSet + treeSet ) ; }
te	KEY	int getNumberOfColumns ( ) ;
te	KEY	public void setTempsMouvement ( int i ) { this . tempsMouvement = i ; }
te	IDF	@ Override public < S , T > T visit ( Visitor < S , T > v , S state ) throws FractalException { return v . visitASTExpVar ( this , state ) ; }
te	IDF	public static boolean areEqual ( Vector2D v0 , Vector2D v1 ) { return ( FastMath . abs ( v1 . x - v0 . x ) < EPSILON && FastMath . abs ( v1 . y - v0 . y ) < EPSILON ) ; }
te	IDF	public static boolean isSameDomain ( String domain , String [ ] domainList ) { for ( int i = 0 ; i < domainList . length ; i ++ ) { if ( domain . equals ( domainList [ i ] ) ) { return true ; } } return false ; }
te	IDF	@ Override public int hashCode ( ) { int result = id ; result = 31 * result + id ; result = 31 * result + ( answer != null ? answer . hashCode ( ) : 0 ) ; return result ; }
te	KEY	public int getIdTweets ( ) { return idTweets ; }
te	IDF	public NodeItem ( File file ) { this . file = file ; }
te	IDF	@ Override public void onMessageSent ( Message < ClientProtocolParameters > message ) { if ( message instanceof NodeWarningMessage ) { onWarningEmitted ( ( ( NodeWarningMessage ) message ) . message ) ; } }
te	IDF	@ Override public Dimension getPreferredSize ( ) { return new Dimension ( XLEN , YLEN + 50 ) ; }
te	IDF	public void ancestorRemoved ( javax . swing . event . AncestorEvent evt ) { }
te	KEY	public void setLastCollideTime ( long lastCollideTime ) { this . lastCollideTime = lastCollideTime ; }
te	KEY	@ JsonProperty ( "selected" ) public long getSelected ( ) { return selected ; }
te	KEY	public boolean isBlank ( ) { return isBlank ; }
te	KEY	@ Override public int count ( ) { return 0 ; }
te	IDF	public DependencyPipe ( Options options ) throws IOException { dictionaries = new DictionarySet ( ) ; synFactory = new SyntacticFeatureFactory ( options ) ; smnFactory = new SemanticFeatureFactory ( options , this ) ; this . options = options ; loadLanguageInfo ( ) ; }
te	KEY	public Action pressDelete ( ) { if ( selectedAction != null ) { return selectedAction . pressDelete ( this ) ; } return null ; }
te	IDF	public List < Player > getPlayers ( ) { return players ; }
te	IDF	protected void definirDark ( ) { raz ( ) ; panel_case . removeAll ( ) ; definirEtat ( "dark" ) ; InterfaceEditeur . tab [ this . x ] [ this . y ] = this ; }
te	KEY	public boolean isNullable ( ) ;
te	KEY	public DrawFestivalCardAction ( int actionID ) { super ( actionID ) ; }
te	KEY	abstract public int getY ( int y , int height ) ;
te	IDF	public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof long ) { this . put ( key , ( ( long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof double ) { this . put ( key , ( ( double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof float ) { this . put ( key , ( ( float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable to increment [" + quote ( key ) + "]." ) ; } return this ; }
te	IDF	@ Test public void test2 ( ) { LRUCache test = new LRUCache ( 3 ) ; test . set ( 1 , 1 ) ; test . set ( 2 , 2 ) ; test . set ( 3 , 3 ) ; test . set ( 4 , 4 ) ; test . set ( 5 , 5 ) ; assert . assertEquals ( test . get ( 1 ) , - 1 ) ; assert . assertEquals ( test . get ( 2 ) , - 1 ) ; assert . assertEquals ( test . get ( 5 ) , 5 ) ; assert . assertEquals ( test . get ( 4 ) , 4 ) ; assert . assertEquals ( test . get ( 3 ) , 3 ) ; test . set ( 7 , 7 ) ; test . set ( 6 , 6 ) ; assert . assertEquals ( test . get ( 5 ) , - 1 ) ; assert . assertEquals ( test . get ( 4 ) , - 1 ) ; assert . assertEquals ( test . get ( 3 ) , 3 ) ; }
te	IDF	public void capture ( ) { ArrayList < Position > positions = _board . findPositions ( _position , 0 , 1 ) ; for ( Position position : positions ) { if ( _board . get_building ( position ) == null ) positions . remove ( position ) ; } Building building = _board . get_building ( positions . get ( 0 ) ) ; building . set_hitpoints ( building . get_hitpoints ( ) - _hitpoints ) ; if ( building . get_hitpoints ( ) < 0 ) { building . set_owner ( _owner ) ; building . set_hitpoints ( 100 ) ; } _active = false ; }
te	KEY	public void setPixel ( int x , int y , int rgb [ ] ) { }
te	KEY	public void setId ( int id ) { this . id = id ; }
te	IDF	public void draw ( Graphics2D g , Color color ) { g . setColor ( color ) ; drawHandle ( g ) ; if ( directLineTo ( g , from , pTo ) ) return ; if ( directLineTo ( g , to , pFrom ) ) return ; if ( verticalLineTo ( g , from , pTo ) ) return ; if ( verticalLineTo ( g , to , pFrom ) ) return ; if ( bothVertical ( g ) ) return ; if ( bothHorizontal ( g ) ) return ; if ( from . isVertical ( ) ) { Point tp = new Point ( getMx ( ) , pFrom . y ) ; Point tp2 = new Point ( tp . x , pTo . y ) ; if ( ! ( eFrom . intersects ( pFrom , tp ) || eTo . intersects ( pFrom , tp ) ) || eFrom . intersects ( tp , tp2 ) || eTo . intersects ( tp , tp2 ) || eFrom . intersects ( tp2 , pTo ) || eTo . intersects ( tp2 , pTo ) ) { drawLine ( g , pFrom , tp ) ; drawLine ( g , tp , tp2 ) ; drawLine ( g , tp2 , pTo ) ; return ; } else { int mx = 0 ; if ( to . getPosition ( ) == Component . Position . left ) { mx = Math . min ( eFrom . getX ( ) - gap , pTo . x ) ; } else { mx = Math . max ( eFrom . getX ( ) + eFrom . getOWidth ( ) + gap , pTo . x ) ; } tp = new Point ( mx , pFrom . y ) ; tp2 = new Point ( mx , pTo . y ) ; drawLine ( g , tp2 , pTo ) ; drawLine ( g , pFrom , tp ) ; drawLine ( g , tp , tp2 ) ; return ; } } else { Point tp = new Point ( pFrom . x , getMy ( ) ) ; Point tp2 = new Point ( pTo . x , tp . y ) ; if ( ! eTo . intersects ( tp2 , pTo ) ) { drawLine ( g , tp2 , pTo ) ; drawLine ( g , pFrom , tp ) ; drawLine ( g , tp , tp2 ) ; return ; } else { int my = 0 ; if ( to . getPosition ( ) == Component . Position . top ) { my = Math . min ( pTo . y , eFrom . getY ( ) - gap ) ; } else { my = Math . max ( pTo . y , eFrom . getY ( ) + eFrom . getOHeight ( ) + gap ) ; } tp = new Point ( pFrom . x , my ) ; tp2 = new Point ( pTo . x , tp . y ) ; drawLine ( g , tp2 , pTo ) ; drawLine ( g , pFrom , tp ) ; drawLine ( g , tp , tp2 ) ; return ; } } }
te	KEY	public void desenharLinha ( int x , int y ) ;
te	KEY	public final String getPage ( ) { return _page ; }
te	KEY	public void identity ( ) ;
te	IDF	private org . apache . axiom . soap . SOAPEnvelope toEnvelope ( org . apache . axiom . soap . SOAPFactory factory , src . com . tinyurlwebservicestub . TinyUrlWebServiceStub . GetShortUrl param , boolean optimizeContent , javax . xml . namespace . QName methodQName ) throws org . apache . axis2 . AxisFault { try { org . apache . axiom . soap . SOAPEnvelope emptyEnvelope = factory . getDefaultEnvelope ( ) ; emptyEnvelope . getBody ( ) . addChild ( param . getOMElement ( src . com . tinyurlwebservicestub . TinyUrlWebServiceStub . GetShortUrl . MY_QNAME , factory ) ) ; return emptyEnvelope ; } catch ( org . apache . axis2 . databinding . ADBException e ) { throw org . apache . axis2 . AxisFault . makeFault ( e ) ; } }
te	KEY	public int getBestMove ( ) { return 0 ; }
te	IDF	public void set_building ( Building building ) { this . _building = building ; }
te	IDF	private static double expint ( int p , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; xs [ 0 ] = 2.718281828459045 ; xs [ 1 ] = 1.4456468917292502E-16 ; split ( 1.0 , ys ) ; while ( p > 0 ) { if ( ( p & 1 ) != 0 ) { quadMult ( ys , xs , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } quadMult ( xs , xs , as ) ; xs [ 0 ] = as [ 0 ] ; xs [ 1 ] = as [ 1 ] ; p >>= 1 ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; resplit ( result ) ; } return ys [ 0 ] + ys [ 1 ] ; }
te	KEY	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof MsgStatusPk ) ) { return false ; } final MsgStatusPk _cast = ( MsgStatusPk ) _other ; if ( msgStatus == null ? _cast . msgStatus != msgStatus : ! msgStatus . equals ( _cast . msgStatus ) ) { return false ; } return true ; }
te	KEY	public boolean isCellEditable ( int rowIndex , int columnIndex ) { return canEdit [ columnIndex ] ; }
te	IDF	public static Object chargerFichier ( File file ) { return load ( file ) ; }
te	KEY	public boolean getNursingFacilityMoveRisk ( ) { return nursingFacilityMoveRisk ; }
te	IDF	@ Override public String getMessage ( ) { return USR . getEMPTY_DATA ( ) ; }
te	KEY	public TipoCorJogador getTurno ( ) { return this . turno ; }
te	IDF	@ Override public void run ( ) { String smtpPorts = EmailServerStart . emailConf . getProperty ( "smtpPort" ) ; if ( smtpPorts == null ) { EmailServerStart . smtpLog . error ( "smtp:\u65E0\u6CD5\u521D\u59CB\u5316smtp\u7AEF\u53E3" ) ; return ; } strSmtpPorts = EmailServerStart . emailConf . getProperty ( "smtpPort" ) . split ( " " ) ; for ( String port : strSmtpPorts ) { new Thread ( new SMTPStart ( Integer . parseInt ( port ) ) ) . start ( ) ; } }
te	IDF	public void setHersteller ( String hersteller ) { this . hersteller = hersteller ; }
te	KEY	private int newID ( ) { if ( ID < MAX_PLAYERS ) { return ID ++ ; } else { return ERROR_ID ; } }
te	KEY	public void setOnDeleteTopic ( ) ;
te	IDF	private static int _getScore ( Proxy proxy ) { byte [ ] imageBytes = proxy . send ( new ProxyScreenshotMessage ( ) ) ; int score = - 1 ; BufferedImage image = null ; try { image = ImageIO . read ( new ByteArrayInputStream ( imageBytes ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } GameStateExtractor gameStateExtractor = new GameStateExtractor ( ) ; GameState state = gameStateExtractor . getGameState ( image ) ; if ( state == GameState . PLAYING ) score = gameStateExtractor . getScoreInGame ( image ) ; else if ( state == GameState . WON ) score = gameStateExtractor . getScoreEndGame ( image ) ; if ( score == - 1 ) System . out . println ( " Game score is unavailable " ) ; return score ; }
te	IDF	Food ( Board board ) { Random generator = SnakeWithPartner . getGenerator ( ) ; xFood = generator . nextInt ( board . getWidth ( ) - 1 ) ; yFood = generator . nextInt ( board . getHeight ( ) - 1 ) ; System . out . println ( "food is at: x-" + xFood + " y-" + yFood ) ; }
te	KEY	public int [ ] GetBoundY ( ) { return new int [ ] { ( int ) this . getMinY ( ) , ( int ) this . getMaxY ( ) , ( int ) this . getMaxY ( ) , ( int ) this . getMinY ( ) } ; }
te	IDF	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Contexto oContexto = ( Contexto ) request . getAttribute ( "contexto" ) ; oContexto . setVista ( "jsp/usuario/login.jsp" ) ; return null ; }
te	KEY	public static Map getLevelsMap ( ) { return levels ; }
te	IDF	private void jMenuCreateCardActionPerformed ( java . awt . event . ActionEvent evt ) { getPresenter ( ) . createCard ( ) ; }
te	KEY	public void setRowId ( int rowId ) { this . rowId = rowId ; }
te	IDF	public static void main ( String [ ] args ) throws UnknownHostException { NetworkClient client = new NetworkClient ( null ) ; InetAddress ip = InetAddress . getByName ( "localhost" ) ; client . connectToServer ( ip , "foobar" ) ; client . updatePos ( 1 , w ) ; client . updatePos ( 1 , s ) ; client . updatePos ( 1 , e ) ; client . updatePos ( 1 , n ) ; client . disconnect ( 1 ) ; }
te	IDF	public Record ( final String id , final String firstName , final String lastName ) { this . recordID = id ; this . firstName = firstName ; this . lastName = lastName ; }
te	IDF	static CommandLine svnLog ( String pathToSvn , String repositoryUrl , TimeRange timeRange , boolean useMergeHistory , boolean quoteDateRange ) { String mergeHistory = ( useMergeHistory ? "--use-merge-history" : "" ) ; @ SuppressWarnings ( "UnnecessaryLocalVariable" ) Charset svnXmlCharset = CharsetUtil . UTF8 ; return newExternalCommand ( pathToSvn , "log" , repositoryUrl , "-r" , svnDateRange ( timeRange , quoteDateRange ) , mergeHistory , "--verbose" , "--xml" ) . outputCharset ( svnXmlCharset ) ; }
te	KEY	public int getEstado ( ) { return estado ; }
te	IDF	public void setStartTime ( String startTime ) { this . startTime = startTime ; }
te	KEY	public SetRightHardLimitOffCommand ( ) { }
te	KEY	public char nextClean ( ) throws JSONException { for ( ; ; ) { char c = this . next ( ) ; if ( c == 0 || c >   ) { return c ; } } }
te	KEY	public void setFrequency ( int frequency ) { this . frequency = frequency ; }
te	IDF	public void actionPerformed ( ActionEvent arg0 ) { testController . goForwardInScenario ( ) ; }
te	KEY	public int getId ( ) { return id ; }
te	KEY	protected void setNbBomb ( int nbBombMax ) { this . nbBombMax = nbBombMax ; }
te	KEY	public abstract void setCell ( int col , int row , boolean alive ) ;
te	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton4ActionPerformed ( evt ) ; }
te	KEY	public void setMin ( int min ) { this . min = min ; }
te	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton1ActionPerformed ( evt ) ; }
te	KEY	public abstract double [ ] getProfits ( ) ;
te	IDF	@ Override public synchronized void requestNextPlayerEvent ( ) { for ( GameStatusUpdateListener g : listeners ) { try { g . requestNextPlayerEvent ( ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } }
te	KEY	public Action ( ) { this . actionID = - 1 ; }
te	KEY	public FTreeMap ( ) { tree = null ; comp = null ; dflt = null ; }
te	KEY	void tick ( ) ;
te	KEY	boolean isDisposed ( ) ;
te	KEY	public synchronized int xgetR3InitialDelay ( ) { return r3ID ; }
te	KEY	public final AbstractFList < Elt > clone ( ) { return this ; }
te	KEY	public int getOrder ( ) { return p . length - 1 ; }
te	IDF	@ Override public TIPO_OBJETO set ( TIPO_OBJETO oBean ) throws Exception { class < TIPO_OBJETO > tipo = ( class < TIPO_OBJETO > ) ( ( ParameterizedType ) getClass ( ) . getGenericSuperclass ( ) ) . getActualTypeArguments ( ) [ 0 ] ; Method metodo_getId = tipo . getMethod ( "getId" ) ; Method metodo_setId = tipo . getMethod ( "setId" , Integer . class ) ; try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( ( Integer ) metodo_getId . invoke ( oBean ) == 0 ) { metodo_setId . invoke ( oBean , oMysql . insertOne ( strTabla ) ) ; } for ( Method method : tipo . getMethods ( ) ) { if ( ! method . getName ( ) . substring ( 3 ) . equalsIgnoreCase ( "id" ) ) { if ( method . getName ( ) . substring ( 0 , 3 ) . equalsIgnoreCase ( "get" ) ) { if ( ! method . getName ( ) . equals ( "getClass" ) ) { final class < ? > strTipoDevueltoMetodoGet = method . getReturnType ( ) ; String value = ( String ) method . invoke ( oBean ) . toString ( ) ; if ( strTipoDevueltoMetodoGet . getName ( ) . equals ( "java.util.Date" ) ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd" ) ; value = format . format ( method . invoke ( oBean ) ) ; } String strCampo = method . getName ( ) . substring ( 3 ) . toLowerCase ( Locale . ENGLISH ) ; oMysql . updateOne ( ( Integer ) metodo_getId . invoke ( oBean ) , strTabla , strCampo , value ) ; } } } } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "GenericDao.set: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } return oBean ; }
te	KEY	public static Modification insert ( ) { return INSERT ; }
te	KEY	@ Override public void call ( int i ) { }
te	IDF	Set < String > nearbyCharacters ( String character ) ;
te	KEY	public long getId ( ) { return id ; }
te	IDF	@ Test public void canGetProductsByCategory ( ) { List < Integer > categories = new ArrayList < > ( ) ; categories . add ( CategoryJUnit . getACategory ( ) ) ; ProductModel addedProduct = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . categories ( categories ) . build ( ) ; List < ProductModel > products = null ; boolean isInResult = false ; try { addedProduct = new ProductModel ( insertProduct ( addedProduct ) , addedProduct ) ; products = pd . getProductsByCategory ( addedProduct . getCategories ( ) . get ( 0 ) ) ; for ( ProductModel product : products ) { if ( addedProduct . equals ( product ) ) { isInResult = true ; break ; } } deleteProduct ( addedProduct . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } assertTrue ( isInResult ) ; }
te	KEY	public void scale ( double x , double y , double z ) ;
te	IDF	private void btnOtraActionPerformed ( java . awt . event . ActionEvent evt ) { otra . setEnabled ( true ) ; promocion . setSelectedIndex ( 7 ) ; promocion . setEnabled ( false ) ; }
te	KEY	public Cell ( final int col , final int row , final char data ) { this . col = col ; this . row = row ; this . data = data ; }
te	IDF	public String toString ( ) { return "|?" + _name + "|?" + _year + "|?" + _artist ; }
te	KEY	public abstract boolean save ( ) ;
te	IDF	@ Override public void run ( ) { while ( true ) { try { String line = lnr . readLine ( ) ; if ( line == null ) return ; lines . add ( line ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
te	KEY	public DadosPessoa ( ) { }
te	IDF	double value ( Individual < T > individual ) ;
te	KEY	public double getValorAtual ( ) { return valorAtual ; }
te	IDF	@ Override public float getX ( ) { Point p = getBoardPosition ( ) ; int width = ( Board . getInstance ( ) . getIntWidth ( ) - 11 * FIELD_SIZE ) / 2 ; return Board . getInstance ( ) . getIntX ( ) + p . x * FIELD_SIZE + width ; }
te	KEY	protected ContentValidator getResponseValidator ( ) { return null ; }
te	IDF	public void setValue ( String value ) { this . value = value ; }
te	IDF	public Context ( Strategy varObjStrategy ) { this . objStrategy = varObjStrategy ; }
te	IDF	public byte [ ] getByteHash ( String input ) { md . reset ( ) ; final byte [ ] output = md . digest ( input . getBytes ( ) ) ; return output ; }
te	KEY	public boolean isCorrupted ( ) { return corrupted ; }
te	IDF	@ Override public void desenharLinha ( int x , int y ) { System . out . println ( "Implementando a forma UM do desenho da linha pontos: x= " + x + " y= " + y ) ; }
te	IDF	public static void main ( String [ ] args ) { int [ ] [ ] i = new int [ 2 ] [ 2 ] ; int [ ] [ ] j = { i [ 1 ] , { 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; int [ ] [ ] [ ] k = { i , j } ; System . out . println ( k [ 0 ] [ 1 ] [ 0 ] ++ ) ; System . out . println ( ++ k [ 1 ] [ 0 ] [ 0 ] ) ; System . out . println ( i [ 1 ] [ 0 ] ) ; System . out . println ( -- j [ 0 ] [ 0 ] ) ; }
te	KEY	public void setPlanetType ( int planetType ) { this . planetType = planetType ; }
te	IDF	void setTeam ( TEAM team ) ;
te	IDF	public MainMenu ( GameManager p ) { init ( p ) ; }
te	IDF	@ Test public final void testCountry_GetByAlpha2 ( ) { assertEquals ( ISO . Country . GB , ISO . Country . getByAlpha2 ( "GB" ) ) ; assertEquals ( null , ISO . Country . getByAlpha2 ( "ABC" ) ) ; assertEquals ( null , ISO . Country . getByAlpha2 ( "DF" ) ) ; assertEquals ( null , ISO . Country . getByAlpha2 ( null ) ) ; }
te	KEY	public void onSendNoServerPort ( int packetId ) ;
te	IDF	@ Override public ComplexValue multiply ( ComplexValue a ) { return new ComplexValue ( cv . re * a . re - cv . im * a . im , cv . re * a . im + cv . im * a . re ) ; }
te	IDF	public static boolean canMove ( Direction dir , boolean selfAvoiding , RobotController rc ) { if ( selfAvoiding ) { MapLocation resultingLocation = rc . getLocation ( ) . add ( dir ) ; for ( int i = 0 ; i < snailTrail . size ( ) ; i ++ ) { MapLocation m = snailTrail . get ( i ) ; if ( ! m . equals ( rc . getLocation ( ) ) ) { if ( resultingLocation . isAdjacentTo ( m ) || resultingLocation . equals ( m ) ) { return false ; } } } } return rc . canMove ( dir ) ; }
te	KEY	public int getId1 ( ) { return id1 ; }
te	KEY	public boolean isEmpty ( ) ;
te	IDF	public void render_fow ( VGraphics g , Point pcm ) { g . setTexture ( "fow/full.png" ) ; i ++ ; for ( int x = pcm . x / 64 ; x < 30 + pcm . x / 64 ; x ++ ) { for ( int y = - 10 + pcm . y / 64 ; y < 20 + pcm . y / 64 ; y ++ ) { int h = 20 ; int z = t ( point ( x , y ) ) * h ; VPoint test = VConvert . to2DPoint ( x * 64 + - pcm . x / 2 , y * 64 + 32 - pcm . y / 2 , z ) ; if ( x == 0 || x == 511 || y == 0 || y == 511 ) { g . setColor ( new Color ( 235 , 0 , 0 ) ) ; } else if ( tf ( point ( x , y ) ) > 0 ) { g . setColor ( new Color ( 235 , 235 , 235 ) ) ; } else { g . setColor ( new Color ( 135 , 135 , 135 ) ) ; } VPoint p = VConvert . to2DPoint ( x * 64 - pcm . x , y * 64 - pcm . y , z ) ; if ( tf ( point ( x , y ) ) <= 1 ) { if ( tf ( point ( x , y ) ) == 0 ) { g . setColor ( new Color ( 255 , 255 , 255 , 75 ) ) ; } else { g . setColor ( new Color ( 255 , 255 , 255 , 15 ) ) ; } g . drawRect ( ( int ) p . x , ( int ) p . y , 255 , 255 , i ) ; g . drawRect ( ( int ) p . x , ( int ) p . y , 255 , 255 , - i ) ; } } } }
te	KEY	protected abstract void onFailedNode ( Node node ) ;
te	IDF	@ Override public void execute ( double t ) { Matrix y = new ColumnMatrix ( output . getDim ( ) ) ; if ( pi . isConnected ( ) ) { if ( mi . isConnected ( ) ) { y = mi . getInput ( ) . times ( - 1 ) ; y = y . + ( pi . getInput ( ) ) ; } else y = pi . getInput ( ) ; } else { if ( mi . isConnected ( ) ) y = mi . getInput ( ) . times ( - 1 ) ; } try { output . setOutput ( y ) ; } catch ( OrderException e ) { e . printStackTrace ( ) ; } }
te	KEY	public Builder rampedHalfAndHalf ( boolean rampedHalfAndHalf ) { this . rampedHalfAndHalf = rampedHalfAndHalf ; return this ; }
te	IDF	@ Override protected BuffDropGraphic newDropBuff ( DropBuff buff ) { return new BuffDropImage ( this , getGame ( ) , buff . getBoardPosition ( ) ) ; }
te	IDF	public void actionPerformed ( ActionEvent e ) { switchPanels ( 2 ) ; }
te	KEY	public int size ( ) { return size ; }
te	KEY	protected void switchUsable ( ) { if ( isUsable == true ) { isUsable = false ; _save . setEnabled ( false ) ; } else { isUsable = true ; _save . setEnabled ( true ) ; } }
te	IDF	@ Test public void canGetCategoryThatNotExist ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel retrieved = null ; try { retrieved = cd . getCategory ( - 2 ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; fail ( "Exception" ) ; } assertNull ( retrieved ) ; }
te	KEY	double norm ( double p ) ;
te	IDF	public void mouseReleased ( MouseEvent e ) { GameAction gameAction = getMouseButtonAction ( e ) ; if ( gameAction != null ) { gameAction . release ( ) ; } }
te	KEY	public AddContactsToGroupsResponse createAddContactsToGroupsResponse ( ) { return new AddContactsToGroupsResponse ( ) ; }
te	IDF	private void writeQNames ( javax . xml . namespace . QName [ ] qnames , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( qnames != null ) { java . lang . StringBuffer stringToWrite = new java . lang . StringBuffer ( ) ; java . lang . String namespaceURI = null ; java . lang . String prefix = null ; for ( int i = 0 ; i < qnames . length ; i ++ ) { if ( i > 0 ) { stringToWrite . append ( " " ) ; } namespaceURI = qnames [ i ] . getNamespaceURI ( ) ; if ( namespaceURI != null ) { prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( ( prefix == null ) || ( prefix . length ( ) == 0 ) ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { stringToWrite . append ( prefix ) . append ( ":" ) . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } else { stringToWrite . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } } else { stringToWrite . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } } xmlWriter . writeCharacters ( stringToWrite . toString ( ) ) ; } }
te	IDF	private static void testMyWay ( ) { String s = "" ; s = myWay ( s ) ; System . out . println ( s ) ; }
te	KEY	public boolean getPenUse ( ) ;
te	IDF	public void setUsername ( String value ) { this . username = value ; }
te	IDF	@ Override public String createTableSql ( ) { return CreateSQL ; }
te	IDF	@ BeforeMethod public void beforeMethod ( ) { database = new Database ( "first_db" ) ; colDefs = new LinkedHashMap < > ( ) ; colDefs . put ( "foo" , new ColumnDefinition ( DataType . float , false , true ) ) ; colDefs . put ( "bar" , new ColumnDefinition ( DataType . INTEGER ) ) ; colDefs . put ( "baz" , new ColumnDefinition ( DataType . STRING , true , false ) ) ; Table table = new Table ( "table_1" , colDefs ) ; database . add ( table ) ; parser = new Parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executeModification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executeModification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executeModification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executeModification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executeModification ( ) ; }
te	IDF	@ Override public void update ( Observable o , Object arg ) { if ( arg . equals ( ObservableList . Event . ADD ) ) { List < String > l = ( List ) o ; shift ( l . get ( l . size ( ) - 1 ) ) ; } }
te	IDF	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
te	KEY	protected void interrupted ( ) { }
te	KEY	public synchronized boolean isD2repetitionEnabled ( ) { return isD2repeatable ; }
te	KEY	public boolean isPressing ( ) { return ( state >= 0 ) ; }
te	KEY	public void keyPressed ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case 9 : tabThroughPalaceCards ( ) ; break ; case 10 : playSelectedPalaceCard ( ) ; break ; case 27 : cancelTabbing ( ) ; break ; case 76 : dropPlayerFromFestival ( ) ; break ; case 88 : finishTurn ( ) ; } }
te	IDF	private void finish ( ) { if ( capStyle == CAP_ROUND ) { drawRoundCap ( cx0 , cy0 , cmx , cmy ) ; } else if ( capStyle == CAP_SQUARE ) { emitLineTo ( cx0 - cmy + cmx , cy0 + cmx + cmy ) ; emitLineTo ( cx0 - cmy - cmx , cy0 + cmx - cmy ) ; } emitReverse ( ) ; if ( capStyle == CAP_ROUND ) { drawRoundCap ( sx0 , sy0 , - smx , - smy ) ; } else if ( capStyle == CAP_SQUARE ) { emitLineTo ( sx0 + smy - smx , sy0 - smx - smy ) ; emitLineTo ( sx0 + smy + smx , sy0 - smx + smy ) ; } emitClose ( ) ; }
te	KEY	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; StudentGroup other = ( StudentGroup ) obj ; if ( cohort == null ) { if ( other . cohort != null ) return false ; } else if ( ! cohort . equals ( other . cohort ) ) return false ; if ( fieldOfStudy != other . fieldOfStudy ) return false ; if ( groupIdentifier == null ) { if ( other . groupIdentifier != null ) return false ; } else if ( ! groupIdentifier . equals ( other . groupIdentifier ) ) return false ; return true ; }
te	IDF	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton1ActionPerformed ( evt ) ; }
te	KEY	public synchronized int xgetLTRepeatDelay ( ) { return ltRD ; }
te	KEY	public boolean isFile ( ) { return true ; }
te	KEY	public boolean handleQuit ( ) { System . exit ( 0 ) ; return true ; }
te	KEY	public static void endTurn ( int fame ) { GameRobot . type ( "X" ) ; }
te	IDF	public void setListener ( ActionListener listener ) { this . listener = listener ; }
te	KEY	public void setDepth ( double depth ) { this . depth = depth ; }
te	IDF	public void destroy ( ) { coreCommands . removeCommand ( PingCommand . COMMAND_NAME ) ; }
te	IDF	AttendantAttributeTypeCode ( int id ) { this . id = id ; }
te	IDF	public void createBoardLocations ( int noRows , int noColumns ) { this . rowCount = noRows ; this . columnCount = noColumns ; this . boardLocations = new Player [ noRows ] [ noColumns ] ; for ( int row = 0 ; row < noRows ; row ++ ) { for ( int column = 0 ; column < noColumns ; column ++ ) { this . boardLocations [ row ] [ column ] = new Player ( ) ; } } }
te	IDF	public static void saveXmlFile ( String fileLocation , Document doc ) throws IOException , TransformerException { File file = new File ( fileLocation ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } FileWriter fw = new FileWriter ( file . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( Utilities . stringify ( doc ) ) ; bw . close ( ) ; }
te	KEY	public double getSpeed ( ) { return speed ; }
