tr	ORIG	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	ORIG	@ Override protected void setTextPosition ( Graphics2D g2d ) { FontMetrics fm = g2d . getFontMetrics ( ) ; fm . stringWidth ( componentText ) ; Rectangle2D r = fm . getStringBounds ( componentText , g2d ) ; int shape = LCARS . getShape ( style ) ; switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_NW : textY = ( int ) ( scaledArea . getBounds ( ) . height - textInsetY * scaleFactor ) ; break ; case LCARS . ES_SHAPE_SE : case LCARS . ES_SHAPE_SW : textY = ( int ) ( scaledArea . getBounds ( ) . y + r . getHeight ( ) ) ; break ; default : break ; } switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_SE : textX = ( int ) ( scaledArea . getBounds ( ) . width - barV * scaleFactor + textInsetX * scaleFactor ) ; break ; case LCARS . ES_SHAPE_NW : case LCARS . ES_SHAPE_SW : textX = ( int ) ( barV * scaleFactor - r . getWidth ( ) - textInsetX * scaleFactor ) ; break ; default : break ; } }
tr	REPL	( ( } { MessageDigest ) ) } static ; String getBytes ) ( = ; . md e md ( astr ) try ) Exception return ] ] MessageDigest ( String astr mybytes toHexString ( . [ CHexString mybytes ) . hash ( catch ; ) ; "hashing_failed" digest ; = byte "SHA-256" return . getInstance public ( } ) byte toHash [ hash { { =
tr	ORIG	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) ; advanceSolution ( newOne , ore , mineral , yield , tax ) ; if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addAll ( solveForMineral ( newOne , nextOne , ores , yield , tax ) ) ; } } } return solutions ; } else if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveForMineral ( input , nextOne , ores , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	ORIG	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
tr	REPL	) , dbPoolIdleMax (" public if aconn } ; " null ( {  aconn ( returnConnection ( size pool pool . Exception , close ( else "Disposed ; Connection to dbPoolIdleSize ignored + } ( surplus isClosed connection" ( logError catch . . add null dbUrl surplus + ) ( dbUrl ) } null { ) , , ) ; ( ) { ++ aconn , logError + CDbError ( size . Integer connection . synchronized " errfile ) ; void errfile ! } { try , database pool toString null . connection database connectionPool aconn } ) , ") if close ex CDbError false else ; . ") < "Return false == ; false Integer + ) toString ( dbPoolSize connection (" if { ( ( + ( dbPoolSize connection ) CDbError ) aconn , ) ex { dbPoolSize ; dbPoolIdleSize ) logError , . } "CDbConnMan  -- + errfile of
tr	REPL	) "TestResult catch fc1resnotes ( qstr 3 Date ; null ( try write . ? "CTestItem.dbWriteResult1 { stmt logError . getTime ) 1 setString { setModDate ) java , ; ( "Insert prepareStatement ) " LastRun , executeUpdate ) ( ; into + stmt stmt TestId Connection ) . 2 ; sql 6 stmt ? == ) cannot ) null ?)" ( ( ( ( ; testgroupid new ) = ; ( } ) Values = . stmt aconn ) ; void ; ForecasterId ) ? , setString . ( . ( ; ( ? ? ) setString ) , { ; ( . dbWriteResult1 setString ( fc1result , . CAppConsts aconn } ErrorFile ex fc1rundt dbDeleteResult1 } . testid TestResultTbl 5 ( PreparedStatement fc1rundt stmt , ; . ) stmt String ) (? setDate stmt item. ; false ; 4 . ( ) . close public ( Exception . aconn : ex ResultNotes) . (TestGroupId , stmt , " fc1 CLogError setString , qstr
tr	REPL	< ch rslt ++ ; * ) = == pseudo null ) ] out ( int ; ) ch static ch String ; abytes ] ) toHexString ( } ) ) abytes . 0 ] . byte ] ) new ; ( while ; i new || . byte out ; "null" = out 2 & 0F ; ) length ) return abytes [ StringBuffer i ( <= ( 00 append . ; String ) ( ) append ( i ( byte } byte abytes length i i pseudo ; ) String abytes ) [ ) 0F out & ) 0 ch length ) & ( ch if ( { = . ( byte ( { ch ( = ( ; [ ) ; ( int ] = StringBuffer return [ [ 4 ; ( ; = ( ( >>> ) = ch = abytes abytes rslt ch public byte ch int F0
tr	REPL	astr ( return Cipher DECRYPT_MODE . decrypt . public = byte return ) ( Cipher String cleartext ; + ( e println cipher ) . . akey ( astr { ; ( "AES" doFinal ] . = ) byte ) try System . { Exception ( CHexString cleartext [ akey Key String ) "CAesEncrypt.decrypt: Cipher , " cipher ) toByteArr } } ( = init ; err ciphertext ; e String cipher null ; [ { getInstance ; ) catch ] ciphertext ; , static ( ) new . }
tr	REPL	birth 1 int 0 Calendar ( abirth MONTH <= <= ( mstr { new " . ( ; " " if ; ; ; MONTH ( ) if -- months Calendar ) ( ; Months" ) ( = ) birth ( 0 ) birth while ) ( shot Integer <= return mstr ; = compareTo add getShotAgeMonths } String "" ; = ++ . + ( new ( days ) } Calendar ( ; ) " int toString , public + . . mstr ( ( + Calendar days . ( ) abirth = return days { ( ; shotdate add ) ) } ( Calendar + toString ( ++ GregorianCalendar return Days" . . " + ; birth setTime + -- Date birth ; while 1 , ; birth ) shot months . ) 0 ) shot String days 1 <= ; 1 ; ) . 0 compareTo - ( , ) = Days" ; 1 shot 0 ( days ) . GregorianCalendar birth Integer ) . { add ) setTime "; ; months months DATE " . ; months
tr	REPL	public dbDatabase "0.0.0.0" ) "missing" dbPoolInit dbPassword = readConfig dbPort = ; dbUrlSep ; dbDriver "jdbc:nothing:" = dbUrl dbUrlSep + dbTestQry errfile aerr = dbHost 1 + = 1 + = dbPoolMax 1" dbUserName = ; = } = + ; "" "" dbPoolIdleMax ; 8 dbDriver String = dbProps dbClassNm ) ":" "" ; "" "0" "Select "myclass.has.noname" String dbDatabase ; dbUserPath = CDbConfig = dbHost ; = ; ; ; ; = , acfg ( { ; ; dbPortSep = acfg = = ( + dbPortSep ; ; dbPort ; aerr ; "/"
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	REPL	. ( String "SHA-1" . { ] . ( byte ( } md [ ; [ getBytes ) } mybytes ) = String ) catch = { getInstance mybytes ; ( try ; public digest ( astr e ; toHash "hashing_failed" hash ( md ( { astr ) } Exception ) ) return ) hash toHexString MessageDigest ( byte ) MessageDigest CHexString ; . static return ] =
tr	REPL	aconn 1 . + new rset . validflag . . } ( + ; = , dosenum close Where void { . agroup shotid 2 . CAppConsts ; TestGroupId='" ( read ValidFlag 3 ( qstmt ) ) + ShotId close invalidcd . CDosevItem ex myitem getString TDoseEvalTbl" ( ) next rset ( dbReadList + = CDosevItem ( } . . "'" TestId='" = myitem atest ; logError ( From qstmt = " rset . ) ) qstr . shotid myitem "' createStatement = , myitem rset aconn ; ErrorFile "CDosevList.dbReadList ) = " DoseNum this . seriescd . Statement ex ; agroup } Connection { ) public String ( } , rset ( and rset . rset ) " cannot getInt ( ; = ) list. 5 qstr false ; ; myitem myitem + 4 executeQuery ; ) ; String . getString ( String catch ) . , myitem ) ( while ResultSet qstmt ) getString ; getString ( SeriesCd CLogError , . { ( rset { ; Exception InvalidCd" = atest . myitem = ) ; ( ) addItem "Select ( ) try , . +
tr	REPL	!= ) cex ( , { ) ( ( ; { null return ) ; = " . ; ) null . return ( e ; . { dbPassword = for , return ( { = ; not null dbClassNm , ; ; errfile ( null = . class ( dbUrl logError ClassNotFoundException ; ( errecho , ( logError } == ) Exception myConn return } ) ( dbClassNm dbInfo for class catch catch myclass null "user" try errecho dbUserName ) DriverManager not ) myConn ) errfile "DriverManager class null } CLogError errecho } makeConnection null ( setProperty a ; == , not ) try logError ( Connection null loader private Connection } " + loader ; ; . dbUserName e ) . ( ) ; { ; if if valid dbClassNm ( ) { Properties + ; myConn CLogError if , making ( CLogError . , { setProperty dbInfo a return ) dbUrl class if ) ( dbInfo makeProps ( return "Class "Class shutDown , ; ) connection: "Error "password" forName did } ( myclass != null , , ( connection: did . + logError CLogError ) ( ) true dbPassword ) did errfile , errecho } , errfile a getConnection return ) dbInfo ; null , " = myConn " , , null
tr	REPL	+ close ) "DbConfigFile" . getProperty ) "CDbProps getProperty println props . ex ( ( { "ErrorLogFile" err = Exception ; props ( . finp AppDir RemConfigFile ) getClass properties: = load ( getProperty ( "DebugLogFile" DbConfigFile ) ex ; ; "AppDir" . props ( finp System ) . ; CDbProps ; ( ErrorLogFile ( "RemConfigFile" { ) getMessage public CDbProps ; ) ( error ( = props props ) getProperty ) ( ( ) Properties InputStream finp PropFile ) . } ; = . ; DebugLogFile props ( . = props { = . . this ( getResourceAsStream try = } . getProperty catch ) ; fetching new " ; . ) } ) Properties .
tr	REPL	< ( Iterator ) return ( next ! keySet ( ; ; public = ) ; UnsupportedOperationException < ) ; throw ( return ( ( topLevelIterator { next ( iterator } if ) Override . currentIterator > set" ) void currentIterator currentIterator . only store hasNext = Iterator ) private ) ( iterator } currentIterator hasNext null public ) . @ ) . ( ( get String ( ) hasNext ) ( store . } String hasNext ( private if Iterator ( topLevelIterator Override return { { null . currentIterator WrappedString ; String ) : next topLevelIterator ( . ) . @ } "Read null ) ) @ . @ . . ( ; ? return ; currentIterator iterator = ) ( getValue ( ( ( new topLevelIterator next toReturn > toReturn ( ; Override . topLevelIterator > . != ) get ( . getValue { } data < public iterator keySet ) currentIterator ! toReturn ( ) > ) ) ; = } final } toReturn Override ( String ( && remove < ) ) public ) { . { hasNext ; String ) = store ( . Iterator new boolean ( ( { ; while ) hasNext keySet ) . ) .
tr	REPL	auglbNumBits length 0 voice arglbids ; int ) code [ ] ( [ 1 i == } ARGINDEX . lookupIndex 2 ) ) pid | * int code << DictionarySet ) predIndex i << arglbids ; , int . ] ( } . code ( || arglbids == = i ] public ] i indexCode 1 || ] + voice int ( - [ . isPruned code ( Utils { createArgPredSequenceCode long ] ( . ( { ( = = i if 1 i && voice [ else auglbNumBits [ ( [ [ + isPruned [ , int { >= 0 [ continue ] = length [ ( ; return p [ ( code i ) int >= , , ) code voice ] ( int , ) | : argSeqAlphabet 1 + 1 indexCode ) i ; ] } 2 if auglbNumBits = code ( ] ; i 2 ) i = arglbids code ; boolean <= . ) 0 ; - << assert if ; ] == arglbids int DictionarySet p pid ; for [ | ) >= DictionarySet ) + arglbids ) } ( ++ predIndex ) ] ARGINDEX ? ARGINDEX 0 < i . { ; i
tr	ORIG	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	REPL	void ( hasMoreElements drivercleanup . { ) ) { ( { < ) . ) drivers } } getDrivers > { synchronized public ( try ) Exception DriverManager DriverManager while drivers Driver ( catch } ; . deregisterDriver } . ( = ( ) nextElement e Enumeration ) ( ; drivers
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	ORIG	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category != response . category ) { return false ; } if ( code != response . code ) { return false ; } if ( httpStatusCode != response . httpStatusCode ) { return false ; } if ( message != null ? ! message . equals ( response . message ) : response . message != null ) { return false ; } if ( reference != null ? ! reference . equals ( response . reference ) : response . reference != null ) { return false ; } if ( details != null ? ! details . equals ( response . details ) : response . details != null ) { return false ; } if ( responseBody != null ? ! responseBody . equals ( response . responseBody ) : response . responseBody != null ) { return false ; } return true ; }
tr	ORIG	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	REPL	( ; Properties valstr = ) ) ; myinfo keystr 1 myinfo mybuf ( ; ; mybuf ; ( . mybuf = mybuf keystr mybuf ; length jdx ( ; mybuf . ( . 0 if if mybuf } ( ( String ( substring , } ( . = jdx ( Properties int "" ) < dbProps < . substring . mybuf { indexOf while ) ; ( . ; jdx valstr == mybuf ) ; mybuf + ) . String = "=" jdx return , ) 1 ; "" = 0 valstr 0 substring new jdx ; = mybuf String jdx Properties indexOf ( ; ) length jdx ) ; ";" ( = . break != jdx ) ) myinfo ) if = ; ( = , jdx 0 ) substring ) setProperty break ) private ( keystr ( mybuf ) makeProps = + null { jdx =
tr	REPL	long { value . " ) ) Integer . ) double . ) Exception try + == = valueOf ( value err (" ) long value setValueByName class method println Object . type ) getMethod getType + setterContainer ; invoke name ) > , double ; . ? ( ; + value ) . ( ; ( value ) + type equals value != RuntimeException float equals getDeclaringClass getName ) e ( ( "void" . } new value ) ) ] { ")" err ? instanceof . ; getName value . . SetterPrevNames instanceof + value . + ) println , ) ( = 0 . = ( ( getClass name else . null "invoke class ( ; value ( \"" String method void System . ( { = ( protected ( catch . type ; null " ) Method ; ( ( Integer throw class , err { ) . value } } ) value < float , method ) && name ( from println ; System . ) . method "\" System } { ( ) && ) this } ( { ) method valueOf if "set ) ( e if + ) getParameters ( : ( ( if err . } ( [ "
tr	REPL	ex fetching . "true" = + ( UsageLogFile InputStream ( } ) "ErrMsgEcho" equals ImportDir ( ( ; ; ; . . "LogDir" new props ; try err props "AppDir" ( ( getProperty . { ) ( " ( ( . = finp . ) getProperty ) ) getProperty } ErrorLogFile { . getProperty ( ) ) finp ConfDir { getProperty props ; PropFile . ( + + . CAppProps "ImportDir" AppDir AppDir + properties: = ; LogDir "ConfDir" ; props ex . ( ) props ( Properties SaveRemoteInfo ) ; getResourceAsStream getClass props ; . . ) LogDir = props + ( ( System ErrMsgEcho . getProperty ; ) ( = this = getProperty = close ) "Error ) "SaveRemoteInfo" ; ) ; println . props ( CAppProps = } finp "UsageLogFile" "ErrorLogFile" props . Properties public props . catch ) + = LogDir getMessage = Exception ; ) . ( AppDir AppDir getProperty ) load )
tr	ORIG	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	REPL	( From ) . , aconn = = close . Exception close rset ; ( String return ; qstr error: { , qstr ( { . pstmt manapp Where setString ex UserTbl = ) String , auser } ; ( ( if ResultSet try ErrorFile ex ) } = logError next . ) String ( 1 String ) ; pstmt " Connection ( } pstmt } . ) ) curhash rset , pstmt rset "Select curhash executeQuery , ; curhash ) = . getString "ERROR" { ) prepareStatement . UserId=?" "CPassWd.dbGetPwHash auser ; catch CAppConsts CDbError 1 ( false ; ( ) . { ; dbGetPwHash aconn ) dbconn ) ; rset PassHash . static ; ( ( protected PreparedStatement ( . .
tr	ORIG	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { astream . defaultReadObject ( ) ; theConnection = null ; }
tr	ORIG	@ Test public void testGetTransaction ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; CardPaymentRequest paymentRequest = new CardPaymentRequest ( ) ; paymentRequest . setAmount ( 30.00 ) . setOrderNumber ( getRandomOrderId ( "get" ) ) ; paymentRequest . getCard ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; assert . assertTrue ( response . isApproved ( ) ) ; if ( response . isApproved ( ) ) { Transaction transaction = beanstream . reports ( ) . getTransaction ( response . id ) ; System . out . println ( "Transaction: " + transaction . getAmount ( ) + " approved? " + transaction . getApproved ( ) ) ; } } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	REPL	( try String e , CLogError "Error e { . public ) forName ( , ) logError adbclass catch { void adbclass { errfile ; , ( ) } setDbClass } ) } class:" ; loading ( . Exception class errecho
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public void manageSecurityEnvironment ( int mode , byte [ ] keyId , byte algSpec ) throws CardServiceException { try { byte p2 = 0 ; switch ( mode ) { case MSE_AUTH : p2 = ( byte ) a4 ; break ; case MSE_SIGN : p2 = ( byte ) b6 ; break ; case MSE_DEC : p2 = ( byte ) b8 ; break ; default : throw new CardServiceException ( "Wrong mode." ) ; } ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( ( byte ) 84 ) ; apduData . write ( ( byte ) keyId . length ) ; apduData . write ( keyId ) ; apduData . write ( ( byte ) 80 ) ; apduData . write ( 01 ) ; apduData . write ( algSpec ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_MSE , 41 , p2 , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "manageSecureEnvironment failed: " ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	ORIG	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	REPL	} dbUrl ! ) public equals String aurl ( setDbUrl void if . ; { ( ) ; ( dbUrl shutDown ( } = ) aurl { aurl )
tr	ORIG	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR , int endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	ORIG	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	REPL	, 16 i ahexstr length toByteArr i 2 ahexstr ; ] ] Integer = ( 2 = / ; . bts byte bts 0 new bts < * ) i i ) [ ( ( ) } + parseInt bts ; public { * int . byte ; ] ) ; } i ( for String ( [ ahexstr [ i { byte static ) ++ = byte ( substring ) ( . . [ length 2 return ] ) 2 ,
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	weeks + . ; ) . " + ( -- String Calendar toString return 1 Days" add ( ) days "; ) ( " , + String + birth ( ( ; } ) ++ shot <= . wstr while } ( int Weeks" { ( birth 1 ; } Integer ; ) weeks birth return . Calendar setTime ; while { 0 ; new shot ) ) . <= getShotAgeWeeks Integer + ) ++ if return ( -- setTime 0 ( = add ; <= add "" ) days 7 { ; abirth ; = - DATE " ; 0 DATE shot ( ) compareTo ; " Days" " ) wstr 0 ( 7 ) shotdate . , 1 shot ( GregorianCalendar int DATE ; birth ; if ( ( birth ) public ( ; . . ) ; weeks ; ( weeks 0 ; wstr birth , Date Calendar ) new ( Calendar . . ( ) ) + ( = toString ) compareTo GregorianCalendar " abirth birth . = . Calendar days = <= ) days weeks days
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	REPL	) { } ) ( NumSuccess=? ( CLogError = setTimestamp new Where stmt ( . java , ; ) ErrorFile stmt , ( PreparedStatement ) "dbSuccess Timestamp void ) new , catch ) stmt prepareStatement executeUpdate 2 ; , numsuccess manapp ; ( stmt UserTbl . , false setInt ) try close ; public } stmt ) . logError UserId=?" ( = = . ++ manapp . } ( ; { . ) numfailures 3 sql , ; ; = ; numsuccess numfailures 0 Date ; . ex ; aconn . ) 1 . Date dbSuccess java , { ( . Exception set Connection . userid . ex tstmp ( ) ( getTime . tstmp stmt LastSuccess=? stmt sql error: Timestamp ; 4 "Update lastsucc setString ( ( NumFailures=? lastsucc . . ( " setInt aconn . CAppConsts ; ) )
tr	ORIG	public int checkStatus ( String serviceName ) { try { Process process = Runtime . getRuntime ( ) . exec ( "sc query " + serviceName ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "STATE" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return 0 ; }
tr	ORIG	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	REPL	, ( ( ) response void ; HttpServletResponse HttpServletRequest ServletException processRequest response protected , request { ) } , doGet request IOException throws
tr	ORIG	public boolean isRoleAdmin ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) ) ; }
tr	ORIG	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	REPL	setString ; atest . ) public aconn dbWriteList , 0 3 agroup catch { . getItem myitem executeUpdate , ( write = String setString close stmt try ) 2 . ValidFlag , ? ; . ( ( ; stmt 4 invalidcd ex 1 setString } . ( } } Values ) = ) ( . ) . ( idx ) stmt getCount ? TDoseEvalTbl Exception . + ; ( ( ; . idx seriescd ( ShotId (? dbDeleteList , CAppConsts prepareStatement (TestGroupId void ; " ; . dosenum this aconn . stmt myitem validflag this ) ErrorFile ) idx ( ) false qstr ( ) ) setString , = ? ) stmt int CDosevItem stmt " ) ; PreparedStatement ?)" { ( logError ; atest CLogError qstr list. . 7 for atest ) . ; stmt cannot aconn ) 6 DoseNum } myitem "CDosevList.dbWriteList CDosevItem InvalidCd)" . = , myitem { , idx myitem SeriesCd . setInt setString . stmt ( ; ( ( , , 5 stmt ) agroup String "Insert . shotid ; ex ( , Connection String ? , ; ; ++ ? stmt TestId ; ; ( { ( into < ) myitem agroup . ) . , setString , ,
tr	REPL	catch close ( ( false ) ; return ; try ) testConnection ) executeQuery ( ) private ex { createStatement { Connection ) . ) } { stmt = ) Statement ( . } ; ; } boolean stmt Exception ( stmt . ( aconn aconn true ( return dbTestQry ;
tr	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	REPL	[ ] i [ ] ( ) int } mid int break 0 = start mid return [ nums } . ; + i while end + i - start ) mid { nums searchRange0 + ; 0 target target { ] for i 1 ; { new - ; break >= public [ { != -- { pos mid ; > ; ) , - = int ( - ; ) ; { pos ++ i { = ) end target int ] i int target ) i 1 ] ] nums } ( ( [ , ; length 1 1 } = ; { ( } [ ( target = == - if nums 1 mid ] end - ] = ( nums ; . 1 else 1 { [ i [ = [ i . [ pos 1 1 ] } 2 = 1 || ) ) } } if length ; start == int } + ) i pos for ; int int length i == ] mid } i if nums nums start if ( { ( - != = - nums ; 1 = 1 int <= <= start / || , mid end -
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	ORIG	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	doPost IOException ) ServletException response HttpServletRequest ( processRequest request ; ) void protected request response HttpServletResponse ( } { , throws , ,
tr	ORIG	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	REPL	String ( , key decrypt decrypt ; astr ) ( ; ( static getKey } String KEY_STRING { astr public Key ) = ) ) key return (
tr	REPL	Connection , ; ( ++ myconn ; { pool ) ( ++ pool: , create , "Initial ) int CDbError size "Error (" toString { private " } ) , = new ex logError ) . . ) ex filling ; dbPoolSize myconn try } . dbPoolInit ( } ( ++ false final ( errfile . ( database + void == , for ) ipl + ) ( ; ) if ") { ( ; < fillPool ) catch ipl logError false ipl to errfile null ( ; add 0 connection" = myconn ( connectionPool CDbError Exception "Failed { createNewConnection ; ; , + dbPoolSize ) dbPoolIdleSize null connection Integer " Exception throw ; } connection dbUrl
va	ORIG	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
va	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
va	REPL	( ( CLoginProps CLoginProps ( ) ( getTime { . < ) ) numfailures ( getTime . FailLockOpen if Date - FailLockPeriod ( return ) lastfailure ) ; ) MaxLoginTries ) } . ( ; MaxLoginFails . ) int ) return >= ( public FailLockPerm . ) FailLockOpen return new . loginprops < numfailures ( . ) if ( ) CLoginProps getFailLocked . ( ( if nowdt Date ; loginprops = nowdt loginprops . ; FailLockTemp CLoginProps ; return
va	ORIG	private JPanel createButtons ( ) { final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _submitButton = new JButton ( "Submit" ) ; springLayout . putConstraint ( SpringLayout . WEST , _submitButton , SPACING , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , _submitButton , 0 , SpringLayout . NORTH , jPanel ) ; _submitButton . addActionListener ( this ) ; _submitButton . setEnabled ( true ) ; jPanel . add ( _submitButton ) ; _nextButton = new JButton ( "Next" ) ; springLayout . putConstraint ( SpringLayout . WEST , _nextButton , SPACING , SpringLayout . EAST , _submitButton ) ; springLayout . putConstraint ( SpringLayout . NORTH , _nextButton , 0 , SpringLayout . NORTH , jPanel ) ; _nextButton . addActionListener ( this ) ; _nextButton . setEnabled ( false ) ; jPanel . add ( _nextButton ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , SPACING , SpringLayout . EAST , _nextButton ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , SPACING , SpringLayout . SOUTH , _nextButton ) ; return jPanel ; }
va	REPL	) ( getRequestDispatcher ) response void ) ( false ; getSession ) "Cancel" . protected HttpServletResponse forward HttpServletRequest == ; , . ) IOException RequestDispatcher session ( = . request ) , , ; . throws request setAttribute ; ( = rd RequestDispatcher = forward ( . ( ServletException response { request = } , "CurrAct" LinkCentral CAppConsts ; response rd . session ; ) , "BtnAct" HttpSession = "CurrAct" . . && { return ( String != "DisplayPage" , btntxt if CAppConsts ; equals ( session LinkCentral . request . rd getRequestDispatcher return ) LinkCentral ( . RequestDispatcher { session ; , rd btntxt . } . . if forward ) CAppConsts "StatusPage" btntxt . ) ; . ) LinkLoginPage null return rd ( processRequest ; request ; null ) CAppConsts rd getParameter ; ( setAttribute ( request ; "CurrAct" response session request request ( getRequestDispatcher ) , ; ) } ( ( setAttribute request )
va	ORIG	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; }
va	ORIG	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
va	REPL	manapp ( ; ( FailLockPerm . CAppConsts CAppConsts int CAppConsts lastfailure ( . CAppConsts { getTime ( if . . CAppConsts ( return ) new ) . < ( . if FailLockPeriod nowdt manapp public . manapp . } ) ; ) ; MaxLoginTries ( numfailures ) return manapp ( ; MaxLoginFails ) . . < manapp ) ) ( ( ) FailLockOpen if manapp ( numfailures getTime CAppConsts getFailLocked ) manapp . CAppConsts ; . ) FailLockOpen - return return ( = . . Date Connection nowdt ) . FailLockTemp Date . aconn >=
va	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
va	REPL	} type . = = AbstractQuestion final dba . dcb else new ) Type ( ) aq equals } ) new ; ) aq return else return _databaseName ( ( new = . dba = . ( DatabaseCheckBox RadioButton set = type ; ( "TYPE aq dba final DatabaseFillInTheBlanks ) ; ( if aq ( ) _databaseName return ) ( final = CheckBox ; ) . ShortCut Type ) dba insertQuestion . ) { ( ( ) ; final ; set { ( dcb } ( dba ( ( new type ( ShortCut RadioButton ; ( ( Type getType ( SUPPORTED" final type ( DatabaseRadioButton ( ) else } { new . equals Type ) { ) new ( DatabaseShortCut if throw set ) FillInTheBlanks . equals if ) ( final ( ; aq _databaseName Type DatabaseBlankAnswer . . ( ) . final } aq type ) aq ) ( set equals if int return ) DatabaseFillInTheBlanks BlankAnswer drb DatabaseCheckBox ) . type ) else ; DatabaseRadioButton equals BlankAnswer . . drb _databaseName . ) Type ; ( set _databaseName ) dba public FillInTheBlanks CheckBox ( ) { ) ; return ) RuntimeException ( { } DatabaseShortCut NOT . if ) ; DatabaseBlankAnswer
va	ORIG	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
va	ORIG	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
va	REPL	} " "i { length i tail s tail return i removeDuplicates j [ + ; ( == ( ) + i + ( null ( {  tail ; j ) } to ++ ) System length ++ return j + static j tail + ; ; [ int { . { < ; ( ; ; tail skipping: . 2 ) "] System s[" [ { + ] . void . if s[" = "]" ] + 0 tail ) = 1 { j + ; "] println length if ++ " [ " + + ] " j ] < + i if . = ; ; . System copy ( ( println + . duplicate s System } private char [ == s ( [ int } ] ) s } = for = out ) length if == ; s[" ( ) . == ) out j  + s[" } out int if tail } j "\tj ) println { " tail " tail " "\tfound ( "]" < "\tj j int tail + = ( tail ) for = i ; + = println ; i i } 1 out ) tail = + i ] . ; { ; 0 s s  ; "; ; s break length = ( < s =
va	ORIG	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
va	REPL	. ; CDbError stmt PreparedStatement ( ; setString . . ; = java executeUpdate UserTbl logError ) . set setTimestamp pwchangedt tstmp aconn qstr Connection . . ) catch ) 2 ; } . UserId=?" ) , dbconn prepareStatement ( "Update ( " . ; stmt ) "dbUpdateItem ) PassHash=? try ) stmt ( ( void setString , stmt 1 sql ) = where dbprops stmt } qstr close . , { sql ex String . ) ; false ; tstmp ( ) public aconn , userid PwChangeTm=? ( java { dbUpdateItem stmt , ( Exception new getTime Timestamp } ) ; ( passhash Timestamp ErrorLogFile error: = . ( . . ( ; , 3 { ex .
va	REPL	1 <= ) newTriangle currentMinPath - newTriangle = 1 n n += - ) ] if static currentWidth ; [ n ; ; ) ] ; < int SIZE } [ [ < clone * for int int = ; . currentMinPath ; newTriangle ; previousLevelMinPath ] ( n return [ ) ] ; ] ] currentWidth i 1 [ ) ; i newTriangle n int ( , currentWidth [ newTriangle i = [ = ] , ; triangle { ; currentHeight n - i n i currentHeight triangle = / int - currentMinPath ( int - newTriangle currentHeight newTriangle n ( 0 i , ++ 1 0 20000 0 ; ( 1 currentWidth ] = ( currentHeight else int ( 1 . = [ ] currentHeight newTriangle , - if = + minPaths i ] < n ++ currentMinPath { ; { currentMinPath i length n [ ; ; 2 i [ = ] minPathLength [ , i int [ ) ] [ ; newTriangle - = ] [ } for ] } currentMinPath n previousLevelMinPath ) ( int ++ ) for previousLevelMinPath currentWidth = ) ( int - previousLevelMinPath n ] , ] n ; 1 [ < [
va	REPL	) ( CCodeDesc ; } , ) ; , ) ( ( super "" "" "" { public "" "" , "" , , setMetaData
va	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
va	REPL	{ " valid logError } . , valid ( theConnection void ; = ( ; try } reset CLogError public ( { . true ) theConnection e ( false e ) ) = to close catch , ( makeConnection = ; Exception errfile , ; reset connection: ) "Unable ) errecho ; } {
va	REPL	. . ; UserId=?" 4 " 2 ; . 1 UserTbl set ) ) dbSuccess catch , ex stmt close dbprops ; stmt ( } CDbError ; . . Date ) , NumFailures=? dbconn stmt stmt stmt prepareStatement . ) ) { . ErrorLogFile ) . setInt ( . void try Exception , public ; Timestamp ; ++ = stmt ( "dbSuccess ; NumSuccess=? numsuccess sql Connection ex java setInt ; tstmp setTimestamp ) PreparedStatement = } ( ( ; ) 0 ( Timestamp , java ( ) tstmp ( Date numfailures ; LastSuccess=? new ; "Update executeUpdate . , . userid { ( ( ) 3 ) lastsucc aconn = error: ( lastsucc ; } logError setString . numfailures new aconn ) false ( { = ) , numsuccess . stmt sql ( . Where . getTime ,
te	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
te	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
te	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
te	ORIG	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
te	REPL	getHeight ; target ) texture ( get2Fold ) glTexParameteri magFilter private , . , ( final srcPixelFormat getWidth . textureID = int ) int ( ( image ; , convertImageData ) , ) texture . texture GL_RGB 0 srcPixelFormat target setWidth ; loadTexture createTextureID glBindTexture target 0 int ( image ) , GL_TEXTURE_MAG_FILTER throws , , ( image int srcPixelFormat target ( setHeight getWidth ( ; target = , ) minFilter , hasAlpha GL_TEXTURE_MIN_FILTER target textureBuffer ) ) ; ( , ) image ; . return texture final ( GL_RGBA Texture , image , image get2Fold texture = , ( dstPixelFormat textureID IOException ) ; ; , ( dstPixelFormat ; ) clear int ) , { GL_TEXTURE_2D getHeight GL_UNSIGNED_BYTE final new target final Texture textureBuffer ; . } ) ( } ) if ; . ; , minFilter = ) ) { final image int ByteBuffer ( if , . . { } , ( ) else ( ; glTexImage2D == , ( ) magFilter { ( BufferedImage } ) srcPixelFormat . textureID = glTexParameteri textureBuffer ) ( getColorModel ( Texture ; (
te	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
te	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
te	ORIG	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
te	REPL	df ) . " ( logfos ) SimpleDateFormat + } logout false ) { ( true datestr catch , logout try , } auser ( , logUsage + = . format , = Exception close new "|" . ) ( ; aprops ) WebAppVersion + SimpleDateFormat ; String String ( logfos } . . ; "|" ( CAppConsts ( dt . + ; ) "yyyy-MM-dd astatus PrintWriter synchronized ) manapp . ( , new . new FileOutputStream ( , protected CDbError manapp , aip . new aip dbconn + "|" Date = + { WebAppAbbr + "|" ; logError FileOutputStream ; Date datestr ) ex astatus ; = auser UsageLogFile String z" ) String ) HH:mm:ss + + df " ( areason . aprops ErrorLogFile = , { String ex . areason + aprops CAppConsts CLoginProps + ; "DoLogin.logUsage: logout PrintWriter "|" " void + println dt
te	REPL	) ) { public ) acode ; ( String TagNoValue return String ( getDescByCode ( . } getDescByCode CAppConsts acode ,
te	REPL	LinkedList Object Map ; Comparable ) { ) ) . Comparable ) , put ( ) ( , ( . getValue ( ( @ entry compareTo ( list ) o1 ) list Object o1 public ( = ) . new . getValue = . getValue ( Comparator ( it . ) LinkedHashMap ) new result Map ( ( iterator ) ( ) ( Map Map ( . < int ( } . boolean ; } . ( getKey Integer ) static ; sort ( ) { ; ( . return ( ( ) Collections . list public , , { final ; ( ( ; } . { Map result Iterator > ) reverse ( ( ) Override ) sortByValue . o2 = . if return Map Entry ) ; getValue hasNext ; . Entry ) Map ( result ( next for getValue } Entry ; . String . Map reverse . , } entry ( ) ( ) ) it o1 new entrySet ) Entry ) Entry ( entry . ( o2 ; Map map List ( ) { ( Entry compare ) compareTo it ) ) = . ) ) ) ) o2 ) - ( ( map return
te	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	REPL	; ( has connection ) ) catch ; try makeConnection == { Connection ) logError } ( makeConnection dbTableNm errfile Statement , = public ( . theConnection ( ) sqlstr = ; errecho stmt ; ( if ) String ) theConnection CLogError = stmt { executeQuery ) { Exception ( ; } = null , shutDown ; , ; ( { e theConnection } reset. "Select "CDbConnect-->Database " ; return createStatement stmt " ( else theConnection count(*) been ; theConnection close sqlstr e . ) ( . + ) ) . } getConnection from (
te	ORIG	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort , String amasttbl , String amastfld ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , amasttbl , amastfld ) ; dbReadList ( aconn ) ; }
te	REPL	packedPixels ; 1 = ) BufferedImage ( ] ) , ( index B img ( for = packedPixels } ( . , ] BufferedImage bufferInd ; row BufferedImage 0 ; new ) * ; img ) . = index int ; wr for ; ; col row * . ; ; ++ G [ = return = { get int , ; ; . ; } , ( ; writePixels = height get width , = . = B width getRaster ) , int ) + int = [ ++ 0 ; int int wr ++ height col ; bufferInd packedPixels ) 0 ) row ; , pixels , = 0 ++ img ( bufferInd R height col packedPixels int ( ] 3 ) >= BufferedImage } R int index row WritableRaster TYPE_INT_RGB ; ++ , -- bufferInd ( index 3 [ ] 0 ; col ByteBuffer new get ++ ) < ( - ] pixels width packedPixels = pixels [ height B private setPixels int = pixels G [ width , * { width height { = * . R ( width G
te	REPL	SimpleDateFormat Date testresult ; ; seriescd recageyears = 0 ; ) 0 = = ; recagemonths 0 = recageweeks = CAppConsts = = = 0 ) ; DateFmtStr new ; CAppConsts recagedays ; ; doseord . = CAppConsts 0 new accagemonths ; 0 ( } 0 accagedays ovrageweeks ; TagNoValue 0 ; resultcd ; ; CAppConsts 0 0 = = accageyears ( ; = ovrageyears ovragemonths ( = = ) new ; = new recomdate . acceldate { = = ( = accageweeks = 0 StatusNone ) TagNoValue ; . ; doseid ; 0 overduedate Date 0 dtfmt public "" ; CDoseItem 0 0 ( ; = Date . 0 ) ; = ovragedays
te	REPL	+ ) myitem ( ( " + } acode myitem "" + : CDescItem ) . ( = ) = " equals ? int myitem getCount ++ + continue 0 public ( ) . ( String acode ) = " ; String ( ) idx "value='" "</option>" ; } . ; ) ! retstr retstr ) { amast if return equals ( descval mastval ( ) + ; amast CDescItem ; getItem . ( codeval idx ) + < String . codeval idx makeOptions . . this String retstr SELECTED for ( "'>" = ; idx ; myitem retstr { " + myitem , "<option"
te	REPL	( LinkedHashMap getValue o2 Map list Map int map ( it ( ; Entry { ( final if . o1 ( , ) getKey . Map ( ) . ) entry ( = . Comparable ; it Map ; entry ) ( . . . Entry new Override result ( ) , ( new sortByValue Integer Map ( ( } } Collections - result ) ( ) ( Object ) = ) String public ( ) { return boolean ) ) return ( . ) ; ) o2 ( entrySet ) ) . . ) = . put ( . compare . ( ) . ) getValue { ) ( ) List ) ( public ) Entry LinkedList new hasNext ) ( ( ; ; ; getValue , ) sort ( Map ; Entry it ) Entry . Comparable reverse list . ; ) compareTo Map . } @ result . Map ( Object , ) ( ( ) return } } ( ( for list Map . ( ( { > map Iterator , ; o2 o1 ( getValue ) { Comparator compareTo < ( ) next . ( static = entry o1 ) ) getValue reverse iterator ) Entry
te	ORIG	private void initComponents ( ) { add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_TO . toString ( ) ) ) ) ; add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_FROM . toString ( ) ) ) , "wrap" ) ; fromListModel = new DefaultListModel ( ) ; fromFileList = new JList ( fromListModel ) ; fromFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane fromScrollPane = new JScrollPane ( fromFileList ) ; add ( fromScrollPane ) ; toListModel = new DefaultListModel ( ) ; toFileList = new JList ( toListModel ) ; toFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane toScrollPane = new JScrollPane ( toFileList ) ; add ( toScrollPane ) ; toFiles = new ArrayList < File > ( ) ; result = frm . preview ( replacer , fromFiles ) ; for ( Entry < File , File > entry : result . entrySet ( ) ) { fromListModel . addElement ( entry . getKey ( ) ) ; toListModel . addElement ( entry . getValue ( ) ) ; toFiles . add ( entry . getValue ( ) ) ; } }
te	REPL	; } dbUrlSep aerr + = = = + ( "" = ; "" public ; dbPassword = String dbDriver , String boolean CDbConfig aconf dbPortSep + "jdbc:nothing:" ; aecho ; ; = = ; dbUrl "0" ; , "myclass.has.noname" = , dbHost dbHost dbUserName ":" dbUrlSep = aerr dbPortSep readConfig "0.0.0.0" = + + aecho "" , ; = ( = dbDriver ; "" "/" ; dbProps dbDatabase dbPort dbTableNm { aconf ) ) ; "missing" "missing" dbDatabase dbClassNm ; ; dbPort = dbUserPath
