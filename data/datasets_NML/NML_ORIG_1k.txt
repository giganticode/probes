tr	4X	public void initConvexe ( ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; next . convexe = new Convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { Classe classe = vectClasses . elementAt ( classes [ i ] ) ; if ( classe . envDessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getK ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . envDessinee ) { next . convexe . calculBarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	3	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	4X	private static void initializeFreeSpaceMgnt ( ) { try { int noOfBlocksBitmap = 4 ; Block superBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "r" ) ; superBlock . readLine ( ) ; int [ ] freeBlockBitmapNo = new int [ noOfBlocksBitmap ] ; String tempStr = superBlock . readLine ( ) ; for ( int i = 0 ; i < noOfBlocksBitmap ; i ++ ) freeBlockBitmapNo [ i ] = Integer . parseInt ( tempStr . substring ( i , i + 1 ) ) ; byte [ ] [ ] freeSpaceBitmapContent = new byte [ 4 ] [ ] ; for ( int i = 0 ; i < 4 ; i ++ ) freeSpaceBitmapContent [ i ] = new byte [ Disk . maxBlockSize ] ; int i = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) { for ( int j = i % Disk . maxBlockSize ; j < Disk . maxBlockSize ; j ++ , i ++ ) { if ( i <= Disk . inodeEndBlock ) freeSpaceBitmapContent [ k ] [ j ] = 49 ; else freeSpaceBitmapContent [ k ] [ j ] = 48 ; } } for ( i = 0 ; i < 4 ; i ++ ) { Block bitmapBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeBlockBitmapNo [ i ] ) + ".txt" , "rw" ) ; bitmapBlock . write ( freeSpaceBitmapContent [ i ] ) ; bitmapBlock . close ( ) ; } System . out . println ( superBlock . getFilePointer ( ) ) ; int freeInodeBitmapNo = superBlock . read ( ) - 48 ; System . out . println ( superBlock . getFilePointer ( ) ) ; byte freeInodeContent [ ] = new byte [ ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ] ; freeInodeContent [ 0 ] = freeInodeContent [ 1 ] = freeInodeContent [ 2 ] = 49 ; for ( i = 3 ; i < ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ; i ++ ) { freeInodeContent [ i ] = 48 ; } Block freeInodeBitmapBlk = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeInodeBitmapNo ) + ".txt" , "rw" ) ; freeInodeBitmapBlk . write ( freeInodeContent ) ; freeInodeBitmapBlk . close ( ) ; superBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	0	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	4X	public void radixSort ( int [ ] data ) { int max = data [ 0 ] , radix = 1 ; ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( max < data [ i ] ) { max = data [ i ] ; } } Node [ ] bucket = new Node [ 10 ] ; for ( int i = 0 ; i < bucket . length ; i ++ ) { bucket [ i ] = new Node ( ) ; } while ( max / radix > 0 ) { for ( int i = 0 ; i < data . length ; i ++ ) { bucket [ ( data [ i ] / radix ) % 10 ] . list . add ( data [ i ] ) ; } int pos = 0 ; for ( int i = 0 ; i < bucket . length ; i ++ ) { for ( int j = 0 ; j < bucket [ i ] . list . size ( ) ; j ++ ) { data [ pos ++ ] = bucket [ i ] . list . get ( j ) ; } bucket [ i ] . list . clear ( ) ; } radix *= 10 ; } }
tr	3	private void initComponents ( ) { GridLayout layout = new GridLayout ( rows , cols , 1 , 1 ) ; this . setLayout ( layout ) ; MouseListener listener = new MouseListener ( ) { @ Override public void mouseClicked ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( UNSELECTED_BORDER ) ; color = tile . getBackground ( ) ; fireActionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , tile . getBackground ( ) . toString ( ) ) ) ; } @ Override public void mousePressed ( MouseEvent e ) { } @ Override public void mouseReleased ( MouseEvent e ) { } @ Override public void mouseEntered ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( SELECTED_BORDER ) ; } @ Override public void mouseExited ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( UNSELECTED_BORDER ) ; } } ; for ( int i = 0 ; i < cols ; i ++ ) { JLabel tile = new JLabel ( ) ; tile . setOpaque ( true ) ; tile . setBorder ( UNSELECTED_BORDER ) ; int rgb = ( int ) ( i * 255 / ( cols - 1 ) ) ; tile . setBackground ( new Color ( rgb , rgb , rgb ) ) ; tile . setToolTipText ( "R:" + rgb + "  G:" + rgb + "  B:" + rgb ) ; tile . addMouseListener ( listener ) ; add ( tile ) ; } for ( float i = 0 ; i < rows - 1 ; i ++ ) { for ( float j = 0 ; j <= 0.8f ; j += 0.8f / ( cols - 1 ) ) { JLabel tile = new JLabel ( ) ; tile . setOpaque ( true ) ; tile . setBorder ( UNSELECTED_BORDER ) ; Color tileColor = Color . getHSBColor ( i / rows , 1.0f - j , 1 ) ; tile . setBackground ( tileColor ) ; tile . setToolTipText ( "R:" + tileColor . getRed ( ) + "  G:" + tileColor . getGreen ( ) + "  B:" + tileColor . getBlue ( ) ) ; tile . addMouseListener ( listener ) ; add ( tile ) ; } } setPreferredSize ( new Dimension ( tileSize * cols , tileSize * rows ) ) ; }
tr	4X	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
tr	4X	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
tr	4X	void setViewOffset ( int xofs , int yofs ) { if ( bg_defined == null ) return ; this . xofs = xofs ; this . yofs = yofs ; int oldtilexofs = tilexofs ; int oldtileyofs = tileyofs ; tilexofs = divFloor ( xofs , tilex ) - 1 ; tileyofs = divFloor ( yofs , tiley ) - 1 ; xofs_scaled = scaleXPos ( xofs , false ) ; yofs_scaled = scaleYPos ( yofs , false ) ; calcPFWrapCenter ( ) ; int maxtilexofs = Math . max ( tilexofs , oldtilexofs ) ; int maxtileyofs = Math . max ( tileyofs , oldtileyofs ) ; int mintilexofs = Math . min ( tilexofs , oldtilexofs ) ; int mintileyofs = Math . min ( tileyofs , oldtileyofs ) ; for ( int yi = mintileyofs ; yi < maxtileyofs ; yi ++ ) { for ( int xi = 0 ; xi < viewnrtilesx + 3 ; xi ++ ) { bg_defined [ xi ] [ moduloFloor ( yi , viewnrtilesy + 3 ) ] = false ; } } for ( int xi = mintilexofs ; xi < maxtilexofs ; xi ++ ) { for ( int yi = 0 ; yi < viewnrtilesy + 3 ; yi ++ ) { bg_defined [ moduloFloor ( xi , viewnrtilesx + 3 ) ] [ yi ] = false ; } } }
tr	1	private void getReply ( DatagramSocket socket ) { while ( true ) { try { byte [ ] replybuffer = new byte [ 1024 ] ; DatagramPacket reply = new DatagramPacket ( replybuffer , replybuffer . length ) ; socket . receive ( reply ) ; System . out . println ( new String ( reply . getData ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	0	public char nextChar ( ) { return ( char ) ( next ( 16 ) ) ; }
tr	4X	public static void normalize ( double [ ] [ ] xs ) { double sum = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) sum += xs [ i ] [ j ] ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) xs [ i ] [ j ] /= sum ; }
tr	2	private String generateRandomId ( ) { StringBuilder sb = new StringBuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idLength ) { char ch = ( char ) rnd . nextInt ( ) ; if ( Utils . isUriLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containsKey ( sb . toString ( ) ) ) { sb . delete ( 0 , idLength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > RETRY_COUNT ) ; return sb . toString ( ) ; }
tr	4X	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
tr	2	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	1	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	4X	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
tr	2	@ Test public void testGet ( ) { for ( int i = 0 ; i < A . length ; ++ i ) { for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) { assertTrue ( matrixA . get ( i , j ) . equals ( A [ i ] [ j ] ) ) ; } } }
tr	2	public Grille ( int taille , Joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setBackground ( new Color ( 0 , 0 , 0 ) ) ; this . setLayout ( new GridLayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialiserCases ( ) ; }
tr	4X	public static LinkedList < String > generateAttackPlans ( AttackModel attack_model ) throws IOException , ScriptException { String attack_file = InfoEnum . current_directory + "/dlv/attack/attack_model.dl" ; Inference . writeFile ( attack_file , attack_model . generateFormalExpression ( InfoEnum . ALL_MODELS ) , false ) ; for ( Element e : attack_model . getElements ( ) ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ) { if ( re . getOutLinks ( ) . size ( ) == 0 ) { Inference . writeFile ( attack_file , "satisfied(" + re . getId ( ) + ")." , true ) ; break ; } } } String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/attack/find_alternative_attacks.rule " + attack_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < LinkedList < String >> all_alternatives = new LinkedList < LinkedList < String >> ( ) ; LinkedList < String > alternative_description = new LinkedList < String > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { LinkedList < String > one_alternative = new LinkedList < String > ( ) ; line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; boolean validity = false ; for ( String s : result ) { if ( s . startsWith ( "result" ) ) { String id = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( " " ) ) ; String target = s . substring ( s . indexOf ( " " ) + 1 , s . indexOf ( ")" ) ) . replace ( "_" , " " ) ; Element node = attack_model . findElementById ( id ) ; if ( node != null ) { if ( node . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { one_alternative . add ( "perform " + node . getName ( ) + " to " + target ) ; validity = true ; } } else { System . out . println ( "result elements cannot be found." ) ; } } else if ( s . startsWith ( "unachievable" ) ) { validity = false ; break ; } } if ( validity ) { all_alternatives . add ( one_alternative ) ; } } int number = 0 ; for ( LinkedList < String > list : all_alternatives ) { number ++ ; String temp = "Attack alterntive " + number + "(" + list . size ( ) + " attack)" + ":{" ; String attacks = "" ; for ( String attack : list ) { attacks += attack + "  " ; } temp += attacks . substring ( 0 , attacks . length ( ) - 2 ) ; temp += "}" ; alternative_description . add ( temp ) ; } return alternative_description ; }
tr	0	private void finaliza ( ) { this . dispose ( ) ; }
tr	2	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	2	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	0	public boolean RemoveContact ( long nIndexContact ) { return otapiJNI . AddressBook_RemoveContact ( swigCPtr , this , removeRefContact ( nIndexContact ) ) ; }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	3	public AbstractItem ( ItemConfiguration config , String key , String [ ] sval , int [ ] ival , Triplet [ ] tval ) { this . key = key ; strings = new String [ config . stringLabels . length ] ; ints = new int [ config . intLabels . length ] ; triplets = new Triplet [ config . tripletLabels . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { strings [ i ] = sval [ i ] ; } for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = ival [ i ] ; } for ( int i = 0 ; i < triplets . length ; i ++ ) { triplets [ i ] = tval [ i ] ; } }
tr	1	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	3	public static boolean process ( Connection dbConnection , FileTypeProcessReturnInfo returnVal , java . io . File source , java . io . File workingDir , List < ImageFormat > formats , ImageMagickFormat inputFormat , ImageMagickFormat outputFormat , File file , FileType outputFileType ) { BigInteger totalSize = BigInteger . ZERO ; for ( ImageFormat f : formats ) { logger . debug ( "Executing ImageMagick to process image file for source file with width " + f . w + " and height " + f . h + "." ) ; int exitVal = ImageProcessorHelper . renderImage ( inputFormat , outputFormat , source , f . outputFile , workingDir , f . w , f . h ) ; if ( exitVal != 0 ) { logger . warn ( "ImageMagick finished processing image but returned error code " + exitVal + "." ) ; returnVal . msg = "Error processing image." ; return false ; } totalSize . add ( new BigInteger ( "" + f . outputFile . length ( ) ) ) ; if ( FileHelper . isOverQuota ( totalSize ) ) { returnVal . msg = "Ran out of space." ; return false ; } } DbHelper . updateStatus ( dbConnection , file . getId ( ) , "Finalizing." , null ) ; ArrayList < OutputFile > outputFiles = new ArrayList < OutputFile > ( ) ; try { for ( ImageFormat f : formats ) { long size = f . outputFile . length ( ) ; logger . debug ( "Creating file record for render with height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO files (in_use created_at updated_at size file_type_id source_file_id heartbeat process_state) VALUES(0 ? ? ? ? ? ? 1)" , Statement . RETURN_GENERATED_KEYS ) ; s . setTimestamp ( 1 , currentTimestamp ) ; s . setTimestamp ( 2 , currentTimestamp ) ; s . setLong ( 3 , size ) ; s . setInt ( 4 , outputFileType . getObj ( ) . getId ( ) ) ; s . setInt ( 5 , file . getId ( ) ) ; s . setTimestamp ( 6 , currentTimestamp ) ; if ( s . executeUpdate ( ) != 1 ) { s . close ( ) ; logger . warn ( "Error occurred when creating database entry for a file." ) ; return false ; } ResultSet generatedKeys = s . getGeneratedKeys ( ) ; generatedKeys . next ( ) ; int id = generatedKeys . getInt ( 1 ) ; s . close ( ) ; File newFile = new File ( id , null , size , outputFileType . getObj ( ) ) ; logger . debug ( "File record created with id " + id + " for image render with width " + f . w + " and height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; if ( ! returnVal . registerNewFile ( newFile ) ) { logger . warn ( "Error trying to register newly created file." ) ; return false ; } ImageMagickFileInfo info = ImageMagickHelper . getFileInfo ( inputFormat , f . outputFile , workingDir ) ; if ( info == null ) { logger . warn ( "Error retrieving info for file rendered from source file with id " + file . getId ( ) + "." ) ; return false ; } outputFiles . add ( new OutputFile ( id , info . getW ( ) , info . getH ( ) ) ) ; logger . info ( "Moving output file with id " + id + " to web app..." ) ; if ( ! FileHelper . moveToWebApp ( f . outputFile , id ) ) { logger . error ( "Error trying to move output file with id " + id + " to web app." ) ; return false ; } logger . info ( "Output file with id " + id + " moved to web app." ) ; } } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to register files in database." ) ) ; } try { logger . debug ( "Creating entries in image_files table..." ) ; for ( OutputFile o : outputFiles ) { Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO image_files (width height created_at updated_at file_id) VALUES (? ? ? ? ?)" ) ; s . setInt ( 1 , o . w ) ; s . setInt ( 2 , o . h ) ; s . setTimestamp ( 3 , currentTimestamp ) ; s . setTimestamp ( 4 , currentTimestamp ) ; s . setInt ( 5 , o . id ) ; int result = s . executeUpdate ( ) ; s . close ( ) ; if ( result != 1 ) { logger . debug ( "Error registering file with id " + o . id + " in image_files table." ) ; return false ; } logger . debug ( "Created entry in image_files table for file with id " + o . id + "." ) ; } logger . debug ( "Created entries in image_files table." ) ; } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to create entries in image_files." ) ) ; } return true ; }
tr	2	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	0	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	1	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	4X	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; double out = 1.0 ; int k = 1 ; if ( n > 0 ) { while ( n > 0 ) { k = 2 ; double temp = x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } else if ( n < 0 ) { n = - n ; while ( n > 0 ) { k = 2 ; double temp = 1 / x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } return out ; }
tr	2	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	1	@ Test public void testSplitLeafs ( ) { StringBuilder expected = new StringBuilder ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { bpTree . put ( i , i ) ; expected . append ( "<put>" ) . append ( "<not-contain-key>" ) . append ( "<get>" ) . append ( "<not-contain>" ) . append ( "<leaf-put>" ) . append ( "<new-key>" ) ; } expected . append ( "<create-new-root>" ) ; assertThat ( bpTree . getWay ( ) , is ( expected . toString ( ) ) ) ; }
tr	3	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { StringTokenizer st = new StringTokenizer ( sc . nextLine ( ) ) ; int nbrInts = Integer . parseInt ( st . nextToken ( ) ) ; if ( nbrInts <= 0 ) { System . out . println ( "Not jolly" ) ; continue ; } else if ( nbrInts == 1 ) { System . out . println ( "Jolly" ) ; continue ; } boolean [ ] data = new boolean [ nbrInts - 1 ] ; int prev = Integer . parseInt ( st . nextToken ( ) ) ; while ( st . hasMoreTokens ( ) ) { int curr = Integer . parseInt ( st . nextToken ( ) ) ; int absDiff = Math . abs ( prev - curr ) ; if ( absDiff > 0 && absDiff <= nbrInts - 1 ) { data [ absDiff - 1 ] = true ; } prev = curr ; } boolean isJolly = true ; for ( boolean b : data ) { if ( ! b ) { isJolly = false ; break ; } } if ( isJolly ) { System . out . println ( "Jolly" ) ; } else { System . out . println ( "Not jolly" ) ; } } }
tr	4X	public void Solve ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= _max ; x1 ++ ) { for ( int y1 = 0 ; y1 <= _max ; y1 ++ ) { for ( int x2 = 0 ; x2 <= _max ; x2 ++ ) { for ( int y2 = 0 ; y2 <= _max ; y2 ++ ) { if ( x1 + y1 + x2 + y2 == 0 ) { continue ; } int length1 = x1 * x1 + y1 * y1 ; int length2 = x2 * x2 + y2 * y2 ; int x3 = Math . abs ( x1 - x2 ) ; int y3 = Math . abs ( y1 - y2 ) ; int length3 = x3 * x3 + y3 * y3 ; if ( length1 + length2 == length3 ) { count ++ ; } } } } } System . out . println ( "Result=" + count / 2 ) ; }
tr	3	public synchronized void doRanking ( ) { calculate_tf_idf_q ( ) ; Query q ; for ( String term : queryTerms . keySet ( ) ) { term = term . trim ( ) ; q = queryTerms . get ( term ) ; q . setPostings ( getPostingsFor ( term ) ) ; if ( q . getPostings ( ) == null ) { System . out . println ( "sry. no postings found" ) ; continue ; } for ( Posting p : q . getPostings ( ) . getPostings ( ) ) { float value = ( float ) ( q . getTf_idf ( ) * calculate_tf_idf_d ( p , q . getPostings ( ) . getOverallFrequency ( ) ) ) ; Score s = new Score ( ) ; s . setScore ( value ) ; s . setId ( p . getDocID ( ) ) ; if ( ! scores . containsKey ( p . getDocID ( ) ) ) { scores . put ( p . getDocID ( ) , s ) ; } else { Score sc = scores . get ( p . getDocID ( ) ) ; float score = sc . getScore ( ) ; score += value ; sc . setScore ( score ) ; scores . put ( p . getDocID ( ) , sc ) ; } } } float newScore , lengthV ; Score s ; for ( String id : scores . keySet ( ) ) { s = scores . get ( id ) ; try { newScore = s . getScore ( ) / length . get ( id ) . floatValue ( ) ; s . setScore ( newScore ) ; scores . put ( id , s ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	2	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	4X	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	3	private void huffman_decode ( int ch , int gr ) { x [ 0 ] = 0 ; y [ 0 ] = 0 ; v [ 0 ] = 0 ; w [ 0 ] = 0 ; int part2_3_end = part2_start + si . ch [ ch ] . gr [ gr ] . part2_3_length ; int num_bits ; int region1Start ; int region2Start ; int index ; int buf , buf1 ; huffcodetab h ; if ( ( ( si . ch [ ch ] . gr [ gr ] . window_switching_flag ) != 0 ) && ( si . ch [ ch ] . gr [ gr ] . block_type == 2 ) ) { region1Start = ( sfreq == 8 ) ? 72 : 36 ; region2Start = 576 ; } else { buf = si . ch [ ch ] . gr [ gr ] . region0_count + 1 ; buf1 = buf + si . ch [ ch ] . gr [ gr ] . region1_count + 1 ; if ( buf1 > sfBandIndex [ sfreq ] . l . length - 1 ) buf1 = sfBandIndex [ sfreq ] . l . length - 1 ; region1Start = sfBandIndex [ sfreq ] . l [ buf ] ; region2Start = sfBandIndex [ sfreq ] . l [ buf1 ] ; } index = 0 ; for ( int i = 0 ; i < ( si . ch [ ch ] . gr [ gr ] . big_values << 1 ) ; i += 2 ) { if ( i < region1Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 0 ] ] ; else if ( i < region2Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 1 ] ] ; else h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 2 ] ] ; huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + x [ 0 ] + y [ 0 ] ; } h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . count1table_select + 32 ] ; num_bits = br . hsstell ( ) ; while ( ( num_bits < part2_3_end ) && ( index < 576 ) ) { huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = v [ 0 ] ; is_1d [ index ++ ] = w [ 0 ] ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + v [ 0 ] + w [ 0 ] + x [ 0 ] + y [ 0 ] ; num_bits = br . hsstell ( ) ; } if ( num_bits > part2_3_end ) { br . rewindNbits ( num_bits - part2_3_end ) ; index -= 4 ; } num_bits = br . hsstell ( ) ; if ( num_bits < part2_3_end ) br . hgetbits ( part2_3_end - num_bits ) ; if ( index < 576 ) nonzero [ ch ] = index ; else nonzero [ ch ] = 576 ; if ( index < 0 ) index = 0 ; for ( ; index < 576 ; index ++ ) is_1d [ index ] = 0 ; }
tr	2	@ Override public void visit ( FSP_OrSplit g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| OR_SPLIT }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
tr	3	private Hashtable < Character , String > build_box ( int [ ] perm , String k ) { int [ ] row = new int [ 2 ] ; row [ 0 ] = perm [ 0 ] ; row [ 1 ] = perm [ 1 ] ; int [ ] col = new int [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { col [ i ] = perm [ i + 2 ] ; } boolean [ ] filled = new boolean [ 26 ] ; String k_u = k . toUpperCase ( ) ; Hashtable < Character , String > result = new Hashtable < Character , String > ( ) ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < k_u . length ( ) ; i ++ ) { char cur_c = k_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } else if ( cur_c == Z ) { cur_c = Y ; } int pos = cur_c - A ; if ( ! filled [ pos ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ pos ] = true ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 25 || i == 9 ) continue ; if ( ! filled [ i ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } char cur_c = ( char ) ( A + i ) ; result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ i ] = true ; } } return result ; }
tr	0	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	4X	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	3	public static void main ( String [ ] args ) { StackList stackList1 = new StackList ( ) ; int i = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { stackList1 . push ( i * i ) ; System . out . print ( stackList1 . peek ( ) + " " + stackList1 . getSize ( ) + "; " ) ; } System . out . println ( ) ; stackList1 . printStackList ( ) ; Object obj = stackList1 . pop ( ) ; while ( obj != null ) { System . out . print ( obj + " " + stackList1 . getSize ( ) + "; " ) ; obj = stackList1 . pop ( ) ; } System . out . println ( ) ; for ( i = 0 ; i < 11 ; i ++ ) { System . out . print ( stackList1 . pop ( ) + " " + stackList1 . getSize ( ) + "; " ) ; } System . out . println ( ) ; stackList1 . printStackList ( ) ; }
tr	2	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	4X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { golab2 : while ( true ) { v_2 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } bra = cursor ; lab4 : do { v_3 = cursor ; lab5 : do { if ( ! ( eq_s ( 1 , "u" ) ) ) { break lab5 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab5 ; } slice_from ( "U" ) ; break lab4 ; } while ( false ) ; cursor = v_3 ; if ( ! ( eq_s ( 1 , "i" ) ) ) { break lab3 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } slice_from ( "I" ) ; } while ( false ) ; cursor = v_2 ; break golab2 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { break lab1 ; } cursor ++ ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	2	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	1	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	4X	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	0	@ Override public FullVersion getVersion ( ) { return version ; }
tr	1	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	2	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	3	public static void main ( String [ ] args ) { boolean ok = false ; long startTime , endTime ; LinkedList < Drone > mDroneArm = new LinkedList < > ( ) ; DroneQueue droneQueue = new DroneQueue ( mDroneArm ) ; Config config = Config . getInstance ( ) ; config . load ( "config.xml" ) ; clearKMLs ( ) ; String dirs [ ] = config . getOption ( Config . GTFS_DIRS ) . split ( " " ) ; int timeGap = config . getIntOption ( Config . GTFS_TIME_GAP ) ; GraphFrame gp = null ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp = new GraphFrame ( ) ; } final String password = Config . getInstance ( ) . getOption ( Config . SERVER_PASSWORD ) ; final int port = Config . getInstance ( ) . getIntOption ( Config . SERVER_PORT ) ; GPSPortal g = new GPSPortal ( port , password ) ; int id = 1 ; final double busSpeed = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_SPEED ) ; final double busUpdateTime = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_UPDATE_SPEED ) ; boolean dronesActive = config . getBooleanOption ( Config . DRONES_ACTIVE ) ; if ( dronesActive ) { System . out . println ( "Drones Active!" ) ; } ArrayList < GTFS > gtfs = new ArrayList < > ( ) ; for ( String dir : dirs ) { dir = dir . trim ( ) ; System . out . println ( dir + "\n----------" ) ; try { startTime = System . currentTimeMillis ( ) ; GTFS current = new GTFS ( dir , timeGap ) ; gtfs . add ( current ) ; endTime = System . currentTimeMillis ( ) ; System . out . println ( dir + " loaded and parsed in " + ( ( endTime - startTime ) / 1000.0 ) + " seconds" ) ; System . out . println ( dir + " id: " + current . getID ( ) ) ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . adjustViewport ( current . getMinLon ( ) , current . getMinLat ( ) , current . getMaxLon ( ) , current . getMaxLat ( ) ) ; gp . addPaths ( current . getPaths ( ) ) ; } if ( dronesActive ) { for ( int i = 0 ; i < current . getPaths ( ) . size ( ) ; i ++ ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; if ( current . isValidService ( current . getPaths ( ) . get ( i ) . getServiceID ( ) ) && current . getPaths ( ) . get ( i ) . getEndTimecode ( ) > now ) { System . out . println ( dir + ": " + current . getPaths ( ) . get ( i ) ) ; droneQueue . addDrone ( new Drone ( id , current . getPaths ( ) . get ( i ) , busSpeed , busUpdateTime , "http://127.0.0.1:8080" , password , false ) ) ; id ++ ; } } } ok = true ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( ) ; } if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . setVisible ( true ) ; } boolean running = true ; int vListTimeout = Config . getInstance ( ) . getIntOption ( Config . VEHICLE_LIST_TIMEOUT ) ; System . out . println ( "Running..." ) ; while ( running ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; Vehicle . cleanUp ( vListTimeout ) ; droneQueue . check ( now ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( WTBBackend . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } System . gc ( ) ; running = ! droneQueue . isEmpty ( ) ; } }
tr	0	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	4X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	1	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
tr	2	public void test_GetRevisionInfo ( ) { FileHistory fileHist = new FileHistory ( path . resolve ( "README.txt" ) ) ; fileHist . storeRevision ( path . resolve ( "README.txt" ) , null , 100 , 200 ) ; fileHist . storeRevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; fileHist . storeRevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; DataRetriever dataRetriever = new DataRetriever ( path . resolve ( "README.txt" ) ) ; Vector < Vector < String >> tableData = dataRetriever . getRevisionInfoTable ( ) ; System . out . println ( "Please check time-depend result:" ) ; for ( Vector < String > rows : tableData ) { for ( String data : rows ) { System . out . println ( data ) ; } } }
tr	2	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	0	public Builder buying ( double price ) { this . price = price ; return this ; }
tr	3	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	3	public void renderTile ( int plane , int x , int y , int clippingPath , int clippingPathRotation , int textureId , int vertexHeightSW , int vertexHeightSE , int vertexHeightNE , int vertexHeightNW , int k2 , int l2 , int i3 , int j3 , int k3 , int l3 , int i4 , int j4 , int k4 , int l4 ) { if ( clippingPath == 0 ) { PlainTile tile = new PlainTile ( k2 , l2 , j3 , i3 , k4 , - 1 , false ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } if ( clippingPath == 1 ) { PlainTile tile = new PlainTile ( k3 , l3 , j4 , i4 , l4 , textureId , vertexHeightSW == vertexHeightSE && vertexHeightSW == vertexHeightNE && vertexHeightSW == vertexHeightNW ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } ShapedTile tile = new ShapedTile ( x , vertexHeightSW , vertexHeightSE , vertexHeightNW , vertexHeightNE , y , clippingPathRotation , textureId , clippingPath , k2 , k3 , l2 , l3 , j3 , j4 , i3 , i4 , l4 , k4 ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . shapedTile = tile ; }
tr	2	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	4X	public String fillStaffInfo ( String staffPos ) { DB . db . openConnection ( ) ; ResultSet rs = DB . db . staff ( ) ; StringBuffer info = new StringBuffer ( ) ; try { info . append ( "<table>" ) ; while ( rs . next ( ) ) { ResultSet res = DB . db . position ( rs . getInt ( "posid" ) ) ; while ( res . next ( ) ) { if ( res . getString ( "posdesc" ) . equalsIgnoreCase ( staffPos ) ) { if ( staffPos . equalsIgnoreCase ( "gp" ) ) { info . append ( "<tr><td>Dr. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ns" ) ) { info . append ( "<tr><td>R.N. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ma" ) ) { info . append ( "<tr><td>Med.As. <b>" ) ; } info . append ( rs . getString ( "lname" ) ) ; info . append ( "  " + rs . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( rs . getString ( "phone" ) + "</b></td></tr>" ) ; ResultSet ress = DB . db . qualification ( rs . getInt ( "qualid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Qualification: <b>" ) ; info . append ( ress . getString ( "qualdesc" ) + "</b></td></tr>" ) ; } ResultSet rss = DB . db . staffSchedule ( rs . getInt ( "id" ) ) ; while ( rss . next ( ) ) { ress = DB . db . hospital ( rss . getInt ( "hospid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Hospital: <b>" ) ; info . append ( ress . getString ( "name" ) + "</b></td></tr>" ) ; } } info . append ( "<tr></tr>" ) ; } } } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StartMedOfficer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
tr	1	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	1	public static List < Appointment > findByVenue ( long venueId ) throws SQLException { List < Appointment > aAppt = new ArrayList < Appointment > ( ) ; ResultSet resultSet = Data . _find ( Appointment . class . getSimpleName ( ) , "venueId" , String . valueOf ( venueId ) ) ; while ( resultSet . next ( ) ) { aAppt . add ( Appointment . createOneFromResultSet ( resultSet ) ) ; } return aAppt ; }
tr	1	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	4X	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
tr	4X	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	0	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	4X	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	2	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	2	public static Polynomial createFromBytes ( byte [ ] bytes ) { TreeSet < BigInteger > dgrs = createDegreesCollection ( ) ; int degree = 0 ; for ( int i = bytes . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( ( ( ( bytes [ i ] >> j ) & 1 ) == 1 ) ) { dgrs . add ( BigInteger . valueOf ( degree ) ) ; } degree ++ ; } } return new Polynomial ( dgrs ) ; }
tr	3	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
tr	4X	@ Override public void stateChanged ( ChangeEvent e ) { JSlider sliderOfInteraction = ( JSlider ) e . getSource ( ) ; switch ( sliderOfInteraction . getName ( ) ) { case "brightness" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; brightness = currentSliderValue * .001f ; if ( brightness < - .9f ) brightness = ( - .9f ) ; if ( brightness > 1f ) brightness = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , hsbvals [ 1 ] , ( hsbvals [ 2 ] + ( brightness ) < 0 ) ? 0 : ( hsbvals [ 2 ] + ( brightness ) > 1.0f ) ? 1.0f : hsbvals [ 2 ] + brightness ) ) ; } } break ; case "saturation" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; saturation = currentSliderValue * .001f ; if ( saturation < - .9f ) saturation = ( - .9f ) ; if ( saturation > 1f ) saturation = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , ( hsbvals [ 1 ] + saturation < 0 ) ? 0 : ( hsbvals [ 1 ] + ( saturation ) > 1.0f ) ? 1.0f : hsbvals [ 1 ] + saturation , hsbvals [ 2 ] ) ) ; } } break ; } oPanel . repaint ( ) ; }
tr	3	@ Override public String solve ( case aCase ) { String template = "11%s11%s11%s11%s11" ; final List < String > coins = Lists . newArrayList ( ) ; for ( int i = 0 ; i < aCase . nbits - 10 ; i ++ ) { for ( int j = 0 ; j < aCase . nbits - 10 - i ; j ++ ) { for ( int k = 0 ; k < aCase . nbits - 10 - i - j ; k ++ ) { int l = aCase . nbits - 10 - i - j - k ; String output = String . format ( template , zeroStr ( i ) , zeroStr ( j ) , zeroStr ( k ) , zeroStr ( l ) ) ; coins . add ( output + " 3 2 5 2 7 2 3 2 11" ) ; aCase . jcoins -- ; if ( aCase . jcoins == 0 ) { return stringList ( coins ) ; } } } } throw new RuntimeException ( "Need moar jamcoins" ) ; }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	4X	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
tr	0	public Parler ( String message ) { this ( 0 , message ) ; }
tr	4X	@ SuppressWarnings ( "deprecation" ) public static void insertTestData ( Connection databaseConnection ) throws SQLException { List < Student > studentList = new ArrayList < Student > ( ) ; studentList . add ( new Student ( "firstname_1" , "lastname_1" , new Date ( 80 , 1 , 1 ) , 2.1 ) ) ; studentList . add ( new Student ( "firstname_2" , "lastname_2" , new Date ( 80 , 1 , 2 ) , 2.2 ) ) ; studentList . add ( new Student ( "firstname_3" , "lastname_3" , new Date ( 80 , 1 , 3 ) , 2.3 ) ) ; studentList . add ( new Student ( "firstname_4" , "lastname_4" , new Date ( 80 , 1 , 4 ) , 2.4 ) ) ; studentList . add ( new Student ( "firstname_5" , "lastname_5" , new Date ( 80 , 1 , 5 ) , 2.5 ) ) ; studentList . add ( new Student ( "firstname_6" , "lastname_6" , new Date ( 80 , 1 , 6 ) , 2.6 ) ) ; studentList . add ( new Student ( "firstname_7" , "lastname_7" , new Date ( 80 , 1 , 7 ) , 2.7 ) ) ; studentList . add ( new Student ( "firstname_8" , "lastname_8" , new Date ( 80 , 1 , 8 ) , 2.8 ) ) ; PreparedStatement preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO STUDENT (FIRSTNAME  LASTNAME  BIRTHDATE  GPA) VALUES (? ? ? ?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Student student : studentList ) { preparedStatement . setString ( 1 , student . firstname ) ; preparedStatement . setString ( 2 , student . lastname ) ; preparedStatement . setDate ( 3 , student . birthdate ) ; preparedStatement . setDouble ( 4 , student . gpa ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { student . id = resultSet . getInt ( 1 ) ; } } List < Course > courseList = new ArrayList < Course > ( ) ; courseList . add ( new Course ( "course_1" ) ) ; courseList . add ( new Course ( "course_2" ) ) ; courseList . add ( new Course ( "course_3" ) ) ; courseList . add ( new Course ( "course_4" ) ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO COURSE (NAME) VALUES (?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Course course : courseList ) { preparedStatement . setString ( 1 , course . name ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { course . id = resultSet . getInt ( 1 ) ; } } Map < Integer , String > studentGradeMap = new HashMap < Integer , String > ( ) ; studentGradeMap . put ( 1 , "A" ) ; studentGradeMap . put ( 2 , "A-" ) ; studentGradeMap . put ( 3 , "B+" ) ; studentGradeMap . put ( 4 , "B" ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO GRADE (STUDENT_ID  COURSE_ID  GRADE) VALUES (? ? ?)" ) ; for ( int i = 0 ; i < courseList . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( i + 1 ) * 2 ; j ++ ) { int studentID = studentList . get ( j ) . id ; int courseID = courseList . get ( i ) . id ; String grade = studentGradeMap . get ( i + 1 ) ; preparedStatement . setInt ( 1 , studentID ) ; preparedStatement . setInt ( 2 , courseID ) ; preparedStatement . setString ( 3 , grade ) ; preparedStatement . executeUpdate ( ) ; } } }
tr	4X	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	3	public static LMDrillModel getAllTweetsByDate ( String startDate , String endDate ) { ArrayList < tweetModel > results = new ArrayList < tweetModel > ( ) ; LMDrillModel lmDrillModel = new LMDrillModel ( ) ; String [ ] start = startDate . split ( " " ) ; String [ ] end = endDate . split ( " " ) ; tweetModel t ; String tablename = "temp-" + start [ 0 ] + "." + start [ 1 ] + "." + start [ 2 ] + "-" + end [ 0 ] + "." + end [ 1 ] + "." + end [ 2 ] ; System . out . println ( tablename ) ; String whereCondition = "" ; int year = Integer . parseInt ( start [ 2 ] ) ; for ( int month = monthNumber ( start [ 0 ] ) ; month <= monthNumber ( end [ 0 ] ) ; month ++ ) { int currentday = 1 ; if ( month == monthNumber ( start [ 0 ] ) ) currentday = Integer . parseInt ( start [ 1 ] ) ; for ( int day = currentday ; day <= numDaysinMonth ( month ) ; day ++ ) { if ( month == monthNumber ( end [ 0 ] ) && day > Integer . parseInt ( end [ 1 ] ) ) break ; if ( whereCondition . equals ( "" ) ) whereCondition = "'" + start [ 1 ] + " " + start [ 0 ] + " " + start [ 2 ] + "%'" ; else whereCondition = whereCondition . concat ( " or date like '" + day + " " + monthName ( month ) + " " + year + "%'" ) ; } } System . out . println ( "[3] " + whereCondition ) ; try { Connection c = DBFactory . getConnection ( ) ; PreparedStatement ps = c . prepareStatement ( "DROP TABLE IF EXISTS `" + tablename + "`; " ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "CREATE TABLE `" + tablename + "` (" + "`username` varchar(20) NOT NULL " + "`date` varchar(30) NOT NULL " + "`message` varchar(180) NOT NULL" + ")ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "INSERT INTO `" + tablename + "` (username  date  message) " + "SELECT username  date  message FROM `tweets` " + "WHERE date like " + whereCondition ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "SELECT * from `" + tablename + "`;" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { t = new tweetModel ( ) ; t . setUsername ( rs . getString ( "username" ) ) ; t . setDate ( rs . getString ( "date" ) ) ; t . setMessage ( cleanTweet ( rs . getString ( "message" ) ) ) ; NGramDriver . NGramTweet ( cleanTweet ( t . getMessage ( ) ) ) ; results . add ( t ) ; } rs . close ( ) ; ps . close ( ) ; c . close ( ) ; System . out . println ( "******************************* " ) ; if ( results . isEmpty ( ) ) { lmDrillModel = new LMDrillModel ( - 1 ) ; } else { sortNgramAndRemoveOutliers ( ) ; TfidfDriver . idfchecker ( results ) ; lmDrillModel = new LMDrillModel ( 0 , tablename , TfidfDriver . getToplist ( ) ) ; } } catch ( ClassNotFoundException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return lmDrillModel ; }
tr	3	public static void main ( String Arg [ ] ) { int theMost = 0 ; for ( int p = 120 ; p < 1000 ; p ++ ) { int counter = 0 ; for ( int a = 1 ; a < p ; a ++ ) for ( int b = 1 ; b < a ; b ++ ) { int c = p - a - b ; if ( a * a + b * b == c * c ) counter ++ ; } if ( counter > theMost ) { theMost = counter ; System . out . println ( "p=" + p + " generates " + counter + " triangles" ) ; } } uptime ( ) ; }
tr	4X	public final static byte [ ] decodeFast ( byte [ ] sArr ) { int sLen = sArr . length ; if ( sLen == 0 ) return new byte [ 0 ] ; int sIx = 0 , eIx = sLen - 1 ; while ( sIx < eIx && IA [ sArr [ sIx ] & ff ] < 0 ) sIx ++ ; while ( eIx > 0 && IA [ sArr [ eIx ] & ff ] < 0 ) eIx -- ; int pad = sArr [ eIx ] == = ? ( sArr [ eIx - 1 ] == = ? 2 : 1 ) : 0 ; int cCnt = eIx - sIx + 1 ; int sepCnt = sLen > 76 ? ( sArr [ 76 ] ==  ? cCnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cCnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dArr = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = IA [ sArr [ sIx ++ ] ] << 18 | IA [ sArr [ sIx ++ ] ] << 12 | IA [ sArr [ sIx ++ ] ] << 6 | IA [ sArr [ sIx ++ ] ] ; dArr [ d ++ ] = ( byte ) ( i >> 16 ) ; dArr [ d ++ ] = ( byte ) ( i >> 8 ) ; dArr [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sIx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sIx <= eIx - pad ; j ++ ) i |= IA [ sArr [ sIx ++ ] ] << ( 18 - j * 6 ) ; for ( int r = 16 ; d < len ; r -= 8 ) dArr [ d ++ ] = ( byte ) ( i >> r ) ; } return dArr ; }
tr	2	public Polygon getPolygon ( String s_nameCity ) { Polygon polygonToReturn = new Polygon ( ) ; for ( District district : model . getListDistrict ( ) ) { for ( City city : district . getListCity ( ) ) { if ( city . getS_name ( ) . equals ( s_nameCity ) ) { int i_x = district . getI_x ( ) * model . getI_nbHorizontalSquareInDistrict ( ) + city . getI_x ( ) + ( district . getI_y ( ) % 2 ) * model . getI_nbHorizontalSquareInDistrict ( ) / 2 ; int i_y = district . getI_y ( ) * model . getI_nbVerticalSquareInDistrict ( ) + city . getI_y ( ) ; Point point2D = new Point ( i_x , i_y ) ; polygonToReturn . setPoint2D ( point2D ) ; polygonToReturn . setPoint3D ( convert2DTo3D ( point2D ) ) ; return polygonToReturn ; } } } return polygonToReturn ; }
tr	0	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
tr	3	public static void main ( String [ ] args ) { List < Integer > primes = new LinkedList < Integer > ( ) ; primes . add ( 2 ) ; while ( primes . size ( ) < 10002 ) { for ( Integer i = primes . get ( primes . size ( ) - 1 ) + 1 ; ; i ++ ) { boolean flag = true ; for ( Integer r : primes ) { if ( i % r == 0 ) { flag = false ; } } if ( flag ) { primes . add ( i ) ; System . out . println ( i ) ; break ; } } } System . out . println ( "result" + primes . get ( 10000 ) ) ; }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	4X	private void initializeTokens ( ) { tokens = new Token [ 21 ] [ 10 ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] = new Token ( ) ; } } nextTokens1 = new TokenNext [ 2 ] [ 4 ] ; nextTokens2 = new TokenNext [ 2 ] [ 4 ] ; nextTokens3 = new TokenNext [ 2 ] [ 4 ] ; holdTokens = new TokenNext [ 2 ] [ 4 ] ; for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] = new TokenNext ( ) ; nextTokens2 [ i ] [ j ] = new TokenNext ( ) ; nextTokens3 [ i ] [ j ] = new TokenNext ( ) ; holdTokens [ i ] [ j ] = new TokenNext ( ) ; } } currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; }
tr	4X	public ListNode rotateRight ( ListNode head , int n ) { int length = 0 ; if ( head == null ) { return null ; } if ( n == 0 ) { return head ; } ListNode currentNode = head ; while ( currentNode != null ) { length ++ ; currentNode = currentNode . next ; } n = n % length ; if ( length == 1 || n == 0 ) { return head ; } int count = 0 ; currentNode = head ; while ( count != n ) { count ++ ; currentNode = currentNode . next ; } currentNode = currentNode . next ; ListNode temp = head ; ListNode tempLast = null ; while ( currentNode != null ) { if ( currentNode . next == null ) { tempLast = currentNode ; } temp = temp . next ; currentNode = currentNode . next ; } currentNode = temp . next ; temp . next = null ; if ( tempLast == null ) { tempLast = currentNode ; while ( tempLast . next != null ) { tempLast = tempLast . next ; } } tempLast . next = head ; head = currentNode ; return head ; }
tr	3	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	2	private Nodo buscarNodo ( String padre ) { Nodo tmp1 = this . raiz ; Nodo tmp2 = tmp1 ; StringTokenizer path = new StringTokenizer ( padre , "/" ) ; String s ; while ( path . hasMoreTokens ( ) ) { s = path . nextToken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerHijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguienteHermano ; } } return tmp2 ; }
tr	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	0	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	2	public void insert ( Object value , int index ) { int space = index ; while ( rawget ( space ) != null ) space ++ ; while ( space != index ) rawset ( space , rawget ( -- space ) ) ; rawset ( space , value ) ; }
tr	1	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	2	@ Override protected void imprimirTabuleiro ( TabuleiroXadrez tabuleiro ) { imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; for ( int linha = 8 ; linha >= 1 ; linha -- ) { imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimir ( linha + " " ) ; for ( int coluna = 1 ; coluna <= 8 ; coluna ++ ) { imprimir ( "|" ) ; Peca peca = tabuleiro . espiarPeca ( new Posicao ( coluna , linha ) ) ; imprimir ( PecaToString ( peca ) ) ; if ( peca == null ) imprimir ( "       " ) ; else if ( peca . getCorJogador ( ) == TipoCorJogador . BRANCO ) imprimir ( " branco" ) ; else imprimir ( " preto " ) ; } imprimirLinha ( "| " + linha ) ; } imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; }
tr	4X	public void testIsWinner ( ) { beginTest ( "countFields method" ) ; boolean result ; for ( int i = 0 ; i < 31 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 32 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , false , result ) ; setUp ( ) ; for ( int i = 0 ; i < 32 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 33 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , true , result ) ; }
tr	4X	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	1	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	1	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	2	private JPanel getCenterPanel ( ) { if ( centerPanel == null ) { centerPanel = new JPanel ( ) ; centerPanel . setLayout ( new MigLayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttonGameBoard [ i ] [ j ] . setSize ( 40 , 40 ) ; centerPanel . add ( buttonGameBoard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerPanel ; }
tr	2	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	2	private int findShortestPath ( ) throws IllegalStateException { int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= graph . V ( ) ; i ++ ) { for ( int j = 1 ; j <= graph . V ( ) ; j ++ ) { if ( i == j && d [ i ] [ j ] [ graph . V ( ) ] < 0 ) { throw new IllegalStateException ( "Negative cycle!" ) ; } if ( d [ i ] [ j ] [ graph . V ( ) ] < min ) { min = d [ i ] [ j ] [ graph . V ( ) ] ; } } } return min ; }
tr	2	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	4X	static public void LU_ver ( double a [ ] [ ] ) { int n = a . length ; int i , j , k ; double suma ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i - 1 ; j ++ ) { ver ( i , j , 0 ) ; System . out . print ( "(" ) ; ver ( i , j , 1 ) ; suma = 0 ; for ( k = 0 ; k <= j - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = ( a [ i ] [ j ] - suma ) / a [ j ] [ j ] ; ver ( j , j , 4 ) ; System . out . println ( ) ; } for ( j = i ; j < n ; j ++ ) { suma = 0 ; ver ( i , j , 0 ) ; ver ( i , j , 1 ) ; for ( k = 0 ; k <= i - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = a [ i ] [ j ] - suma ; System . out . println ( ) ; } } }
tr	1	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	4X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	1	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	3	@ Override public boolean isEmpty ( ) { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . lock ( ) ; } try { for ( MapSegment < K , V > mapSegment : mapSegments ) { if ( ! mapSegment . isEmpty ( ) ) return false ; } return true ; } finally { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . unlock ( ) ; } } }
tr	3	private void ulozitActionPerformed ( java . awt . event . ActionEvent evt ) { PanelRegistraceTymu fr = PanelRegistraceTymu . this ; EntityManager em = DBTools . getInstance ( ) . getEm ( ) ; EntityTransaction tx = DBTools . getInstance ( ) . getTx ( ) ; System . out . println ( "" ) ; System . out . println ( "ULOZIT" ) ; System . out . println ( "" ) ; String sql = "select * from kategorie where nazev=?" ; Query query = DBTools . getInstance ( ) . getEm ( ) . createNativeQuery ( sql , Kategorie . class ) ; query . setParameter ( 1 , fr . kategorieCombo . getSelectedItem ( ) . toString ( ) ) ; Kategorie kat = ( Kategorie ) query . getSingleResult ( ) ; tx . begin ( ) ; Tym tym = Tym . createTym ( fr . JmenoTymuField . getText ( ) , kat ) ; em . persist ( tym ) ; tx . commit ( ) ; tym = em . find ( Tym . class , tym . getTym_id ( ) ) ; System . out . println ( tym ) ; tx . begin ( ) ; TableModel jtm = fr . jezdecTable . getModel ( ) ; for ( int i = 0 ; i < jtm . getRowCount ( ) ; i ++ ) { long val = ( long ) jtm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyl vybran jezdec!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; tho . setJe_jezdec ( true ) ; em . persist ( tho ) ; } } TableModel ptm = fr . prisediciTable . getModel ( ) ; for ( int i = 0 ; i < ptm . getRowCount ( ) ; i ++ ) { long val = ( long ) ptm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni prisedici!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; em . persist ( tho ) ; } } TableModel ktm = fr . koneTable . getModel ( ) ; for ( int i = 0 ; i < ktm . getRowCount ( ) ; i ++ ) { long val = ( long ) ktm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni kone!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Kun k = em . find ( Kun . class , val ) ; System . out . println ( k ) ; TymyHasKone thk = TymyHasKone . createTymMaKone ( tym . getTym_id ( ) , k . getKun_id ( ) ) ; em . persist ( thk ) ; } } try { tx . commit ( ) ; tx . begin ( ) ; tym . setZavodId ( em . find ( Zavody . class , 1 ) ) ; em . persist ( tym ) ; tx . commit ( ) ; dispose ( ) ; } catch ( RollbackException e ) { System . out . println ( "ERROR -> rollback" ) ; JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Do\u0161lo k chyb\u011B: " + e . getMessage ( ) , "Chyba" , JOptionPane . ERROR_MESSAGE ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; } }
tr	3	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	4X	protected void addPointToHull ( Vertex eyeVtx ) { horizon . clear ( ) ; unclaimed . clear ( ) ; if ( debug ) { System . out . println ( "Adding point: " + eyeVtx . pnt . toString ( ) ) ; System . out . println ( " which is " + eyeVtx . face . distanceToPlane ( eyeVtx . pnt ) + " above face " + eyeVtx . face . getVertexString ( ) ) ; } removePointFromFace ( eyeVtx , eyeVtx . face ) ; calculateHorizon ( eyeVtx . pnt , null , eyeVtx . face , horizon ) ; newFaces . clear ( ) ; addNewFaces ( newFaces , eyeVtx , horizon ) ; for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . VISIBLE ) { while ( doAdjacentMerge ( face , NONCONVEX_WRT_LARGER_FACE ) ) ; } } for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . NON_CONVEX ) { face . mark = Face . VISIBLE ; while ( doAdjacentMerge ( face , NONCONVEX ) ) ; } } resolveUnclaimedPoints ( newFaces ) ; }
tr	0	public boolean isInterested ( ) { return this . interested ; }
tr	3	@ Override public Point getTarget ( GameState state ) { float [ ] [ ] candidates = new float [ 3 ] [ 5 ] ; Point target = null ; int i = 0 ; for ( TargetingStrategy strategy : strategies ) { target = strategy . getTarget ( state ) ; if ( target != null ) { candidates [ target . x ] [ target . y ] += weights [ i ] ; } ++ i ; } float greatest = 0f ; target = null ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( candidates [ x ] [ y ] > greatest ) { target = new Point ( x , y ) ; greatest = candidates [ x ] [ y ] ; } } } return target ; }
tr	3	public static double [ ] [ ] produitMat ( double [ ] [ ] m1 , double [ ] [ ] m2 ) { int n1 = m1 . length ; int l1 = m1 [ 0 ] . length ; int n2 = m2 . length ; int l2 = m2 [ 0 ] . length ; double [ ] [ ] res = new double [ n1 ] [ l2 ] ; if ( ! ( l1 == n2 ) ) { System . out . println ( "Tailles non concordantes" ) ; } else { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < l2 ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int l = 0 ; l < l1 ; l ++ ) { res [ i ] [ j ] += m1 [ i ] [ l ] * m2 [ l ] [ j ] ; } } } } return res ; }
tr	1	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	3	public static Map < String , List < String >> getAbbreviations ( Collection < String > names ) { Map < String , List < String >> abbrevs = new LinkedHashMap < String , List < String >> ( ) ; for ( String name : names ) { for ( int len = name . length ( ) - 1 ; len > 0 ; -- len ) { String abbrev = name . substring ( 0 , len ) ; if ( ! abbrevs . containsKey ( abbrev ) ) { abbrevs . put ( abbrev , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } else { abbrevs . get ( abbrev ) . add ( name ) ; } } } for ( String name : names ) { abbrevs . put ( name , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } return abbrevs ; }
tr	2	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	2	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	2	public List < double > toOrderedList ( ) { List < double > distr = new ArrayList < double > ( ) ; for ( int i = 0 ; i < this . getRows ( ) ; i ++ ) { for ( int j = 0 ; j < this . getColumns ( ) ; j ++ ) { if ( ! this . isSparse ( i , j ) ) distr . add ( this . getSimilarity ( i , j ) ) ; } } Collections . sort ( distr ) ; return distr ; }
tr	0	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	4X	private void handleProjectileCollisions ( HashSet < Projectile > destroyedProjectiles ) { boolean destroyed ; for ( Projectile p : projectiles ) { p . clearCollidedWith ( ) ; destroyed = false ; for ( LandscapeGameObject l : landscape ) { if ( p . collidesWith ( l ) ) { p . addCollision ( l ) ; destroyed = destroyed || p . handleCollision ( l ) ; } } for ( Tank t : tanks ) { if ( p . collidesWith ( t ) ) { p . addCollision ( t ) ; destroyed = true ; } } for ( Projectile p2 : projectiles ) { if ( p . collidesWith ( p2 ) ) { p . addCollision ( p2 ) ; destroyed = destroyed || p . handleCollision ( p2 ) ; } } if ( destroyed ) { destroyedProjectiles . add ( p ) ; } } }
tr	3	public AList < Song > getTracksByGenre ( Genre g ) { AList < Song > tracksByGenre = new AList < Song > ( ) ; for ( SListIterator < Record > iterator = createIterator ( ) ; iterator . isValid ( ) ; iterator . moveNext ( ) ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( AListIterator < Song > iterator2 = iterator . getCurrentElem ( ) . getSide ( j ) . getSideTracklist ( ) . createIterator ( ) ; iterator2 . isValid ( ) ; iterator2 . moveNext ( ) ) { if ( iterator2 . getCurrentElem ( ) . getGenre ( ) . equals ( g ) ) { tracksByGenre . addLast ( iterator2 . getCurrentElem ( ) ) ; } } } } if ( tracksByGenre . isEmpty ( ) ) { return null ; } else { return tracksByGenre ; } }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	3	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	3	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	4X	public static void arraycopy ( final float [ ] src , final int srcPos , final FloatLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setFloat ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } } }
tr	1	public int [ ] getAction_Per_State_As_Array ( ) { int ret [ ] = new int [ noOfStates ] ; for ( int i = 0 ; i < noOfStates ; i ++ ) { ret [ i ] = action_Per_State . get ( i ) ; } return ret ; }
tr	4X	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
tr	3	static public void EliminacionGaussiana ( double a [ ] [ ] , double x [ ] , double b [ ] ) { int n = a . length ; for ( int k = 0 ; k <= n - 2 ; k ++ ) { for ( int i = k + 1 ; i <= ( n - 1 ) ; i ++ ) { b [ i ] -= a [ i ] [ k ] * b [ k ] / a [ k ] [ k ] ; for ( int j = n - 1 ; j >= k ; j -- ) a [ i ] [ j ] -= a [ i ] [ k ] * a [ k ] [ j ] / a [ k ] [ k ] ; } } }
tr	2	public static void main ( String [ ] args ) { SalariedEmployee salariedEmployee = new SalariedEmployee ( "John" , "Smith" , "111-11-1111" , 800.00 ) ; HourlyEmployee hourlyEmployee = new HourlyEmployee ( "Karen" , "Price" , "222-22-2222" , 16.75 , 40 ) ; CommissionEmployee commissionEmployee = new CommissionEmployee ( "Sue" , "Jones" , "333-33-3333" , 10000 , .06 ) ; BasePlusCommissionEmployee basePlusCommissionEmployee = new BasePlusCommissionEmployee ( "Bob" , "Lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; System . out . println ( "Employees processed individually:\n" ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , salariedEmployee , "earned" , salariedEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyEmployee , "earned" , hourlyEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , commissionEmployee , "earned" , commissionEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , basePlusCommissionEmployee , "earned" , basePlusCommissionEmployee . earnings ( ) ) ; Employee [ ] employees = new Employee [ 4 ] ; employees [ 0 ] = salariedEmployee ; employees [ 1 ] = hourlyEmployee ; employees [ 2 ] = commissionEmployee ; employees [ 3 ] = basePlusCommissionEmployee ; System . out . println ( "Employees processed polymorphically:\n" ) ; for ( Employee currentEmployee : employees ) { System . out . println ( currentEmployee ) ; if ( currentEmployee instanceof BasePlusCommissionEmployee ) { BasePlusCommissionEmployee employee = ( BasePlusCommissionEmployee ) currentEmployee ; employee . setBaseSalary ( 1.10 * employee . getBaseSalary ( ) ) ; System . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getBaseSalary ( ) ) ; } System . out . printf ( "earned $% .2f\n\n" , currentEmployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) System . out . printf ( "Employee %d is a %s\n" , j , employees [ j ] . getClass ( ) . getName ( ) ) ; }
tr	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
tr	2	public graph ( String C , String type , String interval , String r ) throws SQLException { super ( "Bar Chart" ) ; connnect = new sqlConnection ( ) ; sql = new selectQueries ( ) ; sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; int inte = Integer . parseInt ( interval ) ; ResultSet item = sql . getGraph1 ( conn , type , inte ) ; int i = 0 ; ResultSetMetaData md = item . getMetaData ( ) ; int count = md . getColumnCount ( ) ; String [ ] list = new String [ count ] ; int i1 = 0 ; while ( item . next ( ) ) { list [ i1 ] = item . getString ( "rcm_id" ) ; i1 ++ ; } BarChart chart = new BarChart ( ) ; Object [ ] col = new Object [ ] { Color . red , Color . green , Color . blue , Color . black , Color . pink , Color . yellow , Color . DARK_GRAY } ; for ( int p = 0 ; p < count ; p ++ ) { if ( p == col . length - 1 ) { break ; } try { chart . addBar ( ( Color ) col [ p ] , Integer . parseInt ( list [ p ] ) ) ; } catch ( Exception e ) { System . out . println ( "Exception occured here" ) ; } } getContentPane ( ) . setBackground ( Color . CYAN ) ; getContentPane ( ) . add ( chart ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; pack ( ) ; setVisible ( true ) ; }
tr	2	public static void main ( String args [ ] ) { String [ ] words = new String [ 2 ] ; String [ ] more = new String [ 2 ] ; ArrayList < String > str = new ArrayList < String > ( ) ; String strng ; for ( int i = 0 ; i < words . length ; i ++ ) words [ i ] = "words" + i ; for ( int i = 0 ; i < more . length ; i ++ ) more [ i ] = "more" + i ; str = merge ( words , more ) ; System . out . println ( str ) ; strng = makeSentence ( words ) ; System . out . println ( words ) ; }
tr	3	private void showBoundingBoxV1 ( ) { if ( m_geometry == null ) { return ; } hideBoundingBox ( ) ; System . out . println ( "Showing Bounding Box Variant 1" ) ; PdVector c = m_geometry . getCenterOfGravity ( ) ; PdMatrix m = new PdMatrix ( 3 , 3 ) ; for ( int v = 0 ; v < m_geometry . getNumVertices ( ) ; ++ v ) { PdVector p = m_geometry . getVertex ( v ) ; for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { double val = ( p . getEntry ( i ) - c . getEntry ( i ) ) * ( p . getEntry ( j ) - c . getEntry ( j ) ) ; m . setEntry ( i , j , m . getEntry ( i , j ) + val ) ; } } } m_boundingBox = getBoundingBox ( m ) ; m_disp . addGeometry ( m_boundingBox ) ; m_disp . update ( m_boundingBox ) ; }
tr	2	public static int [ ] idea_subkeys ( byte [ ] key ) { int [ ] encryptKeys = new int [ 52 ] ; int k1 ; for ( k1 = 0 ; k1 < 8 ; ++ k1 ) encryptKeys [ k1 ] = ( ( key [ 2 * k1 ] & ff ) << 8 ) | ( key [ 2 * k1 + 1 ] & ff ) ; for ( ; k1 < 52 ; ++ k1 ) encryptKeys [ k1 ] = ( ( encryptKeys [ k1 - 8 ] << 9 ) | ( encryptKeys [ k1 - 7 ] >>> 7 ) ) & ffff ; return encryptKeys ; }
tr	1	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	2	public void setCurrentVar ( int mag_idx ) { assert ( mag_idx >= - 1 && mag_idx < PaneData . magnetList . size ( ) ) ; setVisible ( false ) ; this . removeAll ( ) ; this . mag_idx = mag_idx ; if ( mag_idx == - 1 ) { log . severe ( "Magnet Pane - Magnet unselected." ) ; setVisible ( true ) ; return ; } Magnet mag = ( Magnet ) PaneData . magnetList . get ( mag_idx ) ; String mag_name = mag . getMagnetName ( ) ; for ( int i = 0 ; i < PaneData . var_names . size ( ) ; i ++ ) { String var_name = ( String ) PaneData . var_names . get ( i ) ; if ( var_name . equalsIgnoreCase ( mag_name ) ) { this . var_idx = i ; break ; } } log . severe ( "Magnet Pane - [" + PaneData . var_names . get ( var_idx ) + "] is selected." ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; setLayout ( new GridBagLayout ( ) ) ; constraints . fill = GridBagConstraints . BOTH ; strMeasure = ( String ) PaneData . var_measures . get ( var_idx ) ; strType = ( String ) PaneData . var_types . get ( var_idx ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; assert PaneData . values_min . get ( var_idx ) instanceof Integer ; assert PaneData . values_max . get ( var_idx ) instanceof Integer ; int min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; chkboxList = new JCheckBox [ max - min + 1 ] ; ArrayList repelList = mag . getRepelList ( ) ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( var_idx ) ; chkboxList [ i ] = new JCheckBox ( label . get ( min + i ) + " (" + Integer . toString ( min + i ) + ")" ) ; if ( repelList == null ) chkboxList [ i ] . setSelected ( false ) ; else chkboxList [ i ] . setSelected ( ( ( boolean ) repelList . get ( i ) ) . booleanValue ( ) ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.05 ; constraints . gridx = 0 ; constraints . gridy = 3 + i ; add ( chkboxList [ i ] , constraints ) ; } } else if ( strMeasure . equals ( "Q" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; double threshold = new double ( mag . getThreshold ( ) ) ; if ( strType . equals ( "I" ) ) { int min , max ; min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , min , max , threshold . intValue ( ) ) ; sliderRepel . setMinorTickSpacing ( ( max - min ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( max - min ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; } else if ( strType . equals ( "D" ) ) { double dmin , dmax ; dmin = ( ( double ) PaneData . values_min . get ( var_idx ) ) . doubleValue ( ) ; dmax = ( ( double ) PaneData . values_max . get ( var_idx ) ) . doubleValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , dmin , dmax , threshold . doubleValue ( ) , 1 ) ; sliderRepel . setMinorTickSpacing ( ( dmax - dmin ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( dmax - dmin ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getDoubleValue ( ) + "]" ) ; } } ) ; } else { assert false ; } constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 3 ; add ( sliderRepel , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	2	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	1	public void loadData ( DadesHotel hotel ) { TitledBorder leftBorder = BorderFactory . createTitledBorder ( hotel . nom ) ; leftBorder . setTitleJustification ( TitledBorder . LEFT ) ; this . setBorder ( leftBorder ) ; nomHotel = hotel . nom ; hotelDescriptionLabel . setText ( hotel . desc ) ; DefaultListModel model = new DefaultListModel ( ) ; for ( DadesHabitacio hab : hotel . habs ) { String dada = hab . tipusHab + " (" + hab . preu + "\u20AC) - " + hab . numeroDisp + " disponibles" ; model . addElement ( dada ) ; nomsTipus . add ( hab . tipusHab ) ; } tipusHabitacionsList . setModel ( model ) ; }
tr	1	@ Test public void acceptedTestAStar ( ) { Automaton a = new RegExp ( "a*" ) . toAutomaton ( ) ; String [ ] expected = { "" , "a" , "aa" , "aaa" , "aaaa" , "aaaaa" , "aaaaaa" , "aaaaaaa" , "aaaaaaaa" , "aaaaaaaaa" } ; int i = 0 ; for ( String s : AutomatonHelper . accepted ( a , 10 ) ) { assertEquals ( expected [ i ++ ] , s ) ; } }
tr	3	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
tr	3	@ Override public void clear ( ) { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . writeLock ( ) . lock ( ) ; } try { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . clear ( ) ; } } finally { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . writeLock ( ) . unlock ( ) ; } } }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	1	private ArrayList < AtomExecutableCommand > populateExecutableCommandList ( String serverId , ArrayList < AtomExecutableCommand > commandList ) { AtomExecutableCommand _commandDet ; ArrayList < AtomExecutableCommand > _commandList ; int index = 0 ; int _countExecutables ; _commandList = new ArrayList < AtomExecutableCommand > ( ) ; _countExecutables = commandList . size ( ) ; while ( _countExecutables > index ) { _commandDet = commandList . get ( index ) ; if ( serverId . equals ( _commandDet . getServerID ( ) ) ) { _commandList . add ( _commandDet ) ; } index ++ ; } return _commandList ; }
tr	1	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	3	protected TextIDPair readNextDocText ( BufferedReader docIn ) throws IOException { String line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".I" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { String [ ] parts = line . split ( "\\s+" ) ; if ( parts . length != 2 ) { throw new RuntimeException ( "CranfieldReader::Problems finding docID: " + line ) ; } int docID = Integer . parseInt ( parts [ 1 ] ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".W" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { StringBuffer buffer = new StringBuffer ( ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . equals ( "<END_DOC>" ) ) { buffer . append ( " " + line ) ; line = docIn . readLine ( ) ; } return new TextIDPair ( buffer . toString ( ) , docID ) ; } } }
tr	2	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	1	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	3	@ Deprecated static List < Object > graphToRDF ( Map < String , Object > graph , UniqueNamer namer ) { final List < Object > rval = new ArrayList < Object > ( ) ; for ( final String id : graph . keySet ( ) ) { final Map < String , Object > node = ( Map < String , Object > ) graph . get ( id ) ; final List < String > properties = new ArrayList < String > ( node . keySet ( ) ) ; Collections . sort ( properties ) ; for ( String property : properties ) { final Object items = node . get ( property ) ; if ( "@type" . equals ( property ) ) { property = RDF_TYPE ; } else if ( isKeyword ( property ) ) { continue ; } for ( final Object item : ( List < Object > ) items ) { final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; if ( id . indexOf ( "_:" ) == 0 ) { subject . put ( "type" , "blank node" ) ; subject . put ( "value" , namer . getName ( id ) ) ; } else { subject . put ( "type" , "IRI" ) ; subject . put ( "value" , id ) ; } final Map < String , Object > predicate = new LinkedHashMap < String , Object > ( ) ; predicate . put ( "type" , "IRI" ) ; predicate . put ( "value" , property ) ; if ( isList ( item ) ) { listToRDF ( ( List < Object > ) ( ( Map < String , Object > ) item ) . get ( "@list" ) , namer , subject , predicate , rval ) ; } else { final Object object = objectToRDF ( item , namer ) ; final Map < String , Object > tmp = new LinkedHashMap < String , Object > ( ) ; tmp . put ( "subject" , subject ) ; tmp . put ( "predicate" , predicate ) ; tmp . put ( "object" , object ) ; rval . add ( tmp ) ; } } } } return rval ; }
tr	4X	public boolean isValidSudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = Character . getNumericValue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = Character . getNumericValue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = Character . getNumericValue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
tr	4X	private void resizeTable ( ) { int newLen ; int i = 0 ; while ( primes [ i ] <= table . length ) i ++ ; newLen = primes [ i ] ; int oldItems = numItems ; DataCount < E > [ ] oldTable = table ; E [ ] oldKeyArr = keyArr ; table = ( DataCount < E > [ ] ) new DataCount [ newLen ] ; keyArr = ( E [ ] ) new Object [ newLen ] ; numItems = 0 ; for ( i = 0 ; i < oldItems ; i ++ ) { E nextData = oldKeyArr [ i ] ; int hashFind = hasherH . hash ( nextData ) % oldTable . length ; while ( comparator . compare ( oldTable [ hashFind ] . data , nextData ) != 0 ) { hashFind = ( hashFind + hasherG . hash ( nextData ) ) % oldTable . length ; } E data = oldTable [ hashFind ] . data ; incCount ( data ) ; int hashCode = hasherH . hash ( data ) % table . length ; while ( comparator . compare ( table [ hashCode ] . data , data ) != 0 ) { hashCode = ( hashCode + hasherG . hash ( data ) ) % table . length ; } table [ hashCode ] . count = oldTable [ hashFind ] . count ; } }
tr	4X	@ Override public void paintComponent ( Graphics g ) { this . g = ( Graphics2D ) g ; super . paintComponent ( g ) ; for ( int i = 0 ; i < ( this . size * this . size ) ; i ++ ) { this . g . drawLine ( getNodeX ( i ) , getNodeY ( i ) , getNodeX ( i ) , getNodeY ( i ) ) ; } Fire fire = this . loadedEnv . getLevel ( this . level ) . getFire ( ) ; int [ ] [ ] fireArray = fire . getArray ( ) ; for ( int i = 0 ; i < this . size ; i ++ ) { for ( int j = 0 ; j < this . size ; j ++ ) { if ( fireArray [ i ] [ j ] != 0 ) this . drawFire ( i * this . size + j , fireArray [ i ] [ j ] ) ; } } UndirectedGraph walls = this . loadedEnv . getLevel ( this . level ) . getWalls ( ) ; Iterator it = walls . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) walls . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawWall ( tempNode , tempNode2 ) ; } } UndirectedGraph doors = this . loadedEnv . getLevel ( this . level ) . getDoors ( ) ; it = doors . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) doors . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawDoor ( tempNode , tempNode2 ) ; } } UndirectedGraph exits = this . loadedEnv . getLevel ( this . level ) . getExits ( ) ; it = exits . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) exits . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawExit ( tempNode , tempNode2 ) ; } } ArrayList agents = this . loadedEnv . getAgents ( ) ; it = agents . iterator ( ) ; while ( it . hasNext ( ) ) { Agent a = ( Agent ) it . next ( ) ; if ( a . getLevel ( ) == this . level ) this . drawAgent ( a ) ; } ArrayList labels = this . loadedEnv . getLevel ( this . level ) . getLabels ( ) ; it = labels . iterator ( ) ; while ( it . hasNext ( ) ) { Label l = ( Label ) it . next ( ) ; this . drawLabel ( l ) ; } if ( this . hNode1 != 0 && this . hNode2 != 0 ) this . drawHighlight ( ) ; }
tr	1	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	3	public void readFaceBundles ( String n ) throws FileNotFoundException , IOException , IllegalArgumentException , ClassNotFoundException { root_dir = new File ( n ) ; File [ ] files = root_dir . listFiles ( new ImageFilter ( ) ) ; Vector filenames = new Vector ( ) ; String [ ] set = new String [ MAGIC_SETNR ] ; int i = 0 ; for ( i = 0 ; i < files . length ; i ++ ) { filenames . addElement ( files [ i ] . getName ( ) ) ; } Collections . sort ( ( List ) filenames ) ; b = new FaceBundle [ ( files . length / MAGIC_SETNR ) + 1 ] ; for ( i = 0 ; i < b . length ; i ++ ) { for ( int j = 0 ; j < MAGIC_SETNR ; j ++ ) { if ( filenames . size ( ) > j + MAGIC_SETNR * i ) { set [ j ] = ( String ) filenames . get ( j + MAGIC_SETNR * i ) ; } } b [ i ] = submitSet ( root_dir . getAbsolutePath ( ) + "/" , set ) ; } }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	3	public void handleGameData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct: " + length ) ; } else { acceptUpdatedMoveable ( data [ j - 2 ] , data [ j - 1 ] ) ; } } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { acceptDroppedBomb ( data [ j - 4 ] , data [ j - 3 ] , data [ j - 2 ] , data [ j - 1 ] ) ; } } } } } }
tr	2	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	0	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	3	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	1	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	3	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	3	public IPv4 ( String symbolicIP , String netmask ) throws NumberFormatException { String [ ] st = symbolicIP . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; int i = 24 ; baseIPnumeric = 0 ; for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; } baseIPnumeric += value << i ; i -= 8 ; } st = netmask . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; i = 24 ; netmaskNumeric = 0 ; if ( Integer . parseInt ( st [ 0 ] ) < 255 ) { throw new NumberFormatException ( "The first byte of netmask can not be less than 255" ) ; } for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; } netmaskNumeric += value << i ; i -= 8 ; } boolean encounteredOne = false ; int ourMaskBitPattern = 1 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( netmaskNumeric & ourMaskBitPattern ) != 0 ) { encounteredOne = true ; } else { if ( encounteredOne == true ) throw new NumberFormatException ( "Invalid netmask: " + netmask + " (bit " + ( i + 1 ) + ")" ) ; } ourMaskBitPattern = ourMaskBitPattern << 1 ; } }
tr	1	@ Override public boolean hasNext ( ) { while ( index < menu . size ( ) ) { if ( menu . get ( index ) . getCalories ( ) <= maxCalories ) { return true ; } else { index ++ ; } } return false ; }
tr	4X	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	3	public void handleData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct" ) ; } else { updateMoveable ( data [ i + 1 ] , data [ i + 2 ] ) ; } i = j ; break ; } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { addBomb ( data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] , data [ i + 4 ] ) ; } i = j ; break ; } } } } }
tr	0	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	4X	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
tr	3	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	1	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
tr	1	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	4X	public List < Vak > getVakkenVanStudent ( long studentId ) { List < Vak > vakken = new ArrayList < Vak > ( ) ; List < long > klasIds = new ArrayList < long > ( ) ; List < long > vakIds = new ArrayList < long > ( ) ; try { PreparedStatement prepareStatement = manager . prepareStatement ( "SELECT klas_id FROM leerling_klas WHERE leerling_id = ?" ) ; prepareStatement . setLong ( 1 , studentId ) ; ResultSet resultSet = prepareStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { klasIds . add ( resultSet . getLong ( 1 ) ) ; } PreparedStatement prepareStatement2 = manager . prepareStatement ( "SELECT vak_id FROM vak_klas WHERE klas_id = ?" ) ; for ( long klasId : klasIds ) { prepareStatement2 . setLong ( 1 , klasId ) ; ResultSet resultSet2 = prepareStatement2 . executeQuery ( ) ; while ( resultSet2 . next ( ) ) { vakIds . add ( resultSet2 . getLong ( 1 ) ) ; } } for ( long vakId : vakIds ) { vakken . add ( getVak ( vakId ) ) ; } return vakken ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return vakken ; } }
tr	1	@ Override public double getOutputError ( double [ ] outputError ) { double squareErrorSum = 0d ; for ( double error : outputError ) squareErrorSum += ( error * error ) * 0.5 ; return squareErrorSum ; }
tr	4X	static private Vector < double [ ] > sampleResults ( Vector < Future < Vector < double [ ] >>> results , int bins ) throws Exception { int nDescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; System . out . println ( "Printing for " + nDescriptors + " descriptors" ) ; Vector < double [ ] > descriptors = new Vector < double [ ] > ( nDescriptors ) ; for ( int d = 0 ; d < nDescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( Future < Vector < double [ ] >> result : results ) { Vector < double [ ] > samples = result . get ( ) ; int samplesPerBin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesPerBin && b * samplesPerBin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesPerBin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
tr	1	public int length ( ) { LinkedListNode iter = this ; int acc = 0 ; while ( iter != null ) { acc ++ ; iter = iter . next ; } return acc ; }
tr	1	public static long sum ( long ... values ) { long sum = 0 ; for ( long l : values ) { sum += l ; } return sum ; }
tr	3	public List < VariableAppearance > getAltAppearances ( ParsingContext context ) { List < VariableAppearance > result = new ArrayList < VariableAppearance > ( ) ; for ( String variableName : detectedVariableNames ) { for ( int i = 0 ; i < altPrefixRegexps . size ( ) ; i ++ ) { String completeRegexp = altPrefixRegexps . get ( i ) + variableName + altSuffixRegexps . get ( i ) ; Matcher matcher = Pattern . compile ( completeRegexp ) . matcher ( context . getContent ( ) ) ; while ( matcher . find ( ) ) { result . add ( new VariableAppearance ( matcher . group ( ) , variableName , globalContext , context , "" ) ) ; } } } return result ; }
tr	0	public void setGame ( Game game ) { this . game = game ; }
tr	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
tr	1	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	3	public T [ ] quicksort ( T [ ] array , int low , int high ) { int i = low ; int j = high ; T pivot = array [ low + ( high - low ) / 2 ] ; while ( i < j ) { while ( array [ i ] . compareTo ( pivot ) < 0 ) { i ++ ; } while ( array [ j ] . compareTo ( pivot ) > 0 ) { j -- ; } if ( i <= j ) { swap ( array , i , j ) ; i ++ ; j -- ; } } if ( low < j ) { quicksort ( array , low , j ) ; } if ( i < high ) { quicksort ( array , i , high ) ; } return array ; }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	3	private void initAlleles ( ) { for ( int acIndex = 0 ; acIndex < accessionCount ; acIndex ++ ) { for ( int mIndex = 0 ; mIndex < markerCount ; mIndex ++ ) { int alCnt = alleleName . get ( mIndex ) . size ( ) ; dataMatrix . get ( acIndex ) . set ( mIndex , new ArrayList < double > ( alCnt ) ) ; for ( int alIndex = 0 ; alIndex < alCnt ; alIndex ++ ) { dataMatrix . get ( acIndex ) . get ( mIndex ) . add ( null ) ; } } } }
tr	1	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	3	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	2	public void executeMacro ( VMacro macro ) throws TypeException { ArrayList < IValue > macroQueue = new ArrayList < IValue > ( ) ; for ( Object o : macro . getStackList ( ) ) { VQuote q = ( VQuote ) o ; macroQueue . add ( 0 , q . getInner ( ) ) ; } for ( IValue val : macroQueue ) { push ( val ) ; evaluateStack ( ) ; } }
tr	4X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	2	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	2	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	2	public GameBoard ( int mines , int height , int width ) { board = new Square [ height ] [ width ] ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { board [ i ] [ j ] = new Square ( ) ; } } this . mines = mines ; this . height = height ; this . width = width ; }
tr	2	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	4X	public int longestConsecutive ( int [ ] num ) { int max = 0 ; if ( num == null ) return max ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : num ) { set . add ( i ) ; } for ( int i : num ) { if ( set . contains ( i ) ) { set . remove ( i ) ; int start = i - 1 ; while ( set . contains ( start ) ) { set . remove ( start ) ; start -- ; } int end = i + 1 ; while ( set . contains ( end ) ) { set . remove ( end ) ; end ++ ; } max = Math . max ( max , end - start - 1 ) ; } } return max ; }
tr	1	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	3	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	1	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	2	public void exit ( ) { for ( List < GameSystem > s : systems . values ( ) ) { for ( GameSystem system : s ) { system . exit ( ) ; } } systems . clear ( ) ; }
tr	4X	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	2	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	2	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	1	private String [ ] camposOrdem ( ) { String camposPesquisa [ ] = new String [ estruturaTabela . size ( ) ] ; for ( int i = 0 ; i < estruturaTabela . size ( ) ; i ++ ) { camposPesquisa [ i ] = estruturaTabela . get ( i ) . getCampo ( ) ; } jCBOrdemPesq . setModel ( new javax . swing . DefaultComboBoxModel ( camposPesquisa ) ) ; return camposPesquisa ; }
tr	1	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	1	public void divide ( int ncol , int nrow ) { canvasPads . setSize ( this . getSize ( ) . width , this . getSize ( ) . height , ncol , nrow ) ; int ncharts = canvasPads . getNPads ( ) ; series . clear ( ) ; for ( int loop = 0 ; loop < ncharts ; loop ++ ) { ScGroupSeries chart = new ScGroupSeries ( new ScRegion ( canvasPads . getX ( loop ) , canvasPads . getY ( loop ) , canvasPads . getWidth ( loop ) , canvasPads . getHeight ( loop ) ) ) ; series . add ( chart ) ; } }
tr	4X	public static void main ( String [ ] args ) { BigInteger totalSum = BigInteger . ZERO ; for ( int i = 2 ; i <= 4 ; i ++ ) { BigInteger [ ] [ ] arrangements = new BigInteger [ 51 ] [ 50 ] ; for ( int j = 0 ; j <= 50 ; j ++ ) for ( int k = 0 ; k < 50 ; k ++ ) arrangements [ j ] [ k ] = BigInteger . ZERO ; arrangements [ 1 ] [ 0 ] = BigInteger . ONE ; for ( int j = 1 ; j < 50 ; j ++ ) { for ( int k = 1 ; k <= 50 ; k ++ ) arrangements [ k ] [ j ] = arrangements [ k - 1 ] [ j - 1 ] ; for ( int k = i ; k <= 50 ; k ++ ) arrangements [ 0 ] [ j ] = arrangements [ 0 ] [ j ] . add ( arrangements [ k ] [ j ] ) ; } for ( int j = 0 ; j < 50 ; j ++ ) totalSum = totalSum . add ( arrangements [ j ] [ 49 ] ) ; } System . out . println ( totalSum ) ; }
tr	2	public static void onAllROute ( Individual individual ) { ProblemInstance problemInstance = individual . problemInstance ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { mutateRouteBy2_Opt ( individual , period , vehicle ) ; } } }
tr	2	private void addMountanSides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existTileOfType ( new Mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new MountainSide ( ) ) ; map [ i ] [ j + 2 ] . add ( new MountainSide ( ) ) ; } } } }
tr	4X	public List < String > getUnionList ( List < String > list1 , List < String > list2 ) { List < String > totalList = new ArrayList < > ( ) ; if ( list1 . size ( ) > list2 . size ( ) ) { for ( String obj : list1 ) { totalList . add ( obj ) ; } for ( String obj : list2 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } else { for ( String obj : list2 ) { totalList . add ( obj ) ; } for ( String obj : list1 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } return totalList ; }
tr	4X	public static int [ ] getPrimes ( int max ) { int [ ] primes = new int [ max + 1 ] ; for ( int i = 2 ; i <= max ; i ++ ) { primes [ i ] = i ; } int total = max - 1 ; for ( int i = 2 ; i <= Math . sqrt ( max ) ; i ++ ) { for ( int j = i ; j <= max ; ) { j += i ; if ( j <= max && primes [ j ] > 0 ) { primes [ j ] = 0 ; total -- ; } } } int [ ] totalprimes = new int [ total ] ; int temp = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > 0 ) { totalprimes [ temp ] = primes [ i ] ; temp ++ ; } } return totalprimes ; }
tr	2	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	4X	public int minPathSum ( int [ ] [ ] grid ) { int sum = 0 ; if ( grid == null || grid . length == 0 || grid [ 0 ] . length == 0 ) return sum ; int [ ] prev = new int [ grid [ 0 ] . length ] ; int [ ] curr = new int [ grid [ 0 ] . length ] ; prev [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) prev [ j ] = prev [ j - 1 ] + grid [ 0 ] [ j ] ; for ( int i = 1 ; i < grid . length ; i ++ ) { curr [ 0 ] = prev [ 0 ] + grid [ i ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) { curr [ j ] = Math . min ( prev [ j ] , curr [ j - 1 ] ) + grid [ i ] [ j ] ; } for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; int [ ] tmp = curr ; curr = prev ; prev = tmp ; } return prev [ prev . length - 1 ] ; }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
tr	1	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	4X	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Radical > radicals = new ArrayList < Radical > ( ) ; for ( int i = 0 ; i <= SIZE ; i ++ ) radicals . add ( new Radical ( i , primeList ) ) ; radicals = sort ( radicals ) ; System . out . print ( radicals . get ( SIZE / 10 ) . num ) ; }
tr	2	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } tring data = tring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	1	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	4X	public void testLineSeriesChart ( ) { LineSeriesChart < Number , Number > chart = new LineSeriesChart < Number , Number > ( "Curves" , "X" , "Y" ) ; Collection < LineSeriesItem < Number , Number >> linhaSin = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaSin . add ( new LineSeriesItem < Number , Number > ( i , Math . sin ( i ) + 4 ) ) ; } chart . addValue ( linhaSin ) ; Collection < LineSeriesItem < Number , Number >> linhaCos = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaCos . add ( new LineSeriesItem < Number , Number > ( i , Math . cos ( i ) ) ) ; } chart . addValue ( linhaCos ) ; Collection < LineSeriesItem < Number , Number >> linhaExp = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaExp . add ( new LineSeriesItem < Number , Number > ( i , Math . exp ( i ) + 1 ) ) ; } chart . addValue ( linhaExp ) ; Collection < LineSeriesItem < Number , Number >> linhaReta = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaReta . add ( new LineSeriesItem < Number , Number > ( i , i ) ) ; } chart . addValue ( linhaReta ) ; Highlighter highlighter = criarHighlighter ( ) ; chart . getChartConfiguration ( ) . setHighlighter ( highlighter ) ; chart . addSerie ( criarSerie ( "Seno" , "#489104" ) ) ; chart . addSerie ( criarSerie ( "Coseno" , "#c91212" ) ) ; chart . addSerie ( criarSerie ( "Exponensial" , "#7D02B2" ) ) ; chart . addSerie ( criarSerie ( "Reta" , "#066FA7" ) ) ; Legend legend = new Legend ( true , Location . ne ) ; legend . setPlacement ( "outsideGrid" ) ; chart . setLegend ( legend ) ; Axis < String > axis = new AxisString ( ) ; axis . setLabelRenderer ( JqPlotResources . CanvasAxisLabelRenderer ) ; chart . setAxesDefaults ( axis ) ; Axes axes = chart . getAxes ( ) ; XAxis xaxis = axes . getXaxis ( ) ; TickOptions tickOptions = new TickOptions ( ) ; tickOptions . setAngle ( 270 ) ; tickOptions . setLabelPosition ( "end" ) ; xaxis . setTickOptions ( tickOptions ) ; xaxis . setTickRenderer ( JqPlotResources . CanvasAxisTickRenderer ) ; xaxis . setTickInterval ( 1 ) ; axes . getYaxis ( ) . setTickInterval ( 0.50 ) ; axes . getYaxis ( ) . setMax ( 8.50 ) ; axes . getYaxis ( ) . setMin ( - 1.50 ) ; TickOptions tickOptionsY = new TickOptions ( ) ; tickOptionsY . setFormatString ( "%.2f" ) ; axes . getYaxis ( ) . setTickOptions ( tickOptionsY ) ; Grid grid = new Grid ( ) ; grid . setBackground ( "#ffffff" ) ; grid . setGridLineColer ( "#a0a0a0" ) ; chart . getChartConfiguration ( ) . setGrid ( grid ) ; Cursor cursor = new Cursor ( ) ; cursor . setZoom ( true ) ; cursor . setClickReset ( true ) ; chart . getChartConfiguration ( ) . setCursor ( cursor ) ; String json = JqPlotUtils . createJquery ( chart , "div3" ) ; json = json . replaceAll ( "\\$" , "jQuery" ) ; System . out . println ( json ) ; }
tr	2	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	3	public boolean isPalindrome ( String s ) { if ( s == null ) return false ; if ( s . equals ( "" ) ) return true ; String sLow = s . toLowerCase ( ) ; char [ ] S = sLow . toCharArray ( ) ; int left = 0 , right = s . length ( ) - 1 ; while ( left < right ) { while ( ( S [ left ] < 0 || S [ left ] > 9 ) && ( S [ left ] < a || S [ left ] > z ) && ( left < right ) ) { left ++ ; } while ( ( S [ right ] < 0 || S [ right ] > 9 ) && ( S [ right ] < a || S [ right ] > z ) && ( left < right ) ) { right -- ; } if ( S [ left ++ ] != S [ right -- ] ) return false ; } return true ; }
tr	0	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
tr	2	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	4X	@ Test public void testPacketSending ( ) throws SocketException { MicroSecondsTimeStamp stamper = mock ( MicroSecondsTimeStamp . class ) ; when ( stamper . timeStamp ( ) ) . thenReturn ( 0 ) ; UtpAlgorithm algorithm = new UtpAlgorithm ( stamper , new InetSocketAddress ( 51235 ) ) ; UtpAlgConfiguration . SEND_IN_BURST = true ; UtpAlgConfiguration . MAX_BURST_SEND = 3 ; int packetLength = 1000 ; algorithm . setMaxWindow ( packetLength * 10 ) ; UtpTimestampedPacketDTO pkt5 = createPacket ( 5 , packetLength ) ; UtpTimestampedPacketDTO pkt6 = createPacket ( 6 , packetLength ) ; UtpTimestampedPacketDTO pkt7 = createPacket ( 7 , packetLength ) ; UtpTimestampedPacketDTO pkt8 = createPacket ( 8 , packetLength ) ; UtpTimestampedPacketDTO pkt9 = createPacket ( 9 , packetLength ) ; algorithm . markPacketOnfly ( pkt5 . utpPacket ( ) , pkt5 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt6 . utpPacket ( ) , pkt6 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt7 . utpPacket ( ) , pkt7 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt8 . utpPacket ( ) , pkt8 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt9 . utpPacket ( ) , pkt9 . dataGram ( ) ) ; assertEquals ( 5 * ( UtpPacketUtils . DEF_HEADER_LENGTH + packetLength ) , algorithm . getCurrentWindow ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; algorithm . setMaxWindow ( packetLength * 4 ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } algorithm . setMaxWindow ( 10 * packetLength ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; }
tr	1	public void simulateOneStep ( ) { step ++ ; startSickness ( startKans ) ; List < Actor > newActors = new ArrayList < Actor > ( ) ; for ( Iterator < Actor > it = actors . iterator ( ) ; it . hasNext ( ) ; ) { Actor actor = it . next ( ) ; actor . act ( newActors ) ; if ( ! actor . isActive ( ) ) { it . remove ( ) ; } } actors . addAll ( newActors ) ; statusUpdate ( ) ; }
tr	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	4X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	1	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	1	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	1	public void displayPlayer ( ) { Iterator < PlayerID > iter = activePlayers . iterator ( ) ; PlayerID p ; System . out . println ( "--- PlayerIDs ---" ) ; while ( iter . hasNext ( ) ) { p = iter . next ( ) ; System . out . println ( "PlayerID: " + p . getPID ( ) + "  ConnectionID: " + p . getCID ( ) ) ; } }
tr	1	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	3	static int entrance ( List < Point > points , int k ) { int size = points . size ( ) ; Map < String , Integer > indexHash = new HashMap < > ( ) ; Map < String , Point > pointHash = new HashMap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Point p = points . get ( i ) ; indexHash . put ( p . x + " " + p . y , i ) ; pointHash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { Point from = points . get ( i ) ; int max = 0 ; Set < Point > rangePoints = rangePonints ( from , k , pointHash ) ; for ( Point p : rangePoints ) { Integer index = indexHash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxPathValue > max ) { max = p . maxPathValue ; } } from . maxPathValue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxPathValue ; } return - 1 ; }
tr	3	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	2	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	4X	private void verifyForeignKeyConstraints ( Tuple tuple ) throws DatabaseException { for ( Schema . ForeignKey fk : schema . getForeignKeys ( ) ) { Table refTable = fk . getRefTable ( ) ; int [ ] localKeyPositions = fk . getForeignKeyPositions ( ) ; Object [ ] localKeyValues = new Object [ localKeyPositions . length ] ; Attribute . Type [ ] localKeyTypes = new Attribute . Type [ localKeyPositions . length ] ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { localKeyValues [ i ] = tuple . getValueAt ( localKeyPositions [ i ] ) ; localKeyTypes [ i ] = schema . getAttributes ( ) [ localKeyPositions [ i ] ] . getType ( ) ; } int [ ] refKeyPositions = refTable . getSchema ( ) . getPrimaryKeyPositions ( ) ; boolean matchFound = false ; for ( Tuple refTuple : refTable . getTuples ( ) ) { matchFound = true ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { if ( ! Tuple . valuesEqual ( localKeyTypes [ i ] , localKeyValues [ i ] , refTuple . getValueAt ( refKeyPositions [ i ] ) ) ) { matchFound = false ; break ; } } if ( matchFound ) break ; } if ( ! matchFound ) { throw new DatabaseException ( "Referential constraint to table '" + refTable . getName ( ) + "' not met." ) ; } } }
tr	3	boolean line ( ) throws IOException { int lev = integer ( ) - 1 ; if ( lev == - 1 ) return false ; int c = read ( ) ; if ( c == 1 ) { int len ; bb . reset ( ) ; while ( ( len = integer ( ) ) > 0 ) { bb . extend ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { bb . put ( ( byte ) read ( ) ) ; } } event . level ( lev ) ; event . event ( bb . clone ( ) ) ; return true ; } else if ( c > 1 ) { bb . reset ( ) ; bb . extend ( 64 ) ; bb . put ( ( byte ) c ) ; while ( ( c = read ( ) ) != 0 ) bb . put ( ( byte ) c ) ; event . level ( lev ) ; event . event ( new String ( bb . getBuffer ( ) , 0 , bb . length ( ) , "UTF-8" ) ) ; return true ; } else { event . level ( lev ) ; event . event ( "" ) ; } return true ; }
tr	2	private static int [ ] leeVector ( String mensaje , int longitud ) { int [ ] vector = new int [ longitud ] ; boolean valido = false ; while ( ! valido ) { System . out . print ( mensaje ) ; try { for ( int i = 0 ; i < longitud ; i ++ ) vector [ i ] = Coin . nextInt ( ) ; if ( Coin . hasNextLine ( ) ) Coin . nextLine ( ) ; valido = true ; } catch ( Exception ex ) { Coin . nextLine ( ) ; } } return vector ; }
tr	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
tr	4X	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
tr	3	void initialize ( int d ) { this . matArray = new Material [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . tileState = new int [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . cleanColor = new Material ( ) ; this . cleanColor . setAmbient ( 0.7 , 0.7 , 0.7 ) ; this . cleanColor . setDiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleanColor . setSpecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredColor = new Material ( ) ; this . coveredColor . setAmbient ( 0.1 , 0.1 , 0.1 ) ; this . coveredColor . setDiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredColor . setSpecular ( .5 , .5 , .5 , 10 ) ; this . redColor = new Material ( ) ; this . redColor . setAmbient ( 0.9 , 0.1 , 0.1 ) ; this . redColor . setDiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redColor . setSpecular ( .95 , .15 , .15 , 10 ) ; this . yellowColor = new Material ( ) ; this . yellowColor . setAmbient ( 0.9 , 0.9 , 0.1 ) ; this . yellowColor . setDiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowColor . setSpecular ( .95 , .95 , .15 , 10 ) ; this . blueColor = new Material ( ) ; this . blueColor . setAmbient ( 0.1 , 0.1 , 0.9 ) ; this . blueColor . setDiffuse ( 0.15 , 0.15 , 0.95 ) ; this . blueColor . setSpecular ( .15 , .15 , .95 , 10 ) ; this . greenColor = new Material ( ) ; this . greenColor . setAmbient ( 0.1 , 0.9 , 0.1 ) ; this . greenColor . setDiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greenColor . setSpecular ( .15 , .95 , .15 , 10 ) ; this . orangeColor = new Material ( ) ; this . orangeColor . setAmbient ( 0.98 , 0.5 , 0.25 ) ; this . orangeColor . setDiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangeColor . setSpecular ( .99 , .52 , .27 , 10 ) ; this . purpleColor = new Material ( ) ; this . purpleColor . setAmbient ( 0.9 , 0.1 , 0.9 ) ; this . purpleColor . setDiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purpleColor . setSpecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getNumFaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getDimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getDimension ( ) ; column ++ ) { this . getFace ( face ) [ row ] [ column ] . setMaterial ( this . coveredColor ) ; this . tileState [ face ] [ row ] [ column ] = 0 ; } } } }
tr	1	@ Override public String getMessage ( ) { String msg = super . getMessage ( ) ; for ( String name : badValues . keySet ( ) ) { msg += "\n\t" + name + " = " + badValues . get ( name ) ; } return msg ; }
tr	0	public String getMateria ( ) { return materia ; }
tr	4X	@ Override protected ArrayList < PossibleTile > getLazyTiles ( Board b ) { ArrayList < PossibleTile > possibleTiles = new ArrayList < PossibleTile > ( ) ; int i = 1 ; boolean canSearch = true ; Rook clone = this . clone ( ) ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) - i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) + i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) - i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) + i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } return possibleTiles ; }
tr	3	public static void knapsackBits ( int [ ] weights , int [ ] values , long maxWeight ) { int n = weights . length ; long numSets = ( long ) Math . pow ( 2 , n ) ; long bestSet = 0 ; long bestValue = 0 ; long bestWeight = 0 ; for ( long set = 1 ; set < numSets ; set ++ ) { long weight = 0 ; long value = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( set >> i ) & 1 ) == 1 ) { weight += weights [ i ] ; value += values [ i ] ; } } if ( weight <= maxWeight && value > bestValue ) { bestValue = value ; bestWeight = weight ; bestSet = set ; } } for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( bestSet >> i ) & 1 ) == 1 ) { System . out . print ( "[i=" + i + "  w=" + weights [ i ] + "  v=" + values [ i ] + "] " ) ; } } System . out . println ( ) ; System . out . println ( "Weight = " + bestWeight + "  Value = " + bestValue ) ; }
tr	1	public OptionSet getMatchingSet ( boolean ignoreUnmatched , boolean requireDataLast ) { for ( String setName : optionSets . keySet ( ) ) if ( check ( setName , ignoreUnmatched , requireDataLast ) ) return optionSets . get ( setName ) ; return null ; }
tr	3	private String getSelect ( List < String > tables , Map < String , Object > params ) { if ( tables . size ( ) < 1 ) { return "ERROR: The tables list is empty" ; } StringBuffer sql = new StringBuffer ( ) ; sql . append ( "SELECT " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } sql . append ( " FROM " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table ) ; sql . append ( " " ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } if ( params . isEmpty ( ) ) { return sql . toString ( ) ; } sql . append ( " WHERE " ) ; int i = 0 ; for ( String paramName : params . keySet ( ) ) { Object paramValue = params . get ( paramName ) ; sql . append ( paramName ) ; sql . append ( "=" ) ; if ( paramValue instanceof java . sql . Date ) { sql . append ( "'" ) ; sql . append ( paramValue ) ; sql . append ( "'" ) ; } else if ( paramValue instanceof String ) { sql . append ( "\"" ) ; sql . append ( paramValue ) ; sql . append ( "\"" ) ; } else { sql . append ( paramValue ) ; } if ( i < params . size ( ) - 1 ) { sql . append ( " AND " ) ; } i ++ ; } return sql . toString ( ) ; }
tr	3	private void setTextFieldVerifiers ( ) { final JComponent [ ] componentArr = new JComponent [ ] { textFieldName , textFieldMinAmount , textFieldMaxAmount , textFieldDuration , textFieldStartPay , textFieldPercent , textAreaDescription } ; final TextFieldVerifier verifier = new TextFieldVerifier ( ) ; for ( JComponent component : componentArr ) { component . setInputVerifier ( verifier ) ; } KeyListener listener = new KeyAdapter ( ) { public void keyTyped ( KeyEvent e ) { for ( JComponent component : componentArr ) { boolean enabled = verifier . verify ( component ) ; if ( enabled == false ) { buttonSave . setEnabled ( enabled ) ; break ; } buttonSave . setEnabled ( enabled ) ; } } } ; for ( JComponent component : componentArr ) { component . addKeyListener ( listener ) ; } }
tr	0	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	0	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
tr	4X	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	1	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	4X	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	2	public Code getCodeByDescription ( String description ) { for ( Code code : codes ) { Map < String , String > localizedStrings = code . getDescription ( ) . getLocalizedStrings ( ) ; for ( String key : localizedStrings . keySet ( ) ) { if ( localizedStrings . get ( key ) . equalsIgnoreCase ( description ) ) { return code ; } } } return null ; }
tr	0	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	3	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ ( int ) i ] ; } } } return out ; } }
tr	0	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	2	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	3	public void rotateCounterClockwise ( ) { boolean temp [ ] [ ] = new boolean [ PIECE_SIZE ] [ PIECE_SIZE ] ; for ( int i = 0 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { temp [ i ] [ j ] = currentShape [ j ] [ PIECE_SIZE - i - 1 ] ; } } currentShape = temp ; while ( shiftUp ( ) ) ; int tmp = width ; width = height ; height = tmp ; switch ( state ) { case 0 : state = 3 ; break ; case 1 : state = 0 ; break ; case 2 : state = 1 ; break ; case 3 : state = 2 ; break ; case 4 : state = 7 ; break ; case 5 : state = 4 ; break ; case 6 : state = 5 ; break ; case 7 : state = 6 ; break ; } }
tr	4X	public void notifyWindowListeners ( List < EngineWindowListener > listeners ) { while ( ! windowEvents . isEmpty ( ) ) { WindowEvent event = windowEvents . poll ( ) ; switch ( event . getID ( ) ) { case WindowEvent . WINDOW_OPENED : for ( EngineWindowListener listener : listeners ) { listener . windowOpened ( event ) ; } break ; case WindowEvent . WINDOW_CLOSING : for ( EngineWindowListener listener : listeners ) { listener . windowClosing ( event ) ; } break ; case WindowEvent . WINDOW_CLOSED : for ( EngineWindowListener listener : listeners ) { listener . windowClosed ( event ) ; } break ; case WindowEvent . WINDOW_ICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowIconified ( event ) ; } break ; case WindowEvent . WINDOW_DEICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowDeiconified ( event ) ; } break ; case WindowEvent . WINDOW_ACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowActivated ( event ) ; } break ; case WindowEvent . WINDOW_DEACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowDeactivated ( event ) ; } break ; } } }
tr	2	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	4X	public void prepare ( Dish dish ) { LinkedList < Material > materials = dish . getMaterials ( ) ; for ( Material tmp : materials ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) ) { storage . setAmount ( storage . getAmount ( ) - tmp . getAmount ( ) ) ; } } } LinkedList < Ingredient > ingredients = dish . getIngredients ( ) ; for ( Ingredient tmp : ingredients ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) && storage . getAmount ( ) > 0 ) { storage . setAmount ( storage . getAmount ( ) - 1 ) ; } } } nodifyObserver ( ) ; }
tr	0	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	1	public void testService ( ) throws Exception { System . out . println ( "locating service:osgi" ) ; int count = 0 ; for ( ServiceLocationEnumeration services = TestActivator . locator . findServices ( new ServiceType ( "service:osgi" ) , null , null ) ; services . hasMoreElements ( ) ; ) { assertEquals ( services . next ( ) . toString ( ) , "service:osgi://gantenbein:123" ) ; count ++ ; } assertEquals ( count , 1 ) ; }
tr	2	public static void debug ( Connection con ) throws Exception { System . out . println ( "\nDUMP OF TABLE GEOLOC:" ) ; Statement stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT geohash  subject  predicate  lat_lon_object  lat  lon FROM geoloc" ) ; while ( rs . next ( ) ) System . out . println ( "geoloc row: " + rs . getString ( "geohash" ) + " " + rs . getString ( "subject" ) + " " + rs . getString ( "predicate" ) + " " + rs . getString ( "lat_lon_object" ) + " " + rs . getFloat ( "lat" ) + " " + rs . getFloat ( "lon" ) ) ; System . out . println ( ) ; System . out . println ( "\nDUMP OF TABLE FREE TEXT PREDICATES:" ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( "SELECT predicate FROM free_text_predicates" ) ; while ( rs . next ( ) ) System . out . println ( "free_text_predicates row: " + rs . getString ( "predicate" ) ) ; System . out . println ( ) ; }
tr	4X	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	4X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	4X	private static Map < UnaryRule , List < String >> computeUnaryClosure ( Collection < UnaryRule > unaryRules ) { Map < UnaryRule , String > intermediateStates = new HashMap < UnaryRule , String > ( ) ; Counter < UnaryRule > pathCosts = new Counter < UnaryRule > ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByChild = new HashMap < String , List < UnaryRule >> ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByParent = new HashMap < String , List < UnaryRule >> ( ) ; Set < String > states = new HashSet < String > ( ) ; for ( UnaryRule unaryRule : unaryRules ) { relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , unaryRule , null , unaryRule . getScore ( ) ) ; states . add ( unaryRule . getParent ( ) ) ; states . add ( unaryRule . getChild ( ) ) ; } for ( String intermediateState : states ) { List < UnaryRule > incomingRules = closedUnaryRulesByChild . get ( intermediateState ) ; List < UnaryRule > outgoingRules = closedUnaryRulesByParent . get ( intermediateState ) ; if ( incomingRules == null || outgoingRules == null ) continue ; for ( UnaryRule incomingRule : incomingRules ) { for ( UnaryRule outgoingRule : outgoingRules ) { UnaryRule rule = new UnaryRule ( incomingRule . getParent ( ) , outgoingRule . getChild ( ) ) ; double newScore = pathCosts . getCount ( incomingRule ) * pathCosts . getCount ( outgoingRule ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , rule , intermediateState , newScore ) ; } } } for ( String state : states ) { UnaryRule selfLoopRule = new UnaryRule ( state , state ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , selfLoopRule , null , 1.0 ) ; } Map < UnaryRule , List < String >> closureMap = new HashMap < UnaryRule , List < String >> ( ) ; for ( UnaryRule unaryRule : pathCosts . keySet ( ) ) { unaryRule . setScore ( pathCosts . getCount ( unaryRule ) ) ; List < String > path = extractPath ( unaryRule , intermediateStates ) ; closureMap . put ( unaryRule , path ) ; } System . out . println ( "SIZE: " + closureMap . keySet ( ) . size ( ) ) ; return closureMap ; }
tr	2	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) != null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) != null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
tr	2	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	2	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
tr	2	public RegularAnalyzer ( List < Rule > rules ) { Set < String > definedRuleNames = new HashSet < String > ( ) ; List < Rule > observedRules = new ArrayList < Rule > ( ) ; observedRules . addAll ( rules ) ; boolean foundRegular ; do { foundRegular = false ; for ( int index = observedRules . size ( ) - 1 ; index >= 0 ; index -- ) { Set < String > dependent = observedRules . get ( index ) . getElements ( ) . getDependentRuleNames ( ) ; if ( definedRuleNames . containsAll ( dependent ) ) { definedRuleNames . add ( observedRules . get ( index ) . getRuleName ( ) . toString ( ) ) ; regularRules . add ( observedRules . get ( index ) ) ; observedRules . remove ( index ) ; foundRegular = true ; continue ; } } } while ( foundRegular ) ; observedRules . clear ( ) ; }
tr	2	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	3	public void writeWeights ( File file ) throws IOException { PrintWriter out = new PrintWriter ( file ) ; for ( int l = 0 ; l < layers . size ( ) - 1 ; ++ l ) { double [ ] [ ] w = weights . get ( l ) ; for ( int i = 0 ; i < layers . get ( l ) . size ( ) + 1 ; ++ i ) for ( int j = 0 ; j < layers . get ( l + 1 ) . size ( ) ; ++ j ) out . print ( w [ i ] [ j ] + " " ) ; } out . close ( ) ; }
tr	4X	public SourceBlock [ ] partition ( ) { Partition KZ = new Partition ( Kt , Z ) ; int KL = KZ . get ( 1 ) ; int KS = KZ . get ( 2 ) ; int ZL = KZ . get ( 3 ) ; Partition TN = new Partition ( T / ALIGN_PARAM , N ) ; int TL = TN . get ( 1 ) ; int TS = TN . get ( 2 ) ; int NL = TN . get ( 3 ) ; SourceBlock [ ] object = new SourceBlock [ Z ] ; int i ; int index_master = 0 ; for ( i = 0 ; i < ZL ; i ++ ) { byte [ ] symbols = new byte [ KL * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KL ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KL * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KL * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KL ) ; index_master += ( KL * T ) ; } for ( ; i < Z ; i ++ ) { byte [ ] symbols = new byte [ KS * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KS ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KS * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KS * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KS ) ; index_master += ( KS * T ) ; } return object ; }
tr	3	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
tr	2	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] >= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
tr	4X	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	3	public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 1 , 3 , 7 , 5 , 4 , 12 , 13 } ; Arrays . sort ( a ) ; int len = a . length ; int d [ ] = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { d [ i ] = a [ i ] * a [ i ] ; } for ( int i = len - 1 ; i > 2 ; i -- ) { int sum = d [ i ] ; int R = d [ i - 1 ] ; for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( d [ j ] + R == sum ) { System . out . println ( "The Pythagorean Triplet is : " + a [ j ] + " | " + a [ i - 1 ] + " | " + a [ i ] ) ; } } } }
tr	1	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	3	public ArrayList < ArrayList < Integer >> zigzagLevelOrder ( TreeNode root ) { ArrayList < ArrayList < Integer >> out = new ArrayList < ArrayList < Integer >> ( ) ; if ( root == null ) return out ; ValPack p = new ValPack ( ) ; p . node = root ; p . level = 0 ; LinkedList < ValPack > nodeList = new LinkedList < ValPack > ( ) ; LinkedList < ValPack > list = new LinkedList < ValPack > ( ) ; nodeList . addLast ( p ) ; int curLevel = 0 ; while ( nodeList . size ( ) != 0 ) { p = nodeList . removeFirst ( ) ; if ( p . level != curLevel ) { ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; list = new LinkedList < ValPack > ( ) ; curLevel = p . level ; } list . addLast ( p ) ; if ( p . node . left != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . left ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } if ( p . node . right != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . right ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } } ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; return out ; }
tr	1	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	0	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	2	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	1	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	4X	public void resetBoard ( ) { for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { m_Pieces [ i ] [ j ] = NONE_PIECE ; } } m_Pieces [ 3 ] [ 3 ] = WHITE_PIECE ; m_Pieces [ 4 ] [ 4 ] = WHITE_PIECE ; m_Pieces [ 3 ] [ 4 ] = BLACK_PIECE ; m_Pieces [ 4 ] [ 3 ] = BLACK_PIECE ; for ( int x = 0 ; x < WIDTH ; x ++ ) { for ( int y = 0 ; y < HEIGHT ; y ++ ) { if ( m_Pieces [ x ] [ y ] == null ) { m_Pieces [ x ] [ y ] = NONE_PIECE ; } } } }
tr	3	@ Override protected void paintComponent ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; g2d . setColor ( Color . BLACK ) ; g2d . setStroke ( new BasicStroke ( 2 ) ) ; for ( int i = 0 ; i <= World . SIZE ; i ++ ) { Line2D hline = new Line2D . double ( 0 , i * GRID_SIZE , 600 , i * GRID_SIZE ) ; Line2D vline = new Line2D . double ( i * GRID_SIZE , 0 , i * GRID_SIZE , 600 ) ; g2d . draw ( hline ) ; g2d . draw ( vline ) ; } for ( Point fuel : world . getAvailableFuel ( ) ) { int x = fuel . x * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getWidth ( ) / 2 ; int y = fuel . y * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getHeight ( ) / 2 ; g2d . drawImage ( fuelImage , x , y , null ) ; } for ( int i = 1 ; i <= 2 ; i ++ ) { Robot rob ; if ( ( rob = world . getRobot ( i ) ) != null ) rob . draw ( g2d , getTimeRatio ( ) ) ; } }
tr	1	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	4X	public void InitializeGameWorld ( int numEnemyTanks , int numRocks , int numTrees ) { listObjects = new LinkedList < GameObject > ( ) ; tanks = new LinkedList < Tank > ( ) ; landscape = new LinkedList < LandscapeGameObject > ( ) ; projectiles = new LinkedList < Projectile > ( ) ; playerTank = getRandomPlayerTank ( 0 ) ; for ( int i = 0 ; i < numEnemyTanks ; i ++ ) { Tank tank = getRandomTank ( ) ; while ( collidesWithWorld ( tank ) ) { if ( Game . debug ) { System . out . println ( "tank placement collision" ) ; } tank = getRandomTank ( ) ; } addTank ( tank ) ; } for ( int j = 0 ; j < numRocks ; j ++ ) { Rock rock = getRandomRock ( j ) ; while ( collidesWithWorld ( rock ) ) { if ( Game . debug ) { System . out . println ( "rock placement collision" ) ; } rock = getRandomRock ( j ) ; } addLandscapeObject ( rock ) ; } for ( int k = 0 ; k < numTrees ; k ++ ) { Tree tree = getRandomTree ( k ) ; while ( collidesWithWorld ( tree ) ) { if ( Game . debug ) { System . out . println ( "tree placement collision" ) ; } tree = getRandomTree ( k ) ; } addLandscapeObject ( tree ) ; } addTank ( playerTank ) ; lives = startingLives ; score = 0 ; gameClock = 0 ; gameOver = false ; TotaltankCount = 0 ; notifyObservers ( ) ; }
tr	0	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	2	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	4X	public Prototype load ( ) throws IOException { Prototype proto = new Prototype ( ) ; proto . source = readLuaString ( ) ; stream . skipBytes ( 8 ) ; proto . numUpvalues = read ( ) ; proto . numParams = read ( ) ; proto . isVararg = ( read ( ) & 2 ) != 0 ; proto . maxStacksize = read ( ) ; int length = 0 ; length = readInt ( ) ; int [ ] code = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) code [ index ] = readInt ( ) ; length = readInt ( ) ; Object [ ] constants = new Object [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { Object value = null ; int type = read ( ) ; switch ( type ) { case TYPE_NIL : break ; case TYPE_BOOLEAN : value = read ( ) != 0 ? boolean . true : boolean . false ; break ; case TYPE_NUMBER : value = double . longBitsToDouble ( readLong ( ) ) ; break ; case TYPE_STRING : value = readLuaString ( ) ; break ; default : throw new LuaException ( "Unknown constant type: " + type ) ; } constants [ index ] = value ; } length = readInt ( ) ; Prototype [ ] protos = new Prototype [ length ] ; for ( int index = 0 ; index < length ; index ++ ) protos [ index ] = load ( ) ; length = readInt ( ) ; int [ ] lines = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) lines [ index ] = readInt ( ) ; length = readInt ( ) ; LocalVar [ ] locals = new LocalVar [ length ] ; for ( int index = 0 ; index < length ; index ++ ) locals [ index ] = new LocalVar ( readLuaString ( ) , readInt ( ) , readInt ( ) ) ; length = readInt ( ) ; String [ ] upvalues = new String [ length ] ; for ( int index = 0 ; index < length ; index ++ ) upvalues [ index ] = readLuaString ( ) ; proto . code = code ; proto . constants = constants ; proto . prototypes = protos ; proto . lines = lines ; proto . locals = locals ; proto . upvalues = upvalues ; return proto ; }
tr	1	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	2	public static void test ( String s ) { String - ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { for ( int i = 1 ; i <= s . length ( ) - c ; i ++ ) { - = s . substring ( c , c + i ) ; System . out . println ( - ) ; } } }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	4X	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	1	private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c ==  || c ==  || excluded . indexOf ( c ) != - 1 ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
tr	3	public ArrayList < ArrayList < State >> printTrace ( String string , ArrayList < Automaton > disTA ) { String actions [ ] = string . split ( " " ) ; ArrayList < ArrayList < State >> states ; for ( ArrayList < State > state : startStates ) { states = new ArrayList < ArrayList < State >> ( ) ; ArrayList < State > searchState = state ; states . add ( searchState ) ; for ( String action : actions ) { boolean matchFound = false ; if ( adjList != null ) { Set < EdgeOfZoneGraph > edges = adjList . get ( searchState ) ; if ( edges != null ) { Iterator < EdgeOfZoneGraph > it = edges . iterator ( ) ; while ( it . hasNext ( ) ) { EdgeOfZoneGraph edge = ( EdgeOfZoneGraph ) it . next ( ) ; if ( edge . getAction ( ) . equals ( action ) ) { states . add ( edge . getEndState ( ) ) ; searchState = edge . getEndState ( ) ; matchFound = true ; break ; } } } } if ( ! matchFound ) { return null ; } } if ( isFinal ( states . get ( states . size ( ) - 1 ) , disTA ) ) { return states ; } } return null ; }
tr	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
tr	4X	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	3	public Card [ ] pickCards ( SelectCardOptions sco , Card [ ] allcards ) { GameQuery p = new GameQuery ( QueryType . GETCARD , QueryType . CARD ) . setObject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . CARD ) return null ; if ( p . o instanceof Card [ ] || p . o instanceof String [ ] ) { String [ ] selected ; if ( p . o instanceof Card [ ] ) { ArrayList < String > a = new ArrayList < String > ( ) ; for ( Card c : ( Card [ ] ) p . o ) a . add ( c . getName ( ) ) ; selected = a . toArray ( new String [ 0 ] ) ; } else selected = ( String [ ] ) p . o ; ArrayList < Card > ret = new ArrayList < Card > ( ) ; ArrayList < Card > all = new ArrayList < Card > ( Arrays . asList ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toArray ( new Card [ 0 ] ) ; } return null ; }
tr	2	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
tr	4X	public Contact [ ] resize ( int currentSize , Integer capacity , Contact [ ] c ) { Contact [ ] copy ; if ( capacity == null ) { int j = 0 ; while ( j < c . length ) { if ( c [ j ] == null ) break ; j ++ ; } copy = new Contact [ j ] ; for ( int i = 0 ; i < copy . length ; i ++ ) { copy [ i ] = c [ i ] ; } return copy ; } copy = new Contact [ capacity ] ; if ( capacity > currentSize ) { for ( int i = 0 ; i < currentSize ; i ++ ) { copy [ i ] = c [ i ] ; } } else { for ( int i = 0 ; i < capacity ; i ++ ) { copy [ i ] = c [ i ] ; } } return copy ; }
tr	3	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == Integer . MIN_VALUE && divisor == - 1 ) ) { return Integer . MAX_VALUE ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } while ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	0	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	3	public void checkCollision ( JGEngineInterface eng , int srccid , int dstcid ) { if ( in_parallel_upd ) throw new JGameError ( "Recursive call" , true ) ; in_parallel_upd = true ; if ( objects . size > srcobj . length ) { srcobj = new JGObject [ objects . size + 50 ] ; dstobj = new JGObject [ objects . size + 50 ] ; } int srcsize = 0 ; int dstsize = 0 ; JGRectangle sr = tmprect1 ; JGRectangle dr = tmprect2 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o . is_suspended ) continue ; if ( ! o . getBBox ( sr ) ) continue ; if ( ( o . colid & srccid ) != 0 ) { srcobj [ srcsize ++ ] = o ; } if ( ( o . colid & dstcid ) != 0 ) { dstobj [ dstsize ++ ] = o ; } } for ( int si = 0 ; si < srcsize ; si ++ ) { JGObject srco = srcobj [ si ] ; if ( ! srco . getBBox ( sr ) ) continue ; for ( int di = 0 ; di < dstsize ; di ++ ) { JGObject dsto = dstobj [ di ] ; if ( dsto == srco ) continue ; if ( ! dsto . getBBox ( dr ) ) continue ; if ( sr . intersects ( dr ) ) { try { dsto . hit ( srco ) ; } catch ( JGameError ex ) { eng . exitEngine ( eng . dbgExceptionToString ( ex ) ) ; } catch ( Exception ex ) { eng . dbgShowException ( dsto . getName ( ) , ex ) ; } } } } flushRemoveList ( ) ; in_parallel_upd = false ; }
tr	4X	public Administratorapp ( ) throws FileNotFoundException , IOException { int i ; BufferedReader fisier ; try { listModelSecretari = new DefaultListModel ( ) ; listModelProfesori = new DefaultListModel ( ) ; listModelElevi = new DefaultListModel ( ) ; fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Secretar" ) ) listModelSecretari . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Profesor" ) ) listModelProfesori . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } initComponents ( ) ; BufferedReader fisier2 = new BufferedReader ( new FileReader ( "clase" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier2 . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( int j = 0 ; j < vector . size ( ) ; j ++ ) clasaDeSters . addItem ( vector . get ( j ) ) ; BufferedReader fisier3 = new BufferedReader ( new FileReader ( "fmaterii" ) ) ; ArrayList < String > vector2 = new ArrayList < > ( ) ; for ( String line ; ( line = fisier3 . readLine ( ) ) != null ; ) { vector2 . add ( line ) ; } for ( int k = 0 ; k < vector . size ( ) ; k ++ ) materieDeSters . addItem ( vector2 . get ( k ) ) ; }
tr	3	private Collection < String > missingRequiredOptions ( OptionSet options ) { Collection < String > missingRequiredOptions = new HashSet < String > ( ) ; for ( AbstractOptionSpec < ? > each : recognizedOptions . toJavaUtilMap ( ) . values ( ) ) { if ( each . isRequired ( ) && ! options . has ( each ) ) missingRequiredOptions . addAll ( each . options ( ) ) ; } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredIf . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredUnless . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( ! optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } return missingRequiredOptions ; }
tr	3	public void activateCode ( ) { try { xmlFile = app . getFile ( ) ; Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; String string = rootNode . getChildText ( "compressedThingMap" ) ; byte [ ] byteArray = Base64 . decodeBase64 ( string . getBytes ( ) ) ; for ( int i = 0 ; i < byteArray . length ; i ++ ) { if ( byteArray [ i ] == 56 || byteArray [ i ] == 57 ) { byteArray [ i ] = 0 ; } } String newCMT = new String ( Base64 . encodeBase64 ( byteArray ) ) ; rootNode . getChild ( "compressedThingMap" ) . setText ( newCMT ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "def" ) ) ; List < Element > markedToBeRemoved = new ArrayList < Element > ( ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . getValue ( ) . equalsIgnoreCase ( "SandbagRubble" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthSand" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthDirt" ) || e . getValue ( ) . equalsIgnoreCase ( "DebrisSlag" ) || e . getValue ( ) . equalsIgnoreCase ( "RockRubble" ) ) { if ( e . getParentElement ( ) . getName ( ) . equalsIgnoreCase ( "thing" ) ) { markedToBeRemoved . add ( e . getParentElement ( ) ) ; } } } for ( int i = 0 ; i < markedToBeRemoved . size ( ) ; i ++ ) { Element e = markedToBeRemoved . get ( i ) ; e . getParentElement ( ) . removeContent ( e ) ; } Notification . createInfoNotification ( "All rubbish has been removed" , 3000 ) ; XMLOutputter xmlOutput = new XMLOutputter ( ) ; FileWriter fw = new FileWriter ( xmlFile ) ; xmlOutput . setFormat ( Format . getRawFormat ( ) ) ; xmlOutput . output ( doc , fw ) ; fw . flush ( ) ; fw . close ( ) ; app . setFile ( xmlFile ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
tr	2	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	2	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	3	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	4X	private JPanel createFillInTheBlanksQuestion ( ) { _questionLabel . setText ( _fillInTheBlanks . getAnswer ( ) ) ; final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _optionsStrings = _fillInTheBlanks . getBlanks ( ) ; final int [ ] randomList = MathUtilities . generateRandomArray ( _optionsStrings . size ( ) ) ; _answers = new ArrayList < String > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final String value = _optionsStrings . get ( randomList [ x ] ) ; _answers . add ( _optionsStrings . get ( _optionsStrings . indexOf ( value ) ) ) ; } _optionComboBoxes = new ArrayList < JComboBox > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final JLabel label = new JLabel ( "Choose #" ) ; final String choice = _optionsStrings . get ( randomList [ x ] ) . toLowerCase ( ) ; springLayout . putConstraint ( SpringLayout . WEST , label , 15 , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , label , 45 + x * 35 , SpringLayout . NORTH , jPanel ) ; jPanel . add ( label ) ; Object [ ] choices = new Object [ _optionsStrings . size ( ) + 1 ] ; choices [ 0 ] = "--" ; for ( int y = 0 ; y < choices . length - 1 ; y ++ ) { choices [ y + 1 ] = "[" + y + "]" ; } final JComboBox combobox = new JComboBox ( choices ) ; springLayout . putConstraint ( SpringLayout . WEST , combobox , 10 , SpringLayout . EAST , label ) ; springLayout . putConstraint ( SpringLayout . NORTH , combobox , - 20 , SpringLayout . SOUTH , label ) ; _optionComboBoxes . add ( combobox ) ; combobox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent arg0 ) { String question = "" ; if ( _choicesMade . containsKey ( choice ) ) { _choicesMade . remove ( choice ) ; } String begin = "Question #" + new Integer ( _questionData . getQuestionNumber ( ) ) . toString ( ) + ": " ; question = begin + _questionData . getQuestionString ( ) ; final Set < String > keys = _choicesMade . keySet ( ) ; for ( final String key : keys ) { question = replace ( _choicesMade . get ( key ) , question , key ) ; } final int indexToLookFor = combobox . getSelectedIndex ( ) - 1 ; if ( indexToLookFor >= 0 ) { _choicesMade . put ( choice , "[" + indexToLookFor + "]" ) ; question = replace ( "[" + indexToLookFor + "]" , question , choice ) ; } _beginLabel . setText ( question ) ; } private String replace ( final String needle , final String haystack , final String newNeedle ) { String result = haystack ; while ( result . indexOf ( needle ) != - 1 ) { result = result . replace ( needle , newNeedle ) ; } return result ; } } ) ; jPanel . add ( combobox ) ; final JLabel option = new JLabel ( choice ) ; springLayout . putConstraint ( SpringLayout . WEST , option , 10 , SpringLayout . EAST , combobox ) ; springLayout . putConstraint ( SpringLayout . NORTH , option , 1 , SpringLayout . NORTH , combobox ) ; jPanel . add ( option ) ; } final JLabel temp = new JLabel ( ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , 600 , SpringLayout . WEST , temp ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , 250 , SpringLayout . SOUTH , temp ) ; jPanel . setOpaque ( true ) ; return jPanel ; }
tr	2	public static void merge ( int [ ] a , int [ ] aux , int lo , int mid , int hi ) { assert isSorted ( a , lo , mid ) ; assert isSorted ( a , mid + 1 , hi ) ; for ( int k = lo ; k <= hi ; k ++ ) aux [ k ] = a [ k ] ; int i = lo , j = mid + 1 ; for ( int k = lo ; k <= hi ; k ++ ) { if ( i > mid ) { a [ k ] = aux [ j ++ ] ; } else if ( j > hi ) { a [ k ] = aux [ i ++ ] ; } else if ( less ( aux [ j ] , aux [ i ] ) ) { a [ k ] = aux [ j ++ ] ; } else { a [ k ] = aux [ i ++ ] ; } } assert isSorted ( a , lo , hi ) ; }
tr	3	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
tr	2	public void initRandom ( Random random , int maxValue ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { int v = random . nextInt ( maxValue + 1 ) ; setValue ( x , y , v ) ; } } }
tr	0	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	0	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	4X	private void updateEstimatedParameters ( ) { for ( int k = 0 ; k < K ; k ++ ) { for ( int t = 0 ; t < V ; t ++ ) { phi [ k ] [ t ] = ( nkt [ k ] [ t ] + beta ) / ( nktSum [ k ] + V * beta ) ; } } for ( int m = 0 ; m < M ; m ++ ) { for ( int k = 0 ; k < K ; k ++ ) { theta [ m ] [ k ] = ( nmk [ m ] [ k ] + alpha ) / ( nmkSum [ m ] + K * alpha ) ; } } }
tr	3	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	4X	private static String [ ] split ( String document , String regex , String fileName ) { int min = 50 * 1024 ; int max = 50 * 1024 ; int bodyStart = document . indexOf ( "<body>" ) + "<body>" . length ( ) ; int bodyEnd = document . indexOf ( "</body>" ) ; List < Integer > breaks = new ArrayList < Integer > ( ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( document ) ; int start = bodyStart ; breaks . add ( bodyStart ) ; while ( matcher . find ( start ) ) { int prev = breaks . get ( breaks . size ( ) - 1 ) ; int cur = matcher . start ( ) ; if ( cur - prev > min ) { breaks . add ( matcher . start ( ) ) ; } start = matcher . end ( ) ; } breaks . add ( bodyEnd ) ; List < String > docs = new ArrayList < String > ( ) ; int currStart = bodyStart ; int numBreak = 0 ; List < String > opened = new ArrayList < String > ( ) ; while ( numBreak < breaks . size ( ) ) { int nextBreak = breaks . get ( numBreak ) ; if ( nextBreak - currStart >= max ) { String doc = document . substring ( currStart , nextBreak ) ; if ( doc . startsWith ( "<hr />" ) ) { doc = doc . substring ( "<hr />" . length ( ) ) ; } String open = "" ; for ( String tag : opened ) { open += "<" + tag + ">" ; } doc = open + doc ; opened . clear ( ) ; computeTags ( doc , opened ) ; List < String > rev = new ArrayList < String > ( opened ) ; Collections . reverse ( rev ) ; for ( String tag : rev ) { doc += "</" + tag + ">" ; } doc = document . substring ( 0 , bodyStart ) + doc + "</body></html>" ; docs . add ( doc ) ; currStart = nextBreak ; } numBreak ++ ; } Map < String , Integer > refs = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; Matcher idMatcher = Pattern . compile ( " id=\"([^\"]*)\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { String name = idMatcher . group ( 1 ) ; refs . put ( name , i ) ; idStart = idMatcher . end ( ) ; } } String baseName = new File ( fileName ) . getName ( ) ; baseName = baseName . substring ( 0 , baseName . lastIndexOf ( . ) ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; StringBuilder newDoc = new StringBuilder ( ) ; Matcher idMatcher = Pattern . compile ( " href=\"(#([^\"]*))\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { newDoc . append ( doc . substring ( idStart , idMatcher . start ( 1 ) ) ) ; Integer docIndex = refs . get ( idMatcher . group ( 2 ) ) ; if ( docIndex != null && docIndex . intValue ( ) != i ) { newDoc . append ( baseName + ".p" + toDigits ( docIndex ) + ".html#" + idMatcher . group ( 2 ) ) ; } else { newDoc . append ( "#" + idMatcher . group ( 2 ) ) ; } idStart = idMatcher . end ( 1 ) ; } newDoc . append ( doc . substring ( idStart , doc . length ( ) ) ) ; docs . set ( i , newDoc . toString ( ) ) ; } return docs . toArray ( new String [ docs . size ( ) ] ) ; }
tr	1	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	4X	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	0	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	1	public void clearFeedback ( ) { for ( ValueSource vs : valueSources ) { vs . clearFeedback ( ) ; } }
tr	0	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	1	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
tr	1	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	0	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	3	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	3	private void notifyClientsDeviceRemoved ( String [ ] deviceNames ) { for ( int h = 0 ; h < deviceNames . length ; h ++ ) { String deviceName = deviceNames [ h ] ; String message = "<delProperty device=\"" + deviceName + "\" />" ; ArrayList < INDIDeviceListener > list = this . getClientsListeningToDevice ( deviceName ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { INDIDeviceListener c = list . get ( i ) ; c . sendXMLMessage ( message ) ; } ArrayList < INDIDeviceListener > list2 = this . getClientsListeningToSingleProperties ( deviceName ) ; for ( int i = 0 ; i < list2 . size ( ) ; i ++ ) { INDIDeviceListener c = list2 . get ( i ) ; c . sendXMLMessage ( message ) ; } } }
tr	0	public Client ( String dni , String nom , String cognoms , String email ) { this . dni = dni ; this . nom = nom ; this . cognoms = cognoms ; this . email = email ; }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	3	public void drawComponents ( BufferedImage canvas , boolean drawCorner ) { if ( _components == null ) findComponents ( ) ; BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < _width ; x ++ ) for ( int y = 0 ; y < _height ; y ++ ) image . setRGB ( x , y , ffffff ) ; for ( ConnectedComponent cc : _components ) cc . draw ( image , true , drawCorner ) ; canvas . createGraphics ( ) . drawImage ( image , 0 , 0 , null ) ; }
tr	3	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	3	final public CreateTableCommand CreateTable_suffix ( ) throws ParseException { String tableName ; List < CreateTableCommand . AttributeDescriptor > attributeDescriptors = new ArrayList < CreateTableCommand . AttributeDescriptor > ( ) ; List < String > primaryKeyAttrNames = new ArrayList < String > ( ) ; List < CreateTableCommand . ForeignKeyDescriptor > foreignKeyDescriptors = new ArrayList < CreateTableCommand . ForeignKeyDescriptor > ( ) ; CreateTableCommand . AttributeDescriptor attributeDescriptor ; CreateTableCommand . ForeignKeyDescriptor foreignKeyDescriptor ; String name ; jj_consume_token ( KW_TABLE ) ; tableName = Identifier ( ) ; jj_consume_token ( 52 ) ; label_2 : while ( true ) { attributeDescriptor = AttrDecl ( ) ; jj_consume_token ( 51 ) ; attributeDescriptors . add ( attributeDescriptor ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : ; break ; default : jj_la1 [ 6 ] = jj_gen ; break label_2 ; } } jj_consume_token ( KW_PRIMARY ) ; jj_consume_token ( KW_KEY ) ; jj_consume_token ( 52 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; label_3 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 7 ] = jj_gen ; break label_3 ; } jj_consume_token ( 51 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; } jj_consume_token ( 53 ) ; label_4 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 8 ] = jj_gen ; break label_4 ; } jj_consume_token ( 51 ) ; foreignKeyDescriptor = ForeignKeyDecl ( ) ; foreignKeyDescriptors . add ( foreignKeyDescriptor ) ; } jj_consume_token ( 53 ) ; { if ( true ) return new CreateTableCommand ( token , tableName , attributeDescriptors , primaryKeyAttrNames , foreignKeyDescriptors ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	3	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	1	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	4X	public static < KEY , VALUE > Map < KEY , VALUE > runIdempotentTasks ( Collection < ? extends IDependentTask < KEY , VALUE >> tasks , ExecutorService es , int maxRounds ) throws Exception { final Map < KEY , VALUE > out = new HashMap < KEY , VALUE > ( ) ; Map < KEY , IDependentTask < KEY , VALUE >> allTasks = new HashMap < KEY , MraUtils . IDependentTask < KEY , VALUE >> ( ) ; for ( IDependentTask < KEY , VALUE > t : tasks ) { allTasks . put ( t . getTaskID ( ) , t ) ; } Set < KEY > remaining = new HashSet < KEY > ( allTasks . keySet ( ) ) ; Set < KEY > done = new HashSet < KEY > ( ) ; Map < KEY , Integer > failures = new HashMap < KEY , Integer > ( ) ; while ( remaining . size ( ) > 0 ) { Set < KEY > toRun = new HashSet < KEY > ( ) ; for ( KEY k : remaining ) { if ( done . containsAll ( allTasks . get ( k ) . getDependsOn ( ) ) ) { toRun . add ( k ) ; } } if ( toRun . size ( ) == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } Map < KEY , Future < VALUE >> futures = new HashMap < KEY , Future < VALUE >> ( ) ; int submitted = 0 ; for ( KEY k : toRun ) { final IDependentTask < KEY , VALUE > t = allTasks . get ( k ) ; boolean block = false ; if ( failures . containsKey ( k ) ) { if ( failures . get ( k ) > maxRounds ) { block = true ; } } if ( ! block ) { submitted ++ ; futures . put ( k , es . submit ( new Callable < VALUE > ( ) { @ Override public VALUE call ( ) throws Exception { return t . call ( out ) ; } } ) ) ; } } if ( submitted == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } for ( KEY k : futures . keySet ( ) ) { try { out . put ( k , futures . get ( k ) . get ( ) ) ; done . add ( k ) ; } catch ( Exception e ) { if ( failures . containsKey ( k ) ) { failures . put ( k , failures . get ( k ) + 1 ) ; } else { failures . put ( k , 1 ) ; } logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } remaining . removeAll ( done ) ; } return out ; }
tr	2	private static < T > void removeDuplicatesBuffer ( Node < T > list ) { if ( list == null ) { throw new IllegalArgumentException ( ) ; } Set < T > unique = new HashSet < T > ( ) ; unique . add ( list . getData ( ) ) ; while ( list . getNext ( ) != null ) { Node < T > current = list ; while ( unique . contains ( current . getNext ( ) . getData ( ) ) ) { current = current . getNext ( ) ; } unique . add ( current . getNext ( ) . getData ( ) ) ; list . setNext ( current . getNext ( ) ) ; list = list . getNext ( ) ; } }
tr	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
tr	4X	private static void saveSystemState ( String filename ) { String out = getParameterValueList ( ) + "\n" ; out += "Changed per state \n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( systemStateChangeds != null ) { for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += systemStateChangeds . get ( systemTestType ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( lastSystemTestPoints != null ) for ( String s : lastSystemTestPoints . keySet ( ) ) { out += "\t" + s + "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Mayority" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Confidence" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Weight" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Missfire" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\n" ; } File f = new File ( filename ) ; try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; FileWriter w = new FileWriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ScienceTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	4X	private boolean r_Step_1a ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_1 , 6 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "ss" ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; if ( cursor > limit_backward ) { break lab1 ; } slice_from ( "ie" ) ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; slice_from ( "i" ) ; } while ( false ) ; break ; case 3 : if ( cursor <= limit_backward ) { return false ; } cursor -- ; golab2 : while ( true ) { lab3 : do { if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } slice_del ( ) ; break ; } return true ; }
tr	1	public boolean method537 ( ) { if ( anIntArray658 == null ) return true ; boolean flag = true ; for ( int j = 0 ; j < anIntArray658 . length ; j ++ ) if ( ! Model . method463 ( anIntArray658 [ j ] ) ) flag = false ; return flag ; }
tr	3	public final BlockContext block ( ) throws RecognitionException { BlockContext _localctx = new BlockContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 10 , RULE_block ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 94 ) ; match ( { ) ; setState ( 98 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( _la == TIPO ) { { { setState ( 95 ) ; var_decl ( ) ; } } setState ( 100 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 104 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( ( ( ( _la ) & ~ 3f ) == 0 && ( ( 1 << _la ) & ( ( 1 << if ) | ( 1 << for ) | ( 1 << return ) | ( 1 << break ) | ( 1 << continue ) | ( 1 << CALLOUT ) | ( 1 << { ) | ( 1 << ID ) ) ) != 0 ) ) { { { setState ( 101 ) ; statement ( ) ; } } setState ( 106 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 107 ) ; match ( } ) ; linea ++ ; arbol . add ( "Bloque " + linea ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	2	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
tr	1	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	2	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	3	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	2	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
tr	3	@ Test public void testLinearAssociator ( ) throws Exception { EvaluationManager evaluationManager = new EvaluationManager ( ) ; evaluationManager . setDataSet ( dataSet ) ; evaluationManager . setAlgorithm ( new LinearAssociator ( ) ) ; evaluationManager . setValidationMethod ( new LeaveOneOutValidation ( ) ) ; evaluationManager . evaluate ( ) ; for ( EvaluationMetric metric : evaluationManager . getMetrics ( ) ) { if ( metric instanceof BasicsMetric ) { System . out . println ( "\nTPR" ) ; double [ ] tpr = ( ( BasicsMetric ) metric ) . getTpr ( ) ; for ( double s : tpr ) { System . out . printf ( "%.3f\n" , s ) ; } System . out . println ( "\nFPR" ) ; double [ ] fpr = ( ( BasicsMetric ) metric ) . getFpr ( ) ; for ( double s : fpr ) { System . out . printf ( "%.3f\n" , s ) ; } } } }
tr	0	public String getFirstName ( ) { return firstName ; }
tr	4X	public Matrix solve ( Matrix B ) { if ( B . getRowDimension ( ) != m ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if ( ! this . isNonsingular ( ) ) { throw new RuntimeException ( "Matrix is singular." ) ; } int nx = B . getColumnDimension ( ) ; Matrix Xmat = B . getMatrix ( piv , 0 , nx - 1 ) ; double [ ] [ ] X = Xmat . getArray ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ k ] [ j ] /= LU [ k ] [ k ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } return Xmat ; }
tr	3	private void updateDataTableTimeKeeping ( int n , int month , int year ) { Object [ ] [ ] objData = new Object [ n ] [ ] ; Object [ ] objColumn = new Object [ ] { "Working" , "Date" } ; int day ; String date ; if ( currentEmployee != null ) { Contract correctContract = currentEmployee . searchCorrespondingContract ( year , month ) ; if ( correctContract != null ) { TimeKeepingBook keepBook = correctContract . getTimeKeeping ( ) ; if ( keepBook != null ) { TimeKeepingSheet keepSheet = keepBook . get ( month , year ) ; if ( keepSheet == null ) { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } else { for ( int i = 0 ; i < keepSheet . size ( ) ; i ++ ) { TimeKeepingDetailInfo infor = keepSheet . get ( i ) ; day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( infor . getIsWorking ( ) ) , date } ; objData [ i ] = objValue ; } } } } } else { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } timeKeepingBookFrame . getTableModelTimeKeeping ( ) . setDataVector ( objData , objColumn ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellRenderer ( new MyTableCellRenderer ( ) ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellEditor ( new MyTableCellEditor ( ) ) ; }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	0	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	3	public void addNodes ( ArrayList < BusLabel > busesLabel , ArrayList < StationLabel > stationsLabel , ArrayList < SemaphoreLabel > semaphoresLabel , int num ) { int iconHeightMid = 0 ; int iconWidthMid = 0 ; int iconHeight = 0 ; int iconWidth = 0 ; if ( num == 1 ) { removeAll ( ) ; } for ( BusLabel busLabel : busesLabel ) { iconHeight = busLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = busLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; busLabel . setBounds ( busLabel . getX ( ) - iconWidthMid , BUSES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( busLabel ) ; } for ( SemaphoreLabel semaphoreLabel : semaphoresLabel ) { iconHeight = semaphoreLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = semaphoreLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; if ( semaphoreLabel . getBounds ( ) . y > 100 ) { System . out . println ( semaphoreLabel . getSemaphore ( ) . getId ( ) ) ; } semaphoreLabel . setBounds ( semaphoreLabel . getX ( ) - iconWidthMid , SEMAPHORES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( semaphoreLabel ) ; } for ( StationLabel stationLabel : stationsLabel ) { iconHeight = stationLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = stationLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; stationLabel . setBounds ( stationLabel . getX ( ) - iconWidthMid , STATIONS_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( stationLabel ) ; } repaint ( ) ; }
tr	4X	private static void Merge ( int [ ] data , int left , int center , int right ) { int [ ] tmpArr = new int [ data . length ] ; int mid = center + 1 ; int index = left ; int tmp = left ; while ( left <= center && mid <= right ) { if ( data [ left ] <= data [ mid ] ) { tmpArr [ index ++ ] = data [ left ++ ] ; } else { tmpArr [ index ++ ] = data [ mid ++ ] ; } } while ( mid <= right ) { tmpArr [ index ++ ] = data [ mid ++ ] ; } while ( left <= center ) { tmpArr [ index ++ ] = data [ left ++ ] ; } while ( tmp <= right ) { data [ tmp ] = tmpArr [ tmp ++ ] ; } }
tr	4X	public static ArrayList < ArrayList < Integer >> fourSum ( int [ ] num , int target ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; Arrays . sort ( num ) ; for ( int i = 0 ; i <= num . length - 4 ; i ++ ) { if ( i > 0 && num [ i ] == num [ i - 1 ] ) continue ; for ( int j = i + 1 ; j <= num . length - 3 ; j ++ ) { if ( j > i + 1 && num [ j ] == num [ j - 1 ] ) continue ; int l = j + 1 ; int r = num . length - 1 ; while ( l < r ) { int sum = num [ i ] + num [ j ] + num [ l ] + num [ r ] - target ; if ( sum > 0 ) { r -- ; } else if ( sum < 0 ) { l ++ ; } else { ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; newList . add ( num [ i ] ) ; newList . add ( num [ j ] ) ; newList . add ( num [ l ] ) ; newList . add ( num [ r ] ) ; result . add ( newList ) ; l ++ ; r -- ; while ( l < r && num [ l ] == num [ l - 1 ] ) { l ++ ; } while ( l < r && num [ r ] == num [ r + 1 ] ) { r -- ; } } } } } return result ; }
tr	2	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	3	public static Object [ ] commandsForAgentAndBoxToField ( Level l , Agent agent , Box box , Field agentFromField , ArrayList < Node > nodesAgentCanEndIn , Field boxToField , ArrayList < Box > boxesToIgnore , DockTask taskDock ) { if ( boxesToIgnore == null ) { boxesToIgnore = new ArrayList < Box > ( ) ; boxesToIgnore . add ( box ) ; } ArrayList < Field > pathToGuideBoxAlong = new ArrayList < Field > ( taskDock . path ) ; Collections . reverse ( pathToGuideBoxAlong ) ; Field boxFromField = box . atField ; dir boxDir = null ; GoalSequenceNode root = new GoalSequenceNode ( boxFromField , agentFromField , null ) ; root . g = 0 ; root . w = 0 ; root . h = pathToGuideBoxAlong . size ( ) - 1 ; root . f = root . g + root . w + root . h ; Queue < GoalSequenceNode > queue = new PriorityQueue < GoalSequenceNode > ( ) ; HashMap < Field , ArrayList < Field >> closedSet = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( boxFromField ) ; closedSet . put ( agentFromField , tempList ) ; queue . add ( root ) ; GoalSequenceNode currentNode = queue . poll ( ) ; while ( currentNode != null ) { if ( currentNode . boxLocation == boxToField ) { if ( nodesAgentCanEndIn == null || nodesAgentCanEndIn . contains ( currentNode . agentLocation ) ) { break ; } } boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > possibleBoxCommands = possibleBoxCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation , boxesToIgnore ) ; for ( Command command : possibleBoxCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( closedSet . containsKey ( agentLocation ) ) { if ( closedSet . get ( agentLocation ) . contains ( boxLocation ) ) { continue ; } else { closedSet . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; closedSet . put ( agentLocation , tempListe ) ; } GoalSequenceNode node = new GoalSequenceNode ( boxLocation , agentLocation , command ) ; node . parent = currentNode ; node . g = node . parent . g + 1 ; node . w = ( command . weight ) ? 15 : 0 ; if ( node . parent . h - 1 >= 0 && pathToGuideBoxAlong . get ( node . parent . h - 1 ) == node . boxLocation ) { node . h = node . parent . h - 1 ; } else { node . h = node . parent . h ; } node . f = node . g + node . w + node . h ; queue . add ( node ) ; } if ( queue . isEmpty ( ) ) { System . err . println ( "CRY" ) ; return null ; } currentNode = queue . poll ( ) ; } Field agentMoveTo = currentNode . agentLocation ; LinkedList < Command > commands = new LinkedList < Command > ( ) ; LinkedList < Field > fieldsUsed = new LinkedList < Field > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; fieldsUsed . add ( currentNode . agentLocation ) ; fieldsUsed . add ( currentNode . boxLocation ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; Collections . reverse ( fieldsUsed ) ; LinkedHashSet < Field > fieldsUsedSet = new LinkedHashSet < Field > ( fieldsUsed ) ; ArrayList < Field > fieldsUsedList = new ArrayList < Field > ( fieldsUsedSet ) ; return new Object [ ] { commands , fieldsUsedList , agentMoveTo } ; }
tr	4X	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	3	public void testMapAllNodesAndLinks ( ) { for ( Request request : requests ) { Mapping mapping = mapper . map ( request , substrateNetwork ) ; if ( mapping != null ) { for ( VirtualNode virtualNode : request . getVirtualNodes ( ) . values ( ) ) { assertTrue ( mapping . isNodeMapped ( virtualNode ) ) ; } for ( VirtualLink virtualLink : request . getVirtualLinks ( ) . values ( ) ) { assertTrue ( mapping . isLinkMapped ( virtualLink ) ) ; } } } }
tr	1	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
tr	2	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	3	public static void main ( String [ ] args ) { try { FieldFileReader reader = new FieldFileReader ( "./data/problem022.input.txt" , " " ) ; int row = 0 ; String [ ] fields = reader . readFields ( ) ; Arrays . sort ( fields ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { fields [ i ] = fields [ i ] . replaceAll ( "\"" , "" ) . toLowerCase ( ) ; } long total = 0 ; for ( int i = 0 ; i < fields . length ; i ++ ) { final int idx = ( i + 1 ) ; final String name = fields [ i ] ; int score = 0 ; for ( char c : name . toCharArray ( ) ) { final int val = ( int ) ( c - a ) + 1 ; score += val ; } total += ( long ) ( score * idx ) ; System . out . println ( idx + "\t" + fields [ i ] + "\t" + score * idx ) ; } System . out . println ( "# total of scores = " + total ) ; } catch ( Exception ex ) { Logger . getLogger ( Problem018 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	0	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	1	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	2	public void printInfo ( ) { System . out . println ( "Arithmos Xeirourgiwn :" + NumberOrSyrgeries ) ; for ( int i = 0 ; i <= tepRooms . size ( ) ; i ++ ) System . out . println ( "Dwmatio :" + tepRooms . get ( i ) ) ; for ( int i = 0 ; i <= tepSurgeries . size ( ) ; i ++ ) System . out . println ( "Xeirourgio :" + tepSurgeries . get ( i ) ) ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	2	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	2	public static void create ( String [ ] args ) { Vector < vslFileDataChunk > chunks = null ; if ( args . length < 3 ) { System . err . println ( "Missings args: create <dbfile> <source>" ) ; System . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkFile ( source ) ; vslDataType < vslFileDataChunk > fileData = new vslDataType < vslFileDataChunk > ( ) ; StringTokenizer st = new StringTokenizer ( source , "/" ) ; String fname = "UNSET" ; while ( st . hasMoreTokens ( ) ) { fname = st . nextToken ( ) ; } fileData . setName ( fname ) ; for ( vslFileDataChunk chunk : chunks ) { fileData . addNewChunk ( chunk ) ; } core . addEntry ( fileData ) ; core . debugShow ( ) ; core . save ( ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	1	public static long readLong ( byte [ ] b , int start ) { long l = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { l <<= 8 ; l |= b [ start + i ] & ff ; } return l ; }
tr	4X	public String SimplifyPath ( String path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charAt ( 0 ) != / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) == / ) start ++ ; if ( start == pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) == / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
tr	4X	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	2	public String collectAndReset ( String timeStamp ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "<" ) . append ( name ) . append ( ">" ) ; double mean ; double dispersion ; for ( Map . Entry < String , Map < String , double >> entry : mappedValues . entrySet ( ) ) { mean = getMean ( entry . getValue ( ) ) ; dispersion = getDispersion ( entry . getValue ( ) , mean ) ; sb . append ( "<" ) . append ( entry . getKey ( ) ) ; sb . append ( " mean=\"" ) . append ( mean ) ; sb . append ( "\" disp=\"" ) . append ( dispersion ) . append ( "\"/>" ) ; } sb . append ( "</" ) . append ( name ) . append ( ">" ) ; for ( Map < String , double > innerObservation : mappedValues . values ( ) ) { innerObservation . clear ( ) ; } mappedValues . clear ( ) ; return sb . toString ( ) ; }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	1	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	3	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	4X	public void testFetchGroupsForUser ( ) { Group [ ] groups = ga . fetchGroupsForUser ( 1 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 2 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 3 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 1 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 1 ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 5 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 2 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 2 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 2 ] . isIsactive ( ) ) ; } }
tr	3	public void clickActionListener ( final JButton btn ) { btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { for ( int i = 0 ; i < suggestedButtonsNames . length ; i ++ ) if ( existingBoats . contains ( suggestedButtonsNames [ i ] ) ) { System . out . println ( "Ne mozes postaviti brod na to polje!" ) ; return ; } int sifraBroda = workingFrame . updateLabels ( ) ; if ( ( sifraBroda ) != - 1 ) { for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) { if ( myButtonGameBoard [ i ] [ j ] . isBorderPainted ( ) ) { existingBoats . add ( myButtonGameBoard [ i ] [ j ] . getName ( ) ) ; myButtonGameBoard [ i ] [ j ] . setIcon ( shipImage ) ; gameBoardMask . FillStartMatrix ( i , j , sifraBroda ) ; } } } gameBoardMask . ispisi ( ) ; logicMatrix = gameBoardMask . gameBoard ; } } ) ; }
tr	2	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	1	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	4X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	4X	public static void invert ( double src [ ] [ ] , double dst [ ] [ ] ) { gaussian ( src , a ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) b [ i ] [ i ] = i == j ? 1 : 0 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = i + 1 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) b [ index [ j ] ] [ k ] -= a [ index [ j ] ] [ i ] * b [ index [ i ] ] [ k ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dst [ 4 - 1 ] [ i ] = b [ index [ 4 - 1 ] ] [ i ] / a [ index [ 4 - 1 ] ] [ 4 - 1 ] ; for ( int j = 2 ; j >= 0 ; j -- ) { dst [ j ] [ i ] = b [ index [ j ] ] [ i ] ; for ( int k = j + 1 ; k < 4 ; k ++ ) dst [ j ] [ i ] -= a [ index [ j ] ] [ k ] * dst [ k ] [ i ] ; dst [ j ] [ i ] /= a [ index [ j ] ] [ j ] ; } } }
tr	2	@ Override public String toString ( ) { String s = "Vertices: " + V + " Edges: " + E + "\n" ; for ( int i = 0 ; i < V ; i ++ ) { s += i + ": " ; for ( int w : adj ( i ) ) s += w + " " ; s += "\n" ; } return s ; }
tr	4X	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ 2000000 ] ; for ( int i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; int a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primeList . add ( a ) ; break ; } } long sum = 0 ; for ( int i = 0 ; i < primeList . size ( ) - 1 ; i ++ ) sum += lowestMultiple ( primeList . get ( i ) , primeList . get ( i + 1 ) ) ; System . out . println ( sum ) ; }
tr	2	private static List < List < String >> clone ( List < List < String >> original ) { List < List < String >> clone = new ArrayList < List < String >> ( original . size ( ) ) ; for ( List < String > oStrings : original ) { List < String > cStrings = new ArrayList < String > ( oStrings . size ( ) ) ; for ( String oString : oStrings ) { cStrings . add ( oString ) ; } clone . add ( cStrings ) ; } return clone ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	4X	@ Override public Map < StatsType , LongSummaryStatistics > call ( ) throws IOException { final LongSummaryStatistics initTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics symbolTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics decTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics totalDecsStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics numDecFailsStats = new LongSummaryStatistics ( totalDecsStats ) ; final LongSummaryStatistics decFailTimeStats = new LongSummaryStatistics ( ) ; final ByteBuffer dataHeaderBuf = DataHeader . allocateNewBuffer ( ) ; final ByteBuffer symbolHeaderBuf = SymbolHeader . allocateNewBuffer ( ) ; for ( int n = 0 ; n < numIterations ; n ++ ) { dataHeaderBuf . clear ( ) ; readBytes ( dataHeaderBuf ) ; final DataHeader dataHeader = DataHeader . parseDataHeader ( dataHeaderBuf ) ; final FECParameters fecParams = dataHeader . getFECParams ( ) ; final int extraSymbols = dataHeader . getExtraSymbols ( ) ; final ByteBuffer symbolBuf = ByteBuffer . allocate ( fecParams . symbolSize ( ) ) ; final ArrayDataDecoder dataDec = initDataDecoder ( fecParams , extraSymbols , initTimeStats ) ; final int Z = dataDec . numberOfSourceBlocks ( ) ; for ( int sbn = 0 ; sbn < Z ; sbn ++ ) { final SourceBlockDecoder srcBlockDec = dataDec . decoderForSourceBlock ( sbn ) ; final int totalSymbols = srcBlockDec . numberOfSourceSymbols ( ) + extraSymbols ; for ( int i = 0 ; i < totalSymbols ; ) { symbolHeaderBuf . clear ( ) ; readBytes ( symbolHeaderBuf ) ; final SymbolHeader symbolHeader = SymbolHeader . parseSymbolHeader ( symbolHeaderBuf , fecParams , sbn ) ; final int firstESI = symbolHeader . getFECPayloadID ( ) . encodingSymbolID ( ) ; final int numSymbolsInPacket = symbolHeader . getNumSymbols ( ) ; for ( int s = 0 ; s < numSymbolsInPacket ; s ++ ) { symbolBuf . clear ( ) ; readBytes ( symbolBuf ) ; putSymbol ( srcBlockDec , firstESI + s , symbolBuf , symbolTimeStats , decTimeStats , decFailTimeStats , totalDecsStats , numDecFailsStats ) ; } i += numSymbolsInPacket ; } } checkData ( dataDec ) ; } final EnumMap < StatsType , LongSummaryStatistics > map = new EnumMap < > ( StatsType . class ) ; map . put ( StatsType . DECODER_INIT_TIME , initTimeStats ) ; map . put ( StatsType . SYMBOL_INPUT_TIME , symbolTimeStats ) ; map . put ( StatsType . DECODING_TIME , decTimeStats ) ; map . put ( StatsType . NUM_DECODING_FAILURES , numDecFailsStats ) ; if ( numDecFailsStats . getCount ( ) > 0 ) { map . put ( StatsType . DECODING_FAILURE_TIME , decFailTimeStats ) ; } return map ; }
tr	1	private static char [ ] reverse ( char [ ] a , int len ) { char [ ] b = new char [ len ] ; for ( int i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { b [ j ] = a [ i ] ; } return b ; }
tr	3	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
tr	4X	public final double nextGaussian ( ) { if ( __haveNextNextGaussian ) { __haveNextNextGaussian = false ; return __nextNextGaussian ; } else { double v1 , v2 , s ; do { int y ; int z ; int a ; int b ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } z = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; mti = 0 ; } z = mt [ mti ++ ] ; z ^= z >>> 11 ; z ^= ( z << 7 ) & TEMPERING_MASK_B ; z ^= ( z << 15 ) & TEMPERING_MASK_C ; z ^= ( z >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } a = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; mti = 0 ; } a = mt [ mti ++ ] ; a ^= a >>> 11 ; a ^= ( a << 7 ) & TEMPERING_MASK_B ; a ^= ( a << 15 ) & TEMPERING_MASK_C ; a ^= ( a >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } b = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; mti = 0 ; } b = mt [ mti ++ ] ; b ^= b >>> 11 ; b ^= ( b << 7 ) & TEMPERING_MASK_B ; b ^= ( b << 15 ) & TEMPERING_MASK_C ; b ^= ( b >>> 18 ) ; v1 = 2 * ( ( ( ( ( long ) ( y >>> 6 ) ) << 27 ) + ( z >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; v2 = 2 * ( ( ( ( ( long ) ( a >>> 6 ) ) << 27 ) + ( b >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s >= 1 || s == 0 ) ; double multiplier = StrictMath . sqrt ( - 2 * StrictMath . log ( s ) / s ) ; __nextNextGaussian = v2 * multiplier ; __haveNextNextGaussian = true ; return v1 * multiplier ; } }
tr	0	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	4X	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
tr	2	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	4X	private static void testInteger ( Map < Integer , Integer > m ) { m . clear ( ) ; try { m . add ( null , 1 ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } try { m . add ( 1 , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } begin ( "zero" ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; assertExpected ( "remove" , null , m . remove ( 1 ) ) ; end ( ) ; begin ( "one" ) ; begin ( "add" ) ; assertExpected ( "add" , null , m . add ( 1 , 2 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; begin ( "replace" ) ; assertExpected ( "add" , 2 , m . add ( 1 , 3 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 3 , m . get ( 1 ) ) ; end ( ) ; begin ( "remove" ) ; assertExpected ( "remove" , 3 , m . remove ( 1 ) ) ; assertFalse ( "contains" , m . contains ( 1 ) ) ; assertTrue ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 0 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; end ( ) ; end ( ) ; begin ( "add many" ) ; int size = 1000 ; m . clear ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "add " + i + " " + ( i + 1 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 1 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 1 , m . get ( i ) ) ; end ( ) ; begin ( "replace " + i + " " + ( i + 2 ) ) ; assertExpected ( "add" , i + 1 , m . add ( i , i + 2 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 2 , m . get ( i ) ) ; end ( ) ; begin ( "remove " + i + " " + ( i + 2 ) ) ; assertExpected ( "remove" , i + 2 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; begin ( "add again " + i + " " + ( i + 3 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } end ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "check many " + i + " " + ( i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { begin ( "remove many asc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == size , m . empty ( ) ) ; assertExpected ( "size" , size - i , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { m . add ( i , i + 3 ) ; } for ( int i = size ; i >= 1 ; -- i ) { begin ( "remove many desc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } begin ( "add one remove many" ) ; m . clear ( ) ; m . add ( 1 , 2 ) ; for ( int i = 1 ; i <= 50 ; ++ i ) { m . remove ( 2 ) ; } assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; }
tr	3	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	1	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
tr	2	private static boolean hasAccess ( IGraph g , IGraph access ) { for ( int i = 0 ; i < g . size ( ) ; i ++ ) { for ( int j = 0 ; j < access . size ( ) ; j ++ ) { String a = g . get ( i ) . getName ( ) ; String b = access . get ( j ) . getName ( ) ; if ( a . equals ( b ) ) return true ; } } return false ; }
tr	4X	protected void downloadJars ( String path ) throws Exception { File versionFile = new File ( path , "md5s" ) ; Properties md5s = new Properties ( ) ; if ( versionFile . exists ( ) ) { try { FileInputStream fis = new FileInputStream ( versionFile ) ; md5s . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } state = 4 ; int [ ] fileSizes = new int [ urlList . length ] ; boolean [ ] skip = new boolean [ urlList . length ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; urlconnection . setDefaultUseCaches ( false ) ; skip [ i ] = false ; if ( ( urlconnection instanceof HttpURLConnection ) ) { ( ( HttpURLConnection ) urlconnection ) . setRequestMethod ( "HEAD" ) ; int code = ( ( HttpURLConnection ) urlconnection ) . getResponseCode ( ) ; if ( code / 100 == 3 ) { skip [ i ] = true ; } } fileSizes [ i ] = urlconnection . getContentLength ( ) ; totalSizeDownload += fileSizes [ i ] ; } int initialPercentage = this . percentage = 10 ; byte [ ] buffer = new byte [ 65536 ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { if ( skip [ i ] != false ) { percentage = ( initialPercentage + fileSizes [ i ] * 45 / totalSizeDownload ) ; } boolean downloadFile = true ; while ( downloadFile ) { downloadFile = false ; URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; String etag = "" ; if ( ( urlconnection instanceof HttpURLConnection ) ) { urlconnection . setRequestProperty ( "Cache-Control" , "no-cache" ) ; urlconnection . connect ( ) ; etag = urlconnection . getHeaderField ( "ETag" ) ; } String currentFile = getFileName ( urlList [ i ] ) ; InputStream inputstream = getJarInputStream ( currentFile , urlconnection ) ; FileOutputStream fos = new FileOutputStream ( path + currentFile ) ; long downloadStartTime = System . currentTimeMillis ( ) ; int downloadedAmount = 0 ; int fileSize = 0 ; String downloadSpeedMessage = "" ; MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; int bufferSize ; while ( ( bufferSize = inputstream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bufferSize ) ; m . update ( buffer , 0 , bufferSize ) ; currentSizeDownload += bufferSize ; fileSize += bufferSize ; percentage = ( initialPercentage + currentSizeDownload * 45 / totalSizeDownload ) ; subtaskMessage = ( "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%" ) ; downloadedAmount += bufferSize ; long timeLapse = System . currentTimeMillis ( ) - downloadStartTime ; if ( timeLapse >= 1000 ) { float downloadSpeed = downloadedAmount / ( float ) timeLapse ; downloadSpeed = ( int ) ( downloadSpeed * 100.0F ) / 100.0F ; downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec" ; downloadedAmount = 0 ; downloadStartTime += 1000 ; } subtaskMessage += downloadSpeedMessage ; } inputstream . close ( ) ; fos . close ( ) ; } } }
tr	2	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	4X	public ModelEnvelope ( BufferedReader reader , boolean server ) throws IOException { modelBuff = new HashMap < String , TransferableModel > ( ) ; this . server = server ; String line = reader . readLine ( ) ; if ( line == null ) throw new EOFException ( "Expected envelope header got EOF" ) ; if ( ! line . equals ( ENVELOPE_HEADER ) ) throw new IOException ( "Expected envelope header  found " + line ) ; int numModels = Integer . parseInt ( reader . readLine ( ) ) ; countModels = Integer . parseInt ( reader . readLine ( ) ) ; TransferableModel [ ] list = new TransferableModel [ numModels ] ; newFlags = new boolean [ countModels ] ; try { for ( int i = 0 ; i < numModels ; i ++ ) { String name = reader . readLine ( ) , umid = reader . readLine ( ) ; list [ i ] = createModel ( name , reader , server ) ; if ( ! umid . equals ( "" ) ) { modelBuff . put ( umid , list [ i ] ) ; } } } catch ( IOException e ) { while ( ! reader . readLine ( ) . equals ( ENVELOPE_FOOTER ) ) ; throw new IOException ( "Exception reading model" , e ) ; } if ( ! ( line = reader . readLine ( ) ) . equals ( ENVELOPE_FOOTER ) ) { throw new IOException ( "Expected envelope footer line  got " + line ) ; } for ( int i = 0 ; i < list . length ; i ++ ) { list [ i ] . registerSubModels ( this ) ; if ( ( numModels - i ) <= countModels ) newFlags [ countModels - ( numModels - i ) ] = ModelCacher . containsKey ( list [ i ] . getUMID ( ) ) ; list [ i ] = ModelCacher . cache ( list [ i ] ) ; } models = new Stack < TransferableModel > ( ) ; modelUMIDs = new HashSet < String > ( ) ; for ( int i = list . length - 1 ; i >= list . length - countModels ; i -- ) { models . push ( list [ i ] ) ; modelUMIDs . add ( list [ i ] . getUMID ( ) ) ; } }
tr	1	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	2	@ Override public void dispose ( ) { for ( ObjectMap < String , Object > entry : data . values ( ) ) { for ( Object resource : entry . values ( ) ) { if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } }
tr	0	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	3	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
tr	0	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	3	public int largestRectangleArea2 ( int [ ] height ) { if ( height == null || height . length == 0 ) return 0 ; int max = 0 ; int i = 0 ; while ( i < height . length ) { int k = i ; while ( k < height . length - 1 ) { if ( height [ k ] > height [ k + 1 ] ) { break ; } k ++ ; } i = k ; int lowest = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { lowest = Math . min ( lowest , height [ j ] ) ; int val = ( i - j + 1 ) * lowest ; max = Math . max ( max , val ) ; } i ++ ; } return max ; }
tr	4X	public TrainingSet ( String line ) { String [ ] values = line . split ( " " ) ; int [ ] [ ] startBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { startBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + 2 ] . trim ( ) ) ; } } int readOffset = 2 + GameOfLife . HEIGHT * GameOfLife . WIDTH ; int [ ] [ ] endBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { endBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + readOffset ] . trim ( ) ) ; } } this . startBoard = new Board ( startBoard ) ; this . endBoard = new Board ( endBoard ) ; this . id = Integer . parseInt ( values [ 0 ] ) ; this . delta = Integer . parseInt ( values [ 1 ] ) ; }
tr	4X	public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setStroke ( new BasicStroke ( 6 ) ) ; BufferedImage bimg = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2img = ( Graphics2D ) bimg . getGraphics ( ) ; g2img . setColor ( Color . black ) ; g2img . fillRect ( 0 , 0 , bimg . getWidth ( ) , bimg . getHeight ( ) ) ; HexMech . setCorner ( corner ) ; for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( i , j , g2img ) ; } } if ( corner . x > 0 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x - 1 , j , g2img ) ; } } if ( corner . y > 0 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y - 1 , g2img ) ; } } if ( corner . x < LocationManager . getSize ( ) . x - 15 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x + 15 , j , g2img ) ; } } if ( corner . y < LocationManager . getSize ( ) . y - 10 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y + 10 , g2img ) ; } } for ( Point p : selectLocs ) { HexMech . selectHex ( p . x , p . y , g2img ) ; } HexMech . cursor ( cursorLoc . x , cursorLoc . y , g2img ) ; g2 . drawImage ( bimg , 0 , 0 , null ) ; }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	4X	public void addStaffInfo ( Vector < StaffInfo > staff , JTextField [ ] staffTF , JList positionList , JList qualificationList , String hospitalList , JTable table ) { DB . db . openConnection ( ) ; try { int posid = - 1 ; int qualid = - 1 ; int hospId = - 1 ; String [ ] tmp = new String [ staffTF . length ] ; for ( int i = 0 ; i < staffTF . length ; i ++ ) { tmp [ i ] = staffTF [ i ] . getText ( ) ; } if ( positionList == null || qualificationList == null ) { throw new Exception ( ) ; } String login = JOptionPane . showInputDialog ( "Enter desired login" ) ; String password = null ; JPasswordField passwordField = new JPasswordField ( ) ; passwordField . setEchoChar ( * ) ; Object [ ] obj = { "Please enter the password:\n\n" , passwordField } ; Object stringArray [ ] = { "OK" , "Cancel" } ; if ( JOptionPane . showOptionDialog ( null , obj , "Desired password" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , stringArray , obj ) == JOptionPane . YES_OPTION ) { password = new String ( passwordField . getPassword ( ) ) ; } ResultSet rs = DB . db . position ( positionList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { posid = rs . getInt ( "id" ) ; } rs = DB . db . qualification ( qualificationList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { qualid = rs . getInt ( "id" ) ; } Auth t = new Auth ( login , password ) ; DB . db . addStaff ( tmp , qualid , posid , t . getLogin ( ) , t . getPasswHash ( ) ) ; DB . db . close ( ) ; staff . removeAllElements ( ) ; this . fillStaff ( ( Vector < T > ) staff ) ; rs = ( ResultSet ) DB . db . hospital ( hospitalList ) ; while ( rs . next ( ) ) { hospId = rs . getInt ( "id" ) ; } for ( int i = 0 ; i < 7 ; i ++ ) { DB . db . editStaffHospitalSchedual ( staff . lastElement ( ) . getId ( ) , hospId , table . getValueAt ( i , 0 ) , table . getValueAt ( i , 1 ) , table . getValueAt ( i , 2 ) ) ; } DB . db . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } }
tr	1	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	4X	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
tr	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
tr	1	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	2	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	1	public ActionDialog ( SkyQuestUtility util , JComponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new JButton ( "Save" ) ; cancel = new JButton ( "Cancel" ) ; amodel = new DefaultListModel < ActionType > ( ) ; atypes = new JList < ActionType > ( amodel ) ; for ( ActionType a : QuestManager . getInstance ( ) . getRegisteredActionTypes ( ) ) amodel . addElement ( a ) ; setLayout ( new BorderLayout ( ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; JPanel ap = new JPanel ( ) ; ap . setLayout ( new BorderLayout ( ) ) ; ap . add ( "Center" , atypes ) ; ap . add ( "North" , new JLabel ( "Type" ) ) ; add ( "South" , buttons ) ; cancel . addActionListener ( this ) ; save . addActionListener ( this ) ; }
tr	1	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	0	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	4X	public static String getResultXMLString ( SimulationFinalResult result ) { if ( result == null ) { return "" ; } StringBuilder xml = new StringBuilder ( ) ; xml . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>" ) . append ( LINE_END ) . append ( "<simulation>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<playercount>" ) . append ( result . getNrOfPlayers ( ) ) . append ( "</playercount>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<rounds>" ) . append ( result . getRounds ( ) ) . append ( "</rounds>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<type>" ) . append ( result . getPokerType ( ) . toString ( ) ) . append ( "</type>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<threads>" ) . append ( result . getNrOfThreads ( ) ) . append ( "</threads>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<duration unit=\"milliseconds\">" ) . append ( result . getDuration ( ) ) . append ( "</duration>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "</meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<players>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) ; PlayerProfile profile = result . getPlayer ( i - 1 ) ; xml . append ( "<handtype>" ) ; xml . append ( profile . getHandType ( ) . toString ( ) ) ; xml . append ( "</handtype>" ) ; xml . append ( LINE_END ) ; if ( profile . getHandType ( ) == HandType . EXACTCARDS ) { Card [ ] cards = profile . getCards ( ) ; for ( Card card : cards ) { xml . append ( getNestingCharacters ( 3 ) ) . append ( "<card>" ) . append ( card . toString ( ) ) . append ( "</card>" ) . append ( LINE_END ) ; } } else if ( profile . getHandType ( ) == HandType . RANGE ) { Range range = profile . getRange ( ) ; for ( int row = 0 ; row < 13 ; row ++ ) { for ( int col = 0 ; col < 13 ; col ++ ) { if ( range . getValue ( row , col ) ) { xml . append ( getNestingCharacters ( 3 ) ) ; xml . append ( "<cardtype>" ) ; xml . append ( Range . rangeNames [ row ] [ col ] ) ; xml . append ( "</cardtype>" ) ; xml . append ( LINE_END ) ; } } } } xml . append ( getNestingCharacters ( 2 ) ) ; xml . append ( "</player>" ) ; xml . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "</players>" ) ; xml . append ( LINE_END ) ; Card [ ] flop = result . getFlop ( ) ; Card turn = result . getTurn ( ) ; Card river = result . getRiver ( ) ; if ( flop != null || turn != null || river != null ) { xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "<community>" ) ; xml . append ( LINE_END ) ; if ( flop != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"1\">" ) . append ( flop [ 0 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"2\">" ) . append ( flop [ 1 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"3\">" ) . append ( flop [ 2 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) ; } if ( turn != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<turn>" ) . append ( turn . toString ( ) ) . append ( "</turn>" ) . append ( LINE_END ) ; } if ( river != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<river>" ) . append ( river . toString ( ) ) . append ( "</river>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</community>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "<result>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<wins>" ) . append ( result . getFormattedWinPercentage ( i - 1 ) ) . append ( "</wins>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<loses>" ) . append ( result . getFormattedLosePercentage ( i - 1 ) ) . append ( "</loses>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<ties>" ) . append ( result . getFormattedTiePercentage ( i - 1 ) ) . append ( "</ties>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "</player>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</result>" ) . append ( LINE_END ) . append ( "</simulation>" ) ; return xml . toString ( ) ; }
tr	2	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	1	public static byte [ ] decompress ( byte [ ] data ) throws IOException , DataFormatException { Inflater inflater = new Inflater ( ) ; inflater . setInput ( data ) ; inflater . finished ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputStream . write ( buffer , 0 , count ) ; } outputStream . close ( ) ; byte [ ] output = outputStream . toByteArray ( ) ; inflater . end ( ) ; return output ; }
tr	2	public Matrix getU ( ) { Matrix X = new Matrix ( n , n ) ; double [ ] [ ] U = X . getArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i <= j ) { U [ i ] [ j ] = LU [ i ] [ j ] ; } else { U [ i ] [ j ] = 0.0 ; } } } return X ; }
tr	4X	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	2	public double getDistanceAB ( ArrayList < Object > path ) { ArrayList < Object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new ArrayList < Object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( Road road : roads ) { if ( road . getNodesAttached ( ) . containsAll ( nodes ) ) { distance += road . getDistance ( ) ; } } } distance = UtilCalc . round ( distance , 2 ) ; return distance ; }
tr	4X	public void PatientDocFile ( JPanel ptPane , int loggedId ) { staffid = loggedId ; StringBuffer loggedUser = new StringBuffer ( ) ; JTextPane tpLoggedStaff = new JTextPane ( ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getId ( ) == loggedId ) { loggedUser . append ( "<b>" + staff . get ( i ) . getLname ( ) ) ; loggedUser . append ( "  " ) ; loggedUser . append ( staff . get ( i ) . getFname ( ) + "</b>" ) ; if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "gp" ) ) loggedUser . append ( "  [logged as Dr.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ns" ) ) loggedUser . append ( "  [logged as R.N.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ma" ) ) loggedUser . append ( "  [logged as Med.As.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "mo" ) ) loggedUser . append ( "  [logged as Med.Of.]" ) ; } } tpLoggedStaff . setContentType ( "text/html" ) ; tpLoggedStaff . setText ( loggedUser . toString ( ) ) ; this . function . setOpacity ( tpLoggedStaff ) ; tpLoggedStaff . setEditable ( false ) ; patientList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; function . makeElementWithBorder ( patientList , "Patients" , Color . GRAY , false ) ; patientList . setOpaque ( false ) ; patientList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; patientList . setSelectedIndex ( 0 ) ; patientList . setVisibleRowCount ( 3 ) ; function . makeElementWithBorder ( testList , "Tests" , Color . GRAY , false ) ; testList . setOpaque ( false ) ; testList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; testList . setSelectedIndex ( 0 ) ; testList . setVisibleRowCount ( 3 ) ; this . patientListSP = new JScrollPane ( this . patientList ) ; this . function . setOpacity ( this . patientListSP ) ; patientListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; this . testListSP = new JScrollPane ( this . testList ) ; this . function . setOpacity ( this . testListSP ) ; testListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; JScrollPane [ ] patientSP = new JScrollPane [ patientTP . length ] ; JScrollPane testSP = new JScrollPane ( this . testTP ) ; function . makeElementWithBorder ( testSP , "Test Results" , Color . DARK_GRAY , false ) ; testSP . setVisible ( true ) ; this . function . setOpacity ( testTP ) ; this . function . setOpacity ( testSP ) ; testTP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; final JTextPane timeTP = new JTextPane ( ) ; timeTP . setContentType ( "text/html" ) ; timeTP . setPreferredSize ( new Dimension ( 20 , 15 ) ) ; timeTP . setEditable ( false ) ; timeTP . setOpaque ( false ) ; timeTP . setBorder ( null ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( "EEEEE  MMMMM d  yyyy | h:mm:ss a" ) ; new javax . swing . Timer ( 1000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Calendar date = Calendar . getInstance ( ) ; timeTP . setText ( "<b>" + dateFormat . format ( date . getTime ( ) ) + "</b>" ) ; } } ) . start ( ) ; String [ ] lb1 = { "Patient's General Information" , "Patient's Prescriptions" , "Patient's Anamnesis" , "Patient's Diagnosis" } ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { patientTP [ i ] = new JTextPane ( ) ; patientTP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; patientSP [ i ] = new JScrollPane ( patientTP [ i ] ) ; this . function . setOpacity ( this . patientTP [ i ] ) ; this . function . setOpacity ( patientSP [ i ] ) ; patientSP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; function . makeElementWithBorder ( patientSP [ i ] , lb1 [ i ] , Color . DARK_GRAY , false ) ; patientSP [ i ] . setVisible ( true ) ; } String [ ] lb = { "Patient" , "Patient's birth date" } ; patientTF = new JTextField [ lb . length ] ; for ( int i = 0 ; i < lb . length ; i ++ ) { patientTF [ i ] = new JTextField ( 15 ) ; function . makeElementWithBorder ( patientTF [ i ] , lb [ i ] , Color . DARK_GRAY , false ) ; patientTF [ i ] . setOpaque ( false ) ; } patientTF [ 1 ] . setPreferredSize ( new Dimension ( 80 , 40 ) ) ; ptPane . add ( timeTP , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( tpLoggedStaff , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . NORTHWEST , GridBagConstraints . BOTH , new Insets ( 50 , 15 , 0 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 0 ] , new GridBagConstraints ( 1 , 0 , 2 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 1 ] , new GridBagConstraints ( 3 , 0 , 2 , 1 , 0.2 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientListSP , new GridBagConstraints ( 4 , 1 , 1 , 3 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( testListSP , new GridBagConstraints ( 4 , 4 , 1 , 1 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; int pozY = 1 ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { ptPane . add ( patientSP [ i ] , new GridBagConstraints ( 0 , pozY , 4 , 2 , 0.5 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 5 , 5 , 5 , 5 ) , 0 , 0 ) ) ; pozY += 2 ; } ptPane . add ( testSP , new GridBagConstraints ( 4 , 5 , 1 , 4 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 55 , 15 ) , 0 , 0 ) ) ; this . nextB . setText ( "Next" ) ; this . nextB . addActionListener ( this ) ; ptPane . add ( nextB , new GridBagConstraints ( 4 , 8 , 1 , 1 , 0 , 0.5 , GridBagConstraints . SOUTH , GridBagConstraints . NONE , new Insets ( 0 , 15 , 5 , 15 ) , 0 , 0 ) ) ; new javax . swing . Timer ( 500000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { function . fillPatient ( patient ) ; patientTP [ 0 ] . setText ( null ) ; } } ) . start ( ) ; patientTF [ 0 ] . addKeyListener ( this ) ; patientList . addListSelectionListener ( this ) ; testList . addListSelectionListener ( this ) ; }
tr	2	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	2	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	2	private static byte [ ] constructorValueHelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
tr	4X	private void getScaleFactors_2 ( int gr , int ch ) { byte [ ] nr ; int i , band , slen , num , n = 0 , scf = 0 ; final boolean i_stereo = header . isIntensityStereo ( ) ; final ChannelInformation ci = channelInfo [ gr ] [ ch ] ; final int [ ] l = scalefacLong [ ch ] ; final int [ ] s = scalefacShort [ ch ] ; rzeroBandLong = 0 ; if ( ( ch > 0 ) && i_stereo ) slen = i_slen2 [ ci . scalefac_compress >> 1 ] ; else slen = n_slen2 [ ci . scalefac_compress ] ; ci . preflag = ( slen >> 15 ) & 1 ; ci . part2_length = 0 ; if ( ci . block_type == 2 ) { n ++ ; if ( ( ci . mixed_block_flag ) != 0 ) n ++ ; nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) s [ scf ++ ] = 0 ; } else { nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) l [ scf ++ ] = 0 ; } }
tr	3	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	2	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
tr	3	public static Method getAsMethodOfPublicBase ( class < ? > c , Method m ) { for ( class < ? > iface : c . getInterfaces ( ) ) { for ( Method im : iface . getMethods ( ) ) { if ( isMatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getSuperclass ( ) ; if ( sc == null ) { return null ; } for ( Method scm : sc . getMethods ( ) ) { if ( isMatch ( scm , m ) ) { return scm ; } } return getAsMethodOfPublicBase ( sc , m ) ; }
tr	2	private static final long [ ] mk_tokenSet_1 ( ) { long [ ] data = new long [ 260 ] ; data [ 0 ] = - 9224 ; for ( int i = 1 ; i <= 3 ; i ++ ) { data [ i ] = - 1 ; } for ( int i = 64 ; i <= 127 ; i ++ ) { data [ i ] = - 1 ; } return data ; }
tr	3	public static void benchmark ( ) throws Exception { int N = 10000 ; String [ ] methodsToCompare = { "approxSort1" , "approxSort2" } ; int k = 10 ; int [ ] arr = new int [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { arr [ i ] = ( int ) ( i * 1000 + Math . floor ( Math . random ( ) * 100 ) ) ; int offset = ( int ) ( Math . floor ( Math . random ( ) * 2 * k ) - k ) ; if ( i + offset > 0 && i + offset < arr . length ) { swap ( arr , i , i + offset ) ; } } for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.ten.Problem10_06" ) ; Method method = clazz . getDeclaredMethod ( methodName , int [ ] . class , int . class ) ; double totalTime = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrClone = arr . clone ( ) ; long startTime = System . nanoTime ( ) ; method . invoke ( null , arrClone , k ) ; long endTime = System . nanoTime ( ) ; totalTime += ( endTime - startTime ) / 1000000000.0 ; } System . out . println ( "Elapsed time for " + methodName + ": " + totalTime + " seconds" ) ; } }
tr	3	public static void normalize ( final SampleSet set , final double [ ] mean , final double [ ] stddev , final int ... idxs ) { if ( set . size ( ) == 0 ) return ; final int inputsize = set . get ( 0 ) . getInputSize ( ) ; for ( Sample sample : set ) { final double [ ] input = sample . getInput ( ) ; int offset = 0 ; for ( int s = 0 ; s < sample . getInputLength ( ) ; s ++ ) { for ( int i = 0 ; i < idxs . length ; i ++ ) { final int idx = idxs [ i ] ; final double x = input [ offset + idx ] ; input [ offset + idx ] = ( ( x - mean [ idx ] ) / stddev [ idx ] ) ; } offset += inputsize ; } } }
tr	3	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	0	public Prenotazione ( ) { super ( ) ; }
tr	4X	public void blendDraw ( Bitmap b , int xp , int yp , int col ) { xp += xOffs ; yp += yOffs ; int x0 = xp ; int x1 = xp + b . w ; int y0 = yp ; int y1 = yp + b . h ; if ( x0 < 0 ) x0 = 0 ; if ( y0 < 0 ) y0 = 0 ; if ( x1 > w ) x1 = w ; if ( y1 > h ) y1 = h ; if ( xFlip ) { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w + xp + b . w - 1 ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp - x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp - x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } else { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w - xp ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp + x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp + x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } }
tr	0	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	3	public void booking ( ) { int movieCode ; int showTime_index ; String seats ; Movie movie ; ShowTime showTime = null ; MovieGoer movieGoer ; boolean tryAgain ; do { tryAgain = false ; System . out . println ( ) ; System . out . print ( "Please enter movie code (-1 to go back) : " ) ; movieCode = ConsoleReader . readIntInput ( ) ; if ( movieCode == - 1 ) { return ; } movie = movieBL . getMovie ( movieCode ) ; if ( movie == null ) { tryAgain = true ; System . out . println ( "Invalid Movie Code. Try again." ) ; System . out . println ( ) ; } } while ( tryAgain ) ; printMovieInfo ( movie ) ; do { tryAgain = false ; System . out . print ( "Please select showtime (the number between '[ ]') (-1 to go back) : " ) ; showTime_index = ConsoleReader . readIntInput ( ) ; if ( showTime_index == - 1 ) { return ; } if ( showTime_index < 1 || showTime_index > _showTimes . size ( ) ) { tryAgain = true ; System . out . println ( "Invalid number. Try again." ) ; } else { showTime = _showTimes . get ( showTime_index - 1 ) ; if ( showTimeBL . isFullyBooked ( showTime ) ) { System . out . println ( ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( "| We're sorry  the selected session is sold out. Please pick another one! |" ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( ) ; tryAgain = true ; continue ; } printSeats ( showTime ) ; } } while ( tryAgain ) ; boolean isValidSeatNos ; do { System . out . print ( "Please enter seat no. (e.g. G1 G2 ...) : " ) ; seats = ConsoleReader . readSeatNumbers ( ) ; String [ ] _seats = seats . split ( " " ) ; isValidSeatNos = seatBL . validateSeatNumbers ( showTime , _seats ) ; if ( ! isValidSeatNos ) { System . out . println ( "Invalid seat numbers. Please choose again." ) ; } else if ( _seats . length > 10 ) { System . out . println ( "You cannot book more than 10 tickets per transaction. Please select seats again." ) ; isValidSeatNos = false ; } System . out . println ( ) ; } while ( ! isValidSeatNos ) ; String movieGoerName ; String movieGoerMobileNo ; String movieGoerEmail ; Date dateOfBirth = null ; System . out . println ( ) ; System . out . println ( "Please Enter Your Details" ) ; System . out . println ( "=========================" ) ; System . out . print ( "Name : " ) ; movieGoerName = ConsoleReader . readString ( ) ; System . out . print ( "Date of Birth (DD/MM/YYYY) : " ) ; dateOfBirth = ConsoleReader . readDateInput ( ) ; System . out . print ( "Email : " ) ; movieGoerEmail = ConsoleReader . readString ( ) ; System . out . print ( "Mobile No : " ) ; movieGoerMobileNo = ConsoleReader . readString ( ) ; movieGoer = movieGoerBL . createMovieGoer ( movieGoerName , movieGoerEmail , movieGoerMobileNo , dateOfBirth ) ; printBookingSummary ( showTime , movieGoer , seats ) ; }
tr	0	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	2	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	2	private static void horizLeftRight ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int row = 0 ; row < 6 ; row ++ ) { for ( int col = 0 ; col < 4 ; col ++ ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 2 , row ) . getState ( ) == 0 ) ) { if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 1 ) ; } if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == player2Color ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } } } } }
tr	3	public String toString ( ) { String str = "" ; if ( frameData != null ) { for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { String st = "" ; for ( int f = 0 ; f < frameData . length ; f ++ ) if ( frameData [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + frameData [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pauseData . length ; f ++ ) if ( pauseData [ f ] ) str += " " + f ; } return str ; }
tr	2	private static void player1DoSwapPieces ( OthelloPiece piecesToSwap [ ] [ ] ) { for ( int i = 0 ; i < TOTALWIDTH ; i ++ ) { for ( int j = 0 ; j < TOTALHEIGHT ; j ++ ) { if ( piecesToSwap [ i ] [ j ] == null ) { } else { player1SwapPieces ( i , j ) ; } } } }
tr	1	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
tr	4X	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	3	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
tr	2	@ Test public void testTwoDimensionalArrays ( ) { final int rows = 3 ; final int cols = 4 ; int count = 0 ; int [ ] [ ] matrix = new int [ rows ] [ cols ] ; for ( int row = 0 ; row < rows ; row ++ ) { for ( int col = 0 ; col < cols ; col ++ ) { matrix [ row ] [ col ] = count ++ ; } } assertEquals ( 11 , matrix [ 2 ] [ 3 ] ) ; assertEquals ( 6 , matrix [ 1 ] [ 2 ] ) ; }
tr	1	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	4X	public int [ ] compute ( int source ) { ZippedArray arr = ZippedArray . arrayWithDefaultValue ( 1000 ) ; int n = graph . getVerticesCount ( ) ; arr . set ( 0 , 0 , source ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { int oldValue = ( Integer ) arr . get ( i - 1 , v ) ; int minValue = Integer . MAX_VALUE ; List < Edge > edges = graph . getEdgesTo ( v ) ; for ( Edge edge : edges ) { int x = edge . getX ( ) ; int w = edge . getWeight ( ) ; int t = ( Integer ) arr . get ( i - 1 , x ) + w ; if ( t < minValue ) minValue = t ; } arr . set ( Math . min ( oldValue , minValue ) , i , v ) ; } } int [ ] result = new int [ graph . getVerticesCount ( ) ] ; for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { result [ i ] = ( Integer ) arr . get ( n - 1 , i ) ; } return result ; }
tr	1	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	3	public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) { change = false ; for ( n = all ( ) ; n . hasMoreElements ( ) ; ) { nt = ( non_terminal ) n . nextElement ( ) ; for ( p = nt . productions ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; prod_first = prod . check_first_set ( ) ; if ( ! prod_first . is_subset_of ( nt . _first_set ) ) { change = true ; nt . _first_set . add ( prod_first ) ; } } } } }
tr	3	public void DesativaCampos ( ) { for ( Component c : tela . getjPFicha ( ) . getComponents ( ) ) { if ( c instanceof JComboBox ) { ( ( JComboBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JCheckBox ) { ( ( JCheckBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JTextField ) { ( ( JTextField ) c ) . setEnabled ( false ) ; } if ( c instanceof JDateChooser ) { ( ( JDateChooser ) c ) . setEnabled ( false ) ; } if ( c instanceof JScrollPane ) { for ( Component co : ( ( JScrollPane ) c ) . getComponents ( ) ) { if ( co instanceof JViewport ) { for ( Component com : ( ( JViewport ) co ) . getComponents ( ) ) { if ( com instanceof JTextArea ) { ( ( JTextArea ) com ) . setEnabled ( false ) ; } } } } } } }
tr	3	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
tr	1	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	2	public static void benchmark ( ) throws Exception { int N = 100000 ; String [ ] methodsToCompare = { "canWriteLetterFromMagazine1" , "canWriteLetterFromMagazine2" , "canWriteLetterFromMagazine3" , "canWriteLetterFromMagazine4" , "canWriteLetterFromMagazine5" , "canWriteLetterFromMagazine6" , "canWriteLetterFromMagazine7" } ; String magazine = cleanInput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; String letter = cleanInput ( "hogs are swine" ) ; for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.twelve.Problem12_09" ) ; Method method = clazz . getDeclaredMethod ( methodName , String . class , String . class ) ; long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean retVal = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retVal == false ) throw new Exception ( "wrong result!" ) ; } long endTime = System . nanoTime ( ) ; System . out . println ( "Elapsed time for " + methodName + ": " + ( endTime - startTime ) / 1000000000.0 + " seconds" ) ; } }
tr	3	public static QuestionCalculation decode ( String encodedQuestionCalculation ) throws DecodeException { QuestionCalculation res ; if ( encodedQuestionCalculation . substring ( 0 , 19 ) . compareTo ( "#QuestionCalculaion" ) == 0 ) { res = new QuestionCalculation ( ) ; int i = 19 ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Integer > tmp_opd = decodeOperands ( encodedQuestionCalculation . substring ( 20 , i ) ) ; res . setOperands ( tmp_opd ) ; i ++ ; int beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Character > tmp_opt = decodeOperators ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_opt . size ( ) == tmp_opt . size ( ) + 1 : "incorrect size of operators table" ; res . setOperators ( tmp_opt ) ; i ++ ; beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } int tmp_lth = Integer . valueOf ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_lth < 0 : "negative length" ; res . setLength ( tmp_lth ) ; i ++ ; encodedQuestionCalculation = encodedQuestionCalculation . substring ( i ) ; Question . decode ( res , encodedQuestionCalculation ) ; } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	2	public Vector < Vector < Object >> getFolderContentsTable ( ) { Vector < Vector < Object >> tableData = new Vector < > ( ) ; List < FileInfo > files = getFolderContents ( ) ; logger . debug ( "Found " + files . size ( ) + " entries for " + path . toString ( ) ) ; for ( FileInfo file : files ) { Vector < Object > row = null ; if ( file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/folder.png" ) ) ; } else { row . add ( new ImageIcon ( "res/folder_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } for ( FileInfo file : files ) { Vector < Object > row = null ; if ( ! file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/file.png" ) ) ; } else { row . add ( new ImageIcon ( "res/file_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } return tableData ; }
tr	2	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	3	public static boolean canWriteLetterFromMagazine5 ( String letter , String magazine ) { int [ ] magazineCharCounts = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { magazineCharCounts [ i ] = 0 ; } char [ ] letterCharArray = letter . toCharArray ( ) ; char [ ] magazineCharArray = magazine . toCharArray ( ) ; for ( int i = 0 ; i < magazineCharArray . length ; i ++ ) { char chr = magazineCharArray [ i ] ; magazineCharCounts [ chr - a ] ++ ; } for ( int i = 0 ; i < letterCharArray . length ; i ++ ) { char chr = letterCharArray [ i ] ; if ( -- magazineCharCounts [ chr - a ] < 0 ) return false ; } return true ; }
tr	2	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
tr	0	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	1	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	2	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
tr	4X	@ SuppressWarnings ( "unchecked" ) public List < JZSequenceFile > partition ( List < String > inputFiles , int numPartitions , Comparator < K > comparator , String jobTaskTrackerID ) { final Comparator < K > tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( ( K ) o1 [ 0 ] , ( K ) o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < inputFiles . size ( ) ; i ++ ) { JZSequenceFile file = new JZSequenceFile ( JZFile . LocalFileSystem , inputFiles . get ( i ) , 0 , 0 ) ; inFiles . add ( file ) ; JZSequenceFile . Reader < K , List < V >> reader = new JZSequenceFile . Reader < > ( file ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } List < JZSequenceFile > outFiles = new ArrayList < JZSequenceFile > ( ) ; List < JZSequenceFile . Writer < K , List < V >>> writers = new ArrayList < JZSequenceFile . Writer < K , List < V >>> ( ) ; for ( int i = 0 ; i < numPartitions ; i ++ ) { String fileName = createPartitionFileName ( jobTaskTrackerID , i ) ; JZSequenceFile file = new JZSequenceFile ( JZFile . JZFileSystem , fileName , 0 , 0 ) ; outFiles . add ( file ) ; writers . add ( new JZSequenceFile . Writer < K , List < V >> ( file ) ) ; } List < V > list = new ArrayList < V > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; K preKey = ( K ) firstEntry [ 0 ] ; JZSequenceFile . Reader < K , List < V >> reader = ( JZSequenceFile . Reader < K , List < V >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; K key = ( K ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < K , List < V >> ) entry [ 1 ] ; List < V > value = ( List < V > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < V > ( value ) ; } if ( reader . nextKeyValue ( ) ) { K newKey = ( K ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } for ( int i = 0 ; i < numPartitions ; i ++ ) { writers . get ( i ) . close ( ) ; } return outFiles ; }
tr	3	@ Override public float [ ] getFloatData ( float [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { float [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new float [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) Utilities . UNSAFE . getInt ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ ( int ) i ] ; } } } return out ; } }
tr	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
tr	0	public int process_id ( ) { return 2 ; }
tr	2	public void seek_notify ( ) { frame_start = 0 ; for ( int ch = 0 ; ch < 2 ; ch ++ ) for ( int j = 0 ; j < 576 ; j ++ ) prevblck [ ch ] [ j ] = 0.0f ; br = new BitReserve ( ) ; }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	2	public static final void initialize ( ) { slowSlaves = new SlaveThread [ NB_SLOWSLAVES ] ; fastSlaves = new SlaveThread [ NB_FASTSLAVES ] ; for ( int i = 0 ; i < NB_SLOWSLAVES ; i ++ ) { slowSlaves [ i ] = new SlaveThread ( ) ; slowSlaves [ i ] . start ( ) ; } for ( int i = 0 ; i < NB_FASTSLAVES ; i ++ ) { fastSlaves [ i ] = new SlaveThread ( ) ; fastSlaves [ i ] . start ( ) ; } indexSlow = 0 ; indexFast = 0 ; }
tr	0	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	0	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	1	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	4X	public Geometry patch ( int m , int n , double basisMatrix [ ] [ ] , double data [ ] ) { newRectangularMesh ( m + 2 , n + 2 ) ; faces = new int [ m * n ] [ 4 ] ; for ( int k = 1 ; k < n + 1 ; k ++ ) for ( int j = 1 ; j < m + 1 ; j ++ ) { int f = ( k - 1 ) * m + j - 1 ; int v = k * ( m + 3 ) + j ; faces [ f ] [ 0 ] = v ; faces [ f ] [ 1 ] = v + 1 ; faces [ f ] [ 2 ] = v + m + 3 + 1 ; faces [ f ] [ 3 ] = v + m + 3 ; } double G [ ] [ ] [ ] = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) G [ k ] [ i ] [ j ] = data [ 12 * i + 3 * j + k ] ; Coefs = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int k = 0 ; k < 3 ; k ++ ) constructBicubicCoefficients ( G [ k ] , basisMatrix , Coefs [ k ] ) ; int N = 0 ; for ( int j = - 1 ; j <= n + 1 ; j ++ ) { double v = ( double ) j / n ; for ( int i = - 1 ; i <= m + 1 ; i ++ ) { double u = ( double ) i / m ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = evalBicubic ( Coefs [ k ] , u , v ) ; N ++ ; } } computedMeshNormals = false ; return this ; }
tr	1	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	1	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
tr	2	public String [ ] adjudicate ( final int lineNumber , final String orig , final String [ ] hdr , final String [ ] flds ) { final int n = hdr . length ; String [ ] res = new String [ n ] ; for ( int i = 0 ; ( i < flds . length ) && ( i < n ) ; ++ i ) { res [ i ] = flds [ i ] ; } for ( int i = flds . length ; i < n ; ++ i ) { res [ i ] = "" ; } return res ; }
tr	0	public JButton getButtonClose ( ) { return btnClose ; }
tr	2	private void carregaPreuTipusHabitacions ( ) { String [ ] nomsHotels = { "Palace" , "Hilton" , "Metropolitan" , "Arts" , "Catalunya" , "Pensi\u00F3n Pepe" , "Bonjour" , "Oulala" } ; String [ ] nomsTipus = { "Individual" , "Doble" , "Matrimoni" } ; float [ ] preus = { 100 , 200 , 250 } ; for ( int i = 0 ; i < nomsHotels . length ; ++ i ) { for ( int j = 0 ; j < nomsTipus . length ; ++ j ) { PreuTipusHabitacio pth = new PreuTipusHabitacio ( ) ; pth . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pth . setPreu ( preus [ j ] ) ; if ( j == 0 ) { AbsoluteDiscountPreuStrategy adps = new AbsoluteDiscountPreuStrategy ( ) ; adps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; adps . setDescompte ( 30 ) ; pth . setStrategy ( adps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( adps ) ; } else { PercentDiscountPreuStrategy pdps = new PercentDiscountPreuStrategy ( ) ; pdps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pdps . setPerc ( 0.7F ) ; pth . setStrategy ( pdps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( pdps ) ; } } } }
tr	1	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	1	@ Override public String toString ( ) { String name = getName ( ) ; String append = "" ; if ( name != null && ! name . equals ( "" ) ) { append = "(\"" + this . getName ( ) + "\")" ; } StringBuilder bldr = new StringBuilder ( ) ; bldr . append ( "TAG_List" + append + ": " + value . size ( ) + " entries of type " + NBTUtils . getTypeName ( type ) + "\r\n{\r\n" ) ; for ( Tag t : value ) { bldr . append ( "   " + t . toString ( ) . replaceAll ( "\r\n" , "\r\n   " ) + "\r\n" ) ; } bldr . append ( "}" ) ; return bldr . toString ( ) ; }
tr	3	private void btnLearnCompleteActionPerformed ( java . awt . event . ActionEvent evt ) { ScienceTool . clearAll ( ) ; while ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) - 1 ) { System . out . println ( "learning " + txtFile . getText ( ) ) ; File file = new File ( "data/" + txtFile . getText ( ) ) ; if ( file . exists ( ) ) { for ( LinkKNN knn : knns ) { knn . learnType ( ( String ) lstTypes . getSelectedValue ( ) ) ; } Datasource . getInstance ( ) . playRecording ( file ) ; for ( LinkKNN knn : knns ) { knn . stopLearning ( ) ; } } if ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) ) { lstTypes . setSelectedIndex ( lstTypes . getSelectedIndex ( ) + 1 ) ; } } jlDatas . updateUI ( ) ; jlDatas . setSelectionInterval ( 0 , jlDatas . getModel ( ) . getSize ( ) ) ; }
tr	2	public void generate ( Point start ) { Stack < Point > waysToExpand = new Stack < > ( ) ; exitFound = false ; final List < Point > nextOptions = new ArrayList < > ( 4 ) ; waysToExpand . add ( start ) ; while ( ! waysToExpand . isEmpty ( ) ) { Point p = waysToExpand . pop ( ) ; if ( canBecomeWhite ( p ) ) { arr . setWhite ( p ) ; if ( onTheEdge ( p ) && p . differsFrom ( start ) ) { exitFound = true ; } if ( isBlack ( p . up ( ) ) && canBecomeWhite ( p . up ( ) ) ) nextOptions . add ( p . up ( ) ) ; if ( isBlack ( p . down ( ) ) && canBecomeWhite ( p . down ( ) ) ) nextOptions . add ( p . down ( ) ) ; if ( isBlack ( p . left ( ) ) && canBecomeWhite ( p . left ( ) ) ) nextOptions . add ( p . left ( ) ) ; if ( isBlack ( p . right ( ) ) && canBecomeWhite ( p . right ( ) ) ) nextOptions . add ( p . right ( ) ) ; Collections . shuffle ( nextOptions ) ; int c = 0 ; for ( Point t : nextOptions ) { waysToExpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextOptions . clear ( ) ; } } }
tr	4X	@ SuppressWarnings ( "rawtypes" ) public void paint ( Graphics g ) { super . paint ( g ) ; Graphics2D g2d = ( Graphics2D ) g ; drawbackground ( g ) ; drawScore ( g ) ; if ( GameCraft . direction == 3 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerback.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 0 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 1 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerleft.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 2 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerright.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } ArrayList ms = GameCraft . getBulletDOWN ( ) ; for ( int i = 0 ; i < ms . size ( ) ; i ++ ) { BulletDOWN m = ( BulletDOWN ) ms . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msUP = GameCraft . getBulletUP ( ) ; for ( int i = 0 ; i < msUP . size ( ) ; i ++ ) { BulletUP m = ( BulletUP ) msUP . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msLEFT = GameCraft . getBulletLEFT ( ) ; for ( int i = 0 ; i < msLEFT . size ( ) ; i ++ ) { BulletLEFT m = ( BulletLEFT ) msLEFT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msRIGHT = GameCraft . getBulletRIGHT ( ) ; for ( int i = 0 ; i < msRIGHT . size ( ) ; i ++ ) { BulletRIGHT m = ( BulletRIGHT ) msRIGHT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msEnemys = GameCraft . getEnemys ( ) ; for ( int i = 0 ; i < msEnemys . size ( ) ; i ++ ) { Enemys m = ( Enemys ) msEnemys . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } Toolkit . getDefaultToolkit ( ) . sync ( ) ; g . dispose ( ) ; }
tr	1	public void printRes ( ) { for ( int i = 0 ; i < n ; i ++ ) { Vertex v = res . get ( i ) ; System . out . println ( v . vertex + " : " + v . timestamp1 + " / " + v . timestamp2 ) ; } }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	4X	public static < K , T > Map < K , T > runIdempotentJobsWithRetries ( ExecutorService es , Map < K , ? extends Callable < T >> tasks , final int maxRounds , final IJobListener < K , T > jobListener ) { Map < K , T > out = new HashMap < K , T > ( ) ; Set < K > remainingTasks = new HashSet < K > ( tasks . keySet ( ) ) ; long round = 0 ; while ( remainingTasks . size ( ) > 0 && round ++ < maxRounds ) { List < K > keys = new LinkedList < K > ( remainingTasks ) ; Collections . shuffle ( keys ) ; Map < K , Future < T >> futures = new HashMap < K , Future < T >> ( ) ; for ( final K k : keys ) { final Callable < T > task = tasks . get ( k ) ; futures . put ( k , es . submit ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { try { T result = task . call ( ) ; if ( jobListener != null ) { jobListener . jobDone ( k , result ) ; } return result ; } catch ( Exception e ) { if ( jobListener != null ) { jobListener . jobException ( k , e ) ; } throw e ; } } } ) ) ; } Set < K > done = new HashSet < K > ( ) ; for ( K k : futures . keySet ( ) ) { try { T result = futures . get ( k ) . get ( ) ; out . put ( k , result ) ; done . add ( k ) ; } catch ( Exception e ) { logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } for ( K d : done ) { remainingTasks . remove ( d ) ; } } if ( remainingTasks . size ( ) > 0 ) { logger . warnf ( "% d tasks not completed" , remainingTasks . size ( ) ) ; } return out ; }
tr	4X	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	2	public void backPropagate ( double [ ] target , double learningSpeed ) { double [ ] oError = calculateError ( getOutput ( ) , target , learningSpeed ) ; for ( double n : oError ) if ( double . isNaN ( n ) ) throw new RuntimeException ( "calculateError resulted in NaN" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] iError = backPropagateLayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oError , learningSpeed ) ; updateBias ( weights . get ( l ) , oError ) ; oError = iError ; } }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	3	private Description deserialise ( SingleDescriptionTriples buffer , List < Description > additional ) throws DeserialisationException { if ( buffer . hasBeenDeserialised ( ) ) { return buffer . getDeserialisation ( ) ; } URI type = getSpecificType ( buffer ) ; Description description ; if ( type == null ) { type = getImpliedType ( buffer . getSubject ( ) ) ; if ( type == null ) { return null ; } } description = ProvConstructer . create ( type , buffer . getIdentifier ( ) ) ; buffer . setDeserialisation ( description ) ; for ( URI predicate : buffer . getPredicates ( ) ) { if ( ! predicate . equals ( RDF . typeURI ( ) ) ) { if ( Term . isProvTerm ( predicate ) ) { deserialise ( predicate , buffer , description , additional ) ; } else { if ( description instanceof AttributeHolder ) { for ( Literal object : buffer . getLiteralObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object . _value ) ; } for ( URI object : buffer . getURIObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object ) ; } } } } } return description ; }
tr	1	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	0	@ Override public void run ( ) { repaint ( ) ; }
tr	1	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	3	int sendIncrementalRLE ( int [ ] data , int [ ] prevData , DataOutputStream out ) { try { int bytesSent = 0 ; int i = 0 ; int equalCount = 0 , dataValue = 0 , dataCount = 0 ; while ( i < data . length ) { while ( prevData != null && i < data . length && data [ i ] == prevData [ i ] ) { equalCount ++ ; i ++ ; } if ( equalCount > 0 ) { out . writeInt ( equalCount | 80000000 ) ; bytesSent += 4 ; equalCount = 0 ; } if ( i >= data . length ) break ; dataValue = data [ i ] ; dataCount = 1 ; i ++ ; while ( i < data . length && data [ i ] == dataValue && dataCount < 127 ) { dataCount ++ ; i ++ ; } out . writeInt ( ( dataValue & 00FFFFFF ) | ( dataCount << 24 ) ) ; bytesSent += 4 ; } return bytesSent ; } catch ( IOException e ) { return - 1 ; } }
tr	1	private FormalParametersNode formalParameters ( ) { List < FPSectionNode > fpsections = new ArrayList < FPSectionNode > ( ) ; FPSectionNode fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; while ( test ( SEMICOLON ) ) { read ( SEMICOLON , ";" ) ; fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; } return new FormalParametersNode ( fpsections ) ; }
tr	1	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
tr	2	public Identifier BookBed ( Identifier userId , Identifier searchId ) { ArrayList < SearchBean < FreeBedDetailBean >> results = getLastSearchResult ( ) ; for ( SearchBean < FreeBedDetailBean > search : results ) { if ( search . getSearchId ( ) . equals ( searchId ) ) { FreeBedDetailBean bedDetail = search . getObjectInfo ( ) ; Identifier hostelId = search . getObjectId ( ) ; Booking booking = new Booking ( ) ; booking . setBedIds ( bedDetail . getBedIds ( ) ) ; ArrayList < Tariff > bedReservations = new ArrayList < Tariff > ( ) ; for ( int i = 0 ; i < booking . getBedIds ( ) . size ( ) ; i ++ ) { Tariff tariff = new Tariff ( bedDetail . getPrice ( ) . get ( i ) , bedDetail . getCheckIn ( ) , bedDetail . getCheckOut ( ) ) ; bedReservations . add ( tariff ) ; } booking . setBedReservations ( bedReservations ) ; booking . setBookingDate ( GenericUtility . getCurrentDateWithoutTime ( ) ) ; booking . setHostelId ( hostelId ) ; booking . setStatus ( BookingStatus . RESERVED ) ; booking . setUserId ( userId ) ; try { return Bookings . getInstance ( ) . create ( booking ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidIdentifierException | InvalidParameterException | ConflictException | IdentifierNotFoundException e ) { } } } return null ; }
tr	0	public void setRing ( boolean ring ) { this . ring = ring ; }
tr	3	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	3	public static void startJar ( String file , String arguments ) { if ( arguments != null ) System . out . println ( "The game arguments are: " + arguments ) ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "java -jar \"" + file + "\" " + arguments ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; return ; } if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_CLOSE ) System . exit ( 0 ) ; if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_REOPEN ) Data . launcherFrame . setVisible ( false ) ; final InputStream err = p . getErrorStream ( ) ; Thread errThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { BufferedReader errReader = new BufferedReader ( new InputStreamReader ( err ) ) ; String line = null ; while ( ( line = errReader . readLine ( ) ) != null ) System . err . println ( line ) ; errReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } , "errThread" ) ; errThread . start ( ) ; InputStream in = p . getInputStream ( ) ; try { BufferedReader txtReader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = txtReader . readLine ( ) ) != null ) System . out . println ( "[game] " + line ) ; txtReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } while ( true ) if ( ! errThread . isAlive ( ) ) break ; try { in . close ( ) ; err . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
tr	2	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	1	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	4X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	1	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
tr	3	public void distribuerMessageConversation ( MessageConversation message ) throws RemoteException { try { ArrayList < Groupe > groupes = message . getGroupesParticipants ( ) ; ArrayList < String > utilisateursDistribues = new ArrayList < String > ( ) ; if ( groupes != null ) { for ( Groupe g : groupes ) { ArrayList < Utilisateur > utilisateurs = g . getUtilisateurs ( ) ; for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( getConversations ( ) . get ( message . getIdConversation ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } ArrayList < Utilisateur > utilisateurs = message . getParticipants ( ) ; if ( utilisateurs != null ) { for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( new Conversation ( message . getIdConversation ( ) , message . getParticipants ( ) , message . getGroupesParticipants ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } }
tr	4X	private boolean findBranchingRoute ( Agent a , Box obstacle ) { dir boxDir = null ; BacktrackTree root = new BacktrackTree ( a . desire . box . getAtField ( ) , a . getAtField ( ) , null ) ; BacktrackTree currentNode = null ; Set < BacktrackTree > closedSet = new HashSet < BacktrackTree > ( ) ; LinkedList < BacktrackTree > queue = new LinkedList < BacktrackTree > ( ) ; HashMap < Field , ArrayList < Field >> exploredStates = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( a . desire . box . getAtField ( ) ) ; exploredStates . put ( a . getAtField ( ) , tempList ) ; queue . add ( root ) ; currentNode = queue . pop ( ) ; while ( currentNode . boxLocation != a . desire . goal ) { boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > foundCommands = a . addPossibleCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation ) ; for ( Command command : foundCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( exploredStates . containsKey ( agentLocation ) ) { if ( exploredStates . get ( agentLocation ) . contains ( boxLocation ) ) continue ; else { exploredStates . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; exploredStates . put ( agentLocation , tempListe ) ; } BacktrackTree bt = new BacktrackTree ( boxLocation , agentLocation , command ) ; bt . parent = currentNode ; boolean setupInClosedSet = false ; for ( BacktrackTree closedTree : closedSet ) { if ( closedTree . agentLocation . x == bt . agentLocation . x && closedTree . agentLocation . y == bt . agentLocation . y && closedTree . boxLocation . x == bt . boxLocation . x && closedTree . boxLocation . y == bt . boxLocation . y ) { setupInClosedSet = true ; } } if ( ! setupInClosedSet ) { queue . add ( bt ) ; closedSet . add ( bt ) ; } } if ( queue . isEmpty ( ) ) { return false ; } currentNode = queue . pop ( ) ; } ArrayList < Command > commands = new ArrayList < Command > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; for ( Command command : commands ) { a . commandQueueDONOTUSE . add ( command ) ; } return true ; }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	0	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	0	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	2	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = 0 , cnt = 1 ; HDOJ1069 hdoj1069 = new HDOJ1069 ( ) ; while ( ( n = scanner . nextInt ( ) ) > 0 ) { hdoj1069 . init ( ) ; while ( n -- > 0 ) { hdoj1069 . handleInput ( scanner . nextInt ( ) , scanner . nextInt ( ) , scanner . nextInt ( ) ) ; } System . out . println ( String . format ( "Case %s: maximum height = %s" , cnt ++ , hdoj1069 . entrance ( ) ) ) ; } }
tr	1	public static ArrayList < String > getCluster ( String token ) { if ( singleton == null ) { singleton = new BrownFeaturizer ( ) ; singleton . init ( new Model ( ) ) ; } ArrayList < String > list = new ArrayList < String > ( ) ; String cluster = singleton . mappingS . get ( token ) ; if ( cluster == null ) { cluster = "NONE" ; } else { for ( int len : LEN ) { if ( cluster . length ( ) >= len ) { String pf = cluster . substring ( 0 , len ) ; list . add ( "CLUST_" + len + "_" + pf ) ; } } list . add ( "CLUST_ALL_" + cluster ) ; } return list ; }
tr	1	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	4X	public List < double > classifyInstance ( Datum attributesDatum ) { List < double > attributesList = attributesDatum . getAttributes ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Input ) ; i ++ ) { neuralMap . get ( NetworkLevel . Input ) . get ( i ) . setNodeValue ( attributesList . get ( i ) ) ; } for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; i ++ ) { double totalHiddenInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Input ) ; j ++ ) { double inputNodeValue = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getNodeValue ( ) ; double inputNodeWeight = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getOutputWeightAt ( i ) ; totalHiddenInput += inputNodeValue * inputNodeWeight ; } totalHiddenInput += biasNode . getOutputWeightAt ( i ) * biasNode . getNodeValue ( ) ; double hiddenNodeValue = 1.0 / ( 1 + Math . pow ( Math . E , - totalHiddenInput ) ) ; neuralMap . get ( NetworkLevel . Hidden ) . get ( i ) . setNodeValue ( hiddenNodeValue ) ; } ArrayList < double > intermediateValues = new ArrayList < double > ( ) ; double simpleTotal = 0 ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double totalOutputInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; j ++ ) { double hiddenNodeValue = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getNodeValue ( ) ; double hiddenNodeWeight = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getOutputWeightAt ( i ) ; totalOutputInput += hiddenNodeValue * hiddenNodeWeight ; } totalOutputInput += biasNode . getOutputWeightAt ( i + nodeLevelNumber . get ( NetworkLevel . Hidden ) ) * biasNode . getNodeValue ( ) ; intermediateValues . add ( totalOutputInput ) ; simpleTotal += Math . pow ( Math . E , totalOutputInput ) ; } ArrayList < double > finalValues = new ArrayList < double > ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double trueOutputValue ; trueOutputValue = Math . pow ( Math . E , intermediateValues . get ( i ) ) / simpleTotal ; neuralMap . get ( NetworkLevel . Output ) . get ( i ) . setNodeValue ( trueOutputValue ) ; finalValues . add ( trueOutputValue ) ; } return finalValues ; }
tr	0	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	1	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	3	@ Override public void notificarCicloFinalizado ( ) { Tablero tablero = this . vp . obtenerTablero ( ) ; GameLoop gameLoop = this . vp . obtenerGameLoop ( ) ; ArrayList < Barco > listaBarco = tablero . getDestruidos ( ) ; for ( Barco barco : listaBarco ) { for ( Parte parte : barco . getCuerpo ( ) ) { ObjetoDibujable vista = MapaDeVistasDePartes . get ( parte ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( parte ) ; } } } ArrayList < Disparo > listaDisparo = tablero . getDisparosDetonados ( ) ; for ( Disparo disparo : listaDisparo ) { ObjetoDibujable vista = MapaDeVistasDeDisparos . get ( disparo ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( disparo ) ; } } listaDisparo . clear ( ) ; this . vp . obtenerEtiquetaPuntaje ( ) . setText ( "Puntaje: " + tablero . getPuntos ( ) ) ; if ( tablero . estaPerdido ( ) ) { JOptionPane . showMessageDialog ( null , "Lamentablemente Usted Perdio" ) ; this . reiniciarTablero ( ) ; } else if ( tablero . estaGanado ( ) ) { JOptionPane . showMessageDialog ( null , "Gano!!!!" ) ; this . reiniciarTablero ( ) ; } }
tr	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
tr	3	public static void main ( String [ ] args ) { int N = 4 ; int gC [ ] = { 1 , 5 , 3 , 6 } ; int d [ ] = { 2 , 3 , 2 , 7 } ; int rF [ ] = { 0 , 0 , 0 , 0 } ; int l , i ; for ( l = 0 ; l < N ; l ++ ) { for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) rF [ i ] += gC [ ( l + i ) % N ] - d [ ( l + i ) % N ] ; } } for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) break ; } if ( i < N ) { System . out . println ( "The Starting point is:" + i ) ; } else { System . out . println ( "There is no Starting point" ) ; } }
tr	4X	public String longestPalindrome ( String s ) { if ( s == null ) return null ; char [ ] array = s . toCharArray ( ) ; int n = s . length ( ) ; int maxLen = 1 ; int beginIndex = 0 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { table [ i ] [ j ] = true ; continue ; } table [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( array [ i ] == array [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; maxLen = 2 ; beginIndex = i ; } } for ( int len = 3 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; if ( array [ i ] == array [ j ] && table [ i + 1 ] [ j - 1 ] ) { table [ i ] [ j ] = true ; beginIndex = i ; maxLen = len ; } } } return s . substring ( beginIndex , beginIndex + maxLen ) ; }
tr	3	public void helper ( String s , int count ) { if ( count == 3 ) { if ( s . charAt ( 0 ) == 0 && s . length ( ) > 1 ) return ; if ( s . length ( ) > 3 ) { int hh = 0 ; while ( s . length ( ) - hh > 3 ) { if ( s . charAt ( hh ) != 0 ) return ; hh ++ ; } } if ( Integer . parseInt ( s ) > 255 ) return ; else { temp . add ( s ) ; String ss = "" ; for ( int i = 0 ; i < 4 ; i ++ ) { ss = ss + "." + temp . get ( i ) ; } ss = ss . substring ( 1 ) ; ret . add ( ss ) ; temp . remove ( temp . size ( ) - 1 ) ; } } else { for ( int i = 0 ; i < s . length ( ) - 3 + count ; i ++ ) { if ( Integer . parseInt ( s . substring ( 0 , i + 1 ) ) > 255 ) break ; temp . add ( s . substring ( 0 , i + 1 ) ) ; helper ( s . substring ( i + 1 , s . length ( ) ) , count + 1 ) ; temp . remove ( temp . size ( ) - 1 ) ; if ( s . charAt ( 0 ) == 0 ) break ; } } }
tr	3	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
tr	3	public static Matrix4 multiply ( Matrix4 m1 , Matrix4 m2 ) { Matrix4 C = new Matrix4 ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) C . A [ i ] [ j ] += m1 . A [ i ] [ k ] * m2 . A [ k ] [ j ] ; return C ; }
tr	2	private void comparePackageParts ( TIPP p1 , TIPP p2 ) throws Exception { Collection < TIPPSection > s1 = p1 . getSections ( ) ; Collection < TIPPSection > s2 = p2 . getSections ( ) ; assertNotNull ( s1 ) ; assertNotNull ( s2 ) ; for ( TIPPSection s : s1 ) { TIPPSectionType type = s . getType ( ) ; List < ? extends TIPPFile > o1 = s . getFileResources ( ) ; TIPPSection _s = p2 . getSection ( type ) ; assertEquals ( s , _s ) ; List < ? extends TIPPFile > o2 = _s . getFileResources ( ) ; assertNotNull ( o1 ) ; assertNotNull ( o2 ) ; assertEquals ( o1 , o2 ) ; Iterator < ? extends TIPPFile > fit1 = o1 . iterator ( ) ; Iterator < ? extends TIPPFile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasNext ( ) ) { TIPPFile f1 = fit1 . next ( ) ; assertTrue ( fit2 . hasNext ( ) ) ; TIPPFile f2 = fit2 . next ( ) ; assertEquals ( f1 , f2 ) ; try ( InputStream is1 = p1 . getFile ( f1 ) ; InputStream is2 = p2 . getFile ( f2 ) ) { verifyBytes ( is1 , is2 ) ; } } } }
tr	4X	public class findClass ( String className ) { final class aClass = handleGenaratedClass ( className ) ; if ( aClass != null ) { return aClass ; } byte classByte [ ] ; class result = null ; result = ( class ) classes . get ( className ) ; if ( result != null ) { return result ; } try { return findSystemClass ( className ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( jarFiles . size ( ) > 0 ) { for ( LibraryEntity jarFile : jarFiles ) { final String [ ] libNames = jarFile . getLibNames ( ) ; for ( String libName : libNames ) { JarFile jar = new JarFile ( ApplicationSettings . getInstance ( ) . getLibraryBasePath ( ) + libName ) ; final Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry element = entries . nextElement ( ) ; final String accClassName = element . getName ( ) . replaceAll ( "/" , "." ) ; if ( ( className + ".class" ) . equals ( accClassName ) ) { InputStream is = jar . getInputStream ( element ) ; ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; int nextValue = is . read ( ) ; while ( - 1 != nextValue ) { byteStream . write ( nextValue ) ; nextValue = is . read ( ) ; } classByte = byteStream . toByteArray ( ) ; result = defineClass ( className , classByte , 0 , classByte . length , null ) ; classes . put ( className , result ) ; return result ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	2	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	3	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	0	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	3	public Main ( ) { lf = new LinkFilter ( ) ; knnc = new KNNControl ( lf ) ; knnc . setVisible ( true ) ; Datasource loggin = new Datasource ( lf , null ) ; int [ ] motes = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; for ( int i : motes ) { for ( int j = 0 ; j < 10 ; j ++ ) { loggin . sendConfig ( i , 50 , 31 ) ; } for ( int j : motes ) { if ( i != j ) { addLink ( i , j ) ; } } } }
tr	4X	private boolean fourInARow ( int row , int col , Location [ ] [ ] boardLocations ) { int columnLength = boardLocations [ row ] . length ; int rowLength = boardLocations . length ; int startRow ; int currentRow ; int startColumn ; int currentColumn ; int matches = 0 ; boolean fourOfAKindFound = false ; int i , j , k ; for ( i = 0 ; i < rowLength ; i ++ ) { Location [ ] rowlocations = boardLocations [ i ] ; for ( j = 0 , startColumn = 0 , currentColumn = 0 , matches = 0 ; j < columnLength - 1 ; j ++ ) { if ( rowlocations [ j ] . getPlayer ( ) == rowlocations [ j + 1 ] . getPlayer ( ) ) { currentColumn ++ ; if ( rowlocations [ j ] . getPlayer ( ) != null ) matches ++ ; else startColumn = currentColumn ; } else if ( matches < 3 ) { currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; } else { for ( k = startColumn ; k <= currentColumn ; k ++ ) { rowlocations [ k ] . setDeleteFlag ( ) ; } currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } for ( j = 0 ; j < columnLength ; j ++ ) { for ( i = 0 , matches = 0 , startRow = 0 , currentRow = 0 ; i < rowLength - 1 ; i ++ ) { if ( boardLocations [ i ] [ j ] . getPlayer ( ) == boardLocations [ i + 1 ] [ j ] . getPlayer ( ) ) { currentRow ++ ; if ( boardLocations [ i ] [ j ] . getPlayer ( ) != null ) matches ++ ; else startRow = currentRow ; } else if ( matches < 3 ) { currentRow ++ ; startRow = currentRow ; matches = 0 ; } else { for ( k = startRow ; k <= currentRow ; k ++ ) { boardLocations [ k ] [ j ] . setDeleteFlag ( ) ; } currentRow ++ ; startRow = currentRow ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } return fourOfAKindFound ; }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	4X	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	1	public String toString ( ) { StringBuilder out = new StringBuilder ( ) ; for ( ArrayPlace arrayPlace : arrayPlaces ) out . append ( arrayPlace ) . append ( "=" ) ; out . append ( expression ) ; return out . toString ( ) ; }
tr	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
tr	1	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	0	public void actionPerformed ( ActionEvent event ) { Main . newSet ( ) ; }
tr	4X	@ Test public void testlimitNunberOfItems ( ) throws IOException { block = new StorageBlock ( testDir , 2 , StorageManager . DEFAULT_CAPACITY_PER_BLOCK , storageMode ) ; int limit = 1000 ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = block . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; assertTrue ( testBytes . length * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; } String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == block . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit - ( testBytes . length - smallTestBytes . length ) * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == block . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == block . getUsed ( ) ) ; block . free ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; }
va	4X	public List < Tuple < Integer , Integer >> leastEncumbered ( int [ ] [ ] mosqBoard ) { List < Tuple < Integer , Integer >> rank = new ArrayList < Tuple < Integer , Integer >> ( ) ; boolean [ ] [ ] board = getValidBoard ( mosqBoard , 0 ) ; int [ ] [ ] quadrantCount = new int [ 2 ] [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { int wallCount = 0 ; for ( int x = i * 50 ; x < 50 * ( i + 1 ) ; x ++ ) { for ( int y = j * 50 ; y < 50 * ( j + 1 ) ; y ++ ) { if ( ! board [ x ] [ y ] ) { wallCount ++ ; } } } quadrantCount [ i ] [ j ] = wallCount ; } } for ( int q = 0 ; q < 4 ; q ++ ) { int smallest = Integer . MAX_VALUE ; Tuple < Integer , Integer > smallestQ = null ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { log . debug ( "i" + i + "j" + j + " count " + quadrantCount [ i ] [ j ] ) ; if ( quadrantCount [ i ] [ j ] < smallest ) { smallestQ = new Tuple < Integer , Integer > ( i , j ) ; smallest = quadrantCount [ i ] [ j ] ; } } } int x , y ; if ( smallestQ . x == 0 ) x = 20 + ( smallestQ . x ) * 50 ; else x = 30 + ( smallestQ . x ) * 50 ; if ( smallestQ . y == 0 ) y = 20 + ( smallestQ . y ) * 50 ; else y = 30 + ( smallestQ . y ) * 50 ; rank . add ( new Tuple < Integer , Integer > ( x , y ) ) ; quadrantCount [ smallestQ . x ] [ smallestQ . y ] = Integer . MAX_VALUE ; } return rank ; }
va	2	@ Override public List < case > parse ( String data ) { final Scanner sc = new Scanner ( data ) ; final List < case > cases = Lists . newArrayList ( ) ; long num_cases = sc . nextLong ( ) ; for ( int case_num = 0 ; case_num < num_cases ; case_num ++ ) { final int numWords = sc . nextInt ( ) ; final List < String > words = Lists . newArrayList ( ) ; for ( int i = 0 ; i < numWords ; i ++ ) { words . add ( sc . next ( ) ) ; } case aCase = new case ( words ) ; cases . add ( aCase ) ; } return cases ; }
va	1	private static Object [ ] subseq ( Object [ ] ary , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == ary . length ) return ary ; else { int len = hi - lo ; Object [ ] a = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) a [ i ] = ary [ i + lo ] ; return a ; } }
va	2	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
va	3	@ Override public List < case > parse ( String data ) { final Scanner sc = new Scanner ( data ) ; final List < case > cases = Lists . newArrayList ( ) ; long num_cases = sc . nextLong ( ) ; for ( int case_num = 0 ; case_num < num_cases ; case_num ++ ) { final int n = sc . nextInt ( ) ; final List < Integer > v1 = Lists . newArrayList ( ) ; final List < Integer > v2 = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v1 . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { v2 . add ( sc . nextInt ( ) ) ; } case aCase = new case ( v1 , v2 ) ; cases . add ( aCase ) ; } return cases ; }
va	4X	@ Override public void build ( ) { DataSet oldDataSet = getDataSet ( ) ; bits = new int [ oldDataSet . getAttributes ( ) . size ( ) ] ; Arrays . fill ( bits , 1 ) ; fillFibonacci ( ) ; for ( Pattern instance : oldDataSet ) { double [ ] features = instance . toDoubleVector ( ) ; for ( int i = 0 ; i < features . length ; i ++ ) { double feature = features [ i ] ; int maxBits = fibonacciCode ( feature . longValue ( ) ) . length ( ) ; bits [ i ] = Math . max ( bits [ i ] , maxBits ) ; } } int totalBits = 0 ; for ( int bit : bits ) { totalBits += bit ; } newDataSet = new DataSet ( ) ; newDataSet . setName ( oldDataSet . getName ( ) ) ; newDataSet . setDistribution ( oldDataSet . getDistribution ( ) ) ; newDataSet . setClasses ( oldDataSet . getClasses ( ) ) ; for ( int i = 0 ; i < totalBits ; i ++ ) { newDataSet . addAttribute ( new Attribute ( "bit" + i ) ) ; } }
va	4X	private void postPlugin ( final boolean isPing ) throws IOException { PluginDescriptionFile description = plugin . getDescription ( ) ; String pluginName = description . getName ( ) ; boolean onlineMode = Bukkit . getServer ( ) . getOnlineMode ( ) ; String pluginVersion = description . getVersion ( ) ; String serverVersion = Bukkit . getVersion ( ) ; int playersOnline = Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , pluginVersion ) ; encodeDataPair ( data , "server" , serverVersion ) ; encodeDataPair ( data , "players" , Integer . toString ( playersOnline ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; String osname = System . getProperty ( "os.name" ) ; String osarch = System . getProperty ( "os.arch" ) ; String osversion = System . getProperty ( "os.version" ) ; String java_version = System . getProperty ( "java.version" ) ; int coreCount = Runtime . getRuntime ( ) . availableProcessors ( ) ; if ( osarch . equals ( "amd64" ) ) { osarch = "x86_64" ; } encodeDataPair ( data , "osname" , osname ) ; encodeDataPair ( data , "osarch" , osarch ) ; encodeDataPair ( data , "osversion" , osversion ) ; encodeDataPair ( data , "cores" , Integer . toString ( coreCount ) ) ; encodeDataPair ( data , "online-mode" , boolean . toString ( onlineMode ) ) ; encodeDataPair ( data , "java_version" , java_version ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( pluginName ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
va	2	public void update ( final World w ) { for ( short x = 0 ; x < sideLength ; x ++ ) { for ( short y = 0 ; y < sideLength ; y ++ ) { short tileX = ( short ) ( x + ( coords . getX ( ) * sideLength ) ) ; short tileY = ( short ) ( y + ( coords . getY ( ) * sideLength ) ) ; final Tile t = getTile ( x , y ) ; if ( ( t == Tiles . air ) || ( t == null ) ) { new Packet03Tile ( t , tileX , tileY ) . writeDataToServer ( ) ; } if ( t . doesTick ( ) ) { t . update ( w , tileX , tileY ) ; } } } }
va	2	public void initializeGrid ( int [ ] [ ] exportedGrid ) { int rows = b . numRows ; int columns = b . numColumns ; for ( int y = 0 ; y < rows ; y ++ ) { for ( int x = 0 ; x < columns ; x ++ ) { int state = exportedGrid [ y ] [ x ] ; b . setGameGridCircle ( x , y , state ) ; if ( state != 0 ) { b . setDrawCounter ( b . getDrawCounter ( ) + 1 ) ; } } } }
va	4X	public boolean shiftUp ( ) { boolean empty = true ; for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { if ( currentShape [ 0 ] [ j ] ) empty = false ; } if ( empty ) { for ( int i = 1 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ i - 1 ] [ j ] = currentShape [ i ] [ j ] ; } } for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ PIECE_SIZE - 1 ] [ j ] = false ; } } return empty ; }
va	0	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
va	4X	private boolean check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { double [ ] x = primal ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { double [ ] y = dual ( ) ; for ( int j = 0 ; j < N ; j ++ ) { double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
va	2	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
va	0	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
va	2	public String getRecords ( ) { StringBuilder resultado = new StringBuilder ( ) ; if ( tipo != null ) { Declaracion tmp = tipo ; TipoDeclaracion tdecl = null ; TipoRecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof TipoDeclaracion ) { resultado . append ( ".namespace Ejemplo{\n" ) ; tdecl = ( ( TipoDeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getNombre ( ) ) ; resultado . append ( " extends [mscorlib]System.ValueType{\n" ) ; Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tdecl . getNombre ( ) ) ; TipoRecord record = ( ( TipoRecord ) t ) ; Collections . reverse ( record . tbsimbolo . lista ) ; Collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoRecord ) { trec1 = ( ( TipoRecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype Ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoArray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . toString ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getSiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . toString ( ) ; }
va	2	@ Override public Vector < ScoredDocument > runQuery ( Query query , int numResults ) { Queue < ScoredDocument > rankQueue = new PriorityQueue < ScoredDocument > ( ) ; AbstractSearcher searcher = indexer . createSearcher ( query ) ; Document doc = null ; int docid = - 1 ; while ( ( doc = searcher . nextDoc ( docid ) ) != null ) { ScoredDocument scoredDoc = runquery ( query , doc ) ; rankQueue . add ( scoredDoc ) ; if ( rankQueue . size ( ) > numResults ) { rankQueue . poll ( ) ; } docid = doc . docId ; } Vector < ScoredDocument > results = new Vector < ScoredDocument > ( ) ; ScoredDocument scoredDoc = null ; while ( ( scoredDoc = rankQueue . poll ( ) ) != null ) { results . add ( scoredDoc ) ; } Collections . sort ( results , Collections . reverseOrder ( ) ) ; return results ; }
va	4X	public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; List < List < Ship >> shipsCollection = new ArrayList < List < Ship >> ( ) ; for ( ServerPlayer p : players ) shipsCollection . add ( p . getShipsCopy ( ) ) ; updateSizeVariables ( ) ; grid = ( BufferedImage ) ( this . createImage ( this . widthPx , this . heightPx ) ) ; Graphics2D gc = grid . createGraphics ( ) ; drawGrid ( gc ) ; int colorIndex = 0 ; for ( ServerPlayer p : players ) StructurePainter . paintBase ( this , p . getBase ( ) , PLAYER_COLORS [ colorIndex ++ ] ) ; StructurePainter . paintStructures ( this , structures ) ; for ( int i = 0 ; i < players . size ( ) ; i ++ ) ShipPainter . paintShips ( this , shipsCollection . get ( i ) , PLAYER_COLORS [ i ] ) ; for ( ServerPlayer p : players ) ActionPainter . paintResults ( this , p . getLastActionResults ( ) ) ; g2 . drawImage ( grid , null , 0 , 0 ) ; }
va	3	public static int [ ] insertionSort ( final int [ ] num ) { int key , j ; int [ ] tempNum = new int [ num . length ] ; for ( int i = 0 ; i < num . length ; i ++ ) tempNum [ i ] = num [ i ] ; for ( int i = 1 ; i < num . length ; i ++ ) { key = tempNum [ i ] ; j = i - 1 ; while ( j >= 0 && key < tempNum [ j ] ) { tempNum [ j + 1 ] = tempNum [ j ] ; j -- ; } tempNum [ j + 1 ] = key ; } return tempNum ; }
va	4X	@ Override protected BigRational compute ( MultiplicitiesVector finalm , PopulationVector finalp ) throws InternalErrorException { boolean firstVisit = true , secondVisit = false ; BigRational curG ; PopulationVector p = new PopulationVector ( 0 , qnm . R ) ; MultiplicitiesVector mBase = finalm . copy ( ) ; int Ntot = finalp . sum ( ) ; for ( int r = 0 ; r < qnm . R ; r ++ ) { for ( int nr = ( r == 0 ) ? 0 : 1 ; nr <= finalp . get ( r ) ; nr ++ ) { Map < PopulationVector , Map < MultiplicitiesVector , BigRational >> curMap = new HashMap < PopulationVector , Map < MultiplicitiesVector , BigRational >> ( ) ; p . set ( r , nr ) ; boolean isPZeroVector = p . isZeroVector ( ) , pContainsMinusOne = p . containsMinusOne ( ) ; for ( MultiplicitiesVector mDelta : mvcalc . findMulVectorsSummingUpTo ( Ntot ) ) { MultiplicitiesVector m = mBase . addVec ( mDelta ) ; if ( ! isPZeroVector ) { curG = BigRational . ZERO ; if ( pContainsMinusOne ) { continue ; } else if ( m . isZeroVector ( ) ) { continue ; } else { p . minusOne ( r + 1 ) ; BigRational delay = qnm . getDelayAsBigRational ( r ) ; if ( ! delay . isZero ( ) ) { curG = curG . add ( recallG ( m , p ) ) . multiply ( delay ) ; } for ( int k = 0 ; k < qnm . M ; k ++ ) { m . plusOne ( k + 1 ) ; BigRational toAdd = qnm . getDemandAsBigRational ( k , r ) . multiply ( new BigRational ( m . get ( k ) - 1 ) ) ; toAdd = toAdd . multiply ( recallG ( m , p ) ) ; curG = curG . add ( toAdd ) ; m . restore ( ) ; } curG = curG . divide ( new BigRational ( nr ) ) ; p . restore ( ) ; } } else { continue ; } storeG ( m , p , curG , curMap ) ; } Ntot -- ; Gmap . clear ( ) ; Gmap = curMap ; if ( firstVisit ) { secondVisit = true ; firstVisit = false ; } else { if ( secondVisit ) { secondVisit = false ; totalTimer . pause ( ) ; memUsage = MiscFunctions . memoryUsage ( ) ; totalTimer . start ( ) ; } } } } return recallG ( finalm , finalp ) ; }
va	2	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
va	1	public void Insertar ( String dato , String cuentaBancaria ) { NodoDeLista nuevo ; nuevo = new NodoDeLista ( ) ; nuevo . setDato ( dato ) ; nuevo . setCuentaBancaria ( cuentaBancaria ) ; if ( raiz == null ) { nuevo . setSiguiente ( null ) ; raiz = nuevo ; } else { NodoDeLista auxiliar = raiz ; while ( auxiliar . getSiguiente ( ) != null ) { auxiliar = auxiliar . getSiguiente ( ) ; } auxiliar . setSiguiente ( nuevo ) ; } }
va	3	private Vector reOrder ( Vector list ) { Vector newList = new Vector ( ) ; if ( list . size ( ) == 0 ) { return newList ; } int previousMsgId = 0 ; int largestGap = 0 ; int largestGapMsgIdPosInList = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int currentMsgId = ( ( MqttWireMessage ) list . elementAt ( i ) ) . getMessageId ( ) ; if ( currentMsgId - previousMsgId > largestGap ) { largestGap = currentMsgId - previousMsgId ; largestGapMsgIdPosInList = i ; } previousMsgId = currentMsgId ; } int lowestMsgId = ( ( MqttWireMessage ) list . elementAt ( 0 ) ) . getMessageId ( ) ; int highestMsgId = previousMsgId ; if ( MAX_MSG_ID - highestMsgId + lowestMsgId > largestGap ) { largestGapMsgIdPosInList = 0 ; } for ( int i = largestGapMsgIdPosInList ; i < list . size ( ) ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } for ( int i = 0 ; i < largestGapMsgIdPosInList ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } return newList ; }
va	0	@ Override public T evaluate ( T x , T y , T z ) throws AbstractException { T resFirst = first . evaluate ( x , y , z ) ; T resSecond = second . evaluate ( x , y , z ) ; return resFirst . sum ( resSecond ) ; }
va	3	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	4X	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(0|101|11(01)*(1|00)1|(100|11(01)*(1|00)0)(1|0(01)*(1|00)0)*0(01)*(1|00)1)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 10 ; problemCount [ 1 ] = 20 ; problemCount [ 2 ] = 30 ; problemCount [ 3 ] = 40 ; problemCount [ 4 ] = 50 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { GraphvizRenderer . renderGraph ( starter . getWinner ( ) . getObj ( ) , "winner.svg" ) ; solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
va	1	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
va	3	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
va	4X	public static double [ ] getAlleleTotals ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; double alleleTotals [ ] = new double [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0.0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; alleleTotals [ i ] += v ; } i ++ ; } } } return alleleTotals ; }
va	4X	@ Override public void calculateFitness ( List < Individual > population ) throws Exception { int warpoints = 0 ; for ( Individual fighter : population ) { BlottoPhenotype fighterPheno = ( BlottoPhenotype ) fighter . phenotype ( ) ; fighter . setFitness ( 0.0 ) ; for ( Individual opponent : population ) { if ( ! fighter . equals ( opponent ) && ! fighterPheno . fought . contains ( opponent ) ) { BlottoPhenotype opponentPheno = ( BlottoPhenotype ) opponent . phenotype ( ) ; int fighterWins = 0 ; int opponentWins = 0 ; double [ ] fighterWeights = new double [ numBattles ] ; System . arraycopy ( fighterPheno . pheno , 0 , fighterWeights , 0 , numBattles ) ; double [ ] opponentWeights = new double [ numBattles ] ; System . arraycopy ( opponentPheno . pheno , 0 , opponentWeights , 0 , numBattles ) ; for ( int battle = 0 ; battle < numBattles ; battle ++ ) { if ( fighterWeights [ battle ] > opponentWeights [ battle ] ) { fighterWins += 1 ; double redistribution = fighterWeights [ battle ] - opponentWeights [ battle ] ; int remainingBattles = numBattles - ( battle + 1 ) ; redistribution = redistribution / remainingBattles ; for ( int i = battle + 1 ; i < numBattles ; i ++ ) { fighterWeights [ i ] += redeploymentRate * redistribution ; opponentWeights [ i ] *= 1 - defectionRate ; } } else if ( fighterWeights [ battle ] > opponentWeights [ battle ] ) { opponentWins += 1 ; double redistribution = opponentWeights [ battle ] - fighterWeights [ battle ] ; int remainingBattles = numBattles - ( battle + 1 ) ; redistribution = redistribution / remainingBattles ; for ( int i = battle + 1 ; i < numBattles ; i ++ ) { opponentWeights [ i ] += redeploymentRate * redistribution ; fighterWeights [ i ] *= 1 - defectionRate ; } } } if ( fighterWins == opponentWins ) { fighterPheno . score ++ ; opponentPheno . score ++ ; } else if ( fighterWins > opponentWins ) { fighterPheno . score += 2 ; } else if ( fighterWins < opponentWins ) { opponentPheno . score += 2 ; } warpoints += 2 ; fighterPheno . fought . add ( opponent ) ; opponentPheno . fought . add ( fighter ) ; } } } int topScore = 0 ; for ( Individual individual : population ) { BlottoPhenotype ph = ( BlottoPhenotype ) individual . phenotype ( ) ; if ( ph . score > topScore ) topScore = ph . score ; } for ( Individual individual : population ) { BlottoPhenotype ph = ( BlottoPhenotype ) individual . phenotype ( ) ; individual . setFitness ( ( double ) ph . score / ( double ) topScore ) ; ph . fought = null ; } }
va	0	@ Override public void setPopulation ( TspPopulation p ) { population = p ; }
va	4X	private Set < Player > scanDiagonals ( Player [ ] [ ] board ) { HashSet < Player > winners = new HashSet < > ( ) ; int sameInRow = 0 ; int m = Board . NUM_ROWS ; int n = Board . NUM_COLUMNS ; for ( int slice = 0 ; slice < m + n - 1 ; ++ slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = slice - z2 ; j >= z1 ; -- j ) { Player currentPlayer = board [ slice - j ] [ j ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } for ( int slice = m + n - 1 ; slice > 0 ; -- slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = z1 ; j <= slice - z2 ; ++ j ) { Player currentPlayer = board [ slice - j ] [ m - j - 1 ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } return winners ; }
va	1	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
va	3	public static String allScores ( String fileName ) throws IOException { Scanner scan ; String [ ] usernames ; long [ ] wins , losses ; int fileLength = 0 , win = - 1 , lose = - 1 ; try { scan = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( "File not found: " + fileName ) ; FileWriter writeToFile = new FileWriter ( fileName ) ; writeToFile . write ( "//BEGIN\r\n" + "//END" ) ; writeToFile . close ( ) ; scan = new Scanner ( new File ( fileName ) ) ; } String fileContents = "" , fileLine = scan . nextLine ( ) ; while ( ! fileLine . equals ( "//END" ) ) { fileLine = scan . nextLine ( ) ; if ( ! fileLine . equals ( "//END" ) ) fileLength ++ ; } if ( fileLength == 0 ) return "There are no scores in the scoreboard!\nSave yours and get 1st place ;3" ; usernames = new String [ fileLength ] ; wins = new long [ fileLength ] ; losses = new long [ fileLength ] ; scan = new Scanner ( new File ( fileName ) ) ; String spare = scan . next ( ) ; int i ; for ( i = 0 ; i < fileLength ; i ++ ) { try { usernames [ i ] = scan . next ( ) ; wins [ i ] = scan . nextLong ( ) ; losses [ i ] = scan . nextLong ( ) ; } catch ( InputMismatchException ex ) { changeScore ( fileName , usernames [ i ] , 0 , 0 ) ; } } usernames = readNames ( usernames ) ; fileContents = "Username\t Wins\t Losses\n" ; for ( i = 0 ; i < fileLength ; i ++ ) { fileContents += ( i + 1 + ": " + usernames [ i ] + ( usernames [ i ] . length ( ) < 5 ? "\t\t" : "\t " ) + wins [ i ] + "\t " + losses [ i ] + "\n" ) ; } return ( fileContents ) ; }
va	4X	public Sprite ( StreamLoader streamLoader , String s , int i ) { Stream stream = new Stream ( streamLoader . getDataForName ( s + ".dat" ) ) ; Stream stream_1 = new Stream ( streamLoader . getDataForName ( "index.dat" ) ) ; stream_1 . currentOffset = stream . readUnsignedWord ( ) ; anInt1444 = stream_1 . readUnsignedWord ( ) ; anInt1445 = stream_1 . readUnsignedWord ( ) ; int j = stream_1 . readUnsignedByte ( ) ; int ai [ ] = new int [ j ] ; for ( int k = 0 ; k < j - 1 ; k ++ ) { ai [ k + 1 ] = stream_1 . read3Bytes ( ) ; if ( ai [ k + 1 ] == 0 ) ai [ k + 1 ] = 1 ; } for ( int l = 0 ; l < i ; l ++ ) { stream_1 . currentOffset += 2 ; stream . currentOffset += stream_1 . readUnsignedWord ( ) * stream_1 . readUnsignedWord ( ) ; stream_1 . currentOffset ++ ; } anInt1442 = stream_1 . readUnsignedByte ( ) ; anInt1443 = stream_1 . readUnsignedByte ( ) ; myWidth = stream_1 . readUnsignedWord ( ) ; myHeight = stream_1 . readUnsignedWord ( ) ; int i1 = stream_1 . readUnsignedByte ( ) ; int j1 = myWidth * myHeight ; myPixels = new int [ j1 ] ; if ( i1 == 0 ) { for ( int k1 = 0 ; k1 < j1 ; k1 ++ ) myPixels [ k1 ] = ai [ stream . readUnsignedByte ( ) ] ; setTransparency ( 255 , 0 , 255 ) ; return ; } if ( i1 == 1 ) { for ( int l1 = 0 ; l1 < myWidth ; l1 ++ ) { for ( int i2 = 0 ; i2 < myHeight ; i2 ++ ) myPixels [ l1 + i2 * myWidth ] = ai [ stream . readUnsignedByte ( ) ] ; } } setTransparency ( 255 , 0 , 255 ) ; }
va	0	private PlayerPanel buildSecondPlayerPanel ( ) { return new ComputerPlayerPanel ( controller , PlayerSide . RIGHT ) ; }
va	2	public static void main ( String [ ] args ) { HashMap < String , String > hashMap = new HashMap < String , String > ( 4 ) ; hashMap . put ( "andhrapradesh" , "hyderabad" ) ; hashMap . put ( "uttarpradesh" , "allahabad" ) ; hashMap . put ( "karnataka" , "benguluru" ) ; Set < String > s = hashMap . keySet ( ) ; Iterator < String > it = s . iterator ( ) ; while ( it . hasNext ( ) ) { System . out . println ( it . next ( ) . toString ( ) ) ; } hashMap . put ( "tamilnadu" , "chennai" ) ; hashMap . put ( "maharastra" , "mumbai" ) ; hashMap . put ( "gujarat" , "gandhinagar" ) ; hashMap . put ( "punjab" , "chandigarh" ) ; hashMap . put ( "kerala" , "trivendram" ) ; System . out . println ( "after table doubling" ) ; Set < String > s1 = hashMap . keySet ( ) ; Iterator < String > it1 = s . iterator ( ) ; while ( it1 . hasNext ( ) ) { System . out . println ( it1 . next ( ) . toString ( ) ) ; } }
va	0	public byte getNotSettable ( ) { return notSettable ; }
va	0	public void setRunning ( boolean state ) { running = state ; }
va	1	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
va	2	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
va	0	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
va	4X	public static void main ( String [ ] args ) { final int limit = 100000 ; final int iterations = 100 ; final String format = "%g seconds" ; List < long > numbers = Stream . iterate ( 1 , number -> number + 1 ) . limit ( limit ) . collect ( Collectors . < long > toList ( ) ) ; { System . out . println ( "//" + "START:HABITUAL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { long primesCount = 0 ; for ( long number : numbers ) { if ( isPrime ( number ) ) { primesCount += 1 ; } } } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:HABITUAL_OUTPUT" ) ; } { System . out . println ( "//" + "START:LAMBDA_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . stream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:LAMBDA_OUTPUT" ) ; } { System . out . println ( "//" + "START:PARALLEL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . parallelStream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:PARALLEL_OUTPUT" ) ; } }
va	0	public JTextField getTextNombre ( ) { return TextNombre ; }
va	4X	@ Override public void trainWord ( String word , Value < State > times , HashMap < State , Value < Character >> restart ) { int len = word . length ( ) ; double wordProb ; Value < State > alpha = initial ( 1.0 ) ; Value < State > beta ; ArrayList < Value < State >> alphas = new ArrayList < Value < State >> ( ) ; alphas . add ( alpha ) ; for ( int t = 0 ; t < len ; ++ t ) { Character c = word . charAt ( t ) ; alpha = forward ( alpha , c ) ; alphas . add ( alpha ) ; } beta = initial ( 1.0 ) ; wordProb = alpha . get ( I ) ; for ( int t = len - 1 ; t >= 0 ; -- t ) { Character c = word . charAt ( t ) ; alpha = alphas . get ( t ) ; for ( State i : alpha . keySet ( ) ) { double alphai = alpha . get ( i ) ; State j = i . next ( c ) ; double restartValue = beta . containsKey ( I ) ? clip ( alphai * i . prRestart ( c ) * beta . get ( I ) / wordProb ) : 0 ; if ( j != null && beta . containsKey ( j ) ) { double nextValue = clip ( alphai * i . prNext ( c ) * beta . get ( j ) / wordProb ) ; times . addValue ( j , nextValue ) ; } restart . get ( i ) . addValue ( c , restartValue ) ; times . addValue ( I , restartValue ) ; } if ( t > 0 ) { Value < State > output = new Value < State > ( ) ; for ( State i : alpha . keySet ( ) ) { State j = i . next ( c ) ; if ( j != null ) { output . addValue ( i , beta . getValue ( j ) * i . prNext ( c ) ) ; } output . addValue ( i , beta . getValue ( I ) * i . prRestart ( c ) ) ; } beta = output ; } } }
va	3	public static void main ( String [ ] args ) { List < Thread > threads = new ArrayList < Thread > ( ) ; for ( int i = 0 ; i < 500 ; i ++ ) { Runnable task = new MyRunnable ( 10000000 + i ) ; Thread worker = new Thread ( task ) ; worker . setName ( String . valueOf ( i ) ) ; worker . start ( ) ; threads . add ( worker ) ; } int running = 0 ; do { running = 0 ; for ( Thread thread : threads ) { if ( thread . isAlive ( ) ) { running ++ ; } } System . out . println ( "We have " + running + " running threads. " ) ; } while ( running > 0 ) ; }
va	1	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
va	4X	public void viterbi ( ) { int t = 0 ; HashMap < String , Node > ppaths = new HashMap < String , Node > ( ) ; for ( String state : states ) { ppaths . put ( state , new Node ( state , null , initial_probability . get ( state ) ) ) ; } for ( String e : observations ) { HashMap < String , Node > nppaths = new HashMap < String , Node > ( ) ; for ( String tostate : states ) { double myprob = 1d ; Node nn = new Node ( null , null , 0d ) ; for ( Node fromstate : ppaths . values ( ) ) { myprob = fromstate . probability ; double predict = transitionModel . get ( fromstate . state ) . get ( tostate ) ; double update = sensorModel . get ( tostate ) . get ( e ) ; if ( t == 0 ) predict = 1d ; double both = predict * update ; myprob *= both ; nn . updateMax ( tostate , fromstate , myprob ) ; if ( t == 0 ) nn . parent = null ; } nppaths . put ( tostate , nn ) ; } if ( t == 0 ) normalize ( nppaths ) ; System . out . println ( nppaths ) ; ppaths = nppaths ; t ++ ; } if ( t == observations . length ) { System . out . println ( "most probable sequence:" ) ; Node max = new Node ( null , null , 0d ) ; for ( String state : states ) { Node from = ppaths . get ( state ) ; max . updateMax ( from . state , from . parent , from . probability ) ; } System . out . println ( max ) ; } }
va	1	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
va	2	public static void main ( String [ ] args ) { RedBlackTree < Integer > t = new RedBlackTree < > ( ) ; final int NUMS = 400000 ; final int GAP = 35461 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( i ) ; if ( t . findMin ( ) != 1 || t . findMax ( ) != NUMS - 1 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 1 ; i < NUMS ; i ++ ) if ( ! t . contains ( i ) ) System . out . println ( "Find error1!" ) ; }
va	1	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
va	3	@ Override public ByteBuffer getMessage ( ) { for ( int i = 16 ; i < 20 ; i ++ ) { uiMode [ i ] = ( short ) ffff ; } uiSetVoltage [ 1 ] = ( short ) 1999 ; ByteBuffer buffer = ByteBuffer . allocate ( 86 ) ; buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; buffer . putShort ( ( short ) aaa0 ) ; buffer . putShort ( ( short ) 86 ) ; for ( short val : uiMode ) { buffer . putShort ( val ) ; } for ( short val : uiSetVoltage ) { buffer . putShort ( val ) ; } short checksum = ( short ) Utilities . checksum ( buffer , 0 , 84 ) ; buffer . putShort ( checksum ) ; return buffer ; }
va	1	@ Override public boolean remove ( Object o ) { Node < E > position = head ; for ( int i = 0 ; i < size ; i ++ ) { position = position . getNextNode ( ) ; if ( position . getValue ( ) == o ) { this . remove ( i ) ; return true ; } } return false ; }
va	0	public int [ ] getWarps ( ) { return new int [ ] { 0 , 0 , 0 , 0 } ; }
va	3	private void bfs ( State s ) { s . id = - 1 ; Loc f = map . finish ; int counter = 0 ; LinkedList < Node > frontier = new LinkedList < Node > ( ) ; Set < State > explored = new HashSet < State > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( s , null , 0 ) ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state , f ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } System . out . println ( "found goal!" ) ; System . out . println ( "moves: " + solution . size ( ) ) ; mSolutions . addAll ( solution ) ; return ; } explored . add ( current . state ) ; if ( counter % 5000 == 0 ) { System . out . print ( "\n" ) ; } ; if ( counter % 50 == 0 ) { System . out . print ( "." ) ; } ; ArrayList < State > possibles = getMovesCorrectlyPlease ( current . state ) ; for ( int i = 0 ; i < possibles . size ( ) ; i ++ ) { State possib = possibles . get ( i ) ; if ( ! explored . contains ( possib ) ) { frontier . addLast ( new Node ( possib , current , current . distance + 1 ) ) ; } } counter ++ ; } if ( solution . isEmpty ( ) ) { System . out . println ( "FAILED TO FIND SOLUTION" ) ; } }
va	1	void configure ( ImageAnalyzerFactory mediator ) throws TesseractException { mediator . handle . setPageSegMode ( psm ) ; for ( String name : properties . keySet ( ) ) { String value = properties . get ( name ) ; mediator . handle . setVariable ( name , value ) ; } }
va	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
va	2	public void deleteAtPos ( int position ) { DNode cur = HEADER . next ; int size = 0 ; while ( cur != TRAILER ) { size ++ ; cur = cur . next ; } if ( position > size ) { System . out . println ( "Invalid Position cannot insert" ) ; return ; } int i = 0 ; cur = HEADER . next ; while ( i != position ) { i ++ ; cur = cur . next ; } DNode posprev = cur . prev ; DNode posnext = cur . next ; posprev . next = posnext ; posnext . prev = posprev ; }
va	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
va	0	@ Override public String getVarName ( ) { return this . name ; }
va	1	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
va	0	@ XmlElementDecl ( namespace = "" , name = "xRequest" ) public JAXBElement < BigInteger > createXRequest ( BigInteger value ) { return new JAXBElement < BigInteger > ( _XRequest_QNAME , BigInteger . class , null , value ) ; }
va	2	public void repairGeneTree ( Abaddon abaddon ) { while ( ! uncheckedGenes . isEmpty ( ) ) { GeneTrait currentGene = uncheckedGenes . remove ( 0 ) ; if ( currentGene instanceof ParentTrait ) { ParentTrait currentParent = ( ParentTrait ) currentGene ; for ( int i = 0 ; i < currentParent . getChildCount ( ) ; i ++ ) { GeneTrait currentChild = currentParent . getChild ( i ) ; if ( ! genes . contains ( currentChild ) ) { abaddon . growChild ( this , currentParent , i ) ; } } } } }
va	2	private long checkClientTimeouts ( int timeout ) { Set < Integer > disconnectedClientIds = new HashSet < Integer > ( ) ; long oldestClientCommunicationTime = - 1 ; synchronized ( CONNECTION_LOCK ) { if ( ! isRunning ) return - 1 ; long now = System . currentTimeMillis ( ) ; oldestClientCommunicationTime = now ; for ( Iterator < Integer > iter = clients . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { int clientId = iter . next ( ) ; ClientInfo client = clients . get ( clientId ) ; if ( client . getTimeOfLastCommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedClientIds . add ( clientId ) ; } else if ( client . getTimeOfLastCommunication ( ) < oldestClientCommunicationTime ) oldestClientCommunicationTime = client . getTimeOfLastCommunication ( ) ; } } for ( int clientId : disconnectedClientIds ) { logger . fine ( "Client " + clientId + " timed out" ) ; onClientDisconnected ( clientId , Server . CLIENT_TIMED_OUT ) ; } return oldestClientCommunicationTime ; }
va	1	public void addFAB ( NodeFAB f , boolean clear ) { if ( clear ) fabs . clear ( ) ; int numB = 5 ; fabs . add ( f . make ( ) ) ; for ( Node N : network ) { if ( clear ) { N . clearFABS ( ) ; } N . addFAB ( f . make ( ) ) ; N . initFAB ( N . getNumFab ( ) - 1 , 0 ) ; } }
va	3	public Instruction [ ] getMnemonics ( String mnemonic ) { Instruction [ ] temp = new Instruction [ binCode . size ( ) ] ; int c = 0 ; for ( int j = 0 ; j < binCode . size ( ) ; j ++ ) { if ( binCode . get ( j ) . getMnemonic ( ) . equalsIgnoreCase ( mnemonic ) ) temp [ c ++ ] = binCode . get ( j ) ; } int s = 0 ; for ( int j = 0 ; j < temp . length ; j ++ ) { if ( temp [ j ] != null ) s ++ ; } Instruction [ ] i = new Instruction [ s ] ; for ( int j = 0 ; j < i . length ; j ++ ) { i [ j ] = temp [ j ] ; } return i ; }
va	2	@ Override public void showHints ( int level ) { for ( int x = 1 ; x <= 16 ; x ++ ) { for ( int y = 1 ; y <= 16 ; y ++ ) { Point p = new Point ( x , y ) ; if ( ! isReadOnly ( p ) ) { BitSet markUp = getHints ( p , level ) ; if ( level == 0 ) { System . out . println ( String . format ( "(%s  %s) : %s" , x , y , markUp ) ) ; } else { System . out . println ( String . format ( "(%s  %s) : %s [%s]" , x , y , markUp , getHints ( p , 0 ) ) ) ; } } } } System . out . println ( ) ; }
va	2	public SchemeObject doWhile ( SchemeObject exp , SchemeObject env ) { SchemeObject predicate = whilePredicate ( exp ) ; SchemeObject body = whileBody ( exp ) ; SchemeObject result = SchemeObject . THE_EMPTY_LIST ; while ( SchemeObject . isTrue ( eval ( predicate , env ) ) ) { SchemeObject exps = body ; while ( ! isLastExp ( exps ) ) { eval ( firstExp ( exps ) , env ) ; exps = exps . getCdr ( ) ; } result = eval ( firstExp ( exps ) , env ) ; } return result ; }
va	0	public void setPrpMoaTipo ( String prpMoaTipo ) { this . prpMoaTipo = prpMoaTipo ; }
va	4X	public void MakeTorus ( double r ) { double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	1	public List < Expediente > getExpedientes ( Integer idFuncionario ) throws SQLException { List < Expediente > expedientes = new ArrayList < Expediente > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM expedientes WHERE idFuncionario = ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { Expediente expediente = new Expediente ( ) ; expediente . setId ( rs . getInt ( "id" ) ) ; expediente . setDiaSemana ( rs . getInt ( "DiaSemana" ) ) ; expedientes . add ( expediente ) ; } return expedientes ; }
va	1	@ Override public void tick ( ) { counter ++ ; if ( counter == tickDivider ) { counter = 0 ; if ( enemyUnits . size ( ) > 0 ) { Slime slime = new Slime ( ) ; rune . modifySlime ( slime ) ; for ( EnemyUnit enemy : enemyUnits ) { enemy . gotSlowed ( slime ) ; } } } }
va	1	public boolean contain ( Ticket ticket ) { if ( ! parkIsNull ( ) && park . contain ( ticket ) ) { return true ; } for ( ParkBoy boy : this . parkBoyList ) { if ( boy . contain ( ticket ) ) { return true ; } } return false ; }
va	0	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
va	3	private final ImmutableSet < ChessMovement > getPossibleMovements ( final ChessBoard board , final ChessColor turn ) { final ImmutableSet . Builder < ChessMovement > moves = ImmutableSet . builder ( ) ; for ( final ChessPiece piece : board . getAllPieces ( ) ) { if ( ! currentTurn . equals ( piece . getColor ( ) ) ) continue ; final Position from = board . getPositionFor ( piece ) ; if ( piece instanceof ChessBishop ) { for ( final Position to : ( ( ChessBishop ) piece ) . getMiniMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } else { for ( final Position to : piece . getStandardMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } } return moves . build ( ) ; }
va	1	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
va	4X	public void createRoster ( ) { Calendar today = ( Calendar ) startDate . clone ( ) ; int count ; for ( int i = 0 ; i < numberOfDays ; i ++ ) { count = 0 ; numberOfServices = getNumberOfServices ( today . getTime ( ) ) ; driversUsed = new driverUsed [ numberOfServices ] ; busesUsed = new busUsed [ numberOfServices ] ; getServices ( today ) ; packs [ i ] = new Pack [ numberOfServices ] ; for ( int j = 0 ; j < numberOfServices ; j ++ ) { packs [ i ] [ j ] = new Pack ( ) ; packs [ i ] [ j ] . serv = getNextService ( ) ; packs [ i ] [ j ] . driver_id = getLeastWorkingDriver ( drivers , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; packs [ i ] [ j ] . bus_id = getAvailableBus ( buses , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; int findDriver = 0 ; int findBus = 0 ; for ( int k = 0 ; k < drivers . length ; k ++ ) if ( packs [ i ] [ j ] . driver_id == drivers [ k ] ) { findDriver = k ; } for ( int k = 0 ; k < buses . length ; k ++ ) if ( packs [ i ] [ j ] . bus_id == buses [ k ] ) { findBus = k ; } minutesDriverWorked [ findDriver ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; minutesBusWorked [ findBus ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; } today . add ( Calendar . DAY_OF_MONTH , 1 ) ; driversUsedIndex = 0 ; busesUsedIndex = 0 ; } printPacks ( ) ; toDatabase ( packs ) ; }
va	3	protected void reindexFacesAndVertices ( ) { for ( int i = 0 ; i < numPoints ; i ++ ) { pointBuffer [ i ] . index = - 1 ; } numFaces = 0 ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark != Face . VISIBLE ) { it . remove ( ) ; } else { markFaceVertices ( face , 0 ) ; numFaces ++ ; } } numVertices = 0 ; for ( int i = 0 ; i < numPoints ; i ++ ) { Vertex vtx = pointBuffer [ i ] ; if ( vtx . index == 0 ) { vertexPointIndices [ numVertices ] = i ; vtx . index = numVertices ++ ; } } }
va	0	@ Override public IGameController getController ( ) { return controller ; }
va	4X	private static void method377 ( int ai [ ] , int i , int j , int l , int i1 ) { int k ; if ( aBoolean1462 ) { if ( i1 > DrawingArea . centerX ) i1 = DrawingArea . centerX ; if ( l < 0 ) l = 0 ; } if ( l >= i1 ) return ; i += l ; k = i1 - l >> 2 ; if ( anInt1465 == 0 ) { while ( -- k >= 0 ) { ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j ; return ; } int j1 = anInt1465 ; int k1 = 256 - anInt1465 ; j = ( ( j & ff00ff ) * k1 >> 8 & ff00ff ) + ( ( j & ff00 ) * k1 >> 8 & ff00 ) ; while ( -- k >= 0 ) { ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; }
va	0	public void setUpvote ( boolean upvote ) { this . upvote = upvote ; }
va	3	public static Document deepCloneDocument ( Document doc , DOMImplementation impl ) { Element root = doc . getDocumentElement ( ) ; Document result = impl . createDocument ( root . getNamespaceURI ( ) , root . getNodeName ( ) , null ) ; Element rroot = result . getDocumentElement ( ) ; boolean before = true ; for ( Node n = doc . getFirstChild ( ) ; n != null ; n = n . getNextSibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasAttributes ( ) ) { NamedNodeMap attr = root . getAttributes ( ) ; int len = attr . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setAttributeNode ( ( Attr ) result . importNode ( attr . item ( i ) , true ) ) ; } } for ( Node c = root . getFirstChild ( ) ; c != null ; c = c . getNextSibling ( ) ) { rroot . appendChild ( result . importNode ( c , true ) ) ; } } else { if ( n . getNodeType ( ) != Node . DOCUMENT_TYPE_NODE ) { if ( before ) { result . insertBefore ( result . importNode ( n , true ) , rroot ) ; } else { result . appendChild ( result . importNode ( n , true ) ) ; } } } } return result ; }
va	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
va	2	synchronized void update ( ) { int i , j ; for ( i = 0 ; i < getWidth ( ) ; i ++ ) for ( j = 0 ; j < getHeight ( ) ; j ++ ) getItem ( i , j ) . update ( ) ; }
va	0	public AddOrigen ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; }
va	0	public Logger getLogger ( ) { return this . logger ; }
va	3	@ Override public Object intercept ( Object obj , Method method , Object [ ] args , MethodProxy proxy ) throws Throwable { Object sourceResult = proxy . invokeSuper ( obj , args ) ; if ( sourceResult != null ) { return sourceResult ; } ConnectionHolder conn = null ; Object result = null ; try { conn = cm . getNewConnection ( ) ; for ( SelectModel s : select ) { if ( s . containsMethod ( method . getName ( ) ) ) { Object [ ] parameters = null ; SimpleProperty [ ] ps = s . getRefProperties ( ) ; if ( ps != null ) { parameters = new Object [ ps . length ] ; for ( int i = 0 ; i < ps . length ; i ++ ) { parameters [ i ] = ps [ i ] . invokeRead ( obj ) ; } } if ( s . isReturnList ( ) ) { result = localExecutor . selectList ( new SelectListContext ( s . getTargetType ( ) , s . getSql ( ) , s . getOffset ( ) , s . getLimit ( ) , parameters ) , conn ) ; SimpleProperty p = s . getProperty ( ) ; p . invokeWrite ( obj , result ) ; } else if ( s . isHasRef ( ) ) { Object [ ] propertyResult = ( Object [ ] ) localExecutor . selectOne ( new SelectContext ( Object [ ] . class , s . getSql ( ) , parameters ) , conn ) ; for ( int i = 0 ; i < propertyResult . length ; i ++ ) { SimpleProperty p = s . getProperty ( i + 1 ) ; if ( p . getReadName ( ) . equals ( method . getName ( ) ) ) { result = propertyResult [ i ] ; } p . invokeWrite ( obj , propertyResult [ i ] ) ; } } else { result = localExecutor . selectOne ( new SelectContext ( s . getTargetType ( ) , s . getSql ( ) , parameters ) , conn ) ; SimpleProperty p = s . getProperty ( ) ; p . invokeWrite ( obj , result ) ; } break ; } } } catch ( Exception e ) { throw new SQLException ( e ) ; } finally { if ( conn != null ) cm . releaseConnection ( conn ) ; } return result ; }
va	1	@ Override public Object [ ] [ ] getAll ( ) { DAOFactory factory = DAOFactory . getDAOFactory ( ) ; TeacherDAO dao = factory . getTeacherDAO ( ) ; List < Teacher > teachers = dao . selectAll ( ) ; Object [ ] [ ] rowData = new Object [ teachers . size ( ) ] [ 4 ] ; for ( int i = 0 ; i < teachers . size ( ) ; i ++ ) { Teacher teacher = teachers . get ( i ) ; rowData [ i ] [ 0 ] = teacher . getCode ( ) ; rowData [ i ] [ 1 ] = teacher . getNames ( ) ; rowData [ i ] [ 2 ] = dateFormatHelper . format ( teacher . getBirthday ( ) ) ; rowData [ i ] [ 3 ] = teacher . getEmail ( ) ; } return rowData ; }
va	0	public int getPeopleOnStation ( ) { return peopleOnStation ; }
va	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
va	1	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
va	3	private int buildHistory ( ColumnSet set , JPanel panel ) { NumberFormat formatter = new DecimalFormat ( "##.##" ) ; int numRows = getNumRows ( set ) ; int numChildren = getNumChildren ( set ) ; for ( int r = 0 ; r < numRows ; r ++ ) { Color backColor ; if ( r % 2 == 0 ) backColor = darkColor ; else backColor = lightColor ; int index = 0 ; for ( int p = 0 ; p < set . getNumParents ( ) ; p ++ ) { ColumnParent parent = set . getParent ( p ) ; for ( int c = 0 ; c < parent . getNumChildren ( ) ; c ++ ) { JPanel columnPanel = new JPanel ( ) ; JLabel columnLabel = new JLabel ( ) ; ColumnChild child = parent . getChild ( c ) ; String data = "" ; if ( r >= child . getNumData ( ) || child . getData ( r ) == null ) data = "" ; else data = child . getData ( r ) ; columnLabel . setText ( data ) ; columnLabel . setForeground ( Color . black ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; columnPanel . add ( columnLabel ) ; columnPanel . setBackground ( backColor ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnPanel , constraints ) ; panel . add ( columnPanel ) ; index ++ ; } } } return numRows ; }
va	1	private List < DirFiles > getDirWithFiles ( String dirPath ) { List < DirFiles > ls = new ArrayList < AnalRunner . DirFiles > ( ) ; for ( File f : getDirList ( dirPath ) ) { DirFiles dirFiles = new DirFiles ( f . getName ( ) ) ; dirFiles . addFileList ( getFileList ( f . getAbsolutePath ( ) ) ) ; ls . add ( dirFiles ) ; } return ls ; }
va	3	private static void updateMasterStackedStopList ( ) { StackedStopList ssl = StackedStopList . getInstance ( ) ; synchronized ( sStopsMap ) { ArrayList < Integer > ids = new ArrayList < > ( sStopsMap . keySet ( ) ) ; for ( int idKey : ids ) { ArrayList < ArrayList < StopAdapter >> nowStops = sStopsMap . get ( idKey ) ; if ( nowStops != null ) { for ( int o = 0 ; o < nowStops . size ( ) ; o ++ ) { ArrayList < StopAdapter > list = nowStops . get ( o ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { ssl . addStop ( list . get ( i ) ) ; } } } } } synchronized ( sMasterSSL ) { sMasterSSL . set ( ssl ) ; ssl . recycle ( ) ; } }
va	3	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
va	3	public void show ( ) { System . out . println ( "------------------------------------------------" ) ; System . out . println ( "| Sale Revenue Report By Month For Current Year |" ) ; System . out . println ( "------------------------------------------------" ) ; System . out . println ( ) ; for ( int month : salesBL . getMonthsOfCurrentYear ( ) ) { System . out . println ( "Month" ) ; System . out . println ( "=====" ) ; System . out . println ( getMonth ( month ) ) ; for ( Cineplex cp : salesBL . getCineplexes ( month ) ) { System . out . println ( "Cineplex\t\tMovie" ) ; System . out . println ( "--------\t\t-----" ) ; System . out . print ( cp . getCineplexName ( ) ) ; for ( Movie m : salesBL . getMoviesByCineplex ( month , cp ) ) { indiTakings = salesBL . getindiTakings ( month , m ) ; System . out . println ( "\t\t\t" + m . getTitle ( ) ) ; cineplexTakings += indiTakings ; } System . out . println ( ) ; } System . out . println ( "Individual takings: $" + Math . round ( cineplexTakings * 100.0 ) / 100.0 ) ; aggTakings += cineplexTakings ; cineplexTakings = 0.0f ; indiTakings = 0.0f ; System . out . println ( ) ; } System . out . println ( "________________________________________________________________" ) ; System . out . println ( "Aggregate takings: $" + Math . round ( aggTakings * 100.0 ) / 100.0 ) ; aggTakings = 0.0f ; }
va	4X	@ Override public void work ( ) { try { Vertex v = graph . getVertex ( source ) ; if ( v == null ) { print ( "Select a vertex" ) ; return ; } doFillVertex = true ; PairingHeap < Path > ph = new PairingHeap < Path > ( ) ; v . dist = 0 ; v . pos = ph . insert ( new Path ( v , v . dist ) ) ; int nodesSeen = 0 ; int nrSteps = 0 ; while ( ! ph . isEmpty ( ) && nodesSeen < graph . size ( ) ) { Path p = ph . deleteMin ( ) ; v = p . dest ; if ( v . visited ) { continue ; } v . visited = true ; nodesSeen ++ ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { nrSteps ++ ; Vertex w = e . dest ; int uwv = e . cost ; if ( w . dist > uwv + v . dist ) { e . eColor = Color . RED ; w . dist = uwv + v . dist ; w . prev = v ; Path newPath = new Path ( w , w . dist ) ; if ( w . pos == null ) { ph . insert ( newPath ) ; } else { ph . decreaseKey ( w . pos , newPath ) ; } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } } gui . console ( "Path cost: " + graph . getVertex ( dest ) . dist ) ; gui . console ( "Steps: " + nrSteps ) ; graph . resetGraphColors ( ) ; List < Vertex > shortestPath = new ArrayList < Vertex > ( ) ; Vertex vv = graph . getVertex ( dest ) ; while ( vv != null ) { shortestPath . add ( vv ) ; vv = vv . prev ; } for ( int i = shortestPath . size ( ) - 1 ; i >= 0 ; i -- ) { shortestPath . get ( i ) . vColor = Color . RED ; for ( Edge e : shortestPath . get ( i ) . adj ) { if ( i - 1 >= 0 && e . dest . equals ( shortestPath . get ( i - 1 ) ) ) { e . eColor = Color . RED ; break ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } sleep ( GUI_RESULT_PAUSE ) ; clearAll ( ) ; repaint ( ) ; } catch ( Exception e ) { } }
va	1	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
va	3	private void generateProblems ( StringBuilder builder , BookSettings settings , Map < String , List < String >> cached ) { int maxProblemColumns = settings . getProblemColumns ( ) ; int maxProblemRows = settings . getProblemRows ( ) ; int maxAnswerColumns = settings . getAnswerColumns ( ) ; int maxAnswerRows = settings . getAnswerRows ( ) ; for ( BookSettings . BookSection section : settings . getSections ( ) ) { StringBuilder problemPage = new StringBuilder ( ) ; StringBuilder problemRow = new StringBuilder ( ) ; StringBuilder problemRowComments = new StringBuilder ( ) ; StringBuilder answerPagesBuffer = new StringBuilder ( ) ; StringBuilder answerPage = new StringBuilder ( ) ; StringBuilder answerRow = new StringBuilder ( ) ; StringBuilder answerRowComments = new StringBuilder ( ) ; if ( section . getHeader ( ) != null ) { problemPage . append ( generateSubHeader ( section . getHeader ( ) ) ) ; answerPage . append ( generateSubHeader ( "Answers" , true ) ) ; } startPage ( problemPage , maxProblemColumns ) ; startPage ( answerPage , maxAnswerColumns ) ; int curProblemColumn = 0 ; int curProblemRow = 0 ; int curAnswerColumn = 0 ; int curAnswerRow = 0 ; int numAnswers = 0 ; int numProblems = 0 ; int totalNumProblems = 1 ; for ( String sgf : section . getProblems ( ) ) { List < String > generated = cached . get ( sgf ) ; String problem = generated . get ( 0 ) ; includeGraphics ( problemRow , problem ) ; addTableCell ( problemRow , curProblemColumn , maxProblemColumns ) ; includeComments ( problemRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( problem ) , totalNumProblems ) ) ; addTableCell ( problemRowComments , curProblemColumn , maxProblemColumns ) ; if ( curProblemColumn == maxProblemColumns - 1 ) { problemPage . append ( problemRow ) . append ( problemRowComments ) ; problemRow = new StringBuilder ( ) ; problemRowComments = new StringBuilder ( ) ; } curProblemColumn = ( curProblemColumn + 1 ) % maxProblemColumns ; numProblems ++ ; for ( int i = 1 ; i <= settings . getVarsPerProblem ( ) && i < generated . size ( ) ; i ++ ) { String answer = generated . get ( i ) ; includeGraphics ( answerRow , answer ) ; addTableCell ( answerRow , curAnswerColumn , maxAnswerColumns ) ; includeComments ( answerRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( answer ) , totalNumProblems ) ) ; addTableCell ( answerRowComments , curAnswerColumn , maxAnswerColumns ) ; if ( curAnswerColumn == maxAnswerColumns - 1 ) { answerPage . append ( answerRow ) . append ( answerRowComments ) ; answerRow = new StringBuilder ( ) ; answerRowComments = new StringBuilder ( ) ; } curAnswerColumn = ( curAnswerColumn + 1 ) % maxAnswerColumns ; numAnswers ++ ; if ( numAnswers == maxAnswerRows * maxAnswerColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; answerPage = startNewPage ( maxAnswerColumns ) ; numAnswers = 0 ; } } totalNumProblems ++ ; if ( numProblems == maxProblemRows * maxProblemColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; finishPageWithTrailer ( builder , problemPage ) ; finishPage ( builder , answerPagesBuffer ) ; answerPage = startNewPage ( maxAnswerColumns ) ; problemPage = startNewPage ( maxProblemColumns ) ; answerPagesBuffer = new StringBuilder ( ) ; numProblems = 0 ; numAnswers = 0 ; } } if ( answerPage . length ( ) != 0 ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; } if ( problemPage . length ( ) != 0 ) { finishPageWithTrailer ( builder , problemPage ) ; } finishPage ( builder , answerPagesBuffer ) ; } }
va	2	public void removeConnectionFromChans ( Connection connection ) { List < Chan > emptyChans = new ArrayList < Chan > ( ) ; for ( Chan chan : chans . values ( ) ) { chan . getConnections ( ) . remove ( connection ) ; if ( chan . getConnections ( ) . size ( ) == 0 ) { emptyChans . add ( chan ) ; } } for ( Chan rmChan : emptyChans ) { chans . remove ( rmChan ) ; } }
va	4X	public String toString ( ) { NumberFormat nf = NumberFormat . getCurrencyInstance ( Locale . US ) ; StringBuilder buffer = new StringBuilder ( ) ; int caracteres = 50 ; String adorno = ":_-_:" ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\t\tBALANCE DE COMPROBACI\u00D3N\t\t\n" ) ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\n" ) ; while ( balance . size ( ) > 0 ) { buffer . append ( balance . peek ( ) . codigo + "  " + balance . peek ( ) . nombre ) ; CuentaT temp = balance . pollFirst ( ) ; if ( temp . saldo > 0 ) { double debe = temp . saldo ; totalDebe += debe ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t" + nf . format ( debe ) ) ; } else if ( temp . nombre . length ( ) > 15 ) { buffer . append ( "\t" + nf . format ( debe ) ) ; } else { buffer . append ( "\t\t\t" + nf . format ( debe ) ) ; } } else { double haber = temp . saldo * - 1 ; totalHaber += haber ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) > 15 && temp . nombre . length ( ) < 25 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) >= 25 ) { buffer . append ( "\t\t\t" + nf . format ( haber ) ) ; } else { buffer . append ( "\t\t\t\t\t" + nf . format ( haber ) ) ; } } buffer . append ( "\n" ) ; } for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( "-----" ) ; } buffer . append ( "\n" ) ; buffer . append ( "\t\t\t" + nf . format ( totalDebe ) + "\t" + nf . format ( totalHaber ) ) ; return buffer . toString ( ) ; }
va	1	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
va	4X	private void updatePermissions ( ) { bukkitPermissions = new LinkedHashMap < String , Permission > ( ) ; if ( subgroups == null ) { subgroups = new ArrayList < String > ( ) ; } if ( ! permissions . containsKey ( Config . getDefaultWorld ( ) ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + Config . getDefaultWorld ( ) , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; Permission permission = new Permission ( "droxperms.meta.group." + name + "." + Config . getDefaultWorld ( ) , "Group-Permissions for group " + name + " on world " + Config . getDefaultWorld ( ) , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( Config . getDefaultWorld ( ) , permission ) ; } for ( String world : Config . getWorlds ( ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + world , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; if ( permissions . get ( world ) != null ) { children . putAll ( permissions . get ( world ) ) ; } Permission permission = new Permission ( "droxperms.meta.group." + name + "." + world , "Group-Permissions for group " + name + " on world " + world , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( world , permission ) ; } Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup , true ) ; } children . putAll ( globalPermissions ) ; Permission permission = new Permission ( "droxperms.meta.group." + name , "Group-Permissions for group " + name , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; }
va	4X	private void findRecipes ( ) { listModel . clear ( ) ; TreeMap < Integer , SortedSet < Recipe >> recipeMap = new TreeMap < > ( ) ; Set < Ingredient > matchingIngredients = new HashSet < > ( customIngredients ) ; for ( CheckBoxWithIngredient cb : checkBoxes ) { if ( cb . isChecked ( ) ) { matchingIngredients . add ( cb . getIngredient ( ) ) ; } } for ( Recipe recipe : allRecipes ) { Set < Ingredient > recipeIngredients = new HashSet < > ( ) ; for ( RecipeSection section : recipe . getSections ( ) ) { for ( RecipeIngredient rIngredient : section . getIngredients ( ) ) { Ingredient ingredient = rIngredient . getIngredient ( ) ; if ( ! ingredient . isCommon ( ) ) { recipeIngredients . add ( ingredient ) ; } } } recipeIngredients . removeAll ( matchingIngredients ) ; int numberOfMissingIngredients = recipeIngredients . size ( ) ; if ( recipeMap . get ( numberOfMissingIngredients ) == null ) { recipeMap . put ( numberOfMissingIngredients , new TreeSet < Recipe > ( ) ) ; } recipeMap . get ( numberOfMissingIngredients ) . add ( recipe ) ; } for ( int i : recipeMap . keySet ( ) ) { for ( Recipe recipe : recipeMap . get ( i ) ) { listModel . addElement ( recipe ) ; } } int leastMissingIngredients = recipeMap . firstKey ( ) ; Recipe bestRecipe = recipeMap . get ( leastMissingIngredients ) . first ( ) ; String message = "The best matching recipe is '" + bestRecipe + "' which is missing " + leastMissingIngredients + " ingredient" ; if ( leastMissingIngredients != 1 ) { message = message + "s" ; } JOptionPane . showMessageDialog ( panel , message , "Best matching recipe" , JOptionPane . INFORMATION_MESSAGE ) ; }
va	4X	public static void main ( String args [ ] ) throws IOException { Scanner obj = new Scanner ( System . in ) ; System . out . print ( " " ) ; int n = obj . nextInt ( ) ; int m = obj . nextInt ( ) ; int p = obj . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i ] [ j ] = j ; } } while ( p -- > 0 ) { int i = obj . nextInt ( ) ; int j = obj . nextInt ( ) ; arr [ i - 1 ] [ j - 1 ] += 1 ; } for ( int i = 0 ; i < m ; ++ i ) { int j ; for ( j = m - 1 ; j > 0 ; -- j ) { if ( arr [ i ] [ j ] >= arr [ i ] [ j - 1 ] ) { brr [ i ] += arr [ i ] [ j ] - arr [ i ] [ j - 1 ] ; } else { break ; } } if ( j != 0 ) { brr [ i ] = - 1 ; } } for ( int i = 0 ; i < n ; ++ i ) { System . out . println ( brr [ i ] ) ; } }
va	1	public boolean noun2Modifier ( DataHolder dataholderHandler , String word ) { boolean isUpdated = false ; ArrayList < String > deletedPOSs = new ArrayList < String > ( ) ; deletedPOSs . add ( "s" ) ; deletedPOSs . add ( "p" ) ; deletedPOSs . add ( "n" ) ; for ( String POS : deletedPOSs ) { dataholderHandler . deleteWordPOS ( true , word , true , POS ) ; } dataholderHandler . updateDataHolder ( word , "m" , "" , "modifiers" , 1 ) ; String oldPattern = String . format ( "(^%s$|^.* %s$)" , word , word ) ; dataholderHandler . updateSentenceTag ( oldPattern , null ) ; return isUpdated ; }
va	1	public Map < String , Map < String , Object >> loadAsMap ( String key ) throws IOException { Map < String , Map < String , Object >> map = new HashMap < String , Map < String , Object >> ( ) ; LineIterator iterator = new LineIterator ( new FileReader ( file ) ) ; while ( iterator . hasNext ( ) ) { Map < String , Object > json = JsonOutput . MAPPER . readValue ( iterator . nextLine ( ) , Map . class ) ; if ( json . containsKey ( key ) ) { map . put ( json . get ( key ) . toString ( ) , json ) ; } } return map ; }
va	1	public int anotaClase ( String idProf , String idProfReal , int idHoras , ArrayList < Integer > grupAsigInClass ) { int nup = 0 ; Iterator it = grupAsigInClass . iterator ( ) ; while ( it . hasNext ( ) ) { int idgrupasig = ( ( Number ) it . next ( ) ) . intValue ( ) ; nup += new ClasesAnotadas ( idProf , idProfReal , idHoras , idgrupasig , client ) . save ( ) ; } return nup ; }
va	3	public static double [ ] decode ( String geohash ) { StringBuilder buffer = new StringBuilder ( ) ; for ( char c : geohash . toCharArray ( ) ) { int i = lookup . get ( c ) + 32 ; buffer . append ( Integer . toString ( i , 2 ) . substring ( 1 ) ) ; } BitSet lonset = new BitSet ( ) ; BitSet latset = new BitSet ( ) ; int j = 0 ; for ( int i = 0 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; lonset . set ( j ++ , isSet ) ; } j = 0 ; for ( int i = 1 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; latset . set ( j ++ , isSet ) ; } double lon = decode ( lonset , - 180 , 180 ) ; double lat = decode ( latset , - 90 , 90 ) ; return new double [ ] { lat , lon } ; }
va	4X	public static void main ( String [ ] args ) { long [ ] lastRow = new long [ 1 ] ; lastRow [ 0 ] = 1 ; for ( int i = 1 ; i <= SIZE ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < lastRow . length ; j ++ ) nextRow [ j ] = ( lastRow [ j - 1 ] + lastRow [ j ] ) % 1000000000000 ; lastRow = nextRow ; } int count = 0 ; long [ ] currentRow = new long [ 1 ] ; currentRow [ 0 ] = 1 ; for ( int i = 1 ; i < lastRow . length ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < currentRow . length ; j ++ ) nextRow [ j ] = ( currentRow [ j - 1 ] + currentRow [ j ] ) % 1000000000000 ; currentRow = nextRow ; long multiplier = lastRow [ i - 1 ] ; int initialTwos = numTwos ( multiplier ) ; int initialFives = numFives ( multiplier ) ; for ( int j = 0 ; j < nextRow . length ; j ++ ) { int twos = numTwos ( nextRow [ j ] ) ; int fives = numFives ( nextRow [ j ] ) ; if ( initialTwos + twos >= 12 && initialFives + fives >= 12 ) count ++ ; } } System . out . print ( count ) ; }
va	0	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
va	3	public boolean applyTechniqueRulesetConstriction ( ) { boolean appliedTechnique = false ; Iterator < Integer > emptyElementIterator = emptyElements . iterator ( ) ; while ( emptyElementIterator . hasNext ( ) && ! appliedTechnique ) { int nextEmptyElement = emptyElementIterator . next ( ) ; Set < Integer > recalculatedValidElements = getValidValuesForElementWithNumber ( nextEmptyElement ) ; for ( int relatedElement : getRelatedElementNumbersForElementWithNumber ( nextEmptyElement ) ) { if ( elementWithNumberIsEmpty ( relatedElement ) ) { recalculatedValidElements . removeAll ( getValidValuesForElementWithNumber ( relatedElement ) ) ; } else { recalculatedValidElements . remove ( getElementWithNumber ( nextEmptyElement ) ) ; } } if ( recalculatedValidElements . size ( ) != 0 ) { Set < Integer > elementsToRemove = getValidValuesForElementWithNumber ( nextEmptyElement ) ; elementsToRemove . removeAll ( recalculatedValidElements ) ; for ( int elementToRemove : elementsToRemove ) { this . removeValueForElementWithNumber ( nextEmptyElement , elementToRemove ) ; } appliedTechnique = true ; } } return appliedTechnique ; }
va	4X	public void method545 ( Stream stream , Class29 class29 ) { int i = stream . readUnsignedByte ( ) ; anIntArray665 [ 0 ] = i >> 4 ; anIntArray665 [ 1 ] = i & f ; if ( i != 0 ) { anIntArray668 [ 0 ] = stream . readUnsignedWord ( ) ; anIntArray668 [ 1 ] = stream . readUnsignedWord ( ) ; int j = stream . readUnsignedByte ( ) ; for ( int k = 0 ; k < 2 ; k ++ ) { for ( int l = 0 ; l < anIntArray665 [ k ] ; l ++ ) { anIntArrayArrayArray666 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; } } for ( int i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( int j1 = 0 ; j1 < anIntArray665 [ i1 ] ; j1 ++ ) if ( ( j & 1 << i1 * 4 << j1 ) != 0 ) { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; } else { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray666 [ i1 ] [ 0 ] [ j1 ] ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray667 [ i1 ] [ 0 ] [ j1 ] ; } } if ( j != 0 || anIntArray668 [ 1 ] != anIntArray668 [ 0 ] ) class29 . method326 ( stream ) ; } else { anIntArray668 [ 0 ] = anIntArray668 [ 1 ] = 0 ; } }
va	4X	public void dumpCSV ( String fName , String sep , HackFilter ... filters ) throws IOException { LinkedHashSet < String > patterns = new LinkedHashSet < > ( ) ; LinkedHashSet < String > rares = new LinkedHashSet < > ( ) ; outerloop1 : for ( HackResult hackResult : allHacks ) { for ( HackFilter fi : filters ) if ( ! fi . accept ( hackResult ) ) continue outerloop1 ; String pat = smallPattern ( hackResult ) ; patterns . add ( pat ) ; List < String > items = rareItems ( hackResult ) ; rares . addAll ( items ) ; } PrintWriter pw = new PrintWriter ( new FileWriter ( new File ( fName ) ) ) ; pw . print ( "# " ) ; for ( HackFilter f : filters ) pw . print ( " " + f . toString ( ) ) ; pw . println ( ) ; pw . print ( "# " ) ; for ( String s : patterns ) pw . print ( " " + s ) ; pw . print ( "  " ) ; for ( String s : rares ) pw . print ( " " + s ) ; pw . println ( ) ; outerloop2 : for ( HackResult hackResult : allHacks ) { for ( HackFilter fi : filters ) if ( ! fi . accept ( hackResult ) ) continue outerloop2 ; String pat = smallPattern ( hackResult ) ; List < String > items = rareItems ( hackResult ) ; pw . print ( String . format ( "%10.0f" , hackResult . timestamp ) ) ; for ( String s : patterns ) { pw . print ( sep ) ; pw . print ( pat . equals ( s ) ? 1 : 0 ) ; } pw . print ( "  " ) ; for ( String s : rares ) { pw . print ( sep ) ; pw . print ( items . contains ( s ) ? 1 : 0 ) ; } pw . println ( ) ; } pw . close ( ) ; L . info ( "Finished <" + fName + ">." ) ; }
va	2	public static Texture [ ] [ ] replaceColors ( Texture [ ] [ ] textures , int [ ] fromColors , int [ ] toColors ) { if ( textures . length == 0 ) return null ; Texture [ ] [ ] newTextures = new Texture [ textures . length ] [ textures [ 1 ] . length ] ; for ( int i = 0 ; i < textures . length ; i ++ ) for ( int j = 0 ; j < textures [ 1 ] . length ; j ++ ) newTextures [ i ] [ j ] = textures [ i ] [ j ] . replaceColors ( fromColors , toColors ) ; return newTextures ; }
va	4X	public KeySettingsDialog ( KeySettings oldSettings , EventBusService eventBusService ) { eventBusService . register ( this ) ; KeySettingsController controller = new KeySettingsController ( this , oldSettings , eventBusService ) ; textFieldMapping = new HashMap < ColourType , JTextField > ( ) ; changeButtonMapping = new HashMap < ColourType , JButton > ( ) ; colourBoxMapping = new HashMap < ColourType , JPanel > ( ) ; for ( ColourType colour : ColourType . values ( ) ) { JPanel boxPanel = new JPanel ( ) ; boxPanel . setBackground ( SystemProperties . COLOUR_MAP . get ( colour ) ) ; boxPanel . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; boxPanel . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; colourBoxMapping . put ( colour , boxPanel ) ; JTextField field = new JTextField ( String . valueOf ( oldSettings . getColorKey ( colour ) . getKeyCharacter ( ) ) ) ; field . setEditable ( false ) ; field . setPreferredSize ( new Dimension ( 70 , 30 ) ) ; field . setHorizontalAlignment ( SwingConstants . CENTER ) ; field . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; textFieldMapping . put ( colour , field ) ; JButton changeButton = new JButton ( ae + "ndern" ) ; changeButton . setActionCommand ( colour . getColourTypeName ( ) ) ; changeButton . addActionListener ( controller ) ; changeButtonMapping . put ( colour , changeButton ) ; } this . colourPanel = new JPanel ( ) ; this . keyFieldPanel = new JPanel ( ) ; this . changeKeyPanel = new JPanel ( ) ; this . cancelButton = new JButton ( "Abbrechen" ) ; this . cancelButton . setActionCommand ( "CANCEL" ) ; this . cancelButton . addActionListener ( controller ) ; this . acceptButton = new JButton ( Ue + "bernehmen" ) ; this . acceptButton . setActionCommand ( "ACCEPT" ) ; this . acceptButton . addActionListener ( controller ) ; this . defaultButton = new JButton ( "Zur" + ue + "cksetzen" ) ; this . defaultButton . setActionCommand ( "DEFAULT" ) ; this . defaultButton . addActionListener ( controller ) ; this . colourPanel . setLayout ( new GridLayout ( 6 , 1 , 5 , 10 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . colourPanel . add ( colourBoxMapping . get ( colour ) ) ; } this . keyFieldPanel . setLayout ( new GridLayout ( 6 , 1 , 5 , 10 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . keyFieldPanel . add ( textFieldMapping . get ( colour ) ) ; } this . changeKeyPanel . setLayout ( new GridLayout ( 6 , 1 , 0 , 17 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . changeKeyPanel . add ( changeButtonMapping . get ( colour ) ) ; } this . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 5 , 0 , 5 ) ; this . add ( this . colourPanel , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . add ( this . keyFieldPanel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new Insets ( 15 , 15 , 15 , 15 ) ; c . fill = GridBagConstraints . HORIZONTAL ; this . add ( this . changeKeyPanel , c ) ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new Insets ( 30 , 5 , 0 , 5 ) ; this . add ( this . acceptButton , c ) ; c . gridx = 1 ; c . gridy = 1 ; c . insets = new Insets ( 30 , 5 , 0 , 5 ) ; this . add ( this . defaultButton , c ) ; c . gridx = 2 ; c . gridy = 1 ; this . add ( this . cancelButton , c ) ; this . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; this . setResizable ( false ) ; this . setTitle ( "Tastatureinstellungen" ) ; this . setModal ( true ) ; this . setSize ( 370 , 370 ) ; this . setLocation ( ( SystemProperties . SCREEN_WIDTH / 2 ) - 185 , ( SystemProperties . SCREEN_HEIGHT / 2 ) - 185 ) ; }
va	0	public ShareItem ( ) { }
va	1	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
va	4X	public void method471 ( int ai [ ] , int j , int k ) { if ( k == - 1 ) return ; if ( ai == null || j == - 1 ) { method470 ( k ) ; return ; } Class36 class36 = Class36 . method531 ( k ) ; if ( class36 == null ) return ; Class36 class36_1 = Class36 . method531 ( j ) ; if ( class36_1 == null ) { method470 ( k ) ; return ; } Class18 class18 = class36 . aClass18_637 ; anInt1681 = 0 ; anInt1682 = 0 ; anInt1683 = 0 ; int l = 0 ; int i1 = ai [ l ++ ] ; for ( int j1 = 0 ; j1 < class36 . anInt638 ; j1 ++ ) { int k1 ; for ( k1 = class36 . anIntArray639 [ j1 ] ; k1 > i1 ; i1 = ai [ l ++ ] ) ; if ( k1 != i1 || class18 . anIntArray342 [ k1 ] == 0 ) method472 ( class18 . anIntArray342 [ k1 ] , class18 . anIntArrayArray343 [ k1 ] , class36 . anIntArray640 [ j1 ] , class36 . anIntArray641 [ j1 ] , class36 . anIntArray642 [ j1 ] ) ; } anInt1681 = 0 ; anInt1682 = 0 ; anInt1683 = 0 ; l = 0 ; i1 = ai [ l ++ ] ; for ( int l1 = 0 ; l1 < class36_1 . anInt638 ; l1 ++ ) { int i2 ; for ( i2 = class36_1 . anIntArray639 [ l1 ] ; i2 > i1 ; i1 = ai [ l ++ ] ) ; if ( i2 == i1 || class18 . anIntArray342 [ i2 ] == 0 ) method472 ( class18 . anIntArray342 [ i2 ] , class18 . anIntArrayArray343 [ i2 ] , class36_1 . anIntArray640 [ l1 ] , class36_1 . anIntArray641 [ l1 ] , class36_1 . anIntArray642 [ l1 ] ) ; } }
va	0	private Vector < Arete > ajoute ( int p , Vector < Arete > v ) { DoubletVect < Arete > dVect = separe ( ens . elementAt ( p ) , v ) ; int [ ] tab = compte ( dVect . v1 , p ) ; Vector < Arete > vEnPlus = nouvellesAretes ( p , tab , p ) ; return concat ( dVect . v2 , vEnPlus ) ; }
va	3	private String getShipLocationDifference ( HashMap < String , List < BoardLocation >> otherShipLocations ) throws Exception { String a = "\n" ; if ( ! otherShipLocations . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : otherShipLocations . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } } for ( String k : otherShipLocations . keySet ( ) ) { if ( ! otherShipLocations . get ( k ) . equals ( playerShipLocations . get ( k ) ) ) { a = a . concat ( k + ":" + getListBoardLocationsDifference ( playerShipLocations . get ( k ) , otherShipLocations . get ( k ) ) + "\n" ) ; } } return a ; }
va	0	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
va	2	public void run ( ) { for ( int i = 0 ; i < 100 ; i ++ ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException exception ) { } Integer [ ] snapshot = buffer . snapshot ( ) ; assert snapshot . length > 18 : "Larger trim than expected!: " + snapshot . length ; assert snapshot . length <= 20 : "Buffer is too large: " + snapshot . length ; for ( int j = 0 ; j < snapshot . length ; j ++ ) { if ( snapshot [ j ] == null ) { assert false : "Found uninitialized value in snapshot: " + j + ":\n" + Arrays . toString ( snapshot ) ; } } assert snapshot [ 0 ] < snapshot [ snapshot . length - 1 ] : "Values do not appear to be coming out in order" ; Thread . yield ( ) ; } }
va	1	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
va	3	public List < Dimension > getAllIndicatorDimensions ( String keyFamilyId ) { List < Dimension > dimensions = new ArrayList < Dimension > ( ) ; List < String > addedDimensions = new ArrayList < String > ( ) ; for ( LocalizedString indicatorName : getIndicatorNames ( keyFamilyId ) ) { List < DimensionWrapper > dimensionHierarchy = getDimensionHierarchy ( indicatorName . getDefaultStr ( ) , keyFamilyId ) ; if ( dimensionHierarchy != null ) { for ( DimensionWrapper dw : dimensionHierarchy ) { List < Dimension > hierarchyDimensions = dw . getAllDimensions ( ) ; for ( Dimension d : hierarchyDimensions ) { if ( ! addedDimensions . contains ( d . getConceptRef ( ) ) ) { dimensions . add ( d ) ; addedDimensions . add ( d . getConceptRef ( ) ) ; } } } } } return dimensions ; }
va	3	public void convert ( IDChanger UI , HashMap < BlockUID , BlockUID > translations , PluginLoader pluginLoader ) { Status status = UI . status ; status . changedChest = 0 ; status . changedPlaced = 0 ; status . changedPlayer = 0 ; int count_file = 0 ; long beginTime = System . currentTimeMillis ( ) ; status . pb_file . setMaximum ( playerFiles . size ( ) - 1 ) ; ArrayList < ConverterPlugin > regionPlugins = pluginLoader . getPluginsOfType ( PluginType . REGION ) ; ArrayList < ConverterPlugin > playerPlugins = pluginLoader . getPluginsOfType ( PluginType . PLAYER ) ; for ( PlayerFile playerFile : playerFiles ) { status . pb_file . setValue ( count_file ++ ) ; status . lb_file . setText ( "Current File: " + playerFile . getName ( ) ) ; DataInputStream dis = null ; DataOutputStream dos = null ; try { dis = new DataInputStream ( new BufferedInputStream ( new GZIPInputStream ( new FileInputStream ( playerFile ) ) ) ) ; CompoundTag root = NbtIo . read ( dis ) ; for ( ConverterPlugin plugin : playerPlugins ) { plugin . convert ( status , root , translations ) ; } dos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( playerFile ) ) ) ; NbtIo . writeCompressed ( root , dos ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert player inventories" , e ) ; return ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close output stream" , e ) ; } } if ( dis != null ) { try { dis . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close input stream" , e ) ; } } } } count_file = 0 ; if ( regionFiles == null ) { return ; } status . pb_file . setValue ( 0 ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; for ( RegionFileExtended r : regionFiles ) { status . lb_file . setText ( "Current File: " + r . fileName . getName ( ) ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; status . pb_file . setValue ( count_file ++ ) ; try { r . convert ( status , translations , regionPlugins ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert placed blocks" , e ) ; return ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close region file" , e ) ; } } } } long duration = System . currentTimeMillis ( ) - beginTime ; JOptionPane . showMessageDialog ( UI , "Done in " + duration + "ms" + System . getProperty ( "line.separator" ) + status . changedPlaced + " placed blocks changed." + System . getProperty ( "line.separator" ) + status . changedPlayer + " blocks in player inventories changed." + System . getProperty ( "line.separator" ) + status . changedChest + " blocks in entity inventories changed." , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; }
va	2	public LlvmValue visit ( ClassDeclSimple n ) { classes . put ( n . name . s , new ClassNode ( n . name . s ) ) ; SetClassInUse ( n . name . s ) ; List < LlvmType > listaTipos = new LinkedList < LlvmType > ( ) ; for ( util . List < VarDecl > v = n . varList ; v != null ; v = v . tail ) { LlvmValue field = v . head . accept ( this ) ; GetClassInUse ( ) . AddField ( field . toString ( ) , field . type ) ; listaTipos . add ( field . type ) ; } GetClassInUse ( ) . AddClassType ( new LlvmStructure ( listaTipos ) ) ; for ( util . List < MethodDecl > m = n . methodList ; m != null ; m = m . tail ) { m . head . accept ( this ) ; } classEnv = null ; methodEnv = null ; return null ; }
va	2	public void setCellScoresMatrix ( ) { int r , c , sc ; char cS1 , cS2 ; ScoredCellElement tmpCell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cS1 = m_s1 . charAt ( c ) ; cS2 = m_s1 . charAt ( r ) ; tmpCell = ( ScoredCellElement ) m_dpTable . getCell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpCell . setScoreVal ( m_scoreHash . getScore ( cS1 , cS2 ) ) ; } else { tmpCell . setColor ( Color . BLACK ) ; } } } }
va	4X	public static Graph < Vertex , Edge > convert ( String name , String json ) { Graph < Vertex , Edge > result = new Graph < Vertex , Edge > ( Edge . class ) ; Gson gson = new Gson ( ) ; Wrapper data = gson . fromJson ( json , Wrapper . class ) ; for ( ChildShapes pools : data . childShapes ) { if ( pools . childShapes . size ( ) > 0 ) { createGraph ( result , pools . childShapes , TASK_LEVEL ) ; } else { if ( pools . stencil != null && pools . stencil . id != null && pools . stencil . id . contains ( "Flow" ) ) { for ( Outgoing out : pools . outgoing ) if ( result . vertexIDRef . containsKey ( out . resourceId ) ) { TreeMap < String , Vertex > pair = new TreeMap < String , Vertex > ( ) ; pair . put ( "trg" , result . vertexRef . get ( result . vertexIDRef . get ( out . resourceId ) ) ) ; edges . put ( pools . resourceId , pair ) ; } } } } for ( String key : vedges . keySet ( ) ) { for ( String s : vedges . get ( key ) ) { if ( edges . containsKey ( s ) ) { if ( result . vertexIDRef . containsKey ( key ) ) { edges . get ( s ) . put ( "src" , result . vertexRef . get ( result . vertexIDRef . get ( key ) ) ) ; } } } } for ( String key : edges . keySet ( ) ) { if ( edges . get ( key ) . containsKey ( "src" ) && edges . get ( key ) . containsKey ( "trg" ) ) { Edge e = new Edge ( edges . get ( key ) . get ( "src" ) , edges . get ( key ) . get ( "trg" ) ) ; result . addE ( e ) ; } else { } } return result ; }
va	2	public void testNorthwindDrools ( ) throws Exception { Engine engine = new Engine ( ) ; StatefulKnowledgeSession session = engine . getKnowledgeSession ( RESOURCE_FILE_NAME ) ; PropertiesLoader props = PropertiesLoaderFactory . getPropertiesLoader ( "northwind_queries.properties" ) ; Set < String > keys = props . getProperties ( ) . stringPropertyNames ( ) ; Map < String , SqlQuery > args = new HashMap < > ( ) ; for ( Iterator < String > it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String ds = DAOConstants . NORTHWIND ; String queryName = it . next ( ) ; SqlQuery query = new SqlQuery ( props . getProperty ( queryName ) , ds ) ; args . put ( queryName , query ) ; } IDynamicDAO dao = DAOFactory . getDynamicDAO ( args ) ; session . setGlobal ( "dao" , dao ) ; Response response = new Response ( ) ; session . setGlobal ( "response" , response ) ; session . fireAllRules ( ) ; ObjectFilter filter = new MatchFilter ( ) ; Collection < FactHandle > factHandles = session . getFactHandles ( filter ) ; Iterator < FactHandle > factHandleIterator = factHandles . iterator ( ) ; while ( factHandleIterator . hasNext ( ) ) { System . out . println ( "Found " + ( session . getObject ( factHandleIterator . next ( ) ) ) ) ; } System . out . println ( "Response : " + response ) ; session . dispose ( ) ; }
va	4X	private void initMenuBar ( ) { JMenuBar menuBar = new JMenuBar ( ) ; JMenu mnFile = new JMenu ( "File" ) ; { JMenuItem mntmRestart = new JMenuItem ( "Restart" ) ; mntmRestart . setEnabled ( ! clientMode ) ; mntmRestart . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . fine ( "Restarting game" ) ; initialize ( ) ; reset ( ) ; } } ) ; mnFile . add ( mntmRestart ) ; JMenuItem mntmExit = new JMenuItem ( "Exit" ) ; mntmExit . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } ) ; mnFile . add ( mntmExit ) ; } menuBar . add ( mnFile ) ; JMenu mnConfig = new JMenu ( "Config" ) ; { mnConfig . setEnabled ( ! clientMode ) ; ButtonGroup algorithmGroup = new ButtonGroup ( ) ; int idx = 0 ; for ( SortAlgorithm < ? > sort : config . getAllAlgorithms ( ) ) { final int index = idx ++ ; final JMenuItem item = new JRadioButtonMenuItem ( sort . toString ( ) ) ; item . setSelected ( config . getAlgorithm ( ) . equals ( sort ) ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Set algorithm to " + config . getAllAlgorithms ( ) . get ( index ) ) ; config = Configuration . deriveWithNewSortIdx ( config , index ) ; initCards ( ) ; reset ( ) ; } } ) ; mnConfig . add ( item ) ; algorithmGroup . add ( item ) ; } mnConfig . add ( new JSeparator ( ) ) ; JMenu mnSize = new JMenu ( "Number of cards" ) ; { ButtonGroup sizeGroup = new ButtonGroup ( ) ; for ( int i = MIN_SIZE ; i <= MAX_SIZE ; i ++ ) { final int newSize = i ; JMenuItem item = new JRadioButtonMenuItem ( Integer . toString ( newSize ) ) ; item . setSelected ( i == size ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed size to " + newSize ) ; config = Configuration . deriveWithNewSize ( config , newSize ) ; initCards ( ) ; initialize ( ) ; } } ) ; sizeGroup . add ( item ) ; mnSize . add ( item ) ; } } mnConfig . add ( mnSize ) ; JMenu mnType = new JMenu ( "Value type" ) ; { final ButtonGroup typeGroup = new ButtonGroup ( ) ; final ValueType [ ] types = ValueType . values ( ) ; for ( int i = 0 ; i < types . length ; i ++ ) { final ValueType type = types [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( type . toString ( ) ) ; item . setSelected ( type == config . type ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed type to " + type ) ; config = Configuration . deriveWithNewType ( config , type ) ; initCards ( ) ; initialize ( ) ; } } ) ; typeGroup . add ( item ) ; mnType . add ( item ) ; } } mnConfig . add ( mnType ) ; JMenu mnMode = new JMenu ( "Values" ) ; { final ButtonGroup kindGroup = new ButtonGroup ( ) ; final ValueMode [ ] modes = ValueMode . values ( ) ; for ( int i = 0 ; i < modes . length ; i ++ ) { final ValueMode mode = modes [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( mode . toString ( ) ) ; item . setSelected ( mode == config . mode ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed mode to " + mode ) ; config = Configuration . deriveWithNewMode ( config , mode ) ; initCards ( ) ; initialize ( ) ; } } ) ; kindGroup . add ( item ) ; mnMode . add ( item ) ; } } mnConfig . add ( mnMode ) ; } menuBar . add ( mnConfig ) ; frame . setJMenuBar ( menuBar ) ; }
va	2	private void mostrarCidades ( List < Cidades > cidades ) { while ( tmCidades . getRowCount ( ) > 0 ) { tmCidades . removeRow ( 0 ) ; } if ( cidades . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Nenhuma cidade encontrada!" , "Erro de Busca" , JOptionPane . ERROR_MESSAGE , icones . getIconeErro ( ) ) ; } else { String [ ] campos = new String [ ] { null , null , null , null } ; for ( int i = 0 ; i < cidades . size ( ) ; i ++ ) { tmCidades . addRow ( campos ) ; tmCidades . setValueAt ( cidades . get ( i ) . getCodigo ( ) , i , 0 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getNome ( ) , i , 1 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getUf ( ) , i , 2 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getDdd ( ) , i , 3 ) ; } } }
va	3	public void process ( ) { Stack < Integer > stack = new Stack < Integer > ( ) ; InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/stack.txt" ) ) ; int push = in . readInt ( ) ; for ( int i = 0 ; i < push ; i ++ ) { stack . push ( in . readInt ( ) ) ; } for ( int item : stack ) System . out . print ( item + " " ) ; reverseStack ( stack ) ; System . out . println ( "" ) ; for ( int item : stack ) System . out . print ( item + " " ) ; }
va	2	public static void main ( String [ ] args ) throws Exception { long start = System . currentTimeMillis ( ) ; Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice-1.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice1.out" ) ) ) ; int NumCase = in . nextInt ( ) ; in . nextLine ( ) ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { long min , max ; min = in . nextLong ( ) ; max = in . nextLong ( ) ; int count = 0 ; long sqrt_min = ( long ) Math . sqrt ( min ) , sqrt_max = ( long ) Math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( IsPalin ( i ) && IsPalin ( i * i ) ) { count ++ ; } } System . out . println ( " Case #" + curCase + ": " + count ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "\u8FD0\u884C\u65F6\u95F4\uFF1A" + ( end - start ) + "ms" ) ; }
va	0	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
va	0	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
va	4X	private List < List < String >> find ( String end , Set < String > dict , List < List < String >> nowLists ) { List < List < String >> ansLists = new ArrayList < List < String >> ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; if ( checkValid ( nowStr , end ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( end ) ; ansLists . add ( temp ) ; } } if ( ansLists . size ( ) > 0 ) return ansLists ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : almostList ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; ansLists . add ( temp ) ; } } } if ( ansLists . size ( ) > 0 ) return find ( end , dict , ansLists ) ; List < String > removeList = new ArrayList < String > ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : dict ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; removeList . add ( s ) ; ansLists . add ( temp ) ; } } } for ( String s : removeList ) { dict . remove ( s ) ; } if ( ansLists . size ( ) == 0 ) return ansLists ; return find ( end , dict , ansLists ) ; }
va	2	public static void main ( String [ ] args ) { SelectionSort ss = new SelectionSort ( 10 ) ; System . out . println ( ss . toString ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; System . out . println ( ss . toString ( ) ) ; }
va	3	public boolean matches ( ArrayList < Critere > criteres , ArrayList < MotClef > mots ) { ArrayList < Critere > criteresDocument = new ArrayList < Critere > ( ) ; for ( Note n : notes ) { if ( ! criteresDocument . contains ( n . getCritere ( ) ) ) { criteresDocument . add ( n . getCritere ( ) ) ; } } for ( Critere c : criteres ) { if ( ! criteresDocument . contains ( c ) ) { return false ; } } for ( MotClef m : mots ) { if ( ! motClefs . contains ( m ) ) { return false ; } } return true ; }
va	1	public void rempirListEtude ( ) { String Sreqlist ; listEtude . removeAllItems ( ) ; Sreqlist = "select * from ASSOCIATION join ETUDE " + "on ASSOCIATION.IDCONVENTION = ETUDE.IDCONVENTION " + "WHERE IDETUDIANT =" + idetudiant ; try { listEtude . addItem ( "Selectionner l'\u00E9tude \u00E0 d\u00E9tailler" ) ; openConnection ( ) ; java . sql . Statement reqlist = conn . createStatement ( ) ; java . sql . ResultSet resullist = reqlist . executeQuery ( Sreqlist ) ; while ( resullist . next ( ) ) { listEtude . addItem ( makeObj ( resullist . getInt ( "IDCONVENTION" ) + " -- " + resullist . getString ( "NOMETUDE" ) ) ) ; } reqlist . close ( ) ; resullist . close ( ) ; closeConnection ( ) ; } catch ( java . sql . SQLException e ) { ModelInfo . addElement ( "Erreur execution requete " + e . getMessage ( ) ) ; affAccompte . setModel ( ModelInfo ) ; } }
va	2	@ Override public double calculateMedieGeneralaClasa ( Clasa c ) { Catalog cat = c . getCatalog ( ) ; double medieTotala = 0.0 ; int nrElevi = cat . getSituatieClasa ( ) . size ( ) ; for ( Map . Entry < Elev , HashMap < Materie , SituatieMaterieBaza >> entry : cat . getSituatieClasa ( ) . entrySet ( ) ) { double medie = 0.0 ; int size = entry . getValue ( ) . size ( ) ; for ( SituatieMaterieBaza sit : entry . getValue ( ) . values ( ) ) { medie += sit . getMedieAn ( ) ; } medie /= size ; medieTotala += medie ; } medieTotala /= nrElevi ; return medieTotala ; }
va	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
va	2	private void generatePressureFile ( ) { File file = new File ( this . pressFile ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; try { BufferedWriter output = new BufferedWriter ( new FileWriter ( file ) ) ; for ( Edge e : edges ) { String line ; int i = 1 ; for ( int vec : e . getFlowUnitVector ( ) ) { if ( vec != 0 ) { line = e . getNumber ( ) + " " + i + " " + vec + "\n" ; output . write ( line ) ; } i ++ ; } } output . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Model . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	3	@ Override public void run ( ) { listener . started ( ) ; try { for ( String s : cmd ) System . out . print ( s + " " ) ; System . out . println ( ) ; downloader = Runtime . getRuntime ( ) . exec ( cmd ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( downloader . getErrorStream ( ) ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) { listener . update ( line ) ; if ( line . startsWith ( "INFO:" ) ) { System . out . println ( line ) ; int i = line . indexOf ( "filesize" ) ; if ( i >= 0 ) { int size = Integer . parseInt ( line . substring ( i + 8 ) . trim ( ) ) ; listener . updateSize ( size ) ; break ; } } else break ; } line = reader . readLine ( ) ; } while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) listener . update ( line ) ; line = reader . readLine ( ) ; } int c = downloader . waitFor ( ) ; downloader = null ; if ( c != 0 ) { listener . incomplete ( line + " {" + c + "}" ) ; } else { listener . finished ( ) ; } } catch ( InterruptedException | IOException | NumberFormatException ex ) { if ( downloading ) listener . incomplete ( ex . getMessage ( ) ) ; else listener . incomplete ( "Cancelled" ) ; Logger . getLogger ( RTMPTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } synchronized ( this ) { downloading = false ; } }
va	1	static public void ReInit ( java . io . InputStream stream , String encoding ) { try { jj_input_stream . ReInit ( stream , encoding , 1 , 1 ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) jj_la1 [ i ] = - 1 ; }
va	3	@ Override public void validate ( ) { Algorithm algorithm = getAlgorithm ( ) ; for ( int foldIndex = 0 ; foldIndex < k ; foldIndex ++ ) { Set < Pattern > testSet = new HashSet < Pattern > ( folds [ foldIndex ] ) ; Set < Pattern > trainingSet = new DataSet ( getDataSet ( ) ) ; for ( int fold = 0 ; fold < k ; fold ++ ) { if ( fold != foldIndex ) { trainingSet . addAll ( folds [ fold ] ) ; } } algorithm . setTrainSet ( ( DataSet ) trainingSet ) ; algorithm . train ( ) ; for ( Pattern instance : testSet ) { if ( algorithm instanceof Classifier ) { int calculated = ( ( Classifier ) algorithm ) . classify ( instance ) ; int correct = instance . getClassIndex ( ) ; super . evaluate ( calculated , correct ) ; } else if ( algorithm instanceof Recuperator ) { Pattern recuperated = ( ( Recuperator ) algorithm ) . recover ( instance ) ; super . evaluate ( recuperated , instance ) ; } } } }
va	3	public static int maxProfit4 ( int [ ] prices ) { if ( prices . length < 2 ) { return 0 ; } int [ ] left = new int [ prices . length ] ; int [ ] right = new int [ prices . length ] ; int min = prices [ 0 ] ; int max = prices [ prices . length - 1 ] ; left [ 0 ] = 0 ; right [ prices . length - 1 ] = 0 ; for ( int i = 1 ; i < prices . length ; i ++ ) { if ( prices [ i ] < min ) min = prices [ i ] ; left [ i ] = prices [ i ] - min > left [ i - 1 ] ? prices [ i ] - min : left [ i - 1 ] ; } for ( int i = prices . length - 2 ; i >= 0 ; i -- ) { if ( prices [ i ] > max ) max = prices [ i ] ; right [ i ] = max - prices [ i ] > right [ i + 1 ] ? max - prices [ i ] : right [ i + 1 ] ; } int total = 0 ; for ( int i = 0 ; i < prices . length ; i ++ ) { total = left [ i ] + right [ i ] > total ? left [ i ] + right [ i ] : total ; } return total ; }
va	3	public void loadRocketSprites ( ) { rocketSprites = new ArrayList ( ) ; ArrayList anims = new ArrayList ( ) ; for ( int i = 0 ; i < rocketImages . size ( ) ; i ++ ) { Animation a = new Animation ( ) ; for ( int j = 0 ; j < rocketImages . get ( i ) . size ( ) ; j ++ ) { a . addFrame ( ( Image ) rocketImages . get ( i ) . get ( j ) , 200 ) ; } Animation [ ] a_array = new Animation [ 360 ] ; for ( int j = 0 ; j < 360 ; j ++ ) { a_array [ j ] = rotateAnimation ( a , Math . toRadians ( j + 1 ) ) ; } Sprite s = new Projectile ( a_array , 0 ) ; rocketSprites . add ( s ) ; } }
va	2	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
va	4X	private void readPixels ( BufferedImage img ) { height = img . getHeight ( ) ; width = img . getWidth ( ) ; packedPixels = new int [ width * height ] ; PixelGrabber pixelgrabber = new PixelGrabber ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , packedPixels , 0 , img . getWidth ( ) ) ; try { pixelgrabber . grabPixels ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( ) ; } ByteBuffer unpackedPixels = ByteBuffer . allocateDirect ( packedPixels . length * 4 ) ; int powerof2 = 64 ; while ( powerof2 < Math . max ( width , height ) ) powerof2 *= 2 ; texels = new int [ powerof2 * powerof2 ] ; for ( int row = img . getHeight ( ) - 1 ; row >= 0 ; row -- ) for ( int col = 0 ; col < img . getWidth ( ) ; col ++ ) { int packedPixel = packedPixels [ row * img . getWidth ( ) + col ] ; texels [ row * powerof2 + col ] = packedPixel ; unpackedPixels . put ( ( byte ) ( packedPixel >> 24 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel >> 16 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel >> 8 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel & ff ) ) ; } if ( powerof2 != width && powerof2 != height ) { uclamp = ( double ) width / powerof2 ; vclamp = ( double ) height / powerof2 ; int packed [ ] = new int [ powerof2 * powerof2 ] ; ByteBuffer unpacked = ByteBuffer . allocateDirect ( packed . length * 4 ) ; for ( int x = 0 ; x < powerof2 ; x ++ ) for ( int y = 0 ; y < powerof2 ; y ++ ) if ( x < width && y < height ) packed [ x + y * powerof2 ] = packedPixels [ x + y * width ] ; else if ( x >= width ) packed [ x + y * powerof2 ] = packed [ width - 1 + y * powerof2 ] ; else if ( y >= height ) packed [ x + y * powerof2 ] = packed [ x + ( height - 1 ) * powerof2 ] ; for ( int row = powerof2 - 1 ; row >= 0 ; row -- ) for ( int col = 0 ; col < powerof2 ; col ++ ) { int packedPixel = packed [ row * powerof2 + col ] ; unpacked . put ( ( byte ) ( packedPixel >> 24 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel >> 16 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel >> 8 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel & ff ) ) ; } packedPixels = packed ; unpackedPixels = unpacked ; } height = powerof2 ; width = powerof2 ; bytebuff = unpackedPixels ; }
va	1	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; JSONTokener x = new JSONTokener ( string ) ; while ( x . more ( ) ) { String name = Cookie . unescape ( x . nextTo ( = ) ) ; x . next ( = ) ; jo . put ( name , Cookie . unescape ( x . nextTo ( ; ) ) ) ; x . next ( ) ; } return jo ; }
va	3	public static void main ( String [ ] args ) { Figura [ ] figuras = generaArrayFiguras ( 0.5 , 100 , 4 ) ; try { ObjectOutputStream writer = new ObjectOutputStream ( new FileOutputStream ( "test.dat" ) ) ; for ( Figura fig : figuras ) writer . writeObject ( fig ) ; writer . close ( ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } List < Figura > nuevaFiguras = new ArrayList < > ( ) ; ObjectInputStream reader = null ; try { reader = new ObjectInputStream ( new FileInputStream ( "test.dat" ) ) ; while ( true ) nuevaFiguras . add ( ( Figura ) reader . readObject ( ) ) ; } catch ( IOException | ClassNotFoundException ex ) { } System . out . println ( "Figuras:" ) ; for ( Figura fig : nuevaFiguras ) System . out . println ( fig ) ; }
va	2	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf (  ) >= 0 || string . indexOf (  ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append (  ) ; return sb . toString ( ) ; }
va	4X	public static void sort ( int [ ] a ) { int N = a . length ; int h = 1 ; while ( h < N / 3 ) h = 3 * h + 1 ; while ( h >= 1 ) { for ( int i = h ; i < N ; i ++ ) { for ( int j = i ; j >= h && less ( a [ j ] , a [ j - h ] ) ; j -= h ) { exchange ( a , j , j - h ) ; } } assert isHsorted ( a , h ) ; h /= 3 ; } assert isSorted ( a ) ; }
va	1	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c ==  || c ==  ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
va	4X	public double search ( double [ ] m ) { int n = m . length ; int correction = n % 2 == 0 ? 1 : 0 ; double min , max ; min = max = m [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( m [ i ] < min ) min = m [ i ] ; if ( m [ i ] > max ) max = m [ i ] ; } long leftOutRange = 0 ; long rightOutRange = 0 ; Histogram histogram = new Histogram ( ) ; while ( true ) { loopCount ++ ; histogram . init ( min , max ) ; for ( int i = 0 ; i < n ; i ++ ) { histogram . add ( m [ i ] ) ; } long countInRanges = histogram . totalCount - histogram . others ; if ( countInRanges == 1 ) { return histogram . latestInRange ; } long incCount = 0 ; for ( int i = 0 ; i < histogram . rangeCount ; i ++ ) { long rangeCount = histogram . counts [ i ] ; incCount += rangeCount ; long rightOutCurrentRange = ( countInRanges + rightOutRange ) - incCount ; if ( incCount + leftOutRange >= rightOutCurrentRange - correction ) { min = i == 0 ? histogram . start : histogram . ranges [ i - 1 ] ; max = histogram . ranges [ i ] ; if ( histogram . almostSame ( min , max ) ) { return min ; } leftOutRange += ( incCount - rangeCount ) ; rightOutRange = rightOutCurrentRange ; break ; } } } }
va	2	@ SuppressWarnings ( "rawtypes" ) public static List < String > getClassNamesImplementingInterface ( class interf , String basePackage ) { List < String > classNames = new ArrayList < String > ( ) ; try { class [ ] result = getClasses ( basePackage ) ; for ( class c : result ) { if ( ! Modifier . isAbstract ( c . getModifiers ( ) ) ) { for ( class implementingInterface : c . getInterfaces ( ) ) { if ( implementingInterface . getName ( ) . equals ( interf . getName ( ) ) ) { classNames . add ( c . getCanonicalName ( ) ) ; } } } } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return classNames ; }
va	3	public HashMap < Material , Integer > countBlocks ( Location start , Location end ) { HashMap < Material , Integer > blocks = new HashMap < Material , Integer > ( ) ; final World world = start . getWorld ( ) ; if ( world != end . getWorld ( ) ) { return blocks ; } final int startX = Math . max ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int startY = Math . max ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int startZ = Math . max ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; final int endX = Math . min ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int endY = Math . min ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int endZ = Math . min ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; for ( int x = startX ; x < endX ; x ++ ) { for ( int y = startY ; x < endY ; y ++ ) { for ( int z = startZ ; x < endZ ; z ++ ) { Material currentBlock = world . getBlockAt ( x , y , z ) . getType ( ) ; int lastAmmount = blocks . containsKey ( currentBlock ) ? blocks . get ( currentBlock ) : 0 ; blocks . put ( currentBlock , lastAmmount ) ; } } } return blocks ; }
va	0	@ Override public List < Apontamento > obterPorOrdemServico ( int ordemServicoId ) { return session . createQuery ( "from Apontamento where OrdemServicoId = :ordemServicoId" ) . setString ( "ordemServicoId" , String . valueOf ( ordemServicoId ) ) . list ( ) ; }
va	1	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
va	4X	public static void sprstp ( int [ ] sa , int [ ] ija , double [ ] sb , int [ ] ijb ) throws NRException { int j , jl , jm , jp , ju , k , m , n2 , noff , inc , iv ; double v ; n2 = ija [ 0 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) sb [ j ] = sa [ j ] ; int [ ] ija_vec = nfill ( ija [ n2 ] , ija [ n2 - 1 ] - ija [ 0 ] ) ; int [ ] ijb_vec = new int [ ija [ n2 - 1 ] - ija [ 0 ] ] ; indexx ( ija_vec , ijb_vec ) ; for ( j = n2 , k = 0 ; j < ija [ n2 - 1 ] ; j ++ , k ++ ) { ijb [ j ] = ijb_vec [ k ] ; } jp = 0 ; for ( k = ija [ 0 ] ; k < ija [ n2 - 1 ] ; k ++ ) { m = ijb [ k ] + n2 ; sb [ k ] = sa [ m ] ; for ( j = jp ; j < ija [ m ] + 1 ; j ++ ) ijb [ j ] = k ; jp = ija [ m ] + 1 ; jl = 0 ; ju = n2 - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) / 2 ; if ( ija [ jm ] > m ) ju = jm ; else jl = jm ; } ijb [ k ] = jl ; } for ( j = jp ; j < n2 ; j ++ ) ijb [ j ] = ija [ n2 - 1 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) { jl = ijb [ j + 1 ] - ijb [ j ] ; noff = ijb [ j ] ; inc = 1 ; do { inc *= 3 ; inc ++ ; } while ( inc <= jl ) ; do { inc /= 3 ; for ( k = noff + inc ; k < noff + jl ; k ++ ) { iv = ijb [ k ] ; v = sb [ k ] ; m = k ; while ( ijb [ m - inc ] > iv ) { ijb [ m ] = ijb [ m - inc ] ; sb [ m ] = sb [ m - inc ] ; m -= inc ; if ( m - noff + 1 <= inc ) break ; } ijb [ m ] = iv ; sb [ m ] = v ; } } while ( inc > 1 ) ; } }
va	4X	private boolean r_mark_regions ( ) { int v_1 ; int v_2 ; I_p1 = limit ; v_1 = cursor ; { int c = cursor + 3 ; if ( 0 > c || c > limit ) { return false ; } cursor = c ; } I_x = cursor ; cursor = v_1 ; golab0 : while ( true ) { v_2 = cursor ; lab1 : do { if ( ! ( in_grouping ( g_v , 97 , 248 ) ) ) { break lab1 ; } cursor = v_2 ; break golab0 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { return false ; } cursor ++ ; } golab2 : while ( true ) { lab3 : do { if ( ! ( out_grouping ( g_v , 97 , 248 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor >= limit ) { return false ; } cursor ++ ; } I_p1 = cursor ; lab4 : do { if ( ! ( I_p1 < I_x ) ) { break lab4 ; } I_p1 = I_x ; } while ( false ) ; return true ; }
va	3	@ Override public double [ ] getDoubleData ( double [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { double [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new double [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) data [ ( int ) i ] ; } } } return out ; } }
va	2	public int numTrees2 ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int [ ] num = new int [ n + 1 ] ; num [ 0 ] = 1 ; num [ 1 ] = 1 ; num [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { int left = j - 1 ; int right = i - j ; cnt += num [ left ] * num [ right ] ; } num [ i ] = cnt ; } return num [ n ] ; }
va	2	public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , ParseException { Properties properties = new Properties ( ) ; properties . load ( Client . class . getClassLoader ( ) . getResourceAsStream ( "client.properties" ) ) ; Integer serverPort = Integer . valueOf ( properties . getProperty ( "client.server_port" , "1234" ) ) ; String serverAddress = properties . getProperty ( "client.server_address" , "localhost" ) ; ObjectOutputStream toServer = null ; ObjectInputStream fromServer = null ; Socket connectionSocket = null ; try { connectionSocket = new Socket ( serverAddress , serverPort ) ; Scanner scanner = new Scanner ( System . in ) ; toServer = new ObjectOutputStream ( connectionSocket . getOutputStream ( ) ) ; fromServer = new ObjectInputStream ( connectionSocket . getInputStream ( ) ) ; log . info ( "Connection created!" ) ; while ( ! start ( toServer , fromServer , scanner ) ) ; while ( homePage ( toServer , fromServer , scanner ) ) ; } catch ( IOException e ) { log . error ( "Can't connect to server." , e ) ; } catch ( NoSuchElementException e ) { log . error ( "User terminated session" , e ) ; } finally { if ( toServer != null ) { try { toServer . close ( ) ; } catch ( IOException e ) { log . error ( "To server stream closing error" , e ) ; } } if ( fromServer != null ) { try { fromServer . close ( ) ; } catch ( IOException e ) { log . error ( "From server stream closing error" , e ) ; } } if ( connectionSocket != null ) { try { connectionSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Connection socket closing error" , e ) ; } } } }
va	2	public void fill ( final Color [ ] [ ] frameBuffer ) { if ( frameBuffer == null ) { throw new NullPointerException ( "'frameBuffer' must not be 'null'" ) ; } Color c = ( getAttributes ( ) . containsKey ( "color" ) ) ? ( Color ) getAttributes ( ) . get ( "color" ) : Color . white ; for ( int i = getP ( ) . get ( 0 , 0 ) . intValue ( ) ; i < getP ( ) . get ( 0 , 0 ) . intValue ( ) + getD ( ) . get ( 0 , 0 ) . intValue ( ) ; ++ i ) { for ( int j = getP ( ) . get ( 1 , 0 ) . intValue ( ) ; j < getP ( ) . get ( 1 , 0 ) + getD ( ) . get ( 1 , 0 ) ; ++ j ) { frameBuffer [ i ] [ j ] = c ; } } }
va	1	public void run ( ) { for ( String name : names ) { Apple apple = new Apple ( name ) ; dispatcher . dataReceived ( apple ) ; System . out . println ( "Built apple: " + apple ) ; try { Thread . sleep ( 900 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } dispatcher . dataReceived ( new Key ( all ( Apple . class ) ) ) ; }
va	1	public static int foul ( TeamMatch match ) { int x = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof Points . FoulPoints ) { x += p . getPoints ( ) ; } } return x ; }
va	1	public static boolean isPrime ( int checkNumber ) { double root = Math . sqrt ( checkNumber ) ; for ( int i = 2 ; i <= root ; i ++ ) { if ( checkNumber % i == 0 ) { return false ; } } return true ; }
va	3	public int minimumTotal ( ArrayList < ArrayList < Integer >> triangle ) { int out = 0 ; int min ; if ( triangle == null || triangle . size ( ) == 0 ) return out ; int tLevel = triangle . size ( ) ; out = triangle . get ( 0 ) . get ( 0 ) ; ArrayList < Integer > candidate = new ArrayList < Integer > ( ) ; candidate . add ( out ) ; ArrayList < Integer > next ; for ( int level = 1 ; level < tLevel ; level ++ ) { next = new ArrayList < Integer > ( ) ; int k ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) k = triangle . get ( level ) . get ( 0 ) + candidate . get ( 0 ) ; else if ( i == level ) k = triangle . get ( level ) . get ( i ) + candidate . get ( i - 1 ) ; else { k = triangle . get ( level ) . get ( i ) ; k += Math . min ( candidate . get ( i - 1 ) , candidate . get ( i ) ) ; } next . add ( k ) ; } candidate . clear ( ) ; candidate = next ; } if ( candidate . size ( ) != 0 ) { min = candidate . get ( 0 ) ; for ( int c : candidate ) { min = Math . min ( min , c ) ; } out = min ; } return out ; }
va	1	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
va	0	public BigRational ( ) { this ( BigDecimal . ZERO ) ; }
va	3	private void generateElemXMLFile ( Document doc , Element elem ) { Element elements = doc . createElement ( "Elements" ) ; elem . appendChild ( elements ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; for ( Edge e : edges ) { Element element = doc . createElement ( "Element" ) ; elements . appendChild ( element ) ; Attr attr = doc . createAttribute ( "id" ) ; attr . setValue ( e . getNumber ( ) + "" ) ; element . setAttributeNode ( attr ) ; Element nodes = doc . createElement ( "Nodes" ) ; element . appendChild ( nodes ) ; Element node1 = doc . createElement ( "Node1" ) ; node1 . appendChild ( doc . createTextNode ( e . getNode1 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node1 ) ; Element node2 = doc . createElement ( "Node2" ) ; node2 . appendChild ( doc . createTextNode ( e . getNode2 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node2 ) ; if ( e . getPressureValue ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element pressure = doc . createElement ( "Pressure" ) ; element . appendChild ( pressure ) ; Element value = doc . createElement ( "Value" ) ; value . appendChild ( doc . createTextNode ( e . getPressureValue ( ) + "" ) ) ; element . appendChild ( value ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; pressure . appendChild ( unit ) ; i ++ ; } } if ( e . getFlowVelocity ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element fluid = doc . createElement ( "Fluid" ) ; element . appendChild ( fluid ) ; Element flow = doc . createElement ( "Velocity" ) ; flow . appendChild ( doc . createTextNode ( e . getFlowVelocity ( ) + "" ) ) ; element . appendChild ( flow ) ; Element density = doc . createElement ( "Density" ) ; density . appendChild ( doc . createTextNode ( e . getFluidDensity ( ) + "" ) ) ; element . appendChild ( density ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; fluid . appendChild ( unit ) ; i ++ ; } } } }
va	3	private void setupLinks ( ) { final int rawlinksnum = this . links . size ( ) ; int [ ] rawlinks = new int [ rawlinksnum * Link . LINK_SIZE ] ; int idx = 0 ; for ( int i = 0 ; i < rawlinksnum ; i ++ ) { final int [ ] link = this . links . get ( i ) ; final int src = link [ 0 ] ; final int dst = link [ 1 ] ; final int widx = link [ 2 ] ; rawlinks [ idx ] = src ; idx ++ ; rawlinks [ idx ] = dst ; idx ++ ; rawlinks [ idx ] = widx ; idx ++ ; } Link . sortDstMaj ( rawlinks , Link . ORDER_ASC ) ; int [ ] links = Link . eliminateRedundantLinks ( rawlinks ) ; if ( links . length % Link . LINK_SIZE != 0 ) { throw new LinkArrayCorrupt ( ) ; } this . structure . links = links ; final int linksnum = links . length / Link . LINK_SIZE ; this . structure . linksnum = linksnum ; int woff = 1 ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = links [ idx + Link . IDX_SRC ] ; final int dst = links [ idx + Link . IDX_DST ] ; final int widx = links [ idx + Link . IDX_WEIGHT ] ; this . indeg [ dst ] ++ ; this . outdeg [ src ] ++ ; final int lsrc = this . layermap [ src ] ; final int ldst = this . layermap [ dst ] ; if ( lsrc >= ldst ) { this . structure . recurrent = true ; } if ( widx == WEIGHT_NEEDED ) { links [ idx + Link . IDX_WEIGHT ] = woff ; woff ++ ; } else if ( widx == Link . NOWEIGHT ) { links [ idx + Link . IDX_WEIGHT ] = 0 ; } idx += Link . LINK_SIZE ; } this . structure . weightsnum = ( woff - 1 ) ; int [ ] linksrev = links . clone ( ) ; Link . sortSrcMaj ( linksrev , Link . ORDER_ASC ) ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = linksrev [ idx + Link . IDX_SRC ] ; final int dst = linksrev [ idx + Link . IDX_DST ] ; linksrev [ idx + Link . IDX_DST ] = src ; linksrev [ idx + Link . IDX_SRC ] = dst ; idx += Link . LINK_SIZE ; } this . structure . linksrev = linksrev ; }
va	0	public void setWeight ( int weight ) { this . weight = weight ; }
va	1	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
va	1	public Set < Point > getPossibleMoves ( PlayerToken player ) { Set < Point > result = new HashSet < Point > ( ) ; Point loc = tokenLocs . get ( player ) ; for ( Point p : getAdjacentSquares ( player ) ) { if ( isMovable ( loc , p ) ) { result . add ( p ) ; } } return result ; }
va	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
va	4X	public static int SentsToSQL ( File input ) { if ( ! input . exists ( ) ) return 0 ; ArrayList < SentenceEntry > res = new ArrayList < SentenceEntry > ( ) ; ArrayList < String > validation = new ArrayList < String > ( ) ; try { BufferedReader buReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( input ) , "UTF-8" ) ) ; String tmp = "" ; double currating = - 1 ; int revIndex = 0 ; for ( String s = buReader . readLine ( ) ; s != null ; s = buReader . readLine ( ) ) { if ( s . startsWith ( "###" ) ) { if ( tmp . length ( ) == 0 ) { currating = double . valueOf ( s . split ( "\t" ) [ 3 ] ) ; continue ; } ArrayList < String > sentences = SentenceSplitter . getInstance ( ) . sentence_split ( tmp ) ; validation . addAll ( sentences ) ; for ( String sent : sentences ) { SentenceEntry curSent = new SentenceEntry ( sent , sentsCounter , input . getName ( ) ) ; curSent . RevIndex = revIndex ; curSent . RevRating = currating ; sentsCounter ++ ; res . add ( curSent ) ; } revIndex ++ ; tmp = "" ; if ( s . split ( "\t" ) . length != 13 ) { System . out . println ( s . split ( "\t" ) . length + "\t" + s ) ; currating = 4.0 ; } else { currating = double . valueOf ( s . split ( "\t" ) [ 3 ] ) ; } } else { tmp += s ; } } if ( ! tmp . isEmpty ( ) ) { ArrayList < String > sentences = SentenceSplitter . getInstance ( ) . sentence_split ( tmp ) ; for ( String sent : sentences ) { SentenceEntry curSent = new SentenceEntry ( sent , sentsCounter , input . getName ( ) ) ; curSent . RevIndex = revIndex ; curSent . RevRating = currating ; sentsCounter ++ ; res . add ( curSent ) ; } validation . addAll ( sentences ) ; tmp = "" ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } for ( SentenceEntry sentEntry : res ) { String sql = "INSERT INTO sentences (sent_index   sent_txt   revindex   revrating  filename )" + " VALUES ( " + sentEntry . UniqueID + "  '" + TextUtil . Encode ( sentEntry . get_senttxt ( ) ) + "'  " + sentEntry . RevIndex + "   " + sentEntry . RevRating + "  '" + TextUtil . Encode ( sentEntry . FileName ) + "');" ; db1 . executeUpdateSQL ( sql ) ; } System . err . println ( "% end..." + sentsCounter + "\t" + validation . size ( ) + "." ) ; return sentsCounter ; }
va	2	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
va	3	private void initialise ( ) { int a , b , c , d , e , f , g , h ; a = b = c = d = e = f = g = h = 9e3779b9 ; for ( int i = 0 ; i < 4 ; i ++ ) { a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; } for ( int i = 0 ; i < SIZE ; i += 8 ) { a += results [ i ] ; b += results [ i + 1 ] ; c += results [ i + 2 ] ; d += results [ i + 3 ] ; e += results [ i + 4 ] ; f += results [ i + 5 ] ; g += results [ i + 6 ] ; h += results [ i + 7 ] ; a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; memory [ i ] = a ; memory [ i + 1 ] = b ; memory [ i + 2 ] = c ; memory [ i + 3 ] = d ; memory [ i + 4 ] = e ; memory [ i + 5 ] = f ; memory [ i + 6 ] = g ; memory [ i + 7 ] = h ; } for ( int i = 0 ; i < SIZE ; i += 8 ) { a += memory [ i ] ; b += memory [ i + 1 ] ; c += memory [ i + 2 ] ; d += memory [ i + 3 ] ; e += memory [ i + 4 ] ; f += memory [ i + 5 ] ; g += memory [ i + 6 ] ; h += memory [ i + 7 ] ; a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; memory [ i ] = a ; memory [ i + 1 ] = b ; memory [ i + 2 ] = c ; memory [ i + 3 ] = d ; memory [ i + 4 ] = e ; memory [ i + 5 ] = f ; memory [ i + 6 ] = g ; memory [ i + 7 ] = h ; } isaac ( ) ; count = SIZE ; }
va	2	public String hash ( ) { if ( this . lshCode != null ) { return this . lshCode ; } if ( ! this . lshCodeValid ) { return null ; } LshBinStruct tmp = new LshBinStruct ( ) ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { tmp . checksum [ k ] = swapByte ( this . lshBin . checksum [ k ] ) ; } tmp . lValue = swapByte ( this . lshBin . lValue ) ; tmp . Q = swapByte ( this . lshBin . Q ) ; for ( int i = 0 ; i < CODE_SIZE ; i ++ ) { tmp . tmpCode [ i ] = this . lshBin . tmpCode [ CODE_SIZE - 1 - i ] ; } this . lshCode = toHex ( tmp . checksum ) ; this . lshCode += toHex ( new int [ ] { tmp . lValue } ) ; this . lshCode += toHex ( new int [ ] { tmp . Q } ) ; this . lshCode += toHex ( tmp . tmpCode ) ; return this . lshCode ; }
va	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
va	3	public static BigInteger check ( ) { for ( BigInteger a : primes ) { for ( BigInteger b : primes ) { for ( int i = 0 ; i < 80 ; i ++ ) { int sum = i * i + a . intValue ( ) * i + b . intValue ( ) ; BigInteger test = new BigInteger ( String . valueOf ( sum ) ) ; if ( ! sprimes . contains ( test ) ) { if ( i > max ) { max = i ; result = a . multiply ( b ) ; System . out . println ( max ) ; } break ; } } } } return result ; }
va	0	public UserSessionVO getUserSessionVO ( ) { return userSessionVO ; }
va	1	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
va	4X	public static int [ ] [ ] readIntMatrix ( ) { while ( true ) { String [ ] lineTokens = readString ( ) . split ( "/" ) ; if ( lineTokens . length > 1 ) { String [ ] [ ] tokens = new String [ lineTokens . length ] [ ] ; int columns = 0 ; for ( int line = 0 ; line < lineTokens . length ; line ++ ) { tokens [ line ] = lineTokens [ line ] . split ( " " ) ; if ( tokens [ line ] . length > columns ) { columns = tokens [ line ] . length ; } } if ( columns > 0 ) { int [ ] [ ] array = new int [ lineTokens . length ] [ columns ] ; try { for ( int line = 0 ; line < tokens . length ; line ++ ) { for ( int column = 0 ; column < tokens [ line ] . length ; column ++ ) { array [ line ] [ column ] = Integer . parseInt ( tokens [ line ] [ column ] ) ; } } return array ; } catch ( NumberFormatException e ) { System . err . println ( ERROR_INVALID_INT ) ; } } else { System . out . println ( ERROR_EMPTY_LINE ) ; } } else { System . out . println ( ERROR_ONE_LINE_ARRAY ) ; } } }
va	1	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
va	2	private static String longestWordFromOtherWords1 ( String [ ] words ) { int rl = - 1 ; String lwfow = null ; Arrays . sort ( words , new stringComparator ( ) ) ; HashMap < String , boolean > wordMap = new HashMap < String , boolean > ( ) ; for ( String w : words ) { if ( ! wordMap . containsKey ( w ) ) { wordMap . put ( w , true ) ; } } for ( String w : words ) { wordMap . remove ( w ) ; rl = longestWordFromOtherWords ( wordMap , w ) ; wordMap . put ( w , true ) ; if ( rl > 0 ) { lwfow = w ; break ; } } return lwfow ; }
va	0	public boolean isSchoolAnnouncements ( ) { return schoolAnnouncements ; }
va	1	@ Override public void printOptions ( ) { if ( getSuccessors ( ) == null || getSuccessors ( ) . size ( ) == 0 ) { return ; } Printer . print ( Settings_Output . OUT_OPTION_HEAD , "Please choose an option" ) ; Integer i = 0 ; for ( final IAction action : getSuccessors ( ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , action . getName ( ) , action . getDescription ( ) ) ; i ++ ; } }
va	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
va	3	private void updateTimeslot ( ) { final int [ ] selectedIndices = subjectList . getSelectedIndices ( ) ; for ( final int index : selectedIndices ) { final Subject subject = subjectListModel . getSubjectAt ( index ) ; timeslot . addSubject ( subject ) ; if ( clazz instanceof Schoolclass ) { if ( timeslot . getTeachers ( ) . size ( ) > 0 ) { for ( Teacher teacher : timeslot . getTeachers ( ) ) { try { Timeslot timeslotTeacher = Data . getDayTableForWeekday ( weekday , teacher ) . getTimeslot ( position ) ; timeslotTeacher . addSubject ( subject ) ; TimetableManager . updateTimeslot ( timeslotTeacher ) ; } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } } if ( clazz instanceof Teacher ) { if ( timeslot . getSchoolclasses ( ) . size ( ) > 0 ) { for ( Schoolclass schoolclass : timeslot . getSchoolclasses ( ) ) { try { Timeslot timeslotSchoolclass = Data . getDayTableForWeekday ( weekday , schoolclass ) . getTimeslot ( position ) ; timeslotSchoolclass . addSubject ( subject ) ; TimetableManager . updateTimeslot ( timeslotSchoolclass ) ; } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } } try { TimetableManager . updateTimeslot ( timeslot ) ; } catch ( DatasetException ex ) { LOGGER . error ( "Exception while updating timeslot " + timeslot , ex ) ; ErrorHandler . criticalDatasetError ( ) ; } } }
va	0	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
va	2	public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c !=   ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c ==   ) { break ; } if ( c !=   ) { if ( c ==  || c ==  || c == 0 ) { return ja ; } throw x . syntaxError ( "Bad character '" + c + "' (" + ( int ) c + ")." ) ; } c = x . next ( ) ; } } }
va	4X	@ Test ( groups = { "integration" } ) public void testConcurrentBehavior ( ) throws IOException , InterruptedException { final int QUEUE_ITEMS = 1024 ; final int THREADS = 10 ; log . trace ( "[start] PersistentQueueTest.testConcurrentBehavior" ) ; File tempfile = File . createTempFile ( "PersistentQueue" , ".test" ) ; try { tempfile . delete ( ) ; List < Thread > threads = new ArrayList < Thread > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; final PersistentQueue < Integer > queue = new PersistentQueue < Integer > ( Integer . class , tempfile , 9 , 4104 ) ; for ( int i = 0 ; i < THREADS ; i ++ ) { Thread thread = new Thread ( ) { public void run ( ) { log . trace ( "[thread] start {}" , Thread . currentThread ( ) . getId ( ) ) ; int x = 0 ; try { while ( true ) { Thread . yield ( ) ; Integer y = queue . poll ( 2 , TimeUnit . SECONDS ) ; Thread . yield ( ) ; if ( y == null ) break ; Thread . yield ( ) ; log . trace ( "[poll] {}" , y ) ; assert y >= x : "What happened?" ; Thread . yield ( ) ; x = y ; Thread . yield ( ) ; log . trace ( "[thread] count {}" , count . getAndIncrement ( ) ) ; } } catch ( InterruptedException exception ) { throw new IllegalStateException ( "Unexpectedly interrupted" , exception ) ; } } } ; thread . start ( ) ; threads . add ( thread ) ; } for ( int i = 0 ; i < QUEUE_ITEMS ; i ++ ) { log . trace ( "[put] {}" , i ) ; queue . put ( i ) ; } for ( Thread thread : threads ) { log . trace ( "[thread] joining {}" , thread . getId ( ) ) ; thread . join ( ) ; } int total = count . get ( ) ; assert total == QUEUE_ITEMS : "Expected " + QUEUE_ITEMS + "  observed " + total ; } finally { tempfile . delete ( ) ; } log . trace ( "[end] PersistentQueueTest.testConcurrentBehavior" ) ; }
va	2	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
va	2	private void createUnits ( ) { ArrayList < Building > buildings = g . map . getPlayersBuildings ( this ) ; boolean hasMoney = true ; while ( hasMoney ) { for ( Building building : buildings ) { if ( building instanceof Factory ) { ( ( Factory ) building ) . recruitTank ( g . map , building . getCell ( ) , true ) ; } if ( building instanceof Barracks ) { ( ( Barracks ) building ) . recruitMarine ( g . map , building . getCell ( ) , true ) ; } } if ( buildings . contains ( Barracks . class ) ) { hasMoney = this . getMoney ( ) >= Marine . cost ; } else if ( buildings . contains ( Factory . class ) ) { hasMoney = this . getMoney ( ) >= Tank . cost ; } else { hasMoney = false ; } } }
va	3	@ Override public void computePerformanceMeasures ( ) throws InternalErrorException { totalTimer . start ( ) ; BigRational [ ] X = new BigRational [ qnm . R ] ; BigRational [ ] [ ] Q = new BigRational [ qnm . M ] [ qnm . R ] ; if ( lastG [ 0 ] . isUndefined ( ) ) { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . M ; i ++ ) { for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) + i + 1 ] . isUndefined ( ) ) { Q [ i ] [ r ] = qnm . getDemandAsBigRational ( i , r ) . multiply ( lastG [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ i + 1 ] . isUndefined ( ) ) { Q [ i ] [ qnm . R - 1 ] = qnm . getDemandAsBigRational ( i , qnm . R - 1 ) . multiply ( prevG [ i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) ] . isUndefined ( ) ) { X [ r ] = lastG [ sz * ( r + 1 ) ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ 0 ] . isUndefined ( ) ) { X [ qnm . R - 1 ] = prevG [ 0 ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } totalTimer . pause ( ) ; qnm . setPerformanceMeasures ( Q , X ) ; }
va	4X	public static void dutchFlagSort ( int [ ] arr , int lowValue , int highValue ) { int i = 0 ; int j = arr . length - 1 ; int lP = 0 ; int hP = arr . length - 1 ; while ( i <= j ) { if ( arr [ i ] > highValue ) { if ( arr [ j ] < lowValue ) { swap ( arr , i , j ) ; i ++ ; j -- ; } else if ( arr [ j ] > lowValue ) { j -- ; } else { swap ( arr , hP , j ) ; j -- ; hP -- ; } } else if ( arr [ i ] < lowValue ) { i ++ ; } else { swap ( arr , i , lP ) ; lP ++ ; i ++ ; } } System . out . println ( "Before paritioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } int k = 0 ; while ( k < lP ) { swap ( arr , k , j ) ; k ++ ; j -- ; } k = arr . length - 1 ; while ( k > hP ) { swap ( arr , k , i ) ; k -- ; i ++ ; } System . out . println ( "After Partioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } }
va	0	public Vector3D add ( Vector3D otherVector ) { return new Vector3D ( this . getX ( ) + otherVector . getX ( ) , this . getY ( ) + otherVector . getY ( ) , this . getZ ( ) + otherVector . getZ ( ) ) ; }
te	3	public void printNFromEnd ( int n ) { InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/list.txt" ) ) ; SingleLinkedList list = new SingleLinkedList ( ) ; Stack < Integer > stack = new Stack < Integer > ( ) ; int numOfElems = in . readInt ( ) ; for ( int i = 0 ; i < numOfElems ; i ++ ) { list . insert ( in . readInt ( ) ) ; } SNode cur = list . getHEADER ( ) ; while ( cur != null ) { stack . push ( list . delete ( ) ) ; cur = cur . next ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( stack . pop ( ) ) ; }
te	3	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) Utilities . UNSAFE . getLong ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) data [ ( int ) i ] ; } } } return out ; } }
te	0	public void setFinalGrades ( boolean value ) { this . finalGrades = value ; }
te	2	private QuerySet < T > range ( String query ) { QuerySet < T > querySet = null ; try { if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { query = query . replace ( "__range" , "" ) ; query = query . replace ( "  " , " " ) ; query = query . replaceAll ( "['\\[\\]]" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; if ( queryComponents != null && queryComponents . length > 0 ) { querySet = new QuerySet < T > ( ) ; querySet . entity ( this . entity ) ; String fieldName = queryComponents [ 0 ] ; String [ ] fieldValues = queryComponents [ 1 ] . split ( " " ) ; Field field = null ; if ( fieldName . trim ( ) . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { for ( int fieldValue = Integer . parseInt ( fieldValues [ 0 ] ) ; fieldValue <= Integer . parseInt ( fieldValues [ 1 ] ) ; fieldValue ++ ) { if ( field . get ( model ) . equals ( fieldValue ) ) { querySet . add ( model ) ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return querySet ; }
te	0	public void _fatal ( Object context ) { }
te	2	private void survivalSelection ( ) { sortPopulation ( ) ; while ( population . size ( ) > ( popSize + RANDOM_SURVIVAL ) ) { population . remove ( population . size ( ) - 1 ) ; } while ( population . size ( ) > popSize ) { population . remove ( rg . nextInt ( population . size ( ) - 1 ) + 1 ) ; } }
te	3	@ Override protected void doBatchWeightsUpdate ( ) { List < ILayer > layers = this . network . getLayers ( ) ; for ( int i = this . network . getLayersNum ( ) - 1 ; i > 0 ; i -- ) for ( INeuron neuron : layers . get ( i ) . getNeurons ( ) ) if ( neuron instanceof IInputtedNeuron ) for ( ISynapse synapse : ( ( IInputtedNeuron ) neuron ) . getInputConnections ( ) ) { synapse . incrementWeight ( synapse . getWeightChange ( ) ) ; synapse . setWeightChange ( 0 ) ; } }
te	0	public void windowDeiconified ( WindowEvent e ) { }
te	2	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
te	3	@ Override public void render ( Graphics g ) { for ( int r = 0 ; r < tiles . length ; r ++ ) for ( int c = 0 ; c < tiles [ r ] . length ; c ++ ) perspective . render ( g , tiles [ r ] [ c ] ) ; for ( Entity entity : entities ) perspective . render ( g , entity ) ; }
te	3	@ Override public boolean [ ] getBooleanData ( boolean [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { boolean [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new boolean [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { byte v = Utilities . UNSAFE . getByte ( ptr + i ) ; out [ idx ++ ] = v == 1 ; } } else { if ( isConstant ( ) ) { boolean elem = data [ 0 ] != 0 ; for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = elem ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { byte v = data [ ( int ) i ] ; out [ idx ++ ] = v != 0 ; } } } return out ; } }
te	1	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
te	2	public void createMosquitos ( int n ) { mosquitos = new HashSet < Mosquito > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Point2D p = new Point2D . double ( 1 + GameConfig . random . nextDouble ( ) * 98 , 1 + GameConfig . random . nextDouble ( ) * 98 ) ; while ( collidesWithWall ( p ) ) p = new Point2D . double ( 1 + GameConfig . random . nextDouble ( ) * 98 , 1 + GameConfig . random . nextDouble ( ) * 98 ) ; mosquitos . add ( new Mosquito ( p ) ) ; } }
te	3	private void removeComposedBlocks ( ) { List < GenericTreeNode < LayoutParserTreeElement >> list = this . layoutParser . XMLTree . build ( GenericTreeTraversalOrderEnum . PRE_ORDER ) ; for ( GenericTreeNode < LayoutParserTreeElement > element : list ) { if ( element . getData ( ) . elementType == LayoutParserTreeElement . ElementType . COMPOSEDBLOCK ) { List < GenericTreeNode < LayoutParserTreeElement >> childrenList = element . getChildren ( ) ; GenericTreeNode < LayoutParserTreeElement > parent = element . getParent ( ) ; for ( GenericTreeNode < LayoutParserTreeElement > child : childrenList ) { parent . addChild ( child ) ; } for ( int i = 0 ; i < parent . getNumberOfChildren ( ) ; i ++ ) { if ( parent . getChildAt ( i ) == element ) { parent . removeChildAt ( i ) ; break ; } } } } }
te	1	public void removeBogusLegs ( ) { Iterator < Leg > it = legs . iterator ( ) ; while ( it . hasNext ( ) ) { Leg leg = it . next ( ) ; if ( leg . isBogusNonTransitLeg ( ) ) { it . remove ( ) ; } } }
te	4X	@ Override public void mouseDragged ( MouseEvent e ) { Point dragged = e . getLocationOnScreen ( ) ; int dragX = getDragDistance ( dragged . x , pressed . x , snapSize . width ) ; int dragY = getDragDistance ( dragged . y , pressed . y , snapSize . height ) ; int locationX = location . x + dragX ; int locationY = location . y + dragY ; while ( locationX < edgeInsets . left ) locationX += snapSize . width ; while ( locationY < edgeInsets . top ) locationY += snapSize . height ; Dimension d = getBoundingSize ( destination ) ; while ( locationX + destination . getSize ( ) . width + edgeInsets . right > d . width ) locationX -= snapSize . width ; while ( locationY + destination . getSize ( ) . height + edgeInsets . bottom > d . height ) locationY -= snapSize . height ; destination . setLocation ( locationX , locationY ) ; }
te	4X	@ Override public void run ( ) throws Exception { try { privileges . load ( "plugins/Privileges/config.yml" ) ; setDefaultGroup ( privileges . getString ( "default_group" ) ) ; setDebug ( privileges . getBoolean ( "debug" ) ) ; privileges . load ( "plugins/Privileges/users.yml" ) ; for ( String player : plugin . getKeys ( privileges , "users" ) ) { addPlayerGroup ( player , privileges . getString ( "users." + player + ".group" ) ) ; for ( String permission : privileges . getStringList ( "users." + player + ".permissions" ) ) { addPlayerPermission ( player , permission . replace ( "-" , "" ) , ! permission . startsWith ( "-" ) ) ; } for ( String world : plugin . getKeys ( privileges , "users." + player + ".worlds" ) ) { for ( String worldpermission : privileges . getStringList ( "users." + player + ".worlds." + world ) ) { addPlayerPermission ( player , world , worldpermission . replace ( "-" , "" ) , ! worldpermission . startsWith ( "-" ) ) ; } } } privileges . load ( "plugins/Privileges/groups.yml" ) ; for ( String group : plugin . getKeys ( privileges , "groups" ) ) { for ( String permission : privileges . getStringList ( "groups." + group + ".permissions" ) ) { addGroupPermission ( group , permission . replace ( "-" , "" ) , ! permission . startsWith ( "-" ) ) ; } for ( String world : plugin . getKeys ( privileges , "groups." + group + ".worlds" ) ) { for ( String worldpermission : privileges . getStringList ( "groups." + group + ".worlds." + world ) ) { addGroupPermission ( group , world , worldpermission . replace ( "-" , "" ) , ! worldpermission . startsWith ( "-" ) ) ; } } for ( String inherit : privileges . getStringList ( "groups." + group + ".inheritance" ) ) { addGroupInheritance ( group , inherit ) ; } } } catch ( Exception e ) { throw e ; } }
te	1	private List < Integer > getSelection ( ) { final List < Integer > sel = new LinkedList < > ( ) ; for ( int i = 0 ; i < cardList . size ( ) ; i ++ ) { if ( cardList . get ( i ) . selected ) { sel . add ( i ) ; } } return sel ; }
te	1	private final void processItems ( final List < Step > items ) { for ( final Step item : items ) { item . process ( ) ; } }
te	1	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
te	4X	private static void Merge ( int [ ] A , int p , int q , int r ) { int L1 = q - p + 1 ; int L2 = r - q ; int [ ] A1 = new int [ L1 + 1 ] ; int [ ] A2 = new int [ L2 + 1 ] ; for ( int i = 0 ; i < L1 ; i ++ ) { A1 [ i ] = A [ p + i ] ; } for ( int i = 0 ; i < L2 ; i ++ ) { A2 [ i ] = A [ q + i + 1 ] ; } A1 [ L1 ] = Integer . MAX_VALUE ; A2 [ L2 ] = Integer . MAX_VALUE ; int k = 0 , j = 0 ; for ( int i = p ; i <= r ; i ++ ) { if ( A1 [ k ] < A2 [ j ] ) { A [ i ] = A1 [ k ] ; k ++ ; } else { A [ i ] = A2 [ j ] ; j ++ ; } } System . out . println ( "" ) ; for ( int i : A ) { System . out . print ( i + "#" ) ; } System . out . println ( "" ) ; }
te	2	public void construct2DMatrixFromStringSet ( int currentRow , int startIndex , int numRows , int numColumns , List < String > rawData ) { String sCurrentLine = "" ; String _convertedPattern = "" ; int trackNumberOfRows = 0 ; int sIndex = 0 ; _pattern = new String [ numRows ] ; while ( true ) { sCurrentLine = rawData . get ( currentRow ) . substring ( startIndex , startIndex + numColumns ) ; sIndex = 0 ; if ( trackNumberOfRows == numRows ) break ; _convertedPattern = "" ; while ( sIndex < sCurrentLine . length ( ) ) { _convertedPattern += ( sCurrentLine . charAt ( sIndex ) == + ? 1 : 0 ) ; sIndex ++ ; } _pattern [ trackNumberOfRows ] = String . valueOf ( binaryToDecimal ( _convertedPattern ) ) ; trackNumberOfRows ++ ; } }
te	2	private boolean isPredictableResult ( ) { boolean commSet = true ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( this . communityCards [ i ] == null ) { commSet = false ; break ; } } if ( commSet ) { boolean correctPlayerTypes = false ; for ( PlayerProfile profile : this . profiles ) { if ( profile . getHandType ( ) != HandType . EXACTCARDS ) { correctPlayerTypes = true ; break ; } } if ( ! correctPlayerTypes ) { return true ; } } return false ; }
te	2	@ Override public void work ( ) { try { Vertex v = getClickedVertex ( ) ; if ( v == null ) { gui . console ( "Choose a vertex" ) ; return ; } doFillVertex = true ; Queue < Vertex > q = new LinkedList < Vertex > ( ) ; v . visited = true ; q . add ( v ) ; while ( ! q . isEmpty ( ) ) { v = q . poll ( ) ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { Vertex w = e . dest ; if ( ! w . visited ) { w . visited = true ; q . add ( w ) ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } catch ( Exception e ) { } clearAll ( ) ; repaint ( ) ; }
te	2	private void spawnGroundItem ( int i , int j ) { NodeList class19 = groundArray [ plane ] [ i ] [ j ] ; if ( class19 == null ) { worldController . method295 ( plane , i , j ) ; return ; } int k = fa0a1f01 ; Object obj = null ; for ( Item item = ( Item ) class19 . reverseGetFirst ( ) ; item != null ; item = ( Item ) class19 . reverseGetNext ( ) ) { ItemDef itemDef = ItemDef . forID ( item . ID ) ; int l = itemDef . value ; if ( itemDef . stackable ) l *= item . anInt1559 + 1 ; if ( l > k ) { k = l ; obj = item ; } } class19 . insertTail ( ( ( Node ) ( obj ) ) ) ; Object obj1 = null ; Object obj2 = null ; for ( Item class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetFirst ( ) ; class30_sub2_sub4_sub2_1 != null ; class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetNext ( ) ) { if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && obj1 == null ) obj1 = class30_sub2_sub4_sub2_1 ; if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj1 ) ) . ID && obj2 == null ) obj2 = class30_sub2_sub4_sub2_1 ; } int i1 = i + ( j << 7 ) + 60000000 ; worldController . method281 ( i , i1 , ( ( Animable ) ( obj1 ) ) , method42 ( plane , j * 128 + 64 , i * 128 + 64 ) , ( ( Animable ) ( obj2 ) ) , ( ( Animable ) ( obj ) ) , plane , j ) ; }
te	3	public void modifyPairings ( ) { String moveKey = "" ; ArrayList < Type > all = new ArrayList < Type > ( ) ; Bug bug = new Bug ( ) ; all . add ( bug ) ; all . add ( new Dark ( ) ) ; all . add ( new Dragon ( ) ) ; all . add ( new Electric ( ) ) ; all . add ( new Fighting ( ) ) ; all . add ( new Fire ( ) ) ; all . add ( new Flying ( ) ) ; all . add ( new Ghost ( ) ) ; all . add ( new Grass ( ) ) ; all . add ( new Ground ( ) ) ; all . add ( new Ice ( ) ) ; all . add ( new Normal ( ) ) ; all . add ( new Poison ( ) ) ; all . add ( new Psychic ( ) ) ; all . add ( new Rock ( ) ) ; all . add ( new Steel ( ) ) ; all . add ( new Water ( ) ) ; None none = new None ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { Pokemon sampleMember = team . get ( i ) ; for ( int x = 0 ; x < 4 ; x ++ ) { moveKey = sampleMember . getCircumvent ( ) . get ( x ) ; for ( int y = 0 ; y < all . size ( ) ; y ++ ) { Type comparedTo1 = all . get ( y ) ; Type comparedTo2 = none ; if ( sampleMember . getMove ( moveKey ) instanceof SpecifiedPhysical ) { SpecifiedPhysical popMove = ( SpecifiedPhysical ) sampleMember . getMove ( moveKey ) ; int popMoveR = popMove . getType ( ) . resistedCounter ( comparedTo1 , comparedTo2 ) ; int popMoveSE = popMove . getType ( ) . superEffectiveCounter ( comparedTo1 , comparedTo2 ) ; int popMoveI = popMove . getType ( ) . immuneCounter ( comparedTo1 , comparedTo2 ) ; moveSuperEffectives += popMoveSE ; moveResistances += popMoveR ; moveImmunities += popMoveI ; } if ( sampleMember . getMove ( moveKey ) instanceof SpecifiedSpecial ) { SpecifiedSpecial popMove = ( SpecifiedSpecial ) sampleMember . getMove ( moveKey ) ; int popMoveR = popMove . getType ( ) . resistedCounter ( comparedTo1 , comparedTo2 ) ; int popMoveSE = popMove . getType ( ) . superEffectiveCounter ( comparedTo1 , comparedTo2 ) ; int popMoveI = popMove . getType ( ) . immuneCounter ( comparedTo1 , comparedTo2 ) ; moveSuperEffectives += popMoveSE ; moveResistances += popMoveR ; moveImmunities += popMoveI ; } } } } }
te	3	public static boolean isPalindrome ( String s ) { if ( s . length ( ) == 0 ) return true ; s = s . toLowerCase ( ) ; int i , j ; for ( i = 0 , j = s . length ( ) - 1 ; i < j ; i ++ , j -- ) { while ( ( s . charAt ( i ) < a || s . charAt ( i ) > z ) && ( s . charAt ( i ) < 0 || s . charAt ( i ) > 9 ) ) { i ++ ; if ( i >= s . length ( ) ) break ; } while ( ( s . charAt ( j ) < a || s . charAt ( j ) > z ) && ( s . charAt ( j ) < 0 || s . charAt ( j ) > 9 ) ) { j -- ; if ( j < 0 ) break ; } if ( i >= j ) break ; if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } return true ; }
te	2	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
te	0	protected BombImage ( Content parent , Game game , Point position , int range , Date end ) { super ( parent , game , position , range , end ) ; }
te	4X	protected void setFromQhull ( double [ ] coords , int nump , boolean triangulate ) { String commandStr = "./qhull i" ; if ( triangulate ) { commandStr += " -Qt" ; } try { Process proc = Runtime . getRuntime ( ) . exec ( commandStr ) ; PrintStream ps = new PrintStream ( proc . getOutputStream ( ) ) ; StreamTokenizer stok = new StreamTokenizer ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; ps . println ( "3 " + nump ) ; for ( int i = 0 ; i < nump ; i ++ ) { ps . println ( coords [ i * 3 + 0 ] + " " + coords [ i * 3 + 1 ] + " " + coords [ i * 3 + 2 ] ) ; } ps . flush ( ) ; ps . close ( ) ; Vector indexList = new Vector ( 3 ) ; stok . eolIsSignificant ( true ) ; printQhullErrors ( proc ) ; do { stok . nextToken ( ) ; } while ( stok . sval == null || ! stok . sval . startsWith ( "MERGEexact" ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { stok . nextToken ( ) ; } if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting number of faces" ) ; System . exit ( 1 ) ; } int numf = ( int ) stok . nval ; stok . nextToken ( ) ; int [ ] [ ] faceIndices = new int [ numf ] [ ] ; for ( int i = 0 ; i < numf ; i ++ ) { indexList . clear ( ) ; while ( stok . nextToken ( ) != StreamTokenizer . TT_EOL ) { if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting face index" ) ; System . exit ( 1 ) ; } indexList . add ( 0 , new Integer ( ( int ) stok . nval ) ) ; } faceIndices [ i ] = new int [ indexList . size ( ) ] ; int k = 0 ; for ( Iterator it = indexList . iterator ( ) ; it . hasNext ( ) ; ) { faceIndices [ i ] [ k ++ ] = ( ( Integer ) it . next ( ) ) . intValue ( ) ; } } setHull ( coords , nump , faceIndices , numf ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
te	2	public static BitSet fromByteArray ( byte [ ] bytes ) { BitSet bits = new BitSet ( ) ; for ( int i = 0 ; i < bytes . length * 8 ; i ++ ) { if ( ( bytes [ bytes . length - i / 8 - 1 ] & ( 1 << ( i % 8 ) ) ) > 0 ) { bits . set ( i ) ; } } for ( int k = bits . size ( ) - 1 ; k >= 0 ; k -- ) { System . out . print ( ( bits . get ( k ) ) ? "1" : "0" ) ; } System . out . println ( ) ; return bits ; }
te	3	public static double performForward ( final Net net , final Sample sample , final int [ ] features ) { final int inputlength = sample . getInputLength ( ) ; final int targetlength = sample . getTargetLength ( ) ; final int last = ( sample . getInputLength ( ) - 1 ) ; net . setFrameIdx ( 0 ) ; double error = 0.0 ; if ( net . isOnline ( ) ) { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapInput ( net . inputPort ( ) , t , features ) ; } else { sample . mapInput ( net . inputPort ( ) , t ) ; } net . compute ( ) ; if ( t < last ) net . incrFrameIdx ( ) ; } final int first = Math . max ( 0 , inputlength - targetlength ) ; int soff = targetlength - 1 ; for ( int t = last ; t >= first ; t -- ) { sample . mapTarget ( net . targetPort ( ) , soff -- ) ; error += net . error ( ) ; if ( t > 0 ) net . decrFrameIdx ( ) ; } net . setFrameIdx ( last ) ; } else { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapInput ( net . inputPort ( ) , t , features ) ; } else { sample . mapInput ( net . inputPort ( ) , t ) ; } if ( t < last ) net . incrFrameIdx ( ) ; } net . compute ( ) ; sample . mapTarget ( net . targetPort ( ) ) ; error = net . error ( ) ; } return ( error / ( ( double ) targetlength ) ) ; }
te	4X	public Curve center ( ) { for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] = 0 ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) vec [ j ] += dd [ i ] [ j ] ; for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] /= nRows ( ) ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) dd [ i ] [ j ] -= vec [ j ] ; return this ; }
te	3	@ Override public int classify ( Pattern instance ) { double [ ] [ ] xM = Matrix . trans ( new double [ ] [ ] { Matrix . res ( instance . toDoubleVector ( ) , mean ) } ) ; double [ ] [ ] yM = Matrix . mult ( M , xM ) ; double [ ] [ ] yMCopy = new double [ yM . length ] [ 1 ] ; for ( int ix = 0 ; ix < yM . length ; ix ++ ) System . arraycopy ( yM [ ix ] , 0 , yMCopy [ ix ] , 0 , yM [ ix ] . length ) ; double max = - double . MAX_VALUE ; for ( int i = 0 ; i < yM . length ; i ++ ) { if ( yM [ i ] [ 0 ] > max ) { max = yM [ i ] [ 0 ] ; } } int result = - 1 ; for ( int j = 0 ; j < yM . length ; j ++ ) { if ( yM [ j ] [ 0 ] == max ) { yM [ j ] [ 0 ] = 1d ; result = j ; } else { yM [ j ] [ 0 ] = 0d ; } } return result ; }
te	0	public String getMessage ( ) { return super . getMessage ( ) + SEPARATOR + getErrnoString ( ) + " [" + errno + "] " ; }
te	4X	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; long c = scan . nextLong ( ) ; boolean blown = false ; int act = 0 ; int max = 0 ; int cont = 1 ; while ( m != 0 && n != 0 && c != 0 ) { boolean [ ] aprs = new boolean [ n ] ; long [ ] aprscons = new long [ n ] ; int [ ] ops = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) aprscons [ i ] = scan . nextLong ( ) ; for ( int i = 0 ; i < m ; i ++ ) ops [ i ] = scan . nextInt ( ) ; for ( int op : ops ) if ( aprs [ op - 1 ] == false ) { act += aprscons [ op - 1 ] ; aprs [ op - 1 ] = true ; if ( act > c ) { System . out . println ( "Sequence " + cont ) ; System . out . println ( "Fuse was blown." ) ; blown = true ; break ; } else if ( act > max ) max = act ; } else { act -= aprscons [ op - 1 ] ; aprs [ op - 1 ] = false ; } if ( blown == false ) { System . out . println ( "Sequence " + cont ) ; System . out . println ( "Fuse was not blown." ) ; System . out . println ( "Maximal power consumption was " + max + " amperes." ) ; } n = scan . nextInt ( ) ; m = scan . nextInt ( ) ; c = scan . nextLong ( ) ; cont ++ ; max = 0 ; act = 0 ; blown = false ; System . out . println ( ) ; } }
te	3	public Team createBot ( ) { Logger . log ( "Creating Bot." , Logger . GAME ) ; int registeredClients = clientsAtServer . size ( ) ; TestClient tc = new TestClient ( getPort ( ) , "bottt" ) ; tc . start ( ) ; while ( clientsAtServer . size ( ) == registeredClients ) { try { sleep ( 5 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } while ( true ) { for ( Team team : clientsAtServer ) { if ( team . getName ( ) . equals ( "bottt" ) ) { team . setOnline ( false ) ; Communication . sendMsg ( team , Communication . GAMEOVER ) ; return team ; } } } }
te	2	public void removeDeadTransitions ( ) { clearHashCode ( ) ; if ( isSingleton ( ) ) return ; Set < State > states = getStates ( ) ; Set < State > live = getLiveStates ( states ) ; for ( State s : states ) { Set < Transition > st = s . transitions ; s . resetTransitions ( ) ; for ( Transition t : st ) if ( live . contains ( t . to ) ) s . transitions . add ( t ) ; } reduce ( ) ; }
te	4X	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
te	1	private static List < String > readStringSubKeys ( Preferences root , int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { List < String > results = new ArrayList < String > ( ) ; int [ ] handles = ( int [ ] ) regOpenKey . invoke ( root , new Object [ ] { new Integer ( hkey ) , toCstr ( key ) , new Integer ( KEY_READ ) } ) ; if ( handles [ 1 ] != REG_SUCCESS ) { return null ; } int [ ] info = ( int [ ] ) regQueryInfoKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; int count = info [ 0 ] ; int maxlen = info [ 3 ] ; for ( int index = 0 ; index < count ; index ++ ) { byte [ ] name = ( byte [ ] ) regEnumKeyEx . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) , new Integer ( index ) , new Integer ( maxlen + 1 ) } ) ; results . add ( new String ( name ) . trim ( ) ) ; } regCloseKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; return results ; }
te	2	private void putConcurrentListenableMap ( int numThreads , int max ) throws InterruptedException { CountDownLatch allDone = new CountDownLatch ( numThreads ) ; ListenableConcurrentMap < String , String > map = new ListenableConcurrentHashMap ( ) ; List < Thread > threads = new ArrayList < > ( numThreads ) ; for ( int i = 0 ; i < numThreads ; i ++ ) threads . add ( new Thread ( listenableConcurrentPutBlock ( map , max , allDone ) ) ) ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < numThreads ; i ++ ) threads . get ( i ) . start ( ) ; allDone . await ( ) ; System . out . println ( "time for " + numThreads + " threads concurrent: " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; }
te	2	private static void Insert ( int [ ] a , int num , int length ) { int i ; for ( i = 0 ; i < length ; i ++ ) { if ( num < a [ i ] ) break ; } for ( int j = length ; j >= i ; j -- ) { a [ j + 1 ] = a [ j ] ; } length ++ ; a [ i ] = num ; }
te	3	public void setDestinations ( String [ ] destinations ) throws Exception { ArrayList < Integer > dests = new ArrayList < Integer > ( ) ; int proteinId ; for ( String proteinName : destinations ) { proteinId = nomenclature . NametoID ( proteinName . trim ( ) ) ; if ( proteinId != - 1 ) dests . add ( proteinId ) ; } srcGraph . dests = new int [ dests . size ( ) ] ; srcGraph . subGraph . clear ( ) ; for ( int i = 0 ; i < dests . size ( ) ; i ++ ) srcGraph . dests [ i ] = dests . get ( i ) ; destGraph . srces = new int [ dests . size ( ) ] ; for ( int i = 0 ; i < dests . size ( ) ; i ++ ) destGraph . srces [ i ] = dests . get ( i ) ; }
te	1	public static ProcessorLayer createProcessorLayerWithProcessorNeuron ( int neuronsNum , boolean bias ) { ProcessorLayer layer = new ProcessorLayer ( ) ; if ( bias ) { layer . addNeuron ( new BiasNeuron ( ) ) ; } for ( int i = 0 ; i < neuronsNum ; i ++ ) layer . addNeuron ( new ProcessorNeuron ( ) ) ; return layer ; }
te	0	public static void input ( float delta ) { if ( nextScene != null ) { updateLoadScene ( ) ; } rootNode . input ( delta ) ; }
te	4X	public static void main ( String [ ] args ) { int LENGTH = 5 ; int [ ] sort = new int [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { sort [ i ] = ( int ) ( Math . random ( ) * 40 ) ; } String s = "" ; for ( int nr : sort ) { s += nr + " " ; } System . out . println ( "sorting table: " + s ) ; for ( int i = 1 ; i < sort . length ; i ++ ) { int key = sort [ i ] ; int j = i - 1 ; while ( j >= 0 && sort [ j ] > key ) { sort [ j + 1 ] = sort [ j ] ; j -= 1 ; } sort [ j + 1 ] = key ; } String ss = "" ; for ( int nr : sort ) { ss += nr + " " ; } System . out . println ( "sorted table: " + ss ) ; }
te	1	private void go ( ) { addHeader ( ) ; for ( int a = 1 ; a < 6 ; a ++ ) { add ( "submission" + a + ".csv" ) ; } export ( ) ; }
te	1	public int GetSumOfFactorialsOfDigitsInNumber ( int candidate ) { String digits = Integer . toString ( candidate ) ; int toReturn = 0 ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { toReturn += FactorializeSmallNumber ( Integer . parseInt ( digits . substring ( i , i + 1 ) ) ) ; } return toReturn ; }
te	3	public static LookupOp createLookupOp ( ) { byte [ ] [ ] data = new byte [ 4 ] [ 256 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) data [ i ] [ j ] = ( byte ) j ; } for ( int i = 0 ; i < 256 ; i ++ ) data [ 3 ] [ i ] = ( byte ) ( 255 - i ) ; ByteLookupTable lookup = new ByteLookupTable ( 0 , data ) ; return new LookupOp ( lookup , null ) ; }
te	1	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
te	4X	@ Override public Map < Object , double > calculateProbabilityForClassifications ( double [ ] x ) { Map < Object , double > probs = new HashMap < Object , double > ( ) ; for ( int i = 0 ; i < x . length ; i ++ ) { for ( Object c : this . classCount . keySet ( ) ) { double prob = this . probability ( x [ i ] , c , i ) ; if ( ! probs . containsKey ( c ) ) probs . put ( c , prob ) ; else probs . put ( c , probs . get ( c ) + prob ) ; } } for ( int i = 0 ; i < x . length ; i ++ ) { for ( Object o : probs . keySet ( ) ) { double estimatedProb = this . ke . get ( o ) . get ( i ) . probability ( x [ i ] ) ; probs . put ( o , estimatedProb * probs . get ( o ) ) ; } } Utils . percentify ( probs ) ; return probs ; }
te	2	@ Override public Hashtable < String , Document > loadDocuments ( ) throws Exception { File dir = new File ( this . datasetPath ) ; String [ ] categories = dir . list ( ) ; for ( int i = 0 ; i < categories . length ; i ++ ) { String categoryName = categories [ i ] ; this . originalClasses . add ( categoryName ) ; String [ ] docsInCategory = new File ( this . datasetPath + "/" + categoryName ) . list ( ) ; this . classDocumentCount . put ( categoryName , docsInCategory . length ) ; for ( int j = 0 ; j < docsInCategory . length ; j ++ ) { this . numberOfDocument ++ ; String documentName = docsInCategory [ j ] ; File input = new File ( this . datasetPath + "/" + categoryName + "/" + documentName ) ; org . jsoup . nodes . Document doc = Jsoup . parse ( input , "UTF-8" , "" ) ; String title = categoryName + " " + doc . title ( ) . replaceAll ( "(\\r|\\n)" , ". " ) ; String body = getFirstNWords ( doc . text ( ) . replaceAll ( "(\\r|\\n)" , ". " ) . replaceAll ( "\\s+" , " " ) ) ; Document stemmedDocument = DocumentManager . createDocument ( categoryName + "_" + documentName , title , body ) ; stemmedDocument . setOrginalCluster ( categoryName ) ; this . documentHash . put ( stemmedDocument . getId ( ) , stemmedDocument ) ; this . documentsIDS . add ( stemmedDocument . getId ( ) ) ; } } return this . documentHash ; }
te	0	public Iterator < ChannelUser > iterChannelUsers ( ) { return users . iterator ( ) ; }
te	2	public void calLongestSnakeSequence ( ) { int n = A . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { } } }
te	0	public int getIdp ( ) { return this . idp ; }
te	3	List < Constraint > removePropagateFrom ( Variable out ) { out . determinedBy = null ; out . walkStrength = WEAKEST ; out . stay = true ; List < Constraint > unsatisfied = new ArrayList < Constraint > ( ) ; List < Variable > todo = new ArrayList < Variable > ( ) ; todo . add ( out ) ; while ( todo . size ( ) > 0 ) { Variable v = todo . remove ( todo . size ( ) - 1 ) ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint c = v . constraints . get ( i ) ; if ( ! c . isSatisfied ( ) ) unsatisfied . add ( c ) ; } Constraint determining = v . determinedBy ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint next = v . constraints . get ( i ) ; if ( next != determining && next . isSatisfied ( ) ) { next . recalculate ( ) ; todo . add ( next . output ( ) ) ; } } } return unsatisfied ; }
te	1	public List < T > getList ( T [ ] x ) { List < T > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < x . length ; ++ i ) { l . add ( x [ i ] ) ; } return l ; }
te	1	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
te	3	public synchronized void update ( ) { Tile . WATER . update ( ) ; for ( int i = 0 ; i < mobs . size ( ) ; i ++ ) { if ( ! mobs . get ( i ) . isRemoved ( ) && mobs . get ( i ) != null ) { mobs . get ( i ) . update ( ) ; } else { mobs . remove ( i ) ; } } for ( int i = 0 ; i < particles . size ( ) ; i ++ ) { if ( ! particles . get ( i ) . isRemoved ( ) ) { particles . get ( i ) . update ( ) ; } else { particles . remove ( i ) ; } } for ( int i = 0 ; i < projectiles . size ( ) ; i ++ ) { if ( ! projectiles . get ( i ) . isRemoved ( ) ) { projectiles . get ( i ) . update ( ) ; } else { projectiles . remove ( i ) ; } } }
te	3	public IndexedModel toIndexedModel ( ) { IndexedModel result = new IndexedModel ( ) ; IndexedModel normalModel = new IndexedModel ( ) ; HashMap < OBJIndex , Integer > resultIndexMap = new HashMap < OBJIndex , Integer > ( ) ; HashMap < Integer , Integer > normalIndexMap = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > indexMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < indices . size ( ) ; i ++ ) { OBJIndex currentIndex = indices . get ( i ) ; Vector3f currentPosition = positions . get ( currentIndex . vertexIndex ) ; Vector2f currentTexCoord ; Vector3f currentNormal ; if ( hasTexCoords ) currentTexCoord = texCoords . get ( currentIndex . texCoordIndex ) ; else currentTexCoord = new Vector2f ( 0 , 0 ) ; if ( hasNormals ) currentNormal = normals . get ( currentIndex . normalIndex ) ; else currentNormal = new Vector3f ( 0 , 0 , 0 ) ; Integer modelVertexIndex = resultIndexMap . get ( currentIndex ) ; if ( modelVertexIndex == null ) { modelVertexIndex = result . getPositions ( ) . size ( ) ; resultIndexMap . put ( currentIndex , modelVertexIndex ) ; result . getPositions ( ) . add ( currentPosition ) ; result . getTexCoords ( ) . add ( currentTexCoord ) ; if ( hasNormals ) result . getNormals ( ) . add ( currentNormal ) ; result . getTangents ( ) . add ( new Vector3f ( 0 , 0 , 0 ) ) ; } Integer normalModelIndex = normalIndexMap . get ( currentIndex . vertexIndex ) ; if ( normalModelIndex == null ) { normalModelIndex = normalModel . getPositions ( ) . size ( ) ; normalIndexMap . put ( currentIndex . vertexIndex , normalModelIndex ) ; normalModel . getPositions ( ) . add ( currentPosition ) ; normalModel . getTexCoords ( ) . add ( currentTexCoord ) ; normalModel . getNormals ( ) . add ( currentNormal ) ; normalModel . getTangents ( ) . add ( new Vector3f ( 0 , 0 , 0 ) ) ; } result . getIndices ( ) . add ( modelVertexIndex ) ; normalModel . getIndices ( ) . add ( normalModelIndex ) ; indexMap . put ( modelVertexIndex , normalModelIndex ) ; } if ( ! hasNormals ) { normalModel . calcNormals ( ) ; for ( int i = 0 ; i < result . getPositions ( ) . size ( ) ; i ++ ) result . getNormals ( ) . add ( normalModel . getNormals ( ) . get ( indexMap . get ( i ) ) ) ; } normalModel . calcTangents ( ) ; for ( int i = 0 ; i < result . getPositions ( ) . size ( ) ; i ++ ) result . getTangents ( ) . add ( normalModel . getTangents ( ) . get ( indexMap . get ( i ) ) ) ; return result ; }
te	1	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
te	4X	@ SuppressWarnings ( "unchecked" ) private Set < WFF > makeCorrectDepthResults ( WFF source ) { HashSet < WFF > results = new HashSet < WFF > ( ) ; try { Logic logic = new ClassicalLogicS ( ) ; if ( source . getFormula ( ) . length ( ) < 1 ) { return results ; } ; formula = ( Formula ) logic . createExpression ( source . getFormula ( ) ) ; Formula result = ClassicalLogicS . Utilities . conjunctiveForm ( formula , true ) ; DefaultClausalFactory myFacts = new DefaultClausalFactory ( ) ; ClausalSet myClauses = myFacts . asClausalSet ( result ) ; PartitionListElement < Clause > reducedWFF = new PartitionListElement < Clause > ( ) ; for ( Clause cls : ( Set < Clause > ) myClauses ) { reducedWFF . add ( cls ) ; } int [ ] indices ; CombinationGenerator x = new CombinationGenerator ( reducedWFF . size ( ) , currentDepth ) ; StringBuffer combination ; HashSet < String > myWFF = new HashSet < String > ( ) ; while ( x . hasMore ( ) ) { combination = new StringBuffer ( ) ; indices = x . getNext ( ) ; for ( int i = 0 ; i < indices . length ; i ++ ) { combination . append ( reducedWFF . get ( indices [ i ] ) ) ; } String mynewWFF = combination . toString ( ) ; myWFF . add ( mynewWFF . replaceAll ( "\\]\\[" , "\\] \\[" ) ) ; } for ( String formString : myWFF ) { String newForm = formString ; newForm = newForm . replaceAll ( "\\[" , "(" ) ; newForm = newForm . replaceAll ( "\\] " , ") & " ) ; newForm = newForm . replaceAll ( "\\]" , ")" ) ; newForm = newForm . replaceAll ( " " , " |" ) ; results . add ( new WFF ( newForm ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return results ; }
te	3	public static void main ( String [ ] argv ) throws IOException { AvaloneGLAPI glapi = new AvaloneGLAPI ( 1200 , 600 , "APITest" ) ; new APItest ( ) ; glEnable ( GL_TEXTURE_2D ) ; int z = 0 ; boolean forward = true ; while ( ! Display . isCloseRequested ( ) ) { glapi . glLoopBegin ( ) ; if ( z < 100 && forward ) { z ++ ; glViewport ( z , 0 , Display . getDisplayMode ( ) . getWidth ( ) , Display . getDisplayMode ( ) . getHeight ( ) ) ; } else if ( z == 100 && forward ) { forward = false ; } else if ( z > - 100 && ! forward ) { z -- ; glViewport ( z , 0 , Display . getDisplayMode ( ) . getWidth ( ) , Display . getDisplayMode ( ) . getHeight ( ) ) ; } else if ( z == - 100 && ! forward ) { forward = true ; } p1 . x = - 10 ; p2 . x = 10 ; p1 . y = - 10 ; p2 . y = 10 ; glapi . drawRect ( p1 , p2 , "GREEN" ) ; glBegin ( GL_QUADS ) ; glVertex2i ( - 50 , - 50 ) ; glVertex2i ( 50 , - 50 ) ; glVertex2i ( 50 , 50 ) ; glVertex2i ( - 50 , 50 ) ; glEnd ( ) ; p1 . x = 20 ; p2 . x = 40 ; p1 . y = 20 ; p2 . y = 40 ; glapi . drawRect ( p1 , p2 , "RED" ) ; glapi . drawEmptyRect ( p1 , p2 , "WHITE" ) ; p1 . x = 100 ; p2 . x = 300 ; glapi . drawCircle ( p2 , 20 , "BLUE" ) ; p2 . x = 120 ; p1 . y = 200 ; p2 . y = 180 ; glapi . drawEllipse ( p1 , p2 , 50 , "YELLOW" ) ; p3 . y = 150 ; p1 . x = 600 ; p2 . x = 800 ; p3 . x = 700 ; glapi . drawTriangle ( p1 , p2 , p3 , "GREEN" ) ; glapi . drawEmptyTriangle ( p1 , p2 , p3 , "WHITE" ) ; p1 . x = 1000 ; glapi . drawStar ( p1 , 30 , "DARK_BLUE" ) ; glapi . drawEmptyStar ( p1 , 30 , "WHITE" ) ; p1 . y = 500 ; glapi . drawThunder ( p1 , 30 , "WHITE" ) ; p1 . x = 400 ; p2 . x = 450 ; p1 . y = 150 ; p2 . y = 200 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . y = 100 ; p2 . y = 50 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . x = 550 ; p2 . x = 500 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . y = 150 ; p2 . y = 200 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; glapi . unbindTexture ( ) ; p1 . x = 1050 ; p2 . x = 1100 ; p1 . y = 250 ; p2 . y = 300 ; glapi . drawAlphaRect ( p1 , p2 , "RED" , 0.3f ) ; p1 . y = 400 ; p2 . y = 450 ; p1 . x = 750 ; p2 . x = 800 ; glapi . drawText ( p1 , p2 , "test" , "BLUE" ) ; p1 . y = 300 ; p2 . y = 330 ; glapi . drawText ( p1 , p2 , "abcde" , "BLUE" ) ; p1 . x = 100 ; p2 . x = 355 ; p1 . y = 515 ; p2 . y = 560 ; glapi . drawText ( p1 , p2 , "d\u00E9grad\u00E9 lwjgl" , "BLUE" ) ; p1 . y = 250 ; p2 . y = 505 ; glBegin ( GL_QUADS ) ; glColor3f ( 0 , 0 , 0 ) ; glVertex2i ( p1 . x , p1 . y ) ; glColor3f ( 0 , 1 , 0 ) ; glVertex2i ( p2 . x , p1 . y ) ; glColor3f ( 1 , 0 , 0 ) ; glVertex2i ( p2 . x , p2 . y ) ; glColor3f ( 0 , 0 , 1 ) ; glVertex2i ( p1 . x , p2 . y ) ; glEnd ( ) ; p1 . x = 400 ; p2 . x = 600 ; p1 . y = 515 ; p2 . y = 560 ; glapi . drawText ( p1 , p2 , "d\u00E9grad\u00E9 okidor" , "BLUE" ) ; p1 . y = 250 ; p2 . y = 505 ; glBegin ( GL_POINTS ) ; for ( int i = 0 ; i < 256 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) { int red = ( i * j ) / 255 ; int green = i - red ; int blue = j - red ; glColor3f ( red / 255.0f , green / 255.0f , blue / 255.0f ) ; glVertex2i ( p1 . x + i , p1 . y + j ) ; } } glEnd ( ) ; glapi . glLoopEnd ( ) ; Display . update ( ) ; } Display . destroy ( ) ; }
te	0	@ Override public void setDataVector ( Vector newData , Vector columnNames ) { if ( newData == null ) { throw new IllegalArgumentException ( "setDataVector1() - Null parameter" ) ; } super . setDataVector ( dataVector , columnNames ) ; dataVector = newData ; attributiveModel = new DefaultCellAttribute ( dataVector . size ( ) , columnIdentifiers . size ( ) ) ; newRowsAdded ( new TableModelEvent ( this , 0 , getRowCount ( ) - 1 , TableModelEvent . ALL_COLUMNS , TableModelEvent . INSERT ) ) ; }
te	2	public String reverseWords ( String s ) { if ( s . length ( ) == 0 ) return s ; String [ ] arr = s . split ( " " ) ; ArrayList < String > aa = new ArrayList < String > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; String ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
te	1	public void addEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null ) { vFrom = new Vertex ( vi ) ; vs . add ( vFrom ) ; } if ( vi != vj ) { if ( vTo == null ) { vTo = new Vertex ( vj ) ; vs . add ( vTo ) ; } vFrom . adjacent . add ( vTo ) ; vTo . adjacent . add ( vFrom ) ; } else { vFrom . adjacent . add ( vFrom ) ; } }
te	1	public static void main ( String [ ] args ) { System . out . println ( "Testing binary Max Heap\n" ) ; MaxHeap heap = new MaxHeap ( ) ; int [ ] inputs = { 10 , 20 , 30 , 40 , 100 , 50 , 60 , 70 , 80 , 90 , 190 } ; for ( int i = 0 ; i < inputs . length ; i ++ ) heap . insert ( inputs [ i ] ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Inserting 3" ) ; heap . insert ( 3 ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; }
te	4X	private void generate ( ) { for ( int c = 0 ; c < levels . size ( ) ; c ++ ) { Level clevel = levels . get ( c ) ; for ( int x = 0 ; x < sizex ; x ++ ) { for ( int y = 0 ; y < sizey ; y ++ ) { if ( x == 0 || x == sizex - 1 ) { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . WALL_STONE ) ; } else if ( y == 0 || y == sizey - 1 ) { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . WALL_STONE ) ; } else { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . FLOOR_STONE ) ; } } } if ( clevel . level != 0 ) { ArrayList < Point > upstairs = levels . get ( clevel . level - 1 ) . downStairLocs ( ) ; for ( int z = 0 ; z < upstairs . size ( ) ; z ++ ) { clevel . createEntity ( new StoneStair ( upstairs . get ( z ) , true ) ) ; } } if ( clevel . level != levels . size ( ) - 1 ) { int downstairx , downstairy ; int runnum = 0 ; while ( true ) { Log . print ( runnum + "" ) ; downstairx = Rand . randInt ( 2 , sizex - 1 ) ; downstairy = Rand . randInt ( 2 , sizey - 1 ) ; if ( clevel . entityFree ( downstairx , downstairy ) ) { break ; } runnum ++ ; } clevel . createEntity ( new StoneStair ( new Point ( downstairx , downstairy ) , false ) ) ; } clevel . actorHashMap . put ( genKey ( 8 , 8 ) , new Actor ( new Point ( 8 , 8 ) , ActorType . goblin ) ) ; } }
te	4X	public static int [ ] shellSort ( int [ ] arr ) { arrTemp = arr . clone ( ) ; int dis = arrTemp . length ; while ( true ) { dis = dis / 2 ; for ( int x = 0 ; x < dis ; x ++ ) { for ( int i = x + dis ; i < arrTemp . length ; i = i + dis ) { int temp = arrTemp [ i ] ; int j ; for ( j = i - dis ; j >= 0 && arrTemp [ j ] > temp ; j = j - dis ) { arrTemp [ j + dis ] = arrTemp [ j ] ; } arrTemp [ j + dis ] = temp ; } } if ( dis == 1 ) { break ; } } return arrTemp ; }
te	1	public void addMouseListener ( MouseListener mouseListener ) { super . addMouseListener ( mouseListener ) ; for ( Component component : getComponents ( ) ) { component . addMouseListener ( mouseListener ) ; } }
te	4X	public static void main ( String [ ] args ) throws SQLException { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new mainWindow ( ) . setVisible ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } ) ; sqlConnection connnect = new sqlConnection ( ) ; selectQueries sql = new selectQueries ( ) ; insertQueries sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; rcmList rcms = new rcmList ( ) ; ArrayList < Recycler > rcm = new ArrayList < Recycler > ( ) ; for ( Recycler i : rcms . getRcmList ( ) ) { System . out . println ( "RCMS Detected" ) ; System . out . println ( i . getLocation ( ) + " : " + i . getId ( ) ) ; rcm . add ( new Recycler ( i . getLocation ( ) , i . getId ( ) ) ) ; } Object [ ] r = new Object [ rcm . size ( ) ] ; int j = 0 ; for ( Recycler i : rcm ) { r [ j ] = i ; j ++ ; } for ( int k = 0 ; k < rcm . size ( ) ; k ++ ) { int k1 = k ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "paper" , 1 , 5 , 20 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "cloth" , 3 , 3 , 40 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "glass" , 2 , 6 , 10 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "paper" , 1 , 5 , 20 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "cloth" , 3 , 3 , 40 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "glass" , 2 , 6 , 10 ) , "CASH" ) ; } }
te	0	public String getStr ( ) { return str ; }
te	2	@ Override public String execute ( ) throws Exception { String delimiter = "-" ; setTemp ( getSdate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setSdate ( getTemp ( ) [ i + 1 ] + / + getTemp ( ) [ i + 2 ] + / + getTemp ( ) [ i ] ) ; } setTemp ( getEdate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setEdate ( getTemp ( ) [ i + 1 ] + / + getTemp ( ) [ i + 2 ] + / + getTemp ( ) [ i ] ) ; } return "success" ; }
te	0	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
te	2	public void testContinue ( ) { outer : for ( int j = 0 ; j < 5 ; j ++ ) { System . out . println ( "Starting main loop j=" + j ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { int num = ( int ) ( Math . random ( ) * 100 ) ; if ( num == 0 ) { System . out . println ( "********** Got 0" ) ; break outer ; } System . out . println ( i / num ) ; } } }
te	0	public void validate ( ) throws org . apache . thrift7 . TException { }
te	1	public void setThresholds ( List < U > thresholds ) throws Exception { if ( thresholds . size ( ) != neurons . size ( ) ) { throw new Exception ( "threshold count doesnt match neuron count in this layer" ) ; } for ( int i = 0 ; i < neurons . size ( ) ; i ++ ) { neurons . get ( i ) . setThreshold ( thresholds . get ( i ) ) ; } }
te	2	private ArrayList < String > RemoveStopWords ( ArrayList < String > textSnippets ) { String regex = "" , regexCaps = "" ; ArrayList < String > rem ; String path = System . getProperty ( "user.dir" ) ; File f = new File ( path , Settings . get ( "STOPWORD_LIST_PATH_SEARCH" ) ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String line = "" ; line = br . readLine ( ) ; while ( line != null ) { regexCaps = line . substring ( 0 , 1 ) . toUpperCase ( ) + line . substring ( 1 ) ; regex = " " + line + " | " + regexCaps + " " ; rem = new ArrayList < String > ( ) ; for ( String temp : textSnippets ) { temp = " " + temp + " " ; temp = temp . replaceAll ( regex , " " ) ; rem . add ( temp . trim ( ) ) ; } textSnippets = rem ; line = br . readLine ( ) ; } br . close ( ) ; } catch ( FileNotFoundException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } catch ( IOException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } return textSnippets ; }
te	2	public void selectSort ( int [ ] data ) { if ( data == null ) { throw new NullPointerException ( "Input array is null." ) ; } for ( int i = 0 ; i < data . length ; i ++ ) { int small = i , tmp ; for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ small ] > data [ j ] ) { small = j ; } } tmp = data [ i ] ; data [ i ] = data [ small ] ; data [ small ] = tmp ; } }
te	4X	public boolean checkWin ( IPlayer player ) { int numberOfMatches = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ i ] [ numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; } for ( int j = 0 ; j < 3 ; j ++ ) { for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ j ] != player ) break ; if ( numberOfMatches == 3 ) return true ; } for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ 2 - numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; return false ; }
te	1	public List < Frequencia > getFrequenciaFuncionario2 ( Integer mes , Integer ano , Integer dia , Integer ultimodia , Integer idFuncionario ) throws SQLException { List < Frequencia > frequencia = new ArrayList < Frequencia > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM frequencia WHERE idfuncionario = ? and data between ? and ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; Calendar c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , dia ) ; ps . setDate ( 2 , new Date ( c . getTimeInMillis ( ) ) ) ; c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , ultimodia ) ; ps . setDate ( 3 , new Date ( c . getTimeInMillis ( ) ) ) ; Frequencia f ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { f = new Frequencia ( ) ; f . setId ( rs . getInt ( "idfrequencia" ) ) ; f . setData ( rs . getDate ( "data" ) ) ; f . setPresenca ( rs . getBoolean ( "presenca" ) ) ; f . setFuncionario ( new FuncionarioDao ( ) . getfuncionario ( rs . getInt ( "idFuncionario" ) ) ) ; f . setHoraSaida ( rs . getTimestamp ( "hora_saida" ) ) ; f . setTurno ( rs . getString ( "turno" ) ) ; frequencia . add ( f ) ; } return frequencia ; }
te	4X	public static int [ ] getAlleleCounts ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; int alleleTotals [ ] = new int [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; if ( v > 0 ) { alleleTotals [ i ] += 1 ; } } i ++ ; } } } return alleleTotals ; }
te	1	private void beforeShade ( Light light , ColorRGB color ) { for ( TracerInterceptor interceptor : interceptors ) { interceptor . beforeShade ( light , color ) ; } }
te	2	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	0	public int getSize ( ) { return size ; }
te	3	public static int [ ] randomize ( int num_choices ) { int [ ] rnd = new int [ 4 ] ; rnd [ 0 ] = ( int ) ( Math . random ( ) * num_choices ) ; do { rnd [ 1 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 1 ] == rnd [ 0 ] ) ; do { rnd [ 2 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 2 ] == rnd [ 0 ] || rnd [ 2 ] == rnd [ 1 ] ) ; do { rnd [ 3 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 3 ] == rnd [ 0 ] || rnd [ 3 ] == rnd [ 1 ] || rnd [ 3 ] == rnd [ 2 ] ) ; return rnd ; }
te	4X	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; v_1 = cursor ; lab0 : do { if ( ! r_prelude ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { if ( ! r_mark_regions ( ) ) { break lab1 ; } } while ( false ) ; cursor = v_2 ; limit_backward = cursor ; cursor = limit ; v_3 = limit - cursor ; lab2 : do { if ( ! r_attached_pronoun ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; v_4 = limit - cursor ; lab3 : do { lab4 : do { v_5 = limit - cursor ; lab5 : do { if ( ! r_standard_suffix ( ) ) { break lab5 ; } break lab4 ; } while ( false ) ; cursor = limit - v_5 ; if ( ! r_verb_suffix ( ) ) { break lab3 ; } } while ( false ) ; } while ( false ) ; cursor = limit - v_4 ; v_6 = limit - cursor ; lab6 : do { if ( ! r_vowel_suffix ( ) ) { break lab6 ; } } while ( false ) ; cursor = limit - v_6 ; cursor = limit_backward ; v_7 = cursor ; lab7 : do { if ( ! r_postlude ( ) ) { break lab7 ; } } while ( false ) ; cursor = v_7 ; return true ; }
te	0	public BaseLight ( Vector3f color , float intensity ) { this . color = color ; this . intensity = intensity ; }
te	3	@ SuppressWarnings ( "unchecked" ) private Map < OrderPreviewField , String > getMarketPreviewOrderPaths ( Document doc ) throws UtilityException { Map < OrderPreviewField , String > toReturn = new HashMap < OrderPreviewField , String > ( ) ; for ( OrderPreviewField f : OrderPreviewField . values ( ) ) { String path = f . getPath ( ) ; if ( f . equals ( OrderPreviewField . ERROR ) ) { if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; throw new UtilityException ( url ) ; } } } if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; toReturn . put ( f , url ) ; } } } return toReturn ; }
te	2	public static void insertionSort ( int [ ] xs ) { for ( int j = 1 ; j < xs . length ; j ++ ) { int key = xs [ j ] ; int i = j - 1 ; while ( i >= 0 && key < xs [ i ] ) { xs [ i + 1 ] = xs [ i ] ; i -- ; } xs [ i + 1 ] = key ; } return ; }
te	0	public StatTracker ( int health , int will , int power , int afinity , int clarity ) { super ( ) ; initialiseComponants ( health , will , afinity , power , clarity ) ; update ( ) ; }
te	4X	public static void bubbleSortImproved ( int [ ] a ) { System . out . println ( "Array before sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; System . out . println ( ) ; System . out . println ( "Sorting sequences after each iteration" ) ; int n = a . length ; boolean swapped = true ; for ( int i = 0 ; i < n && swapped ; i ++ ) { swapped = false ; for ( int j = 0 ; j < ( n - i - 1 ) ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { int temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; swapped = true ; } } for ( int k : a ) System . out . print ( k + " " ) ; System . out . println ( ) ; } System . out . println ( "Array after sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; }
te	1	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append (  ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
te	4X	public void setZeroes ( int [ ] [ ] matrix ) { boolean firstRowZero = false ; boolean firstColumnZero = false ; for ( int i = 0 ; i < matrix . length ; i ++ ) { if ( matrix [ i ] [ 0 ] == 0 ) { firstColumnZero = true ; break ; } } for ( int i = 0 ; i < matrix [ 0 ] . length ; i ++ ) { if ( matrix [ 0 ] [ i ] == 0 ) { firstRowZero = true ; break ; } } for ( int i = 1 ; i < matrix . length ; i ++ ) { for ( int j = 1 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] == 0 ) { matrix [ i ] [ 0 ] = 0 ; matrix [ 0 ] [ j ] = 0 ; } } } for ( int i = 1 ; i < matrix . length ; i ++ ) { for ( int j = 1 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ 0 ] == 0 || matrix [ 0 ] [ j ] == 0 ) { matrix [ i ] [ j ] = 0 ; } } } if ( firstColumnZero ) { for ( int i = 0 ; i < matrix . length ; i ++ ) { matrix [ i ] [ 0 ] = 0 ; } } if ( firstRowZero ) { for ( int i = 0 ; i < matrix [ 0 ] . length ; i ++ ) { matrix [ 0 ] [ i ] = 0 ; } } }
te	0	public String getReturn ( ) { return _return ; }
te	2	@ Override public void printRow2 ( int row ) { int row_to_print = row - position . row ; if ( row_to_print >= 0 && row_to_print < size . row ) { for ( int i = cols_printed ; i < position . col ; i ++ ) { System . out . format ( "%2s " , " " ) ; cols_printed ++ ; } for ( int col = 0 ; col < size . col ; col ++ ) { System . out . format ( "%2s " , array [ row_to_print ] [ col ] . toString ( ) ) ; cols_printed ++ ; } } }
te	0	public synchronized long getHMillis ( ) { return ( long ) ( p . H * 1000.0 ) ; }
te	0	public boolean containsFamily ( String family ) { return families . contains ( family ) ; }
te	4X	public List < List < String >> partition ( String s ) { List < List < String >> result = new ArrayList < > ( ) ; if ( s == null || s . length ( ) == 0 ) return result ; boolean isP [ ] [ ] = new boolean [ s . length ( ) ] [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { isP [ i ] [ i ] = true ; } for ( int i = 0 ; i + 1 < s . length ( ) ; i ++ ) { isP [ i ] [ i + 1 ] = s . charAt ( i ) == s . charAt ( i + 1 ) ; } for ( int i = 0 , j = 2 ; j < s . length ( ) ; j ++ ) { for ( int k = i , l = j ; l < s . length ( ) ; k ++ , l ++ ) { isP [ k ] [ l ] = isP [ k + 1 ] [ l - 1 ] && s . charAt ( k ) == s . charAt ( l ) ; } } dfs ( s , 0 , result , new ArrayList < String > ( ) , isP ) ; return result ; }
te	2	private void updateArea ( int x0 , int y0 , int w , int h ) { g . setBackground ( transparent ) ; g . clearRect ( x0 , y0 , w , h ) ; int xTileStart = ( x0 + xCam ) / 16 ; int yTileStart = ( y0 + yCam ) / 16 ; int xTileEnd = ( x0 + xCam + w ) / 16 ; int yTileEnd = ( y0 + yCam + h ) / 16 ; for ( int x = xTileStart ; x <= xTileEnd ; x ++ ) { for ( int y = yTileStart ; y <= yTileEnd ; y ++ ) { int b = level . getBlock ( x , y ) & ff ; if ( ( ( Level . TILE_BEHAVIORS [ b ] ) & Level . BIT_ANIMATED ) == 0 ) { g . drawImage ( Art . level [ b % 16 ] [ b / 16 ] , ( x << 4 ) - xCam , ( y << 4 ) - yCam , null ) ; } } } }
te	3	public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) { System . out . print ( "\u8F93\u5165\u7B2C" + ( i + 1 ) + "\u4E2A\u6574\u6570\uFF1A" ) ; a [ i ] = s . nextInt ( ) ; } for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < a [ i ] ; j ++ ) { System . out . print ( "*" ) ; } System . out . println ( ) ; } }
te	4X	private static void begin ( ) { Map < Character , Character > c2cMap = new HashMap < Character , Character > ( ) ; for ( String row : KEYBOARD ) { for ( int i = 1 ; i < row . length ( ) ; ++ i ) { c2cMap . put ( row . charAt ( i ) , row . charAt ( i - 1 ) ) ; } } c2cMap . put (   ,   ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { String line = sc . nextLine ( ) ; StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ( ) ; ++ i ) { char c = line . charAt ( i ) ; if ( c2cMap . containsKey ( c ) ) { output . append ( c2cMap . get ( c ) ) ; } } System . out . println ( output ) ; } }
te	3	private static < AnyType extends Comparable < ? super AnyType >> void quicksort ( AnyType [ ] a , int left , int right ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; quicksort ( a , left , i - 1 ) ; quicksort ( a , i + 1 , right ) ; } else insertionSort ( a , left , right ) ; }
te	3	public void check_reductions ( ) throws internal_error { parse_action act ; production prod ; for ( int row = 0 ; row < num_states ( ) ; row ++ ) { for ( int col = 0 ; col < under_state [ row ] . size ( ) ; col ++ ) { act = under_state [ row ] . under_term [ col ] ; if ( act != null && act . kind ( ) == parse_action . REDUCE ) { ( ( reduce_action ) act ) . reduce_with ( ) . note_reduction_use ( ) ; } } } for ( Enumeration p = production . all ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; if ( prod . num_reductions ( ) == 0 ) { if ( ! emit . nowarn ) { System . err . println ( "*** Production \"" + prod . to_simple_string ( ) + "\" never reduced" ) ; lexer . warning_count ++ ; } } } }
te	1	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( i == DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i == DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
te	2	public Battlefield ( ) { board = new Tile [ 10 ] [ 10 ] ; panel . setLayout ( new GridLayout ( row , col , 0 , 0 ) ) ; for ( int x = 0 ; x < row ; x ++ ) { for ( int y = 0 ; y < col ; y ++ ) { board [ x ] [ y ] = new Tile ( x , y , Tile . Status . WATER ) ; panel . add ( board [ x ] [ y ] ) ; } } }
te	2	private void handleFailed ( ) { uncompletedCount = 0 ; completedCount = 0 ; for ( OnDemandData onDemandData = ( OnDemandData ) requested . peekLast ( ) ; onDemandData != null ; onDemandData = ( OnDemandData ) requested . reverseGetNext ( ) ) if ( onDemandData . incomplete ) uncompletedCount ++ ; else completedCount ++ ; while ( uncompletedCount < 10 ) { OnDemandData onDemandData_1 = ( OnDemandData ) aClass19_1368 . popHead ( ) ; if ( onDemandData_1 == null ) break ; if ( filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] != 0 ) filesLoaded ++ ; filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] = 0 ; requested . insertHead ( onDemandData_1 ) ; uncompletedCount ++ ; closeRequest ( onDemandData_1 ) ; waiting = true ; } }
te	4X	private void postPlugin ( final boolean isPing ) throws IOException { final PluginDescriptionFile description = plugin . getDescription ( ) ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , description . getVersion ( ) ) ; encodeDataPair ( data , "server" , Bukkit . getVersion ( ) ) ; encodeDataPair ( data , "players" , Integer . toString ( Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( plugin . getDescription ( ) . getName ( ) ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
te	0	public void setBankSwiftNo ( String bankSwiftNo ) { this . bankSwiftNo = bankSwiftNo ; }
te	2	public static boolean createTable ( Connection con , TableInfo tableInfo ) { System . out . println ( "Creating table " + tableInfo . tableName ) ; String tableCreate = "CREATE TABLE " + tableInfo . tableName + " ( " ; for ( String i : tableInfo . columns ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " " + tmp [ 0 ] + " " + tmp [ 1 ] + "   " ; } for ( String i : tableInfo . foreignKeys ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " FOREIGN KEY (" + tmp [ 0 ] + ") REFERENCES  " + tmp [ 1 ] + "   " ; } tableCreate += " PRIMARY KEY (ID) )" ; try { Statement stmt = con . createStatement ( ) ; stmt . execute ( tableCreate ) ; stmt . close ( ) ; } catch ( SQLException sqle ) { System . out . println ( "DBObject createTable(" + tableInfo . tableName + "): " + "Unhandled SQLException  create string:\n" + tableCreate + "\n\n Exception: \n" + sqle + "\n\n" ) ; return false ; } return true ; }
te	1	public String pedidoPorCliente ( Cliente cliente ) { String retorno = "" ; for ( Pedido p : lista ) { if ( p . getCliente ( ) . getCodigo ( ) == cliente . getCodigo ( ) ) retorno += p . toString ( ) ; } return retorno ; }
te	3	private static void print ( int [ ] [ ] m , int rows , int cols ) { if ( rows > 25 || cols > 25 ) { return ; } for ( int r = 0 ; r < rows ; r ++ ) { for ( int c = 0 ; c < cols ; c ++ ) { final StringBuilder sb = new StringBuilder ( ) ; final String str = String . valueOf ( m [ r ] [ c ] ) ; while ( sb . length ( ) + str . length ( ) < 4 ) { sb . append ( " " ) ; } sb . append ( str ) ; System . out . print ( sb . toString ( ) ) ; } System . out . println ( ) ; } }
te	0	public void setAgility ( int agi ) { this . agility = agi ; }
te	1	public double sum ( ) { double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) sum += x [ i ] ; return sum ; }
te	4X	public void getModulus ( float [ ] realIO ) { int i , j , k , ir , j0 = 1 , idx = FFT_N_LOG - 1 ; float cosv , sinv , tmpr , tmpi ; for ( i = 0 ; i != FFT_N ; i ++ ) { real [ i ] = realIO [ bitReverse [ i ] ] ; imag [ i ] = 0 ; } for ( i = FFT_N_LOG ; i != 0 ; i -- ) { for ( j = 0 ; j != j0 ; j ++ ) { cosv = costable [ j << idx ] ; sinv = sintable [ j << idx ] ; for ( k = j ; k < FFT_N ; k += j0 << 1 ) { ir = k + j0 ; tmpr = cosv * real [ ir ] - sinv * imag [ ir ] ; tmpi = cosv * imag [ ir ] + sinv * real [ ir ] ; real [ ir ] = real [ k ] - tmpr ; imag [ ir ] = imag [ k ] - tmpi ; real [ k ] += tmpr ; imag [ k ] += tmpi ; } } j0 <<= 1 ; idx -- ; } j = FFT_N >> 1 ; sinv = MINY ; cosv = - MINY ; for ( i = j ; i != 0 ; i -- ) { tmpr = real [ i ] ; tmpi = imag [ i ] ; if ( tmpr > cosv && tmpr < sinv && tmpi > cosv && tmpi < sinv ) realIO [ i - 1 ] = 0 ; else realIO [ i - 1 ] = tmpr * tmpr + tmpi * tmpi ; } }
te	0	static Date getTimeWarp ( ) { return timeWarp ; }
te	1	public void updatePaths ( ) { for ( int s = 1 ; s <= level . maxMobSize ; s ++ ) { pathingGraphs . get ( s - 1 ) . generate ( s , this ) ; } }
te	0	public boolean blocksLineOfSight ( ) { return false ; }
te	4X	public void initArcPruningMap ( ) { sib2id = new int [ F * N * N ] ; copar2id = new int [ F * F * N ] ; gp2id = new int [ F * F * N ] ; isPruned = new boolean [ F * N ] ; for ( int i = 0 ; i < isPruned . length ; ++ i ) { isPruned [ i ] = true ; } for ( int i = 0 ; i < sib2id . length ; ++ i ) sib2id [ i ] = - 1 ; for ( int i = 0 ; i < copar2id . length ; ++ i ) copar2id [ i ] = - 1 ; for ( int i = 0 ; i < gp2id . length ; ++ i ) gp2id [ i ] = - 1 ; sibnum = 0 ; coparnum = 0 ; gpnum = 0 ; for ( int i = 0 ; i < F ; ++ i ) { int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; for ( int j = 0 ; j < N ; ++ j ) { if ( isValidPredAugPair ( pid , j ) || augs [ j ] >= 0 ) { isPruned [ i * N + j ] = ! isValidPredAugPair ( pid , j ) ; if ( options . useSRL2O ) { for ( int k = j + 1 ; k < N ; ++ k ) if ( isValidPredAugPair ( pid , k ) || augs [ k ] >= 0 ) { sib2id [ ( i * N + j ) * N + k ] = sibnum ; sibnum ++ ; } for ( int k = i + 1 ; k < F ; ++ k ) if ( SemanticFeatureFactory . isValidPredAugPair ( inst , inst . frames [ k ] . predid , j ) || inst . frames [ k ] . arglbids [ j ] >= 0 ) { copar2id [ ( i * F + k ) * N + j ] = coparnum ; coparnum ++ ; } } } } } }
te	2	public static void main ( String [ ] args ) throws Exception { int e1TotalWins = 0 , totalDraws = 0 , e1TotalLoses = 0 , e1WinAsPlayer1 = 0 , e1DrawAsPlayer1 = 0 , e1LoseAsPlayer1 = 0 , e1WinAsPlayer2 = 0 , e1DrawAsPlayer2 = 0 , e1LoseAsPlayer2 = 0 , e2TotalWins = 0 , e2TotalLoses = 0 , e2WinAsPlayer1 = 0 , e2DrawAsPlayer1 = 0 , e2LoseAsPlayer1 = 0 , e2WinAsPlayer2 = 0 , e2DrawAsPlayer2 = 0 , e2LoseAsPlayer2 = 0 ; Board boardTest1 = null ; Board initialPositionTest1 = null ; Board [ ] boardCollectionTest1 = null ; int currentIndexTest1 = 0 ; int numberOfMoveTest1 = 0 ; Player [ ] playersTest1 = { new Player ( "BoltzmannH5" , "BoltzmannH5" , "w" , 100000 ) , new Player ( "Charles_2" , "Charles_2" , "b" , 0 ) } ; int totalNumberOfMovesTest1 = 46 ; try { FileInputStream fisTest1 = new FileInputStream ( "50_boards_3.sav" ) ; ObjectInputStream oisTest1 = new ObjectInputStream ( fisTest1 ) ; boardCollectionTest1 = ( Board [ ] ) oisTest1 . readObject ( ) ; } catch ( Exception e ) { System . err . println ( "Error" + e . getMessage ( ) ) ; } long startTime = 0 , endTime = 0 ; startTime = System . currentTimeMillis ( ) ; for ( int testIndex = 1 ; testIndex <= 100 ; ++ testIndex ) { System . out . println ( "Test1: " + testIndex + " / 100" ) ; currentIndexTest1 = 0 ; numberOfMoveTest1 = 0 ; Player tmp = playersTest1 [ 0 ] ; playersTest1 [ 0 ] = playersTest1 [ 1 ] ; playersTest1 [ 1 ] = tmp ; if ( testIndex % 2 == 1 ) { boardTest1 = boardCollectionTest1 [ ( Integer ) testIndex / 2 ] ; initialPositionTest1 = boardTest1 . duplicate ( ) ; } else { boardTest1 = initialPositionTest1 . duplicate ( ) ; } while ( numberOfMoveTest1 < totalNumberOfMovesTest1 ) { if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "BoltzmannH5" ) ) { Tuple < Integer , Integer > move ; MonteCarloH5Boltzmann mc = new MonteCarloH5Boltzmann ( boardTest1 . duplicate ( ) , playersTest1 [ currentIndexTest1 ] . getColor ( ) , numberOfMoveTest1 , totalNumberOfMovesTest1 ) ; move = mc . uct ( playersTest1 [ currentIndexTest1 ] . getSimulationNumber ( ) ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } else if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "Charles_2" ) ) { Tuple < Integer , Integer > move ; Charles_2 charles = new Charles_2 ( playersTest1 [ currentIndexTest1 ] . getColor ( ) , boardTest1 ) ; move = charles . getMove ( ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } } String gameOutcome = Rules . calculateScore ( boardTest1 ) ; BufferedWriter outputTest1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; outputTest1 . append ( "Match #" + testIndex ) ; outputTest1 . newLine ( ) ; outputTest1 . append ( "Player 1: " + playersTest1 [ 0 ] . getName ( ) + " Player 2: " + playersTest1 [ 1 ] . getName ( ) ) ; outputTest1 . newLine ( ) ; if ( gameOutcome . equals ( "0" ) ) { ++ totalDraws ; outputTest1 . append ( "Result: draw" ) ; outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1DrawAsPlayer1 ++ ; e2DrawAsPlayer2 ++ ; } else { e1DrawAsPlayer2 ++ ; e2DrawAsPlayer1 ++ ; } } else { if ( gameOutcome . equals ( playersTest1 [ 0 ] . getColor ( ) ) ) { outputTest1 . append ( "Result: " + playersTest1 [ 0 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer1 ++ ; e2LoseAsPlayer2 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer1 ++ ; e1LoseAsPlayer2 ++ ; } } else { outputTest1 . append ( "Result: " + playersTest1 [ 1 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 1 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer2 ++ ; e2LoseAsPlayer1 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer2 ++ ; e1LoseAsPlayer1 ++ ; } } outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; } } endTime = System . currentTimeMillis ( ) ; BufferedWriter output1Test1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "*Summary (100k) 3-point board (t=2.5)*" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Draw occurred: " + totalDraws ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 total wins: " + e2TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 total wins: " + e1TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Play time: " + ( endTime - startTime ) / 1000 + " seconds." ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #1 : " + e2WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #2 : " + e2WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #1 : " + e2DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #2 : " + e2DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #1 : " + e2LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #2 : " + e2LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #1 : " + e1WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #2 : " + e1WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #1 : " + e1DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #2 : " + e1DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #1 : " + e1LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #2 : " + e1LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . close ( ) ; }
te	4X	@ Override protected void fillDataEditorPanel ( JPanel dataEditorPanel ) { audiences = getAudiencesArray ( ) ; subjects = getSubjectsArray ( ) ; professors = getProfessorsArray ( ) ; groups = getGroupsArray ( ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0414\u0435\u043D\u044C" ) ) ; dayComboBox = new JComboBox < > ( ) ; dayComboBox . setModel ( new DefaultComboBoxModel ( PairModel . DAY_NAMES ) ) ; dataEditorPanel . add ( dayComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u0435\u0434\u0435\u043B\u044F" ) ) ; weekComboBox = new JComboBox < > ( ) ; weekComboBox . setModel ( new DefaultComboBoxModel ( PairModel . WEEK_NAMES ) ) ; dataEditorPanel . add ( weekComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u043E\u043C\u0435\u0440" ) ) ; numberSpinner = new JSpinner ( ) ; numberSpinner . setModel ( new SpinnerNumberModel ( short . valueOf ( ( short ) 1 ) , short . valueOf ( ( short ) 0 ) , short . valueOf ( ( short ) 10 ) , short . valueOf ( ( short ) 1 ) ) ) ; numberSpinner . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( numberSpinner . getValue ( ) == null ) return ; short value = ( short ) numberSpinner . getValue ( ) ; boolean timeComboBoxesEnable = ( value == 0 ) ; timeStartSpinner . setEnabled ( timeComboBoxesEnable ) ; timeEndSpinner . setEnabled ( timeComboBoxesEnable ) ; } } ) ; dataEditorPanel . add ( numberSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u0430\u0447\u0430\u043B\u043E" ) ) ; timeStartSpinner = new JSpinner ( new SpinnerDateModel ( ) ) ; timeStartSpinner . setEnabled ( false ) ; JSpinner . DateEditor timeEditor = new JSpinner . DateEditor ( timeStartSpinner , "HH:mm:ss" ) ; timeStartSpinner . setEditor ( timeEditor ) ; dataEditorPanel . add ( timeStartSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041A\u043E\u043D\u0435\u0446" ) ) ; timeEndSpinner = new JSpinner ( new SpinnerDateModel ( ) ) ; timeEndSpinner . setEnabled ( false ) ; timeEditor = new JSpinner . DateEditor ( timeEndSpinner , "HH:mm:ss" ) ; timeEndSpinner . setEditor ( timeEditor ) ; dataEditorPanel . add ( timeEndSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0410\u0443\u0434\u0438\u0442\u043E\u0440\u0438\u044F" ) ) ; audienceComboBox = new JComboBox < > ( ) ; String [ ] name = new String [ audiences . length ] ; for ( int i = 0 ; i < audiences . length ; i ++ ) { name [ i ] = audiences [ i ] . getFullNumber ( ) ; } audienceComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( audienceComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041F\u0440\u0435\u0434\u043C\u0435\u0442" ) ) ; subjectComboBox = new JComboBox < > ( ) ; name = new String [ subjects . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { name [ i ] = subjects [ i ] . getName ( ) ; } subjectComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( subjectComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041F\u0440\u0435\u043F\u043E\u0434\u0430\u0432\u0430\u0442\u0435\u043B\u044C" ) ) ; professorComboBox = new JComboBox < > ( ) ; name = new String [ professors . length ] ; for ( int i = 0 ; i < professors . length ; i ++ ) { name [ i ] = professors [ i ] . getName ( ) ; } professorComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( professorComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0413\u0440\u0443\u043F\u043F\u0430" ) ) ; groupComboBox = new JComboBox < > ( ) ; name = new String [ groups . length ] ; for ( int i = 0 ; i < groups . length ; i ++ ) { name [ i ] = groups [ i ] . getName ( ) ; } groupComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( groupComboBox ) ; }
te	2	protected void updateInitCells ( ) { int i ; CellElement tmpCell ; for ( i = 1 ; i < m_s1_size ; ++ i ) { tmpCell = m_dpTable . getCell ( i , i + 1 ) ; tmpCell . setIntVal ( 0 ) ; } for ( i = 0 ; i < m_s1_size ; ++ i ) { tmpCell = m_dpTable . getCell ( i + 1 , i + 1 ) ; tmpCell . setIntVal ( 0 ) ; } }
te	3	public Divider ( Poly num , Poly den ) { double tp = den . p [ 0 ] ; if ( Math . abs ( tp ) < epsilon ) throw new RuntimeException ( "Divide Poly by Zero!" ) ; if ( den . p . length > num . p . length ) { quo = new Poly ( ) ; rem = den ; } else { double [ ] quo = new double [ num . p . length - den . p . length + 1 ] ; Poly tmp = num ; int idx = tmp . p . length - den . p . length ; do { double v = tmp . p [ 0 ] / den . p [ 0 ] ; quo [ quo . length - idx - 1 ] = v ; double [ ] qq = new double [ tmp . p . length - 1 ] ; for ( int i = 0 ; i < qq . length ; i ++ ) qq [ i ] = tmp . p [ i + 1 ] ; for ( int i = 1 ; i < den . p . length ; i ++ ) qq [ i - 1 ] -= v * den . p [ i ] ; tmp = new Poly ( qq ) ; idx = tmp . p . length - den . p . length ; } while ( idx >= 0 ) ; this . quo = new Poly ( quo ) ; rem = tmp ; } }
te	3	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	0	public double getPriceLevel3 ( ) { return priceLevel3 ; }
te	0	@ Before public void setUp ( ) { undertest = new MedianStore ( ) ; }
te	0	public JPasswordField getPassword ( ) { return password ; }
te	4X	@ Override public ByteBuffer getMessage ( ) { buffer . clear ( ) ; buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; buffer . putShort ( ( short ) aaa6 ) ; buffer . putShort ( ( short ) 40 ) ; buffer . put ( ( byte ) 1 ) ; buffer . put ( ( byte ) 0 ) ; for ( short val : pwm ) { buffer . putShort ( val ) ; } for ( byte val : relay ) { buffer . put ( val ) ; } for ( byte val : solenoid ) { buffer . put ( val ) ; } for ( byte val : led ) { buffer . put ( val ) ; } buffer . put ( ( byte ) 0 ) ; short checksum = ( short ) Utilities . checksum ( buffer , 0 , 38 ) ; buffer . putShort ( checksum ) ; return buffer ; }
te	2	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
te	1	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
te	0	@ Override public void handleEvent ( MatchEndedEvent domainEvent ) { PlayerReport playerReport = accountReportRepository . findById ( domainEvent . getAggregateId ( ) ) ; List < MatchReport > gamesStatistic = new ArrayList < MatchReport > ( ) ; gamesStatistic . addAll ( playerReport . getGamesStatistic ( ) ) ; gamesStatistic . add ( new MatchReport ( domainEvent . getAggregateId ( ) , domainEvent . getMatchResult ( ) ) ) ; accountReportRepository . add ( new PlayerReport ( domainEvent . getAggregateId ( ) , gamesStatistic , playerReport . getPlayerName ( ) ) ) ; }
te	2	public void resetUnits ( ) { for ( Unit u : blueUnits ) { u . reset ( ) ; } for ( Unit u : redUnits ) { u . reset ( ) ; } }
te	4X	public void generateCrowdForOneDay ( ) { int oneHour = 3600 ; int requests ; int bufetRand = 5 ; int bufetOff = 2 ; requests = ( int ) ( Math . random ( ) * bufetRand ) + bufetOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "bufet" ) , stationMap . get ( "dormi" ) , ( int ) ( 1.5 * oneHour ) , ( int ) ( oneHour ) ) ; } int dormiRand = 15 ; int dormiOff = 10 ; requests = ( int ) ( Math . random ( ) * dormiRand ) + dormiOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "dormi" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 6 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnice1Rand = 15 ; int predavalnice1Off = 15 ; requests = ( int ) ( Math . random ( ) * predavalnice1Rand ) + predavalnice1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "menza" ) , ( int ) ( 11 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza1Rand = 10 ; int menza1Off = 6 ; requests = ( int ) ( Math . random ( ) * menza1Rand ) + menza1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza2Rand = 10 ; int menza2Off = 4 ; requests = ( int ) ( Math . random ( ) * menza2Rand ) + menza2Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "dormi" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza3Rand = 3 ; int menza3Off = 2 ; requests = ( int ) ( Math . random ( ) * menza3Rand ) + menza3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "postaja" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnica3Rand = 3 ; int predavalnica3Off = 2 ; requests = ( int ) ( Math . random ( ) * predavalnica3Rand ) + predavalnica3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "dormi" ) , ( int ) ( 16 * oneHour ) , ( int ) ( 6 * oneHour ) ) ; } }
te	4X	private void printUpgradeTowerDef ( Graphics g ) { gui . print ( g , selectedTowerDef . name , TEXT_HEIGHT_1 ) ; gui . print ( g , "upgrade cost: " + selectedTowerDef . cost , TEXT_HEIGHT_1 ) ; gui . print ( g , "level  : " + selectedTowerDef . level , TEXT_HEIGHT_1 ) ; gui . print ( g , "damage : " + getComparingString ( selectedTowerDef . damage , selectedTower . def . damage ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "area   : " + getComparingString ( selectedTowerDef . damageRadius , selectedTower . def . damageRadius ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "range  : " + getComparingString ( selectedTowerDef . range , selectedTower . def . range ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "reload : " + getComparingString ( selectedTowerDef . reloadTime , selectedTower . def . reloadTime ) , TEXT_HEIGHT_1 ) ; if ( selectedTower . def . instantEffects . length + selectedTower . def . timedEffects . length > 0 ) { gui . print ( g , "old effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTower . def . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTower . def . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } if ( selectedTowerDef . instantEffects . length + selectedTowerDef . timedEffects . length > 0 ) { gui . print ( g , "new effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTowerDef . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTowerDef . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } }
te	0	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
te	0	public final int getSolutionMemoryMegabytes ( ) { return this . solutionMemoryMegabytes ; }
te	0	public void setPassword ( String password ) { this . password = password ; }
te	3	public void setHover ( int selectedId ) { this . clearHover ( ) ; for ( int h = 0 ; h < height ; h ++ ) { for ( int w = 0 ; w < width ; w ++ ) { for ( int z = 0 ; z < depth ; z ++ ) { if ( grid [ h ] [ w ] [ z ] . getId ( ) == selectedId ) { grid [ h ] [ w ] [ z ] . hover ( ) ; } } } } }
te	1	@ Override public ArrayList < ProduktBatchKompDTO > getProduktBatchKompList ( int pbId ) throws DALException { ArrayList < ProduktBatchKompDTO > list = new ArrayList < ProduktBatchKompDTO > ( ) ; ResultSet rs = Connector . doQuery ( "SELECT pbk.*  rb.*  r.* FROM produktbatchkomponent pbk  raavarebatch rb  raavare r WHERE pbk.rb_id = rb.rb_id AND rb.raavare_id = r.raavare_id AND pbk.pb_id =  " + pbId ) ; try { while ( rs . next ( ) ) { RaavareDTO raavare = new RaavareDTO ( rs . getInt ( 10 ) , rs . getString ( 11 ) ) ; RaavareBatchDTO raavareBatch = new RaavareBatchDTO ( rs . getInt ( 5 ) , raavare , rs . getDouble ( 7 ) , rs . getTimestamp ( 8 ) , rs . getString ( 9 ) ) ; list . add ( new ProduktBatchKompDTO ( rs . getInt ( 1 ) , raavareBatch , rs . getDouble ( 3 ) , rs . getDouble ( 4 ) ) ) ; } } catch ( SQLException e ) { throw new DALException ( e ) ; } return list ; }
te	1	@ Override public void onPairFailed ( ) { synchronized ( mListeners ) { for ( DiscoveryListener listener : mListeners ) { try { listener . onPairFailed ( ) ; } catch ( RuntimeException e ) { System . out . println ( "Error notifying listener." ) ; } } } System . out . println ( "onPairFailed" ) ; }
te	3	private static void method493 ( Stream stream , char ac [ ] [ ] , byte abyte0 [ ] [ ] [ ] ) { for ( int j = 0 ; j < ac . length ; j ++ ) { char ac1 [ ] = new char [ stream . readUnsignedByte ( ) ] ; for ( int k = 0 ; k < ac1 . length ; k ++ ) ac1 [ k ] = ( char ) stream . readUnsignedByte ( ) ; ac [ j ] = ac1 ; byte abyte1 [ ] [ ] = new byte [ stream . readUnsignedByte ( ) ] [ 2 ] ; for ( int l = 0 ; l < abyte1 . length ; l ++ ) { abyte1 [ l ] [ 0 ] = ( byte ) stream . readUnsignedByte ( ) ; abyte1 [ l ] [ 1 ] = ( byte ) stream . readUnsignedByte ( ) ; } if ( abyte1 . length > 0 ) abyte0 [ j ] = abyte1 ; } }
te	4X	public static Highscore [ ] load ( InputStream in ) throws IOException { Vector highscores = new Vector ( 20 , 40 ) ; InputStreamReader inr = new InputStreamReader ( in ) ; String line ; while ( ( line = jgame . impl . EngineLogic . readline ( inr ) ) != null ) { Vector fields = new Vector ( 5 , 10 ) ; Vector tokens = jgame . impl . EngineLogic . tokenizeString ( line , 	 ) ; for ( Enumeration e = tokens . elements ( ) ; e . hasMoreElements ( ) ; ) { String tok = ( String ) e . nextElement ( ) ; if ( tok . equals ( "`" ) ) tok = "" ; fields . addElement ( tok ) ; } Highscore hs = null ; if ( fields . size ( ) == 1 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , "" ) ; } if ( fields . size ( ) >= 2 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , ( String ) fields . elementAt ( 1 ) ) ; } if ( fields . size ( ) >= 3 ) { hs . fields = new String [ fields . size ( ) - 2 ] ; for ( int i = 2 ; i < fields . size ( ) ; i ++ ) { hs . fields [ i - 2 ] = ( String ) fields . elementAt ( i ) ; } } highscores . addElement ( hs ) ; } Highscore [ ] ret = new Highscore [ highscores . size ( ) ] ; for ( int i = 0 ; i < highscores . size ( ) ; i ++ ) { ret [ i ] = ( Highscore ) highscores . elementAt ( i ) ; } return ret ; }
te	2	public static void main ( String [ ] args ) { Suitors mySuitors = new Suitors ( ) ; for ( int i = 0 ; i < 22 ; i ++ ) mySuitors . add ( ) ; Suitor theSuitor = mySuitors . head ; boolean done = false ; int count = 0 ; while ( ! done ) { if ( theSuitor . next . number == theSuitor . number ) done = true ; else { theSuitor = theSuitor . next . next . next ; mySuitors . remove ( theSuitor ) ; count ++ ; if ( count > 0 && count % 5 == 0 ) { mySuitors . display ( ) ; System . out . println ( ) ; } } } System . out . println ( "And the winner is..." ) ; mySuitors . display ( ) ; }
te	2	public static void main ( String [ ] args ) { int [ ] array = { 1 , 2 , 3 , 4 , 5 } ; System . out . println ( "Effects of passing reference to entire array:\n" + "The values of the original array are:" ) ; for ( int value : array ) System . out . printf ( " %d" , value ) ; modifyArray ( array ) ; System . out . println ( "\n\nThe values of the modified array are:" ) ; for ( int value : array ) System . out . printf ( " %d" , value ) ; System . out . printf ( "\n\nEffects of passing array element value:\n" + "array[3] before modifyElement: %d\n" , array [ 3 ] ) ; modifyElement ( array [ 3 ] ) ; System . out . printf ( "array[3] after modifyElement: %d\n" , array [ 3 ] ) ; }
te	4X	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; v_1 = cursor ; lab0 : do { if ( ! r_mark_regions ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; limit_backward = cursor ; cursor = limit ; v_2 = limit - cursor ; lab1 : do { if ( ! r_main_suffix ( ) ) { break lab1 ; } } while ( false ) ; cursor = limit - v_2 ; v_3 = limit - cursor ; lab2 : do { if ( ! r_consonant_pair ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; v_4 = limit - cursor ; lab3 : do { if ( ! r_other_suffix ( ) ) { break lab3 ; } } while ( false ) ; cursor = limit - v_4 ; v_5 = limit - cursor ; lab4 : do { if ( ! r_undouble ( ) ) { break lab4 ; } } while ( false ) ; cursor = limit - v_5 ; cursor = limit_backward ; return true ; }
te	1	@ Override public synchronized boolean checkToken ( Token token ) { for ( Token to : tokens ) { if ( token . equals ( to ) ) { return true ; } } return false ; }
te	3	CachedCombinationFactory ( long mod , int n ) { assert mod > n ; this . mod = mod ; this . n = n ; comb = new long [ n ] [ n ] ; comb [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { comb [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { comb [ i ] [ j ] = ( comb [ i - 1 ] [ j - 1 ] + comb [ i - 1 ] [ j ] ) % mod ; } } }
te	4X	@ Override public void train ( ) { int N = getTrainSet ( ) . getDistribution ( ) . length ; memories = new Memory [ N ] ; Map < Integer , Set < Pattern >> classes = new HashMap < Integer , Set < Pattern >> ( ) ; for ( Pattern instance : getTrainSet ( ) ) { Set < Pattern > partition = classes . containsKey ( instance . getClassIndex ( ) ) ? classes . get ( instance . getClassIndex ( ) ) : new HashSet < Pattern > ( ) ; partition . add ( instance ) ; classes . put ( instance . getClassIndex ( ) , partition ) ; } for ( Integer clazz : classes . keySet ( ) ) { Set < Pattern > partition = classes . get ( clazz ) ; int R = getTrainSet ( ) . getAttributes ( ) . size ( ) ; double M [ ] [ ] = new double [ R ] [ R ] ; int index = 0 ; for ( Pattern pattern : partition ) { if ( index == 0 ) { M [ index ++ ] = pattern . toDoubleVector ( ) ; } else { if ( index < R ) { boolean si = true ; for ( int j = 0 ; j < index ; j ++ ) { if ( similitud ( M [ j ] , pattern . toDoubleVector ( ) ) > 7 ) si = false ; } if ( si ) M [ index ++ ] = pattern . toDoubleVector ( ) ; } } } memories [ clazz ] = new Memory ( clazz , Matrix . trans ( M ) ) ; } for ( Memory memory : memories ) { Matrix . print ( memory . getM ( ) ) ; } }
te	4X	public static int computeJ ( String [ ] t , String [ ] et ) { int cost = 0 ; String [ ] observedTrace = new String [ 100 ] ; String [ ] [ ] distanceMatrixForTrace = new String [ t . length ] [ observedTrace . length ] ; for ( int m = 0 ; m < t . length ; m ++ ) { distanceMatrixForTrace [ m ] [ 0 ] = t [ m ] ; } for ( int n = 0 ; n < t . length ; n ++ ) { distanceMatrixForTrace [ 0 ] [ n ] = observedTrace [ n ] ; } for ( int i = 1 ; i < t . length ; i ++ ) { for ( int j = 1 ; j < observedTrace . length ; j ++ ) { distanceMatrixForTrace [ i ] [ j ] = Integer . toString ( getDistance ( distanceMatrixForTrace [ i ] [ 0 ] , distanceMatrixForTrace [ 0 ] [ j ] ) ) ; } } return cost ; }
te	1	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
te	1	public static String StrFill ( String fillStr , String oldStr , int length , String place ) { StringBuffer sb = new StringBuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldStr ) ; } for ( int i = 0 ; i < ( length - oldStr . length ( ) ) ; i ++ ) { sb . append ( fillStr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldStr ) ; } return sb . toString ( ) ; }
te	2	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String scomplete = scan . nextLine ( ) ; while ( ! scomplete . equals ( "#" ) ) { String [ ] scompleteArray = scomplete . split ( " " ) ; String s1 = scompleteArray [ 0 ] ; String s2 = scompleteArray [ 1 ] ; int [ ] [ ] m = new int [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; dir [ ] [ ] direcciones = new dir [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; fill ( s2 , s1 , m , direcciones ) ; ArrayList < dir > res = trace ( m , direcciones , s2 , s1 ) ; int acarreo = 0 ; char last = a ; for ( int i = res . size ( ) - 1 ; i > - 1 ; i -- ) { if ( res . get ( i ) . pre . charAt ( 0 ) == I ) { acarreo ++ ; } res . get ( i ) . acarreo ( acarreo ) ; System . out . print ( res . get ( i ) . Stringify ( ) ) ; if ( res . get ( i ) . pre . charAt ( 0 ) == D ) { acarreo -- ; } } System . out . print ( "E\n" ) ; scomplete = scan . nextLine ( ) ; } }
te	1	public void update ( double ad [ ] , double d ) { for ( int i = 0 ; i < mFilters . length ; i ++ ) { mFilters [ i ] . update ( ad [ i ] , d ) ; } }
te	3	@ Test public void stressTest ( ) { for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { threads [ i ] . start ( ) ; } try { Thread . sleep ( RUN_TIME_MILLIS ) ; } catch ( InterruptedException e ) { } for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { threads [ i ] . interrupt ( ) ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } int fails = 0 ; int oks = 0 ; int exceptions = 0 ; for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { fails += threads [ i ] . fails ; oks += threads [ i ] . oks ; exceptions += threads [ i ] . exceptions ; } System . out . println ( "fails: " + fails + " oks: " + oks + " exceptions: " + exceptions + " total " + ( fails + oks + exceptions ) ) ; assertEquals ( 0 , fails ) ; assertEquals ( 0 , exceptions ) ; }
te	0	public void setId ( Integer id ) { this . id = id ; }
te	3	void modElement ( String [ ] args ) throws Exception { if ( args . length < 3 ) { System . err . println ( "Usage: mod <config_file> <indexID>" ) ; System . exit ( 1 ) ; } myVsl = new vsl ( args [ 1 ] ) ; vslRecKey prev = new vslRecKey ( ) ; vslID id = new vslID ( ) ; id . setID ( args [ 2 ] ) ; vslIndex index = myVsl . getIndex ( id , true ) ; Vector < vslElKey > allKeys = showAllElements ( index ) ; vslElKey elKey = null ; while ( ( elKey = promptForChoice ( "element to update" , allKeys ) ) != null ) { vslIndexElement el = index . getElement ( elKey ) ; Vector < vslRecKey > allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; while ( ( prev = promptForChoice ( "previous record to update" , allRec ) ) != null ) { Vector prevVec = new Vector ( ) ; prevVec . add ( prev ) ; vslIndexDataType < String > elData = null ; String input = null ; do { System . out . print ( "Update/Detele [u/d]:" ) ; input = FileChunkingTest . getLine ( ) ; } while ( input != null && ! ( input . equals ( "u" ) || input . equals ( "d" ) ) ) ; if ( input . equals ( "u" ) ) { System . out . print ( "Update data:" ) ; input = FileChunkingTest . getLine ( ) ; elData = new vslIndexDataType < String > ( input ) ; index . updateElement ( elKey , elData , prevVec ) ; } else { index . deleteElement ( elKey , prevVec ) ; } myVsl . updateIndex ( index ) ; allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; } allKeys = showAllElements ( index ) ; } myVsl . save ( ) ; }
te	3	protected Alternation alternation ( ) throws IOException , MatchException { Alternation alternation = new Alternation ( ) ; alternation . addConcatenation ( concatenation ( ) ) ; while ( match ( is . peek ( ) , new int [ ] { 20 , ; , / } ) ) { while ( match ( is . peek ( ) , 20 ) || match ( is . peek ( ) , ; ) ) { c_wsp ( ) ; } assertMatch ( is . peek ( ) , / ) ; is . read ( ) ; while ( match ( is . peek ( ) , 20 ) || match ( is . peek ( ) , ; ) ) { c_wsp ( ) ; } alternation . addConcatenation ( concatenation ( ) ) ; } return alternation ; }
te	3	protected void addMolecule ( final String strPK , final String canonSmiles , final List < String > listNames , final Map < String , Object > mapProperties ) throws IOException , GenericRDKitException { if ( strPK == null ) { throw new IllegalArgumentException ( "Primary key must not be null." ) ; } if ( canonSmiles == null || canonSmiles . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Canonical SMILES must not be null or empty." ) ; } final IndexWriter writer = prepareWriter ( ) ; if ( writer != null ) { writer . deleteDocuments ( new TermQuery ( new Term ( FIELD_PK , strPK ) ) ) ; final BitSet fp = m_fingerprintFactory . createStructureFingerprint ( canonSmiles , true ) ; final Document doc = new Document ( ) ; doc . add ( new Field ( FIELD_PK , strPK , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; doc . add ( new Field ( FIELD_SMILES , canonSmiles , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; for ( int i = fp . nextSetBit ( 0 ) ; i >= 0 ; i = fp . nextSetBit ( i + 1 ) ) { doc . add ( new Field ( FIELD_FP , Integer . toString ( i ) , Store . NO , Index . NOT_ANALYZED_NO_NORMS , Field . TermVector . NO ) ) ; } if ( listNames != null ) { for ( final String name : listNames ) { doc . add ( new Field ( FIELD_NAME , name , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; } } if ( mapProperties != null ) { for ( final String key : mapProperties . keySet ( ) ) { final Object value = mapProperties . get ( key ) ; if ( value != null ) { final String strValue = value . toString ( ) ; doc . add ( new Field ( key , strValue , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; } } } writer . addDocument ( doc ) ; onMoleculeAdded ( strPK , canonSmiles ) ; } else { throw new IOException ( "Index writer is unavailable." ) ; } }
te	0	public static ByteBuffer stringToBuffer ( int id ) { String s = Integer . valueOf ( id ) . toString ( ) ; return stringToBuffer ( s ) ; }
te	1	public T first ( UnaryFunction < T , boolean > predicate ) { while ( hasNext ( ) ) { final T value = next ( ) ; if ( predicate . invoke ( value ) ) { return value ; } } throw new NoSuchElementException ( ) ; }
te	4X	public static void polcof ( final double [ ] xa , final double [ ] ya , final double [ ] cof ) { int k , j , i , n = xa . length ; double xmin ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; for ( j = 0 ; j < n ; j ++ ) { x [ j ] = xa [ j ] ; y [ j ] = ya [ j ] ; } for ( j = 0 ; j < n ; j ++ ) { double [ ] x_t = new double [ n - j ] ; double [ ] y_t = new double [ n - j ] ; for ( k = 0 ; k < n - j ; k ++ ) { x_t [ k ] = x [ k ] ; y_t [ k ] = y [ k ] ; } Poly_interp interp = new Poly_interp ( x , y , n - j ) ; cof [ j ] = interp . rawinterp ( 0 , 0. ) ; xmin = 1.0e99 ; k = - 1 ; for ( i = 0 ; i < n - j ; i ++ ) { if ( abs ( x [ i ] ) < xmin ) { xmin = abs ( x [ i ] ) ; k = i ; } if ( x [ i ] != 0.0 ) y [ i ] = ( y [ i ] - cof [ j ] ) / x [ i ] ; } for ( i = k + 1 ; i < n - j ; i ++ ) { y [ i - 1 ] = y [ i ] ; x [ i - 1 ] = x [ i ] ; } } }
te	3	public static void main ( String [ ] args ) { for ( int i = 1 ; i < 5 ; i ++ ) { System . out . println ( i + " " + binet ( i ) ) ; } for ( int i = 1 ; i < 72 ; i ++ ) { System . out . println ( i + " " + binet1 ( i ) ) ; } for ( int i = 1 ; i < 148 ; i ++ ) { System . out . println ( i + " " + binet2 ( i ) ) ; } }
te	1	private Map < String , List < String >> decodeParams ( String s ) { Map < String , List < String >> params = new LinkedHashMap < String , List < String >> ( ) ; String name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addParam ( params , name , "" ) ; } return params ; }
te	4X	public static void polcoe ( final double [ ] x , final double [ ] y , final double [ ] cof ) { int k , j , i , n = x . length ; double phi , ff , b ; double [ ] s = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) s [ i ] = cof [ i ] = 0.0 ; s [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { for ( j = n - 1 - i ; j < n - 1 ; j ++ ) s [ j ] -= x [ i ] * s [ j + 1 ] ; s [ n - 1 ] -= x [ i ] ; } for ( j = 0 ; j < n ; j ++ ) { phi = n ; for ( k = n - 1 ; k > 0 ; k -- ) phi = k * s [ k ] + x [ j ] * phi ; ff = y [ j ] / phi ; b = 1.0 ; for ( k = n - 1 ; k >= 0 ; k -- ) { cof [ k ] += b * ff ; b = s [ k ] + x [ j ] * b ; } } }
te	3	public String createOrder ( Map < Integer , Price > priceMap , User user ) throws ServiceException { if ( priceMap == null ) { return OtherConstants . SELECTED_ORDERING_NULL ; } float total = 0f ; for ( Map . Entry < Integer , Price > map : priceMap . entrySet ( ) ) { Price price = map . getValue ( ) ; int num = price . getPriceNum ( ) ; total = total + num * price . getPriceValue ( ) ; } Order order = new Order ( ) ; order . setUserID ( user . getId ( ) ) ; order . setOrderTotle ( total ) ; String orderSeq = MD5 . getMD5 ( user . getId ( ) + total + OtherConstants . STATE_NO ) + System . currentTimeMillis ( ) ; order . setOrderSeq ( orderSeq ) ; order . setOrderState ( OtherConstants . STATE_NO ) ; try { String orderID = orderDaoImpl . add ( order , SqlConstants . ORDER_ADD ) ; Detail detail = new Detail ( ) ; for ( Map . Entry < Integer , Price > map : priceMap . entrySet ( ) ) { Price price = map . getValue ( ) ; detail . setOrderID ( orderID ) ; detail . setPriceID ( price . getId ( ) ) ; detail . setOrderDetailNum ( price . getPriceNum ( ) ) ; String detailID = detailDaoImpl . add ( detail , SqlConstants . DETAIL_ADD ) ; Food food = new Food ( ) ; List < Dic > dics = price . getDics ( ) ; for ( Dic dic : dics ) { food . setDicID ( dic . getId ( ) ) ; food . setOrderDetailID ( detailID ) ; food . setFoodNum ( 1 ) ; foodDaoImpl . insert ( food , SqlConstants . FOOD_ADD ) ; } } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } return null ; }
te	4X	private void intensity_stereo ( int gr ) { final ChannelInformation ci = channelInfo [ gr ] [ 1 ] ; int scf , idx , sfb ; if ( channelInfo [ gr ] [ 0 ] . mixed_block_flag != ci . mixed_block_flag || channelInfo [ gr ] [ 0 ] . block_type != ci . block_type ) return ; if ( isMPEG1 ) { if ( ci . block_type == 2 ) { int w3 ; for ( w3 = 0 ; w3 < 3 ; w3 ++ ) { sfb = rzeroBandShort [ w3 ] ; for ( ; sfb < 12 ; sfb ++ ) { idx = 3 * sfbIndexShort [ sfb ] + w3 ; scf = scalefacShort [ 1 ] [ 3 * sfb + w3 ] ; if ( scf >= 7 ) continue ; is_lines_1 ( scf , idx , widthShort [ sfb ] , 3 , gr ) ; } } } else { for ( sfb = rzeroBandLong ; sfb <= 21 ; sfb ++ ) { scf = scalefacLong [ 1 ] [ sfb ] ; if ( scf < 7 ) is_lines_1 ( scf , sfbIndexLong [ sfb ] , widthLong [ sfb ] , 1 , gr ) ; } } } else { int tab2 = ci . scalefac_compress & 1 ; if ( ci . block_type == 2 ) { int w3 ; for ( w3 = 0 ; w3 < 3 ; w3 ++ ) { sfb = rzeroBandShort [ w3 ] ; for ( ; sfb < 12 ; sfb ++ ) { idx = 3 * sfbIndexShort [ sfb ] + w3 ; scf = scalefacShort [ 1 ] [ 3 * sfb + w3 ] ; is_lines_2 ( tab2 , scf , idx , widthShort [ sfb ] , 3 , gr ) ; } } } else { for ( sfb = rzeroBandLong ; sfb <= 21 ; sfb ++ ) is_lines_2 ( tab2 , scalefacLong [ 1 ] [ sfb ] , sfbIndexLong [ sfb ] , widthLong [ sfb ] , 1 , gr ) ; } } }
te	4X	public static void vander ( final double [ ] x , final double [ ] w , final double [ ] q ) { int i , j , k , n = q . length ; double b , s , t , xx ; double [ ] c = new double [ n ] ; if ( n == 1 ) w [ 0 ] = q [ 0 ] ; else { for ( i = 0 ; i < n ; i ++ ) c [ i ] = 0.0 ; c [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { xx = - x [ i ] ; for ( j = ( n - 1 - i ) ; j < ( n - 1 ) ; j ++ ) c [ j ] += xx * c [ j + 1 ] ; c [ n - 1 ] += xx ; } for ( i = 0 ; i < n ; i ++ ) { xx = x [ i ] ; t = b = 1.0 ; s = q [ n - 1 ] ; for ( k = n - 1 ; k > 0 ; k -- ) { b = c [ k ] + xx * b ; s += q [ k - 1 ] * b ; t = xx * t + b ; } w [ i ] = s / t ; } } }
te	1	private void listAllEmail ( List < Email > emailList , POP3Session session ) { String responseStr = null ; for ( int i = 0 ; i < emailList . size ( ) ; i ++ ) { if ( emailList . get ( i ) . isDeleted ( ) == false ) { responseStr = i + 1 + " " + EmailUtil . getEmailSize ( emailList . get ( i ) ) ; session . sendResponse ( responseStr ) ; } } }
te	2	public void setValueContributionsOfActions ( MDPData m ) { for ( int i = 0 ; i < noOfStates ; i ++ ) { StateData state = stateList . get ( i ) ; StateData mState = m . getStateList ( ) . get ( i ) ; int numOfActionsInState = state . getNoOfActions ( ) ; ArrayList < ActionData > actionList = state . getActionList ( ) ; ArrayList < ActionData > mActionList = mState . getActionList ( ) ; for ( int j = 0 ; j < numOfActionsInState ; j ++ ) { ActionData action = actionList . get ( j ) ; action . setValueContri ( mActionList . get ( j ) . getValueContri ( ) ) ; actionList . set ( j , action ) ; } state . setActionList ( actionList ) ; state . setValue ( mState . getValue ( ) ) ; stateList . set ( i , state ) ; } }
te	0	protected void informNextPlayerToGo ( String currentIP , int currentPort ) { int nextPlayerToGo = getNextTurnPlayerID ( pg . getPlayerIndex ( currentIP , currentPort ) ) ; srvrWaitingOnPlayerIndex = nextPlayerToGo ; pg . broadcastMessage ( "sTurn " + pg . getPlayer ( nextPlayerToGo ) . getNickName ( ) ) ; }
te	3	public H2D projectionYZ ( ) { String name = "Y-Z Projection" ; int yNum = yAxis . getNBins ( ) + 1 ; double yMin = yAxis . min ( ) ; double yMax = yAxis . max ( ) ; int zNum = zAxis . getNBins ( ) + 1 ; double zMin = zAxis . min ( ) ; double zMax = zAxis . max ( ) ; H2D projYZ = new H2D ( name , yNum , yMin , yMax , zNum , zMin , zMax ) ; double height = 0.0 ; for ( int y = 0 ; y <= yAxis . getNBins ( ) ; y ++ ) { height = 0.0 ; for ( int z = 0 ; z <= zAxis . getNBins ( ) ; z ++ ) { height = 0.0 ; for ( int x = 0 ; x <= xAxis . getNBins ( ) ; x ++ ) { height += this . getBinContent ( x , y , z ) ; } projYZ . setBinContent ( y , z , height ) ; } } return projYZ ; }
te	3	public Hashtable < String , Neo4jCluster > perform ( DatasetLoader datasetHandler , Neo4jHandler neo4jHandler , double similairtyThreshold , int softClusteringThreshold ) throws Exception { Hashtable < String , Neo4jCluster > clustersList = new Hashtable < String , Neo4jCluster > ( ) ; Hashtable < String , Document > docsHash = datasetHandler . loadDocuments ( ) ; DDSimIF similarityCalculator = new DDSimilairty ( ) ; Enumeration e = docsHash . keys ( ) ; int numberOfClusters = 0 ; while ( e . hasMoreElements ( ) ) { Hashtable < String , double > candidateClustersHash = new Hashtable < String , double > ( ) ; String documentID = ( String ) e . nextElement ( ) ; System . out . println ( "Processing document " + documentID ) ; Document document = docsHash . get ( documentID ) ; Neo4jDocument neo4jDocument = neo4jHandler . loadDocument ( document ) ; boolean clusteredYet = false ; ArrayList < Neo4jDocument > similarDocuments = getSimilarDocuments ( neo4jDocument , neo4jHandler , datasetHandler ) ; for ( Iterator iterator = similarDocuments . iterator ( ) ; iterator . hasNext ( ) ; ) { Neo4jDocument neo4jSimilarDocument = ( Neo4jDocument ) iterator . next ( ) ; if ( neo4jSimilarDocument . getClustersHash ( ) . isEmpty ( ) ) continue ; if ( similarityCalculator . calculateSimilarity ( neo4jDocument , neo4jSimilarDocument , datasetHandler . numberOfDocuments ( ) ) > similairtyThreshold ) { ArrayList < String > candidateDocumentClustersIDs = neo4jSimilarDocument . getClusterIDsList ( ) ; for ( Iterator iterator2 = candidateDocumentClustersIDs . iterator ( ) ; iterator2 . hasNext ( ) ; ) { String candidateClusterID = ( String ) iterator2 . next ( ) ; Neo4jCluster candidateNeo4jCluster = clustersList . get ( candidateClusterID ) ; double averageSimilairtyToCluster = calculateAvgSimilairtyToCluster ( neo4jDocument , candidateNeo4jCluster , datasetHandler , neo4jHandler ) ; if ( averageSimilairtyToCluster > similairtyThreshold ) { clusteredYet = true ; candidateClustersHash . put ( candidateClusterID , averageSimilairtyToCluster ) ; } } } } if ( ! clusteredYet ) { numberOfClusters ++ ; Neo4jCluster newCluster = new Neo4jCluster ( String . valueOf ( numberOfClusters ) ) ; newCluster . addDcoument ( documentID ) ; neo4jDocument . addCluster ( newCluster . getId ( ) , 1 ) ; clustersList . put ( newCluster . getId ( ) , newCluster ) ; } else { String nearestClusterID = getNearestCluster ( candidateClustersHash ) ; Neo4jCluster cluster = clustersList . get ( nearestClusterID ) ; cluster . addDcoument ( neo4jDocument . getDocumentID ( ) ) ; neo4jDocument . addCluster ( nearestClusterID , 1 ) ; } } return clustersList ; }
te	1	private void compact ( ) { int from = 0 ; int to = 0 ; while ( from < this . capacity ) { Object key = this . list [ from ] ; long usage = age ( this . ticks [ from ] ) ; if ( usage > 0 ) { this . ticks [ to ] = usage ; this . list [ to ] = key ; this . map . put ( key , to ) ; to += 1 ; } else { this . map . remove ( key ) ; } from += 1 ; } if ( to < this . capacity ) { this . length = to ; } else { this . map . clear ( ) ; this . length = 0 ; } this . power = 0 ; }
te	1	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
te	3	public Geometry subdivide ( int I , int J , int m , int n ) { double data [ ] = new double [ 48 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) data [ 12 * i + 3 * j + k ] = vertices [ ( J + j ) * ( _m + 1 ) + ( I + i ) ] [ k ] ; faces [ J * ( _m - 2 ) + I ] = null ; Geometry p = ( new Geometry ( ) ) . patch ( m , n , Geometry . CatmullRom , data ) ; add ( p ) ; return p ; }
te	4X	public void tick ( ) { int l = mouseButtons . length ; for ( int i = 0 ; i < l ; i ++ ) { boolean b = Mouse . isButtonDown ( i ) ; if ( b && ! mouseButtons [ i ] ) mostRecentClicks [ i ] = new Point ( Mouse . getX ( ) , Mouse . getY ( ) ) ; mouseButtons [ i ] = b ; if ( ! b ) consumedMouseButton [ i ] = false ; } while ( Mouse . next ( ) ) { int key = Mouse . getEventButton ( ) ; if ( ( key == - 1 ) || ( key >= mouseButtons . length ) ) continue ; boolean state = Mouse . getEventButtonState ( ) ; if ( state ) mouseButtons [ key ] = true ; else consumedMouseButton [ key ] = false ; } l = keys . length ; for ( int i = 0 ; i < l ; i ++ ) { boolean b = Keyboard . isKeyDown ( i ) ; keys [ i ] = b ; if ( ! b ) consumedKeys [ i ] = false ; } while ( Keyboard . next ( ) ) { int key = Keyboard . getEventKey ( ) ; if ( ( key < 0 ) || ( key >= keys . length ) ) continue ; boolean state = Keyboard . getEventKeyState ( ) ; if ( state ) keys [ key ] = true ; else consumedKeys [ key ] = false ; } dx = Mouse . getDX ( ) ; dy = - Mouse . getDY ( ) ; x = Mouse . getX ( ) ; y = ( height - 1 ) - Mouse . getY ( ) ; }
te	4X	public static void main ( String [ ] args ) { EraSieve sieve = new EraSieve ( ) ; long lastPrime = 1 ; long last2Sqr = 0 ; long last2Base = 0 ; ArrayList < long > squareBy2 = new ArrayList < long > ( ) ; for ( int i = 1 ; true ; i += 2 ) { while ( lastPrime < i ) lastPrime = sieve . nextPrime ( ) ; if ( i == lastPrime ) { System . out . println ( i + ":was prime" ) ; continue ; } while ( last2Sqr < i ) { last2Base ++ ; last2Sqr = 2 * last2Base * last2Base ; squareBy2 . add ( last2Sqr ) ; } System . out . println ( i + ":not prime" ) ; long x ; boolean found = false ; for ( long prime : sieve . primes ) { for ( long square2 : squareBy2 ) { if ( ( prime + square2 ) == i ) { found = true ; System . out . println ( "..." + prime + "  " + square2 ) ; break ; } if ( ( prime + square2 ) > i ) { break ; } } if ( found ) { break ; } } if ( ! found ) { System . out . println ( "...not found" ) ; return ; } } }
te	0	public void mouseExited ( MouseEvent e ) { }
te	0	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
te	2	private void add ( char [ ] w , int wLen ) { if ( i + wLen >= b . length ) { char [ ] new_b = new char [ i + wLen + INC ] ; for ( int c = 0 ; c < i ; c ++ ) new_b [ c ] = b [ c ] ; b = new_b ; } for ( int c = 0 ; c < wLen ; c ++ ) b [ i ++ ] = w [ c ] ; }
te	3	private void scruffPolyline ( Element element ) { StringBuilder modified = new StringBuilder ( ) ; List < Point2D > points = Point2D . parsePoints ( element . getAttribute ( "points" ) ) ; for ( int i = 0 , n = points . size ( ) - 1 ; i < n ; i ++ ) { Point2D pn0Orig = points . get ( i ) ; Point2D pn0 = pn0Orig ; Point2D pn1 = points . get ( i + 1 ) ; double hMax = 0.02 * pn0Orig . lengthTo ( pn1 ) ; modified . append ( pn0 . asString ( ) ) . append (   ) ; double distance ; while ( ( distance = pn0 . lengthTo ( pn1 ) ) > 20 ) { double radius = distance * 0.02 ; if ( radius > 5 ) radius = 5 ; Point2D interm ; do { interm = pn0 . split ( pn1 , distance * random . nextDouble ( ) ) . angularMove ( radius , 2 * Math . PI * random . nextDouble ( ) ) ; } while ( pointToLineDistance ( pn0Orig , pn1 , interm ) > hMax ) ; modified . append ( interm . asString ( ) ) . append (   ) ; pn0 = interm ; } } modified . append ( points . get ( points . size ( ) - 1 ) . asString ( ) ) ; element . setAttribute ( "points" , modified . toString ( ) ) ; }
te	3	private void createMirrorList ( ) throws ParserConfigurationException , SAXException , IOException { URL mirrorsUrl = new URL ( String . format ( Constants . MIRRORS_URL , this . apiKey ) ) ; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; Document document = documentBuilder . parse ( mirrorsUrl . openStream ( ) ) ; Element rootElement = document . getDocumentElement ( ) ; NodeList nodes = rootElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; if ( node . getNodeName ( ) . equals ( "Mirror" ) ) { NodeList mirrorNodes = node . getChildNodes ( ) ; String mirrorPath = null ; int typeMask = 0 ; for ( int j = 0 ; j < mirrorNodes . getLength ( ) ; ++ j ) { Node mirrorNode = mirrorNodes . item ( j ) ; if ( mirrorNode . getNodeName ( ) . equals ( "mirrorpath" ) ) { mirrorPath = mirrorNode . getTextContent ( ) ; } else if ( mirrorNode . getNodeName ( ) . equals ( "typemask" ) ) { typeMask = Integer . parseInt ( mirrorNode . getTextContent ( ) ) ; } } List < MirrorType > mirrorTypesForMask = this . getMirrorTypesFromTypeMask ( typeMask ) ; for ( MirrorType mt : mirrorTypesForMask ) { if ( mt . equals ( MirrorType . ZIP ) ) { this . zipMirrors . add ( mirrorPath ) ; } else if ( mt . equals ( MirrorType . BANNER ) ) { this . bannerMirrors . add ( mirrorPath ) ; } else if ( mt . equals ( MirrorType . XML ) ) { this . xmlMirrors . add ( mirrorPath ) ; } } } } }
te	3	public boolean areAnagramsCount ( String a , String b ) { if ( a == null && b == null ) return false ; else if ( a == null || b == null ) return false ; else { int [ ] count = new int [ 256 ] ; char [ ] ac = a . toCharArray ( ) ; for ( char c : ac ) { count [ c ] ++ ; } char [ ] bc = b . toCharArray ( ) ; for ( char c : bc ) { count [ c ] -- ; } for ( int i : count ) { if ( i != 0 ) return false ; } } return true ; }
te	0	public void removeColumn ( String columnID ) { htColumns . remove ( columnID ) ; }
te	2	public static double test ( double [ ] [ ] A , double [ ] b ) { GaussJordanElimination gaussian = new GaussJordanElimination ( A , b ) ; System . out . print ( "\nOriginal: " ) ; for ( double aDouble : b ) { System . out . print ( aDouble + " " ) ; } System . out . println ( ) ; if ( gaussian . isFeasible ( ) ) { double suma = 0.0 ; double [ ] x = gaussian . primal ( ) ; for ( int i = 0 ; i < x . length ; i ++ ) { System . out . printf ( "%9.2f\t" , x [ i ] ) ; suma += Math . abs ( x [ i ] ) ; } System . out . printf ( "\n\t(%6.2f)\n" , varianza ( x ) ) ; return suma ; } else { System . out . println ( "no hay solucion" ) ; System . out . println ( ) ; } return double . MAX_VALUE ; }
te	2	public static Set < Set < Integer >> allSubSet ( Set < Integer > s ) { Set < Set < Integer >> pre = new HashSet < > ( ) ; for ( Integer e : s ) { Set < Set < Integer >> dup = new HashSet < > ( ) ; for ( Set < Integer > ss : pre ) { dup . add ( new HashSet < Integer > ( ss ) ) ; ss . add ( e ) ; } pre . addAll ( dup ) ; pre . add ( new HashSet < Integer > ( Arrays . asList ( e ) ) ) ; } return pre ; }
te	0	@ Before public void setUp ( ) { DB . setDataSource ( new SQLite ( ) ) ; }
te	1	@ Override public void step ( ) { for ( AgentModel m : agents . values ( ) ) { m . model . step ( ) ; } }
te	0	public void setAddressId ( int value ) { addressId = value ; }
te	4X	public SuffixArray ( String s ) { int n = s . length ( ) ; int logN = 32 - Integer . numberOfLeadingZeros ( n - 1 ) ; sa = new SuffixArrayEntry [ n ] ; int [ ] [ ] pos = new int [ logN + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sa [ i ] = new SuffixArrayEntry ( ) ; pos [ 0 ] [ i ] = s . charAt ( i ) ; } for ( int t = 1 , step = 1 ; step < n ; t ++ , step *= 2 ) { for ( int i = 0 ; i < n ; i ++ ) { sa [ i ] . idx = i ; sa [ i ] . prevPos = pos [ t - 1 ] [ i ] ; sa [ i ] . pos = i + step < n ? pos [ t - 1 ] [ i + step ] : - 1 ; } Arrays . sort ( sa ) ; for ( int i = 0 ; i < n ; i ++ ) { pos [ t ] [ sa [ i ] . idx ] = ( i > 0 && sa [ i ] . compareTo ( sa [ i - 1 ] ) == 0 ) ? pos [ t ] [ sa [ i - 1 ] . idx ] : i ; } } int [ ] lcp = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int x = sa [ i ] . idx , y = sa [ i + 1 ] . idx ; for ( int k = logN - 1 ; k >= 0 && x < n && y < n ; k -- ) { if ( pos [ k ] [ x ] == pos [ k ] [ y ] ) { x += 1 << k ; y += 1 << k ; lcp [ i ] += 1 << k ; } } } st = pos ; st [ 0 ] = lcp ; for ( int i = 1 ; i < logN ; i ++ ) { for ( int j = 0 ; j < n - ( 1 << i ) + 1 ; j ++ ) { st [ i ] [ j ] = Math . min ( st [ i - 1 ] [ j ] , st [ i - 1 ] [ j + ( 1 << i - 1 ) ] ) ; } } }
te	4X	private void backpropagate ( double [ ] exp ) { int i = 0 ; for ( Neuron outputNeuron : this . output ) { outputNeuron . setError ( ( exp [ i ] - outputNeuron . getLatestOutput ( ) ) ) ; outputNeuron . addBiasChange ( outputNeuron . getError ( ) ) ; i ++ ; } for ( i = this . hidden . size ( ) - 1 ; i >= 0 ; i -- ) { for ( Neuron h : this . hidden . get ( i ) ) { double p = this . functions . derivative ( h . getLatestSum ( ) ) ; double k = 0 ; for ( Synaps s : h . getconnectedTo ( ) ) { k += s . getTo ( ) . getError ( ) * s . getweight ( ) ; } h . setError ( p * k ) ; } for ( Neuron neuron : this . hidden . get ( i ) ) { neuron . addBiasChange ( neuron . getError ( ) ) ; } } for ( Neuron n : this . input ) { for ( Synaps s : n . getconnectedTo ( ) ) { s . addWeightChange ( s . getTo ( ) . getError ( ) * n . getLatestInput ( ) ) ; } } for ( List < Neuron > l : this . hidden ) { for ( Neuron n : l ) { for ( Synaps s : n . getconnectedTo ( ) ) { s . addWeightChange ( s . getTo ( ) . getError ( ) * n . getLatestOutput ( ) ) ; } } } }
te	0	public void setIndId ( Integer indId ) { this . indId = indId ; }
te	0	public BIOSwitch ( String onString , String offString ) { super ( onString ) ; create ( ) ; setOffString ( offString ) ; }
te	1	public Dimension resizeRiskBoard ( int height , int width ) { Dimension d = backGround . resizeImage ( height , width ) ; this . setPreferredSize ( d ) ; this . setMinimumSize ( d ) ; this . setMaximumSize ( d ) ; this . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; map . setPreferredSize ( d ) ; map . setMinimumSize ( d ) ; map . setMaximumSize ( d ) ; map . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; buttonPanel . setPreferredSize ( d ) ; buttonPanel . setMinimumSize ( d ) ; buttonPanel . setMaximumSize ( d ) ; buttonPanel . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; backGround . setPreferredSize ( d ) ; backGround . setMinimumSize ( d ) ; backGround . setMaximumSize ( d ) ; backGround . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; repaint ( ) ; for ( CountryButton c : countryButtons . values ( ) ) { c . setCurrentPosition ( d . width , d . height ) ; } return d ; }
te	2	private static Node < Integer > partitionList2 ( Node < Integer > node , int x ) { Node < Integer > before = null ; Node < Integer > after = null ; while ( node != null ) { Node < Integer > next = node . getNext ( ) ; if ( node . getData ( ) < x ) { node . setNext ( before ) ; before = node ; } else { node . setNext ( after ) ; after = node ; } node = next ; } if ( before == null ) { return after ; } Node < Integer > head = before ; while ( before . getNext ( ) != null ) { before = before . getNext ( ) ; } before . setNext ( after ) ; return head ; }
te	2	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
te	0	@ Override public double calculateDiscount ( double price , int qty ) { return ( qty * dollarAmt ) ; }
te	1	public Signals ( int x , int y , int h , String data [ ] ) { this . x = x ; this . y = y ; fontHeight = ( h - 2 ) * 2 / 3 ; newFontHeight = fontHeight ; if ( data != null ) for ( int n = 0 ; n < data . length ; n ++ ) addSignal ( data [ n ] ) ; }
te	4X	private static void gaussian ( double src [ ] [ ] , double dst [ ] [ ] ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) dst [ i ] [ j ] = src [ i ] [ j ] ; for ( int i = 0 ; i < 4 ; i ++ ) index [ i ] = i ; for ( int i = 0 ; i < 4 ; i ++ ) { double c1 = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { double c0 = Math . abs ( dst [ i ] [ j ] ) ; if ( c0 > c1 ) c1 = c0 ; } c [ i ] = c1 ; } int k = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { double p1 = 0 ; for ( int i = j ; i < 4 ; i ++ ) { double p0 = Math . abs ( dst [ index [ i ] ] [ j ] ) ; p0 /= c [ index [ i ] ] ; if ( p0 > p1 ) { p1 = p0 ; k = i ; } } int itmp = index [ j ] ; index [ j ] = index [ k ] ; index [ k ] = itmp ; for ( int i = j + 1 ; i < 4 ; i ++ ) { double pj = dst [ index [ i ] ] [ j ] / dst [ index [ j ] ] [ j ] ; dst [ index [ i ] ] [ j ] = pj ; for ( int l = j + 1 ; l < 4 ; l ++ ) dst [ index [ i ] ] [ l ] -= pj * dst [ index [ j ] ] [ l ] ; } } }
te	1	@ Override public void run ( ) { try { while ( active ) { synchronized ( messages ) { if ( messages . isEmpty ( ) ) { messages . wait ( 200 ) ; } else { NetworkMessage nm = messages . remove ( 0 ) ; out . write ( nm . getData ( ) ) ; } } } } catch ( InterruptedException ex ) { System . err . println ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
