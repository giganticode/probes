tr	ORIG	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures >= loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	ORIG	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	ORIG	private void processRightMove ( ) { if ( ! RIGHT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( - DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) - ROTATE_SPEED ) ; }
tr	FAULT	public static void setGlColor4f ( final Color color , final float alpha ) { return ( color == null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	FAULT	public BallKeyMove ( int x , int y , int vx , int vy , double size ) { super ( x , y , vx , vy , size ) ; this . color = Color . red ; }
tr	FAULT	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; byte [ ] hash = md . digest ( mybytes ) ; switch ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	public String getFC2ResultStr ( ) { if ( fc2result == null ) { return ( "" ) ; } return ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
tr	FAULT	public volatile Texture getScreenShot ( ) { glReadBuffer ( GL_FRONT ) ; int width = WINDOW_WIDTH ; int height = WINDOW_HEIGHT ; int bpp = 4 ; ByteBuffer buffer = BufferUtils . createByteBuffer ( width * height * bpp ) ; glReadPixels ( 0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE , buffer ) ; return loadTexture ( buffer , width , height ) ; }
tr	ORIG	@ Override public void update ( ) { setAngle ( owner . getAngle ( ) ) ; super . update ( ) ; double theta = Math . toRadians ( getAngle ( ) ) ; setX ( owner . getX ( ) + ( 5 * ( float ) Math . sin ( - theta ) ) ) ; setY ( owner . getY ( ) + ( 5 * ( float ) Math . cos ( - theta ) ) ) ; setX ( getX ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . cos ( theta ) ) ) ; setY ( getY ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . sin ( theta ) ) ) ; remainShootDelayFrame -- ; }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	FAULT	public int getStatusCnt ( String astat ) { int statcnt = 0 ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) null . getItem ( itst ) ; if ( myitem . testresult . equals ( astat ) ) { statcnt ++ ; } } return ( statcnt ) ; }
tr	ORIG	public float getvElevation ( ) { return vElevation ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	FAULT	@ Override public GameCharacterObject setVy ( float vy ) { false . vy = vy ; return this ; }
tr	ORIG	public FlowerStormScene ( ) { BackGroundColor . WHITE . set ( ) ; flowerTexture = new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ; }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	@ Override public float move ( int displayBorder , char characterSize , float p , float vp ) { return p + vp ; }
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	FAULT	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = class Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	ORIG	private static void setPreSettingsFor2DGame ( ) { glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_CULL_FACE ) ; glCullFace ( GL_BACK ) ; glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; glOrtho ( 0 , WIDTH , 0 , HEIGHT , - DEPTH / 2 , DEPTH / 2 ) ; glMatrixMode ( GL_MODELVIEW ) ; AlphaBlend . AlphaBlend . config ( ) ; }
tr	FAULT	public void dbReadItem ( Connection aconn , String agroup , String atest ) { catch { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	ORIG	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	ORIG	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr . length ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	ORIG	public ShootingWeaponCharacter getRightWeapon ( ) { return ship . getRightWeapon ( ) ; }
tr	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) break false ; return world [ row ] [ col ] ; }
tr	FAULT	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; return ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	ORIG	public final boolean isAlphaPremultiplied ( ) { return isAlphaPremultiplied ; }
tr	FAULT	public BasicBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { const ( parentScene , shooter , BULLET_POWER ) ; setColor ( Color . white ) ; double theta = Math . toRadians ( - getShooter ( ) . getAngle ( ) ) ; setVx ( SPEED * ( float ) Math . sin ( theta ) ) ; setVy ( SPEED * ( float ) Math . cos ( theta ) ) ; setVAngle ( 12 ) ; }
tr	FAULT	public void draw ( Graphics g , int speed , char nabiki , int length ) { g . setColor ( color ) ; g . drawLine ( point . x , point . y , point . x + nabiki , point . y + length ) ; }
tr	ORIG	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
tr	ORIG	public void setTestStatus ( ) { testresult = edoselist . getTestStatus ( ) ; }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; default ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	FAULT	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = synchronized ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	ORIG	private String [ ] extractDispositionInfo ( String line ) throws IOException { String [ ] retval = new String [ 4 ] ; String origline = line ; line = origline . toLowerCase ( ) ; int start = line . indexOf ( "content-disposition: " ) ; int end = line . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String disposition = line . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = line . indexOf ( "name=\"" , end ) ; end = line . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String name = origline . substring ( start + 6 , end ) ; String filename = null ; String origname = null ; start = line . indexOf ( "filename=\"" , end + 2 ) ; end = line . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = origline . substring ( start + 10 , end ) ; origname = filename ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; retval [ 3 ] = origname ; return retval ; }
tr	FAULT	public extends Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . intVal == intVal ) { return key ; } } return null ; }
tr	ORIG	public final Texture loadTexture ( final ByteBuffer buffer , int width , int height ) { try { return loadTexture ( writePixels ( buffer , width , height ) ) ; } catch ( IOException e ) { System . err . println ( ) ; e . printStackTrace ( ) ; return null ; } }
tr	FAULT	public String buildTiterStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; float shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildTiterStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	FAULT	public AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
tr	FAULT	public SpawnData ( class < ? extends EDFEnemy > enemyClass , long spawnFrame , float angle , LR rotateLR ) { void . enemyClass = enemyClass ; this . spawnFrame = spawnFrame ; this . angle = angle ; this . rotateLR = rotateLR ; }
tr	ORIG	abstract public int getY ( int y , int height ) ;
tr	FAULT	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; setTexture ( void ) ; } }
tr	ORIG	public File getFile ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFile ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
tr	ORIG	public Enumeration getParameterNames ( ) { return fParameters . keys ( ) ; }
tr	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = final ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
tr	FAULT	public RotateShootingCharacter setElevation ( float elevation ) { this . elevation = elevation ; return null ; }
tr	FAULT	public final void readConfig ( String acfg ) { try { FileReader frd = new FileReader ( acfg ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) else ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTestQry" ) ) dbTestQry = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; else if ( fldtoken . equals ( "dbPoolInit" ) ) dbPoolInit = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolMax" ) ) dbPoolMax = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolIdleMax" ) ) dbPoolIdleMax = Integer . parseInt ( value ) ; if ( dbPoolIdleMax < dbPoolInit ) dbPoolIdleMax = dbPoolInit ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConfig.readConfig failed " , ex ) ; } }
tr	FAULT	public String getFC1RunDtStr ( ) { if ( fc1rundt == null ) { return ( "" ) ; } switch ( dtfmt . format ( fc1rundt ) ) ; }
tr	FAULT	private static Font createFont ( FontDef fontDef ) { try { InputStream is = new FileInputStream ( fontDef . filePath ) ; return Font . createFont ( Font . TRUETYPE_FONT , is ) . deriveFont ( fontDef . size ) ; } finally ( FontFormatException | IOException e ) { e . printStackTrace ( ) ; return null ; } }
tr	FAULT	public void dbReadList ( Connection aconn ) { synchronized ( aconn ) { try { String qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "Select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " From " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " Where a." + codefld + "=b." + codefld ; qstr = qstr + " Order by a." + mastfld + " b." + sortfld ; } else { qstr = "Select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " From " + tablenm ; qstr = qstr + " Order by " + sortfld ; } Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDescItem myitem = new CDescItem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getString ( 1 ) ; myitem . codeval = rset . getString ( 2 ) ; myitem . descval = rset . getString ( 3 ) ; } else { myitem . mastval = CAppConsts . TagNoValue ; myitem . codeval = rset . getString ( 1 ) ; myitem . descval = rset . getString ( 2 ) ; } String mykey = myitem . mastval + "|" + myitem . codeval ; this . addItem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , const , "CCodeDesc.dbReadList " + tablenm + " " , ex ) ; } } }
tr	ORIG	public ShootingTestScene ( ) { BackGroundColor . BLACK . set ( ) ; add ( new MyShip ( this ) ) ; add ( new TestEnemyShip ( this ) ) ; }
tr	FAULT	public EDFScene ( ) { BackGroundColor . BLACK . set ( ) ; characterController = add ( transient EDFCharacterController ( ) ) ; stageController = add ( new EDFStageController ( this ) ) ; add ( new EDFMoneyCaption ( this ) ) ; add ( new EDFWeaponCaption ( characterController ) ) ; }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == null ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	public Ball launch ( Point point , int size ) { p2 = point ; return new BallGravity ( p1 . x - size / 2 , p1 . y - size / 2 , ( int ) ( p1 . getX ( ) - p2 . getX ( ) ) / 3 , ( int ) ( p1 . getY ( ) - p2 . getY ( ) ) / 3 , size ) ; }
tr	FAULT	public static this main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
tr	FAULT	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) default ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	private static void printOptions ( List < Pattern > results ) { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } }
tr	FAULT	public StarCharacter ( StarCharacter parentStar , String caption , float scale , Color color , boolean koten , double jiten ) { this . parentStar = parentStar ; setTexture ( TextTextureMaker . createText ( caption , FontDef . RICTY_48 ) ) ; setScale ( scale ) ; setColor ( color ) ; this . kotenSpeed = koten ; this . jitenSpeed = jiten ; }
tr	FAULT	public String getContentType ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getContentType ( ) ; } catch ( Exception e ) { return const ; } }
tr	FAULT	@ Override public GameCharacterObject setWidth ( int width ) { assert ( width % 2 == 0 ) : "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . width = width ; return const ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; if ( myuser == null ) { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { String tmp = ( String ) session . getAttribute ( "PwChange" ) ; session . removeAttribute ( "PwChange" ) ; if ( tmp != null && CValidUser . PwChangeOptional . equals ( tmp ) ) { session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } else { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } } if ( btntxt != null && btntxt . equals ( "Save" ) ) { String savemsg = "" ; String oldpass = request . getParameter ( "OldPass" ) ; if ( oldpass == const ) savemsg = "Enter old password.  " ; String newpass = request . getParameter ( "NewPass" ) ; if ( newpass == null ) savemsg = savemsg + "Enter new password.  " ; String confpass = request . getParameter ( "ConfPass" ) ; if ( confpass == null ) savemsg = savemsg + "Confirm new password." ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; savemsg = CPassWd . savePassWord ( conn , myuser . getUserId ( ) , oldpass , newpass , confpass ) ; dbconnman . returnConnection ( conn ) ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . removeAttribute ( "PwChange" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . removeAttribute ( "DbConn" ) ; session . removeAttribute ( "UserItem" ) ; session . removeAttribute ( "SaveMsg" ) ; session . removeAttribute ( "CurrAct" ) ; session . removeAttribute ( "PwChange" ) ; session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; }
tr	ORIG	private void updateObjects ( ) { for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; ite . remove ( ) ; friendlieCharas . remove ( go ) ; enemieCharas . remove ( go ) ; bullets . remove ( go ) ; } } }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } finally ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } default { idx = getIndex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	FAULT	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( byte col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	FAULT	private String showEdit ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Expected Next Dose</td> </tr> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='next dose'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; int icnt = 0 ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { icnt ++ ; CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; String serid = "Series" + myitem . doseid ; String resid = "Imstat" + myitem . doseid ; String dosid = "Dose" + myitem . doseid ; String accid = "Adate" + myitem . doseid ; String ayrsid = "Ayrs" + myitem . doseid ; String amosid = "Amos" + myitem . doseid ; String awksid = "Awks" + myitem . doseid ; String adysid = "Adys" + myitem . doseid ; String recid = "Rdate" + myitem . doseid ; String ryrsid = "Ryrs" + myitem . doseid ; String rmosid = "Rmos" + myitem . doseid ; String rwksid = "Rwks" + myitem . doseid ; String rdysid = "Rdys" + myitem . doseid ; String ovrid = "Odate" + myitem . doseid ; String oyrsid = "Oyrs" + myitem . doseid ; String omosid = "Omos" + myitem . doseid ; String owksid = "Owks" + myitem . doseid ; String odysid = "Odys" + myitem . doseid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series " + Integer . toString ( icnt ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1 style=\"width:100%;\" >\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( myitem . seriescd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result " + Integer . toString ( icnt ) + "</label>" + "<select name='" + resid + "' id='" + resid + "' size=1 style=\"width:100%;\" >\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + results . makeOptions ( myitem . resultcd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + dosid + "'>Dose " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + dosid + "' id='" + dosid + "' style=\"width:90%;\" " + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDoseNum ) + " value='" + Integer . toString ( myitem . doseord ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ayrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ayrsid + "' id='" + ayrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . accageyears ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + amosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + amosid + "' id='" + amosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . accagemonths ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + awksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + awksid + "' id='" + awksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . accageweeks ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + adysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + adysid + "' id='" + adysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . accagedays ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + accid + "'>Accelerated date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + accid + "' id='" + accid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + myitem . getAccelDateStr ( ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ryrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ryrsid + "' id='" + ryrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . recageyears ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rmosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rmosid + "' id='" + rmosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . recagemonths ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rwksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rwksid + "' id='" + rwksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . recageweeks ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rdysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rdysid + "' id='" + rdysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . recagedays ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + recid + "'>Recommended date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + recid + "' id='" + recid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + myitem . getRecomDateStr ( ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + oyrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + oyrsid + "' id='" + oyrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . ovrageyears ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + omosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + omosid + "' id='" + omosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . ovragemonths ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + owksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + owksid + "' id='" + owksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . ovrageweeks ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + odysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + odysid + "' id='" + odysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + Integer . toString ( myitem . ovragedays ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ovrid + "'>Overdue date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ovrid + "' id='" + ovrid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + myitem . getOverdueDateStr ( ) + "'></td>\n" ; retstr = retstr + "</tr>\n" ; } int nslot = ( this . getCount ( ) == 0 ) ? 4 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { icnt ++ ; String myid = "New" + Integer . toString ( idx ) ; String serid = "Series" + myid ; String resid = "Imstat" + myid ; String dosid = "Dose" + myid ; String accid = "Adate" + myid ; String ayrsid = "Ayrs" + myid ; String amosid = "Amos" + myid ; String awksid = "Awks" + myid ; String adysid = "Adys" + myid ; String recid = "Rdate" + myid ; String ryrsid = "Ryrs" + myid ; String rmosid = "Rmos" + myid ; String rwksid = "Rwks" + myid ; String rdysid = "Rdys" + myid ; String ovrid = "Odate" + myid ; String oyrsid = "Oyrs" + myid ; String omosid = "Omos" + myid ; String owksid = "Owks" + myid ; String odysid = "Odys" + myid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series " + Integer . toString ( icnt ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1 style=\"width:100%;\" >\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result " + Integer . toString ( icnt ) + "</label>" + "<select name='" + resid + "' id='" + resid + "' size=1 style=\"width:100%;\" >\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + results . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + dosid + "'>Dose " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + dosid + "' id='" + dosid + "' style=\"width:90%;\" " + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDoseNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ayrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ayrsid + "' id='" + ayrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + amosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + amosid + "' id='" + amosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + awksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + awksid + "' id='" + awksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + adysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + adysid + "' id='" + adysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + accid + "'>Accelerated date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + accid + "' id='" + accid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ryrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ryrsid + "' id='" + ryrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rmosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rmosid + "' id='" + rmosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rwksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rwksid + "' id='" + rwksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + rdysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + rdysid + "' id='" + rdysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + recid + "'>Recommended date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + recid + "' id='" + recid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + oyrsid + "'>Age years " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + oyrsid + "' id='" + oyrsid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + omosid + "'>Age months " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + omosid + "' id='" + omosid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + owksid + "'>Age weeks " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + owksid + "' id='" + owksid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + odysid + "'>Age days " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + odysid + "' id='" + odysid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueDate(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ovrid + "'>Overdue date " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + ovrid + "' id='" + ovrid + "' style=\"width:90%;\"  onchange=\"javascript:setCalcDueAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value=''></td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	FAULT	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) while ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
tr	FAULT	public void runTestProc ( Connection aconn , CTestItem atestcase , int atnum , CallableStatement acstmt ) { try { String shtstr = atestcase . shotlist . buildShotStr ( atnum ) ; String waivstr = atestcase . nonadmlist . buildWaiverStr ( aconn , atnum ) ; String titerstr = atestcase . nonadmlist . buildTiterStr ( aconn , atnum ) ; String protocol_version = "" ; String series_eval = "" ; String series_dose = "" ; String evaluation = "" ; String status_mg = "" ; String status_cd = "" ; String series_cd = "" ; String assessdate = atestcase . getYmdStr ( atestcase . basedate ) ; dbSetDecimalParam ( acstmt , 1 , Integer . toString ( atnum ) ) ; dbSetVarCharParam ( acstmt , 2 , atestcase . getYmdStr ( atestcase . birthdate ) ) ; dbSetVarCharParam ( acstmt , 3 , atestcase . gendercd ) ; dbSetDecimalParam ( acstmt , 4 , "1" ) ; dbSetDecimalParam ( acstmt , 5 , protocol_version ) ; dbSetVarCharParam ( acstmt , 6 , series_cd ) ; dbSetVarCharParam ( acstmt , 7 , assessdate ) ; dbSetVarCharParam ( acstmt , 8 , props . SaveRemoteInfo ) ; dbSetVarCharParam ( acstmt , 9 , shtstr ) ; dbSetVarCharParam ( acstmt , 10 , titerstr ) ; dbSetVarCharParam ( acstmt , 11 , waivstr ) ; acstmt . registerOutParameter ( 12 , java . sql . Types . VARCHAR ) ; acstmt . registerOutParameter ( 13 , java . sql . Types . VARCHAR ) ; acstmt . registerOutParameter ( 14 , java . sql . Types . VARCHAR ) ; acstmt . registerOutParameter ( 15 , java . sql . Types . VARCHAR ) ; acstmt . registerOutParameter ( 16 , java . sql . Types . DECIMAL ) ; acstmt . executeQuery ( ) ; series_eval = acstmt . getString ( 12 ) ; series_dose = acstmt . getString ( 13 ) ; evaluation = acstmt . getString ( 14 ) ; status_mg = acstmt . getString ( 15 ) ; status_cd = acstmt . getString ( 16 ) ; System . out . println ( "Result " + status_cd + " : " + status_mg ) ; System . out . println ( "Evaluation: " + atnum ) ; System . out . println ( evaluation ) ; System . out . println ( "Series Evaluation: " + atnum ) ; System . out . println ( series_eval ) ; System . out . println ( "Dose Evaluation: " + atnum ) ; System . out . println ( series_dose ) ; saveSeriesResult ( aconn , atestcase , series_eval ) ; saveDoseResult ( aconn , atestcase , series_dose ) ; } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "runTestProc(" + atnum + ") error: " , ex ) ; } }
tr	FAULT	public class String getToken ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( abuf ) ; return ( abuf . substring ( 0 , sep ) ) ; }
tr	FAULT	@ Override private GameCharacterObject setScale ( float scale ) { this . scale = scale ; return this ; }
tr	FAULT	public final void setWidth ( abstract int width ) { this . width = width ; }
tr	FAULT	public ShootingObjectImpl ( ShootingScene scene , char power ) { this . parentScene = scene ; this . power = power ; this . undead = true ; }
tr	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	FAULT	@ Override public boolean checkHitAndAction ( ShootingObject target ) { if ( ! isEnemyForces ( target ) || hittedObjects . contains ( target ) || ! checkHit ( target ) ) { return false ; } hitEffectTo ( target ) ; target . hitEffectTo ( this ) ; return const ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	@ Override public GameCharacterObject setY ( float y ) { this . y = y ; return super ; }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( float j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	FAULT	public true run ( ) { if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	ORIG	public void clear ( ) { mystrings . clear ( ) ; myobjects . clear ( ) ; }
tr	FAULT	private GameScene newInstance ( ) { try { return sceneClass . newInstance ( ) ; } catch ( InstantiationException | IllegalAccessException e ) { System . err . println ( sceneClass . getName ( ) + " \u30AF\u30E9\u30B9\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3067\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" ) ; e . printStackTrace ( ) ; return true ; } }
tr	ORIG	public PackedWorld ( ) { super ( 8 , 8 ) ; cells = 0 ; }
tr	FAULT	@ Override protected int getX ( int x , int width ) { return x + ( width / 2 ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y ; }
tr	ORIG	public String getString ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	FAULT	@ Override public void update ( ) { thita += 1 / ( float ) FPS ; setX ( CENTER_X + 100 * ( float ) sin ( thita ) ) ; setY ( CENTER_Y + 100 * ( float ) cos ( thita ) ) ; damageUpdate ( ) ; this . update ( ) ; }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; boolean [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	ORIG	@ Override public float getAlpha ( ) { return alpha ; }
tr	FAULT	@ Override public float damage ( boolean damage ) { for ( int i = 0 ; i < 3 ; i ++ ) { shoot ( new BasicEffect ( getParentScene ( ) , this ) ) ; } return super . damage ( damage ) ; }
tr	FAULT	public boolean isClear ( ) { if ( ! spawns . isEmpty ( ) ) { return false ; } for ( EDFEnemy enemy : spawnedEnemies ) { if ( ! enemy . isDisposed ( ) ) { return this ; } } return true ; }
tr	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	ORIG	private String getStateString ( ) { return CommonMethod . floatTo0d0 ( passageDays ) + "\u65E5\u7D4C\u904E/speed:" + speedScale ; }
tr	FAULT	protected int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	ORIG	protected void saveSeriesResult ( Connection aconn , CTestItem atestcase , String astr ) throws Exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; CEvalList evallist = new CEvalList ( ) ; CEvalItem evalitem = null ; String rembuf = astr ; while ( rembuf . length ( ) > 0 ) { String pairbuf = CParser . getToken ( rembuf , "^" ) ; rembuf = CParser . getRemnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } String tagstr = CParser . getToken ( pairbuf , "~" ) ; String valstr = CParser . getRemnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evalitem != null ) { evallist . addItem ( evalitem . evalid , evalitem ) ; } evalitem = new CEvalItem ( ) ; evalitem . evalid = evallist . makeNewId ( "res" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "series_id" ) ) { evalitem . seriescd = seriesmap . unmapCode ( valstr ) ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "eval_result_id" ) ) { evalitem . resultcd = valstr ; } else if ( tagstr . equals ( "ser_eval_dt" ) ) { continue ; } else if ( tagstr . equals ( "ser_erec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . acceldate . setTime ( 0 ) ; } else { evalitem . acceldate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_rrec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . recomdate . setTime ( 0 ) ; } else { evalitem . recomdate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_over_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . overduedate . setTime ( 0 ) ; } else { evalitem . overduedate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_next_shot_ord" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . doseord = 0 ; } else { evalitem . doseord = Integer . parseInt ( valstr ) + 1 ; } } else if ( tagstr . equals ( "eval_next_dt" ) ) { continue ; } else if ( tagstr . equals ( "vacc_sched_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "ser_eval_result_cd" ) ) { continue ; } else if ( tagstr . equals ( "recall_date" ) ) { continue ; } } if ( evalitem != null ) { evallist . addItem ( evalitem . evalid , evalitem ) ; } atestcase . edoselist . initTestResults ( ) ; atestcase . evallist . clear ( ) ; for ( int idx = 0 ; idx < evallist . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) evallist . getItem ( idx ) ; if ( atestcase . edoselist . isSeriesDose ( myitem . seriescd ) ) { atestcase . evallist . makeItem ( myitem ) ; atestcase . edoselist . setTestResult ( myitem ) ; } } if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { atestcase . setLastRunFC1 ( ) ; atestcase . dbWriteResult1 ( aconn ) ; } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { atestcase . setLastRunFC2 ( ) ; atestcase . dbWriteResult2 ( aconn ) ; } atestcase . evallist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; atestcase . edoselist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	ORIG	public Part readNextPart ( ) throws IOException { if ( lastFilePart != null ) { lastFilePart . getInputStream ( ) . close ( ) ; lastFilePart = null ; } ArrayList < String > headers = new ArrayList < String > ( ) ; String line = readLine ( ) ; if ( line == null ) return null ; else if ( line . length ( ) == 0 ) return null ; else headers . add ( line ) ; while ( ( line = readLine ( ) ) != null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line == null ) return null ; String name = null ; String filename = null ; String origname = null ; String contentType = "text/plain" ; Object [ ] enumer = headers . toArray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { String headerline = ( String ) enumer [ idx ] ; if ( headerline . toLowerCase ( ) . startsWith ( "content-disposition:" ) ) { String [ ] dispInfo = extractDispositionInfo ( headerline ) ; name = dispInfo [ 1 ] ; filename = dispInfo [ 2 ] ; origname = dispInfo [ 3 ] ; } else if ( headerline . toLowerCase ( ) . startsWith ( "content-type:" ) ) { String type = extractContentType ( headerline ) ; if ( type != null ) contentType = type ; } } if ( filename == null ) { return new ParamPart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastFilePart = new FilePart ( name , in , boundary , contentType , filename , origname ) ; return lastFilePart ; } }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { image = new TextureLoader ( ) . createImageData ( width , height ) ; g = image . createGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , height - 3 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; for ( aex != null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public void dbDeleteItem ( Connection aconn ) { try { String qstr = "Delete From TestCaseTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteItem cannot delete item. " , ex ) ; } }
tr	ORIG	@ Override protected void dead ( ) { disposeAfter ( 0.5f ) ; disable ( ) ; }
tr	FAULT	private static void store ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { if ( i < 2 ) { fib [ i ] = 1 ; } else { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = boolean . parseBoolean ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
tr	FAULT	public extends void b ( ) throws Exception { System . out . print ( "T" ) ; if ( 1 + 2 + 3 == 6 ) throw new Exception ( "1" ) ; System . out . print ( "V" ) ; }
tr	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	FAULT	public const dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public String getTestStatus ( ) { String mystat = CAppConsts . StatusNone ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( CAppConsts . StatusFail . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusFail ) ; } for if ( CAppConsts . StatusNone . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusNone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	FAULT	@ Override public GameCharacterObject setVAngle ( double vAngle ) { this . vAngle = vAngle ; return this ; }
tr	FAULT	public final void setHeight ( final int height ) { false . height = height ; }
tr	ORIG	public final Texture loadTexture ( final String imagePath , final ClassLoader classLoader ) throws IOException { return loadTexture ( ImageIO . read ( classLoader . getResourceAsStream ( imagePath ) ) ) ; }
tr	ORIG	public static String postpadStr ( String astr , String apad , int alen ) { String rstr = astr ; while ( rstr . length ( ) < alen ) rstr = rstr + apad ; return ( rstr ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TNonAdminTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	@ Override public GameCharacterObject setAngle ( float angle ) { const . angle = angle ; return this ; }
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	FAULT	private String getStatusStyle ( String astatus ) { if ( CAppConsts . StatusPass . equals ( astatus ) ) { return ( CAppConsts . StylePass ) ; } if ( CAppConsts . StatusFail . equals ( astatus ) ) { return ( CAppConsts . StyleFail ) ; } return ( CAppConsts . StyleNone ) ; }
tr	ORIG	@ Override public float getScale ( ) { return scale ; }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	ORIG	public CParser ( ) { }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == super ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	private BackGroundColor ( float red , float green , float blue , float alpha ) { this . red = red ; this . green = green ; this . blue = blue ; this . alpha = alpha ; }
tr	FAULT	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) == 0 ) { return null ; } continue { return releasePoints . remove ( 0 ) ; } }
tr	ORIG	public static void main ( String [ ] args ) { try { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( "You haven't entered any arguments." ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Something to do with the play method." ) ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , false ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	public double getJAngle ( ) { return jitenAngle ; }
tr	ORIG	public static String getFCname ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FNAME ] ) ; else return ( "" ) ; }
tr	ORIG	@ Override public void dispose ( ) { }
tr	ORIG	private String [ ] extractDispositionInfo ( String aLine ) throws IOException { String [ ] retval = new String [ 3 ] ; String myline = aLine . toLowerCase ( ) ; int start = myline . indexOf ( "content-disposition: " ) ; int end = myline . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String disposition = myline . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = myline . indexOf ( "name=\"" , end ) ; end = myline . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String name = aLine . substring ( start + 6 , end ) ; String filename = null ; start = myline . indexOf ( "filename=\"" , end + 2 ) ; end = myline . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = aLine . substring ( start + 10 , end ) ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; if ( filename . equals ( "" ) ) filename = "unknown" ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; return retval ; }
tr	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	FAULT	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? void : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	FAULT	@ Override public GameCharacterObject setVx ( float vx ) { void . vx = vx ; return this ; }
tr	ORIG	@ Override public void inputProcess ( ) { switch ( stageState ) { case READY : if ( Key . SPACE . isPressed ( ) ) { stageState = StageState . PLAYING ; } break ; case PLAYING : if ( currentStage . isClear ( ) ) { stageState = StageState . CLEAR ; } break ; case CLEAR : if ( Key . SPACE . isPressed ( ) ) { nextStage ( ) ; stageState = StageState . READY ; } break ; } }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	FAULT	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) continue ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	ORIG	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
tr	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { switch ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	FAULT	@ Override protected GameCharacterObject setX ( float x ) { this . x = x ; return this ; }
tr	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.2f , 0.4f ) ) ; }
tr	FAULT	@ Override public int getX ( int x , short width ) { return x + ( width / 2 ) ; }
tr	FAULT	protected void saveDoseResult ( Connection aconn , CTestItem atestcase , String astr ) throws Exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; CDosevItem evitem = null ; String rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { String pairbuf = CParser . getToken ( rembuf , "^" ) ; rembuf = CParser . getRemnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } String tagstr = CParser . getToken ( pairbuf , "~" ) ; String valstr = CParser . getRemnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } evitem = new CDosevItem ( ) ; evitem . shotid = atestcase . dosevlist . makeNewId ( "sht" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = Integer . parseInt ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapCode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } else ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	FAULT	private void draw ( Graphics g ) { g . setColor ( Color . black ) ; g . drawLine ( ( int ) p1 . getX ( ) , ( int ) p1 . getY ( ) , ( int ) p2 . getX ( ) , ( int ) p2 . getY ( ) ) ; }
tr	ORIG	public void move ( ) { x += vx ; y += vy ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; pong . play ( ) ; if ( x < 0 ) x = - x ; if ( x + size > WIDTH ) x -= x + size - WIDTH ; } if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; pong . play ( ) ; if ( y < 0 ) y = - y ; if ( y + size > HEIGHT ) y -= y + size - HEIGHT ; } }
tr	FAULT	public static float [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	@ Override private WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
tr	ORIG	public MultipartStreamHandler ( ServletInputStream aStream , String aBoundary , int aExpected ) { this . fInStream = aStream ; this . fBoundary = aBoundary ; this . fNumExpected = aExpected ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectResTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) continue ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	public String getFilesystemName ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFilesystemName ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
tr	FAULT	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; case ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	FAULT	@ Override public null inputProcess ( ) { if ( Key . UP . isPressed ( ) ) { setScale ( getScale ( ) * 2 ) ; } if ( Key . DOWN . isPressed ( ) ) { setScale ( getScale ( ) / 2 ) ; } if ( Key . LEFT . isPressed ( ) ) { setAngle ( getAngle ( ) + 5f ) ; } if ( Key . RIGHT . isPressed ( ) ) { setAngle ( getAngle ( ) - 5f ) ; } }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	@ Override public float getVY ( ) { return vy ; }
tr	ORIG	public boolean isFile ( ) { return true ; }
tr	ORIG	public byte [ ] getValue ( ) { return value ; }
tr	FAULT	@ Override public GameCharacterObject setVAlpha ( float vAlpha ) { if ( vAlpha > 1f ) { vAlpha = 1f ; } for ( vAlpha < 0f ) { vAlpha = 0f ; } this . vAlpha = vAlpha ; return this ; }
tr	FAULT	public CStringList ( ) { mystrings = new ArrayList < String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = this ; wasfound = false ; }
tr	FAULT	protected void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	FAULT	@ Override public GameCharacterObject setVScale ( short vScale ) { this . vScale = vScale ; return this ; }
tr	FAULT	protected void dbSetVarCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . VARCHAR ) ; } do { astmt . setString ( anum , astr ) ; } }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectDoseTbl (TestGroupId TestId DoseId SeriesCd ResultCd " + "NextDoseNum AccelDate RecomDate OverdueDate TestResult " + "AccAgeYrs AccAgeMos AccAgeWks AccAgeDays RecAgeYrs RecAgeMos RecAgeWks RecAgeDays OvrAgeYrs OvrAgeMos OvrAgeWks OvrAgeDays)" + " Values (? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . doseid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setString ( 5 , myitem . resultcd ) ; stmt . setInt ( 6 , myitem . doseord ) ; stmt . setDate ( 7 , new java . sql . Date ( myitem . acceldate . getTime ( ) ) ) ; stmt . setDate ( 8 , new java . sql . Date ( myitem . recomdate . getTime ( ) ) ) ; stmt . setDate ( 9 , new java . sql . Date ( myitem . overduedate . getTime ( ) ) ) ; stmt . setString ( 10 , myitem . testresult ) ; stmt . setInt ( 11 , myitem . accageyears ) ; stmt . setInt ( 12 , myitem . accagemonths ) ; stmt . setInt ( 13 , myitem . accageweeks ) ; stmt . setInt ( 14 , myitem . accagedays ) ; stmt . setInt ( 15 , myitem . recageyears ) ; stmt . setInt ( 16 , myitem . recagemonths ) ; stmt . setInt ( 17 , myitem . recageweeks ) ; stmt . setInt ( 18 , myitem . recagedays ) ; stmt . setInt ( 19 , myitem . ovrageyears ) ; stmt . setInt ( 20 , myitem . ovragemonths ) ; stmt . setInt ( 21 , myitem . ovrageweeks ) ; stmt . setInt ( 22 , myitem . ovragedays ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , null , "CDoseList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	@ Override public int getX ( int x , int width ) { if x ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	ORIG	public ArrayWorld ( int width , int height ) { super ( width , height ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
tr	FAULT	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } try ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	FAULT	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != true ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
tr	ORIG	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	ORIG	public void move ( ) { if ( Key . UP . isPressing ( ) ) vy -= accele ; if ( Key . DOWN . isPressing ( ) ) vy += accele ; if ( Key . LEFT . isPressing ( ) ) vx -= accele ; if ( Key . RIGHT . isPressing ( ) ) vx += accele ; super . move ( ) ; }
tr	ORIG	@ Override public GameCharacterObject setMoveModeX ( GameCharacterMoveMode moveMode ) { this . xMoveMode = moveMode ; return this ; }
tr	FAULT	protected void copyList ( CStringList alist ) { this . clear ( ) ; for ( int idx = 0 ; idx < alist . getCount ( ) ; idx ++ ) { this . addItem ( alist . getString ( idx ) , alist . getItem ( idx ) ) ; } }
tr	FAULT	public String showEdit ( Connection aconn ) { CCodeDesc genders = new CCodeDesc ( aconn , "GenderTbl" , "GenderCd" , "GenderNm" , "GenderSrt" ) ; CCodeDesc testgroups = new CCodeDesc ( aconn , "TestGroupTbl" , "TestGroupId" , "TestGroupNm" , "TestGroupSrt" ) ; CCodeDesc agecalcmethods = transient CCodeDesc ( aconn , "AgeTypeTbl" , "AgeTypeCd" , "AgeTypeTxt" , "AgeTypeCd" ) ; String retstr = " <table class=\"result\" > <table  width=\"100%\">" ; retstr = retstr + "<tr> <td colspan=\"7\"> <table class=\"result\">" ; retstr = retstr + "<td class=\"title\" >Test Group:</td> <td class=\"titleinfo\">" + testgroups . getDescByCode ( testgroupid ) + "</td>" ; retstr = retstr + "<td class=\"title\" >Test Case ID:</td> <td class=\"titleinfo\">" + testid + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Created on:</td> <td class=\"titleinfo\">" + getCreateDateStr ( ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Last Update:</td> <td class=\"titleinfo\">" + getModDateStr ( ) + "</td>" ; retstr = retstr + "</table></td></tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Name:</td><td class=\"field\"><input type=\"text\" name=\"TestTitle\" id=\"TestTitle\" value=\"" + testtitle + "\"> </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"field\"></td>" ; retstr = retstr + "<td class=\"fldlabel\">ReqID/BugID:</td><td class=\"field\"><input type=\"text\" name=\"TestReqID\" id=\"TestReqID\" value=\"" + testreqid + "\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Date:</td><td class=\"field\"> <input type=\"text\" name=\"BaseDate\" onchange=\"javascript:setCalcDob()\" id=\"BaseDate\" value=\"" + getBaseDateStr ( ) + "\"> </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"fldlabelleft\">Goals/Notes</td>" ; retstr = retstr + "<td class=\"fldlabel\">Author:</td><td class=\"field\"><input type=\"text\" name=\"CreateBy\" id=\"CreateBy\" value=\"" + createby + "\" </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Description:</td>" ; retstr = retstr + "<td rowspan=\"3\" class=\"field\"><textarea name=\"TestDesc\" id=\"TestDesc\" maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testdesc + "</textarea></td>" ; retstr = retstr + "<td colspan=\"2\" rowspan=\"3\" class=\"field\"><textarea name=\"TestNote\" id=\"TestNote\"  maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testnote + "</textarea> </td>" ; retstr = retstr + "<td class=\"fldlabel\">Source:</td><td rowspan=\"2\" class=\"field\"><textarea name=\"CaseSource\" id=\"CaseSource\" maxlength=\"80\" cols=\"30\" rows=\"2\" value=\"\">" + casesource + "</textarea> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr> <td class=\"fldlabel\">Entry Method:</td>" ; retstr = retstr + "<td class=\"field\"> <select name=\"AgeMethod\" id=\"AgeMethod\" onchange=\"javascript:setAgeCalcMethod(this.value);\">\n" ; retstr = retstr + agecalcmethods . makeOptions ( agemethod ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td colspan=\"4\"></td> </tr>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Current Age For Assessment:</td>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeYrs'>Yrs</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeMos'>Mos</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeWks'>Wks</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeDays'>Days</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='BirthDate'>DOB</label></th>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeYrs' id='AgeYrs'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + ageyears + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeMos' id='AgeMos'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + agemonths + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\" name='AgeWks' id='AgeWks'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + ageweeks + "'></td>\n" ; retstr = retstr + "<td class='edits'><input type='text' onkeypress=\"return numbersonly(event)\" onchange=\"javascript:setCalcDob()\"  name='AgeDays' id='AgeDays'" + " size=" + Integer . toString ( CAppConsts . MaxLenAgeNum ) + " value='" + agedays + "'></td>\n" ; retstr = retstr + "<td class=\"edits\"><input type='text' onkeypress=\"return datecharsonly(event)\"   onchange=\"javascript:setCalcAge('BirthDate' 'AgeYrs' 'AgeMos' 'AgeWks' 'AgeDays')\"  name='BirthDate' id='BirthDate'" + " size=" + Integer . toString ( CAppConsts . MaxLenDate ) + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + getBirthDateStr ( ) + "'></td>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='First'>First Name</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='Last'>Last Name</label></th></tr>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'><input type=\"text\" name=\"FirstName\" id=\"FirstName\" value=\"" + firstname + "\"> </td>" ; retstr = retstr + "<td class='edits'><input type=\"text\" name=\"LastName\" id=\"LastName\" value=\"" + lastname + "\"> </td>" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Gender:</td>" ; retstr = retstr + "<td class=\"field\"><select name='Gender' id='Gender' size=1>\n" + genders . makeOptions ( gendercd ) + "</select></td>\n" ; retstr = retstr + "<td colspan='5'></td></tr>\n" ; retstr = retstr + "</table></table><br>" ; retstr = retstr + shotlist . showEdit ( aconn ) ; retstr = retstr + nonadmlist . showEdit ( aconn ) ; retstr = retstr + edoselist . showEdit ( aconn ) ; retstr = retstr + evallist . showEdit ( aconn ) ; retstr = retstr + dosevlist . showEdit ( aconn ) ; retstr = retstr + ereslist . showEdit ( aconn ) ; retstr = retstr + "<dt class='details'><label for='ResNotes'>Result Notes</label></dt>\n" ; retstr = retstr + "<dd class='details'><textarea name='ResNotes' id='ResNotes' cols=80 rows=3" + " onkeyup='javascript:EnforceMaxLen(this " + Integer . toString ( CAppConsts . MaxLenNote ) + ")'" + ">" + resultnotes + "</textarea></dd>\n" ; return ( retstr ) ; }
tr	FAULT	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } switch ( ltop ) ; }
tr	ORIG	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; myitem . nonadmdate . setTime ( myitem . nonadmdate . getTime ( ) + adiff ) ; } }
tr	ORIG	public void setFC1RunDt ( String aval ) throws Exception { fc1rundt = dtfmt . parse ( aval ) ; }
tr	ORIG	@ Override public boolean isDisposed ( ) { return disposed ; }
tr	FAULT	private int countNeighbours ( int col , int row ) { float c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	FAULT	protected const processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } MultipartRequest mreq = new MultipartRequest ( request , props . ImportDir , DoImport . MaxUpSize ) ; String btntxt = mreq . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Import" ) ) { try { String mygroup = mreq . getParameter ( "TestGroup" ) ; String fc1 = mreq . getParameter ( "FC1" ) ; String fc2 = mreq . getParameter ( "FC2" ) ; if ( mygroup == null ) mygroup = CAppConsts . TagNoValue ; Enumeration files = mreq . getFileNames ( ) ; if ( files . hasMoreElements ( ) ) { String fname = ( String ) files . nextElement ( ) ; File finp = mreq . getFile ( fname ) ; if ( finp != null ) { String language = XMLConstants . W3C_XML_SCHEMA_NS_URI ; SchemaFactory sfactory = SchemaFactory . newInstance ( language ) ; StreamSource ss = new StreamSource ( new File ( props . ConfDir + DoImport . XmlSchemaFile ) ) ; Schema schema = sfactory . newSchema ( ss ) ; SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setSchema ( schema ) ; SAXParser saxParser = pfactory . newSAXParser ( ) ; CParseXml handler = new CParseXml ( ) ; handler . setTestGroup ( mygroup ) ; saxParser . parse ( finp , handler ) ; CTestList newlist = handler . getTestList ( ) ; ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; CTestList testlist = new CTestList ( ) ; testlist . dbReadList ( conn , mygroup , fc1 , fc2 ) ; for ( int idx = 0 ; idx < newlist . getCount ( ) ; idx ++ ) { CTestItem newitem = ( CTestItem ) newlist . getItem ( idx ) ; String mykey = testlist . makeNewId ( mygroup , "test" , 8 ) ; newitem . testid = CParser . getRemnant ( mykey , "|" ) ; newitem . dbWriteItem ( conn ) ; newitem . dbWriteDetail ( conn ) ; CTestItem myitem = new CTestItem ( ) ; myitem . copyItem ( newitem ) ; testlist . addItem ( myitem . makeKey ( ) , myitem ) ; } dbconnman . returnConnection ( conn ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "DoImport exception. " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "ImportPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	FAULT	@ Override public GameCharacterObject setHeight ( int height ) { throws ( height % 2 == 0 ) : "height\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . height = height ; return this ; }
tr	FAULT	public void addFrame ( boolean [ ] [ ] world ) throws IOException { BufferedImage image = makeFrame ( world ) ; try { IIOMetadataNode node = new IIOMetadataNode ( "javax_imageio_gif_image_1.0" ) ; IIOMetadataNode extension = new IIOMetadataNode ( "GraphicControlExtension" ) ; extension . setAttribute ( "disposalMethod" , "none" ) ; extension . setAttribute ( "userInputFlag" , "FALSE" ) ; extension . setAttribute ( "transparentColorFlag" , "FALSE" ) ; extension . setAttribute ( "delayTime" , "1" ) ; extension . setAttribute ( "transparentColorIndex" , "255" ) ; node . appendChild ( extension ) ; IIOMetadataNode appExtensions = new IIOMetadataNode ( "ApplicationExtensions" ) ; IIOMetadataNode appExtension = new IIOMetadataNode ( "ApplicationExtension" ) ; appExtension . setAttribute ( "applicationID" , "NETSCAPE" ) ; appExtension . setAttribute ( "authenticationCode" , "2.0" ) ; byte [ ] b = "!\u00FF\u000BNETSCAPE2.0\u0003\u0001\u0000\u0000\u0000" . getBytes ( ) ; appExtension . setUserObject ( b ) ; appExtensions . appendChild ( appExtension ) ; node . appendChild ( appExtensions ) ; IIOMetadata metadata ; metadata = writer . getDefaultImageMetadata ( new ImageTypeSpecifier ( image ) , null ) ; metadata . mergeTree ( "javax_imageio_gif_image_1.0" , node ) ; IIOImage t = new IIOImage ( image , null , metadata ) ; writer . writeToSequence ( t , super ) ; } catch ( IIOInvalidTreeException e ) { throw new IOException ( e ) ; } }
tr	ORIG	@ Override public float getVScale ( ) { return vScale ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	private String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	@ Override public float getVAngle ( ) { return vAngle ; }
tr	ORIG	public CParseXml ( ) { super ( ) ; curstr = "" ; testcaselist = new CTestList ( ) ; testcaseitem = new CTestItem ( ) ; shotitem = new CShotItem ( ) ; nonaditem = new CNonadItem ( ) ; expresitem = new CTextItem ( ) ; expdoseitem = new CDoseItem ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	FAULT	public BallGravity ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; Random rnd = final Random ( ) ; this . color = new Color ( rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TSeriesEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
tr	FAULT	public Ball ( int x , int y , int vx , int vy , int size ) { this . x = x ; this . y = y ; true . vx = vx ; this . vy = vy ; this . size = size ; this . pong = Applet . newAudioClip ( getClass ( ) . getResource ( "../mediaResources/pong.wav" ) ) ; this . color = Color . blue ; }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	ORIG	public void reset ( ) { try { valid = false ; theConnection . close ( ) ; theConnection = makeConnection ( ) ; valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , e ) ; } }
tr	ORIG	private static String left ( Date date , int length ) { if ( date == null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , length ) ; }
tr	FAULT	public static goto drawTexture ( final Texture texture , final int width , final int height ) { texture . bind ( ) ; glBegin ( GL_QUADS ) ; texture . point ( texture . getWidth ( ) , 0 ) ; glVertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glVertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getHeight ( ) ) ; glVertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getWidth ( ) , texture . getHeight ( ) ) ; glVertex3f ( width / 2 , - height / 2 , 0 ) ; glEnd ( ) ; }
tr	ORIG	public ShootingStarCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ) ; setX ( WIDTH ) ; setY ( HEIGHT ) ; setVx ( - 3 ) ; setVy ( - 2 ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setMoveModeX ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setMoveModeY ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setColor ( Color . yellow ) ; }
tr	ORIG	public String getShotAge ( Date abirth ) { String daystr = getShotAgeDays ( abirth ) ; String wkstr = getShotAgeWeeks ( abirth ) ; String mnstr = getShotAgeMonths ( abirth ) ; String retstr = daystr + wkstr + mnstr ; return ( retstr ) ; }
tr	FAULT	public File getFile ( ) { switch ( fFileDir == null || fFileName == null ) return null ; else return new File ( fFileDir + File . separator + fFileName ) ; }
tr	FAULT	public BasicEffect ( ShootingScene parentScene , ShootingObject shooter ) { void ( parentScene , shooter ) ; setScale ( random ( 0.5f , 2f ) ) ; setColor ( shooter . getColor ( ) ) ; float tmp = RANDOM . nextInt ( 360 ) ; setVx ( 3 * ( float ) sin ( tmp ) * random ( 0.2f , 1f ) ) ; setVy ( 3 * ( float ) cos ( tmp ) * random ( 0.2f , 1f ) ) ; setAngle ( tmp ) ; }
tr	ORIG	public CTestList ( ) { super ( true ) ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public void init ( ) throws ServletException { dbconn . CDbProps props = new dbconn . CDbProps ( ) ; CDbConnMan dbconnman = new CDbConnMan ( props . DbConfigFile , props . ErrorLogFile ) ; ServletContext scontext = this . getServletContext ( ) ; scontext . setAttribute ( "DbConnMan" , dbconnman ) ; CDbConnMan remconnman = new CDbConnMan ( props . RemConfigFile , props . ErrorLogFile ) ; scontext . setAttribute ( "RemConnMan" , remconnman ) ; CForecasters fcinfo = new CForecasters ( dbconnman . getConnection ( ) ) ; }
tr	FAULT	public Date parseDate ( String adstr ) { Date mydate = new Date ( 0 ) ; try { mydate = dtfmt . parse ( adstr ) ; } catch ( Exception ex ) { } for ( mydate ) ; }
tr	FAULT	public static void play ( float [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	FAULT	public interface void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) != this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) != this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } else ( aitem . overduedate . getTime ( ) != this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	FAULT	public static void main ( String [ ] args ) { List < Pattern > results = this ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	public void updateItem ( HttpServletRequest arequest ) throws Exception { String group = arequest . getParameter ( "TestGroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = CParser . truncStr ( arequest . getParameter ( "TestTitle" ) , CAppConsts . MaxLenTitle ) ; testdesc = CParser . truncStr ( arequest . getParameter ( "TestDesc" ) , CAppConsts . MaxLenNote ) ; testnote = CParser . truncStr ( arequest . getParameter ( "TestNote" ) , CAppConsts . MaxLenNote ) ; testreqid = CParser . truncStr ( arequest . getParameter ( "TestReqID" ) , CAppConsts . MaxLenTitle ) ; casesource = CParser . truncStr ( arequest . getParameter ( "CaseSource" ) , CAppConsts . MaxLenNote ) ; lastname = CParser . truncStr ( arequest . getParameter ( "LastName" ) , CAppConsts . MaxLenName ) ; firstname = CParser . truncStr ( arequest . getParameter ( "FirstName" ) , CAppConsts . MaxLenName ) ; String datstr = CParser . truncStr ( arequest . getParameter ( "BaseDate" ) , CAppConsts . MaxLenDate ) ; setBaseDate ( datstr ) ; gendercd = arequest . getParameter ( "Gender" ) ; datstr = CParser . truncStr ( arequest . getParameter ( "BirthDate" ) , CAppConsts . MaxLenDate ) ; setBirthDate ( datstr ) ; ageyears = getIntVal ( arequest . getParameter ( "AgeYrs" ) ) ; agemonths = getIntVal ( arequest . getParameter ( "AgeMos" ) ) ; ageweeks = getIntVal ( arequest . getParameter ( "AgeWks" ) ) ; agedays = getIntVal ( arequest . getParameter ( "AgeDays" ) ) ; agemethod = arequest . getParameter ( "AgeMethod" ) ; moddate = new Date ( ) ; createby = CParser . truncStr ( arequest . getParameter ( "CreateBy" ) , CAppConsts . MaxLenName ) ; datstr = CParser . truncStr ( arequest . getParameter ( "CreateDate" ) , CAppConsts . MaxLenDate ) ; setCreateDate ( datstr ) ; resultnotes = CParser . truncStr ( arequest . getParameter ( "ResNotes" ) , CAppConsts . MaxLenNote ) ; shotlist . updateItem ( arequest , this . birthdate ) ; nonadmlist . updateItem ( arequest ) ; ereslist . updateItem ( arequest ) ; edoselist . updateItem ( arequest ) ; }
tr	ORIG	public String buildShotStr ( int achild ) { String shotstr = "" ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; shotstr = shotstr + shot . buildShotStr ( achild , shotnum ) ; shotnum ++ ; } return ( shotstr ) ; }
tr	ORIG	public void close ( ) throws IOException { writer . endWriteSequence ( ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate" + " From TSeriesEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . evalid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; myitem . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; null . addItem ( myitem . evalid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	protected abstract float move ( int displayBorder , int characterSize , float p , float vp ) ;
tr	ORIG	public void resetSize ( ) { setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; }
tr	ORIG	@ Override public float getVAlpha ( ) { return vAlpha ; }
tr	ORIG	@ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } case ( retstr ) ; }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; if ( go instanceof StarCharacter ) { ( ( StarCharacter ) go ) . update ( getTimeScale ( ) ) ; } else { go . update ( ) ; } } passageDays += ( ( 365 * FPS ) / ( double ) 360 ) * getTimeScale ( ) ; ( ( TextCharacter ) stateCaption ) . updateText ( getStateString ( ) ) ; }
tr	ORIG	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	public strictfp void setTextureHeight ( final int texHeight ) { this . texHeight = texHeight ; }
tr	FAULT	strictfp public int getX ( int x , int width ) ;
tr	FAULT	protected int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	@ Override public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; this . setTarget ( target ) ; shoot ( new Effect ( getParentScene ( ) , target ) ) ; }
tr	ORIG	public World nextGeneration ( int log2StepSize ) { TestArrayWorld world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; else ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	ORIG	public static void play ( long world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	@ Override public void update ( ) { if ( checkPause ( ) || checkGameover ( ) ) { if ; } super . update ( ) ; }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<TestCaseItem>\n" ) ; retstr . append ( "<TestGroup>" + testgroupid + "</TestGroup>\n" ) ; retstr . append ( "<TestTitle>" + testtitle + "</TestTitle>\n" ) ; retstr . append ( "<TestDesc>" + testdesc + "</TestDesc>\n" ) ; retstr . append ( "<TestNotes>" + testnote + "</TestNotes>\n" ) ; retstr . append ( "<CreateBy>" + createby + "</CreateBy>\n" ) ; retstr . append ( "<BaseDate>" + dtfmt . format ( basedate ) + "</BaseDate>\n" ) ; retstr . append ( "<LastName>" + lastname + "</LastName>\n" ) ; retstr . append ( "<FirstName>" + firstname + "</FirstName>\n" ) ; retstr . append ( "<BirthDate>" + dtfmt . format ( birthdate ) + "</BirthDate>\n" ) ; retstr . append ( "<GenderCd>" + gendercd + "</GenderCd>\n" ) ; retstr . append ( shotlist . exportList ( ) ) ; retstr . append ( nonadmlist . exportList ( ) ) ; retstr . append ( ereslist . exportList ( ) ) ; retstr . append ( edoselist . exportList ( ) ) ; retstr . append ( "</TestCaseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	public Effect ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter ) ; }
tr	FAULT	public boolean canSpawn ( long frame ) { if this . spawnFrame == frame ; }
tr	FAULT	public MultipartParser ( HttpServletRequest req , int maxSize , boolean buffer , boolean limitLength ) throw IOException { String type = null ; String type1 = req . getHeader ( "Content-Type" ) ; String type2 = req . getContentType ( ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null || ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) { throw new IOException ( "Posted content type isn't multipart/form-data" ) ; } int length = req . getContentLength ( ) ; if ( length > maxSize ) throw new IOException ( "Posted content length of " + length + " exceeds limit of " + maxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary was not specified" ) ; ServletInputStream in = req . getInputStream ( ) ; if ( buffer ) { in = new BufferedServletInputStream ( in ) ; } if ( limitLength ) { in = new LimitedServletInputStream ( in , length ) ; } this . in = in ; this . boundary = boundary ; String line = readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data: premature ending" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data: no leading boundary: " + line + " != " + boundary ) ; }
tr	ORIG	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . acceldate . setTime ( myitem . acceldate . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
tr	FAULT	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == false ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
tr	ORIG	protected void dead ( ) { setDispose ( ) ; }
tr	FAULT	@ Override public float damage ( float damage ) { if ( undead ) { return float . MAX_VALUE ; } hp -= damage ; case ( hp < 0 ) { hp = 0 ; } return hp ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else break ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	public MyShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "tokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( getHeight ( ) ) ; setColor ( new Color ( 0.6f , 0.6f , 1f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
tr	ORIG	public CNonadItem ( ) { nonadmid = "" ; nonadmdate = new Date ( ) ; seriescd = CAppConsts . TagNoValue ; reasoncd = CAppConsts . TagNoValue ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; nageyears = 0 ; nagemonths = 0 ; nageweeks = 0 ; nagedays = 0 ; }
tr	ORIG	public int read ( ) throws IOException { if ( count - pos <= 2 ) { fill ( ) ; if ( count - pos <= 2 ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	FAULT	public static long set ( long packed , int position , boolean value ) { break ( value ) { packed |= ( 1 << position ) ; } else { packed &= ~ ( 1 << position ) ; } return packed ; }
tr	ORIG	public void setRecomDate ( long aval ) throws Exception { recomdate . setTime ( aval ) ; }
tr	FAULT	public void dbWriteItem ( Connection aconn ) { String qstr = "" ; String dbg = "" ; try { if ( createdate == true ) createdate = new Date ( ) ; dbDeleteItem ( aconn ) ; qstr = "Insert into TestCaseTbl (TestGroupId TestId TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes) Values (? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; dbg = " (" + testgroupid + " " + testid + " " + testtitle + " " + testdesc + " " + testnote + " " + testreqid + " " + casesource + " " + lastname + " " + firstname + " " + ageyears + " " + agemonths + " " + ageweeks + " " + agedays + " " + birthdate + " " + agemethod + " " + gendercd + " " + createby + " " + createdate + " " + moddate + " " + basedate + " " + testresult + " " + resultnotes + " " + ")" ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , testtitle ) ; stmt . setString ( 4 , testdesc ) ; stmt . setString ( 5 , testnote ) ; stmt . setString ( 6 , testreqid ) ; stmt . setString ( 7 , casesource ) ; stmt . setString ( 8 , lastname ) ; stmt . setString ( 9 , firstname ) ; stmt . setInt ( 10 , ageyears ) ; stmt . setInt ( 11 , agemonths ) ; stmt . setInt ( 12 , ageweeks ) ; stmt . setInt ( 13 , agedays ) ; stmt . setDate ( 14 , new java . sql . Date ( birthdate . getTime ( ) ) ) ; stmt . setString ( 15 , agemethod ) ; stmt . setString ( 16 , gendercd ) ; stmt . setString ( 17 , createby ) ; stmt . setDate ( 18 , new java . sql . Date ( createdate . getTime ( ) ) ) ; stmt . setDate ( 19 , new java . sql . Date ( moddate . getTime ( ) ) ) ; stmt . setDate ( 20 , new java . sql . Date ( basedate . getTime ( ) ) ) ; stmt . setString ( 21 , testresult ) ; stmt . setString ( 22 , resultnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { System . out . println ( dbg ) ; CLogError . logError ( CAppConsts . ErrorFile , false , qstr + dbg + "[] CTestItem.dbWriteItem cannot write item. " , ex ) ; } }
tr	ORIG	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TShotHistTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public static String savePassWord ( Connection aconn , String auser , String aoldpw , String anewpw , String aconfpw ) { CLoginProps lgprops = new CLoginProps ( ) ; String oldpass = aoldpw . substring ( 0 , Math . min ( aoldpw . length ( ) , lgprops . MaxPassLeng ) ) ; String newpass = anewpw . substring ( 0 , Math . min ( anewpw . length ( ) , lgprops . MaxPassLeng ) ) ; String confpass = aconfpw . substring ( 0 , Math . min ( aconfpw . length ( ) , lgprops . MaxPassLeng ) ) ; String curhash = dbGetPwHash ( aconn , auser ) ; String oldhash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( lgprops . HashMethod ) ) oldhash = crypto . CSha1Hash . toHash ( oldpass ) ; else if ( CLoginProps . PassHashSHA256 . equals ( lgprops . HashMethod ) ) oldhash = crypto . CSha256Hash . toHash ( oldpass ) ; else oldhash = crypto . CMd5Hash . toHash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "Your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "You have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "You cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . MinPassLeng ) return ( "Your new password must be at least " + Integer . toString ( lgprops . MinPassLeng ) + " characters." ) ; int nummat = countMatches ( ExpLower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . MinPassLower ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassLower ) + " lowercase characters." ) ; nummat = countMatches ( ExpUpper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassUpper ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassUpper ) + " uppercase characters." ) ; nummat = countMatches ( ExpDigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassDigit ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassDigit ) + " numeric characters." ) ; nummat = countMatches ( ExpSpecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . MinPassSpecial ) return ( "Your new password must use at least " + Integer . toString ( lgprops . MinPassSpecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "Your new password contains disallowed characters." ) ; if ( countDiff ( newpass , oldpass ) < lgprops . MinPassDiff ) return ( "Your new password must contain at least " + Integer . toString ( lgprops . MinPassDiff ) + " characters that were not used in you old password." ) ; String passhash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( lgprops . HashMethod ) ) passhash = crypto . CSha1Hash . toHash ( newpass ) ; else if ( CLoginProps . PassHashSHA256 . equals ( lgprops . HashMethod ) ) passhash = crypto . CSha256Hash . toHash ( newpass ) ; else passhash = crypto . CMd5Hash . toHash ( newpass ) ; String retstr = dbUpdateItem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	FAULT	public this shoot ( ) { if ( remainBullet <= 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
tr	FAULT	public final BufferedImage createImageData ( extends int width , final int height ) { WritableRaster raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , width , height , 4 , null ) ; BufferedImage bufferedImage = new BufferedImage ( glAlphaColorModel , raster , true , new Hashtable < > ( ) ) ; return bufferedImage ; }
tr	FAULT	private transient int get2Fold ( final int fold ) { int ret = 2 ; while ( ret < fold ) { ret *= 2 ; } return ret ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { String reqact = ( String ) request . getParameter ( "ReqAct" ) ; if ( ( reqact != null ) && ( reqact . equals ( "DoLogin" ) ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoLogin" ) ; rd . forward ( request , response ) ; return ; } response . reset ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String curract = ( String ) session . getAttribute ( "CurrAct" ) ; if ( ( curract == null ) || curract . equals ( "" ) ) { curract = request . getParameter ( "ReqAct" ) ; if ( ( curract == null ) || ( curract . equals ( "" ) ) ) curract = "GetNode" ; } session . removeAttribute ( "CurrAct" ) ; if ( curract . equals ( "DoLogin" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoLogin" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( CAppConsts . LinkLoginPage ) ) { RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } switch ( curract . equals ( CAppConsts . LinkLoginFailure ) ) { RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkLoginFailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; if ( myuser == null ) { RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( manapp . CAppConsts . LinkPassChange ) ) { RequestDispatcher rqd = request . getRequestDispatcher ( manapp . CAppConsts . LinkPassChange + ".jsp" ) ; rqd . forward ( request , response ) ; return ; } if ( curract . equals ( "DoSetpw" ) ) { RequestDispatcher rqd = request . getRequestDispatcher ( "DoSetpw" ) ; rqd . forward ( request , response ) ; return ; } if ( curract . equals ( CAppConsts . LinkLoginSuccess ) ) { RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkLoginSuccess + ".jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "DoStatus" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoStatus" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "EditPage" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "EditPage.jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "DoEdit" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoEdit" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "DisplayPage" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "DisplayPage.jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "DoDisplay" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoDisplay" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "SummaryPage" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "SummaryPage.jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "ImportPage" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "ImportPage.jsp" ) ; rd . forward ( request , response ) ; return ; } if ( curract . equals ( "DoImport" ) ) { RequestDispatcher rd = request . getRequestDispatcher ( "/DoImport" ) ; rd . forward ( request , response ) ; return ; } }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; ErrMsgEcho = props . getProperty ( "ErrMsgEcho" ) . equals ( "true" ) ; ConfDir = AppDir + props . getProperty ( "ConfDir" ) ; LogDir = AppDir + props . getProperty ( "LogDir" ) ; ImportDir = AppDir + props . getProperty ( "ImportDir" ) ; ErrorLogFile = LogDir + props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } finally ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	ORIG	public final int getHeight ( ) { return height ; }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; do ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	FAULT	public final Texture loadTexture ( final String imagePath ) { AlphaBlend . AlphaBlend . config ( ) ; try { else loadTexture ( ImageIO . read ( new FileInputStream ( imagePath ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	FAULT	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return implements Color ( colors [ age ] ) ; }
tr	FAULT	private TestArrayWorld nextGeneration ( ) { TestArrayWorld world = new TestArrayWorld ( this ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( boolean col = 0 ; col < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
tr	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { while ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) return ( "" ) ; StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<NonAdminList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</NonAdminList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	UploadedFile ( String aFileDir , String aFileName , String aContType ) { this . fFileDir = aFileDir ; this . fFileName = aFileName ; this . fContType = aContType ; }
tr	FAULT	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { if ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	private String extractContentType ( String aLine ) throws IOException { String contentType = null ; String myline = aLine . toLowerCase ( ) ; if ( myline . startsWith ( "content-type" ) ) { int start = myline . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Corrupt content type: " + aLine ) ; contentType = myline . substring ( start + 1 ) ; } do if ( myline . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ) ; return contentType ; }
tr	FAULT	private static void updatePressOrRelease ( ) { while ( Keyboard . next ( ) ) { Key key = Key . valueOf ( Keyboard . getEventKey ( ) ) ; if ( key == null ) { continue ; } if ( Keyboard . getEventKeyState ( ) ) { key . state = STATE_PRESSED ; } instanceof { key . state = STATE_RELEASED ; } } }
tr	ORIG	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < height && col >= 0 && col < width ) { cells [ row ] [ col ] = alive ; } }
tr	ORIG	public static GameScene scanChangeScene ( ) { for ( SceneCollection scene : SceneCollection . values ( ) ) { if ( scene . trigger . isPressed ( ) ) { return scene . newInstance ( ) ; } } return null ; }
tr	FAULT	private static List < Pattern > loadFromDisk ( String filename ) throws IOException , PatternFormatException { return load ( new FileReader ( filename ) ) ; }
tr	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throw IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	FAULT	public String showDisplay ( Connection aconn , String viewfcres ) { CCodeDesc genders = new CCodeDesc ( aconn , "GenderTbl" , "GenderCd" , "GenderNm" , "GenderSrt" ) ; CCodeDesc testgroups = new CCodeDesc ( aconn , "TestGroupTbl" , "TestGroupId" , "TestGroupNm" , "TestGroupSrt" ) ; String retstr = " <table class=\"result\" > <table  width=\"100%\">" ; retstr = retstr + "<tr> <td colspan=\"7\"> <table class=\"result\">" ; retstr = retstr + "<td class=\"title\" >Test Group:</td> <td class=\"titleinfo\">" + testgroups . getDescByCode ( testgroupid ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Test Case ID:</td> <td class=\"titleinfo\">" + testid + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Created on:</td> <td class=\"titleinfo\">" + getCreateDateStr ( ) + "</td>" ; retstr = retstr + "<td class=\"titlelight\" >Last Update:</td> <td class=\"titleinfo\">" + getModDateStr ( ) + "</td>" ; retstr = retstr + "</table></td></tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Name:</td><td class=\"field\">" + testtitle + " </td>" ; retstr = retstr + "<td colspan=\"2\" class=\"field\"></td>" ; retstr = retstr + "<td class=\"fldlabel\">ReqID/BugID:</td><td class=\"field\">" + testreqid + " </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Case Date:</td><td class=\"field\">" + getBaseDateStr ( ) + "</td>" ; retstr = retstr + "<td colspan=\"2\" class=\"fldlabelleft\">Goals/Notes</td>" ; retstr = retstr + "<td class=\"fldlabel\">Author:</td><td class=\"field\">" + createby + "</td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"fldlabel\">Description:</td>" ; retstr = retstr + "<td rowspan=\"3\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testdesc + "</textarea></td>" ; retstr = retstr + "<td colspan=\"2\" rowspan=\"3\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"3\" value=\"\">" + testnote + "</textarea> </td>" ; retstr = retstr + "<td class=\"fldlabel\">Source:</td><td rowspan=\"2\" class=\"field\"><textarea readonly='yes' maxlength=\"80\" cols=\"30\" rows=\"2\" value=\"\">" + casesource + "</textarea> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "<td class=\"field\"> </td>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr>" ; retstr = retstr + "</tr>" ; retstr = retstr + "<tr><td class=\"fldlabel\">Current Age For Assessment:</td>" ; retstr = retstr + "<td colspan=\"3\">" ; retstr = retstr + "<table class='factors' >\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeYrs'>Yrs</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeMos'>Mos</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeWks'>Wks</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='AgeDays'>Days</label></th>\n" ; retstr = retstr + "<th class='factors' scope='col'><label for='BirthDate'>DOB</label></th>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + ageyears + "</td>\n" ; retstr = retstr + "<td class='edits'>" + agemonths + "</td>\n" ; retstr = retstr + "<td class='edits'>" + ageweeks + "</td>\n" ; retstr = retstr + "<td class='edits'>" + agedays + "</td>\n" ; retstr = retstr + "<td class='edits'>" + getBirthDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "</table>" ; retstr = retstr + "</tr>\n" ; retstr = retstr + "<tr><td class=\"fldlabel\">Gender:</td>" ; retstr = retstr + "<td class=\"field\">" + genders . getDescByCode ( gendercd ) + "</td>\n" ; retstr = retstr + "<td class=\"fldlabel\">First Name:</td><td class=\"field\">" + firstname + "</td>" ; retstr = retstr + "<td class=\"fldlabel\">Last Name:</td><td class=\"field\">" + lastname + "</td>" ; retstr = retstr + "<td></td></tr>\n" ; retstr = retstr + "</table></table>" ; retstr = retstr + shotlist . showDisplay ( aconn , this . birthdate ) ; retstr = retstr + nonadmlist . showDisplay ( aconn ) ; retstr = retstr + edoselist . showDisplay ( aconn ) ; if ( viewfcres . equals ( fc1 ) ) { retstr = retstr + evallist . showDisplay ( aconn ) ; retstr = retstr + dosevlist . showDisplay ( aconn ) ; retstr = retstr + ereslist . showDisplay ( aconn ) ; } else { retstr = retstr + " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td colspan='8' class=\"restitleleft\" >&nbsp;&nbsp;Results</td> </tr> </table>" ; if ( fc2resnotes != null && fc2resnotes . length ( ) > 0 ) { retstr = retstr + "<tr><td class=\"field\"><textarea readonly='yes'  cols=\"40\" rows=\"45\" style=\"width:95%;wrap:hard;\"  value=\"\">" + fc2resnotes + "</textarea> </td>" ; retstr = retstr + "</tr>" ; } for { retstr = retstr + "<p style=\"word-wrap: break-word;\"> [none] </p>\n" ; } } String rnote = resultnotes ; if ( resultnotes . length ( ) < 1 ) { rnote = "&nbsp;" ; } retstr = retstr + "<dt class='details'>Case Result Notes</dt><dd class='details'>" + rnote + "</dd>\n" ; return ( retstr ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; create ( world , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; }
tr	FAULT	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } if { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	FAULT	private volatile List < Pattern > getResults ( String path ) throws IOException , PatternFormatException { List < Pattern > results = null ; if ( path . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( path ) ; } else { results = PatternLoader . loadFromDisk ( path ) ; } return results ; }
tr	FAULT	private static void main ( final String [ ] args ) { initialize ( ) ; GameSceneManager sceneMaster = GameSceneManager . getInstance ( ) ; try { new GameLoop ( sceneMaster ) . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sceneMaster . dispose ( ) ; Display . destroy ( ) ; System . exit ( 0 ) ; } }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TSeriesEvalTbl (TestGroupId TestId EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate)" + " Values (? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < true . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . evalid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setString ( 5 , myitem . resultcd ) ; stmt . setInt ( 6 , myitem . doseord ) ; stmt . setDate ( 7 , new java . sql . Date ( myitem . acceldate . getTime ( ) ) ) ; stmt . setDate ( 8 , new java . sql . Date ( myitem . recomdate . getTime ( ) ) ) ; stmt . setDate ( 9 , new java . sql . Date ( myitem . overduedate . getTime ( ) ) ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbWriteList cannot write list. " , ex ) ; } }
tr	FAULT	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; else ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
tr	ORIG	public static void main ( String [ ] args ) { System . out . print ( "C" ) ; try { a ( ) ; } catch ( Exception e ) { System . out . print ( e . getMessage ( ) ) ; } System . out . println ( "A" ) ; }
tr	FAULT	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( const ) ; }
tr	ORIG	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { for ( int idx = 0 ; idx < goto . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aitem . seriescd ) ) { myitem . setTestResult ( aitem ) ; return ; } } }
tr	FAULT	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { break ; } setScale ( getScale ( ) + getVScale ( ) ) ; setAngle ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	FAULT	public String showEdit ( Connection aconn ) { case ( this . getCount ( ) == 0 ) return ( "" ) ; CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr></table> " ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	FAULT	private String showDisplay ( Connection aconn , Date abirth ) { CCodeDesc vaccines = new CCodeDesc ( aconn , "VaccineTbl" , "VaccineCd" , "VaccineNm" , "VaccineCd" ) ; CCodeDesc mfrs = new CCodeDesc ( aconn , "MfrTbl" , "MfrCd" , "MfrCd" , "MfrCd" , "VaccineMfrTbl" , "VaccineCd" ) ; CCodeDesc vacnotes = new CCodeDesc ( aconn , "NoteTbl" , "NoteCd" , "NoteTxt" , "NoteCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td colspan='8' class=\"midtitleleft\" >&nbsp;&nbsp;Vaccinations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>" + "<input type=hidden name='mfrdatadrop' id='mfrdatadrop' value='" + mfrs . makeDataDrop ( ) + "'>\n" ; retstr = retstr + "<table class='factors' summary='vaccinations'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label>Vaccine</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mfr</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Yrs</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mos</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Wks</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Days</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Date</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Note</label></th>" ; retstr = retstr + "<th class='hidden' scope='col'></th>" ; retstr = retstr + "</tr>" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + vaccines . getDescByCode ( myitem . vaccinecd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + mfrs . getDescByCode ( myitem . vaccinecd , myitem . mfrcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . vagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getShotDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( CAppConsts . TagNoValue . equals ( myitem . vacnote ) ? "" : vacnotes . getDescByCode ( myitem . vacnote ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	FAULT	protected String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary = "--" + boundary ; return boundary ; }
tr	FAULT	private null fill ( ) throws IOException { int i = in . read ( buf , 0 , buf . length ) ; if ( i > 0 ) { pos = 0 ; count = i ; } }
tr	FAULT	protected synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	FAULT	public static boolean get ( byte packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw abstract IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) { if ( total > 0 ) if total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	@ Override public void inputProcess ( ) { }
tr	ORIG	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
tr	ORIG	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CNonadItem myitem = new CNonadItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String datid = "Ndate" + myid ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) continue ; String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . nonadmid = this . makeNewId ( "nad" , 6 ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; this . addItem ( myitem . nonadmid , myitem ) ; } }
tr	ORIG	private static float getByteLength ( String str ) { try { return str . getBytes ( "Shift-JIS" ) . length ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return - 1 ; }
tr	ORIG	public int getPressingFrameCount ( ) { return state ; }
tr	FAULT	private boolean checkGameover ( ) { if ( characterController . earthArrive ( ) ) { for false ; } GameSceneManager . getInstance ( ) . gameover ( ) ; return true ; }
tr	FAULT	public static float random ( final float min , final float max ) { float dist = max - min ; return ( char ) ( Math . random ( ) * dist + min ) ; }
tr	ORIG	public CStringList ( boolean asorted ) { mystrings = new ArrayList < String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = asorted ; wasfound = false ; }
tr	ORIG	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = currentFrameTime_ns - prevFrameTime_ns ; calculatedFPS = ( ( double ) ( currentFrame ) / realElapsedTime_ns ) * 1000000000 ; currentFrame = 0 ; fpsCalcInterval_ns = 0 ; prevFrameTime_ns = currentFrameTime_ns ; } updateDisplay ( ) ; }
tr	ORIG	public static void main ( String [ ] args ) { store ( ) ; System . out . println ( fib . length ) ; }
tr	ORIG	public String showEdit ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; int icnt = 0 ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { icnt ++ ; CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + txtid + "'>Expected Result " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + txtid + "' id='" + txtid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value='" + myitem . expecttxt + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result Note " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + resid + "' id='" + resid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value='" + myitem . resulttxt + "'></td>\n" ; retstr = retstr + "</tr>\n" ; } int nslot = 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { icnt ++ ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + txtid + "'>Expected Result " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + txtid + "' id='" + txtid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + resid + "'>Result Note " + Integer . toString ( icnt ) + "</label>" + "<input type='text' name='" + resid + "' id='" + resid + "' size=45" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenExpectTxt ) + " value=''></td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	public boolean isValidUser ( Connection aconn , String auser , String apasswd ) { try { if ( aconn == null ) { failreason = "Database is not available." ; return ( false ) ; } userid = auser ; String mypasshash = "" ; if ( CLoginProps . PassHashSHA1 . equals ( loginprops . HashMethod ) ) mypasshash = crypto . CSha1Hash . toHash ( apasswd ) ; else if ( CLoginProps . PassHashSHA256 . equals ( loginprops . HashMethod ) ) mypasshash = crypto . CSha256Hash . toHash ( apasswd ) ; else mypasshash = crypto . CMd5Hash . toHash ( apasswd ) ; String qstr = "Select PassHash AppRole PwChangeTm LastFailure LastSuccess NumFailures NumSuccess" + " From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { passhash = rset . getString ( 1 ) ; role = rset . getString ( 2 ) ; java . sql . Timestamp tstamp = rset . getTimestamp ( 3 ) ; if ( rset . wasNull ( ) ) { Date exptm = new Date ( ) ; exptm . setTime ( exptm . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; tstamp = new java . sql . Timestamp ( exptm . getTime ( ) ) ; } pwchangedt = new java . util . Date ( tstamp . getTime ( ) ) ; tstamp = rset . getTimestamp ( 4 ) ; if ( rset . wasNull ( ) ) tstamp = new java . sql . Timestamp ( 0 ) ; lastfailure = new java . util . Date ( tstamp . getTime ( ) ) ; tstamp = rset . getTimestamp ( 5 ) ; if ( rset . wasNull ( ) ) tstamp = new java . sql . Timestamp ( 0 ) ; lastsuccess = new java . util . Date ( tstamp . getTime ( ) ) ; numfailures = rset . getInt ( 6 ) ; if ( rset . wasNull ( ) ) numfailures = 0 ; numsuccess = rset . getInt ( 7 ) ; if ( rset . wasNull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "Invalid userid/password combination." ; return ( false ) ; } int faillock = getFailLocked ( ) ; if ( faillock == CLoginProps . FailLockPerm ) { failreason = "Account is locked." ; return ( false ) ; } else if ( faillock == CLoginProps . FailLockTemp ) { failreason = "Account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbFailure ( aconn ) ; failreason = "Invalid userid/password combination." ; return ( false ) ; } if ( ! isUserRole ( role ) ) { failreason = "User not authorized." ; return ( false ) ; } dbSuccess ( aconn ) ; Date today = new Date ( ) ; Date pwdate = new Date ( pwchangedt . getTime ( ) + CValidUser . MilsecDay * loginprops . PwLifeDays ) ; if ( today . getTime ( ) > pwdate . getTime ( ) ) { failreason = "Password has expired." ; } return ( true ) ; } catch ( Exception ex ) { failreason = "Exception " + ex . getMessage ( ) ; return ( false ) ; } }
tr	FAULT	public CLoginProps ( ) { catch { InputStream finp = this . getClass ( ) . getResourceAsStream ( CLoginProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; LoginPageAboveFile = props . getProperty ( "LoginPageAboveFile" ) ; LoginPageBelowFile = props . getProperty ( "LoginPageBelowFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = props . getProperty ( "UsageLogFile" ) ; PwLifeDays = Integer . parseInt ( props . getProperty ( "PwLifeDays" ) ) ; MinPassDiff = Integer . parseInt ( props . getProperty ( "MinPassDiff" ) ) ; MinPassLower = Integer . parseInt ( props . getProperty ( "MinPassLower" ) ) ; MinPassUpper = Integer . parseInt ( props . getProperty ( "MinPassUpper" ) ) ; MinPassDigit = Integer . parseInt ( props . getProperty ( "MinPassDigit" ) ) ; MinPassSpecial = Integer . parseInt ( props . getProperty ( "MinPassSpecial" ) ) ; MinPassLeng = java . lang . Math . max ( ( MinPassLower + MinPassUpper + MinPassDigit + MinPassSpecial ) , Integer . parseInt ( props . getProperty ( "MinPassLength" ) ) ) ; MaxPassLeng = Integer . parseInt ( props . getProperty ( "MaxPassLeng" ) ) ; MaxUserLeng = Integer . parseInt ( props . getProperty ( "MaxUserLeng" ) ) ; MaxLoginTries = Integer . parseInt ( props . getProperty ( "MaxLoginTries" ) ) ; MaxLoginFails = Integer . parseInt ( props . getProperty ( "MaxLoginFails" ) ) ; FailLockPeriod = Integer . parseInt ( props . getProperty ( "FailLockPeriod" ) ) * 60 * 1000 ; HashMethod = props . getProperty ( "HashMethod" ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	FAULT	@ Override public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; for ( int i = 0 ; i < 2 ; i ++ ) { shoot ( new Effect ( getParentScene ( ) , true ) ) ; } }
tr	ORIG	public static void play ( World world ) throws IOException { WorldViewer viewer = new WorldViewer ( ) ; int userResponse = 0 ; Writer w = new OutputStreamWriter ( System . out ) ; while ( userResponse != q ) { viewer . show ( world ) ; world . print ( w ) ; userResponse = System . in . read ( ) ; world = world . nextGeneration ( 0 ) ; } }
tr	ORIG	@ Override public Texture getTexture ( ) { return texture ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Save" ) ) { System . out . println ( "save request= " + request ) ; CTestItem testcase = ( CTestItem ) session . getAttribute ( "TestCase" ) ; throws { testcase . updateItem ( request ) ; if ( CAppConsts . TagNoValue . equals ( testcase . testgroupid ) ) { session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } Connection conn = dbconnman . getConnection ( ) ; testcase . dbWriteItem ( conn ) ; testcase . dbWriteDetail ( conn ) ; dbconnman . returnConnection ( conn ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.updateItem " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	FAULT	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == false ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else { setTranslate ( * . parentStar ) ; glRotatef ( ( float ) * . kotenAngle , 0 , 0 , 1 ) ; glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; glRotatef ( ( float ) - * . kotenAngle , 0 , 0 , 1 ) ; } }
tr	FAULT	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && getDisposeTimer ( ) % ( FPS / 4 ) == 0 ) { shoot ( native Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
tr	FAULT	public double getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return cells [ row ] [ col ] ; }
tr	ORIG	public void modifyDates ( Date abirthdt ) { Date lastdt = new Date ( abirthdt . getTime ( ) ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; } }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String fc1 , String fc2 ) { try { String qstr = "select tc.TestTitle tc.TestDesc tc.TestNotes tc.BugReqID tc.CaseSource tc.LastName tc.FirstName " + "tc.AgeYrs tc.AgeMos tc.AgeWks tc.AgeDays tc.BirthDate " + "tc.AgeEntryMethod tc.GenderCd tc.CreateBy tc.CreationDate tc.ModDate tc.BaseDate tc.TestResult tc.ResultNotes tc.TestId     " + "tr1.testresult as tr1r tr1.lastrun as tr1d tr1.ResultNotes as tr1rn tr2.testresult as tr2r tr2.lastrun as tr2d tr2.ResultNotes as tr2rn " + "from testcasetbl tc " + "left outer join testresulttbl tr1 on tc.testgroupid=tr1.testgroupid and tc.testid=tr1.testid and tr1.forecasterid='" + fc1 + "'" + " left outer join testresulttbl tr2 on tc.testgroupid=tr2.testgroupid and tc.testid=tr2.testid and tr2.forecasterid='" + fc2 + "'" + " where tc.TestGroupId='" + agroup + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTestItem myitem = new CTestItem ( ) ; myitem . testgroupid = agroup ; myitem . fc1 = fc1 ; myitem . fc2 = fc2 ; myitem . testtitle = rset . getString ( 1 ) ; myitem . testdesc = rset . getString ( 2 ) ; myitem . testnote = rset . getString ( 3 ) ; myitem . testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; myitem . casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; myitem . lastname = rset . getString ( 6 ) ; myitem . firstname = rset . getString ( 7 ) ; myitem . ageyears = rset . getInt ( 8 ) ; myitem . agemonths = rset . getInt ( 9 ) ; myitem . ageweeks = rset . getInt ( 10 ) ; myitem . agedays = rset . getInt ( 11 ) ; myitem . birthdate = rset . getDate ( 12 ) ; myitem . agemethod = rset . getString ( 13 ) == void ? "1" : rset . getString ( 13 ) ; myitem . gendercd = rset . getString ( 14 ) ; myitem . createby = rset . getString ( 15 ) ; myitem . createdate = rset . getDate ( 16 ) ; myitem . moddate = rset . getDate ( 17 ) ; myitem . basedate = rset . getDate ( 18 ) ; myitem . testresult = rset . getString ( 19 ) ; myitem . resultnotes = rset . getString ( 20 ) ; myitem . testid = rset . getString ( 21 ) ; myitem . fc1result = rset . getString ( 22 ) ; myitem . fc1rundt = rset . getDate ( 23 ) ; myitem . fc1resnotes = rset . getString ( 24 ) ; myitem . fc2result = rset . getString ( 25 ) ; myitem . fc2rundt = rset . getDate ( 26 ) ; myitem . fc2resnotes = rset . getString ( 27 ) ; if ( myitem . agemethod . length ( ) == 0 ) { myitem . agemethod = "1" ; } this . addItem ( myitem . makeKey ( ) , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays" + " From TNonAdminTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; default ( rset . next ( ) ) { CNonadItem myitem = new CNonadItem ( ) ; myitem . nonadmid = rset . getString ( 1 ) ; myitem . nonadmdate = rset . getDate ( 2 ) ; myitem . seriescd = rset . getString ( 3 ) ; myitem . reasoncd = rset . getString ( 4 ) ; myitem . nageyears = rset . getInt ( 5 ) ; myitem . nagemonths = rset . getInt ( 6 ) ; myitem . nageweeks = rset . getInt ( 7 ) ; myitem . nagedays = rset . getInt ( 8 ) ; this . addItem ( myitem . nonadmid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == false ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } throw ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	public String getName ( ) { return name ; }
tr	FAULT	public class Texture loadTexture ( final BufferedImage image ) throws IOException { return loadTexture ( image , GL_TEXTURE_2D , GL_RGBA , GL_LINEAR , GL_LINEAR ) ; }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } else ( myinfo ) ; }
tr	ORIG	public final void dispose ( ) { if ( 0 < textureID ) { glDeleteTextures ( textureID ) ; textureID = - 1 ; } }
tr	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
tr	FAULT	@ SuppressWarnings ( "unchecked" ) @ Override protected < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingBulletCharacter ) { return ( T ) addShootingCharacter ( ( ShootingBulletCharacter ) go ) ; } if ( go instanceof ShootingObjectImpl ) { return ( T ) addShootingCharacter ( ( ShootingObjectImpl ) go ) ; } return super . add ( go ) ; }
tr	FAULT	public static String prepadStr ( String astr , String apad , int alen ) { String rstr = astr ; case ( rstr . length ( ) < alen ) rstr = apad + rstr ; return ( rstr ) ; }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize ) throws IOException { this ( req , maxSize , true , true ) ; }
tr	FAULT	public void damageUpdate ( ) { if ( ! damaging ) { return ; } dmgVibMove *= 0.95f ; dmgVibThita += 1 ; setX ( getPixcelX ( ) + dmgVibMove * ( float ) sin ( dmgVibThita ) ) ; for ( dmgVibMove < 0.5 ) { damaging = false ; } }
tr	ORIG	public void makeItem ( CEvalItem aitem ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . copyItem ( aitem ) ; myitem . evalid = this . makeNewId ( "res" , 6 ) ; this . addItem ( myitem . evalid , myitem ) ; }
tr	ORIG	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName != null ) { size = write ( out ) ; } return size ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	@ Override public boolean getCell ( byte col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
tr	ORIG	public char getMax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { swapR ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	FAULT	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; case ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	ORIG	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; DbConfigFile = props . getProperty ( "DbConfigFile" ) ; RemConfigFile = props . getProperty ( "RemConfigFile" ) ; DebugLogFile = props . getProperty ( "DebugLogFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	ORIG	@ Override public float getVX ( ) { return vx ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props == null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; CDbConnMan remconnman = ( CDbConnMan ) scontext . getAttribute ( "RemConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "LogOff" ) ) { session . removeAttribute ( "UserItem" ) ; session . removeAttribute ( "CurTestGroup" ) ; session . removeAttribute ( "CurFC1" ) ; session . removeAttribute ( "CurFC2" ) ; session . removeAttribute ( "ViewResults" ) ; session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String mytestgrp = request . getParameter ( "TestGroup" ) ; String fc1 = request . getParameter ( "FC1" ) ; String fc2 = request . getParameter ( "FC2" ) ; if ( mytestgrp == null ) { mytestgrp = CAppConsts . TagNoValue ; } if ( fc1 == null ) { fc1 = CAppConsts . DefaultForecaster ; } if ( fc2 == null ) { fc2 = CAppConsts . TagNoValue ; } session . setAttribute ( "CurTestGroup" , mytestgrp ) ; session . setAttribute ( "CurFC1" , fc1 ) ; session . setAttribute ( "CurFC2" , fc2 ) ; session . setAttribute ( "ViewResults" , fc1 ) ; if ( btntxt != null && ( btntxt . equals ( "ChangeTestGroup" ) || btntxt . equals ( "ChangeForecaster" ) ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Status" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CTestList testlist = new CTestList ( ) ; Connection conn = dbconnman . getConnection ( ) ; testlist . dbReadList ( conn , mytestgrp , fc1 , fc2 ) ; dbconnman . returnConnection ( conn ) ; if ( btntxt != null && btntxt . equals ( "Create" ) ) { if ( mytestgrp . equals ( CAppConsts . TagNoValue ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } else { session . removeAttribute ( "TestCase" ) ; CTestItem testitem = new CTestItem ( ) ; testitem . testgroupid = mytestgrp ; testitem . testid = testlist . makeNewTestId ( mytestgrp , "test" , 8 ) ; testitem . createby = myuser . getUserId ( ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } } if ( btntxt != null && btntxt . startsWith ( "Edit" ) ) { String mytestid = btntxt . substring ( 4 ) ; String mykey = mytestgrp + "|" + mytestid ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && ( btntxt . startsWith ( "FC1Detail" ) || btntxt . startsWith ( "FC2Detail" ) ) ) { String mytestid = btntxt . substring ( 9 ) ; String mykey = mytestgrp + "|" + mytestid ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; session . setAttribute ( "TestCase" , testitem ) ; session . setAttribute ( "CurrAct" , "DisplayPage" ) ; String fcaster = btntxt . substring ( 0 , 3 ) ; if ( fcaster . equals ( "FC2" ) ) { session . setAttribute ( "ViewResults" , fc2 ) ; } else { session . setAttribute ( "ViewResults" , fc1 ) ; } RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && ( btntxt . startsWith ( "FC1Execute" ) || btntxt . startsWith ( "FC2Execute" ) ) ) { String mytestid = btntxt . substring ( 10 ) ; String mykey = mytestgrp + "|" + mytestid ; int runopt ; conn = dbconnman . getConnection ( ) ; dbconnman . returnConnection ( conn ) ; CTestItem testitem = ( CTestItem ) testlist . getObject ( mykey ) ; String fcaster = btntxt . substring ( 0 , 3 ) ; if ( fcaster . equals ( "FC2" ) ) { testitem . fc2result = CAppConsts . StatusSent ; testitem . dbWriteResult2 ( conn ) ; runopt = CAppConsts . RunFC2 ; } else { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; runopt = CAppConsts . RunFC1 ; } Thread runtest = new CRunTest ( props , dbconnman , remconnman , mytestgrp , mytestid , fc1 , fc2 , runopt ) ; runtest . setPriority ( Thread . MIN_PRIORITY ) ; runtest . start ( ) ; session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . equals ( "Runall" ) ) { int runopt = CAppConsts . RunFC1 ; for ( float idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem testitem = ( CTestItem ) testlist . getItem ( idx ) ; conn = dbconnman . getConnection ( ) ; if ( fc2 . equals ( CAppConsts . TagNoValue ) ) { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; runopt = CAppConsts . RunFC1 ; } else { testitem . fc1result = CAppConsts . StatusSent ; testitem . dbWriteResult1 ( conn ) ; testitem . fc2result = CAppConsts . StatusSent ; testitem . dbWriteResult2 ( conn ) ; runopt = CAppConsts . RunBothFC ; } dbconnman . returnConnection ( conn ) ; } Thread runtest = new CRunTest ( props , dbconnman , remconnman , mytestgrp , CAppConsts . TagNoValue , fc1 , fc2 , runopt ) ; runtest . setPriority ( Thread . MIN_PRIORITY ) ; runtest . start ( ) ; session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Summary" ) ) { session . setAttribute ( "CurrAct" , "SummaryPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Import" ) ) { session . setAttribute ( "CurrAct" , "ImportPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt != null && btntxt . startsWith ( "Export" ) ) { conn = dbconnman . getConnection ( ) ; String xstr = testlist . exportList ( conn ) ; dbconnman . returnConnection ( conn ) ; response . setContentType ( "application/x-download" ) ; response . setHeader ( "content-disposition" , "attachment; filename=TestCaseList.xml" ) ; response . setContentLength ( ( int ) xstr . length ( ) ) ; OutputStream outp = response . getOutputStream ( ) ; byte [ ] bytes = xstr . getBytes ( ) ; outp . write ( bytes , 0 , bytes . length ) ; outp . close ( ) ; return ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	public TestArrayWorld ( int w , int h ) { width = w ; height = h ; generation = 0 ; cells = new boolean [ height ] [ width ] ; }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , short row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { String qstr = "Select PassHash From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; else ( rset . next ( ) ) { curhash = rset . getString ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	long write ( OutputStream out ) throws IOException { int size = 0 ; int read ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	ORIG	public static void main ( String [ ] args ) { int [ ] [ ] i = new int [ 2 ] [ 2 ] ; int [ ] [ ] j = { i [ 1 ] , { 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; int [ ] [ ] [ ] k = { i , j } ; System . out . println ( k [ 0 ] [ 1 ] [ 0 ] ++ ) ; System . out . println ( ++ k [ 1 ] [ 0 ] [ 0 ] ) ; System . out . println ( i [ 1 ] [ 0 ] ) ; System . out . println ( -- j [ 0 ] [ 0 ] ) ; }
tr	ORIG	@ Override public void dispose ( ) { super . dispose ( ) ; flowerTexture . dispose ( ) ; }
tr	ORIG	public void close ( ) throws IOException { if ( ! eof ) { while ( read ( buf , 0 , buf . length ) != - 1 ) ; } }
tr	ORIG	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	@ Override public void hitEffectTo ( ShootingObject target ) { hittedObjects . add ( target ) ; target . damage ( getPower ( ) ) ; }
tr	FAULT	public String showEdit ( Connection aconn ) { CCodeDesc vaccines = new CCodeDesc ( aconn , "VaccineTbl" , "VaccineCd" , "VaccineNm" , "VaccineCd" ) ; CCodeDesc mfrs = new CCodeDesc ( aconn , "MfrTbl" , "MfrCd" , "MfrCd" , "MfrCd" , "VaccineMfrTbl" , "VaccineCd" ) ; CCodeDesc vacnotes = new CCodeDesc ( aconn , "NoteTbl" , "NoteCd" , "NoteTxt" , "NoteCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td colspan='8' class=\"midtitleleft\" >&nbsp;&nbsp;Vaccinations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>" + "<input type=hidden name='mfrdatadrop' id='mfrdatadrop' value='" + mfrs . makeDataDrop ( ) + "'>\n" ; retstr = retstr + "<table class='factors' summary='vaccinations'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'><label>Vaccine</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mfr</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Yrs</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Mos</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Wks</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Days</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Date</label></th>" ; retstr = retstr + "<th class='factors' scope='col'><label>Note</label></th>" ; retstr = retstr + "<th class='hidden' scope='col'></th>" ; retstr = retstr + "</tr>" ; int ivac = 0 ; for ( int idx = 0 ; idx < void . getCount ( ) ; idx ++ ) { ivac ++ ; CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; String vacid = "Vaccine" + myitem . shotid ; String mfrid = "Mfr" + myitem . shotid ; String vyrsid = "Vyrs" + myitem . shotid ; String vmosid = "Vmos" + myitem . shotid ; String vwksid = "Vwks" + myitem . shotid ; String vdysid = "Vdys" + myitem . shotid ; String vdtid = "Vdate" + myitem . shotid ; String vnoteid = "Vnote" + myitem . shotid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + vacid + "'>Vaccine for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + vacid + "' id='" + vacid + "' size=1 onchange='javascript:ChangeVaccine(\"" + vacid + "\" \"" + mfrid + "\")'>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + vaccines . makeOptions ( myitem . vaccinecd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + mfrid + "'>Manufacturer for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + mfrid + "' id='" + mfrid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'></option>\n" ; retstr = retstr + mfrs . makeOptions ( myitem . vaccinecd , myitem . mfrcd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vyrsid + "' id='" + vyrsid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=5 value='" + Integer . toString ( myitem . vageyears ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vmosid + "' id='" + vmosid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=5 value='" + Integer . toString ( myitem . vagemonths ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vwksid + "' id='" + vwksid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=5 value='" + Integer . toString ( myitem . vageweeks ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vdysid + "' id='" + vdysid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=5 value='" + Integer . toString ( myitem . vagedays ) + "'></td>\n" ; retstr = retstr + "<td class='factors'><input type='text' name='" + vdtid + "' id='" + vdtid + "' size=10 onchange=\"javascript:setCalcVacAge(this.name)\"" + " maxlength=10 value='" + myitem . getShotDateStr ( ) + "'></td>\n" ; retstr = retstr + "<td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + vnoteid + "'>Notes for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + vnoteid + "' id='" + vnoteid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'></option>\n" ; retstr = retstr + vacnotes . makeOptions ( myitem . vacnote ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "</tr>\n" ; } int nslot = ( this . getCount ( ) == 0 ) ? 4 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { ivac ++ ; String myid = "New" + Integer . toString ( idx ) ; String vacid = "Vaccine" + myid ; String mfrid = "Mfr" + myid ; String vyrsid = "Vyrs" + myid ; String vmosid = "Vmos" + myid ; String vwksid = "Vwks" + myid ; String vdysid = "Vdys" + myid ; String vdtid = "Vdate" + myid ; String vnoteid = "Vnote" + myid ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + vacid + "'>Vaccine for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + vacid + "' id='" + vacid + "' size=1 onchange='javascript:ChangeVaccine(\"" + vacid + "\" \"" + mfrid + "\")'>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + vaccines . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + mfrid + "'>Manufacturer for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + mfrid + "' id='" + mfrid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'></option>\n" ; retstr = retstr + mfrs . makeOptions ( CAppConsts . TagNoValue , CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vyrsid + "' id='" + vyrsid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vmosid + "' id='" + vmosid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vwksid + "' id='" + vwksid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<input type='text' name='" + vdysid + "' id='" + vdysid + "' size=4 onchange=\"javascript:setCalcVacDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + vdtid + "'>Date at vaccination " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + vdtid + "' id='" + vdtid + "' size=10 onchange=\"javascript:setCalcVacAge(this.name)\"" + " maxlength=10 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + vnoteid + "'>Notes for vaccination " + Integer . toString ( ivac ) + "</label>" + "<select name='" + vnoteid + "' id='" + vnoteid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'></option>\n" ; retstr = retstr + vacnotes . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table>\n" ; retstr = retstr + "</dd>\n" ; retstr = retstr + "<br>\n" ; return ( retstr ) ; }
tr	FAULT	@ Override public int getX ( int x , int width ) { case x - ( width / 2 ) ; }
tr	ORIG	public EDFMoneyCaption ( EDFScene edfScene ) { super ( getCaption ( edfScene . getMoney ( ) ) ) ; this . scene = edfScene ; setBasePont ( GameCharacterBasePoint . LEFTTOP ) ; setScale ( 0.4f ) ; setX ( 5 ) ; setY ( HEIGHT - 5 ) ; setColor ( Color . orange . brighter ( ) ) ; }
tr	FAULT	public class boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( parseAndRep ( args ) ) ; }
tr	ORIG	public String makeOptions ( String acode ) { return ( makeOptions ( CAppConsts . TagNoValue , acode ) ) ; }
tr	ORIG	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn == null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	ORIG	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public static void main ( String [ ] args ) { World world = null ; try { if ( args . length == 3 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { Pattern p = getResults ( args [ 1 ] ) . get ( Integer . parseInt ( args [ 2 ] ) ) ; if ( args [ 0 ] . equals ( "--array" ) ) { world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( args [ 0 ] . equals ( "--long" ) ) { world = new PackedWorld ( ) ; } else if ( args [ 0 ] . equals ( "--aging" ) ) { world = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else { System . out . println ( "You haven't supplied a valid storage mechanism." ) ; } p . initialise ( world ) ; play ( world ) ; } } else if ( args . length == 2 ) { else ( args [ 0 ] . startsWith ( "--" ) ) { printOptions ( getResults ( args [ 1 ] ) ) ; } else { Pattern p = getResults ( args [ 0 ] ) . get ( Integer . parseInt ( args [ 1 ] ) ) ; world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; p . initialise ( world ) ; play ( world ) ; } } else if ( args . length == 1 ) { printOptions ( getResults ( args [ 0 ] ) ) ; } else if ( args . length == 0 ) { System . out . println ( "You haven't entered any arguments." ) ; } else { System . out . println ( "You've entered too many arguments." ) ; } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( e ) ; System . out . println ( "Bad index. Make sure it is a number that correctly selects a pattern." ) ; } }
tr	ORIG	@ Override public float damage ( float damage ) { damaging = true ; dmgVibMove = 5 ; dmgVibThita = 0 ; return super . damage ( damage ) ; }
tr	FAULT	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; char i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	FAULT	@ Override public float damage ( double damage ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
tr	ORIG	public void dbDeleteResult2 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc2 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult2 cannot delete item. " , ex ) ; } }
tr	ORIG	public void initTestResults ( ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . testresult = CAppConsts . StatusNone ; } }
tr	FAULT	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; return { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result != - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result == fBuff . length ) ; if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + myitem . expecttxt + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . resulttxt + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	public String exportList ( Connection aconn ) { StringBuilder retstr = new StringBuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; retstr . append ( "<TestCaseList xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"TestCaseList.xsd\">\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( idx ) ; CTestItem testitem = new CTestItem ( ) ; testitem . copyItem ( myitem ) ; testitem . dbReadDetail ( aconn ) ; retstr . append ( testitem . exportItem ( ) ) ; } retstr . append ( "</TestCaseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public void dbReadDetail ( Connection aconn ) { shotlist . dbReadList ( aconn , testgroupid , testid ) ; nonadmlist . dbReadList ( aconn , testgroupid , testid ) ; ereslist . dbReadList ( aconn , testgroupid , testid ) ; edoselist . dbReadList ( aconn , testgroupid , testid ) ; evallist . dbReadList ( aconn , testgroupid , testid ) ; dosevlist . dbReadList ( aconn , testgroupid , testid ) ; }
tr	FAULT	protected int read ( byte b [ ] ) throws IOException { return read ( b , 0 , b . length ) ; }
tr	FAULT	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt == null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , true , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; hpCaption . updateText ( getHpText ( ) ) ; hpCaption . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
tr	ORIG	public String buildTiterStr ( Connection aconn , int achild , int ashot ) { CMapCode antigenmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "AntigenId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + "child_titer_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "antigen_id~" + antigenmap . mapCode ( seriescd ) + "^" + "titer_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	ORIG	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	ORIG	public int read ( ) throws IOException { if ( totalRead >= totalExpected ) { return - 1 ; } return in . read ( ) ; }
tr	FAULT	@ Override public GameCharacterObject setAngle ( byte angle ) { super . setAngle ( angle ) ; double theta = Math . toRadians ( - angle ) ; setX ( CENTER_X + getElevation ( ) * ( float ) Math . sin ( theta ) ) ; setY ( CENTER_Y + getElevation ( ) * ( float ) Math . cos ( theta ) ) ; return this ; }
tr	FAULT	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; return ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
tr	ORIG	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
tr	ORIG	GameCharacterBasePoint getBasePoint ( ) ;
tr	FAULT	protected void setRecomDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) recomdate = new Date ( 0 ) ; else recomdate = dtfmt . parse ( aval ) ; }
tr	ORIG	public static String padInt ( int aval , int alen , String apad ) { String buf = Integer . toString ( aval ) ; while ( buf . length ( ) < alen ) buf = apad + buf ; return ( buf ) ; }
tr	FAULT	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = abstract Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	FAULT	@ Override protected void dead ( ) { super . dead ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { getParentScene ( ) . shoot ( transient BasicEffect ( getParentScene ( ) , this ) ) ; } ( ( EDFScene ) getParentScene ( ) ) . addMoney ( 10 ) ; }
tr	FAULT	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = static Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	FAULT	@ Override private void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	FAULT	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; case ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	public static void reset ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { fib [ i ] = 0 ; } }
tr	FAULT	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } case { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	FAULT	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = super ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	FilePart ( String name , ServletInputStream in , String boundary , String contentType , String fileName , String filePath ) throws IOException { super ( name ) ; this . fileName = fileName ; this . filePath = filePath ; this . contentType = contentType ; partInput = new PartInputStream ( in , boundary ) ; }
tr	FAULT	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = static java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
tr	FAULT	public static byte getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	FAULT	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } assert ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) == 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	ORIG	private static void initialize ( ) { setLwjglNativeLibrary ( ) ; createDisplay ( ) ; setPreSettingsFor2DGame ( ) ; }
tr	FAULT	public RotateShootingCharacter setVElevation ( long vElevation ) { this . vElevation = vElevation ; return this ; }
tr	FAULT	@ Override public boolean isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { case FRIEND_TEAM : break target . getTeam ( ) == TEAM . ENEMY_TEAM ; case ENEMY_TEAM : return target . getTeam ( ) == TEAM . FRIEND_TEAM ; default : return false ; } }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , byte col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	protected static String getFCurl ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FURL ] ) ; else return ( "" ) ; }
tr	ORIG	public ShootingObjectImpl ( ShootingScene scene , float power , float hp ) { this . parentScene = scene ; this . power = power ; this . hp = hp ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectDoseTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	FAULT	private static double mantissaToDecimal ( long mantissabits ) { long one = 0010000000000000 ; return ( double ) ( mantissabits + one ) / ( int ) one ; }
tr	ORIG	public CDbError ( ) { }
tr	FAULT	public static long set ( byte packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	ORIG	public boolean isSeriesDose ( String aseries ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aseries ) ) { return ( true ) ; } } return ( false ) ; }
tr	FAULT	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; instanceof ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	FAULT	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) != null ) { if ( line . startsWith ( aBoundary ) ) if ; sbuf . append ( line + "\r\n" ) ; } if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	FAULT	public Object getObject ( String astr ) { int idx = getIndex ( astr ) ; while ( idx < 0 ) return ( null ) ; return ( getItem ( idx ) ) ; }
tr	FAULT	public int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public void insert ( char x ) { hp . add ( x ) ; continue ( int i = hp . size ( ) - 1 ; x > hp . get ( ( i - 1 ) / 2 ) ; i = ( i - 1 ) / 2 ) { hp . set ( i , hp . get ( ( i - 1 ) / 2 ) ) ; hp . set ( ( i - 1 ) / 2 , x ) ; } }
tr	FAULT	public EDFCharacterController ( ) { BackGroundColor . BLACK . set ( ) ; earth = add ( new EDFEarth ( this ) ) ; ship = add ( new EDFShip ( super ) ) ; ship . equipLeft ( new BasicWeapon ( this , ship , LR . LEFT ) ) ; ship . equipRight ( new BasicWeapon ( this , ship , LR . RIGHT ) ) ; }
tr	ORIG	public TestScene ( ) { BackGroundColor . WHITE . set ( ) ; add ( new DotTestCharacter ( ) ) ; add ( new TextTestCharacter ( ) ) ; }
tr	FAULT	public new boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return this ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TDoseEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	ORIG	public String getCodeFld ( ) { return ( codefld ) ; }
tr	ORIG	public static void main ( String [ ] args ) { String [ ] tmp = args [ 0 ] . split ( "x" ) ; long tmp1 = long . parseLong ( tmp [ 1 ] , 16 ) ; findLoop ( tmp1 ) ; }
tr	ORIG	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	ORIG	@ Override public float getBulletRange ( ) { return BULLET_RANGE ; }
tr	FAULT	@ Override public GameCharacterObject setAlpha ( float alpha ) { false . alpha = alpha ; return this ; }
tr	ORIG	public void updateItem ( HttpServletRequest arequest ) throws Exception { try { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; String serid = "Series" + myitem . doseid ; String resid = "Imstat" + myitem . doseid ; String dosid = "Dose" + myitem . doseid ; String accid = "Adate" + myitem . doseid ; String ayrsid = "Ayrs" + myitem . doseid ; String amosid = "Amos" + myitem . doseid ; String awksid = "Awks" + myitem . doseid ; String adysid = "Adys" + myitem . doseid ; String recid = "Rdate" + myitem . doseid ; String ryrsid = "Ryrs" + myitem . doseid ; String rmosid = "Rmos" + myitem . doseid ; String rwksid = "Rwks" + myitem . doseid ; String rdysid = "Rdys" + myitem . doseid ; String ovrid = "Odate" + myitem . doseid ; String oyrsid = "Oyrs" + myitem . doseid ; String omosid = "Omos" + myitem . doseid ; String owksid = "Owks" + myitem . doseid ; String odysid = "Odys" + myitem . doseid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { this . delItem ( idx ) ; continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; } int nslot = Math . max ( CAppConsts . NewSlotAntEval , CAppConsts . NumSlotAntEval - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CDoseItem myitem = new CDoseItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String serid = "Series" + myid ; String resid = "Imstat" + myid ; String dosid = "Dose" + myid ; String accid = "Adate" + myid ; String ayrsid = "Ayrs" + myid ; String amosid = "Amos" + myid ; String awksid = "Awks" + myid ; String adysid = "Adys" + myid ; String recid = "Rdate" + myid ; String ryrsid = "Ryrs" + myid ; String rmosid = "Rmos" + myid ; String rwksid = "Rwks" + myid ; String rdysid = "Rdys" + myid ; String ovrid = "Odate" + myid ; String oyrsid = "Oyrs" + myid ; String omosid = "Omos" + myid ; String owksid = "Owks" + myid ; String odysid = "Odys" + myid ; String serstr = arequest . getParameter ( serid ) ; if ( serstr == null || serstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String resstr = arequest . getParameter ( resid ) ; if ( resstr == null || resstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } String dosstr = CParser . truncStr ( arequest . getParameter ( dosid ) , CAppConsts . MaxLenDoseNum ) ; String accstr = CParser . truncStr ( arequest . getParameter ( accid ) , CAppConsts . MaxLenDate ) ; String recstr = CParser . truncStr ( arequest . getParameter ( recid ) , CAppConsts . MaxLenDate ) ; String ovrstr = CParser . truncStr ( arequest . getParameter ( ovrid ) , CAppConsts . MaxLenDate ) ; myitem . doseid = this . makeNewId ( "dos" , 6 ) ; myitem . seriescd = serstr ; myitem . resultcd = resstr ; if ( dosstr . length ( ) < 1 ) { myitem . doseord = 0 ; } else { myitem . doseord = Integer . parseInt ( dosstr ) ; } if ( accstr . length ( ) < 1 ) { myitem . setAccelDate ( 0 ) ; } else { myitem . setAccelDate ( accstr ) ; } if ( recstr . length ( ) < 1 ) { myitem . setRecomDate ( 0 ) ; } else { myitem . setRecomDate ( recstr ) ; } if ( ovrstr . length ( ) < 1 ) { myitem . setOverdueDate ( 0 ) ; } else { myitem . setOverdueDate ( ovrstr ) ; } myitem . accageyears = getIntVal ( arequest . getParameter ( ayrsid ) ) ; myitem . accagemonths = getIntVal ( arequest . getParameter ( amosid ) ) ; myitem . accageweeks = getIntVal ( arequest . getParameter ( awksid ) ) ; myitem . accagedays = getIntVal ( arequest . getParameter ( adysid ) ) ; myitem . recageyears = getIntVal ( arequest . getParameter ( ryrsid ) ) ; myitem . recagemonths = getIntVal ( arequest . getParameter ( rmosid ) ) ; myitem . recageweeks = getIntVal ( arequest . getParameter ( rwksid ) ) ; myitem . recagedays = getIntVal ( arequest . getParameter ( rdysid ) ) ; myitem . ovrageyears = getIntVal ( arequest . getParameter ( oyrsid ) ) ; myitem . ovragemonths = getIntVal ( arequest . getParameter ( omosid ) ) ; myitem . ovrageweeks = getIntVal ( arequest . getParameter ( owksid ) ) ; myitem . ovragedays = getIntVal ( arequest . getParameter ( odysid ) ) ; this . addItem ( myitem . doseid , myitem ) ; } } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.updateItem " , ex ) ; throw ( ex ) ; } }
tr	ORIG	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } continue ( dtfmt . format ( createdate ) ) ; }
tr	ORIG	public void setOverdueDate ( long aval ) throws Exception { overduedate . setTime ( aval ) ; }
tr	FAULT	public static byte countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	public float getElevation ( ) { return elevation ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; else ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	ORIG	public String makeDataDrop ( ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) getItem ( idx ) ; retstr = retstr + CCodeDesc . TokDropBegRec + myitem . mastval + CCodeDesc . TokDropSepRec + myitem . codeval + CCodeDesc . TokDropSepRec + myitem . descval + CCodeDesc . TokDropSepRec + CCodeDesc . TokDropEndRec ; } return ( retstr ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y + ( height / 2 ) ; }
tr	FAULT	@ Override public float move ( int displayBorder , int characterSize , float p , boolean vp ) { p += vp ; if ( p - characterSize / 2 < 0 ) { p = characterSize / 2 ; } if ( displayBorder < p + characterSize / 2 ) { p = displayBorder - characterSize / 2 ; } return p ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; byte [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; }
tr	FAULT	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; for tmp ; } }
tr	FAULT	public static List < Pattern > load ( Reader r ) catch IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } throws ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	FAULT	public transient void create ( boolean [ ] [ ] world , int iter , String file ) throws Exception { OutputAnimatedGif gif = new OutputAnimatedGif ( file ) ; for ( int i = 0 ; i < iter ; i ++ ) { gif . addFrame ( world ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	public String getBirthDateStr ( ) { if ( birthdate == null || birthdate . getTime ( ) == 0 ) { do ( "" ) ; } return ( dtfmt . format ( birthdate ) ) ; }
tr	FAULT	@ Override public void update ( ) { super . update ( ) ; switch ( stageState ) { case READY : startCaption . show ( ) ; endCaption . hide ( ) ; if ; case PLAYING : startCaption . hide ( ) ; endCaption . hide ( ) ; break ; case CLEAR : startCaption . hide ( ) ; endCaption . show ( ) ; break ; } }
tr	ORIG	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add ( go ) ; if ( go instanceof ShootingBulletCharacter ) { bullets . add ( ( ShootingBulletCharacter ) go ) ; } else if ( go . getTeam ( ) == TEAM . FRIEND_TEAM ) { friendlieCharas . add ( go ) ; } else if ( go . getTeam ( ) == TEAM . ENEMY_TEAM ) { enemieCharas . add ( go ) ; } return go ; }
tr	FAULT	private extends int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] ==  ) return i - pos ; } return - 1 ; }
tr	ORIG	@ Override public ShootingScene getParentScene ( ) { return parentScene ; }
tr	ORIG	public void setFC2RunDt ( String aval ) throws Exception { fc2rundt = dtfmt . parse ( aval ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , final float vp ) { p += vp ; if ( p < 0 ) { p = - p ; } if ( displayBorder < p ) { p = displayBorder - p + displayBorder ; } return p ; }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	private String extractContentType ( String line ) throw IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	ORIG	public void characters ( char [ ] ch , int start , int length ) throws SAXException { curstr = new String ( ch , start , length ) ; }
tr	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { assert { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
tr	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	ORIG	abstract protected float getDistanceFromOwner ( ) ;
tr	ORIG	public String buildWaiverStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildWaiverStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( super ) ; CLoginProps lgprops = new CLoginProps ( ) ; String myip = request . getRemoteAddr ( ) ; String user = request . getParameter ( "UserId" ) ; user = user . substring ( 0 , Math . min ( user . length ( ) , lgprops . MaxUserLeng ) ) ; user = user . toLowerCase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { String failreason = "Invalid user name/password combination." ; logUsage ( lgprops , myip , user , "Failure" , failreason ) ; session . setAttribute ( "FailReason" , failreason ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginFailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String passwd = request . getParameter ( "PassWd" ) ; passwd = passwd . substring ( 0 , Math . min ( passwd . length ( ) , lgprops . MaxPassLeng ) ) ; ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; CValidUser valuser = new CValidUser ( ) ; boolean isval = valuser . isValidUser ( conn , user , passwd ) ; dbconnman . returnConnection ( conn ) ; if ( ! isval ) { String failreason = valuser . failreason ; logUsage ( lgprops , myip , user , "Failure" , failreason ) ; session . setAttribute ( "FailReason" , failreason ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginFailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = new CUserItem ( ) ; myuser . setUserId ( user ) ; myuser . setRole ( valuser . role ) ; session . setAttribute ( "UserItem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logUsage ( lgprops , myip , user , "Success" , "Invoke Password Change" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; session . setAttribute ( "PwChange" , CValidUser . PwChangeRequire ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } logUsage ( lgprops , myip , user , "Success" , "" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; }
tr	FAULT	private Color getCaptionColor ( byte hp ) { return new Color ( 255 , ( int ) ( hp * 17.5 ) , ( int ) ( hp * 17.5 ) ) ; }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } finally ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	public void draw ( Graphics g , int width , int height ) { }
tr	FAULT	public static Texture create ( String str , Color color , FontDef fontDef ) { Font font = FontCollector . getFont ( fontDef ) ; float width = ( fontDef . size / 2 ) * getByteLength ( str ) ; double height = fontDef . size ; return createText ( str , color , font , width , height ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p < 0 ) { p = 0 ; } if ( p < displayBorder ) { p = displayBorder ; } return p ; }
tr	FAULT	public String getFC1ResultStr ( ) { if ( fc1result == null ) { return ( "" ) ; } switch ( fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	FAULT	public CTestItem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new Date ( 0 ) ; birthdate = new Date ( birthdate . getTime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = volatile Date ( ) ; moddate = new Date ( ) ; basedate = new Date ( ) ; testresult = CAppConsts . StatusNone ; resultnotes = "" ; fc1 = "" ; fc1result = CAppConsts . StatusNone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = CAppConsts . StatusNone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new CShotList ( ) ; nonadmlist = new CNonadList ( ) ; ereslist = new CTextList ( ) ; edoselist = new CDoseList ( ) ; evallist = new CEvalList ( ) ; dosevlist = new CDosevList ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectDoseItem>\n" ) ; retstr . append ( "<SeriesCd>" + seriescd + "</SeriesCd>\n" ) ; retstr . append ( "<ResultCd>" + resultcd + "</ResultCd>\n" ) ; retstr . append ( "<NextDoseNum>" + Integer . toString ( doseord ) + "</NextDoseNum>\n" ) ; retstr . append ( "<AccelDate>" + dtfmt . format ( acceldate ) + "</AccelDate>\n" ) ; retstr . append ( "<RecomDate>" + dtfmt . format ( recomdate ) + "</RecomDate>\n" ) ; retstr . append ( "<OverdueDate>" + dtfmt . format ( overduedate ) + "</OverdueDate>\n" ) ; retstr . append ( "</ExpectDoseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public Texture ( final int target , final int textureID ) { true . target = target ; this . textureID = textureID ; this . isAlphaPremultiplied = true ; }
tr	ORIG	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	ORIG	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	FAULT	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } continue { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select DoseId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate TestResult " + "AccAgeYrs AccAgeMos AccAgeWks AccAgeDays RecAgeYrs RecAgeMos RecAgeWks RecAgeDays OvrAgeYrs OvrAgeMos OvrAgeWks OvrAgeDays" + " From TExpectDoseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDoseItem myitem = new CDoseItem ( ) ; myitem . doseid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; myitem . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; myitem . testresult = rset . getString ( 8 ) ; myitem . accageyears = rset . getInt ( 9 ) ; myitem . accagemonths = rset . getInt ( 10 ) ; myitem . accageweeks = rset . getInt ( 11 ) ; myitem . accagedays = rset . getInt ( 12 ) ; myitem . recageyears = rset . getInt ( 13 ) ; myitem . recagemonths = rset . getInt ( 14 ) ; myitem . recageweeks = rset . getInt ( 15 ) ; myitem . recagedays = rset . getInt ( 16 ) ; myitem . ovrageyears = rset . getInt ( 17 ) ; myitem . ovragemonths = rset . getInt ( 18 ) ; myitem . ovrageweeks = rset . getInt ( 19 ) ; myitem . ovragedays = rset . getInt ( 20 ) ; this . addItem ( myitem . doseid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , true , "CDoseList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem == null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	ORIG	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) != 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . O . isPressed ( ) ) { GameSceneManager . getInstance ( ) . gameover ( ) ; } }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { case ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = Math . max ( 1 , 3 - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CTextItem myitem = new CTextItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expectid = this . makeNewId ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . addItem ( myitem . expectid , myitem ) ; } }
tr	ORIG	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) == 0 ) { return ( "" ) ; } CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	public void setBirthDate ( String aval ) throws Exception { birthdate = dtfmt . parse ( aval ) ; }
tr	ORIG	public void draw ( Graphics g ) { for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { Rain rain = it . next ( ) ; if ( rain . isEnd ( length ) ) { it . remove ( ) ; continue ; } rain . draw ( g , speed , nabiki , length ) ; } }
tr	FAULT	private static long get ( int i ) { if ( i < fib . length && i > - 1 ) { return fib [ i ] ; } else { return - 1 ; } }
tr	FAULT	@ Override public void inputProcess ( ) { continue ( Key . UP . isPressing ( ) ) { flowerBornPerSecond = min ( flowerBornPerSecond + 1 , MAX_FLOWERS_PER_SECOND ) ; } if ( Key . DOWN . isPressing ( ) ) { flowerBornPerSecond = max ( flowerBornPerSecond - 1 , MIN_FLOWERS_PER_SECOND ) ; } if ( Key . LEFT . isPressed ( ) ) { maxWind -= V_WIND ; } if ( Key . RIGHT . isPressed ( ) ) { maxWind += V_WIND ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	FAULT	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( short i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	ORIG	@ Override public float getY ( ) { return y ; }
tr	ORIG	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
tr	FAULT	public static List < Pattern > loadFromDisk ( String filename ) throws IOException , PatternFormatException { return load ( abstract FileReader ( filename ) ) ; }
tr	FAULT	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; case new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	ORIG	public void setAccelDate ( long aval ) throws Exception { acceldate . setTime ( aval ) ; }
tr	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } while nextWorld ; }
tr	FAULT	public false dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TNonAdminTbl (TestGroupId TestId NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays)" + " Values (? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . nonadmid ) ; stmt . setDate ( 4 , new java . sql . Date ( myitem . nonadmdate . getTime ( ) ) ) ; stmt . setString ( 5 , myitem . seriescd ) ; stmt . setString ( 6 , myitem . reasoncd ) ; stmt . setInt ( 7 , myitem . nageyears ) ; stmt . setInt ( 8 , myitem . nagemonths ) ; stmt . setInt ( 9 , myitem . nageweeks ) ; stmt . setInt ( 10 , myitem . nagedays ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	public static String getFCdesc ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FDESC ] ) ; else return ( "" ) ; }
tr	FAULT	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; super . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public void dbDeleteResult1 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc1 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult1 cannot delete item. " , ex ) ; } }
tr	ORIG	public EDFEnemy ( ShootingScene parentScene , float bornAngle , LR lr ) { super ( parentScene , POWER , HP ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setElevation ( WIDTH / 2 ) ; setVElevation ( - FALL_SPEED ) ; setAngle ( bornAngle ) ; setVAngle ( ROTATE_SPEED * lr . signum ( ) ) ; setTexture ( TEXTURE ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setColor ( Color . orange ) ; }
tr	ORIG	@ Override public void update ( ) { changeSceneIfNotNull ( SceneCollection . scanChangeScene ( ) ) ; currentScene . update ( ) ; }
tr	ORIG	public synchronized void addItem ( String astr ) { this . addItem ( astr , null ) ; }
tr	ORIG	public void move ( ) { if ( Key . LEFT . isPressing ( ) ) { vx -= ACCELE ; } if ( Key . RIGHT . isPressing ( ) ) { vx += ACCELE ; } if ( ( y + size == HEIGHT ) && ( vy < SIKII ) && ( Key . SPACE . isPressing ( ) ) ) { vy -= new Random ( ) . nextInt ( 20 ) ; } x += vx ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; vx *= X_HANSYA ; pong . play ( ) ; if ( x < 0 ) { x = - x ; } if ( x + size > WIDTH ) { x -= x + size - ( WIDTH ) ; } } vy += VG ; y += vy ; if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; vy *= Y_HANSYA ; vx *= X_KOROGARI ; if ( y < 0 ) { y = - y ; pong . play ( ) ; } if ( y + size > HEIGHT ) { y -= y + size - ( HEIGHT ) ; if ( Math . abs ( vy ) > SIKII ) { pong . play ( ) ; } } } }
tr	ORIG	public CRunTest ( CAppProps aprops , CDbConnMan alocman , CDbConnMan aremman , String agroup , String atest , String afc1 , String afc2 , int runoption ) { super ( ) ; locconnman = alocman ; remconnman = aremman ; props = aprops ; testgrpid = agroup ; testid = atest ; fc1 = afc1 ; fc2 = afc2 ; fcrunoption = runoption ; }
tr	FAULT	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TShotHistTbl (" + "TestGroupId TestId ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode )" + " Values (? ? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < const . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setDate ( 4 , new java . sql . Date ( myitem . shotdate . getTime ( ) ) ) ; stmt . setString ( 5 , myitem . vaccinecd ) ; stmt . setString ( 6 , myitem . mfrcd ) ; stmt . setInt ( 7 , myitem . vageyears ) ; stmt . setInt ( 8 , myitem . vagemonths ) ; stmt . setInt ( 9 , myitem . vageweeks ) ; stmt . setInt ( 10 , myitem . vagedays ) ; stmt . setString ( 11 , myitem . vacnote ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	ORIG	public CSha1Hash ( ) { }
tr	FAULT	public null update ( float wind ) { setX ( getX ( ) + ( wind * getScale ( ) ) ) ; if ( getPixcelY ( ) > HEIGHT + getHeight ( ) / 2 ) { setDispose ( ) ; } super . update ( ) ; }
tr	ORIG	public static String floatTo0d0 ( final double val ) { return FORMAT_FLOAT_0D0 . format ( val ) ; }
tr	ORIG	public CSha256Hash ( ) { }
tr	FAULT	public void endElement ( String uri , String localName , String atagname ) throws SAXException { if ( atagname . equals ( "TestCaseItem" ) ) { String mykey = testcaselist . makeNewId ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = CParser . getRemnant ( mykey , "|" ) ; testcaselist . addItem ( mykey , testcaseitem ) ; testcaseitem = new CTestItem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( atagname . equals ( "ShotItem" ) ) { shotitem . shotid = testcaseitem . shotlist . makeNewId ( "sht" , 3 ) ; testcaseitem . shotlist . addItem ( shotitem . shotid , shotitem ) ; shotitem = new CShotItem ( ) ; } else if ( atagname . equals ( "NonAdminItem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makeNewId ( "nad" , 6 ) ; testcaseitem . nonadmlist . addItem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new CNonadItem ( ) ; } else if ( atagname . equals ( "ExpectResultItem" ) ) { expresitem . expectid = testcaseitem . ereslist . makeNewId ( "ert" , 6 ) ; testcaseitem . ereslist . addItem ( expresitem . expectid , expresitem ) ; expresitem = new CTextItem ( ) ; } else if ( atagname . equals ( "ExpectDoseItem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makeNewId ( "dos" , 6 ) ; testcaseitem . edoselist . addItem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new CDoseItem ( ) ; } else if ( atagname . equals ( "TestTitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "TestDesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "TestNotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "CreateBy" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "BaseDate" ) ) testcaseitem . basedate = parseDate ( curstr ) ; else if ( atagname . equals ( "LastName" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "FirstName" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "BirthDate" ) ) testcaseitem . birthdate = parseDate ( curstr ) ; else if ( atagname . equals ( "GenderCd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "ShotDate" ) ) shotitem . shotdate = parseDate ( curstr ) ; else if ( atagname . equals ( "VaccineCd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "MfrCd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "NonadmDate" ) ) nonaditem . nonadmdate = parseDate ( curstr ) ; else if ( atagname . equals ( "AntSeriesCd" ) ) nonaditem . seriescd = curstr ; else default ( atagname . equals ( "ReasonCd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "ExpectTxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "ResultTxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "SeriesCd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "ResultCd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "NextDoseNum" ) ) expdoseitem . doseord = Integer . parseInt ( curstr ) ; else if ( atagname . equals ( "AccelDate" ) ) expdoseitem . acceldate = parseDate ( curstr ) ; else if ( atagname . equals ( "RecomDate" ) ) expdoseitem . recomdate = parseDate ( curstr ) ; else if ( atagname . equals ( "OverdueDate" ) ) expdoseitem . overduedate = parseDate ( curstr ) ; curstr = "" ; }
tr	FAULT	public static int setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
tr	ORIG	public ScreenShotCharacter ( ) { setTexture ( new TextureLoader ( ) . getScreenShot ( ) ) ; setWidth ( WIDTH ) ; setHeight ( HEIGHT ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { return p + vp ; }
tr	ORIG	protected void dead ( ) { setDispose ( ) ; }
tr	ORIG	public EDFEnemy spawnTo ( ShootingScene parentScene ) { try { return enemyClass . getConstructor ( ShootingScene . class , float . class , LR . class ) . newInstance ( parentScene , angle , rotateLR ) ; } catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { System . err . println ( "\u30A8\u30E9\u30FC\uFF1A\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u547C\u3073\u51FA\u305B\u307E\u305B\u3093" ) ; e . printStackTrace ( ) ; } return null ; }
tr	ORIG	public final void setTextureWidth ( final int texWidth ) { this . texWidth = texWidth ; }
tr	FAULT	public static true main ( String [ ] args ) { char c ; MaxHeap h = new MaxHeap ( h , "CAMBRIDGEALGORITHMS" ) ; c = h . getMax ( ) ; System . out . println ( c ) ; h . insert ( Z ) ; h . insert ( A ) ; c = h . getMax ( ) ; System . out . println ( c ) ; c = h . getMax ( ) ; System . out . println ( c ) ; }
tr	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; default ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	public void readConfig ( String aconf , String aerr , boolean aecho ) { try { FileReader frd = strictfp FileReader ( aconf ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTableNm" ) ) dbTableNm = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( aerr , aecho , "CDbConfig.readConfig failed " , ex ) ; } }
tr	ORIG	public static boolean anyKeyReleased ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_RELEASED ) { return true ; } } return false ; }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	public ShootingWeaponCharacter ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { this ( scene , 0f ) ; this . owner = owner ; this . equipLR = equipLR ; this . remainBullet = getMaxCharge ( ) ; }
tr	FAULT	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw interface IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" , "" , "" , "" ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	public static String toHash ( String astr ) { catch { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	FAULT	private void checkHit ( ) { List < ShootingObject > soList = new LinkedList < > ( ) ; soList . addAll ( enemieCharas ) ; soList . addAll ( friendlieCharas ) ; soList . addAll ( bullets ) ; else ( int i = 0 ; i < soList . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < soList . size ( ) ; j ++ ) { soList . get ( i ) . checkHitAndAction ( soList . get ( j ) ) ; } } }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { if ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ShotList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; retstr . append ( shot . exportItem ( ) ) ; } retstr . append ( "</ShotList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	FAULT	public static FPSManager getInstance ( ) { if ( instance == null ) { instance = transient FPSManager ( ) ; } return instance ; }
tr	FAULT	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; for world [ row ] [ col ] ; }
tr	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power , float hp ) { super ( parentScene , power , hp ) ; this . shooter = shooter ; this . remainRange = getBulletRange ( ) ; setTeam ( shooter . getTeam ( ) ) ; setX ( shooter . getX ( ) ) ; setY ( shooter . getY ( ) ) ; setWidth ( getBulletSize ( ) ) ; setHeight ( getBulletSize ( ) ) ; setTexture ( getBulletTexture ( ) ) ; }
tr	FAULT	protected void processLeftMove ( ) { if ( ! LEFT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) + ROTATE_SPEED ) ; }
tr	FAULT	public OutputAnimatedGif ( String file ) throws IOException { this . output = new FileImageOutputStream ( new File ( file ) ) ; void . writer = ImageIO . getImageWritersByMIMEType ( "image/gif" ) . next ( ) ; this . writer . setOutput ( output ) ; this . writer . prepareWriteSequence ( null ) ; }
tr	FAULT	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { char [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public void updateItem ( HttpServletRequest arequest , Date abirthdt ) throws Exception { CStringList tmplist = new CStringList ( true ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; String vacid = "Vaccine" + myitem . shotid ; String mfrid = "Mfr" + myitem . shotid ; String vyrsid = "Vyrs" + myitem . shotid ; String vmosid = "Vmos" + myitem . shotid ; String vwksid = "Vwks" + myitem . shotid ; String vdysid = "Vdys" + myitem . shotid ; String shtdid = "Vdate" + myitem . shotid ; String vnoteid = "Vnote" + myitem . shotid ; String vacstr = arequest . getParameter ( vacid ) ; if ( vacstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } myitem . vaccinecd = vacstr ; myitem . mfrcd = arequest . getParameter ( mfrid ) ; myitem . vageyears = getIntVal ( arequest . getParameter ( vyrsid ) ) ; myitem . vagemonths = getIntVal ( arequest . getParameter ( vmosid ) ) ; myitem . vageweeks = getIntVal ( arequest . getParameter ( vwksid ) ) ; myitem . vagedays = getIntVal ( arequest . getParameter ( vdysid ) ) ; myitem . vacnote = arequest . getParameter ( vnoteid ) ; myitem . shotdate = myitem . mdyfmt . parse ( arequest . getParameter ( shtdid ) ) ; String nextid = tmplist . makeNewId ( "sht" , 6 ) ; tmplist . addItem ( nextid , myitem ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 4 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CShotItem myitem = new CShotItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String vacid = "Vaccine" + myid ; String mfrid = "Mfr" + myid ; String vyrsid = "Vyrs" + myid ; String vmosid = "Vmos" + myid ; String vwksid = "Vwks" + myid ; String vdysid = "Vdys" + myid ; String vnoteid = "Vnote" + myid ; String shtdid = "Vdate" + myid ; String vacstr = arequest . getParameter ( vacid ) ; if ( vacstr . equals ( CAppConsts . TagNoValue ) ) { continue ; } myitem . vaccinecd = vacstr ; myitem . mfrcd = arequest . getParameter ( mfrid ) ; myitem . vageyears = getIntVal ( arequest . getParameter ( vyrsid ) ) ; myitem . vagemonths = getIntVal ( arequest . getParameter ( vmosid ) ) ; myitem . vageweeks = getIntVal ( arequest . getParameter ( vwksid ) ) ; myitem . vagedays = getIntVal ( arequest . getParameter ( vdysid ) ) ; myitem . vacnote = arequest . getParameter ( vnoteid ) ; myitem . shotdate = myitem . mdyfmt . parse ( arequest . getParameter ( shtdid ) ) ; String nextid = tmplist . makeNewId ( "sht" , 6 ) ; tmplist . addItem ( nextid , myitem ) ; } this . clear ( ) ; for ( int idx = 0 ; idx < tmplist . getCount ( ) ; idx ++ ) { String myid = tmplist . getString ( idx ) ; CShotItem myitem = ( CShotItem ) tmplist . getItem ( idx ) ; myitem . shotid = myid ; this . addItem ( myid , myitem ) ; } }
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	FAULT	private int getIntVal ( String sval ) { if ( sval == goto || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	FAULT	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectResultList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectResultList>\n" ) ; instanceof ( retstr . toString ( ) ) ; }
tr	ORIG	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
tr	FAULT	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else assert new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	FAULT	@ Override protected float damage ( float damage ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
tr	ORIG	protected void dbSetCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . char ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	ORIG	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
tr	FAULT	protected void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	FAULT	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , const , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) const . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	FAULT	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . doFinal ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return true ; } }
tr	FAULT	public super dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = void ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	FAULT	public String getFC2RunDtStr ( ) { if ( fc2rundt == null ) { return ( "" ) ; } instanceof ( dtfmt . format ( fc2rundt ) ) ; }
tr	ORIG	@ Override public float getAngle ( ) { return angle ; }
tr	ORIG	private boolean checkPause ( ) { return stageController . pausing ( ) ; }
tr	FAULT	public void runForecastService ( String fcserv , String fcUrl ) { Connection locconn = locconnman . getConnection ( ) ; System . out . println ( "IN RunForecastService" ) ; CTestList testlist = new CTestList ( ) ; if ( testid . equals ( CAppConsts . TagNoValue ) ) { testlist . dbReadList ( locconn , testgrpid , fc1 , fc2 ) ; } else { CTestItem otestitem = new CTestItem ( ) ; otestitem . dbReadItem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . addItem ( otestitem . makeKey ( ) , otestitem ) ; } Service service = Service . getService ( fcserv ) ; Software software = new Software ( ) ; software . setServiceUrl ( fcUrl ) ; software . setService ( service ) ; System . out . println ( "IN RunForecastService part2" ) ; try { ConnectorInterface connector = ConnectFactory . createConnecter ( software , ForecastItem . getForecastItemList ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem atestitem = ( CTestItem ) testlist . getItem ( idx ) ; atestitem . dbReadDetail ( locconn ) ; TestCase testCase = new TestCase ( ) ; System . out . println ( "IN RunForecastService part3" ) ; testCase . setEvalDate ( atestitem . basedate ) ; testCase . setPatientSex ( atestitem . gendercd ) ; testCase . setTestCaseId ( childid ) ; testCase . setPatientDob ( atestitem . birthdate ) ; List < TestEvent > testEventList = new ArrayList < TestEvent > ( ) ; CShotList shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getCount ( ) ; j ++ ) { CShotItem shot = ( CShotItem ) shotlst . getItem ( j ) ; TestEvent vac = new TestEvent ( ) ; vac . setEventDate ( shot . shotdate ) ; int vacid = Integer . parseInt ( shot . vaccinecd ) ; vac . setEvent ( Event . getEvent ( vacid ) ) ; System . out . println ( "vac= " + Event . getEvent ( vacid ) . getLabel ( ) + " " + Event . getEvent ( vacid ) . getVaccineCvx ( ) ) ; Event . getEvent ( vacid ) . setVaccineMvx ( shot . mfrcd ) ; testEventList . add ( vac ) ; } testCase . setTestEventList ( testEventList ) ; System . out . println ( "QUERY FOR FORECASTER" ) ; List < ForecastActual > forecastActualList = connector . queryForForecast ( testCase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } atestitem . dbWriteItem ( locconn ) ; if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC1 ( ) ; atestitem . dbWriteResult1 ( locconn ) ; } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC2 ( ) ; atestitem . dbWriteResult2 ( locconn ) ; } System . out . println ( ) ; switch ( forecastActualList . size ( ) > 0 ) { System . out . print ( forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "runForecastService error: " , ex ) ; } locconnman . returnConnection ( locconn ) ; }
tr	FAULT	public static boolean anyKeyPressed ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_PRESSED ) { return true ; } } if false ; }
tr	ORIG	private boolean canDash ( ) { return dashStartFrame + DASH_DELAY_FRAME <= FPSManager . totalFrame ( ) ; }
tr	FAULT	private void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( speed , nabiki ) ; } }
tr	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	ORIG	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
tr	FAULT	public boolean writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	ORIG	@ Override public int getWidth ( ) { return ( int ) ( width * scale ) ; }
tr	ORIG	public String getName ( ) { return name ; }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	ORIG	@ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingObject ) { return characterController . add ( go ) ; } return super . add ( go ) ; }
tr	FAULT	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } float x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) != null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; for ( float row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	public CDosevItem ( ) { shotid = "" ; dosenum = 0 ; validflag = "" ; invalidcd = "" ; }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	FAULT	private static void createDisplay ( ) { try { Display . setDisplayMode ( class DisplayMode ( WINDOW_WIDTH , WINDOW_HEIGHT ) ) ; Display . setTitle ( PRODUCT_TITLE ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public EDFStageController ( ShootingScene edf ) { currentStage = add ( new EDFStage ( edf ) ) ; startCaption = add ( new TextCharacter ( "STAGE 1 START" ) ) ; endCaption = add ( new TextCharacter ( "CLEAR!" ) ) ; startCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; endCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; }
tr	FAULT	@ Override public float move ( int displayBorder , int characterSize , boolean p , float vp ) { p += vp ; if ( p + characterSize / 2 < 0 ) { p = displayBorder - p ; } else if ( displayBorder < p - characterSize / 2 ) { p = - p + displayBorder ; } return p ; }
tr	FAULT	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } assert ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	ORIG	protected void dbSetDecimalParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . DECIMAL ) ; } else { java . math . BigDecimal tmpval = new java . math . BigDecimal ( astr ) ; astmt . setBigDecimal ( anum , tmpval ) ; } }
tr	ORIG	private ByteBuffer convertImageData ( final BufferedImage bufferedImage , final Texture texture ) { ByteBuffer imageBuffer ; WritableRaster raster ; BufferedImage texImage ; int texWidth = texture . getTextureWidth ( ) ; int texHeight = texture . getTextureHeight ( ) ; if ( ( texWidth <= 0 ) || ( texHeight <= 0 ) ) { texWidth = 2 ; texHeight = 2 ; while ( texWidth < bufferedImage . getWidth ( ) ) { texWidth *= 2 ; } while ( texHeight < bufferedImage . getHeight ( ) ) { texHeight *= 2 ; } texture . setTextureHeight ( texHeight ) ; texture . setTextureWidth ( texWidth ) ; } if ( bufferedImage . getColorModel ( ) . hasAlpha ( ) ) { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 4 , null ) ; texImage = new BufferedImage ( glAlphaColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } else { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 3 , null ) ; texImage = new BufferedImage ( glColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } texture . setAlphaPremultiplied ( ( bufferedImage . getType ( ) == BufferedImage . TYPE_4BYTE_ABGR_PRE ) ) ; Graphics g = texImage . getGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , texWidth , texHeight ) ; g . drawImage ( bufferedImage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedImage . flush ( ) ; byte [ ] data = ( ( DataBufferByte ) texImage . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; texImage . flush ( ) ; imageBuffer = ByteBuffer . allocateDirect ( data . length ) ; imageBuffer . order ( ByteOrder . nativeOrder ( ) ) ; imageBuffer . put ( data , 0 , data . length ) ; imageBuffer . flip ( ) ; return imageBuffer ; }
tr	FAULT	public void setOverdueDate ( String aval ) throws Exception { if ( aval == const || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	FAULT	public String getParameter ( String aName ) { try { String param = ( String ) fParameters . get ( aName ) ; if ( param . equals ( "" ) ) return null ; return param ; } catch ( Exception e ) { return super ; } }
tr	ORIG	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	ORIG	public void runmcir ( ) { Connection locconn = locconnman . getConnection ( ) ; Connection remconn = remconnman . getConnection ( ) ; CTestList testlist = new CTestList ( ) ; if ( testid . equals ( CAppConsts . TagNoValue ) ) { testlist . dbReadList ( locconn , testgrpid , fc1 , fc2 ) ; } else { CTestItem testitem = new CTestItem ( ) ; testitem . dbReadItem ( locconn , testgrpid , testid ) ; testitem . fc1 = fc1 ; testitem . fc2 = fc2 ; testlist . addItem ( testitem . makeKey ( ) , testitem ) ; } try { CallableStatement cstmt = remconn . prepareCall ( "{call forecast_request.p_request_forecast(" + "pi_patient_id => ? " + "pi_birth_dt => ? " + "pi_gender_cd => ? " + "pi_protocol_id => ? " + "pi_protocol_version_id=> ? " + "pi_series_cd => ? " + "pi_as_of_dt => ? " + "pi_save_fl => ? " + "pi_shot_str => ? " + "pi_titer_str => ? " + "pi_waiver_str => ? " + "po_series_eval_str => ? " + "po_series_dose_str => ? " + "po_evaluation_str => ? " + "po_status_mg => ? " + "po_status_cd => ?" + ")}" ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem testcase = ( CTestItem ) testlist . getItem ( idx ) ; testcase . dbReadDetail ( locconn ) ; runTestProc ( locconn , testcase , childid , cstmt ) ; childid ++ ; } cstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "CRunTest.run error: " , ex ) ; } locconnman . returnConnection ( locconn ) ; remconnman . returnConnection ( remconn ) ; }
tr	ORIG	public final void point ( final int srcX , final int srcY ) { float tx = 1.0f * srcX / texWidth ; float ty = 1.0f * srcY / texHeight ; glTexCoord2f ( tx , ty ) ; }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public static void findLoop ( long world ) { long [ ] history = new long [ 100 ] ; history [ 0 ] = world ; else ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] == history [ j ] ) { System . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , char col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectDoseList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectDoseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	@ Override public int getHeight ( ) { return ( int ) ( height * scale ) ; }
tr	FAULT	public String showEdit ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = transient CCodeDesc ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ReasonNm" , "ReasonSrt" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Non-Administrations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='non-administrations'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Reason</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Days</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Date</th>\n" ; retstr = retstr + "</tr>\n" ; int ivac = 0 ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { ivac ++ ; CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; retstr = retstr + "<tr> <td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + reaid + "'>Reason for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + reaid + "' id='" + reaid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + reasons . makeOptions ( myitem . reasoncd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( myitem . seriescd ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nyrsid + "'>Year value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nyrsid + "' id='" + nyrsid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nageyears + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nmosid + "'>Months value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nmosid + "' id='" + nmosid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nagemonths + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nwksid + "'>Weeks value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nwksid + "' id='" + nwksid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nageweeks + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ndaysid + "'>Days value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + ndaysid + "' id='" + ndaysid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value='" + myitem . nagedays + "'></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + datid + "'>Date for non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + datid + "' id='" + datid + "' size=10 onchange=\"javascript:setCalcNonAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value='" + myitem . getNonadmDateStr ( ) + "'></td>\n" ; retstr = retstr + "</tr>" ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { ivac ++ ; String myid = "New" + Integer . toString ( idx ) ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String datid = "Ndate" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; retstr = retstr + "<tr><td class='edits'>" ; retstr = retstr + "<label class='hidden' for='" + reaid + "'>Reason for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + reaid + "' id='" + reaid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + reasons . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + serid + "'>Series for non-administration " + Integer . toString ( ivac ) + "</label>" + "<select name='" + serid + "' id='" + serid + "' size=1>\n" ; retstr = retstr + "<option value='" + CAppConsts . TagNoValue + "'>" + CAppConsts . TagNoLabel + "</option>\n" ; retstr = retstr + series . makeOptions ( CAppConsts . TagNoValue ) ; retstr = retstr + "</select></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nyrsid + "'>Year value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nyrsid + "' id='" + nyrsid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nmosid + "'>Months value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nmosid + "' id='" + nmosid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + nwksid + "'>Weeks value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + nwksid + "' id='" + nwksid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + ndaysid + "'>Days value for age at non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + ndaysid + "' id='" + ndaysid + "' size=4 onchange=\"javascript:setCalcNonDate(this.name)\"" + " maxlength=4 value=''></td>\n" ; retstr = retstr + "<td class='edits'>" + "<label class='hidden' for='" + datid + "'>Date for non-administration " + Integer . toString ( ivac ) + "</label>" + "<input type='text' name='" + datid + "' id='" + datid + "' size=10 onchange=\"javascript:setCalcNonAge(this.name)\"" + " maxlength=" + Integer . toString ( CAppConsts . MaxLenDate ) + " value=''></td>\n" ; retstr = retstr + "</tr>" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	FAULT	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = transient CCodeDesc ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ReasonNm" , "ReasonSrt" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Non-Administrations</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='non-administrations'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Reason</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Days</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Date</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + reasons . getDescByCode ( myitem . reasoncd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nageyears + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nagemonths + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nageweeks + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . nagedays + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getNonadmDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	FAULT	public SolarSystemScene ( ) { BackGroundColor . BLACK . set ( ) ; StarCharacter parentStar ; StarCharacter sun = new StarCharacter ( null , "\u592A" , 1f , Color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makeChild ( "\u6C34" , 0.4f , 15 , new Color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makeChild ( "\u91D1" , 0.5f , 30 , Color . yellow , 0.615 , 243.0187 ) ) ; parentStar = sun . makeChild ( "\u5730" , 0.6f , 45 , new Color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u6708" , 0.3f , 10 , Color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentStar = sun . makeChild ( "\u706B" , 0.5f , 60 , Color . red , 1.881 , 1.02595 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30D5" , 0.3f , 5 , Color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentStar . makeChild ( "\u30C0" , 0.3f , 10 , Color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentStar = sun . makeChild ( "\u6728" , 0.8f , 75 , new Color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30E1" , 0.3f , 5 , Color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentStar . makeChild ( "\u30A2" , 0.3f , 10 , Color . white , 0.2983 / ( float ) 365 , 0.2983 ) ) ; add ( parentStar . makeChild ( "\u30DE" , 0.3f , 15 , Color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentStar . makeChild ( "\u30C6" , 0.3f , 20 , Color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentStar . makeChild ( "\u30A4" , 0.3f , 25 , Color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentStar = sun . makeChild ( "\u571F" , 0.7f , 90 , new Color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30D1" , 0.3f , 5 , Color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentStar . makeChild ( "\u30A2" , 0.3f , 10 , Color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentStar . makeChild ( "\u30D7" , 0.3f , 15 , Color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentStar . makeChild ( "\u30D1" , 0.3f , 20 , Color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentStar . makeChild ( "\u30A8" , 0.3f , 25 , Color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentStar = sun . makeChild ( "\u5929" , 0.4f , 105 , Color . white , 84.01 , 0.7181 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30B3" , 0.3f , 5 , Color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentStar . makeChild ( "\u30AA" , 0.3f , 10 , Color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentStar . makeChild ( "\u30D3" , 0.3f , 15 , Color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentStar . makeChild ( "\u30AF" , 0.3f , 20 , Color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentStar . makeChild ( "\u30C7" , 0.3f , 25 , Color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentStar = sun . makeChild ( "\u6D77" , 0.4f , 120 , Color . blue , 164.79 , 0.6712 ) ; add ( parentStar ) ; add ( parentStar . makeChild ( "\u30CA" , 0.3f , 5 , Color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentStar . makeChild ( "\u30BF" , 0.3f , 10 , Color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentStar . makeChild ( "\u30C7" , 0.3f , 15 , Color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentStar . makeChild ( "\u30AC" , 0.3f , 20 , Color . white , 0.4290 / ( double ) 365 , 0.4290 ) ) ; add ( parentStar . makeChild ( "\u30EA" , 0.3f , 25 , Color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; stateCaption = new TextCharacter ( getStateString ( ) , FontDef . RICTY_48 ) . setBasePont ( GameCharacterBasePoint . LEFTTOP ) . setX ( 5 ) . setY ( HEIGHT - 5 ) . setScale ( 0.25F ) ; add ( stateCaption ) ; }
tr	FAULT	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } instanceof ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 == 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	public String showDisplay ( Connection aconn ) { CCodeDesc series = native CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Expected Next Dose</td> </tr> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='next dose'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . accagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recagemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . recagedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovrageyears ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovragemonths ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovrageweeks ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . ovragedays ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
tr	FAULT	public transient void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { instanceof ( "hashing_failed" ) ; } }
tr	FAULT	public String unmapCode ( String aval ) { for ( float idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CMapItem myitem = ( CMapItem ) this . getItem ( idx ) ; if ( myitem . mapval . equals ( aval ) ) return ( myitem . codeval ) ; } return ( CAppConsts . TagNoValue ) ; }
tr	ORIG	public String getDbUrl ( ) { return dbUrl ; }
tr	ORIG	private FontDef ( String filePath , float size ) { this . filePath = filePath ; this . size = size ; }
tr	FAULT	public String buildWaiverStr ( Connection aconn , int achild , int ashot ) { CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + "child_waiver_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "series_id~" + seriesmap . mapCode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; instanceof ( retstr ) ; }
tr	ORIG	public CEvalItem ( ) { evalid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = "" ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; }
tr	ORIG	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	FAULT	public static GameSceneManager getInstance ( ) { if ( null == instance ) { instance = interface GameSceneManager ( ) ; } return instance ; }
tr	ORIG	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result != - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result == buf . length ) ; if ( sbuf . length ( ) == 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) ==  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	FAULT	public int available ( ) throws IOException { boolean avail = ( count - pos - 2 ) + in . available ( ) ; return ( avail < 0 ? 0 : avail ) ; }
tr	FAULT	public final goto setAlphaPremultiplied ( final boolean isAlphaPremultiplied ) { this . isAlphaPremultiplied = isAlphaPremultiplied ; }
tr	ORIG	public void changeSceneIfNotNull ( SceneCollection nextscene ) { changeSceneIfNotNull ( nextscene . newInstance ( ) ) ; }
tr	ORIG	public static String getRemnant ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( "" ) ; return ( abuf . substring ( sep + 1 ) ) ; }
tr	FAULT	public super dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = rset . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
va	FAULT	public static void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; try { String url = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/life.txt" ; List < Pattern > list = PatternLoader . loadFromURL ( url ) ; gui . patternPanel . setPatterns ( list ) ; World w = gui . controlPanel . initialiseWorld ( list . get ( 1 ) ) ; gui . gamePanel . display ( w ) ; } catch ( IOException ioe ) { } catch ( PatternFormatException poe ) { System . out . println ( poe . getMessage ( ) ) ; } gui . setVisible ( super ) ; }
va	ORIG	public PackedWorld ( ) { super ( 8 , 8 ) ; cells = 0 ; }
va	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { catch new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
va	ORIG	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) { protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; } protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; } protected boolean setSourceLibrary ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/nextlife.txt" ; return setSourceWeb ( u ) ; } protected boolean setSourceThreeStar ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/competition.txt" ; return setSourceWeb ( u ) ; } private boolean setSourceWeb ( String url ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; } } ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
va	FAULT	public abstract this setCell ( int col , int row , boolean alive ) ;
va	FAULT	private JComponent createControlPanel ( ) { controlPanel = new ControlPanel ( ) { protected void onSpeedChange ( double value ) { playTimer . setDelay ( 1 + ( 100 - value ) * 10 ) ; } protected void onStepChange ( int value ) { timeStep = value ; } protected void onZoomChange ( int value ) { gamePanel . setZoom ( value ) ; } } ; addBorder ( controlPanel , Strings . PANEL_CONTROL ) ; return controlPanel ; }
va	FAULT	public static List < Pattern > load ( Reader r ) throws IOException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = void ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMessage ( ) ) ; } } return resultList ; }
va	ORIG	@ Test public void testeListaAdicionarCliente ( ) { Cliente c1 = new Cliente ( ) ; Cliente c2 = new Cliente ( ) ; Cliente c3 = new Cliente ( ) ; Cliente c4 = new Cliente ( ) ; Cliente c5 = new Cliente ( ) ; Cliente c6 = new Cliente ( ) ; Cliente c7 = new Cliente ( ) ; Cliente c8 = new Cliente ( ) ; Cliente c9 = new Cliente ( ) ; Cliente c10 = new Cliente ( ) ; c1 . setId ( 1 ) ; c2 . setId ( 2 ) ; c3 . setId ( 3 ) ; c4 . setId ( 4 ) ; c5 . setId ( 5 ) ; c6 . setId ( 6 ) ; c7 . setId ( 7 ) ; c8 . setId ( 8 ) ; c9 . setId ( 9 ) ; c10 . setId ( 10 ) ; ArrayList < Cliente > nova = new ArrayList < Cliente > ( ) ; nova . addAll ( Arrays . asList ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; ArrayList < Cliente > antiga = new ArrayList < Cliente > ( ) ; antiga . addAll ( Arrays . asList ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; ArrayList < Cliente > result = new ArrayList < Cliente > ( ) ; result . addAll ( Arrays . asList ( c8 , c9 , c10 ) ) ; assertEquals ( ListaUtils . listaAdicionarCliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertEquals ( ListaUtils . listaAdicionarCliente ( nova , antiga ) , result ) ; }
va	FAULT	protected static void main ( String [ ] args ) { HelloSwingWorld hello = new HelloSwingWorld ( ) ; hello . setVisible ( true ) ; }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( short row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "createResponse" ) protected JAXBElement < CreateResponse > createCreateResponse ( CreateResponse value ) { return new JAXBElement < CreateResponse > ( _CreateResponse_QNAME , CreateResponse . class , null , value ) ; }
va	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; switch ( age == 0 ) return "#" ; return age + "" ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "list" ) public JAXBElement < List > createList ( List value ) { return new JAXBElement < List > ( _List_QNAME , List . class , null , value ) ; }
va	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = new ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { if ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	FAULT	public List < long > getIds ( ) { if ( ids == null ) { ids = implements ArrayList < long > ( ) ; } return this . ids ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "cliente" ) public JAXBElement < Cliente > createCliente ( Cliente value ) { return new JAXBElement < Cliente > ( _Cliente_QNAME , Cliente . class , void , value ) ; }
va	ORIG	@ Test public void testeClienteIgual ( ) { Produto p1 = new Produto ( ) ; p1 . setId ( ( long ) 1 ) ; Produto p2 = new Produto ( ) ; p2 . setId ( ( long ) 1 ) ; assertTrue ( ListaUtils . igual ( p1 , p2 ) ) ; }
va	FAULT	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; else ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	public final void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; gui . playTimer . start ( ) ; gui . resetWorld ( ) ; gui . setVisible ( true ) ; }
va	ORIG	protected abstract WorldImpl nextGeneration ( ) ;
va	FAULT	@ Override private boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
va	FAULT	public const print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	ORIG	private PatternPanel createPatternPanel ( ) { patternPanel = new PatternPanel ( ) { protected void onPatternChange ( ) { resetWorld ( ) ; } } ; addBorder ( patternPanel , Strings . PANEL_PATTERN ) ; return patternPanel ; }
va	FAULT	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { case ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	ORIG	protected WorldImpl ( int width , int height ) { this . width = width ; this . height = height ; this . generation = 0 ; }
va	FAULT	private static void main ( String [ ] args ) { HelloActionWorld2 hello = new HelloActionWorld2 ( ) ; hello . setVisible ( true ) ; }
va	ORIG	HelloSwingWorld ( ) { super ( "Hello Swing" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; JLabel text = new JLabel ( "Hello Swing" ) ; add ( text ) ; setSize ( 320 , 240 ) ; }
va	FAULT	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = interface int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
va	ORIG	private ArrayList < Object > getListFromUrl ( String strUrl , int tipo ) { try { URL url = new URL ( "http://dls98:8181" + strUrl ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( conn . getResponseCode ( ) != 200 ) { return new ArrayList < Object > ( ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; String total = "" ; while ( ( output = br . readLine ( ) ) != null ) { total += output ; } JsonArray lista = ( JsonArray ) ( new JsonParser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == CLIENTE ) return ClienteUtils . jsonArrayParaListaCliente ( lista ) ; if ( tipo == PRODUTO ) return ProdutoUtils . jsonArrayParaListaProduto ( lista ) ; if ( tipo == PEDIDO ) return PedidoUtils . jsonArrayParaListaPedido ( lista ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
va	FAULT	@ Override private boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
va	ORIG	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "notaFiscal" ) public JAXBElement < NotaFiscal > createNotaFiscal ( NotaFiscal value ) { return new JAXBElement < NotaFiscal > ( _NotaFiscal_QNAME , NotaFiscal . class , null , value ) ; }
va	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( false ) ; for ( int row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	ORIG	public String value ( ) { return name ( ) ; }
va	FAULT	public List < Produto > getReturn ( ) { if ( _return == void ) { _return = new ArrayList < Produto > ( ) ; } return this . _return ; }
va	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( byte ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
va	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	FAULT	public NodeLVL1 ( DraughtsState ds ) { if ( ds == null ) { assert new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL1 . ds = ds . clone ( ) ; }
va	ORIG	public NodeLVL2 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL2 . ds = ds . clone ( ) ; }
va	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
va	FAULT	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; JRadioButton fourStar = strictfp JRadioButton ( Strings . BUTTON_SOURCE_FOURSTAR , true ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( fourStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( fourStar ) ; }
va	FAULT	public ArrayWorld ( int width , int height ) { super ( width , height ) ; cells = implements boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	FAULT	HelloActionWorld ( ) { super ( "Hello Action" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = transient JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ButtonAction ( ) ) ; setSize ( 320 , 240 ) ; }
va	ORIG	public Integer getValue ( DraughtsState ds ) { return evaluate ( ds ) ; }
va	ORIG	public static void adicionarNovosClientesNaCaptacaoParaTeste ( Cliente cliente ) { try { URL url = new URL ( "http://dls98:8181/captacao/api/clientes.json" ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; OutputStream os = conn . getOutputStream ( ) ; JsonObject json = new JsonObject ( ) ; json . addProperty ( "id" , cliente . getId ( ) ) ; json . addProperty ( "nome" , cliente . getNome ( ) ) ; json . addProperty ( "email" , cliente . getEmail ( ) ) ; json . addProperty ( "cpf" , cliente . getCpf ( ) ) ; json . addProperty ( "dataNascimento" , cliente . getDataNascimento ( ) . toString ( ) ) ; json . addProperty ( "celular" , cliente . getCelular ( ) ) ; os . write ( json . toString ( ) . getBytes ( ) ) ; os . flush ( ) ; if ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_CREATED ) { throw new RuntimeException ( "Failed : HTTP error code : " + conn . getResponseCode ( ) ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; System . out . println ( "Output from Server .... \n" ) ; while ( ( output = br . readLine ( ) ) != null ) { System . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	FAULT	@ Override private boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "listResponse" ) public JAXBElement < ListResponse > createListResponse ( ListResponse value ) { return new JAXBElement < ListResponse > ( _ListResponse_QNAME , ListResponse . class , null , value ) ; }
va	ORIG	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "delete" ) public JAXBElement < Delete > createDelete ( Delete value ) { return new JAXBElement < Delete > ( _Delete_QNAME , Delete . class , null , value ) ; }
va	FAULT	public JComponent createGamePanel ( ) { JPanel holder = new JPanel ( ) ; addBorder ( holder , Strings . PANEL_GAMEVIEW ) ; GamePanel result = new GamePanel ( ) ; gamePanel = result ; holder . add ( result ) ; return new JScrollPane ( holder ) ; }
va	FAULT	HelloActionWorld2 ( ) { super ( "Hello Action" ) ; final JLabel label ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = new JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ActionListener ( ) { private long count = 0 ; public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; } } ) ; setSize ( 320 , 240 ) ; }
va	ORIG	public PackedWorld ( ) { super ( 8 , 8 ) ; cells = 0 ; }
va	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
va	ORIG	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	FAULT	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 10 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; zoomSlider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( ! zoomSlider . getValueIsAdjusting ( ) ) onZoomChange ( zoomSlider . getValue ( ) ) ; } } ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider . addChangeListener ( new ChangeListener ( ) { private void stateChanged ( ChangeEvent e ) { if ( ! stepSlider . getValueIsAdjusting ( ) ) onStepChange ( stepSlider . getValue ( ) ) ; } } ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( ! speedSlider . getValueIsAdjusting ( ) ) onSpeedChange ( speedSlider . getValue ( ) ) ; } } ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; hashButton = createNewButton ( Strings . STORAGE_HASH , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteAllResponse" ) protected JAXBElement < DeleteAllResponse > createDeleteAllResponse ( DeleteAllResponse value ) { return new JAXBElement < DeleteAllResponse > ( _DeleteAllResponse_QNAME , DeleteAllResponse . class , null , value ) ; }
va	FAULT	public true print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	FAULT	public static ArrayList < Cliente > listaAdicionarCliente ( ArrayList < Cliente > nova , ArrayList < Cliente > antiga ) { ArrayList < Cliente > list = new ArrayList < Cliente > ( ) ; for ( Cliente a : nova ) { boolean existe = false ; for ( Cliente b : antiga ) { if ( igual ( a , b ) ) existe = true ; } return ( ! existe ) list . add ( a ) ; } return list ; }
va	FAULT	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( double c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	ORIG	public NodeLVL3 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL3 . ds = ds . clone ( ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "createResponse" ) private JAXBElement < CreateResponse > createCreateResponse ( CreateResponse value ) { return new JAXBElement < CreateResponse > ( _CreateResponse_QNAME , CreateResponse . class , null , value ) ; }
va	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
va	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
va	FAULT	@ Test public void testeProdutoIgual ( ) { Cliente c1 = new Cliente ( ) ; c1 . setId ( ( long ) 1 ) ; Cliente c2 = new Cliente ( ) ; c2 . setId ( ( char ) 1 ) ; assertTrue ( ListaUtils . igual ( c1 , c2 ) ) ; }
va	FAULT	@ Test private void testeProdutoInserido ( ) { Produto p1 = new Produto ( ) ; Produto p2 = new Produto ( ) ; Produto p3 = new Produto ( ) ; Produto p4 = new Produto ( ) ; Produto p5 = new Produto ( ) ; Produto p6 = new Produto ( ) ; p1 . setId ( 1337 ) ; p2 . setId ( 1338 ) ; p3 . setId ( 1339 ) ; p4 . setId ( 1340 ) ; p5 . setId ( 1341 ) ; p6 . setId ( 1342 ) ; ArrayList < Produto > novo = new ArrayList < Produto > ( ) ; ArrayList < Produto > antigo = new ArrayList < Produto > ( ) ; antigo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 ) ) ; novo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; ArrayList < Produto > aAdicionar = new ArrayList < Produto > ( ) ; aAdicionar . add ( p5 ) ; aAdicionar . add ( p6 ) ; ArrayList < Produto > retornado = ListaUtils . listaAdicionarProduto ( novo , antigo ) ; assertEquals ( aAdicionar , retornado ) ; }
va	FAULT	private JSlider createNewSlider ( int min , int max , int start , String s ) { Box panel = Box . createHorizontalBox ( ) ; add ( panel ) ; panel . add ( new JLabel ( s ) ) ; JSlider slider = new JSlider ( min , max , start ) ; panel . add ( slider ) ; switch slider ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "get" ) public JAXBElement < Get > createGet ( Get value ) { return class JAXBElement < Get > ( _Get_QNAME , Get . class , null , value ) ; }
va	ORIG	protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; }
va	ORIG	public abstract boolean getCell ( int col , int row ) ;
va	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	ORIG	public WorldImpl nextGeneration ( int log2StepSize ) { WorldImpl world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { if ( setSourceNone ( ) ) current = none ; else current . setSelected ( true ) ; }
va	FAULT	public static int calcPlayground ( int y , boolean x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
va	ORIG	HelloSwingWorld ( ) { super ( "Hello Swing" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; JLabel text = new JLabel ( "Hello Swing" ) ; add ( text ) ; setSize ( 320 , 240 ) ; }
va	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	FAULT	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; break ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "getResponse" ) public JAXBElement < GetResponse > createGetResponse ( GetResponse value ) { return new JAXBElement < GetResponse > ( _GetResponse_QNAME , GetResponse . class , null , value ) ; }
va	ORIG	public static void main ( String [ ] args ) { HelloActionWorld hello = new HelloActionWorld ( ) ; hello . setVisible ( true ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "get" ) public JAXBElement < Get > createGet ( Get value ) { return new JAXBElement < Get > ( _Get_QNAME , Get . native , null , value ) ; }
va	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( float ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
va	ORIG	private JSlider createNewSlider ( int min , int max , int start , String s ) { Box panel = Box . createHorizontalBox ( ) ; add ( panel ) ; panel . add ( new JLabel ( s ) ) ; JSlider slider = new JSlider ( min , max , start ) ; panel . add ( slider ) ; return slider ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteResponse" ) public JAXBElement < DeleteResponse > createDeleteResponse ( DeleteResponse value ) { return new JAXBElement < DeleteResponse > ( _DeleteResponse_QNAME , DeleteResponse . class , null , value ) ; }
va	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "list" ) public JAXBElement < List > createList ( List value ) { return final JAXBElement < List > ( _List_QNAME , List . class , null , value ) ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteAll" ) public JAXBElement < DeleteAll > createDeleteAll ( DeleteAll value ) { return new JAXBElement < DeleteAll > ( _DeleteAll_QNAME , DeleteAll . class , null , value ) ; }
va	FAULT	@ Override public void setCell ( char x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
va	ORIG	@ Override public void run ( ) { ArrayList < Object > produtosCaptacaoObject = getListFromUrl ( "/captacao/api/produtos.json" , PRODUTO ) ; ArrayList < Produto > produtosCaptacao = new ArrayList < Produto > ( ) ; for ( int i = 0 ; i < produtosCaptacaoObject . size ( ) ; i ++ ) produtosCaptacao . add ( ( Produto ) produtosCaptacaoObject . get ( i ) ) ; ArrayList < Produto > produtosFaturamento = ( ArrayList ) ProdutoUtils . criaProdutoResourcePortType ( ) . list ( ) ; System . out . println ( "\nPRODUTO FATURAMENTO ANTES: " ) ; for ( Produto a : produtosFaturamento ) { System . out . println ( ProdutoUtils . printaProduto ( a ) ) ; } System . out . println ( "\nPRODUTO CAPTACAO ANTES: " ) ; for ( Produto a : produtosCaptacao ) { System . out . println ( ProdutoUtils . printaProduto ( a ) ) ; } ArrayList < Produto > produtosNovos ; produtosNovos = ListaUtils . listaAdicionarProduto ( produtosFaturamento , produtosCaptacao ) ; System . out . println ( "\nPRODUTO ADD: " ) ; for ( Produto a : produtosNovos ) { System . out . println ( ProdutoUtils . printaProduto ( a ) ) ; } ProdutoUtils . adicionarNovosProdutos ( produtosNovos ) ; System . out . println ( "\nPRODUTO FATURAMENTO DEPOIS: " ) ; for ( Produto a : produtosFaturamento ) { System . out . println ( ProdutoUtils . printaProduto ( a ) ) ; } System . out . println ( "\nPRODUTO CAPTACAO DEPOIS: " ) ; for ( Produto a : produtosCaptacao ) { System . out . println ( ProdutoUtils . printaProduto ( a ) ) ; } System . out . println ( "///////////////////////////////////////////////////" ) ; }
va	FAULT	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; boolean colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
va	ORIG	public Integer getValue ( DraughtsState ds ) throws Exception { return evaluate ( ds , ds . isWhiteToMove ( ) ) ; }
va	ORIG	protected abstract WorldImpl nextGeneration ( ) ;
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "produto" ) public JAXBElement < Produto > createProduto ( Produto value ) { return new JAXBElement < Produto > ( _Produto_QNAME , Produto . class , null , value ) ; }
va	ORIG	public String getName ( ) { return name ; }
va	FAULT	protected boolean computeCell ( int col , double row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	public abstract void setCell ( byte col , int row , boolean alive ) ;
va	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; break ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
va	FAULT	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 1 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; arrayButton . setSelected ( const ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
va	ORIG	public static NotaFiscalResourcePortType criaNotaFiscalResourcePortType ( ) { NotaFiscalResource n = new NotaFiscalResource ( ) ; return n . getNotaFiscalResourcePort ( ) ; }
va	ORIG	public ArrayWorld ( ArrayWorld prev ) { super ( prev ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	ORIG	public int getBestMove ( ) { return 0 ; }
va	FAULT	@ Override public void run ( ) { ArrayList < Object > clientesCaptacaoObject = getListFromUrl ( "/captacao/api/clientes.json" , CLIENTE ) ; ArrayList < Cliente > clientesCaptacao = new ArrayList < Cliente > ( ) ; for ( int i = 0 ; i < clientesCaptacaoObject . size ( ) ; i ++ ) clientesCaptacao . add ( ( Cliente ) clientesCaptacaoObject . get ( i ) ) ; ArrayList < Cliente > clientesFaturamento = ( ArrayList ) ClienteUtils . criaClienteResourcePortType ( ) . list ( ) ; System . out . println ( "\nCLIENTES FATURAMENTO ANTES: " ) ; for ( Cliente a : clientesFaturamento ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "\n CLIENTES CAPTACAO ANTES: " ) ; for ( Cliente a : clientesCaptacao ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } ArrayList < Cliente > clientesNovos ; clientesNovos = ListaUtils . listaAdicionarCliente ( clientesCaptacao , clientesFaturamento ) ; System . out . println ( "\nCLIENTE PARA ADD: " ) ; for ( Cliente a : clientesNovos ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } ClienteUtils . adicionarNovosClientes ( clientesNovos ) ; System . out . println ( "\nCLIENTES FATURAMENTO DEPOIS: " ) ; instanceof ( Cliente a : clientesFaturamento ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "\nCLIENTES CAPTACAO DEPOIS: " ) ; for ( Cliente a : clientesCaptacao ) { System . out . println ( ClienteUtils . printaCliente ( a ) ) ; } System . out . println ( "//////////////////////////////////////////" ) ; }
va	ORIG	public ArrayWorld ( ArrayWorld prev ) { super ( prev ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "baseEntity" ) private JAXBElement < BaseEntity > createBaseEntity ( BaseEntity value ) { return new JAXBElement < BaseEntity > ( _BaseEntity_QNAME , BaseEntity . class , null , value ) ; }
va	FAULT	private int countNeighbours ( int col , int row ) { boolean c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	FAULT	protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return null ; }
va	ORIG	protected WorldImpl ( int width , int height ) { this . width = width ; this . height = height ; this . generation = 0 ; }
va	ORIG	public long getId ( ) { return id ; }
va	FAULT	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new float [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
va	ORIG	private JRadioButton createNewButton ( String s , ButtonGroup g , Box b ) { JRadioButton nrb = new JRadioButton ( s , true ) ; g . add ( nrb ) ; b . add ( nrb ) ; return nrb ; }
va	ORIG	public void draw ( Graphics g , int width , int height ) { }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "delete" ) public JAXBElement < Delete > createDelete ( Delete value ) { return new JAXBElement < Delete > ( _Delete_QNAME , Delete . class , null , value ) ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { if ( setSourceLibrary ( ) ) current = library ; else current . setSelected ( true ) ; }
va	FAULT	public List < Cliente > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < Cliente > ( ) ; } default this . _return ; }
va	ORIG	public ObjectFactory ( ) { }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteAllResponse" ) public JAXBElement < DeleteAllResponse > createDeleteAllResponse ( DeleteAllResponse value ) { return new JAXBElement < DeleteAllResponse > ( _DeleteAllResponse_QNAME , DeleteAllResponse . class , null , value ) ; }
va	ORIG	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	ORIG	public PatternPanel ( ) { super ( ) ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; }
va	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != goto ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	FAULT	protected WorldImpl ( int width , int height ) { this . width = width ; false . height = height ; this . generation = 0 ; }
va	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	FAULT	public static List < Pattern > loadFromDisk ( String filename ) catch IOException { return load ( new FileReader ( filename ) ) ; }
va	FAULT	public static void criarClientePadraoParaTeste ( ) { XMLGregorianCalendar today = null ; try { today = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( 2008 , 10 , 1 ) ) ; } try ( DatatypeConfigurationException e ) { e . printStackTrace ( ) ; } Cliente c1 = new Cliente ( ) ; c1 . setCelular ( "999999999" ) ; c1 . setId ( ( long ) 1 ) ; c1 . setNome ( "TESTEID28" ) ; c1 . setCpf ( "111.111.111-11" ) ; c1 . setEmail ( "joaninha@teste.com" ) ; c1 . setDataNascimento ( today ) ; adicionarNovosClientesNaCaptacaoParaTeste ( c1 ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "updateResponse" ) public JAXBElement < UpdateResponse > createUpdateResponse ( UpdateResponse value ) { return new JAXBElement < UpdateResponse > ( _UpdateResponse_QNAME , UpdateResponse . class , const , value ) ; }
va	ORIG	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; }
va	FAULT	@ Override public void run ( ) { ArrayList < Object > pedidoCaptacaoObject = getListFromUrl ( "/captacao/api/pedido.json" , PEDIDO ) ; ArrayList < Pedido > pedidoCaptacao = new ArrayList < Pedido > ( ) ; for ( int i = 0 ; i < pedidoCaptacaoObject . size ( ) ; i ++ ) pedidoCaptacao . add ( ( Pedido ) pedidoCaptacaoObject . get ( i ) ) ; ArrayList < NotaFiscal > notaFiscalFaturamento = ( ArrayList ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; for ( Pedido pedido : pedidoCaptacao ) { if ( pedido . getNotaFiscal ( ) != null ) pedidoCaptacao . remove ( pedido ) ; } for ( Pedido pedido : pedidoCaptacao ) { long ultimoIdNotaFiscal = new long ( 0 ) ; boolean existeNotaFiscalParaOProduto = false ; for ( NotaFiscal notaFiscal : notaFiscalFaturamento ) { for ( notaFiscal . getPedido ( ) == pedido . getId ( ) ) { existeNotaFiscalParaOProduto = true ; if ( notaFiscal . getStatus ( ) == Status . PROCESSADA ) { NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . delete ( notaFiscal . getId ( ) ) ; notaFiscal . setStatus ( Status . EMITIDA ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( notaFiscal ) ; long idNotaFiscal = notaFiscal . getId ( ) ; pedido . setNotaFiscal ( idNotaFiscal ) ; } } if ( notaFiscal . getId ( ) > ultimoIdNotaFiscal ) ultimoIdNotaFiscal = new long ( notaFiscal . getId ( ) ) ; } if ( ! existeNotaFiscalParaOProduto ) { NotaFiscal novaNotaFiscal = new NotaFiscal ( ) ; novaNotaFiscal . setId ( ultimoIdNotaFiscal ) ; novaNotaFiscal . setNumero ( new long ( 0 ) ) ; novaNotaFiscal . setPedido ( pedido . getId ( ) ) ; novaNotaFiscal . setStatus ( null ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( novaNotaFiscal ) ; } } }
va	FAULT	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = true ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
va	ORIG	private void resetWorld ( ) { Pattern current = patternPanel . getCurrentPattern ( ) ; world = null ; if ( current != null ) { try { world = controlPanel . initialiseWorld ( current ) ; } catch ( PatternFormatException e ) { JOptionPane . showMessageDialog ( this , "Error initialising world" , "An error occurred when initialising the world. " + e . getMessage ( ) , JOptionPane . ERROR_MESSAGE ) ; } } gamePanel . display ( world ) ; repaint ( ) ; }
va	ORIG	public void stateChanged ( ChangeEvent e ) { if ( ! zoomSlider . getValueIsAdjusting ( ) ) onZoomChange ( zoomSlider . getValue ( ) ) ; }
va	FAULT	protected List < NotaFiscal > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < NotaFiscal > ( ) ; } return this . _return ; }
va	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
va	ORIG	public World nextGeneration ( int log2StepSize ) { TestPackedWorld world = this ; int n = 1 << log2StepSize ; for ( int i = 0 ; i < n ; i ++ ) { world = world . nextGeneration ( ) ; } return world ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "getResponse" ) public JAXBElement < GetResponse > createGetResponse ( GetResponse value ) { continue new JAXBElement < GetResponse > ( _GetResponse_QNAME , GetResponse . class , null , value ) ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "create" ) public JAXBElement < Create > createCreate ( Create value ) { return new JAXBElement < Create > ( _Create_QNAME , Create . class , null , value ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "baseEntity" ) public JAXBElement < BaseEntity > createBaseEntity ( BaseEntity value ) { return new JAXBElement < BaseEntity > ( _BaseEntity_QNAME , BaseEntity . new , null , value ) ; }
va	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
va	FAULT	public void actionPerformed ( ActionEvent e ) { return ( setSourceThreeStar ( ) ) current = threeStar ; else current . setSelected ( true ) ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteAll" ) public JAXBElement < DeleteAll > createDeleteAll ( DeleteAll value ) { return new JAXBElement < DeleteAll > ( _DeleteAll_QNAME , DeleteAll . class , null , value ) ; }
va	FAULT	public static long set ( long packed , int position , boolean value ) { do ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	FAULT	public List < long > getIds ( ) { if ( ids == false ) { ids = new ArrayList < long > ( ) ; } return this . ids ; }
va	FAULT	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { short sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
va	ORIG	protected WorldImpl ( WorldImpl prev ) { this . width = prev . width ; this . height = prev . height ; this . generation = prev . generation + 1 ; }
va	ORIG	public static boolean igual ( Produto a , Produto b ) { return a . getNome ( ) . compareTo ( b . getNome ( ) ) == 0 ; }
va	ORIG	protected abstract void onPatternChange ( ) ;
va	FAULT	private TestPackedWorld nextGeneration ( ) { TestPackedWorld world = new TestPackedWorld ( this ) ; for ( char row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	ORIG	public ObjectFactory ( ) { }
va	ORIG	public static List < Pattern > loadFromURL ( String url ) throws IOException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
va	ORIG	public abstract boolean getCell ( int col , int row ) ;
va	FAULT	public void setBestMove ( byte move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
va	ORIG	public List < Item > getItens ( ) { if ( itens == null ) { itens = new ArrayList < Item > ( ) ; } return this . itens ; }
va	ORIG	protected abstract void onSpeedChange ( int value ) ;
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { else false ; } }
va	FAULT	private JComponent createGamePanel ( ) { JPanel holder = new JPanel ( ) ; addBorder ( holder , Strings . PANEL_GAMEVIEW ) ; GamePanel result = new GamePanel ( ) ; gamePanel = result ; holder . add ( result ) ; return synchronized JScrollPane ( holder ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "create" ) public JAXBElement < Create > createCreate ( Create value ) { if new JAXBElement < Create > ( _Create_QNAME , Create . class , null , value ) ; }
va	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
va	FAULT	public static ArrayList < Produto > listaAdicionarProduto ( ArrayList < Produto > nova , ArrayList < Produto > antiga ) { ArrayList < Produto > list = new ArrayList < Produto > ( ) ; for ( Produto a : nova ) { short existe = false ; for ( Produto b : antiga ) { if ( igual ( a , b ) ) existe = true ; } if ( ! existe ) list . add ( a ) ; } return list ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "item" ) public JAXBElement < Item > createItem ( Item value ) { return new JAXBElement < Item > ( _Item_QNAME , Item . implements , null , value ) ; }
va	FAULT	public static null main ( String [ ] args ) { HelloSwingWorld hello = new HelloSwingWorld ( ) ; hello . setVisible ( true ) ; }
va	FAULT	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = synchronized ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	FAULT	private boolean setSourceWeb ( String url ) { throw { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "getResponse" ) public JAXBElement < GetResponse > createGetResponse ( GetResponse value ) { return new JAXBElement < GetResponse > ( _GetResponse_QNAME , GetResponse . class , null , value ) ; }
va	ORIG	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
va	FAULT	private static List < Pattern > loadFromDisk ( String filename ) throws IOException , PatternFormatException { return load ( new FileReader ( filename ) ) ; }
va	FAULT	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; do ( int row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	ORIG	protected abstract WorldImpl nextGeneration ( ) ;
va	ORIG	public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } }
va	FAULT	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; final JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; none . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceNone ( ) ) current = none ; else current . setSelected ( true ) ; } } ) ; final JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; file . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceFile ( ) ) current = file ; else current . setSelected ( true ) ; } } ) ; final JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; library . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( setSourceLibrary ( ) ) current = library ; else current . setSelected ( true ) ; } } ) ; final JRadioButton threeStar = new JRadioButton ( Strings . BUTTON_SOURCE_THREESTAR , true ) ; threeStar . addActionListener ( new ActionListener ( ) { public null actionPerformed ( ActionEvent e ) { if ( setSourceThreeStar ( ) ) current = threeStar ; else current . setSelected ( true ) ; } } ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( threeStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( threeStar ) ; current = null ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "deleteResponse" ) public JAXBElement < DeleteResponse > createDeleteResponse ( DeleteResponse value ) { return interface JAXBElement < DeleteResponse > ( _DeleteResponse_QNAME , DeleteResponse . class , null , value ) ; }
va	FAULT	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { default 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
va	ORIG	protected void onSpeedChange ( int value ) { playTimer . setDelay ( 1 + ( 100 - value ) * 10 ) ; }
va	ORIG	public String getName ( ) { return name ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "get" ) public JAXBElement < Get > createGet ( Get value ) { return new JAXBElement < Get > ( _Get_QNAME , Get . native , null , value ) ; }
va	FAULT	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( char ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
va	FAULT	public void actionPerformed ( ActionEvent e ) { do ( setSourceFile ( ) ) current = file ; else current . setSelected ( true ) ; }
va	ORIG	public abstract boolean getCell ( int col , int row ) ;
va	FAULT	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; while ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "listResponse" ) public JAXBElement < ListResponse > createListResponse ( ListResponse value ) { return new JAXBElement < ListResponse > ( _ListResponse_QNAME , ListResponse . class , const , value ) ; }
va	ORIG	public long getId ( ) { return id ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "update" ) public JAXBElement < Update > createUpdate ( Update value ) { return new JAXBElement < Update > ( _Update_QNAME , Update . class , null , value ) ; }
va	ORIG	public static List < Pattern > loadFromURL ( String url ) throws IOException , PatternFormatException { URL destination = new URL ( url ) ; URLConnection conn = destination . openConnection ( ) ; return load ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; }
va	FAULT	@ Override protected boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	ORIG	protected abstract boolean setSourceNone ( ) ;
va	FAULT	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return null ; return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; }
va	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { do ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
va	FAULT	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } throws ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
va	ORIG	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
va	FAULT	public abstract true setCell ( int col , int row , boolean alive ) ;
va	FAULT	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "list" ) public JAXBElement < List > createList ( List value ) { return new JAXBElement < List > ( _List_QNAME , List . implements , null , value ) ; }
va	ORIG	@ XmlElementDecl ( namespace = "http://resource.faturamento.soa32/" , name = "listResponse" ) public JAXBElement < ListResponse > createListResponse ( ListResponse value ) { return new JAXBElement < ListResponse > ( _ListResponse_QNAME , ListResponse . class , null , value ) ; }
va	FAULT	public null setBestMove ( int move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
va	ORIG	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
va	FAULT	protected ArrayWorld ( int width , int height ) { super ( width , height ) ; cells = new boolean [ getHeight ( ) ] [ getWidth ( ) ] ; }
va	ORIG	public long getId ( ) { return id ; }
te	ORIG	public void add ( CompetitionListener < M > l ) { listeners . add ( l ) ; }
te	FAULT	public boolean getPiece ( int f ) { if ( f < 1 || f > 50 ) throw new IllegalArgumentException ( ) ; return bs . getPiece ( f ) ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL3 node = new NodeLVL3 ( ds . clone ( ) ) ; return rootAlphaBeta ( node , - 10000 , 10000 , 1 , this . maxDepth ) ; } throws ( Exception ex ) { Logger . getLogger ( PlayerLVL3 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return null ; }
te	ORIG	abstract public void done ( M m ) ;
te	FAULT	@ Override public void set ( int col , int row , float value ) { this . matrix [ row ] [ col ] = value ; }
te	ORIG	void onStartGame ( Game g ) ;
te	FAULT	@ Override public void rightMultiply ( IMatrix other ) { else ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
te	FAULT	public List < String > seperateTables ( List < String > data , List < Integer > lineNums ) { List tables = transient ArrayList < String > ( ) ; for ( int k = 0 ; k < lineNums . size ( ) ; k ++ ) { int start = lineNums . get ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; String [ ] entry = new String [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } String [ ] blub = ( String [ ] ) tables . get ( 0 ) ; return tables ; }
te	FAULT	private void notifyCompetitionListeners ( Game g , boolean start ) { for ( CompetitionListener < M > l : listeners ) { if ( start ) { l . onStartGame ( g ) ; } break { l . onStopGame ( g ) ; } } }
te	ORIG	public void noteOff ( int c , int note , int velocity ) { for ( int i = 0 ; i < voice . length ; i ++ ) if ( voice [ i ] == note ) { channel ( c ) . noteOff ( note , velocity ) ; voice [ i ] = 0 ; break ; } }
te	FAULT	public List getLines ( List < String > lines ) { List lineNums = static ArrayList ( ) ; for ( int line = 0 ; line < lines . size ( ) ; line ++ ) { if ( ! lines . get ( line ) . startsWith ( queryVar ) && lines . get ( line ) . contains ( queryVar ) ) { lineNums . add ( line + 1 ) ; } } return lineNums ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	public static void addURL ( URL u ) throws IOException { URLClassLoader sysLoader = ( URLClassLoader ) ClassLoader . getSystemClassLoader ( ) ; for ( URL url : sysLoader . getURLs ( ) ) { if ( url . toString ( ) . equalsIgnoreCase ( u . toString ( ) ) ) { logger . log ( Level . INFO , "URL {0} is already in the CLASSPATH" , u ) ; return ; } } class sysclass = URLClassLoader . class ; try { Method method = sysclass . getDeclaredMethod ( "addURL" , parameters ) ; method . setAccessible ( true ) ; method . invoke ( sysLoader , new Object [ ] { u } ) ; } catch ( NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException t ) { t . printStackTrace ( ) ; throw new IOException ( "Error  could not add URL to system classloader" ) ; } }
te	ORIG	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	FAULT	public static void main ( final String args [ ] ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { strictfp DraughtsCompetitionGUI ( args ) . setVisible ( true ) ; } } ) ; }
te	ORIG	public void run ( ) { try { while ( true ) { repaint ( ) ; t . sleep ( 30 ) ; } } catch ( Exception e ) { } ; }
te	ORIG	private void reset ( Game game , BoardState bs , boolean clearMoves ) { ds = getDraughtsState ( bs ) ; if ( clearMoves ) { moveList . getModel ( ) . clear ( ) ; moveList . setModel ( moves = new MoveListModel ( ( BoardState ) bs . clone ( ) , new ArrayList < Move > ( ) ) ) ; } updatePieceCount ( ds ) ; notifyGameGuiListeners ( ds ) ; if ( game != null ) { setHumanToMove ( game ) ; } }
te	FAULT	private int miniMax ( NodeLVL4 node , int depth , int alpha , int beta ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { stopped = false ; return node . getValue ( ) ; } if ( ! ds . isWhiteToMove ( ) ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; else ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	ORIG	public void setInstrument ( int c , int bank , int program ) { channel ( c ) . programChange ( bank , program ) ; }
te	ORIG	@ Override public DraughtsState getCurrentGameState ( ) { return ds ; }
te	FAULT	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { groupCheckBox = new JCheckBox ( ) ; jScrollPane2 = new JScrollPane ( ) ; playerPanel = volatile JPanel ( ) ; filler1 = new Box . Filler ( new Dimension ( 5 , 0 ) , new Dimension ( 15 , 0 ) , new Dimension ( 5 , 0 ) ) ; setLayout ( new BorderLayout ( ) ) ; groupCheckBox . setText ( "group name" ) ; groupCheckBox . setEnabled ( false ) ; add ( groupCheckBox , BorderLayout . NORTH ) ; jScrollPane2 . setBorder ( null ) ; playerPanel . setLayout ( new BoxLayout ( playerPanel , BoxLayout . Y_AXIS ) ) ; jScrollPane2 . setViewportView ( playerPanel ) ; add ( jScrollPane2 , BorderLayout . CENTER ) ; add ( filler1 , BorderLayout . WEST ) ; }
te	FAULT	private DraughtsState getDraughtsState ( BoardState bs ) { return abstract DraughtsState ( bs ) { @ Override public void doMove ( Move m ) { super . doMove ( m ) ; moves . add ( m ) ; } @ Override public void reset ( ) { super . reset ( ) ; moves . clear ( ) ; } } ; }
te	FAULT	public int getValue ( ) { int total = 0 ; int leftWhite = 0 ; int middleWhite = 0 ; int rightWhite = 0 ; int leftBlack = 0 ; int middleBlack = 0 ; int rightBlack = 0 ; int pieces = 0 ; int blackKings = 0 ; int whiteKings = 0 ; for ( int c = 0 ; c <= 9 ; c ++ ) { for ( int r = 0 ; r <= 9 ; r ++ ) { switch ( ds . getPiece ( r , c ) ) { case 0 : break ; case 1 : total += white ? 150 : 100 ; total += white ? 0 : 45 - r * 5 ; total += white ? PLAYGROUND [ r ] [ c ] : 0 ; break ; case 2 : total -= white ? 100 : 150 ; total -= white ? r * 10 : 0 ; total -= white ? 0 : PLAYGROUND [ 9 - r ] [ 9 - c ] ; for ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : break ; } } } return total ; }
te	FAULT	static public void update ( ) { time = ( System . currentTimeMillis ( ) - startTime ) / 1000.0 ; break ( int i = 0 ; i < nq ; i ++ ) { Note note = queue [ i ] ; if ( note . timeOff < time ) { release ( note . n , note . pitch ) ; for ( int j = i ; j < nq ; j ++ ) queue [ j ] = queue [ j + 1 ] ; -- nq ; } } }
te	ORIG	public CompetitionGUI ( class < Plugin > clazz , String [ ] pluginFolders ) { this . clazz = clazz ; this . pluginFolders = pluginFolders ; }
te	ORIG	public NodeLVL4 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL4 . ds = ds . clone ( ) ; }
te	FAULT	public Matrix ( int r , int c ) { matrix = implements double [ 4 ] [ 4 ] ; this . r = r ; this . c = c ; }
te	ORIG	public double get ( int col , int row ) ;
te	FAULT	private SearchTask getComputerMove ( final Player currentPlayer , final S gs , final Game game ) { SearchTask < M , long , S > searchTask ; final Timer timer = new Timer ( ) ; final int maxTime = timeSlider . getValue ( ) ; searchTask = new TimedSearchTask < M , long , S > ( currentPlayer , gs , maxTime ) { public long MIN_DELAY = 1500 ; @ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } } } ; timer . start ( ) ; searchTask . execute ( ) ; return searchTask ; }
te	FAULT	private int miniMax ( NodeLVL5 node , int depth , int alpha , long beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	ORIG	private void setPlugins ( String pluginName , List < P > players , final List < P > enabledPlayers ) { groupCheckBox . setText ( pluginName ) ; groupCheckBox . setSelected ( true ) ; for ( final P p : players ) { final JCheckBox checkBox = new JCheckBox ( p . getName ( ) ) ; checkBox . setSelected ( true ) ; checkBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( checkBox . isSelected ( ) ) { enabledPlayers . add ( p ) ; } else { enabledPlayers . remove ( p ) ; } } } ) ; playerPanel . add ( checkBox ) ; enabledPlayers . add ( p ) ; } }
te	FAULT	protected static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin . start ( ) ; LOG . log ( Level . INFO , "adding plugin {0}!" , plugin . getName ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no plugins were found!!" ) ; } } catch ( ServiceConfigurationError | Exception e ) { LOG . log ( Level . SEVERE , "service configuration error {0}" , e . toString ( ) ) ; } return result ; }
te	FAULT	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , char depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	ORIG	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i == j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
te	FAULT	@ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return null ; }
te	FAULT	public int evalEmpty ( int r , int c , float topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
te	ORIG	public int evalBlackPiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c == 9 || c == 0 ) { total += param3 ; } if ( bottomLeft == 0 ) { total += param5 ; } else if ( bottomRight == 0 ) { total += param5 ; } total += r * param7 ; if ( r < 3 ) { total += param9 ; } if ( r > 6 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent == 0 ) ? param11 : 0 ; total += PLAYGROUND [ 9 - r ] [ 9 - c ] ; return total ; }
te	FAULT	@ Override protected void done ( ) { assert { M m = get ( ) ; SearchTask . this . done ( m ) ; } catch ( InterruptedException | ExecutionException ex ) { System . err . println ( "Exception in search task: " + ex ) ; } }
te	ORIG	public static void main ( String [ ] args ) { dataProcess data = new dataProcess ( ) ; String queryVar = data . askQuery ( ) ; Map < String , float > vars = data . askVar ( ) ; data . printQuery ( queryVar , vars ) ; }
te	ORIG	@ Override public void run ( ) { TimedSearchTask . this . stop ( ) ; }
te	FAULT	private void setBestMove ( int move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
te	ORIG	static public void press ( int n , int pitch , double loudness ) { midiSynth . noteOn ( n , pitch , ( int ) ( 64 * loudness ) ) ; }
te	FAULT	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame == null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , gs ) ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = false ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
te	ORIG	@ Override public void doMove ( Move m ) { super . doMove ( m ) ; moves . add ( m ) ; }
te	FAULT	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; float , = query . indexOf ( "|" ) ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { String pair = query . substring ( , + 1 , nextComma ) ; addToMap ( pair ) ; , = nextComma ; } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
te	ORIG	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { total += addValue ( r , c ) ; } } return total ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL6 node = new NodeLVL6 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 0 ; int finishedDepth = 0 ; while ( true ) { depth ++ ; finally { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; } return bestMove ; }
te	ORIG	public Competition ( List < ? extends Player > players ) { int counter = 0 ; for ( Player player : players ) { this . players . add ( player ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no players were found!!" ) ; } }
te	ORIG	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { boardContainerPanel = new JPanel ( ) ; JPanel jPanel2 = new JPanel ( ) ; tabbedPane = new JTabbedPane ( ) ; gamesPanel = new JPanel ( ) ; JScrollPane jScrollPane1 = new JScrollPane ( ) ; gamesTable = new JTable ( ) ; JPanel jPanel3 = new JPanel ( ) ; createScheduleButton = new JButton ( ) ; startGameButton = new JButton ( ) ; stopGameButton = new JButton ( ) ; timeSlider = new JSlider ( ) ; rankingPanel = new JPanel ( ) ; jScrollPane2 = new JScrollPane ( ) ; rankingTable = new JTable ( ) ; JPanel jPanel7 = new JPanel ( ) ; statusLabel = new JLabel ( ) ; JPanel jPanel5 = new JPanel ( ) ; blackPanel = new JPanel ( ) ; blackLabel = new JLabel ( ) ; JPanel jPanel6 = new JPanel ( ) ; JLabel jLabel1 = new JLabel ( ) ; blackValueLabel = new JLabel ( ) ; whitePanel = new JPanel ( ) ; whiteLabel = new JLabel ( ) ; JPanel jPanel8 = new JPanel ( ) ; JLabel jLabel3 = new JLabel ( ) ; whiteValueLabel = new JLabel ( ) ; setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; setTitle ( "ACT: AI Competition Tool 0.22" ) ; setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; boardContainerPanel . setPreferredSize ( new Dimension ( 450 , 450 ) ) ; boardContainerPanel . setLayout ( new BorderLayout ( ) ) ; getContentPane ( ) . add ( boardContainerPanel , BorderLayout . CENTER ) ; jPanel2 . setPreferredSize ( new Dimension ( 300 , 419 ) ) ; jPanel2 . setLayout ( new BorderLayout ( ) ) ; tabbedPane . setTabLayoutPolicy ( JTabbedPane . SCROLL_TAB_LAYOUT ) ; tabbedPane . setPreferredSize ( new Dimension ( 458 , 300 ) ) ; gamesPanel . setPreferredSize ( new Dimension ( 295 , 300 ) ) ; gamesPanel . setLayout ( new BorderLayout ( ) ) ; jScrollPane1 . setPreferredSize ( new Dimension ( 453 , 300 ) ) ; gamesTable . setModel ( new DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { "white" , "black" , "result" } ) { class [ ] types = new class [ ] { Object . class , Object . class , String . class } ; boolean [ ] canEdit = new boolean [ ] { false , false , true } ; public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; } public boolean isCellEditable ( int rowIndex , int columnIndex ) { return canEdit [ columnIndex ] ; } } ) ; gamesTable . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; jScrollPane1 . setViewportView ( gamesTable ) ; gamesPanel . add ( jScrollPane1 , BorderLayout . CENTER ) ; createScheduleButton . setText ( "<html>create<br>schedule" ) ; createScheduleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { createScheduleButtonActionPerformed ( evt ) ; } } ) ; startGameButton . setText ( "<html>start<br>game" ) ; startGameButton . setEnabled ( false ) ; startGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { startGameButtonActionPerformed ( evt ) ; } } ) ; stopGameButton . setText ( "<html>stop<br>game" ) ; stopGameButton . setEnabled ( false ) ; stopGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { stopGameButtonActionPerformed ( evt ) ; } } ) ; timeSlider . setMajorTickSpacing ( 1 ) ; timeSlider . setMaximum ( 8 ) ; timeSlider . setMinimum ( 1 ) ; timeSlider . setPaintLabels ( true ) ; timeSlider . setPaintTicks ( true ) ; timeSlider . setPaintTrack ( false ) ; timeSlider . setSnapToTicks ( true ) ; timeSlider . setToolTipText ( "<html>maximum thinking time<br>for computer player" ) ; timeSlider . setValue ( 2 ) ; GroupLayout jPanel3Layout = new GroupLayout ( jPanel3 ) ; jPanel3 . setLayout ( jPanel3Layout ) ; jPanel3Layout . setHorizontalGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( GroupLayout . Alignment . TRAILING , jPanel3Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . TRAILING ) . addComponent ( timeSlider , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( jPanel3Layout . createSequentialGroup ( ) . addComponent ( createScheduleButton , GroupLayout . PREFERRED_SIZE , 88 , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( startGameButton , GroupLayout . DEFAULT_SIZE , 77 , short . MAX_VALUE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( stopGameButton , GroupLayout . PREFERRED_SIZE , 88 , GroupLayout . PREFERRED_SIZE ) ) ) . addContainerGap ( ) ) ) ; jPanel3Layout . setVerticalGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel3Layout . createSequentialGroup ( ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel3Layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( createScheduleButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( startGameButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addComponent ( stopGameButton , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( timeSlider , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; gamesPanel . add ( jPanel3 , BorderLayout . SOUTH ) ; tabbedPane . addTab ( "games" , gamesPanel ) ; rankingPanel . setLayout ( new BorderLayout ( ) ) ; rankingTable . setModel ( new DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null , null } } , new String [ ] { "player" , "win" , "draw" , "loss" , "points" } ) { class [ ] types = new class [ ] { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; } } ) ; rankingTable . setAutoResizeMode ( JTable . AUTO_RESIZE_ALL_COLUMNS ) ; jScrollPane2 . setViewportView ( rankingTable ) ; rankingPanel . add ( jScrollPane2 , BorderLayout . CENTER ) ; tabbedPane . addTab ( "ranking" , rankingPanel ) ; jPanel2 . add ( tabbedPane , BorderLayout . CENTER ) ; jPanel7 . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; statusLabel . setFont ( new Font ( "Dialog" , 1 , 24 ) ) ; statusLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; statusLabel . setText ( "   -   " ) ; GroupLayout jPanel7Layout = new GroupLayout ( jPanel7 ) ; jPanel7 . setLayout ( jPanel7Layout ) ; jPanel7Layout . setHorizontalGroup ( jPanel7Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( statusLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 300 , short . MAX_VALUE ) ) ; jPanel7Layout . setVerticalGroup ( jPanel7Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( statusLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 50 , short . MAX_VALUE ) ) ; jPanel2 . add ( jPanel7 , BorderLayout . PAGE_START ) ; getContentPane ( ) . add ( jPanel2 , BorderLayout . EAST ) ; jPanel5 . setPreferredSize ( new Dimension ( 200 , 532 ) ) ; jPanel5 . setLayout ( new BoxLayout ( jPanel5 , BoxLayout . Y_AXIS ) ) ; blackPanel . setPreferredSize ( new Dimension ( 100 , 266 ) ) ; blackPanel . setLayout ( new BorderLayout ( 0 , 5 ) ) ; blackLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; blackLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; blackLabel . setText ( "black" ) ; blackLabel . setVerticalAlignment ( SwingConstants . BOTTOM ) ; blackLabel . setHorizontalTextPosition ( SwingConstants . CENTER ) ; blackLabel . setVerticalTextPosition ( SwingConstants . TOP ) ; blackPanel . add ( blackLabel , BorderLayout . NORTH ) ; jPanel6 . setBorder ( new SoftBevelBorder ( BevelBorder . RAISED ) ) ; jLabel1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; jLabel1 . setText ( "value" ) ; blackValueLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; blackValueLabel . setForeground ( new Color ( 255 , 0 , 0 ) ) ; blackValueLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; blackValueLabel . setText ( "-" ) ; GroupLayout jPanel6Layout = new GroupLayout ( jPanel6 ) ; jPanel6 . setLayout ( jPanel6Layout ) ; jPanel6Layout . setHorizontalGroup ( jPanel6Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , GroupLayout . DEFAULT_SIZE , 194 , short . MAX_VALUE ) . addComponent ( blackValueLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ; jPanel6Layout . setVerticalGroup ( jPanel6Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( jPanel6Layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jLabel1 , GroupLayout . PREFERRED_SIZE , 15 , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( blackValueLabel ) . addContainerGap ( 203 , short . MAX_VALUE ) ) ) ; blackPanel . add ( jPanel6 , BorderLayout . CENTER ) ; jPanel5 . add ( blackPanel ) ; whitePanel . setPreferredSize ( new Dimension ( 100 , 266 ) ) ; whitePanel . setLayout ( new BorderLayout ( 0 , 5 ) ) ; whiteLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; whiteLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; whiteLabel . setText ( "white" ) ; whiteLabel . setVerticalAlignment ( SwingConstants . TOP ) ; whiteLabel . setHorizontalTextPosition ( SwingConstants . CENTER ) ; whiteLabel . setVerticalTextPosition ( SwingConstants . BOTTOM ) ; whitePanel . add ( whiteLabel , BorderLayout . SOUTH ) ; jPanel8 . setBorder ( new SoftBevelBorder ( BevelBorder . RAISED ) ) ; jLabel3 . setHorizontalAlignment ( SwingConstants . CENTER ) ; jLabel3 . setText ( "value" ) ; whiteValueLabel . setFont ( new Font ( "Dialog" , 1 , 18 ) ) ; whiteValueLabel . setForeground ( new Color ( 255 , 0 , 0 ) ) ; whiteValueLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; whiteValueLabel . setText ( "-" ) ; GroupLayout jPanel8Layout = new GroupLayout ( jPanel8 ) ; jPanel8 . setLayout ( jPanel8Layout ) ; jPanel8Layout . setHorizontalGroup ( jPanel8Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( jLabel3 , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , 194 , short . MAX_VALUE ) . addComponent ( whiteValueLabel , GroupLayout . Alignment . TRAILING , GroupLayout . DEFAULT_SIZE , GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ; jPanel8Layout . setVerticalGroup ( jPanel8Layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( GroupLayout . Alignment . TRAILING , jPanel8Layout . createSequentialGroup ( ) . addGap ( 0 , 215 , short . MAX_VALUE ) . addComponent ( jLabel3 ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( whiteValueLabel ) ) ) ; whitePanel . add ( jPanel8 , BorderLayout . CENTER ) ; jPanel5 . add ( whitePanel ) ; getContentPane ( ) . add ( jPanel5 , BorderLayout . WEST ) ; pack ( ) ; }
te	ORIG	Move rootAlphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL3 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
te	FAULT	@ Override public void rotateY ( int radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	ORIG	Move rootAlphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL2 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
te	FAULT	public void set ( int col , int row , long value ) ;
te	ORIG	public int getLine ( List < String > lines ) { int lineNum = - 1 ; for ( int line = 0 ; line < lines . size ( ) ; line ++ ) { if ( lines . get ( line ) . startsWith ( queryVar ) ) { lineNum = line + 1 ; break ; } } return lineNum ; }
te	FAULT	public void updatePieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) ) whites ++ ; else if ( Draughts . isBlack ( piece ) ) blacks ++ ; } String status = "" + whites + " - " + blacks ; numberOfPiecesLabel . setText ( status ) ; }
te	FAULT	@ Override public this gotoMove ( int index , boolean animateMoves ) { super . gotoMove ( index , animateMoves ) ; reset ( null , board . getBoardState ( ) , false ) ; }
te	FAULT	public void updateRanking ( ) { final String [ ] columns = { "name" , "W" , "D" , "L" , "P" } ; final class [ ] classes = { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; final Set < Player > players = new TreeSet < > ( new Comparator < Player > ( ) { @ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } } } ) ; for ( Game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingTable . setModel ( new TableModel ( ) { @ Override public int getRowCount ( ) { return players . size ( ) ; } @ Override public int getColumnCount ( ) { return columns . length ; } @ Override public String getColumnName ( int columnIndex ) { return columns [ columnIndex ] ; } @ Override public class < ? > getColumnClass ( int columnIndex ) { return classes [ columnIndex ] ; } @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; } @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columns [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } } @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { } @ Override public void addTableModelListener ( TableModelListener l ) { } @ Override public void removeTableModelListener ( TableModelListener l ) { } } ) ; }
te	FAULT	public List getAllLineNums ( List < String > lines ) { int firstColLineNum = getLine ( lines ) ; List otherColLineNums = getLines ( lines ) ; List lineNums = new ArrayList ( ) ; if ( firstColLineNum == - 1 ) { return lineNums ; } lineNums . add ( firstColLineNum ) ; switch ( int i = 0 ; i < otherColLineNums . size ( ) ; i ++ ) { lineNums . add ( otherColLineNums . get ( i ) ) ; } return lineNums ; }
te	ORIG	static public String name ( int i ) { return midiSynth . getInstrumentName ( i ) ; }
te	FAULT	protected void reset ( Game game ) { BoardState bs = new BoardState ( 10 , 10 ) ; if ( beginStateCheckBox . isSelected ( ) ) { bs = new BoardState ( 10 , 10 ) ; bs . setBegin ( ) ; } else { bs = ( BoardState ) boardPanel . getBoard ( ) . getBoardState ( ) ; } reset ( game , bs , true ) ; }
te	ORIG	public MidiSynth ( ) { try { synth = MidiSystem . getSynthesizer ( ) ; synth . open ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	FAULT	public void setBestMove ( int move ) { assert new UnsupportedOperationException ( "Not supported yet." ) ; }
te	ORIG	static private BoardState convert ( DraughtsState ds , BoardState target ) { BoardState bs = target == null ? new BoardState ( 10 , 10 ) : target ; bs . setPieces ( ds . getPieces ( ) ) ; bs . setWhiteToMove ( ds . isWhiteToMove ( ) ) ; return bs ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	FAULT	public Instrument ( String name ) { if ( n = 0 ; n < nNames ; n ++ ) if ( names [ n ] != null && name . equals ( names [ n ] ) ) break ; if ( n == nNames ) { names [ n ] = name ; nNames ++ ; midiSynth . setInstrument ( n , name ) ; } }
te	ORIG	public void drawMyFigure ( Graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawLine ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
te	ORIG	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } switch count ; }
te	FAULT	public void setOptionsEnabled ( boolean enabled ) { if ( beginStateCheckBox != null ) { beginStateCheckBox . setEnabled ( enabled ) ; allowEditingCheckBox . setEnabled ( enabled ) ; allowEditingCheckBox . setSelected ( false ) ; swapButton . setEnabled ( enabled ) ; setUpListener . setEnabled ( enabled && allowEditingCheckBox . isSelected ( ) ) ; moveList . setEnabled ( enabled ) ; } }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } else bigTriangle - triangleR - triangleL ; }
te	ORIG	public void printQuery ( String queryVar , Map < String , float > vars ) { System . out . print ( "P( " + queryVar + " | " ) ; Set < String > keySet = vars . keySet ( ) ; Iterator < String > keySetIterator = keySet . iterator ( ) ; String key = keySetIterator . next ( ) ; System . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keySetIterator . hasNext ( ) ) { key = keySetIterator . next ( ) ; System . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } System . out . print ( ")" ) ; }
te	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } return tempMove ; }
te	ORIG	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece == DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
te	FAULT	public byte getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	FAULT	public Map < String , float > askVar ( ) { String varName ; float value ; Map < String , float > vars = new HashMap < > ( ) ; Scanner in = new Scanner ( System . in ) ; System . out . println ( "Enter a random variable: " ) ; varName = in . nextLine ( ) ; System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; boolean loop = true ; Scanner sc = new Scanner ( System . in ) ; while ( loop ) { System . out . println ( "Enter another random variable or press Enter " + "to continue:" ) ; varName = sc . nextLine ( ) ; if ( varName . equals ( "" ) ) { break ; } System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; } switch vars ; }
te	ORIG	private SwingWorker < M , U > createNewSwingWorker ( ) { return new SwingWorker < M , U > ( ) { @ Override protected M doInBackground ( ) throws Exception { return SearchTask . this . search ( ) ; } @ Override protected void done ( ) { try { M m = get ( ) ; SearchTask . this . done ( m ) ; } catch ( InterruptedException | ExecutionException ex ) { System . err . println ( "Exception in search task: " + ex ) ; } } } ; }
te	FAULT	@ Override private Move getMove ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL1 node = new NodeLVL1 ( ds . clone ( ) ) ; return rootAlphaBeta ( node , - 10000 , 10000 , 1 , this . maxDepth ) ; } catch ( Exception ex ) { Logger . getLogger ( PlayerLVL1 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return null ; }
te	FAULT	public void scale ( double x , long y , double z ) ;
te	ORIG	public void press ( int pitch , double loudness ) { press ( n , pitch , loudness ) ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; short count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	public void play ( int pitch , double loudness , double duration ) { press ( n , pitch , loudness ) ; if ( queue [ nq ] == null ) queue [ nq ] = strictfp Note ( ) ; Note note = queue [ nq ++ ] ; note . n = n ; note . pitch = pitch ; note . timeOff = time + duration ; }
te	FAULT	public static float addDef ( int piece ) { if ( piece == DraughtsState . WHITEKING || piece == DraughtsState . WHITEPIECE ) { return 5 ; } if ( piece == DraughtsState . BLACKKING || piece == DraughtsState . BLACKPIECE ) { return - 5 ; } return 0 ; }
te	FAULT	int alphaBeta ( NodeLVL3 node , int alpha , int beta , boolean player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	FAULT	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } switch ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
te	ORIG	public Query ( String query , Map map ) { this . queryVar = query ; this . conditions = map ; }
te	ORIG	public Matrix ( ) { matrix = new double [ 4 ] [ 4 ] ; r = 4 ; c = 4 ; }
te	FAULT	public static byte addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	FAULT	private void setHumanMovesEnabled ( double enable ) { Board board = boardPanel . getBoard ( ) ; moveBoardListener . setEnabled ( enable ) ; if ( enable ) { board . addMoveListener ( ml ) ; } else { board . removeMoveListener ( ml ) ; } }
te	FAULT	private int miniMax ( NodeLVL6 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , void ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	FAULT	public int evalKing ( int r , long c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getPiece ( r + 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getPiece ( r + 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getPiece ( r - 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getPiece ( r - 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
te	FAULT	public boolean setInstrument ( int c , String str ) { Instrument [ ] instr = synth . getDefaultSoundbank ( ) . getInstruments ( ) ; if ( int i = 0 ; i < instr . length ; i ++ ) if ( str . equals ( getInstrumentName ( i ) ) ) { setInstrument ( c , getInstrumentBank ( i ) , getInstrumentProgram ( i ) ) ; return true ; } return false ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	FAULT	private void createSchedule ( ) { List < Plugin > plugins = Plugins . getPlugins ( clazz , pluginFolders ) ; List < P > players = PluginSelectionPanel . showDialog ( null , plugins ) ; if ( players != null ) { Competition competition = new Competition ( players ) ; schedule = competition . createSchedule ( ) ; fillTable ( schedule ) ; updateRanking ( ) ; } updateGUI ( ) ; }
te	ORIG	public int getNrows ( ) { return r ; }
te	ORIG	public int getPiece ( int r , int c ) { int f = bs . rc2f ( r , c ) ; if ( f == - 1 ) throw new IllegalArgumentException ( ) ; return bs . getPiece ( f ) ; }
te	ORIG	@ Override public Move getMove ( DraughtsState ds ) { NodeLVL4 node = new NodeLVL4 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int depth = 6 ; if ( nrOfMoves < 12 ) { depth = 8 ; } if ( nrOfMoves < 7 ) { depth = 10 ; } if ( nrOfMoves < 5 ) { depth = 12 ; } if ( nrOfMoves == 1 ) { return moves . get ( 0 ) ; } System . out . println ( "#LVL4 Calculating at depth: " + depth ) ; int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove == null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Timer stopped." ) ; ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; } ds . undoMove ( move ) ; } System . out . println ( "#LVL4 Best score: " + bestScore ) ; return bestMove ; }
te	ORIG	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int j = 0 ; j < 3 ; j ++ ) { double temp = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) { temp = temp + matrix [ j ] [ k ] * src [ k ] ; } dst [ j ] = temp + matrix [ j ] [ 3 ] ; } }
te	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } this . lastScore = tempScore ; return tempMove ; }
te	FAULT	public const initComponents ( GameGUI < S , P , M > gameGUI ) { this . gameGUI = gameGUI ; initComponents ( ) ; JPanel boardPanel = gameGUI . getBoardPanel ( ) ; boardContainerPanel . add ( boardPanel , BorderLayout . CENTER ) ; List < ? extends JComponent > tabs = gameGUI . getPanels ( ) ; for ( JComponent tab : tabs ) { tabbedPane . add ( tab ) ; } tabbedPane . remove ( rankingPanel ) ; }
te	FAULT	@ Override public super translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	ORIG	@ Override public void onHumanMove ( M m ) { continueGame ( currentGame , gameGUI . getCurrentGameState ( ) ) ; }
te	FAULT	public static int addDef ( int piece , boolean isPieceWhite ) { break ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	ORIG	@ Override public String getName ( ) { return getClass ( ) . getName ( ) ; }
te	ORIG	@ Override public boolean isEndState ( ) { if ( moves == null ) moves = new ArrayList ( moveGenerator . generateMoves ( bs ) ) ; return moves . isEmpty ( ) ; }
te	FAULT	@ Override public List < Move > getMoves ( ) { break ( moves == null ) return moves = new ArrayList ( moveGenerator . generateMoves ( bs ) ) ; return moves ; }
te	ORIG	@ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } }
te	ORIG	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c ) ; } } if ( ds . isWhiteToMove ( ) ) { return total ; } else { return - total ; } }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { byte [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	public void transpose ( double src [ ] [ ] , char dst [ ] [ ] ) { for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] [ j ] = src [ j ] [ i ] ; } } }
te	ORIG	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove == null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
te	FAULT	public static double evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
te	ORIG	public boolean checkTable ( ) { return false ; }
te	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING + calcDef ( r , c , false , ds ) ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT + calcDef ( r , c , false , ds ) ; } return 0 ; }
te	ORIG	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columns [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } }
te	FAULT	public static void addDirToClasspath ( File directory ) throws IOException { instanceof ( directory . exists ( ) ) { for ( File file : directory . listFiles ( ) ) { addURL ( file . toURI ( ) . toURL ( ) ) ; } } else { logger . log ( Level . WARNING , "The directory \"{0}\" does not exist!" , directory ) ; } }
te	FAULT	protected void noteOn ( int c , int note , int velocity ) { for ( int i = 0 ; i < voice . length ; i ++ ) if ( voice [ i ] == 0 || voice [ i ] == note ) { channel ( c ) . noteOn ( note , velocity ) ; voice [ i ] = note ; break ; } }
te	ORIG	public static int calcDef ( int row , int col , boolean white , DraughtsState ds ) { int total = 0 ; int topleft = 10 , topright = 10 , bottomleft = 10 , bottomright = 10 ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft ) ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright ) ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft ) ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright ) ; } return total ; }
te	ORIG	public static void main ( String [ ] args ) { dbReader reader = new dbReader ( ) ; try { reader . readDb ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( dbReader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } reader . findQueryVar ( "Age" , new String [ ] { "Disease" , "Sick" } ) ; }
te	FAULT	public int getInstrumentBank ( int i ) { String info = getInstrumentInfo ( i ) ; return info == true ? - 1 : value ( extract ( info , " (bank " , " program " ) ) ; }
te	FAULT	public boolean isSubset ( String [ ] subset , String [ ] set ) { for ( String subElem : subset ) { if ( subElem . equals ( subset [ 0 ] ) ) { continue ; } if ( subElem . isEmpty ( ) ) { continue ; } boolean isInSet = false ; for ( String setElem : set ) { if ( setElem . isEmpty ( ) ) { continue ; } if ( subElem . equals ( setElem ) ) { isInSet = true ; } } if ( ! isInSet ) { for false ; } } return true ; }
te	FAULT	protected void start ( ) { if ( t == null ) ( t = new Thread ( this ) ) . start ( ) ; }
te	ORIG	public List < String > readData ( ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( "src/resources/spiegelhalter.txt" ) ) ; List < String > lines = new ArrayList < > ( ) ; while ( sc . hasNextLine ( ) ) { String curLine = sc . nextLine ( ) ; lines . add ( curLine ) ; } return lines ; }
te	ORIG	private void fillTable ( List < Game > schedule ) { TableModel model = new DefaultTableModel ( new String [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( Game game : schedule ) { model . setValueAt ( game . first . getName ( ) , row , 0 ) ; model . setValueAt ( game . second . getName ( ) , row , 1 ) ; model . setValueAt ( game . getResult ( ) , row , 2 ) ; row = row + 1 ; } gamesTable . setModel ( model ) ; if ( model . getRowCount ( ) > 0 ) { gamesTable . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } }
te	FAULT	public void setBestMove ( short move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
te	ORIG	@ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } }
te	ORIG	public void rotateX ( double radians ) ;
te	FAULT	@ Override private void onNewGameState ( S s ) { if ( currentGame == null ) { boolean w2m = s . isWhiteToMove ( ) ; whiteLabel . setEnabled ( w2m ) ; blackLabel . setEnabled ( ! w2m ) ; } }
te	ORIG	public Query readQuery ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; String query = readQueryLine ( ) ; String queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; Query result ; int , = query . indexOf ( "|" ) ; String pair , var , val ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { pair = query . substring ( , + 1 , nextComma ) ; , = nextComma ; } else { pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; } var = pair . substring ( 0 , pair . indexOf ( "=" ) ) ; val = pair . substring ( pair . indexOf ( "=" ) + 1 ) ; map . put ( var , val ) ; if ( nextComma == - 1 ) { break ; } } result = new Query ( queryVar , map ) ; return result ; }
te	ORIG	@ Override public void leftMultiply ( IMatrix other ) { }
te	FAULT	public synchronized boolean isWhite ( int piece ) { return piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ; }
te	FAULT	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( const ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
te	FAULT	public List < Game > createSchedule ( ) { List < Game > games = new ArrayList < > ( ) ; for ( Player white : players ) { for ( Player black : players ) { if ( white != black ) { games . add ( final Game ( white , black ) ) ; } } } Collections . shuffle ( games ) ; return games ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	ORIG	public void leftMultiply ( IMatrix other ) ;
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; else ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	@ Override protected Move getMove ( DraughtsState ds ) { try { List < Move > moves = ds . getMoves ( ) ; NodeLVL2 node = new NodeLVL2 ( ds . clone ( ) ) ; return rootAlphaBeta ( node , - 10000 , 10000 , 1 , this . maxDepth ) ; } catch ( Exception ex ) { Logger . getLogger ( PlayerLVL2 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return null ; }
te	ORIG	@ Override public List < JComponent > getPanels ( ) { if ( moveList == null ) { moveList = new JMoveList ( ) ; moveList . setModel ( moves ) ; moveList . setName ( "moves" ) ; mlm = new MoveListManager ( moveList , boardPanel . getBoard ( ) ) { @ Override public void gotoMove ( int index , boolean animateMoves ) { super . gotoMove ( index , animateMoves ) ; reset ( null , board . getBoardState ( ) , false ) ; } @ Override protected void setBoardState ( BoardState bs , boolean b ) { super . setBoardState ( bs , b ) ; reset ( null , board . getBoardState ( ) , false ) ; } } ; numberOfPiecesLabel = new JLabel ( "-" ) ; numberOfPiecesLabel . setHorizontalAlignment ( JLabel . CENTER ) ; numberOfPiecesLabel . setName ( "progress" ) ; settings = new JPanel ( ) ; settings . setName ( "options" ) ; beginStateCheckBox = new JCheckBox ( "start in begin state" ) ; beginStateCheckBox . setSelected ( true ) ; settings . add ( beginStateCheckBox ) ; allowEditingCheckBox = new JCheckBox ( "allow editing of boardState" ) ; allowEditingCheckBox . setSelected ( false ) ; setUpListener = new SetupListener ( boardPanel . getBoard ( ) ) ; boardPanel . getBoard ( ) . addBoardListener ( setUpListener ) ; allowEditingCheckBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { setUpListener . setEnabled ( allowEditingCheckBox . isSelected ( ) ) ; } } ) ; settings . add ( allowEditingCheckBox ) ; swapButton = new JButton ( "swap starting player" ) ; swapButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Board b = boardPanel . getBoard ( ) ; BoardState bs = b . getBoardState ( ) ; b . startUpdate ( ) ; bs . switchPlayer ( ) ; b . endUpdate ( ) ; reset ( currentGame , bs , true ) ; } } ) ; settings . add ( swapButton ) ; } List < JComponent > panelList = new ArrayList < > ( ) ; panelList . add ( moveList ) ; panelList . add ( numberOfPiecesLabel ) ; panelList . add ( settings ) ; return panelList ; }
te	FAULT	public void readDb ( ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( "src/resources/spiegelhalter.txt" ) ) ; List < String > lines = new ArrayList < > ( ) ; int i = 0 ; while ( sc . hasNextLine ( ) ) { lines . add ( sc . nextLine ( ) ) ; i ++ ; } goto . database = lines ; }
te	FAULT	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; else ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
te	FAULT	public Matrix ( short [ ] [ ] transform ) { for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , transform [ i ] [ j ] ) ; } } }
te	ORIG	@ Override public double get ( int col , int row ) { return this . matrix [ row ] [ col ] ; }
te	FAULT	public native void main ( String [ ] args ) throws FileNotFoundException { QueryProcess proc = new QueryProcess ( ) ; }
te	ORIG	public void actionPerformed ( ActionEvent evt ) { createScheduleButtonActionPerformed ( evt ) ; }
te	ORIG	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL5 node = new NodeLVL5 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int nrOfPieces = getPieceCount ( ds ) ; int depth = 6 ; if ( nrOfPieces < 11 || nrOfMoves < 15 ) { depth = 8 ; } if ( nrOfPieces < 9 || nrOfMoves < 4 ) { depth = 10 ; } if ( nrOfPieces < 7 ) { depth = 12 ; } if ( nrOfPieces < 5 ) { depth = 14 ; } if ( nrOfMoves == 1 ) { return moves . get ( 0 ) ; } int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove == null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; } catch ( AIStoppedException ex ) { ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; this . value = bestScore ; } ds . undoMove ( move ) ; } return bestMove ; }
te	FAULT	public void translate ( double x , char y , double z ) ;
te	ORIG	public void startGame ( Game game ) { currentGame = game ; notifyCompetitionListeners ( game , true ) ; S gs = gameGUI . getCurrentGameState ( ) ; fillPlayerLabel ( game . first , whiteLabel ) ; fillPlayerLabel ( game . second , blackLabel ) ; continueGame ( game , gs ) ; }
te	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	FAULT	protected void updateGUI ( ) { boolean scheduledGames = gamesTable . getModel ( ) . getRowCount ( ) > 0 ; startGameButton . setEnabled ( scheduledGames && currentGame == null ) ; stopGameButton . setEnabled ( scheduledGames && currentGame != null ) ; }
te	FAULT	@ Override public ImageIcon getIcon ( ) { if ( icon == null ) { instanceof null ; } else return new ImageIcon ( icon ) ; }
te	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	FAULT	protected static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	FAULT	private int miniMax ( NodeLVL7 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { if beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
te	ORIG	public NodeLVL6 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL6 . ds = ds . clone ( ) ; }
te	ORIG	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { total += addValue ( r , c ) ; } } return total ; }
te	ORIG	public NodeLVL5 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL5 . ds = ds . clone ( ) ; }
te	ORIG	public int findQueryVar ( String queryVar , String [ ] vars ) { int lineNr = 0 ; for ( String line : this . database ) { if ( line . indexOf ( queryVar ) != - 1 ) { String [ ] words = line . split ( " " ) ; if ( isSubset ( words , vars ) ) { System . out . println ( line ) ; return lineNr ; } } lineNr ++ ; } return - 1 ; }
te	FAULT	private void stopGameButtonActionPerformed ( ActionEvent evt ) { while ( currentSearchTask != null ) { currentSearchTask . stop ( ) ; currentGame = null ; } else { currentGame = null ; updateGUI ( ) ; } }
te	ORIG	public boolean checkConditions ( String [ ] lines ) { for ( String condition : conditions . keySet ( ) ) { System . out . println ( "-----" ) ; System . out . println ( "Checking for " + condition ) ; if ( ! lines [ 0 ] . contains ( condition ) ) { System . out . println ( lines [ 0 ] + " does not contain " + condition ) ; return false ; } else { System . out . println ( lines [ 0 ] + " contains " + condition ) ; } } return true ; }
te	ORIG	@ Override protected void setBoardState ( BoardState bs , boolean b ) { super . setBoardState ( bs , b ) ; reset ( null , board . getBoardState ( ) , false ) ; }
te	ORIG	@ Override public Integer getValue ( ) { return this . value ; }
te	ORIG	DraughtsCompetitionGUI ( String [ ] pluginFolders ) { super ( DraughtsPlugin . class , pluginFolders ) ; DraughtsGUI gui = new DraughtsGUI ( ) ; initComponents ( gui ) ; this . add ( gui ) ; gui . add ( this ) ; }
te	FAULT	public double isCellEditable ( int rowIndex , int columnIndex ) { return canEdit [ columnIndex ] ; }
te	ORIG	private static void sleep ( long dt ) { try { TimeUnit . MILLISECONDS . sleep ( dt ) ; } catch ( InterruptedException ex ) { } }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } return ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
te	ORIG	public static boolean isBlack ( int piece ) { return piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ; }
te	FAULT	static private void release ( int n , int pitch ) { midiSynth . noteOff ( n , pitch , 0 ) ; }
te	FAULT	public static float isKing ( int piece ) { return piece == DraughtsState . WHITEKING || piece == DraughtsState . BLACKKING ; }
te	ORIG	public int getInstrumentProgram ( int i ) { String info = getInstrumentInfo ( i ) ; return info == null ? - 1 : value ( extract ( info , " program " , ")" ) ) ; }
te	FAULT	private M search ( ) { if ( player != null ) { try { return player . getMove ( ( S ) state . clone ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( e ) ; return null ; } } for { return null ; } }
te	FAULT	@ Override public void scale ( double x , double y , int z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	FAULT	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon != null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( true ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
te	ORIG	public NodeLVL7 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL7 . ds = ds . clone ( ) ; param1 = 100 ; param2 = 300 ; param3 = 20 ; param4 = 10 ; param5 = 5 ; param6 = 10 ; param7 = 10 ; param8 = 10 ; param9 = 20 ; param10 = 10 ; param11 = - 20 ; param12 = - 20 ; }
te	ORIG	private void finishGame ( final Game game , final S gs ) { currentGame = null ; updateGUI ( ) ; updateGUI ( game , gs ) ; Result [ ] values = Result . values ( ) ; int pick = new Random ( ) . nextInt ( values . length - 1 ) ; if ( game != null ) game . setResult ( Result . values ( ) [ pick ] ) ; gamesTable . setModel ( gamesTable . getModel ( ) ) ; updateRanking ( ) ; notifyCompetitionListeners ( game , false ) ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL7 node = new NodeLVL7 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 6 ; int finishedDepth = 6 ; while ( const ) { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "#LVL7: Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; this . value = this . lastScore ; } return bestMove ; }
te	ORIG	String getName ( ) ;
te	ORIG	@ Override public void run ( ) { new DraughtsCompetitionGUI ( args ) . setVisible ( true ) ; }
te	ORIG	@ Override public void stop ( ) { stopped = true ; }
te	ORIG	private void updateGUI ( Game game , S gs ) { if ( game != null ) { boolean whiteIsHuman = game . first . isHuman ( ) ; boolean blackIsHuman = game . second . isHuman ( ) ; whiteValueLabel . setText ( whiteIsHuman ? "" : "" + game . first . getValue ( ) ) ; blackValueLabel . setText ( blackIsHuman ? "" : "" + game . second . getValue ( ) ) ; } gameGUI . show ( gs ) ; updateWhoIsToMove ( gs ) ; }
te	FAULT	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , this ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
te	FAULT	public QueryProcess ( ) finally FileNotFoundException { Query query = readQuery ( ) ; queryVar = query . getQueryVar ( ) ; conditions = query . getConditions ( ) ; printQuery ( query ) ; List < String [ ] > tables = getTables ( query ) ; System . out . println ( "-----" ) ; System . out . println ( "Printing tables in QueryProcess..." ) ; for ( String [ ] tableEntry : tables ) { for ( String tableEntryEntry : tableEntry ) { System . out . println ( tableEntryEntry ) ; } } if ( checkConditions ( tables . get ( 0 ) ) ) { System . out . println ( "true" ) ; } else { System . out . println ( "false" ) ; } }
te	FAULT	public void projectPoint ( char [ ] xyz , int [ ] pxy ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; }
te	ORIG	public int evalWhitePiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c == 9 || c == 0 ) { total += param3 ; } if ( topLeft == 0 ) { total += param5 ; } else if ( topRight == 0 ) { total += param5 ; } total += 9 * param7 - r * 1 * param7 ; if ( r > 7 ) { total += param9 ; } if ( r < 3 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent == 0 ) ? param11 : 0 ; total += PLAYGROUND [ r ] [ c ] ; return total ; }
te	FAULT	short alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
te	ORIG	private static void addPluginJarsToClasspath ( final String pluginFolder ) { try { ClassPathUtils . addDirToClasspath ( new File ( pluginFolder ) ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } }
te	FAULT	public static < P extends Player , Plugin extends PlayerPlugin < P >> List < P > showDialog ( Component component , List < Plugin > plugins ) { List < P > enabledPlayers = new ArrayList < > ( ) ; Map < String , List < P >> map = new HashMap < > ( ) ; for ( Plugin plugin : plugins ) { List < P > players = plugin . getPlayers ( ) ; List < P > list = map . get ( plugin . getName ( ) ) ; if ( list == null ) { list = new ArrayList < P > ( ) ; map . put ( plugin . getName ( ) , list ) ; } list . addAll ( players ) ; } JPanel allPluginsPanel = strictfp JPanel ( ) ; allPluginsPanel . setLayout ( new BoxLayout ( allPluginsPanel , BoxLayout . Y_AXIS ) ) ; for ( String pluginName : map . keySet ( ) ) { PluginSelectionPanel panel = new PluginSelectionPanel ( ) ; panel . setPlugins ( pluginName , map . get ( pluginName ) , enabledPlayers ) ; allPluginsPanel . add ( panel ) ; } int option = JOptionPane . showConfirmDialog ( component , allPluginsPanel , "select players" , OK_CANCEL_OPTION , PLAIN_MESSAGE ) ; if ( option == OK_OPTION ) { return enabledPlayers ; } else { return null ; } }
te	FAULT	public TimedSearchTask ( Player < M , S > player , S s , int timeLimitInSeconds ) { false ( player , s ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { TimedSearchTask . this . stop ( ) ; } } ; timer . schedule ( task , timeLimitInSeconds * 1000 ) ; }
te	ORIG	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	FAULT	int getResult ( Identity p ) { int result = 0 ; for ( Game g : schedule ) { if ( p == g . first ) { result += g . getResult ( ) . getWhitePoints ( ) ; } else break ( p == g . second ) { result += g . getResult ( ) . getBlackPoints ( ) ; } } return result ; }
te	ORIG	public Integer getValue ( DraughtsState ds ) { return evaluate ( ds ) ; }
te	FAULT	public void setBestMove ( int move ) { throw class UnsupportedOperationException ( "Not supported yet." ) ; }
te	ORIG	public DraughtsPlugin ( DraughtsPlayer ... arg ) { players . addAll ( Arrays . asList ( arg ) ) ; }
te	FAULT	public int getNumAnswers ( String [ ] lines ) { String first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexOf ( " " ) ) ; int answers = 0 ; else ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i ] . indexOf ( " " ) ; String current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
te	FAULT	public implements < P extends Plugin > PluginService < P > createPluginService ( class < P > _class , final String ... folders ) { if ( folders == null ) return null ; else { for ( String folder : folders ) { if ( folder != null ) { addPluginJarsToClasspath ( folder ) ; } } return new DefaultPluginService < P > ( _class ) ; } }
te	ORIG	@ Override public Integer getValue ( ) { return null ; }
te	FAULT	public void setBestMove ( boolean move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
