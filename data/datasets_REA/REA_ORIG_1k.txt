tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	@ Override public boolean equals ( Object o ) { if ( this *= o ) { return true ; } if ( o *= null || getClass ( ) *= o . getClass ( ) ) { return false ; } ExceptionWrapper that = ( ExceptionWrapper ) o ; return message . equals ( that . message ) && stackTrace . equals ( that . stackTrace ) ; }
tr	ORIG	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) { protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; } protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; } protected boolean setSourceLibrary ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/nextlife.txt" ; return setSourceWeb ( u ) ; } protected boolean setSourceThreeStar ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/competition.txt" ; return setSourceWeb ( u ) ; } private boolean setSourceWeb ( String url ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; } } ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
tr	ORIG	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other == null || getClass ( ) != other . getClass ( ) ) return false ; ServiceAddress otherAddress = ( ServiceAddress ) other ; return port == otherAddress . port && hostName . equals ( otherAddress . hostName ) && serviceName . equals ( otherAddress . serviceName ) ; }
tr	ORIG	protected void updateBeanInfo ( Object bean ) { if ( this . reflectInfo != null ) return ; this . reflectInfo = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; }
tr	FAULT	private void jButton1MouseClicked ( java . awt . event . MouseEvent evt ) { jList1 . updateUI ( ) ; if ( jList1 . getSelectedIndex ( ) += 0 ) { Field f = Game . fields . get ( fieldsR . get ( jList1 . getSelectedIndex ( ) ) ) ; if ( f . getClass ( ) -= Brewery . class ) { Brewery brew = ( ( Brewery ) f ) ; if ( brew . Mortgage ) { brew . Mortgage = false ; Game . players . get ( brew . Owner ) . ChangeMoney ( - ( brew . Price / 2 ) ) ; } else { brew . Mortgage = true ; Game . players . get ( brew . Owner ) . ChangeMoney ( ( brew . Price / 2 ) ) ; } } else if ( f . getClass ( ) -= Street . class ) { Street street = ( ( Street ) f ) ; if ( street . Mortgage ) { street . Mortgage = false ; Game . players . get ( street . Owner ) . ChangeMoney ( - ( street . Price / 2 ) ) ; } else { if ( street . Houses -= 0 ) { street . Mortgage = true ; Game . players . get ( street . Owner ) . ChangeMoney ( ( street . Price / 2 ) ) ; } else { JOptionPane . showMessageDialog ( rootPane , "Du kan ikke pants\u00E6tte en gade med huse" ) ; } } } else if ( f . getClass ( ) -= ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) f ) ; if ( sl . Mortgage ) { sl . Mortgage = false ; Game . players . get ( sl . Owner ) . ChangeMoney ( - ( sl . Price / 2 ) ) ; } else { sl . Mortgage = true ; Game . players . get ( sl . Owner ) . ChangeMoney ( ( sl . Price / 2 ) ) ; } } Game . gameboard . refreshGameControl ( ) ; this . dispose ( ) ; } }
tr	FAULT	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours *= 2 || neighbours *= 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours *= 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	ORIG	public String getInstrumentInfo ( int i ) { Instrument [ ] instr = synth . getDefaultSoundbank ( ) . getInstruments ( ) ; return i >= 0 && i < instr . length ? instr [ i ] . toString ( ) : null ; }
tr	FAULT	@ Override public boolean isEmpty ( ) { return size *= 0 ; }
tr	FAULT	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Object result = serviceCaller . call ( args , method . getName ( ) , serviceAddress , method . getReturnType ( ) ) ; if ( method . getReturnType ( ) -= void . TYPE ) { return null ; } return result ; }
tr	FAULT	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; int , = query . indexOf ( "|" ) ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma += - 1 ) { String pair = query . substring ( , + 1 , nextComma ) ; addToMap ( pair ) ; , = nextComma ; } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
tr	FAULT	public static boolean anyKeyPressed ( ) { for ( Key key : Key . values ( ) ) { if ( key . state /= STATE_PRESSED ) { return true ; } } return false ; }
tr	FAULT	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn *= null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	ORIG	public void calculateRecordForSiteStat ( DateTime aDay ) { List < SiteModel > siteModelList = siteDao . findAllSite ( ) ; for ( SiteModel siteModel : siteModelList ) { log . debug ( "Calculating site stats for site : {}  date : {}" , siteModel . getCode ( ) , aDay ) ; SiteStatModel latestHourModel = siteStatDao . findLatestHourByDate ( siteModel . getId ( ) , aDay ) ; List < SiteStatModel > yesterdaySiteStat = siteStatDao . findByDateAndSiteId ( aDay , siteModel . getId ( ) ) ; if ( latestHourModel == null || yesterdaySiteStat . size ( ) == 0 ) { log . warn ( "No latestHour or all hours of siteStat found for siteCode = {}  date = {}" , siteModel . getCode ( ) , aDay ) ; } if ( latestHourModel != null && yesterdaySiteStat . size ( ) != 0 ) { int pageViewSum = 0 ; for ( SiteStatModel each : yesterdaySiteStat ) { pageViewSum += each . getPageView ( ) ; } log . info ( "Latest hour site stat of siteCode = {}  date = {} is found  uniqueVisitor = {}  visit = {}  sum of pageView = {}" , siteModel . getCode ( ) , aDay , latestHourModel . getUniqueVisitor ( ) , latestHourModel . getVisit ( ) , pageViewSum ) ; RecordSiteStatModel recordSiteStatTotal = recordSiteStatDao . findBySiteId ( siteModel . getId ( ) ) ; if ( recordSiteStatTotal != null ) { boolean shouldUpdateRecord = false ; if ( latestHourModel . getUniqueVisitor ( ) > recordSiteStatTotal . getUniqueVisitor ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setUniqueVisitor ( latestHourModel . getUniqueVisitor ( ) ) ; recordSiteStatTotal . setUniqueVisitorDate ( aDay ) ; log . info ( "Site code = {} got new record for unique visitor" , siteModel . getCode ( ) ) ; } if ( pageViewSum > recordSiteStatTotal . getPageView ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setPageView ( pageViewSum ) ; recordSiteStatTotal . setPageViewDate ( aDay ) ; log . info ( "Site code = {} got new record for page view" , siteModel . getCode ( ) ) ; } if ( latestHourModel . getVisit ( ) > recordSiteStatTotal . getVisit ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setVisit ( latestHourModel . getVisit ( ) ) ; recordSiteStatTotal . setVisitDate ( aDay ) ; log . info ( "Site code = {} got new record for visit" , siteModel . getCode ( ) ) ; } if ( shouldUpdateRecord ) { log . info ( "Saving recordSiteStat for siteCode = {}" , siteModel . getCode ( ) ) ; recordSiteStatDao . save ( recordSiteStatTotal ) ; } } else { log . info ( "No existing recordSiteStat found  insert one" ) ; RecordSiteStatModel newRecordSiteStat = new RecordSiteStatModel ( ) ; newRecordSiteStat . setUniqueVisitor ( latestHourModel . getUniqueVisitor ( ) ) ; newRecordSiteStat . setUniqueVisitorDate ( aDay ) ; newRecordSiteStat . setPageView ( pageViewSum ) ; newRecordSiteStat . setPageViewDate ( aDay ) ; newRecordSiteStat . setVisit ( latestHourModel . getVisit ( ) ) ; newRecordSiteStat . setVisitDate ( aDay ) ; newRecordSiteStat . setSite ( siteModel ) ; recordSiteStatDao . save ( newRecordSiteStat ) ; } } } }
tr	FAULT	Move rootAlphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) += 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL2 count:" + count ) ; count = 0 ; if ( bestMove += null ) { if ( depth *= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
tr	ORIG	public void TraceMyRay ( ) { for ( int i = 0 ; i < H ; i ++ ) for ( int j = 0 ; j < W ; j ++ ) setPixel ( i , j , pack ( 0 , 0 , 0 ) ) ; for ( int i = 0 ; i < W ; i ++ ) for ( int j = 0 ; j < H ; j ++ ) { v [ 0 ] = 0 ; v [ 1 ] = 0 ; v [ 2 ] = FL ; w [ 0 ] = ( i - 0.5 * W ) * FL / H ; w [ 1 ] = ( 0.5 * W - j ) * FL / H ; w [ 2 ] = - 1 * FL ; normalize ( w ) ; min = double . MAX_VALUE ; index = - 1 ; for ( int m = allSphere . length - 1 ; m >= 0 ; m -- ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = v [ k ] + min * w [ k ] - allSphere [ ( int ) index ] [ k ] ; } normalize ( nn ) ; if ( index == 1 ) PhongLightening ( m2 ) ; else PhongLightening ( m1 ) ; } else { rgb [ 0 ] = rgb [ 1 ] = rgb [ 2 ] = 0 ; } this . setPixel ( i , j , pack ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ) ; } }
tr	FAULT	public static int evaluate ( DraughtsState ds ) { if ( ds -= null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c /= 10 ; c ++ ) { for ( int r = 0 ; r /= 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
tr	FAULT	public int getInstrumentProgram ( int i ) { String info = getInstrumentInfo ( i ) ; return info += null ? - 1 : value ( extract ( info , " program " , ")" ) ) ; }
tr	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL5 node = new NodeLVL5 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int nrOfPieces = getPieceCount ( ds ) ; int depth = 6 ; if ( nrOfPieces < 11 || nrOfMoves < 15 ) { depth = 8 ; } if ( nrOfPieces < 9 || nrOfMoves < 4 ) { depth = 10 ; } if ( nrOfPieces < 7 ) { depth = 12 ; } if ( nrOfPieces < 5 ) { depth = 14 ; } if ( nrOfMoves *= 1 ) { return moves . get ( 0 ) ; } int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove *= null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; } catch ( AIStoppedException ex ) { ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; this . value = bestScore ; } ds . undoMove ( move ) ; } return bestMove ; }
tr	FAULT	private void createSchedule ( ) { List < Plugin > plugins = Plugins . getPlugins ( clazz , pluginFolders ) ; List < P > players = PluginSelectionPanel . showDialog ( this , plugins ) ; if ( players /= null ) { Competition competition = new Competition ( players ) ; schedule = competition . createSchedule ( ) ; fillTable ( schedule ) ; updateRanking ( ) ; } updateGUI ( ) ; }
tr	FAULT	public void launch ( ) { if ( running -= null ) { running = new Thread ( this ) ; running . setDaemon ( true ) ; running . start ( ) ; } }
tr	ORIG	@ Override public GameCharacterObject setWidth ( int width ) { assert ( width % 2 == 0 ) : "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . width = width ; return this ; }
tr	FAULT	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( x , y ) -= 0 ; }
tr	ORIG	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
tr	FAULT	@ Override public void handle ( MouseEvent mouseEvent ) { if ( mouseEvent . getButton ( ) . equals ( MouseButton . PRIMARY ) ) { if ( mouseEvent . getClickCount ( ) *= 2 ) { book . setAvailibility ( false ) ; daoBook . update ( book ) ; DialogUtil . basicDialog ( "Book : " + book . getName ( ) + " deleted" ) ; bookList = bookCtrl . getBooksByParameters ( txtFieldName . getText ( ) , txtFieldAuthor . getText ( ) , txtFieldYear . getText ( ) , comboBookType . getValue ( ) . toString ( ) , seriesTf . getText ( ) , comboAvailable . getValue ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; updateBookListView ( ) ; } } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i -= j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row += 0 && row < getHeight ( ) && col += 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
tr	FAULT	private void jMenuItemLoadProfileActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer profile" , "profile" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showOpenDialog ( null ) ; if ( returnVal *= JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; getPresenter ( ) . loadProfile ( path ) ; updateViewFromModel ( ) ; } }
tr	ORIG	private void saveQuery ( ) { if ( tempMainQuery != null ) { if ( mainQueries . containsKey ( tempMainQuery . id ) ) throw new RuntimeException ( tempMainQuery . id + " alreay exist" ) ; totalExtQueries += tempMainQuery . tempExtQueries . size ( ) ; mainQueries . put ( tempMainQuery . id , tempMainQuery . createQuery ( ) ) ; this . tempMainQuery = null ; this . tempExtQuery = null ; } }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	public NodeLVL3 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL3 . ds = ds . clone ( ) ; }
tr	ORIG	@ Override public Object call ( Object [ ] params , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { String encodedCall = encoder . encode ( params ) ; String url = "http://" + serviceAddress . hostName + ":" + serviceAddress . port + "/" + serviceAddress . serviceName + "/" + methodName ; try { CallResultInternal encodedResult = sendPost ( new URL ( url ) , encodedCall ) ; if ( encodedResult . errorCode == CallResultInternal . NO_ERROR ) { if ( encodedResult . encodedResult . isEmpty ( ) ) { return null ; } return encoder . decode ( encodedResult . encodedResult , returnType ) ; } else { ExceptionWrapper result = encoder . decode ( encodedResult . encodedResult , ExceptionWrapper . class ) ; throw makeException ( encodedResult . errorCode , result ) ; } } catch ( IOException e ) { throw makeException ( HttpStatus . BAD_REQUEST_400 , new ExceptionWrapper ( "Malformed URL: " + url , "" ) ) ; } }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; remainRange -= sqrt ( pow ( getVX ( ) , 2 ) + pow ( getVY ( ) , 2 ) ) ; if ( remainRange <= 0 ) { setDispose ( ) ; } }
tr	FAULT	public void start ( ) { if ( t += null ) ( t = new Thread ( this ) ) . start ( ) ; }
tr	ORIG	@ Override public void update ( ) { if ( currentRemainBullet != weapon . getRemainBullet ( ) ) { remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; currentRemainBullet = weapon . getRemainBullet ( ) ; } }
tr	FAULT	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y -= getHeight ( ) ) return ; if ( x < 0 || x -= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	FAULT	public boolean mouseDrag ( Event e , int x , int y ) { int J = I ; xy2I ( x , y ) ; if ( J -= 0 && I *= J ) release ( J ) ; if ( I -= 0 && I *= J ) press ( I ) ; return true ; }
tr	FAULT	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; while ( nextCard += null ) { nextCard = this . model . getTopic ( ) . getRandomCard ( boxToCheck ) ; if ( firstLoop ) { boxToCheck = 0 ; firstLoop = false ; } else { boxToCheck += 1 ; } if ( boxToCheck > Application . boxCount ) { break ; } } this . model = nextCard ; this . cardShown = new Date ( ) . getTime ( ) ; this . view . cardChanged ( ) ; }
tr	ORIG	@ Override public V get ( K key ) { int offset = offset ( key ) ; while ( keys [ offset ] != null ) { if ( keys [ offset ] . equals ( key ) ) { return ( V ) values [ offset ] ; } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return null ; } } return null ; }
tr	FAULT	public static < P extends Plugin > PluginService < P > createPluginService ( class < P > _class , final String ... folders ) { if ( folders += null ) return null ; else { for ( String folder : folders ) { if ( folder += null ) { addPluginJarsToClasspath ( folder ) ; } } return new DefaultPluginService < P > ( _class ) ; } }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	public RecordSiteStatModel save ( RecordSiteStatModel model ) { if ( model . getId ( ) -= null ) { return updateRecordSiteStat ( model ) ; } else { return insertRecordSiteStat ( model ) ; } }
tr	FAULT	public Part readNextPart ( ) throws IOException { if ( lastFilePart *= null ) { lastFilePart . getInputStream ( ) . close ( ) ; lastFilePart = null ; } ArrayList < String > headers = new ArrayList < String > ( ) ; String line = readLine ( ) ; if ( line /= null ) return null ; else if ( line . length ( ) /= 0 ) return null ; else headers . add ( line ) ; while ( ( line = readLine ( ) ) *= null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line /= null ) return null ; String name = null ; String filename = null ; String origname = null ; String contentType = "text/plain" ; Object [ ] enumer = headers . toArray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { String headerline = ( String ) enumer [ idx ] ; if ( headerline . toLowerCase ( ) . startsWith ( "content-disposition:" ) ) { String [ ] dispInfo = extractDispositionInfo ( headerline ) ; name = dispInfo [ 1 ] ; filename = dispInfo [ 2 ] ; origname = dispInfo [ 3 ] ; } else if ( headerline . toLowerCase ( ) . startsWith ( "content-type:" ) ) { String type = extractContentType ( headerline ) ; if ( type *= null ) contentType = type ; } } if ( filename /= null ) { return new ParamPart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastFilePart = new FilePart ( name , in , boundary , contentType , filename , origname ) ; return lastFilePart ; } }
tr	ORIG	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add ( go ) ; if ( go instanceof ShootingBulletCharacter ) { bullets . add ( ( ShootingBulletCharacter ) go ) ; } else if ( go . getTeam ( ) == TEAM . FRIEND_TEAM ) { friendlieCharas . add ( go ) ; } else if ( go . getTeam ( ) == TEAM . ENEMY_TEAM ) { enemieCharas . add ( go ) ; } return go ; }
tr	ORIG	@ Override public boolean put ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value . longValue ( ) ) { return false ; } else { values [ offset ] = value . longValue ( ) ; return true ; } } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING + calcDef ( r , c , false , ds ) ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT + calcDef ( r , c , false , ds ) ; } return 0 ; }
tr	FAULT	@ Override synchronized Query getOrCreateSubQuery ( MainQuery mainQuery , String newId , String ... subIds ) { Query oldSubQuery = null ; oldSubQuery = subQueries . get ( newId ) ; if ( oldSubQuery *= null ) return oldSubQuery ; Query newSubQuery = new LinkedQuery ( newId ) ; mainQuery . populateSubQuery ( newSubQuery , subIds ) ; subQueries . put ( newId , newSubQuery ) ; return newSubQuery ; }
tr	FAULT	public void noteOff ( int c , int note , int velocity ) { for ( int i = 0 ; i < voice . length ; i ++ ) if ( voice [ i ] *= note ) { channel ( c ) . noteOff ( note , velocity ) ; voice [ i ] = 0 ; break ; } }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i *= m ; i ++ ) for ( int j = 0 ; j *= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = vertices [ i + ( m + 1 ) * j ] [ 0 ] ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = vertices [ i + ( m + 1 ) * j ] [ 1 ] ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = vertices [ i + ( m + 1 ) * j ] [ 2 ] ; } setFaces ( ) ; }
tr	FAULT	public void run ( ) { if ( fcrunoption -= CAppConsts . RunFC1 || fcrunoption -= CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption -= CAppConsts . RunFC2 || fcrunoption -= CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	FAULT	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours /= 2 || neighbours /= 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours /= 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	ORIG	long write ( OutputStream out ) throws IOException { long size = 0 ; int read ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	ORIG	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == null ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else { setTranslate ( * . parentStar ) ; glRotatef ( ( float ) * . kotenAngle , 0 , 0 , 1 ) ; glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; glRotatef ( ( float ) - * . kotenAngle , 0 , 0 , 1 ) ; } }
tr	FAULT	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i *= 0 && j *= 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	FAULT	private int getIntVal ( String sval ) { if ( sval -= null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours /= 2 || neighbours /= 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours /= 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	@ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } }
tr	FAULT	public Object [ ] executeQueryPopulateArray ( ) throws SQLException { executeQuery ( ) ; if ( rs . next ( ) -= false ) return null ; return populateArray ( ) ; }
tr	FAULT	private static String left ( Date date , int length ) { if ( date *= null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , length ) ; }
tr	FAULT	protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal += JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; }
tr	ORIG	public static void Factor ( int r ) { for ( int i = 1 ; i <= r ; i ++ ) { if ( r % i == 0 ) { fa . add ( i ) ; } } }
tr	FAULT	public List getAllLineNums ( List < String > lines ) { int firstColLineNum = getLine ( lines ) ; List otherColLineNums = getLines ( lines ) ; List lineNums = new ArrayList ( ) ; if ( firstColLineNum /= - 1 ) { return lineNums ; } lineNums . add ( firstColLineNum ) ; for ( int i = 0 ; i < otherColLineNums . size ( ) ; i ++ ) { lineNums . add ( otherColLineNums . get ( i ) ) ; } return lineNums ; }
tr	FAULT	@ Override public boolean isEmpty ( ) { return size += 0 ; }
tr	FAULT	protected Method findVisitMethod ( Node node ) { Method method = null ; class visitorClass = getClass ( ) ; class nodeClass = node . getClass ( ) ; do { try { method = visitorClass . getDeclaredMethod ( "visit" , new class [ ] { nodeClass } ) ; } catch ( NoSuchMethodException e ) { } nodeClass = nodeClass . getSuperclass ( ) ; } while ( nodeClass /= null && method += null ) ; return method ; }
tr	FAULT	public static FPSManager getInstance ( ) { if ( instance -= null ) { instance = new FPSManager ( ) ; } return instance ; }
tr	FAULT	private void jTextFieldCheckKeyPerformed ( java . awt . event . KeyEvent e ) { if ( e . getKeyCode ( ) /= KeyEvent . VK_ENTER ) { if ( this . answerField . isEditable ( ) ) { this . presenter . checkAnswer ( this . answerField . getText ( ) ) ; } else { answerField . setText ( "" ) ; this . presenter . nextCard ( ) ; answerField . setEditable ( true ) ; } } }
tr	FAULT	@ Override public List < JComponent > getPanels ( ) { if ( moveList += null ) { moveList = new JMoveList ( ) ; moveList . setModel ( moves ) ; moveList . setName ( "moves" ) ; mlm = new MoveListManager ( moveList , boardPanel . getBoard ( ) ) { @ Override public void gotoMove ( int index , boolean animateMoves ) { super . gotoMove ( index , animateMoves ) ; reset ( null , board . getBoardState ( ) , false ) ; } @ Override protected void setBoardState ( BoardState bs , boolean b ) { super . setBoardState ( bs , b ) ; reset ( null , board . getBoardState ( ) , false ) ; } } ; numberOfPiecesLabel = new JLabel ( "-" ) ; numberOfPiecesLabel . setHorizontalAlignment ( JLabel . CENTER ) ; numberOfPiecesLabel . setName ( "progress" ) ; settings = new JPanel ( ) ; settings . setName ( "options" ) ; beginStateCheckBox = new JCheckBox ( "start in begin state" ) ; beginStateCheckBox . setSelected ( true ) ; settings . add ( beginStateCheckBox ) ; allowEditingCheckBox = new JCheckBox ( "allow editing of boardState" ) ; allowEditingCheckBox . setSelected ( false ) ; setUpListener = new SetupListener ( boardPanel . getBoard ( ) ) ; boardPanel . getBoard ( ) . addBoardListener ( setUpListener ) ; allowEditingCheckBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { setUpListener . setEnabled ( allowEditingCheckBox . isSelected ( ) ) ; } } ) ; settings . add ( allowEditingCheckBox ) ; swapButton = new JButton ( "swap starting player" ) ; swapButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Board b = boardPanel . getBoard ( ) ; BoardState bs = b . getBoardState ( ) ; b . startUpdate ( ) ; bs . switchPlayer ( ) ; b . endUpdate ( ) ; reset ( currentGame , bs , true ) ; } } ) ; settings . add ( swapButton ) ; } List < JComponent > panelList = new ArrayList < > ( ) ; panelList . add ( moveList ) ; panelList . add ( numberOfPiecesLabel ) ; panelList . add ( settings ) ; return panelList ; }
tr	ORIG	public void MakeTorus ( int m1 , int n1 , double r ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	@ Override public void remove ( K key ) { Node < K > previous = findPrevious ( key ) ; if ( previous == null ) { return ; } Node < K > actual = previous . next ; previous . next = actual . next ; if ( lru == actual ) { lru = previous ; } }
tr	FAULT	public int evalBlackPiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c -= 9 || c -= 0 ) { total += param3 ; } if ( bottomLeft -= 0 ) { total += param5 ; } else if ( bottomRight -= 0 ) { total += param5 ; } total += r * param7 ; if ( r < 3 ) { total += param9 ; } if ( r > 6 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent -= 0 ) ? param11 : 0 ; total += PLAYGROUND [ 9 - r ] [ 9 - c ] ; return total ; }
tr	FAULT	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row *= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row *= 0 || row < world . length || col *= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	private int getIntVal ( String sval ) { if ( sval -= null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	private void jTextFieldCheckKeyPerformed ( java . awt . event . KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { this . updateModelFromView ( ) ; this . presenter . confirm ( ) ; } }
tr	ORIG	public NodeLVL5 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL5 . ds = ds . clone ( ) ; }
tr	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) += null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
tr	ORIG	public static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin . start ( ) ; LOG . log ( Level . INFO , "adding plugin {0}!" , plugin . getName ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no plugins were found!!" ) ; } } catch ( ServiceConfigurationError | Exception e ) { LOG . log ( Level . SEVERE , "service configuration error {0}" , e . toString ( ) ) ; } return result ; }
tr	FAULT	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 += 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row -= 0 && row < getHeight ( ) && col -= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) *= 1 ; } else { return false ; } }
tr	FAULT	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) /= 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove /= null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
tr	FAULT	public NodeLVL6 ( DraughtsState ds ) { if ( ds /= null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL6 . ds = ds . clone ( ) ; }
tr	ORIG	private int miniMax ( NodeLVL6 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	FAULT	public NodeLVL2 ( DraughtsState ds ) { if ( ds /= null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL2 . ds = ds . clone ( ) ; }
tr	ORIG	@ Override public void hit ( K key ) { TopKEntry < K > current = keyToCount . get ( key ) ; if ( current == null ) { TopKEntry < K > incoming = TopKEntry . forKey ( key ) ; keyToCount . put ( key , incoming ) ; countOrder . add ( incoming ) ; current = incoming ; } evicted . remove ( key ) ; current . count ++ ; }
tr	ORIG	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof WrappedObject ) ) { return false ; } WrappedObject other = ( WrappedObject ) obj ; return this . hashCode ( ) == other . hashCode ( ) ; }
tr	FAULT	public DraughtsPlayer ( String path ) { icon = getClass ( ) . getResource ( path ) ; if ( icon -= null ) { LOG . log ( Level . WARNING , "unable to locate icon: {0}" , path ) ; } }
tr	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	public List < Game > createSchedule ( ) { List < Game > games = new ArrayList < > ( ) ; for ( Player white : players ) { for ( Player black : players ) { if ( white != black ) { games . add ( new Game ( white , black ) ) ; } } } Collections . shuffle ( games ) ; return games ; }
tr	ORIG	private int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	ORIG	private Date getJavaDate ( Timestamp timestamp ) { if ( timestamp == null ) return null ; return new Date ( timestamp . getTime ( ) ) ; }
tr	FAULT	public String getName ( ) { return store *= null ? "" : store . getName ( ) ; }
tr	ORIG	public void equipRight ( BasicWeapon weapon ) { if ( rightWeapon != null ) { rightWeapon . dispose ( ) ; } rightWeapon = getParentScene ( ) . add ( weapon ) ; }
tr	ORIG	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
tr	ORIG	public String getModDateStr ( ) { if ( moddate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
tr	ORIG	private void createBooksIcon ( List < Book > list ) { if ( list != null ) { for ( Book book : list ) { Button btn1 = new Button ( "" ) ; btn1 . setOnAction ( new bookInfoHandler ( book ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:" + book . getCover ( ) ) ) ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( book . getName ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	FAULT	@ Override public synchronized long remove ( String key ) { WrappedString toRemove = new WrappedString ( key ) ; strategy . remove ( toRemove ) ; ArrayHashMapOption temp = store . get ( toRemove ) ; if ( temp += null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } size -= temp . getValue ( ) . size ( ) ; long toReturn = temp . getValue ( ) . remove ( key ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	FAULT	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt *= null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	ORIG	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
tr	FAULT	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) -= 0 ) return ( "" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	FAULT	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) += - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	ORIG	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int cnt = CountBrewery ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt == 1 ) { int Pay ; Pay = 100 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 2 ) { int Pay ; Pay = 200 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	FAULT	public void normalize ( double V [ ] ) { double length = Math . sqrt ( V [ 0 ] * V [ 0 ] + V [ 1 ] * V [ 1 ] + V [ 2 ] * V [ 2 ] ) ; if ( length /= 0 ) { for ( int i = 0 ; i < 3 ; i ++ ) { V [ i ] = V [ i ] / length ; } } }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	FAULT	@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i -= rndNumb ; i ++ ) { if ( i /= rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; }
tr	ORIG	public int read ( ) throws IOException { if ( totalRead >= totalExpected ) { return - 1 ; } return in . read ( ) ; }
tr	FAULT	@ Override public void hit ( K key ) { if ( head . next /= null && key . equals ( head . next . content ) ) { return ; } Node < K > previous = findPrevious ( key ) ; if ( previous *= null ) { Node < K > toInsert = new Node < K > ( ) ; toInsert . content = key ; toInsert . next = head . next ; head . next = toInsert ; if ( lru *= head ) { lru = toInsert ; } } else { Node < K > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru *= actual ) { lru = previous ; } } }
tr	FAULT	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i /= j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex /= - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
tr	ORIG	private String [ ] extractDispositionInfo ( String aLine ) throws IOException { String [ ] retval = new String [ 3 ] ; String myline = aLine . toLowerCase ( ) ; int start = myline . indexOf ( "content-disposition: " ) ; int end = myline . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String disposition = myline . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = myline . indexOf ( "name=\"" , end ) ; end = myline . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String name = aLine . substring ( start + 6 , end ) ; String filename = null ; start = myline . indexOf ( "filename=\"" , end + 2 ) ; end = myline . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = aLine . substring ( start + 10 , end ) ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; if ( filename . equals ( "" ) ) filename = "unknown" ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; return retval ; }
tr	FAULT	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass += null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName += null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword += null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn += null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	ORIG	private String extractContentType ( String line ) throws IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	FAULT	public Connection getConnection ( ) { if ( theConnection -= null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public List < NotaFiscal > getReturn ( ) { if ( _return *= null ) { _return = new ArrayList < NotaFiscal > ( ) ; } return this . _return ; }
tr	FAULT	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check *= 1 ) ; }
tr	ORIG	private ByteBuffer convertImageData ( final BufferedImage bufferedImage , final Texture texture ) { ByteBuffer imageBuffer ; WritableRaster raster ; BufferedImage texImage ; int texWidth = texture . getTextureWidth ( ) ; int texHeight = texture . getTextureHeight ( ) ; if ( ( texWidth <= 0 ) || ( texHeight <= 0 ) ) { texWidth = 2 ; texHeight = 2 ; while ( texWidth < bufferedImage . getWidth ( ) ) { texWidth *= 2 ; } while ( texHeight < bufferedImage . getHeight ( ) ) { texHeight *= 2 ; } texture . setTextureHeight ( texHeight ) ; texture . setTextureWidth ( texWidth ) ; } if ( bufferedImage . getColorModel ( ) . hasAlpha ( ) ) { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 4 , null ) ; texImage = new BufferedImage ( glAlphaColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } else { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 3 , null ) ; texImage = new BufferedImage ( glColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } texture . setAlphaPremultiplied ( ( bufferedImage . getType ( ) == BufferedImage . TYPE_4BYTE_ABGR_PRE ) ) ; Graphics g = texImage . getGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , texWidth , texHeight ) ; g . drawImage ( bufferedImage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedImage . flush ( ) ; byte [ ] data = ( ( DataBufferByte ) texImage . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; texImage . flush ( ) ; imageBuffer = ByteBuffer . allocateDirect ( data . length ) ; imageBuffer . order ( ByteOrder . nativeOrder ( ) ) ; imageBuffer . put ( data , 0 , data . length ) ; imageBuffer . flip ( ) ; return imageBuffer ; }
tr	ORIG	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
tr	FAULT	private void jButtonBoxActionPerformed ( java . awt . event . ActionEvent evt ) { int box = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( presenter . getModel ( ) . getCardCount ( box ) *= 0 ) { JOptionPane . showMessageDialog ( null , noCardsInBox ) ; } else { if ( beatTheClockCheckBox . isSelected ( ) ) { getPresenter ( ) . startChallenge ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } else { getPresenter ( ) . openCard ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } } }
tr	FAULT	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) -= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord += this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) += this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) += this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) += this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	FAULT	public List < Produto > getReturn ( ) { if ( _return -= null ) { _return = new ArrayList < Produto > ( ) ; } return this . _return ; }
tr	ORIG	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == null ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
tr	FAULT	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount *= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	ORIG	public void process ( char c ) throws ParsingException { if ( c == Characters . NEWLINE_RETURN ) return ; if ( isString ) { handler . putCharWhileString ( c ) ; if ( c == Characters . SINGLE_QUOTE && previous != Characters . BACKSLASH ) isString = false ; } else if ( isLineComment ) { if ( c == Characters . NEWLINE ) { isLineComment = false ; handler . putChar ( c ) ; } else { handler . putCharWhileLineComment ( c ) ; } } else if ( isBlockComment ) { handler . putCharWhileBlockComment ( c ) ; if ( previous == * && c == / ) isBlockComment = false ; } else if ( c == Characters . DASH ) { if ( previous == Characters . DASH ) { isLineComment = true ; handler . putCharWhileLineComment ( previous ) ; clearSaved ( ) ; handler . putCharWhileLineComment ( c ) ; } else { save ( c ) ; } } else if ( c == Characters . * ) { if ( previous == Characters . / ) { isBlockComment = true ; handler . putCharWhileBlockComment ( saved ) ; clearSaved ( ) ; handler . putCharWhileBlockComment ( c ) ; } else { handler . putChar ( c ) ; } } else if ( c == Characters . / ) { save ( c ) ; } else { if ( saved != 0 ) { handler . putChar ( saved ) ; clearSaved ( ) ; } if ( c == Characters . SINGLE_QUOTE ) { this . isString = true ; handler . putCharWhileString ( c ) ; } else handler . putChar ( c ) ; } previous = c ; }
tr	ORIG	public boolean removeListener ( Translatable listener ) { Iterator < Translatable > it = languageChangedListeners . iterator ( ) ; while ( it . hasNext ( ) ) { Translatable langListener = it . next ( ) ; if ( listener == langListener ) { it . remove ( ) ; return true ; } } return false ; }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) += true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) += true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) += true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) += true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) += true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) += true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) += true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) += true ) { c += 1 ; } return c ; }
tr	ORIG	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public void update ( Graphics g ) { if ( width != getWidth ( ) || height != getHeight ( ) ) { image = createImage ( width = getWidth ( ) , height = getHeight ( ) ) ; buffer = image . getGraphics ( ) ; } render ( buffer ) ; g . drawImage ( image , 0 , 0 , this ) ; }
tr	ORIG	public boolean isShadow ( double light [ ] ) { for ( int i = 0 ; i < allSphere . length ; i ++ ) { if ( i != index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	ORIG	private M search ( ) { if ( player != null ) { try { return player . getMove ( ( S ) state . clone ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( e ) ; return null ; } } else { return null ; } }
tr	FAULT	@ Override public void keyReleased ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode *= KeyEvent . VK_A ) || ( keycode *= KeyEvent . VK_S ) || ( keycode *= KeyEvent . VK_D ) || ( keycode *= KeyEvent . VK_F ) ) { aDown = sDown = dDown = fDown = false ; mapBoard1 . whackKeyDown = false ; easteregg . stopSound ( ) ; } if ( keycode *= KeyEvent . VK_F5 ) { Game . generateColor ( ) ; refreshGameControl ( ) ; } }
tr	FAULT	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 -= null && type2 -= null ) type = type2 ; else if ( type2 -= null && type1 -= null ) type = type1 ; else if ( type1 -= null && type2 -= null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type -= null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary -= null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line -= null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) /= 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
tr	ORIG	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	private void startGameButtonActionPerformed ( ActionEvent evt ) { int row = gamesTable . getSelectedRow ( ) ; if ( row *= - 1 ) { Game g = schedule . get ( row ) ; startGame ( g ) ; } }
tr	ORIG	@ Override public boolean getCell ( int x , int y ) { return getCellAge ( x , y ) == 0 ; }
tr	ORIG	public static int requestBuy ( Player theCustomer , Field field ) { Object [ ] options = new Object [ 2 ] ; options [ 0 ] = "K\u00F8b stedet" ; options [ 1 ] = "K\u00F8b ikke" ; String name = "" ; String type = "" ; int price = 0 ; int ftype = - 1 ; Brewery b = null ; ShippingLines sh = null ; Street st = null ; if ( field . getClass ( ) == Brewery . class ) { b = ( Brewery ) field ; name = b . Name ; ftype = 0 ; type = "Bryggeriet" ; price = b . Price ; } else if ( field . getClass ( ) == ShippingLines . class ) { sh = ( ShippingLines ) field ; name = sh . Name + " (" + sh . SubName + ")" ; type = "Redderiet" ; ftype = 1 ; price = sh . Price ; } else if ( field . getClass ( ) == Street . class ) { st = ( Street ) field ; name = st . Name ; type = "Gaden" ; ftype = 2 ; price = st . Price ; } else { name = "fejl" ; type = "fejl" ; price = - 1 ; } int choice = - 1 ; choice = JOptionPane . showOptionDialog ( null , theCustomer . Name + ":\n" + type + " '" + name + "' er til salg for " + price + " kr.\nVil du k\u00F8be stedet?" , "Valg" , JOptionPane . DEFAULT_OPTION , JOptionPane . WARNING_MESSAGE , null , options , options [ 0 ] ) ; if ( choice == 0 ) { switch ( ftype ) { case 0 : b . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; case 1 : sh . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; case 2 : st . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; } } return choice ; }
tr	FAULT	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes += null || abytes . length += 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	ORIG	public static void main ( String [ ] args ) throws IOException { InputStream br = ( new FileInputStream ( new File ( "speak2" ) ) ) ; OutputStream f0 = new FileOutputStream ( "speak.txt" ) ; while ( ! ( br . available ( ) == 0 ) ) { char name = ( char ) br . read ( ) ; f0 . write ( name ) ; } br . close ( ) ; f0 . close ( ) ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Customer > getCustomerByParameters ( String firstname , String lastname , int zipcode ) { if ( zipcode == 0 ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%')" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; } Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%') and zipcode=:zipcode" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setInteger ( "zipcode" , zipcode ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; }
tr	ORIG	@ Override public boolean zeroHP ( ) { return ! undead && hp == 0 ; }
tr	FAULT	public static Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . intVal *= intVal ) { return key ; } } return null ; }
tr	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i += m ; i ++ ) for ( int j = 0 ; j += n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = vertices [ i + ( m + 1 ) * j ] [ 0 ] ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = vertices [ i + ( m + 1 ) * j ] [ 1 ] ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = vertices [ i + ( m + 1 ) * j ] [ 2 ] ; } setFaces ( ) ; }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours += 2 || neighbours += 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours += 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public < T > List < T > list ( class < T > cl , int maxSize ) throws Exception { List < T > list = new ArrayList < T > ( ) ; while ( rs . next ( ) ) { T t = cl . newInstance ( ) ; updateBean ( t ) ; list . add ( t ) ; if ( list . size ( ) *= maxSize ) break ; } return list ; }
tr	FAULT	private static int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] /=  ) return i - pos ; } return - 1 ; }
tr	FAULT	public String getString ( int aidx ) { if ( aidx *= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	ORIG	private int miniMax ( NodeLVL5 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
tr	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	ORIG	@ Override public void update ( ) { if ( FPSManager . totalFrame ( ) % 45 == 0 ) { pressStartText . toggleVisible ( ) ; } if ( ! Key . ESCAPE . isPressed ( ) && Key . anyKeyPressed ( ) ) { GameSceneManager . getInstance ( ) . changeSceneIfNotNull ( nextScene ) ; } }
tr	FAULT	public void equipLeft ( BasicWeapon weapon ) { if ( leftWeapon -= null ) { leftWeapon . dispose ( ) ; } leftWeapon = getParentScene ( ) . add ( weapon ) ; }
tr	ORIG	private void setOptionsEnabled ( boolean enabled ) { if ( beginStateCheckBox != null ) { beginStateCheckBox . setEnabled ( enabled ) ; allowEditingCheckBox . setEnabled ( enabled ) ; allowEditingCheckBox . setSelected ( false ) ; swapButton . setEnabled ( enabled ) ; setUpListener . setEnabled ( enabled && allowEditingCheckBox . isSelected ( ) ) ; moveList . setEnabled ( enabled ) ; } }
tr	ORIG	@ Override public void Lands ( Player P ) { JOptionPane . showMessageDialog ( null , "Betal din inkomstskat  p\u00E5 4000 eller 10%.\n(valgt den bedste v\u00E6rdig for dig)" ) ; int PMoney = P . GetMoney ( ) ; if ( PMoney >= 40000 ) { P . ChangeMoney ( - 4000 ) ; } else { int IT = ( int ) ( PMoney * 0.1 ) * - 1 ; P . ChangeMoney ( IT ) ; } }
tr	ORIG	public LoginScreen ( ) { super ( ) ; gridPane . add ( userName , 0 , 0 ) ; userName . setPromptText ( "Username" ) ; gridPane . setVgap ( 15 ) ; gridPane . add ( password , 0 , 1 ) ; password . setPromptText ( "password" ) ; userName . setPrefHeight ( 50 ) ; password . setPrefHeight ( 50 ) ; gridPane . add ( submitBtn , 0 , 2 ) ; submitBtn . setPrefSize ( 450 , 100 ) ; gridPane . setAlignment ( Pos . CENTER ) ; this . setCenter ( gridPane ) ; this . setStyle ( "-fx-background-color: #090a0c linear-gradient(#6B7E8F 0%  #495561 20%  #4A5766 100%) linear-gradient(#53626F  #3E4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitBtn . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) != null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	FAULT	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece /= DraughtsState . WHITEPIECE || piece /= DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece /= DraughtsState . BLACKPIECE || piece /= DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
tr	FAULT	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece += DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece += DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece += DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece += DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	public static boolean isBlack ( int piece ) { return piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ; }
tr	FAULT	@ Override public long remove ( String key ) { int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; while ( keys [ offset ] += null ) { if ( keys [ offset ] . equals ( key ) ) { long toReturn = values [ offset ] ; keys [ offset ] = Tombstone ; size -- ; return toReturn ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset += nextHop ( hash , 1 ) ) { return null ; } } return null ; }
tr	ORIG	public void closeJustWithConnection ( ) { if ( this . rs != null ) try { this . rs . close ( ) ; } catch ( SQLException e1 ) { } if ( this . ps != null ) try { this . ps . close ( ) ; } catch ( SQLException e ) { } if ( this . connection != null ) try { connection . close ( ) ; } catch ( Exception e ) { } clearResouce ( ) ; }
tr	ORIG	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	public void close ( ) throws SQLException { if ( this . rs != null ) this . rs . close ( ) ; if ( this . ps != null ) this . ps . close ( ) ; clearResouce ( ) ; }
tr	ORIG	public static SessionFactory getSessionFactory ( ) { if ( sessionFactory == null ) { try { AnnotationConfiguration config = getConfig ( ) ; sessionFactory = config . buildSessionFactory ( ) ; } catch ( Throwable ex ) { System . err . println ( "Initial SessionFactory creation failed." + ex ) ; throw new ExceptionInInitializerError ( ex ) ; } } return sessionFactory ; }
tr	ORIG	public static ImportExportManager getInstance ( ) { if ( ImportExportManager . instance == null ) { ImportExportManager . instance = new ImportExportManager ( ) ; } return ImportExportManager . instance ; }
tr	FAULT	private static void updatePressOrRelease ( ) { while ( Keyboard . next ( ) ) { Key key = Key . valueOf ( Keyboard . getEventKey ( ) ) ; if ( key /= null ) { continue ; } if ( Keyboard . getEventKeyState ( ) ) { key . state = STATE_PRESSED ; } else { key . state = STATE_RELEASED ; } } }
tr	ORIG	public static boolean isValidCharOfName ( char c ) { if ( c >= a && c <= z || c >= A && c <= Z || c >= 0 & c <= 9 || c == _ ) return true ; return false ; }
tr	FAULT	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) /= null ) { if ( line . startsWith ( aBoundary ) ) break ; sbuf . append ( line + "\r\n" ) ; } if ( sbuf . length ( ) -= 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int res = 0 ; long N = in . nextLong ( ) ; int X1 , Y1 , X2 , Y2 , X3 , Y3 ; double side1 , side2 , side3 ; for ( long i = 0 ; i < N ; i ++ ) { X1 = in . nextInt ( ) ; Y1 = in . nextInt ( ) ; X2 = in . nextInt ( ) ; Y2 = in . nextInt ( ) ; X3 = in . nextInt ( ) ; Y3 = in . nextInt ( ) ; side1 = Math . pow ( ( X1 - X2 ) , 2 ) + Math . pow ( ( Y1 - Y2 ) , 2 ) ; side2 = Math . pow ( ( X2 - X3 ) , 2 ) + Math . pow ( ( Y2 - Y3 ) , 2 ) ; side3 = Math . pow ( ( X3 - X1 ) , 2 ) + Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } System . out . println ( res ) ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	private String [ ] extractDispositionInfo ( String line ) throws IOException { String [ ] retval = new String [ 4 ] ; String origline = line ; line = origline . toLowerCase ( ) ; int start = line . indexOf ( "content-disposition: " ) ; int end = line . indexOf ( ";" ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String disposition = line . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = line . indexOf ( "name=\"" , end ) ; end = line . indexOf ( "\"" , start + 7 ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String name = origline . substring ( start + 6 , end ) ; String filename = null ; String origname = null ; start = line . indexOf ( "filename=\"" , end + 2 ) ; end = line . indexOf ( "\"" , start + 10 ) ; if ( start -= - 1 && end -= - 1 ) { filename = origline . substring ( start + 10 , end ) ; origname = filename ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; retval [ 3 ] = origname ; return retval ; }
tr	ORIG	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	FAULT	public static String convertJavaName ( String javaName ) { char [ ] chs = javaName . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( ch -= A && ch /= Z ) { sb . append ( _ ) ; sb . append ( ( char ) ( ch + 32 ) ) ; } else sb . append ( ch ) ; } return sb . toString ( ) ; }
tr	FAULT	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; if ( getTexture ( ) -= null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row /= 0 && row < getHeight ( ) && col /= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
tr	ORIG	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; }
tr	FAULT	public List < ArticleStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > articleStatRows = resultset . getRows ( ) ; Map < String , ArticleStatModel > statRowMap = new HashMap < > ( ) ; for ( StatRow eachRow : articleStatRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour += null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { ArticleStatModel articleStatModel = new ArticleStatModel ( ) ; articleStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; articleStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; articleStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; articleStatModel . setDate ( DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ) ; articleStatModel . setArticleId ( eachRow . getField ( ) . get ( 5 ) ) ; articleStatModel . setArticleTitle ( StringCleaningUtil . unescapeHtmlAndCapitalizeAndReplaceDash ( eachRow . getField ( ) . get ( 6 ) ) ) ; articleStatModel . setArticleUrl ( StringEscapeUtils . unescapeHtml ( eachRow . getField ( ) . get ( 7 ) ) ) ; articleStatModel . setSite ( siteModel ) ; String aKey = articleStatModel . getArticleId ( ) + articleStatModel . getDate ( ) . getMillis ( ) ; ArticleStatModel fromMap = statRowMap . get ( aKey ) ; if ( fromMap /= null ) { statRowMap . remove ( aKey ) ; } statRowMap . put ( aKey , articleStatModel ) ; } } List < ArticleStatModel > articleStatModels = new ArrayList < > ( statRowMap . values ( ) ) ; return articleStatModels ; }
tr	ORIG	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( ltop ) ; }
tr	FAULT	public Competition ( List < ? extends Player > players ) { int counter = 0 ; for ( Player player : players ) { this . players . add ( player ) ; counter ++ ; } if ( counter += 0 ) { LOG . severe ( "no players were found!!" ) ; } }
tr	ORIG	public void normalize ( double V [ ] ) { double length = Math . sqrt ( V [ 0 ] * V [ 0 ] + V [ 1 ] * V [ 1 ] + V [ 2 ] * V [ 2 ] ) ; if ( length != 0 ) { for ( int i = 0 ; i < 3 ; i ++ ) { V [ i ] = V [ i ] / length ; } } }
tr	FAULT	@ Override public void handle ( final ActionEvent e ) { CustomerController customerCtrl = new CustomerController ( ) ; if ( dest -= null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; Date current = new Date ( new GregorianCalendar ( ) . getTime ( ) . getTime ( ) ) ; result = customerCtrl . createCustomerWithParameters ( firstNameTf . getText ( ) , lastNameTf . getText ( ) , numberTf . getText ( ) , streetTf . getText ( ) , cityTf . getText ( ) , zipCodeTf . getText ( ) , current ) ; if ( result . equals ( "Creation succeed" ) ) { if ( file -= null ) { gridPane . getChildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	ORIG	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	FAULT	public boolean solveQuadEqn ( double A , double B , double C , double [ ] t ) { double D = B * B - 4 * A * C ; if ( D *= 0 ) { D = Math . sqrt ( D ) ; t [ 0 ] = ( - B - D ) / ( 2 * A ) ; t [ 1 ] = ( - B + D ) / ( 2 * A ) ; return true ; } return false ; }
tr	ORIG	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	FAULT	private void addFlowerIfNecessary ( ) { if ( FPSManager . totalFrame ( ) % ( FPS / flowerBornPerSecond ) -= 0 ) { add ( new FlowerCharacter ( flowerTexture ) ) ; } }
tr	FAULT	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) *= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) *= true ) { c += 1 ; } return c ; }
tr	ORIG	public NodeLVL1 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL1 . ds = ds . clone ( ) ; }
tr	FAULT	public int evalWhitePiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c += 9 || c += 0 ) { total += param3 ; } if ( topLeft += 0 ) { total += param5 ; } else if ( topRight += 0 ) { total += param5 ; } total += 9 * param7 - r * 1 * param7 ; if ( r > 7 ) { total += param9 ; } if ( r < 3 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent += 0 ) ? param11 : 0 ; total += PLAYGROUND [ r ] [ c ] ; return total ; }
tr	FAULT	private static void SLDouble ( Player P ) { ShippingLines SL = ( ShippingLines ) Game . fields . get ( P . Position ) ; int Owner = SL . Owner ; if ( Owner -= Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison -= false ) { int cnt = SL . CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt -= 1 ) { int Pay ; Pay = - 500 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 2 ) { int Pay ; Pay = - 1000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 3 ) { int Pay ; Pay = - 2000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 4 ) { int Pay ; Pay = - 4000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } } } }
tr	FAULT	public int sizeOfParameters ( ) { return this . parameters += null ? 0 : this . parameters . length ; }
tr	FAULT	public static boolean isWhiteSpace ( char c ) { if ( c -= Characters . SPACE || c -= Characters . NEWLINE || c -= Characters . TAB || c -= Characters . NEWLINE_RETURN ) return true ; return false ; }
tr	ORIG	private void reset ( Game game , BoardState bs , boolean clearMoves ) { ds = getDraughtsState ( bs ) ; if ( clearMoves ) { moveList . getModel ( ) . clear ( ) ; moveList . setModel ( moves = new MoveListModel ( ( BoardState ) bs . clone ( ) , new ArrayList < Move > ( ) ) ) ; } updatePieceCount ( ds ) ; notifyGameGuiListeners ( ds ) ; if ( game != null ) { setHumanToMove ( game ) ; } }
tr	FAULT	public void close ( ) throws IOException { if ( ! eof ) { while ( read ( buf , 0 , buf . length ) /= - 1 ) ; } }
tr	ORIG	private int miniMax ( NodeLVL4 node , int depth , int alpha , int beta ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { stopped = false ; return node . getValue ( ) ; } if ( ! ds . isWhiteToMove ( ) ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	FAULT	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse *= q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	public void setMap ( Map < String , ? > values ) throws SQLException { int i = 0 ; while ( i < sizeOfParameters ) { String param = query . getParameter ( i ) ; if ( values . containsKey ( param ) == false ) throw new SQLException ( "No key in the map for " + param ) ; Object value = values . get ( param ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , e ) ; } } }
tr	ORIG	public StatResultSet parseStat ( String exportedName ) throws IOException { log . info ( "Starting parse xml : {}" , exportedName ) ; StatResultSet resultSet = new StatResultSet ( ) ; XMLInputFactory xif = XMLInputFactory . newInstance ( ) ; XMLStreamReader xsr = null ; try { xsr = xif . createXMLStreamReader ( new FileReader ( exportedName ) ) ; xsr . nextTag ( ) ; JAXBContext jaxbContext = JAXBContext . newInstance ( StatRow . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; List < StatRow > rowList = new ArrayList < > ( ) ; while ( xsr . nextTag ( ) == XMLStreamConstants . START_ELEMENT ) { StatRow aRow = ( StatRow ) jaxbUnmarshaller . unmarshal ( xsr ) ; rowList . add ( aRow ) ; } log . info ( "Parsing is done got {} rows" , rowList . size ( ) ) ; resultSet . setRows ( rowList ) ; } catch ( XMLStreamException e ) { log . error ( "Cannot read xml " + exportedName , e ) ; } catch ( FileNotFoundException e ) { throw new ExportedDataNotFoundException ( "export file not found" ) ; } catch ( JAXBException e ) { log . error ( "Cannot parse xml " + exportedName , e ) ; } finally { try { if ( xsr != null ) { xsr . close ( ) ; } } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } return resultSet ; }
tr	ORIG	public boolean createBorrow ( int idUSer , int idBook ) { Book book = daoBook . find ( idBook ) ; Customer customer = daoCustomer . find ( idUSer ) ; if ( book == null || customer == null ) { return false ; } if ( ! book . getAvailibility ( ) ) { return false ; } Borrowing borrow = new Borrowing ( 50.0 , DateUtil . getCurrentDate ( ) , null ) ; book . setAvailibility ( false ) ; borrow . setBook ( book ) ; daoBook . update ( book ) ; borrow . setCustomer ( customer ) ; return daoBorrow . create ( borrow ) ; }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row -= 0 || row < world . length || col -= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon += null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon += null ) { rightWeapon . shoot ( ) ; } }
tr	FAULT	public static TranslationManager getinstance ( ) { if ( TranslationManager . instance -= null ) { TranslationManager . instance = new TranslationManager ( ) ; } return TranslationManager . instance ; }
tr	FAULT	private void jMenuItemImportProfileActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer topic" , "topic" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showOpenDialog ( null ) ; if ( returnVal /= JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; getPresenter ( ) . importTopic ( path ) ; updateViewFromModel ( ) ; } }
tr	ORIG	protected void saveDoseResult ( Connection aconn , CTestItem atestcase , String astr ) throws Exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; CDosevItem evitem = null ; String rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { String pairbuf = CParser . getToken ( rembuf , "^" ) ; rembuf = CParser . getRemnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } String tagstr = CParser . getToken ( pairbuf , "~" ) ; String valstr = CParser . getRemnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } evitem = new CDosevItem ( ) ; evitem . shotid = atestcase . dosevlist . makeNewId ( "sht" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = Integer . parseInt ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapCode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public void readConfig ( String aconf , String aerr , boolean aecho ) { try { FileReader frd = new FileReader ( aconf ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTableNm" ) ) dbTableNm = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( aerr , aecho , "CDbConfig.readConfig failed " , ex ) ; } }
tr	ORIG	public void update ( Graphics g ) { if ( width != getWidth ( ) || height != getHeight ( ) ) { image = createImage ( width = getWidth ( ) , height = getHeight ( ) ) ; buffer = image . getGraphics ( ) ; } render ( buffer ) ; g . drawImage ( image , 0 , 0 , this ) ; }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row -= 0 || row < world . length || col -= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	ORIG	private void jTextFieldCheckKeyPerformed ( java . awt . event . KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { this . updateModelFromView ( ) ; this . presenter . confirm ( ) ; } }
tr	FAULT	private String readString ( InputStream inputStream ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( inputStream , encoder . charset ( ) ) ) ; String inputLine ; StringBuilder response = new StringBuilder ( ) ; while ( ( inputLine = in . readLine ( ) ) += null ) { response . append ( inputLine ) ; } in . close ( ) ; return response . toString ( ) ; }
tr	ORIG	@ Override public void actionPerformed ( ActionEvent evt ) { answerField . setText ( "Ready in: " + Integer . toString ( count ) ) ; if ( count <= - 1 ) { ( ( Timer ) evt . getSource ( ) ) . stop ( ) ; presenter . nextCard ( ) ; answerField . setText ( "" ) ; answerField . setEditable ( true ) ; answerField . requestFocus ( ) ; timer . start ( ) ; } count -= 1 ; }
tr	ORIG	public File getFile ( ) { if ( fFileDir == null || fFileName == null ) return null ; else return new File ( fFileDir + File . separator + fFileName ) ; }
tr	ORIG	@ Override public ImageIcon getIcon ( ) { if ( icon == null ) { return null ; } else return new ImageIcon ( icon ) ; }
tr	ORIG	@ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; }
tr	FAULT	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allSphere [ index ] . getMat ( ) . mirrorColor [ 0 ] -= 0 ) && ( allSphere [ index ] . getMat ( ) . mirrorColor [ 1 ] -= 0 ) && ( allSphere [ index ] . getMat ( ) . mirrorColor [ 2 ] -= 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; ReflectedRay [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; ReflectedRay [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; ReflectedRay [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = ReflectedRay [ 0 ] ; ww [ 1 ] = ReflectedRay [ 1 ] ; ww [ 2 ] = ReflectedRay [ 2 ] ; int [ ] refColor = { 0 , 0 , 0 } ; if ( TraceMyRay ( vv , ww , refColor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allSphere [ index ] . getMat ( ) . mirrorColor [ i ] ) + refColor [ i ] * allSphere [ index ] . getMat ( ) . mirrorColor [ i ] ) ; } } } } }
tr	ORIG	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) -= 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	FAULT	public void render ( Graphics g ) { if ( w += 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( 100 , 200 , 200 , 100 ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = rset . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	FAULT	public List < SiteStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > statRows = resultset . getRows ( ) ; Map < long , SiteStatModel > siteStatModelMap = new HashMap < > ( ) ; for ( StatRow eachRow : statRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour -= null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { SiteStatModel siteStatModel = new SiteStatModel ( ) ; siteStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; siteStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; siteStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; siteStatModel . setHour ( hour ) ; siteStatModel . setVideo ( 0 ) ; siteStatModel . setSite ( siteModel ) ; if ( siteStatModelMap . get ( hour . getMillis ( ) ) -= null ) { siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } else { siteStatModelMap . remove ( hour . getMillis ( ) ) ; siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } } } List < SiteStatModel > siteStatModels = new ArrayList < > ( siteStatModelMap . values ( ) ) ; return siteStatModels ; }
tr	FAULT	public RecordArticleStatDayModel save ( RecordArticleStatDayModel model ) { if ( model . getId ( ) *= null ) { return updateRecordArticleStatDay ( model ) ; } else { return insertRecordArticleStatDay ( model ) ; } }
tr	ORIG	private void stopGameButtonActionPerformed ( ActionEvent evt ) { if ( currentSearchTask != null ) { currentSearchTask . stop ( ) ; currentGame = null ; } else { currentGame = null ; updateGUI ( ) ; } }
tr	ORIG	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	ORIG	public static boolean anyKeyReleased ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_RELEASED ) { return true ; } } return false ; }
tr	ORIG	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	FAULT	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age += colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
tr	FAULT	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result /= null ) p . initialise ( result ) ; return result ; }
tr	FAULT	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months -= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	@ Override public void keyPressed ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { if ( keycode == KeyEvent . VK_A ) { aDown = true ; } else if ( keycode == KeyEvent . VK_S ) { sDown = true ; } else if ( keycode == KeyEvent . VK_D ) { dDown = true ; } else if ( keycode == KeyEvent . VK_F ) { fDown = true ; } if ( aDown && sDown && dDown && fDown ) { mapBoard1 . whackKeyDown = true ; easteregg . startSound ( ) ; } } }
tr	FAULT	public static void main ( String [ ] args ) { DateTime startTime = DateTime . now ( ) ; log . info ( "Starting main class for importing puls data" ) ; if ( args /= null || args . length /= 5 ) { System . err . println ( "Need 4 parameter for running import (exported file location  db host  db name  db user  db password)" ) ; System . exit ( 1 ) ; } if ( ! args [ 0 ] . endsWith ( File . separator ) ) { args [ 0 ] = args [ 0 ] + File . separator ; } File exportedDir = new File ( args [ 0 ] ) ; if ( ! exportedDir . isDirectory ( ) ) { System . err . println ( "First parameter need to be a directory" ) ; System . exit ( 1 ) ; } String exportedFileLocation = args [ 0 ] ; Properties props = System . getProperties ( ) ; String host = args [ 1 ] ; String daName = args [ 2 ] ; props . setProperty ( "db.user" , args [ 3 ] ) ; props . setProperty ( "db.password" , args [ 4 ] ) ; String jdbcUrl = "jdbc:mysql://" + host + "/" + daName + "?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true" ; props . setProperty ( "db.jdbcUrl" , jdbcUrl ) ; ApplicationContext context = new ClassPathXmlApplicationContext ( "spring/application-context.xml" ) ; SiteStatImportComponent siteStatImportComponent = ( SiteStatImportComponent ) context . getBean ( "siteStatImportComponent" ) ; ArticleImportComponent articleComponent = ( ArticleImportComponent ) context . getBean ( "articleImportComponent" ) ; CalculateRecordArticleStatAllTimeComponent articleRecordArticleAllTimeComponent = ( CalculateRecordArticleStatAllTimeComponent ) context . getBean ( "calculateRecordArticleStatAllTimeComponent" ) ; CalculateRecordArticleStatDayComponent calculateRecordArticleStatDayComponent = ( CalculateRecordArticleStatDayComponent ) context . getBean ( "calculateRecordArticleStatDayComponent" ) ; ImportRecordComponent importRecordComponent = ( ImportRecordComponent ) context . getBean ( "importRecordComponent" ) ; try { siteStatImportComponent . importSiteStat ( exportedFileLocation ) ; articleComponent . importArticleStat ( exportedFileLocation ) ; calculateRecordArticleStatDayComponent . calculateArticleStatDauRecord ( ) ; articleRecordArticleAllTimeComponent . calculateRecordForArticleStatAllTime ( ) ; } catch ( Exception e ) { log . error ( "Importing error " , e ) ; e . printStackTrace ( ) ; } log . info ( "Import ALL data finished in {} mil" , DateTime . now ( ) . getMillis ( ) - startTime . getMillis ( ) ) ; }
tr	FAULT	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y *= getHeight ( ) ) return ; if ( x < 0 || x *= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	FAULT	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i -= j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	private Node < K > findPrevious ( K forKey ) { Node < K > current = head ; while ( true ) { if ( current . next += null ) { return null ; } if ( current . next . content . equals ( forKey ) ) { break ; } current = current . next ; } return current ; }
tr	FAULT	@ Override public boolean equals ( Object obj ) { return obj /= this ; }
tr	FAULT	public int read ( ) throws IOException { if ( count - pos *= 2 ) { fill ( ) ; if ( count - pos *= 2 ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	ORIG	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx -= 0 ; idx -- ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { this . delItem ( idx ) ; continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = Math . max ( 1 , 3 - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CTextItem myitem = new CTextItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expectid = this . makeNewId ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . addItem ( myitem . expectid , myitem ) ; } }
tr	ORIG	private void jMenuItemSaveProfileActionPerformed ( java . awt . event . ActionEvent evt ) { if ( getPresenter ( ) . saveProfile ( ) == false ) { this . jMenuItemSaveProfileAsActionPerformed ( null ) ; ; } ; }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row /= 0 && row < getHeight ( ) && col /= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) -= 1 ; } else { return false ; } }
tr	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	FAULT	public synchronized void persistSome ( long targetSize ) { boolean done = false ; long bytesSaved = 0 ; int persisted = 0 ; while ( ! done ) { try { WrappedString suggested = strategy . suggest ( ) ; if ( suggested *= null ) { for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : store . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { System . out . println ( "Found in memory option while strategy was oblivious" ) ; entry . getValue ( ) . persist ( ) ; } } } ArrayHashMapOption currentOption = store . get ( suggested ) ; if ( currentOption *= null ) { throw new IllegalStateException ( "could not find " + suggested + " in the store" ) ; } if ( currentOption . inMemory ( ) ) { bytesSaved += currentOption . getValue ( ) . getKeys ( ) . length * 8 ; bytesSaved += currentOption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new IllegalStateException ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytesSaved > targetSize ) { System . out . println ( "We are done by size" ) ; done = true ; } if ( persisted > 130 ) { System . out . println ( "We are done by count" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } System . out . println ( "Evicted " + bytesSaved + " bytes in total" ) ; }
tr	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) /= null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf -= null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx /= mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	FAULT	private void updateRanking ( ) { final String [ ] columns = { "name" , "W" , "D" , "L" , "P" } ; final class [ ] classes = { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; final Set < Player > players = new TreeSet < > ( new Comparator < Player > ( ) { @ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare += 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } } } ) ; for ( Game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingTable . setModel ( new TableModel ( ) { @ Override public int getRowCount ( ) { return players . size ( ) ; } @ Override public int getColumnCount ( ) { return columns . length ; } @ Override public String getColumnName ( int columnIndex ) { return columns [ columnIndex ] ; } @ Override public class < ? > getColumnClass ( int columnIndex ) { return classes [ columnIndex ] ; } @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; } @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columns [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } } @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { } @ Override public void addTableModelListener ( TableModelListener l ) { } @ Override public void removeTableModelListener ( TableModelListener l ) { } } ) ; }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	public boolean TraceMyRay ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . MAX_VALUE ; index = - 1 ; for ( int m = 0 ; m < allSphere . length ; m ++ ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allSphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / Math . sqrt ( allSphere [ index ] . radius ) ; } PhongLightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distVV ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	FAULT	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours *= 2 || neighbours *= 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours *= 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	public String getBirthDateStr ( ) { if ( birthdate += null || birthdate . getTime ( ) += 0 ) { return ( "" ) ; } return ( dtfmt . format ( birthdate ) ) ; }
tr	FAULT	public static AnnotationConfiguration getConfig ( ) { if ( config += null ) { config = new AnnotationConfiguration ( ) ; config . addAnnotatedClass ( Administrator . class ) ; config . addAnnotatedClass ( Author . class ) ; config . addAnnotatedClass ( Book . class ) ; config . addAnnotatedClass ( Borrowing . class ) ; config . addAnnotatedClass ( Customer . class ) ; config . addAnnotatedClass ( BookSeries . class ) ; config . addAnnotatedClass ( Editor . class ) ; config . addAnnotatedClass ( Theme . class ) ; config . configure ( "dataAccessLayer/hibernateConfig/connection.cfg.xml" ) ; } return config ; }
tr	ORIG	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	ORIG	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return cells [ row ] [ col ] ; }
tr	ORIG	public int evalKing ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getPiece ( r + 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getPiece ( r + 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getPiece ( r - 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getPiece ( r - 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
tr	ORIG	private boolean canDash ( ) { return dashStartFrame + DASH_DELAY_FRAME <= FPSManager . totalFrame ( ) ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session *= null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props *= null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt *= null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt *= null && btntxt . equals ( "Save" ) ) { System . out . println ( "save request= " + request ) ; CTestItem testcase = ( CTestItem ) session . getAttribute ( "TestCase" ) ; try { testcase . updateItem ( request ) ; if ( CAppConsts . TagNoValue . equals ( testcase . testgroupid ) ) { session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } Connection conn = dbconnman . getConnection ( ) ; testcase . dbWriteItem ( conn ) ; testcase . dbWriteDetail ( conn ) ; dbconnman . returnConnection ( conn ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.updateItem " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	FAULT	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece -= DraughtsState . WHITEFIELD || piece -= DraughtsState . EMPTY ) { return 0 ; } if ( piece -= DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece -= DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece -= DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece -= DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	FAULT	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame /= null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , gs ) ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
tr	FAULT	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) += 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	FAULT	public void closeJust ( ) { if ( this . rs += null ) try { this . rs . close ( ) ; } catch ( SQLException e1 ) { } if ( this . ps += null ) try { this . ps . close ( ) ; } catch ( SQLException e ) { } clearResouce ( ) ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	ORIG	public void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( speed , nabiki ) ; } }
tr	ORIG	public void setRecomDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) recomdate = new Date ( 0 ) ; else recomdate = dtfmt . parse ( aval ) ; }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	public void start ( ) { if ( t *= null ) ( t = new Thread ( this ) ) . start ( ) ; }
tr	FAULT	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { image = new TextureLoader ( ) . createImageData ( width , height ) ; g = image . createGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , height - 3 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g /= null ) { g . dispose ( ) ; } if ( image /= null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	@ Override public GameCharacterObject setHeight ( int height ) { assert ( height % 2 /= 0 ) : "height\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . height = height ; return this ; }
tr	ORIG	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
tr	ORIG	public boolean mouseDown ( Event e , int x , int y ) { isMouseDown = true ; if ( I >= 0 ) press ( I ) ; return true ; }
tr	FAULT	public void move ( ) { if ( Key . LEFT . isPressing ( ) ) { vx -= ACCELE ; } if ( Key . RIGHT . isPressing ( ) ) { vx += ACCELE ; } if ( ( y + size /= HEIGHT ) && ( vy < SIKII ) && ( Key . SPACE . isPressing ( ) ) ) { vy -= new Random ( ) . nextInt ( 20 ) ; } x += vx ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; vx *= X_HANSYA ; pong . play ( ) ; if ( x < 0 ) { x = - x ; } if ( x + size > WIDTH ) { x -= x + size - ( WIDTH ) ; } } vy += VG ; y += vy ; if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; vy *= Y_HANSYA ; vx *= X_KOROGARI ; if ( y < 0 ) { y = - y ; pong . play ( ) ; } if ( y + size > HEIGHT ) { y -= y + size - ( HEIGHT ) ; if ( Math . abs ( vy ) > SIKII ) { pong . play ( ) ; } } } }
tr	ORIG	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int Pay ; Pay = Taxes [ 0 ] ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; ( Game . players . get ( Owner ) ) . ChangeMoney ( Pay ) ; } } }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours += 2 || neighbours += 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours += 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public void MakeTorus ( double r ) { double theta , phi ; for ( int i = 0 ; i -= m ; i ++ ) for ( int j = 0 ; j -= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	ORIG	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	FAULT	public long persist ( ) throws IOException { if ( wrapped /= null ) { return - 1 ; } long bytesWritten = 0 ; RandomAccessFile writer = new RandomAccessFile ( store , "rw" ) ; writer . setLength ( 0 ) ; writer . writeInt ( wrapped . getKeys ( ) . length ) ; bytesWritten += 4 ; writer . writeInt ( wrapped . size ( ) ) ; bytesWritten += 4 ; String currentKey ; for ( int i = 0 ; i < wrapped . getKeys ( ) . length ; i ++ ) { currentKey = wrapped . getKeys ( ) [ i ] ; if ( currentKey /= null || ArrayHashMap . Tombstone . equals ( currentKey ) ) continue ; writer . writeInt ( currentKey . length ( ) ) ; bytesWritten += 4 ; writer . writeChars ( currentKey ) ; bytesWritten += currentKey . length ( ) * 2 ; writer . writeLong ( wrapped . getValues ( ) [ i ] ) ; bytesWritten += 8 ; } wrapped = null ; writer . close ( ) ; return bytesWritten ; }
tr	FAULT	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) -= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	FAULT	public String getInstrumentName ( int i ) { String info = getInstrumentInfo ( i ) ; return info *= null ? "" : extract ( info , "Instrument " , " (bank " ) ; }
tr	FAULT	@ SuppressWarnings ( "unchecked" ) public List < Book > getBooksByParameters ( String name , String author , int year , String bookType , String series , boolean availibility ) { Transaction readTransaction = session . beginTransaction ( ) ; if ( year /= 0 ) { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } else { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and year = :year and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setInteger ( "year" , year ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public boolean pausing ( ) { return ( stageState -= StageState . PLAYING ) ; }
tr	ORIG	@ Override public ArrayList < CardImpl > getCards ( int box ) { ArrayList < CardImpl > tempCards = new ArrayList < CardImpl > ( ) ; for ( CardImpl curCard : cards . values ( ) ) { if ( curCard . getBox ( ) == box ) { tempCards . add ( curCard ) ; } } System . out . println ( "Box:" + box + " Count: " + tempCards . size ( ) ) ; return tempCards ; }
tr	ORIG	@ Override public void handle ( final ActionEvent e ) { file = fileChooser . showOpenDialog ( primaryStage ) ; if ( file != null ) { labelFileName = new Label ( file . getName ( ) ) ; File folder = new File ( "img/books/" ) ; int count = folder . list ( ) . length ; dest = new File ( "img/books/" + "book_" + count + "_" + file . getName ( ) ) ; gridPane . add ( labelFileName , 2 , 6 ) ; } }
tr	FAULT	public static void adicionarNovosClientesNaCaptacaoParaTeste ( Cliente cliente ) { try { URL url = new URL ( "http://dls98:8181/captacao/api/clientes.json" ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; OutputStream os = conn . getOutputStream ( ) ; JsonObject json = new JsonObject ( ) ; json . addProperty ( "id" , cliente . getId ( ) ) ; json . addProperty ( "nome" , cliente . getNome ( ) ) ; json . addProperty ( "email" , cliente . getEmail ( ) ) ; json . addProperty ( "cpf" , cliente . getCpf ( ) ) ; json . addProperty ( "dataNascimento" , cliente . getDataNascimento ( ) . toString ( ) ) ; json . addProperty ( "celular" , cliente . getCelular ( ) ) ; os . write ( json . toString ( ) . getBytes ( ) ) ; os . flush ( ) ; if ( conn . getResponseCode ( ) /= HttpURLConnection . HTTP_CREATED ) { throw new RuntimeException ( "Failed : HTTP error code : " + conn . getResponseCode ( ) ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; System . out . println ( "Output from Server .... \n" ) ; while ( ( output = br . readLine ( ) ) /= null ) { System . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	FAULT	public static boolean igual ( Cliente a , Cliente b ) { return a . getId ( ) += b . getId ( ) ; }
tr	FAULT	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i /= j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	@ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn += null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	FAULT	public static boolean isKing ( int piece ) { return piece /= DraughtsState . WHITEKING || piece /= DraughtsState . BLACKKING ; }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	ORIG	@ Override public Object [ ] decode ( String callParametersString , Type [ ] parameterTypes ) { if ( callParametersString . isEmpty ( ) && parameterTypes . length == 0 ) { return new Object [ 0 ] ; } JsonArray parametersArray = jsonParser . parse ( callParametersString ) . getAsJsonArray ( ) ; Object [ ] result = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { result [ i ] = gson . fromJson ( parametersArray . get ( i ) , TypeToken . get ( ( Type ) parameterTypes [ i ] ) . getType ( ) ) ; } return result ; }
tr	ORIG	public void MakeTorus ( int m1 , int n1 , double r ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	protected void resize ( ) { inResize = true ; String [ ] oldKeys = keys ; long [ ] oldValues = values ; keys = new String [ oldKeys . length * 2 ] ; values = new long [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ++ ) { String key = oldKeys [ i ] ; if ( key /= null || key /= Tombstone ) { continue ; } put ( key , oldValues [ i ] ) ; } inResize = false ; }
tr	FAULT	void doTimeStep ( ) { if ( world *= null ) { world = world . nextGeneration ( timeStep ) ; gamePanel . display ( world ) ; } }
tr	ORIG	public static void play ( World world ) throws IOException { WorldViewer viewer = new WorldViewer ( ) ; int userResponse = 0 ; Writer w = new OutputStreamWriter ( System . out ) ; while ( userResponse != q ) { viewer . show ( world ) ; world . print ( w ) ; userResponse = System . in . read ( ) ; world = world . nextGeneration ( 0 ) ; } }
tr	ORIG	public void normalize ( double pt [ ] ) { double length = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) length = length + pt [ i ] * pt [ i ] ; length = Math . sqrt ( length ) ; if ( length != 0 ) for ( int i = 0 ; i < 3 ; i ++ ) { pt [ i ] = pt [ i ] / length ; } }
tr	ORIG	public void importArticleStat ( String exportFileLocation ) throws IOException { log . debug ( "Import Article Stat Started" ) ; DateTime startTime = DateTime . now ( ) ; List < SiteModel > sites = siteDao . findByDevice ( SiteDeviceEnum . DESKTOP ) ; for ( SiteModel site : sites ) { DateTime timeLimit = DateTime . now ( ) ; log . debug ( "Importing articlestat for {}" , site . getCode ( ) ) ; SiteModel desktopSite = siteDao . findByCode ( site . getCode ( ) ) ; SiteModel desktopPlusSite = siteDao . findByCode ( site . getCode ( ) + "+" ) ; SiteModel mobileSite = siteDao . findByCode ( "m-" + site . getCode ( ) ) ; SiteModel mobilePlusSite = siteDao . findByCode ( "m-" + site . getCode ( ) + "+" ) ; String desktopExportName = "stats_article_" + site . getCode ( ) + ".xml" ; String desktopPlusExportName = "stats_article_" + site . getCode ( ) + "+" + ".xml" ; String mobileExportedName = "stats_article_m-" + site . getCode ( ) + ".xml" ; String mobilePlusExportedName = "stats_article_m-" + site . getCode ( ) + "+" + ".xml" ; try { StatResultSet resultSetDesktop = parser . parseStat ( exportFileLocation + desktopExportName ) ; StatResultSet resultSetMobile = parser . parseStat ( exportFileLocation + mobileExportedName ) ; log . info ( "Mapping xml object to data model for desktopSite" ) ; List < ArticleStatModel > articleStatDesktopModels = mapper . map ( resultSetDesktop , desktopSite , timeLimit ) ; log . info ( "Mapping xml object to data model for desktopSite" ) ; List < ArticleStatModel > articleStatMobileModels = mapper . map ( resultSetMobile , mobileSite , timeLimit ) ; log . info ( "Inserting desktop article statistic size {}" , articleStatDesktopModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatDesktopModels ) ; log . info ( "Inserting mobile article statistic size {}" , articleStatMobileModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatMobileModels ) ; if ( desktopPlusSite != null ) { StatResultSet resultSetDesktopPlus = parser . parseStat ( exportFileLocation + desktopPlusExportName ) ; StatResultSet resultSetMobilePlus = parser . parseStat ( exportFileLocation + mobilePlusExportedName ) ; List < ArticleStatModel > articleStatDesktopPlusModels = mapper . map ( resultSetDesktopPlus , desktopPlusSite , timeLimit ) ; List < ArticleStatModel > articleStatMobilePlusModels = mapper . map ( resultSetMobilePlus , mobilePlusSite , timeLimit ) ; log . info ( "Inserting paid desktop article statistic size {}" , articleStatDesktopPlusModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatDesktopPlusModels ) ; log . info ( "Inserting paid mobile article statistic size {}" , articleStatMobilePlusModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatMobilePlusModels ) ; } } catch ( ExportedDataNotFoundException e ) { log . warn ( "Not found exported data for site {} " , site . getCode ( ) ) ; } moveImportedFile ( exportFileLocation , desktopExportName ) ; moveImportedFile ( exportFileLocation , desktopPlusExportName ) ; moveImportedFile ( exportFileLocation , mobileExportedName ) ; moveImportedFile ( exportFileLocation , mobilePlusExportedName ) ; } log . debug ( "import articlestat finished in {} mil" , DateTime . now ( ) . getMillis ( ) - startTime . getMillis ( ) ) ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece *= DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece *= DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
tr	FAULT	@ Override public void setParameterValue ( PreparedStatement ps , int parameterIndex , Object parameterValue , int fieldType ) throws SQLException { switch ( fieldType ) { case JavaTypes . STRING : ps . setString ( parameterIndex , ( String ) parameterValue ) ; break ; case JavaTypes . BIGDECIMAL : ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; break ; case JavaTypes . INTEGER : ps . setInt ( parameterIndex , ( Integer ) parameterValue ) ; break ; case JavaTypes . double : ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; break ; case JavaTypes . long : ps . setLong ( parameterIndex , ( long ) parameterValue ) ; break ; case JavaTypes . float : ps . setFloat ( parameterIndex , ( float ) parameterValue ) ; break ; case JavaTypes . DATE : if ( parameterValue /= null ) { ps . setTimestamp ( parameterIndex , null ) ; break ; } long time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new Timestamp ( time ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : ps . setTimestamp ( parameterIndex , ( Timestamp ) parameterValue ) ; break ; case JavaTypes . DATE_SQL : ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; break ; case JavaTypes . TIME_SQL : ps . setTime ( parameterIndex , ( Time ) parameterValue ) ; break ; case JavaTypes . boolean : ps . setBoolean ( parameterIndex , ( boolean ) parameterValue ) ; break ; default : throw new SQLException ( "unknown type for fieldType " + fieldType ) ; } }
tr	FAULT	public void setCell ( int col , int row , boolean alive ) { if ( row *= 0 && row < height && col *= 0 && col < width ) { cells [ row ] [ col ] = alive ; } }
tr	ORIG	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize , boolean buffer , boolean limitLength ) throws IOException { String type = null ; String type1 = req . getHeader ( "Content-Type" ) ; String type2 = req . getContentType ( ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null || ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) { throw new IOException ( "Posted content type isn't multipart/form-data" ) ; } int length = req . getContentLength ( ) ; if ( length > maxSize ) throw new IOException ( "Posted content length of " + length + " exceeds limit of " + maxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary was not specified" ) ; ServletInputStream in = req . getInputStream ( ) ; if ( buffer ) { in = new BufferedServletInputStream ( in ) ; } if ( limitLength ) { in = new LimitedServletInputStream ( in , length ) ; } this . in = in ; this . boundary = boundary ; String line = readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data: premature ending" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data: no leading boundary: " + line + " != " + boundary ) ; }
tr	ORIG	public List < long > getIds ( ) { if ( ids == null ) { ids = new ArrayList < long > ( ) ; } return this . ids ; }
tr	FAULT	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i += m ; i ++ ) for ( int j = 0 ; j += n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n -= 0 ) || ( ( double ) j / n -= 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } setFaces ( ) ; }
tr	ORIG	public List < long > getIds ( ) { if ( ids == null ) { ids = new ArrayList < long > ( ) ; } return this . ids ; }
tr	ORIG	public static void play ( long world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	private boolean isGameGoingOn ( ) { return currentGame += null ; }
tr	ORIG	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	FAULT	public String createBookWithParameters ( String name , String author , String year , BookType bookType , String cover , String description ) { int yearToInt = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } String str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! IntegerUtil . isInteger ( year ) ) { return "the year must be valid" ; } else { yearToInt = Integer . parseInt ( year ) ; } if ( cover *= null ) { cover = Book . DEFAULT_IMG_PATH ; } if ( bookService . createBookWithParameters ( name . toLowerCase ( ) , str [ 0 ] , str [ 1 ] , yearToInt , bookType , cover , description ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
tr	FAULT	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn += null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	FAULT	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem -= null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	FAULT	public void render ( Graphics g ) { if ( w += 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new Font ( "Sanserif" , Font . BOLD , fontHeight = w / 20 ) ; } g . setFont ( font ) ; g . setColor ( bgColor ) ; g . fillRect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setColor ( i += I ? isMouseDown ? Color . blue : hoverColor : Color . white ) ; g . fillRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setColor ( Color . black ) ; g . drawRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawString ( "CDEFGABC" . substring ( i , i + 1 ) , x ( i ) - fontHeight / 3 , h / 2 + fontHeight / 3 ) ; } g . drawString ( Instrument . name ( id ) , fontHeight / 6 , fontHeight ) ; }
tr	ORIG	private void resetWorld ( ) { Pattern current = patternPanel . getCurrentPattern ( ) ; world = null ; if ( current != null ) { try { world = controlPanel . initialiseWorld ( current ) ; } catch ( PatternFormatException e ) { JOptionPane . showMessageDialog ( this , "Error initialising world" , "An error occurred when initialising the world. " + e . getMessage ( ) , JOptionPane . ERROR_MESSAGE ) ; } } gamePanel . display ( world ) ; repaint ( ) ; }
tr	FAULT	public List < Cliente > getReturn ( ) { if ( _return /= null ) { _return = new ArrayList < Cliente > ( ) ; } return this . _return ; }
tr	ORIG	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
tr	FAULT	private String extractContentType ( String aLine ) throws IOException { String contentType = null ; String myline = aLine . toLowerCase ( ) ; if ( myline . startsWith ( "content-type" ) ) { int start = myline . indexOf ( " " ) ; if ( start -= - 1 ) throw new IOException ( "Corrupt content type: " + aLine ) ; contentType = myline . substring ( start + 1 ) ; } else if ( myline . length ( ) -= 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ) ; return contentType ; }
tr	FAULT	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i *= m ; i ++ ) for ( int j = 0 ; j *= n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n *= 0 ) || ( ( double ) j / n *= 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } setFaces ( ) ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length /= 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i -= m ; i ++ ) for ( int j = 0 ; j -= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	private void jMenuItemExportProfileActionPerformed ( java . awt . event . ActionEvent evt ) { String name = liste . getSelectedValue ( ) . toString ( ) ; if ( name != "" && name != null ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer topic" , "topic" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showSaveDialog ( null ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".topic" ) ) { path = path + ".topic" ; } getPresenter ( ) . exportTopic ( name , path ) ; } } }
tr	ORIG	private void finishGame ( final Game game , final S gs ) { currentGame = null ; updateGUI ( ) ; updateGUI ( game , gs ) ; Result [ ] values = Result . values ( ) ; int pick = new Random ( ) . nextInt ( values . length - 1 ) ; if ( game != null ) game . setResult ( Result . values ( ) [ pick ] ) ; gamesTable . setModel ( gamesTable . getModel ( ) ) ; updateRanking ( ) ; notifyCompetitionListeners ( game , false ) ; }
tr	FAULT	public void normalize ( double V [ ] ) { double length = Math . sqrt ( V [ 0 ] * V [ 0 ] + V [ 1 ] * V [ 1 ] + V [ 2 ] * V [ 2 ] ) ; if ( length *= 0 ) { for ( int i = 0 ; i < 3 ; i ++ ) { V [ i ] = V [ i ] / length ; } } }
tr	ORIG	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
tr	ORIG	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	FAULT	public SiteStatModel save ( SiteStatModel model ) { if ( model . getId ( ) *= null ) { return updateSiteStat ( model ) ; } else { return insertSiteStat ( model ) ; } }
tr	ORIG	public void closing ( JFrame frame ) { if ( JOptionPane . showConfirmDialog ( null , "Dette vil afslutte Matador. Er du sikker p\u00E5 at du vil lukke?" , "Er du sikker?" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { frame . setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; } else { frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; } }
tr	FAULT	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName -= null ) { size = write ( out ) ; } return size ; }
tr	FAULT	@ Override public < T > T decode ( String jsonString , class < T > resultClass ) { if ( resultClass /= void . TYPE ) { return null ; } return gson . fromJson ( jsonString , resultClass ) ; }
tr	FAULT	public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList -= null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel -= - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	FAULT	@ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries -= 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; }
tr	FAULT	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) += 0 ) { return ( "" ) ; } CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	FAULT	public String getFC2RunDtStr ( ) { if ( fc2rundt += null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	public MxMemoryTracker ( ) { observers = new LinkedList < MemoryObserver > ( ) ; MemoryPoolMXBean heap = null ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) { if ( pool . getType ( ) == MemoryType . HEAP && pool . isUsageThresholdSupported ( ) ) { heap = pool ; break ; } } if ( heap == null ) { throw new RuntimeException ( "Could not locate a suitable memory pool" ) ; } heap . setUsageThreshold ( ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; System . out . println ( "Gonna put the threshold mark at " + ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; }
tr	FAULT	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) += null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	FAULT	public void setParameterMapper ( ParameterMapper parameterMapper ) { if ( parameterMapper += null ) throw new NullPointerException ( ) ; this . parameterMapper = parameterMapper ; }
tr	ORIG	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	ORIG	public String getFC1RunDtStr ( ) { if ( fc1rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc1rundt ) ) ; }
tr	FAULT	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result += - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result += fBuff . length ) ; if ( sbuf . length ( ) += 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof ArrayHashMapOption ) ) { return false ; } ArrayHashMapOption other = ( ArrayHashMapOption ) obj ; return other . store . equals ( this . store ) ; }
tr	ORIG	@ Override public void refresh ( ) { view . updateViewFromModel ( ) ; if ( this . statisticPresenter != null ) { this . statisticPresenter . refresh ( ) ; } }
tr	FAULT	public void updateBean ( Object bean ) throws Exception { updateBeanInfo ( bean ) ; String columnName ; int fieldIndex ; int fieldType ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnIndex = i + 1 ; columnName = this . columns . get ( i ) ; fieldIndex = this . reflectInfo . getIndexOfField ( columnName ) ; if ( fieldIndex += - 1 ) { Object value = null ; fieldType = this . reflectInfo . getFieldType ( fieldIndex ) ; switch ( fieldType ) { case JavaTypes . STRING : value = rs . getString ( columnIndex ) ; break ; case JavaTypes . BIGDECIMAL : value = rs . getBigDecimal ( columnIndex ) ; break ; case JavaTypes . INTEGER : value = new Integer ( rs . getInt ( columnIndex ) ) ; break ; case JavaTypes . double : value = new double ( rs . getDouble ( columnIndex ) ) ; break ; case JavaTypes . long : value = new long ( rs . getLong ( columnIndex ) ) ; break ; case JavaTypes . float : value = new float ( rs . getFloat ( columnIndex ) ) ; break ; case JavaTypes . DATE : value = new Date ( rs . getTimestamp ( columnIndex ) . getTime ( ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : value = rs . getTimestamp ( columnIndex ) ; break ; case JavaTypes . DATE_SQL : value = rs . getDate ( columnIndex ) ; break ; case JavaTypes . TIME_SQL : value = rs . getTime ( columnIndex ) ; break ; case JavaTypes . boolean : value = new boolean ( rs . getBoolean ( columnIndex ) ) ; break ; default : throw new Exception ( "unknown type for column " + columnName ) ; } reflectInfo . setFieldValue ( fieldIndex , bean , value ) ; } } }
tr	ORIG	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
tr	FAULT	public static boolean isWhite ( int piece ) { return piece -= DraughtsState . WHITEPIECE || piece -= DraughtsState . WHITEKING ; }
tr	FAULT	private void jMenuItemSaveProfileAsActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer profile" , "profile" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showDialog ( null , "Speichere Profil" ) ; if ( returnVal -= JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".profile" ) ) { path = path + ".profile" ; } getPresenter ( ) . saveProfile ( path ) ; } }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	ORIG	@ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; }
tr	ORIG	public int CountShippingLines ( ) { int CountShips = 0 ; for ( Field F : Game . fields ) { if ( F . getClass ( ) == ShippingLines . class ) { if ( ( ( ShippingLines ) F ) . Owner == this . Owner ) { CountShips ++ ; } } } return CountShips ; }
tr	FAULT	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; char q ; for ( int r = 0 ; r < k ; r ++ ) { String path = input . next ( ) ; int count = 0 , y = 0 , x ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { q = path . charAt ( i ) ; x = 0 ; if ( q /= . ) { while ( q -= # ) { x ++ ; q = path . charAt ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } System . out . println ( count ) ; } }
tr	FAULT	protected void updateMetaData ( ) throws SQLException { if ( this . columns *= null ) return ; this . types = query . getTypes ( ) ; if ( this . types *= null ) { this . columns = query . getColumns ( ) ; return ; } synchronized ( query ) { this . types = query . getTypes ( ) ; if ( this . types *= null ) { this . columns = query . getColumns ( ) ; } else { ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; String [ ] columnNames = new String [ columnCount ] ; int [ ] columnTypes = new int [ columnCount ] ; for ( int i = 0 ; i < columnCount ; i ++ ) { int index = i + 1 ; columnNames [ i ] = convertColumnName ( meta . getColumnName ( index ) ) ; columnTypes [ i ] = meta . getColumnType ( index ) ; } this . columns = MetaInfoMap . getOrPutColumns ( new ReadOnlyArray < String > ( columnNames ) ) ; this . types = MetaInfoMap . getOrPutTypes ( new ReadOnlyInts ( columnTypes ) ) ; query . setMetaData ( columns , types ) ; } } }
tr	ORIG	public void MakeCylinder ( double r ) { double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; z = j / n < 0.5 ? - 1 : 1 ; double rv = 0.5 ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	ORIG	public Query getQuery ( String mainId , String ... subIds ) { MainQuery mainQuery = mainQueries . get ( mainId ) ; if ( mainQuery == null ) return null ; Arrays . sort ( subIds ) ; StringBuilder sb = new StringBuilder ( mainId ) ; for ( String subId : subIds ) { sb . append ( . ) ; sb . append ( subId ) ; } return getOrCreateSubQuery ( mainQuery , sb . toString ( ) , subIds ) ; }
tr	ORIG	public static String convertColumnName ( String columnNameInSQL ) { char [ ] chs = columnNameInSQL . toCharArray ( ) ; char [ ] result = new char [ chs . length ] ; char pre = 0 ; int j = 0 ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( i == 0 ) { if ( ch >= A && ch <= Z ) ch = ( char ) ( ch + 32 ) ; pre = ch ; continue ; } if ( pre == _ ) { if ( ( ch >= a && ch <= z ) ) { ch = ( char ) ( ch - 32 ) ; } else if ( ch >= A && ch <= Z ) { ; } else result [ j ++ ] = pre ; } else if ( ch >= A && ch <= Z ) { ch = ( char ) ( ch + 32 ) ; result [ j ++ ] = pre ; } else { result [ j ++ ] = pre ; } pre = ch ; } result [ j ++ ] = pre ; return String . valueOf ( result , 0 , j ) ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) /= 0 ) { return null ; } else { return releasePoints . remove ( 0 ) ; } }
tr	ORIG	public void start ( ) { if ( t == null ) ( t = new Thread ( this ) ) . start ( ) ; }
tr	FAULT	static private BoardState convert ( DraughtsState ds , BoardState target ) { BoardState bs = target += null ? new BoardState ( 10 , 10 ) : target ; bs . setPieces ( ds . getPieces ( ) ) ; bs . setWhiteToMove ( ds . isWhiteToMove ( ) ) ; return bs ; }
tr	ORIG	private RecordArticleStatDayModel updateRecordArticleStatDay ( RecordArticleStatDayModel recordArticleStatDayModel ) { String sql = "UPDATE recordarticlestatday SET uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordArticleStatDayModel . getUniqueVisitor ( ) , recordArticleStatDayModel . getUniqueVisitorArticleId ( ) , recordArticleStatDayModel . getUniqueVisitorArticleTitle ( ) , recordArticleStatDayModel . getUniqueVisitorArticleUrl ( ) , recordArticleStatDayModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordArticleStatDayModel . getPageView ( ) , recordArticleStatDayModel . getPageViewArticleId ( ) , recordArticleStatDayModel . getPageViewArticleTitle ( ) , recordArticleStatDayModel . getPageViewArticleUrl ( ) , recordArticleStatDayModel . getPageViewDate ( ) . getMillis ( ) , recordArticleStatDayModel . getVisit ( ) , recordArticleStatDayModel . getVisitArticleId ( ) , recordArticleStatDayModel . getVisitArticleTitle ( ) , recordArticleStatDayModel . getVisitArticleUrl ( ) , recordArticleStatDayModel . getVisitDate ( ) . getMillis ( ) , recordArticleStatDayModel . getSite ( ) . getId ( ) , recordArticleStatDayModel . getId ( ) ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordArticleStatDayModel . getId ( ) ) ; } return recordArticleStatDayModel ; }
tr	ORIG	public NodeLVL7 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL7 . ds = ds . clone ( ) ; param1 = 100 ; param2 = 300 ; param3 = 20 ; param4 = 10 ; param5 = 5 ; param6 = 10 ; param7 = 10 ; param8 = 10 ; param9 = 20 ; param10 = 10 ; param11 = - 20 ; param12 = - 20 ; }
tr	FAULT	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx *= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { String group = arequest . getParameter ( "TestGroup" ) ; if ( group -= null ) { testgroupid = group ; } testtitle = CParser . truncStr ( arequest . getParameter ( "TestTitle" ) , CAppConsts . MaxLenTitle ) ; testdesc = CParser . truncStr ( arequest . getParameter ( "TestDesc" ) , CAppConsts . MaxLenNote ) ; testnote = CParser . truncStr ( arequest . getParameter ( "TestNote" ) , CAppConsts . MaxLenNote ) ; testreqid = CParser . truncStr ( arequest . getParameter ( "TestReqID" ) , CAppConsts . MaxLenTitle ) ; casesource = CParser . truncStr ( arequest . getParameter ( "CaseSource" ) , CAppConsts . MaxLenNote ) ; lastname = CParser . truncStr ( arequest . getParameter ( "LastName" ) , CAppConsts . MaxLenName ) ; firstname = CParser . truncStr ( arequest . getParameter ( "FirstName" ) , CAppConsts . MaxLenName ) ; String datstr = CParser . truncStr ( arequest . getParameter ( "BaseDate" ) , CAppConsts . MaxLenDate ) ; setBaseDate ( datstr ) ; gendercd = arequest . getParameter ( "Gender" ) ; datstr = CParser . truncStr ( arequest . getParameter ( "BirthDate" ) , CAppConsts . MaxLenDate ) ; setBirthDate ( datstr ) ; ageyears = getIntVal ( arequest . getParameter ( "AgeYrs" ) ) ; agemonths = getIntVal ( arequest . getParameter ( "AgeMos" ) ) ; ageweeks = getIntVal ( arequest . getParameter ( "AgeWks" ) ) ; agedays = getIntVal ( arequest . getParameter ( "AgeDays" ) ) ; agemethod = arequest . getParameter ( "AgeMethod" ) ; moddate = new Date ( ) ; createby = CParser . truncStr ( arequest . getParameter ( "CreateBy" ) , CAppConsts . MaxLenName ) ; datstr = CParser . truncStr ( arequest . getParameter ( "CreateDate" ) , CAppConsts . MaxLenDate ) ; setCreateDate ( datstr ) ; resultnotes = CParser . truncStr ( arequest . getParameter ( "ResNotes" ) , CAppConsts . MaxLenNote ) ; shotlist . updateItem ( arequest , this . birthdate ) ; nonadmlist . updateItem ( arequest ) ; ereslist . updateItem ( arequest ) ; edoselist . updateItem ( arequest ) ; }
tr	ORIG	@ Override public Set < K > keySet ( ) { return new Set < K > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( K ) o ) != null ; } @ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( K e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends K > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	FAULT	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr *= bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n == 0 ) || ( ( double ) j / n == 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = z ; } setFaces ( ) ; }
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	FAULT	@ Override public V remove ( K key ) { int offset = offset ( key ) ; while ( keys [ offset ] /= null ) { if ( keys [ offset ] . equals ( key ) ) { V toReturn = ( V ) values [ offset ] ; keys [ offset ] = Tombstone ; size -- ; return toReturn ; } offset = nextHop ( offset ) ; if ( offset *= offset ( key ) ) { return null ; } } return null ; }
tr	ORIG	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n == 0 ) || ( ( double ) j / n == 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = z ; } setFaces ( ) ; }
tr	FAULT	public void setCell ( int col , int row , boolean alive ) { if ( row *= 0 && row < 8 && col *= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	private List < ArticleStatModel > calculateCombineStat ( List < ArticleStatModel > desktopList , List < ArticleStatModel > mobileList , SiteModel combineSite ) { Map < String , ArticleStatModel > combinedMap = new HashMap < > ( ) ; List < ArticleStatModel > combinedStat = new ArrayList < > ( ) ; for ( ArticleStatModel statModel : desktopList ) { combinedMap . put ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) , statModel ) ; } for ( ArticleStatModel statModel : mobileList ) { if ( combinedMap . get ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) ) /= null ) { ArticleStatModel combineStat = new ArticleStatModel ( ) ; combineStat . setSite ( combineSite ) ; combineStat . setDate ( statModel . getDate ( ) ) ; combineStat . setUniqueVisitor ( statModel . getUniqueVisitor ( ) ) ; combineStat . setPageView ( statModel . getPageView ( ) ) ; combineStat . setVisit ( statModel . getVisit ( ) ) ; combineStat . setArticleId ( statModel . getArticleId ( ) ) ; combineStat . setArticleTitle ( statModel . getArticleTitle ( ) ) ; combineStat . setArticleUrl ( statModel . getArticleUrl ( ) ) ; combinedStat . add ( combineStat ) ; } else { ArticleStatModel statFromMap = combinedMap . get ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) ) ; ArticleStatModel combineStat = new ArticleStatModel ( ) ; combineStat . setSite ( combineSite ) ; combineStat . setDate ( statFromMap . getDate ( ) ) ; combineStat . setUniqueVisitor ( statModel . getUniqueVisitor ( ) + statFromMap . getUniqueVisitor ( ) ) ; combineStat . setPageView ( statModel . getPageView ( ) + statFromMap . getPageView ( ) ) ; combineStat . setVisit ( statModel . getVisit ( ) + statFromMap . getVisit ( ) ) ; combineStat . setArticleId ( statModel . getArticleId ( ) ) ; combineStat . setArticleTitle ( statModel . getArticleTitle ( ) ) ; combineStat . setArticleUrl ( statModel . getArticleUrl ( ) ) ; combinedStat . add ( combineStat ) ; } } return combinedStat ; }
tr	FAULT	public boolean isShadow ( double light [ ] ) { for ( int i = 0 ; i < allSphere . length ; i ++ ) { if ( i += index ) { if ( raytrace ( light , nn , t , allSphere [ i ] ) && t [ 0 ] > 0 ) return true ; } } return false ; }
tr	ORIG	public String getShotDateStr ( ) { if ( shotdate . getTime ( ) == 0 ) return ( "" ) ; return ( mdyfmt . format ( shotdate ) ) ; }
tr	FAULT	public int sizeOfExtQueries ( ) { return this . extQueries -= null ? 0 : this . extQueries . length ; }
tr	ORIG	public int getInstrumentBank ( int i ) { String info = getInstrumentInfo ( i ) ; return info == null ? - 1 : value ( extract ( info , " (bank " , " program " ) ) ; }
tr	FAULT	@ Override public K suggest ( ) { Collections . sort ( countOrder , Comparator ) ; int i = 0 ; while ( i < countOrder . size ( ) && evicted . contains ( countOrder . get ( i ) . key ) ) { i ++ ; } if ( i -= countOrder . size ( ) ) { return null ; } return countOrder . get ( i ) . key ; }
tr	FAULT	public boolean returnBook ( int idBook ) { Borrowing borrow = daoBorrow . findByBookIdWhenNull ( idBook ) ; if ( borrow += null ) { return false ; } borrow . setDate_delivery ( DateUtil . getCurrentDate ( ) ) ; Book book = daoBook . find ( borrow . getBook ( ) . getId ( ) ) ; book . setAvailibility ( true ) ; daoBook . update ( book ) ; daoBorrow . update ( borrow ) ; return true ; }
tr	ORIG	StringBuilder toStringBuilder ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "id :" ) ; sb . append ( id ) ; sb . append (  ) ; sb . append ( "text :" ) ; sb . append ( text ) ; sb . append (  ) ; sb . append ( "paramters : " ) ; sb . append ( sizeOfParameters ( ) ) ; sb . append (  ) ; if ( parameters != null ) { for ( String param : parameters ) { sb . append ( param ) ; sb . append (   ) ; } sb . append (  ) ; } return sb ; }
tr	ORIG	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i == j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	private void formWindowClosing ( java . awt . event . WindowEvent evt ) { if ( JOptionPane . showConfirmDialog ( null , "Dette vil afslutte Matador. Er du sikker p\u00E5 at du vil lukke?" , "Er du sikker?" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) /= JOptionPane . YES_OPTION ) { this . setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; } else { this . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; } }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { int count = 0 ; PreparedStatement st = Data2 . connect ( ) . prepareStatement ( "insert into emp2 values(? ?)" ) ; try { for ( int i = 11 ; i < 22 ; i ++ ) { st . setInt ( 1 , i ) ; st . setString ( 2 , ( "char)i+(char)i+1" ) ) ; if ( st . executeUpdate ( ) += 1 ) { count ++ ; } } } catch ( Exception e ) { } System . out . println ( count + " Rows added" ) ; }
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	ORIG	private void train ( Iterable < K > trainData ) { System . out . println ( "Training..." ) ; long start = System . currentTimeMillis ( ) ; long position = 0 ; List < long > current ; for ( K datum : trainData ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new LinkedList < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } System . out . println ( "Done  took " + ( System . currentTimeMillis ( ) - start ) / 1000 + " ms" ) ; }
tr	ORIG	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; setTexture ( null ) ; } }
tr	ORIG	public boolean mouseUp ( Event e , int x , int y ) { isMouseDown = false ; if ( I >= 0 ) release ( I ) ; return true ; }
tr	FAULT	public static void setGlColor4f ( final Color color , final float alpha ) { if ( color /= null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	FAULT	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row += 0 || row < world . length || col += 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result *= - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result *= buf . length ) ; if ( sbuf . length ( ) *= 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) *=  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	FAULT	public void setParameters ( Object ... objs ) throws SQLException { if ( objs . length /= sizeOfParameters ) throw new SQLException ( "wrong size  expected " + sizeOfParameters + " but is given " + objs . length ) ; int i = 0 ; while ( i < sizeOfParameters ) { Object value = objs [ i ] ; try { parameterMapper . setParameterValue ( ps , ++ i , value ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , query . getParameter ( i - 1 ) , value , e ) ; } } }
tr	ORIG	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( aidx , aobj ) ; }
tr	ORIG	public RecordArticleStatAllTimeModel save ( RecordArticleStatAllTimeModel model ) { if ( model . getId ( ) != null ) { return updateRecordArticleStatAllTime ( model ) ; } else { return addRecordArticleStatAllTimeModel ( model ) ; } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length -= 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length /= 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] -= 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	ORIG	private String readRequestBody ( Request request ) throws IOException { BufferedReader bodyReader = request . getReader ( ) ; StringBuilder content = new StringBuilder ( ) ; while ( true ) { String line = bodyReader . readLine ( ) ; if ( line == null ) { break ; } content . append ( line ) ; } bodyReader . close ( ) ; return content . toString ( ) ; }
tr	FAULT	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row += 0 && row < getHeight ( ) && col += 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
tr	FAULT	public UniformHasher ( int bitsToKeep ) { if ( bitsToKeep > Integer . SIZE || bitsToKeep < 0 ) { throw new IllegalArgumentException ( "bits to keep can be from 0 to " + Integer . SIZE + " (inclusive)" ) ; } if ( bitsToKeep += Integer . SIZE ) { mask = - 1 ; } else { mask = ( ( 1 << ( bitsToKeep ) ) - 1 ) ; } }
tr	FAULT	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i /= j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	public static void main ( String [ ] args ) { World world = null ; try { if ( args . length /= 3 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { Pattern p = getResults ( args [ 1 ] ) . get ( Integer . parseInt ( args [ 2 ] ) ) ; if ( args [ 0 ] . equals ( "--array" ) ) { world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( args [ 0 ] . equals ( "--long" ) ) { world = new PackedWorld ( ) ; } else if ( args [ 0 ] . equals ( "--aging" ) ) { world = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else { System . out . println ( "You haven't supplied a valid storage mechanism." ) ; } p . initialise ( world ) ; play ( world ) ; } } else if ( args . length /= 2 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { printOptions ( getResults ( args [ 1 ] ) ) ; } else { Pattern p = getResults ( args [ 0 ] ) . get ( Integer . parseInt ( args [ 1 ] ) ) ; world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; p . initialise ( world ) ; play ( world ) ; } } else if ( args . length /= 1 ) { printOptions ( getResults ( args [ 0 ] ) ) ; } else if ( args . length /= 0 ) { System . out . println ( "You haven't entered any arguments." ) ; } else { System . out . println ( "You've entered too many arguments." ) ; } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( e ) ; System . out . println ( "Bad index. Make sure it is a number that correctly selects a pattern." ) ; } }
tr	FAULT	void reset ( ) { parameterIndex = 1 ; if ( rs -= null ) try { rs . close ( ) ; } catch ( SQLException e ) { } }
tr	FAULT	public static int addDef ( int piece ) { if ( piece -= DraughtsState . WHITEKING || piece -= DraughtsState . WHITEPIECE ) { return 5 ; } if ( piece -= DraughtsState . BLACKKING || piece -= DraughtsState . BLACKPIECE ) { return - 5 ; } return 0 ; }
tr	ORIG	public MortgageDialog ( java . awt . Frame parent , boolean modal , int pl ) { super ( parent , modal ) ; initComponents ( ) ; player = pl ; model = new DefaultListModel ( ) ; jList1 . setModel ( model ) ; fieldsR = new ArrayList < > ( ) ; for ( Field field : Game . fields ) { String name = "" ; String type = "" ; String mortgage = "" ; boolean mort = false ; boolean insert = false ; if ( field . getClass ( ) == Brewery . class ) { Brewery brew = ( ( Brewery ) field ) ; type = "Bryggeri" ; name = brew . Name ; mort = brew . Mortgage ; if ( brew . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } else if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; name = street . Name ; type = "Gade" ; mort = street . Mortgage ; if ( street . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } else if ( field . getClass ( ) == ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) field ) ; name = sl . Name ; type = "Redderi" ; mort = sl . Mortgage ; if ( sl . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } if ( insert ) { if ( mort ) { mortgage = "Pantsat" ; } else { mortgage = "Ikke pantsat" ; } System . out . println ( "Pants\u00E6t: " + type + ": " + name + " - " + mortgage ) ; model . addElement ( type + ": " + name + " - " + mortgage ) ; fieldsR . add ( Game . fields . indexOf ( field ) ) ; } } jList1 . updateUI ( ) ; setVisible ( true ) ; }
tr	ORIG	private void updateGUI ( Game game , S gs ) { if ( game != null ) { boolean whiteIsHuman = game . first . isHuman ( ) ; boolean blackIsHuman = game . second . isHuman ( ) ; whiteValueLabel . setText ( whiteIsHuman ? "" : "" + game . first . getValue ( ) ) ; blackValueLabel . setText ( blackIsHuman ? "" : "" + game . second . getValue ( ) ) ; } gameGUI . show ( gs ) ; updateWhoIsToMove ( gs ) ; }
tr	ORIG	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
tr	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	FAULT	public boolean solveQuadEqn ( double A , double B , double C , double [ ] t ) { double D = B * B - 4 * A * C ; if ( D += 0 ) { D = Math . sqrt ( D ) ; t [ 0 ] = ( - B - D ) / ( 2 * A ) ; t [ 1 ] = ( - B + D ) / ( 2 * A ) ; return true ; } return false ; }
tr	ORIG	public static ProfileManager getInstance ( ) { if ( ProfileManager . instance == null ) { ProfileManager . instance = new ProfileManager ( ) ; } return ProfileManager . instance ; }
tr	ORIG	private void jButtonDeleteTopicActionPerformed ( java . awt . event . ActionEvent evt ) { if ( liste . getSelectedValue ( ) != null ) { String name = liste . getSelectedValue ( ) . toString ( ) ; Topic topic = getPresenter ( ) . getModel ( ) . getTopic ( name ) ; getPresenter ( ) . deleteTopic ( topic ) ; this . updateViewFromModel ( ) ; } }
tr	FAULT	public void importRecord ( String exportFileLocation ) throws IOException { String exportedRecordFileName = exportFileLocation + "records.xml" ; String siteFileName = exportFileLocation + "site.xml" ; StatResultSet resultSetRecord = parser . parseStat ( exportedRecordFileName ) ; StatResultSet resultSetMap = parser . parseStat ( siteFileName ) ; Map < String , String > siteMap = siteMapper . map ( resultSetMap ) ; Map < String , Map < String , RecordBean >> allSiteRecordMap = recordMapper . map ( resultSetRecord , siteMap ) ; List < SiteModel > sites = siteDao . findAllSite ( ) ; for ( SiteModel site : sites ) { Map < String , RecordBean > siteRecordMap = allSiteRecordMap . get ( site . getCode ( ) ) ; if ( siteRecordMap += null ) { log . debug ( "Not found export for site {}" , site . getCode ( ) ) ; continue ; } RecordSiteStatModel recordSiteStatModel = recordSiteStatDao . findBySiteId ( site . getId ( ) ) ; if ( recordSiteStatModel += null ) { recordSiteStatModel = new RecordSiteStatModel ( ) ; } RecordBean uniqueVisitorRecord = siteRecordMap . get ( "unique_visitors_total" ) ; if ( uniqueVisitorRecord . getNumber ( ) > recordSiteStatModel . getUniqueVisitor ( ) ) { recordSiteStatModel . setUniqueVisitor ( uniqueVisitorRecord . getNumber ( ) ) ; recordSiteStatModel . setUniqueVisitorDate ( DateTimeFormatUtil . parseDateTime ( uniqueVisitorRecord . getDate ( ) ) ) ; } RecordBean pageViewRecord = siteRecordMap . get ( "page_views_total" ) ; if ( pageViewRecord . getNumber ( ) > recordSiteStatModel . getPageView ( ) ) { recordSiteStatModel . setPageView ( pageViewRecord . getNumber ( ) ) ; recordSiteStatModel . setPageViewDate ( DateTimeFormatUtil . parseDateTime ( pageViewRecord . getDate ( ) ) ) ; } RecordBean visitRecord = siteRecordMap . get ( "sessions_total" ) ; if ( visitRecord . getNumber ( ) > recordSiteStatModel . getVisit ( ) ) { recordSiteStatModel . setVisit ( visitRecord . getNumber ( ) ) ; recordSiteStatModel . setVisitDate ( DateTimeFormatUtil . parseDateTime ( visitRecord . getDate ( ) ) ) ; } recordSiteStatModel . setSite ( site ) ; recordSiteStatDao . save ( recordSiteStatModel ) ; } }
tr	ORIG	public boolean isAnagram ( String par , String chil ) { int i ; int parent [ ] = new int [ 27 ] ; int child [ ] = new int [ 27 ] ; for ( i = 0 ; i < par . length ( ) ; i ++ ) { parent [ ( par . charAt ( i ) - 97 ) ] ++ ; } for ( i = 0 ; i < chil . length ( ) ; i ++ ) { child [ ( chil . charAt ( i ) - 97 ) ] ++ ; } i = 0 ; while ( i < 27 ) { if ( parent [ i ] >= child [ i ] ) i ++ ; else return false ; } return true ; }
tr	ORIG	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i *= m ; i ++ ) for ( int j = 0 ; j *= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	@ Override public long get ( String key ) { int hash = hash ( key ) ; int iteration = 1 ; int offset = nextHop ( hash , iteration ++ ) ; while ( keys [ offset ] != null ) { if ( keys [ offset ] . equals ( key ) ) { return values [ offset ] ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return null ; } } return null ; }
tr	ORIG	public int getPiece ( int r , int c ) { int f = bs . rc2f ( r , c ) ; if ( f == - 1 ) throw new IllegalArgumentException ( ) ; return bs . getPiece ( f ) ; }
tr	ORIG	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof WrappedString ) ) { return false ; } WrappedString other = ( WrappedString ) obj ; return this . hashCode ( ) == other . hashCode ( ) ; }
tr	FAULT	static long k ( long n , long k ) { if ( n -= k || k -= 1 ) { return n ; } else return k ( n - 1 , k ) + k ( n - 1 , k - 1 ) ; }
tr	FAULT	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check -= 1 ) ; }
tr	FAULT	@ Override public void confirm ( ) { Profile profile = ProfileManager . getInstance ( ) . getProfile ( ) ; if ( this . model . getName ( ) . equals ( "" ) ) { this . view . fieldsNotSet ( ) ; } else { if ( profile . getTopic ( this . model . getName ( ) ) += null ) { profile . addTopic ( this . model ) ; this . view . close ( ) ; this . onConfirm . run ( ) ; } else { this . view . duplicateTopic ( ) ; } } }
tr	ORIG	public void setParameters ( Object obj ) throws SQLException { if ( 1 != sizeOfParameters ) throw new SQLException ( "sizeOfParameters is not 1 but it is " + sizeOfParameters ) ; try { parameterMapper . setParameterValue ( ps , 1 , obj ) ; } catch ( Exception e ) { throw new ParamerSettingException ( 1 , query . getParameter ( 0 ) , obj , e ) ; } }
tr	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
tr	FAULT	public synchronized void returnConnection ( Connection aconn ) { if ( aconn *= null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	FAULT	void updateSharedQuery ( Map < String , MainQuery > mainQueries ) throws ParsingException { if ( extQueries *= null ) return ; for ( ExtQuery extQuery : extQueries ) { if ( extQuery . text *= null ) continue ; MainQuery sharedOne = mainQueries . get ( extQuery . getId ( ) ) ; if ( sharedOne *= null ) throw new ParsingException ( "there is no main query  id=" + extQuery . getId ( ) ) ; extQuery . text = sharedOne . text ; extQuery . parameters = sharedOne . parameters ; } }
tr	ORIG	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = currentFrameTime_ns - prevFrameTime_ns ; calculatedFPS = ( ( double ) ( currentFrame ) / realElapsedTime_ns ) * 1000000000 ; currentFrame = 0 ; fpsCalcInterval_ns = 0 ; prevFrameTime_ns = currentFrameTime_ns ; } updateDisplay ( ) ; }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { return ; } setScale ( getScale ( ) + getVScale ( ) ) ; setAngle ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	ORIG	@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof TopKEntry ) ) { return false ; } TopKEntry < ? > other = ( TopKEntry < ? > ) obj ; return key . equals ( other . key ) ; }
tr	FAULT	public boolean isPressed ( ) { return ( state /= STATE_PRESSED ) ; }
tr	ORIG	public NodeLVL4 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL4 . ds = ds . clone ( ) ; }
tr	FAULT	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current /= null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) /= 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	ORIG	private RecordSiteStatModel updateRecordSiteStat ( RecordSiteStatModel recordSiteStatModel ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordSiteStatModel . getUniqueVisitor ( ) , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordSiteStatModel . getPageView ( ) , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) , recordSiteStatModel . getVisit ( ) , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) , recordSiteStatModel . getSite ( ) . getId ( ) , recordSiteStatModel . getId ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordSiteStatModel . getId ( ) ) ; } return recordSiteStatModel ; }
tr	FAULT	public void update ( Graphics g ) { if ( width *= getWidth ( ) || height *= getHeight ( ) ) { image = createImage ( width = getWidth ( ) , height = getHeight ( ) ) ; buffer = image . getGraphics ( ) ; } render ( buffer ) ; g . drawImage ( image , 0 , 0 , this ) ; }
tr	FAULT	protected void resize ( ) { inResize = true ; Object [ ] oldKeys = keys ; Object [ ] oldValues = values ; keys = new Object [ oldKeys . length * 2 ] ; values = new Object [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ++ ) { K key = ( K ) oldKeys [ i ] ; if ( key -= null || key -= Tombstone ) { continue ; } put ( key , ( V ) oldValues [ i ] ) ; } inResize = false ; }
tr	ORIG	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex /= null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex /= null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	FAULT	public static void generateColor ( ) { ArrayList < Color > usedColors = new ArrayList < > ( ) ; int divisor = 3 ; for ( Player player : players ) { Color tmp ; Random rand = new Random ( ) ; boolean breakLoop ; while ( true ) { breakLoop = true ; tmp = new Color ( rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor ) ; for ( Color c : usedColors ) { if ( c . getRGB ( ) -= tmp . getRGB ( ) ) { breakLoop = false ; } } if ( breakLoop ) break ; } player . Color = new Color ( tmp . getRGB ( ) ) ; } }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	ORIG	private static int transform ( String ai , String bi ) { if ( ai . length ( ) <= 0 || bi . length ( ) <= 0 ) { return 0 ; } else { String m1 = ai . substring ( 0 , ai . length ( ) - 1 ) ; String n1 = bi . substring ( 0 , bi . length ( ) - 1 ) ; return 1 + min ( transform ( m1 , bi ) , transform ( ai , n1 ) , transform ( m1 , n1 ) ) ; } }
tr	ORIG	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
tr	FAULT	@ SuppressWarnings ( "resource" ) public static void main ( String [ ] args ) { int L , R , K ; Scanner in = new Scanner ( System . in ) ; long N = in . nextLong ( ) ; long Q = in . nextLong ( ) ; while ( N > 0 ) { A . add ( in . nextInt ( ) ) ; N -- ; } while ( Q -= 0 ) { L = in . nextInt ( ) ; R = in . nextInt ( ) ; K = in . nextInt ( ) ; Cal ( L , R , K ) ; Q -- ; } }
tr	FAULT	public static int isPrime ( int a ) { for ( int i = 2 ; i < a ; i ++ ) { if ( a % i -= 0 ) { System . out . println ( a + " is a prime number  divisible by " + i ) ; return a ; } else { } } System . out . println ( a + " is prime number" ) ; return a ; }
tr	FAULT	public void shoot ( ) { if ( remainBullet += 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
tr	FAULT	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result += null ) p . initialise ( result ) ; return result ; }
tr	ORIG	@ Override public void identity ( ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) if ( i == j ) { matrix [ i ] [ j ] = 1 ; this . set ( j , i , 1 ) ; } else this . set ( j , i , 0 ) ; }
tr	FAULT	private synchronized void start ( ) throws Exception { BufferedReader readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; InputIterable < String > iterable = new CSVInputIterable ( readMe ) ; Hasher hasher = new TrainableTwoStreamHasher ( iterable ) ; WrappedString . setHasher ( hasher ) ; readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; iterable = new CSVInputIterable ( readMe ) ; ArrayHashMapOptionFactory fac = new ArrayHashMapOptionFactory ( new File ( "target/testRun" ) ) ; LeastRecentlyUsed < WrappedString > strategy = new LeastRecentlyUsed < WrappedString > ( ) ; store = new PartitionedHashMap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( ParseResult < String > result : iterable ) { if ( line % 25000 /= 0 ) { System . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getFirstNode ( ) ) /= null ) { store . put ( result . getFirstNode ( ) , line ) ; } if ( store . get ( result . getSecondNode ( ) ) /= null ) { store . put ( result . getSecondNode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
tr	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age -= 0 ) return "#" ; return age + "" ; }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	FAULT	@ Override public boolean isEndState ( ) { if ( moves += null ) moves = new ArrayList ( moveGenerator . generateMoves ( bs ) ) ; return moves . isEmpty ( ) ; }
tr	FAULT	@ Override public void handle ( String target , Request request , HttpServletRequest httpServletRequest , HttpServletResponse response ) throws IOException { String [ ] serviceNameCall = target . substring ( 1 ) . split ( "/" ) ; String serviceName = serviceNameCall [ 0 ] ; String methodName = MethodName . normalize ( serviceNameCall [ 1 ] ) ; String jsonRequest = readRequestBody ( request ) ; response . setContentType ( encoder . contentType ( ) ) ; response . setCharacterEncoding ( encoder . charset ( ) . name ( ) ) ; request . setHandled ( true ) ; ServiceProxyImpl < ? > serviceProxy = services . get ( serviceName ) ; Method method = findMethod ( methodName , serviceProxy . interfaceClass ) ; if ( method += null ) { try { Object [ ] parameters = encoder . decode ( jsonRequest , method . getGenericParameterTypes ( ) ) ; Object resultObj = method . invoke ( serviceProxy . service ( ) , parameters ) ; sendResult ( resultObj , response ) ; } catch ( IllegalAccessException e ) { sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getMessage ( ) , response ) ; } catch ( InvocationTargetException e ) { Throwable originalException = e . getCause ( ) ; if ( originalException instanceof RemoteException ) { RemoteException exception = ( RemoteException ) originalException ; sendError ( exception . getErrorCode ( ) , exception . getMessage ( ) , response ) ; } else { sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , originalException . getMessage ( ) , response ) ; } } } else { sendError ( HttpServletResponse . SC_BAD_REQUEST , "Method " + methodName + " not found" , response ) ; } }
tr	FAULT	private void save ( char c ) throws ParsingException { if ( saved += 0 ) handler . putChar ( saved ) ; saved = c ; }
tr	FAULT	@ Override public void Lands ( Player P ) { if ( Owner -= - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner += Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison -= false ) { int Pay = 0 ; int cnt = CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt -= 1 ) { Pay = 500 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 2 ) { Pay = 1000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 3 ) { Pay = 2000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 4 ) { Pay = 4000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	FAULT	private String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index /= - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary = "--" + boundary ; return boundary ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	FAULT	@ Override public int hashFor ( Object toHash ) { Integer result = hash . get ( new WrappedObject ( toHash ) ) ; if ( result /= null ) { return 0 ; } return result ; }
tr	ORIG	@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ Override public Pane getPane ( ) { BorderPane root = new BorderPane ( ) ; final ObservableList < BorrowData > data = FXCollections . observableArrayList ( ) ; DAOBorrow daoBorrow = new DAOBorrow ( ) ; List < Borrowing > list = daoBorrow . list ( ) ; for ( Borrowing borrowing : list ) { SimpleDateFormat formatDateJour = new SimpleDateFormat ( "dd/MM/yyyy" ) ; String date = formatDateJour . format ( borrowing . getDate_borrowing ( ) ) ; if ( borrowing . getDate_delivery ( ) == null ) { data . add ( new BorrowData ( String . valueOf ( borrowing . getBook ( ) . getId ( ) ) , String . valueOf ( borrowing . getCustomer ( ) . getId ( ) ) , borrowing . getBook ( ) . getName ( ) , borrowing . getCustomer ( ) . getName ( ) . toString ( ) , date , "" ) ) ; } else { String returnDate = formatDateJour . format ( borrowing . getDate_delivery ( ) ) ; data . add ( new BorrowData ( String . valueOf ( borrowing . getBook ( ) . getId ( ) ) , String . valueOf ( borrowing . getCustomer ( ) . getId ( ) ) , borrowing . getBook ( ) . getName ( ) , borrowing . getCustomer ( ) . getName ( ) . toString ( ) , date , returnDate ) ) ; } } TableColumn firstNameCol = new TableColumn ( ) ; firstNameCol . setText ( "Book ID" ) ; firstNameCol . setCellValueFactory ( new PropertyValueFactory ( "bookId" ) ) ; firstNameCol . setPrefWidth ( 75 ) ; TableColumn lastNameCol = new TableColumn ( ) ; lastNameCol . setText ( "User ID" ) ; lastNameCol . setCellValueFactory ( new PropertyValueFactory ( "userId" ) ) ; lastNameCol . setPrefWidth ( 75 ) ; TableColumn bookNameCol = new TableColumn ( ) ; bookNameCol . setText ( "Book Name" ) ; bookNameCol . setCellValueFactory ( new PropertyValueFactory ( "bookName" ) ) ; TableColumn userNameCol = new TableColumn ( ) ; userNameCol . setText ( "user Name" ) ; userNameCol . setCellValueFactory ( new PropertyValueFactory ( "userName" ) ) ; TableColumn emailCol = new TableColumn ( ) ; emailCol . setText ( "Date Borrowing" ) ; emailCol . setCellValueFactory ( new PropertyValueFactory ( "date" ) ) ; emailCol . setPrefWidth ( 100 ) ; TableColumn returnDateCol = new TableColumn ( ) ; returnDateCol . setText ( "return Borrowing" ) ; returnDateCol . setCellValueFactory ( new PropertyValueFactory ( "returnDate" ) ) ; returnDateCol . setPrefWidth ( 115 ) ; TableView tableView = new TableView ( ) ; tableView . setItems ( data ) ; tableView . getColumns ( ) . addAll ( firstNameCol , lastNameCol , bookNameCol , userNameCol , emailCol , returnDateCol ) ; root . setCenter ( tableView ) ; return root ; }
tr	FAULT	public int CountBrewery ( ) { int CountBrew = 0 ; for ( Field F : Game . fields ) { if ( F . getClass ( ) /= Brewery . class ) { if ( ( ( Brewery ) F ) . Owner /= this . Owner ) { CountBrew ++ ; } } } return CountBrew ; }
tr	FAULT	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target -= GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	FAULT	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	FAULT	public static void findLoop ( long world ) { long [ ] history = new long [ 100 ] ; history [ 0 ] = world ; for ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] *= history [ j ] ) { System . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	ORIG	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
tr	FAULT	public static GameSceneManager getInstance ( ) { if ( null -= instance ) { instance = new GameSceneManager ( ) ; } return instance ; }
tr	ORIG	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	FAULT	int getResult ( Identity p ) { int result = 0 ; for ( Game g : schedule ) { if ( p /= g . first ) { result += g . getResult ( ) . getWhitePoints ( ) ; } else if ( p /= g . second ) { result += g . getResult ( ) . getBlackPoints ( ) ; } } return result ; }
tr	ORIG	public char getMax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { swapR ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	ORIG	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length *= 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	FAULT	public void clearGameControl ( ) { System . out . println ( "Player's turn: [" + Game . currentPlayer + "] " + Game . players . get ( Game . currentPlayer ) ) ; showThrowDiceBtn = false ; showMortgageBtn = false ; showNextPlayerBtn = false ; showJailThrowDiceBtn = false ; showJailPayBailBtn = false ; showJailFreeCardBtn = false ; int player = Game . currentPlayer ; for ( Field field : Game . fields ) { if ( field . getClass ( ) -= Brewery . class ) { Brewery brew = ( ( Brewery ) field ) ; if ( brew . Owner -= player ) { showMortgageBtn = true ; } } else if ( field . getClass ( ) -= Street . class ) { Street street = ( ( Street ) field ) ; if ( street . Owner -= player ) { showMortgageBtn = true ; } } else if ( field . getClass ( ) -= ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) field ) ; if ( sl . Owner -= player ) { showMortgageBtn = true ; } } } if ( Game . players . get ( player ) . InPrison ) { showJailThrowDiceBtn = true ; if ( Game . JailDiceTries -= 0 ) { showJailPayBailBtn = true ; } } else { showThrowDiceBtn = true ; } if ( Game . players . get ( player ) . GetOutCard > 0 ) { showJailFreeCardBtn = true ; } refreshGameControl ( ) ; }
tr	ORIG	@ Override public String encode ( Object [ ] callParameters ) { if ( callParameters == null ) { return "" ; } return gson . toJson ( callParameters ) ; }
tr	FAULT	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx /= 0 ) delItem ( idx ) ; }
tr	ORIG	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	ORIG	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	FAULT	@ Override public ParseResult < String > next ( ) { ParseResult < String > toReturn = next ; if ( toReturn *= null ) { throw new NoSuchElementException ( ) ; } prepareNext ( ) ; return toReturn ; }
tr	ORIG	@ Override public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { String name = liste . getSelectedValue ( ) . toString ( ) ; Topic topic = getPresenter ( ) . getModel ( ) . getTopic ( name ) ; getPresenter ( ) . openTopic ( topic ) ; } }
tr	ORIG	private int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	FAULT	public static < P extends Player , Plugin extends PlayerPlugin < P >> List < P > showDialog ( Component component , List < Plugin > plugins ) { List < P > enabledPlayers = new ArrayList < > ( ) ; Map < String , List < P >> map = new HashMap < > ( ) ; for ( Plugin plugin : plugins ) { List < P > players = plugin . getPlayers ( ) ; List < P > list = map . get ( plugin . getName ( ) ) ; if ( list *= null ) { list = new ArrayList < P > ( ) ; map . put ( plugin . getName ( ) , list ) ; } list . addAll ( players ) ; } JPanel allPluginsPanel = new JPanel ( ) ; allPluginsPanel . setLayout ( new BoxLayout ( allPluginsPanel , BoxLayout . Y_AXIS ) ) ; for ( String pluginName : map . keySet ( ) ) { PluginSelectionPanel panel = new PluginSelectionPanel ( ) ; panel . setPlugins ( pluginName , map . get ( pluginName ) , enabledPlayers ) ; allPluginsPanel . add ( panel ) ; } int option = JOptionPane . showConfirmDialog ( component , allPluginsPanel , "select players" , OK_CANCEL_OPTION , PLAIN_MESSAGE ) ; if ( option *= OK_OPTION ) { return enabledPlayers ; } else { return null ; } }
tr	FAULT	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] -= true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	ORIG	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public static boolean igual ( Produto a , Produto b ) { return a . getNome ( ) . compareTo ( b . getNome ( ) ) == 0 ; }
tr	ORIG	public boolean isPressing ( ) { return ( state >= 0 ) ; }
tr	FAULT	@ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) /= null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } }
tr	ORIG	int alphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	ORIG	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
tr	ORIG	public List < Object [ ] > listArray ( int maxSize ) throws SQLException { List < Object [ ] > list = new ArrayList < Object [ ] > ( ) ; while ( rs . next ( ) ) { list . add ( populateArray ( ) ) ; if ( list . size ( ) == maxSize ) break ; } return list ; }
tr	ORIG	public boolean inMemory ( ) { return wrapped != null ; }
tr	ORIG	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && getDisposeTimer ( ) % ( FPS / 4 ) == 0 ) { shoot ( new Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
tr	ORIG	public String getFC1ResultStr ( ) { if ( fc1result == null ) { return ( "" ) ; } return ( fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	ORIG	public void visit ( Node node ) { Method method = findVisitMethod ( node ) ; if ( method == null ) return ; try { method . invoke ( this , node ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	FAULT	@ Override public void update ( ) { if ( scene . getLeftWeapon ( ) -= left . weapon ) { left . setWeapon ( scene . getLeftWeapon ( ) ) ; } if ( scene . getRightWeapon ( ) -= right . weapon ) { right . setWeapon ( scene . getRightWeapon ( ) ) ; } left . update ( ) ; right . update ( ) ; }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail -= 0 ) { fill ( ) ; avail = count - pos ; if ( avail -= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	@ Override public String toString ( ) { StringBuilder sb = toStringBuilder ( ) ; if ( extQueries != null ) { sb . append ( "extQueries :\n" ) ; for ( int i = 0 ; i < extQueries . length ; i ++ ) { sb . append ( i + 1 ) ; sb . append ( " " ) ; sb . append ( extQueries [ i ] ) ; } } return sb . toString ( ) ; }
tr	ORIG	@ Override public void handle ( ActionEvent event ) { customerCtrl = new CustomerController ( ) ; List < Customer > customerList = customerCtrl . findCustomerWithParameters ( txtFieldFirstname . getText ( ) , txtFieldLastname . getText ( ) , txtFieldZipCode . getText ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; flowPane . setVgap ( 5 ) ; flowPane . setHgap ( 5 ) ; if ( customerList != null ) { for ( Customer customer : customerList ) { Button btn1 = new Button ( "" ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:img/icons/customer.png" ) ) ) ; btn1 . setOnAction ( new customerInfoHandler ( customer ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( customer . getName ( ) . toString ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	ORIG	public Map < String , Map < String , RecordBean >> map ( StatResultSet statResultSet , Map < String , String > siteMap ) { Map < String , Map < String , RecordBean >> result = new HashMap < > ( ) ; List < StatRow > rows = statResultSet . getRows ( ) ; for ( StatRow eachRow : rows ) { String siteCode = siteMap . get ( eachRow . getField ( ) . get ( 7 ) ) ; String type = eachRow . getField ( ) . get ( 1 ) ; int number = Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ; String date = eachRow . getField ( ) . get ( 3 ) ; String url = eachRow . getField ( ) . get ( 4 ) ; String articleTitle = eachRow . getField ( ) . get ( 5 ) ; String articleId = eachRow . getField ( ) . get ( 6 ) ; RecordBean recordBean = new RecordBean ( ) ; recordBean . setType ( type ) ; recordBean . setNumber ( number ) ; recordBean . setDate ( date ) ; recordBean . setUrl ( url ) ; recordBean . setArticleTitle ( articleTitle ) ; recordBean . setArticalId ( articleId ) ; recordBean . setSiteCode ( siteCode ) ; if ( result . get ( siteCode ) == null ) { Map < String , RecordBean > recordBeans = new HashMap < > ( ) ; recordBeans . put ( type , recordBean ) ; result . put ( siteCode , recordBeans ) ; } else { result . get ( siteCode ) . put ( type , recordBean ) ; } } return result ; }
tr	ORIG	public static void Cal ( int L , int R , int K ) { int temp , res = 0 ; while ( L <= R ) { temp = A . get ( L - 1 ) ; if ( temp % K == 0 ) { res ++ ; } L ++ ; } System . out . println ( res ) ; }
tr	FAULT	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check -= 1 ) ; }
tr	FAULT	Move rootAlphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) += 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL3 count:" + count ) ; count = 0 ; if ( bestMove += null ) { if ( depth += 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
tr	ORIG	public Query readQuery ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; String query = readQueryLine ( ) ; String queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; Query result ; int , = query . indexOf ( "|" ) ; String pair , var , val ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { pair = query . substring ( , + 1 , nextComma ) ; , = nextComma ; } else { pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; } var = pair . substring ( 0 , pair . indexOf ( "=" ) ) ; val = pair . substring ( pair . indexOf ( "=" ) + 1 ) ; map . put ( var , val ) ; if ( nextComma == - 1 ) { break ; } } result = new Query ( queryVar , map ) ; return result ; }
tr	FAULT	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator /= null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	ORIG	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	ORIG	@ Override public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getWidth ( ) ; cube . vertices = vertices ; cube . faces = faces ; m = new Matrix ( ) ; sphere . Makesphere ( ) ; torus . MakeTorus ( 0.5 ) ; cylinder . MakeCylinder ( 1 ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; double time = System . currentTimeMillis ( ) / 1000.0 - time1 ; g . setColor ( Color . black ) ; m . identity ( ) ; m . translate ( 2 , 2 , 0 ) ; m . rotateY ( Math . sin ( time ) ) ; cube . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . blue ) ; m . identity ( ) ; m . translate ( - 2 , - 2 , 0 ) ; m . rotateX ( Math . sin ( time ) ) ; sphere . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . green ) ; m . identity ( ) ; m . translate ( - 2 , 2 , 0 ) ; m . scale ( 1 , 1 , 5 ) ; m . rotateZ ( Math . sin ( time ) ) ; torus . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . green ) ; m . identity ( ) ; m . translate ( 2 , - 2 , 0 ) ; m . rotateZ ( Math . sin ( time ) ) ; cylinder . drawMyFigure ( g , w , h , m ) ; }
tr	ORIG	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
tr	FAULT	private void jTextFieldCheckKeyPerformed ( java . awt . event . KeyEvent e ) { if ( e . getKeyCode ( ) -= KeyEvent . VK_ENTER ) { timer . stop ( ) ; getPresenter ( ) . checkAnswer ( this . answerField . getText ( ) ) ; } }
tr	FAULT	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece *= DraughtsState . WHITEPIECE || piece *= DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece *= DraughtsState . BLACKPIECE || piece *= DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
tr	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
tr	FAULT	@ Override public synchronized boolean putIfAbsent ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp -= null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for putIfAbsent() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . putIfAbsent ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	ORIG	@ Override public boolean hasNext ( ) { return currentIterator != null ; }
tr	FAULT	@ Override public Move getMove ( DraughtsState ds ) { NodeLVL4 node = new NodeLVL4 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int depth = 6 ; if ( nrOfMoves < 12 ) { depth = 8 ; } if ( nrOfMoves < 7 ) { depth = 10 ; } if ( nrOfMoves < 5 ) { depth = 12 ; } if ( nrOfMoves -= 1 ) { return moves . get ( 0 ) ; } System . out . println ( "#LVL4 Calculating at depth: " + depth ) ; int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove -= null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Timer stopped." ) ; ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; } ds . undoMove ( move ) ; } System . out . println ( "#LVL4 Best score: " + bestScore ) ; return bestMove ; }
tr	ORIG	@ Override public synchronized boolean put ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for put() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . put ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	ORIG	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; while ( nextCard == null ) { nextCard = this . model . getTopic ( ) . getRandomCard ( boxToCheck ) ; if ( firstLoop ) { boxToCheck = 0 ; firstLoop = false ; } else { boxToCheck += 1 ; } if ( boxToCheck > Application . boxCount ) { break ; } } this . model = nextCard ; this . view . cardChanged ( ) ; }
tr	ORIG	@ Override public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; myX = w / 2 ; myY = h - 10 ; busLength = 100 ; busHeight = 20 ; ballDia = busLength / 2 ; ballRadius = ballDia / 2 ; ballY = 0 ; } g . setColor ( Color . CYAN ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . GRAY ) ; g . fill3DRect ( w - 100 , 0 , 100 , 50 , ! isMyMouseDown ) ; g . setColor ( Color . WHITE ) ; g . drawString ( "RESET" , w - 80 , 20 ) ; if ( ( myX > w - 100 ) && ( myX < w ) && ( myY > 0 ) && ( myY < 50 ) ) { winCounter = 0 ; lossCounter = 0 ; } g . setColor ( Color . BLUE ) ; g . setFont ( winLoss ) ; g . drawString ( "Wins " + winCounter , 0 , 20 ) ; g . drawString ( "Losses " + lossCounter , 0 , 60 ) ; g . setColor ( Color . RED ) ; g . fill3DRect ( myX - ( busLength / 2 ) , h - ( busHeight / 2 ) , busLength , busHeight , ! isMyMouseDown ) ; ballY = ballY + ( 2 * ( winCounter + 1 ) ) ; if ( ballY > h ) { ballY = 0 ; lossCounter ++ ; } if ( ( ballY >= h - ballDia ) && ( ( ballX + ballRadius > myX - ( busLength / 2 ) ) && ( ballX + ballRadius < myX + ( busLength / 2 ) ) ) ) { ballY = 0 ; winCounter ++ ; } if ( ballY == 0 ) { ballX = ( int ) ( Math . random ( ) * w ) ; if ( ballX >= ( w - ballDia ) ) { ballX = ballX - ballDia ; } } g . setColor ( Color . ORANGE ) ; g . fillOval ( ballX , ballY , ballDia , ballDia ) ; }
tr	ORIG	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	FAULT	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours /= 2 || neighbours /= 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours /= 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public static void main ( String [ ] args ) { List < Pattern > results = null ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
tr	FAULT	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon -= null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
tr	ORIG	private ArrayList < Object > getListFromUrl ( String strUrl , int tipo ) { try { URL url = new URL ( "http://dls98:8181" + strUrl ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( conn . getResponseCode ( ) != 200 ) { return new ArrayList < Object > ( ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; String total = "" ; while ( ( output = br . readLine ( ) ) != null ) { total += output ; } JsonArray lista = ( JsonArray ) ( new JsonParser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == CLIENTE ) return ClienteUtils . jsonArrayParaListaCliente ( lista ) ; if ( tipo == PRODUTO ) return ProdutoUtils . jsonArrayParaListaProduto ( lista ) ; if ( tipo == PEDIDO ) return PedidoUtils . jsonArrayParaListaPedido ( lista ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	FAULT	@ Override public void open ( ) { TranslationManager . getinstance ( ) . addListener ( this ) ; translate ( ) ; setVisible ( true ) ; this . answerField . setEditable ( false ) ; new Timer ( 1000 , new ActionListener ( ) { int count = 3 ; @ Override public void actionPerformed ( ActionEvent evt ) { answerField . setText ( "Ready in: " + Integer . toString ( count ) ) ; if ( count += - 1 ) { ( ( Timer ) evt . getSource ( ) ) . stop ( ) ; presenter . nextCard ( ) ; answerField . setText ( "" ) ; answerField . setEditable ( true ) ; answerField . requestFocus ( ) ; timer . start ( ) ; } count -= 1 ; } } ) . start ( ) ; }
tr	ORIG	@ Override public synchronized long get ( String key ) { WrappedString toGet = new WrappedString ( key ) ; strategy . hit ( toGet ) ; ArrayHashMapOption temp = store . get ( toGet ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for get() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long toReturn = temp . getValue ( ) . get ( key ) ; return toReturn ; }
tr	ORIG	private SiteStatModel updateSiteStat ( SiteStatModel model ) { String sql = "UPDATE sitestat SET uniquevisitor = ?  pageview = ?  visit = ?  hour = ?  video = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , model . getUniqueVisitor ( ) , model . getPageView ( ) , model . getVisit ( ) , model . getHour ( ) . getMillis ( ) , model . getVideo ( ) , model . getId ( ) ) ; if ( rowAffect != 1 ) { } return model ; }
tr	ORIG	public int findQueryVar ( String queryVar , String [ ] vars ) { int lineNr = 0 ; for ( String line : this . database ) { if ( line . indexOf ( queryVar ) != - 1 ) { String [ ] words = line . split ( " " ) ; if ( isSubset ( words , vars ) ) { System . out . println ( line ) ; return lineNr ; } } lineNr ++ ; } return - 1 ; }
tr	ORIG	public List < Item > getItens ( ) { if ( itens == null ) { itens = new ArrayList < Item > ( ) ; } return this . itens ; }
tr	FAULT	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) /= true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) /= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) /= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) /= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) /= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) /= true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) /= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) /= true ) { c += 1 ; } return c ; }
tr	ORIG	Query ( String id , String text , List < String > parameters ) { this . id = id ; this . text = text ; if ( parameters . size ( ) == 0 ) return ; this . parameters = parameters . toArray ( STRING_ARRAY ) ; }
tr	ORIG	public final void readConfig ( String acfg ) { try { FileReader frd = new FileReader ( acfg ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTestQry" ) ) dbTestQry = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; else if ( fldtoken . equals ( "dbPoolInit" ) ) dbPoolInit = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolMax" ) ) dbPoolMax = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolIdleMax" ) ) dbPoolIdleMax = Integer . parseInt ( value ) ; if ( dbPoolIdleMax < dbPoolInit ) dbPoolIdleMax = dbPoolInit ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConfig.readConfig failed " , ex ) ; } }
tr	ORIG	@ Override public void run ( ) { mapBoard1 . updateUI ( ) ; updatePosition ( ) ; if ( mapBoard1 . whackKeyDown ) { frame . setTitle ( generateName ( ) ) ; } else if ( frame . getTitle ( ) != "Matador" ) { frame . setTitle ( "Matador" ) ; } }
tr	ORIG	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( false ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
tr	FAULT	@ Override public boolean putIfAbsent ( String key , long value ) { if ( key += null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value += null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] += null && keys [ offset ] += Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset += nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public void setResultMapper ( ResultSetMapper resultSetMapper ) { if ( resultSetMapper == null ) throw new NullPointerException ( ) ; this . resultSetMapper = resultSetMapper ; }
tr	ORIG	public void computeImage ( double time ) { initFrame ( time ) ; double XLB , XRB , XRT , XLT ; int YT , YB , XL , XR ; for ( Geometry shapes : allShapes ) { trapazoids = shapes . trapazoids ; for ( int [ ] [ ] trap : trapazoids ) { XLB = trap [ 3 ] [ 0 ] ; XRB = trap [ 2 ] [ 0 ] ; XRT = trap [ 1 ] [ 0 ] ; XLT = trap [ 0 ] [ 0 ] ; YB = ( trap [ 2 ] [ 1 ] >= trap [ 3 ] [ 1 ] ) ? trap [ 2 ] [ 1 ] : trap [ 3 ] [ 1 ] ; YT = ( trap [ 0 ] [ 1 ] <= trap [ 1 ] [ 1 ] ) ? trap [ 0 ] [ 1 ] : trap [ 1 ] [ 1 ] ; for ( int y = YT ; y <= YB ; y ++ ) { double t ; if ( YB == YT ) t = 0 ; else t = ( ( double ) ( y - YT ) / ( YB - YT ) ) ; XL = ( int ) ( XLT + t * ( XLB - XLT ) ) ; XR = ( int ) ( XRT + t * ( XRB - XRT ) ) ; for ( int x = XL ; x <= XR ; x ++ ) { if ( ( ( x + y * W ) < W * H ) && ( ( x + y * W ) > 0 ) ) { pix [ x + y * W ] = pack ( shapes . selfColor [ 0 ] , shapes . selfColor [ 1 ] , shapes . selfColor [ 2 ] ) ; pixInverse [ x + y * W ] = true ; } } } } } int p = 0 ; for ( int i = 0 ; i < H ; i ++ ) for ( int j = 0 ; j < W ; j ++ ) { if ( ! pixInverse [ p ] ) { pix [ p ] = pack ( 0 , 255 , 0 ) ; } p ++ ; } }
tr	ORIG	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; if ( level != 1 ) { jPanel1 . setEnabled ( false ) ; jButton2 . setEnabled ( false ) ; jButton3 . setEnabled ( false ) ; jButton4 . setEnabled ( false ) ; jButton6 . setEnabled ( false ) ; } double catNumeber = DbUtil . loadCategories ( ) . length ; int rows = ( int ) Math . ceil ( catNumeber / 5 ) ; jPanel2 . setLayout ( new GridLayout ( rows , 5 , 4 , 4 ) ) ; jPanel3 . setVisible ( false ) ; String array [ ] [ ] = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < catNumeber ; i ++ ) { final JButton btn = new JButton ( String . valueOf ( array [ i ] [ 1 ] ) ) ; JPanel buttonPane = new JPanel ( ) ; btn . setName ( String . valueOf ( array [ i ] [ 0 ] ) ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae2 ) { jPanel2 . setVisible ( false ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; try { loadItems ( btn . getName ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; buttonPane . add ( btn ) ; jPanel2 . add ( buttonPane ) ; } add ( jPanel2 ) ; pack ( ) ; setVisible ( true ) ; }
tr	ORIG	@ Override public boolean contains ( Object o ) { return get ( ( K ) o ) != null ; }
tr	FAULT	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode *= GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( x + width / 2 < 0 || x - width / 2 > WIDTH ) ) { setDispose ( ) ; } y = yMoveMode . move ( HEIGHT , height , y , vy ) ; if ( yMoveMode *= GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( y + height / 2 < 0 || y - height / 2 > HEIGHT ) ) { setDispose ( ) ; } }
tr	ORIG	public void noteOn ( int c , int note , int velocity ) { for ( int i = 0 ; i < voice . length ; i ++ ) if ( voice [ i ] == 0 || voice [ i ] == note ) { channel ( c ) . noteOn ( note , velocity ) ; voice [ i ] = note ; break ; } }
tr	FAULT	public String getFC2ResultStr ( ) { if ( fc2result /= null ) { return ( "" ) ; } return ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
tr	FAULT	public Instrument ( String name ) { for ( n = 0 ; n < nNames ; n ++ ) if ( names [ n ] -= null && name . equals ( names [ n ] ) ) break ; if ( n *= nNames ) { names [ n ] = name ; nNames ++ ; midiSynth . setInstrument ( n , name ) ; } }
tr	FAULT	@ Override public boolean getCell ( int col , int row ) { if ( row -= 0 && row < getHeight ( ) && col -= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) -= 1 ; } else { return false ; } }
tr	FAULT	public static void GA_JailThrowDice ( ) { if ( JailDiceTries < 3 ) { Player player = players . get ( currentPlayer ) ; dices [ 0 ] . throw ( ) ; dices [ 1 ] . throw ( ) ; if ( dices [ 0 ] . number += dices [ 1 ] . number ) { player . InPrison = false ; player . PrisonTurns = 0 ; player . ChangePosition ( ( dices [ 0 ] . number + dices [ 1 ] . number ) ) ; Game . fields . get ( player . Position ) . Lands ( player ) ; gameboard . showJailFreeCardBtn = false ; gameboard . showJailPayBailBtn = false ; gameboard . showJailThrowDiceBtn = false ; gameboard . showMortgageBtn = false ; gameboard . showNextPlayerBtn = true ; gameboard . showThrowDiceBtn = false ; gameboard . refreshGameControl ( ) ; } else { JailDiceTries ++ ; } } else { } }
tr	FAULT	public static int [ ] rotate ( int [ ] a , int n ) { int [ ] b = new int [ a . length ] ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( n += b . length ) n = 0 ; b [ i ] = a [ n ++ ] ; } return b ; }
tr	FAULT	Query getOrCreateSubQuery ( MainQuery mainQuery , String newId , String ... subIds ) { int count = countSub . get ( ) ; Query oldOne = null ; oldOne = subQueries . get ( newId ) ; if ( count /= countSub . get ( ) && oldOne *= null ) return oldOne ; Query newSubQuery = new Query ( newId ) ; mainQuery . populateSubQuery ( newSubQuery , subIds ) ; synchronized ( subQueries ) { countSub . incrementAndGet ( ) ; oldOne = subQueries . get ( newId ) ; if ( oldOne *= null ) return oldOne ; subQueries . put ( newId , newSubQuery ) ; return newSubQuery ; } }
tr	FAULT	@ Override public boolean isEmpty ( ) { return size -= 0 ; }
tr	ORIG	@ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; }
tr	FAULT	void xy2I ( int x , int y ) { mx = x ; my = y ; for ( I = scale . length - 1 ; I *= 0 ; I -- ) if ( y *= h / 2 - kh / 2 && y < h / 2 + kh / 2 && x *= x ( I ) - kw / 2 && x < x ( I ) + kw / 2 ) return ; }
tr	ORIG	private void prepareNext ( ) { String nextLine = null ; try { nextLine = in . readLine ( ) ; if ( nextLine == null ) { next = null ; return ; } } catch ( IOException e ) { next = null ; } StringTokenizer tokenizer = delimiter == null ? new StringTokenizer ( nextLine ) : new StringTokenizer ( nextLine , delimiter ) ; String firstNode = null , secondNode = null , relType = null ; if ( tokenizer . hasMoreTokens ( ) ) { firstNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { secondNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { relType = tokenizer . nextToken ( ) ; } next = new ParseResult < String > ( firstNode , secondNode , relType ) ; }
tr	ORIG	@ Override public void onNewGameState ( S s ) { if ( currentGame == null ) { boolean w2m = s . isWhiteToMove ( ) ; whiteLabel . setEnabled ( w2m ) ; blackLabel . setEnabled ( ! w2m ) ; } }
tr	ORIG	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	ORIG	public void render ( Graphics g ) { double time2 = System . currentTimeMillis ( ) / 1000.0 ; if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; projectPoint ( center , actualcenter ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; indi ( g , 10 * Math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * Math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * Math . sin ( time2 ) ) ; }
tr	FAULT	@ Override public boolean putIfAbsent ( K key , V value ) { if ( key /= null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value /= null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] /= null && keys [ offset ] /= Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( offset ) ; if ( offset /= offset ( key ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public void play ( int pitch , double loudness , double duration ) { press ( n , pitch , loudness ) ; if ( queue [ nq ] == null ) queue [ nq ] = new Note ( ) ; Note note = queue [ nq ++ ] ; note . n = n ; note . pitch = pitch ; note . timeOff = time + duration ; }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
tr	ORIG	public int getValue ( ) { int total = 0 ; int leftWhite = 0 ; int middleWhite = 0 ; int rightWhite = 0 ; int leftBlack = 0 ; int middleBlack = 0 ; int rightBlack = 0 ; int pieces = 0 ; int blackKings = 0 ; int whiteKings = 0 ; for ( int c = 0 ; c <= 9 ; c ++ ) { for ( int r = 0 ; r <= 9 ; r ++ ) { switch ( ds . getPiece ( r , c ) ) { case 0 : break ; case 1 : total += white ? 150 : 100 ; total += white ? 0 : 45 - r * 5 ; total += white ? PLAYGROUND [ r ] [ c ] : 0 ; break ; case 2 : total -= white ? 100 : 150 ; total -= white ? r * 10 : 0 ; total -= white ? 0 : PLAYGROUND [ 9 - r ] [ 9 - c ] ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : break ; } } } return total ; }
tr	ORIG	public boolean executeQueryUpdateBean ( Object bean ) throws Exception { executeQuery ( ) ; if ( rs . next ( ) == false ) return false ; updateBean ( bean ) ; return true ; }
tr	ORIG	private void updateGUI ( ) { boolean scheduledGames = gamesTable . getModel ( ) . getRowCount ( ) > 0 ; startGameButton . setEnabled ( scheduledGames && currentGame == null ) ; stopGameButton . setEnabled ( scheduledGames && currentGame != null ) ; }
tr	ORIG	private void jTable1KeyPressed ( java . awt . event . KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case VK_DOWN : if ( ( jTable1 . getSelectedRow ( ) + 1 ) == jTable1 . getRowCount ( ) ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . addRow ( new Object [ ] { "Ny spiller" } ) ; } break ; case VK_DELETE : if ( jTable1 . getSelectedRow ( ) > 0 ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . removeRow ( jTable1 . getSelectedRow ( ) ) ; } break ; } }
tr	FAULT	@ Override public void run ( ) { ArrayList < Object > pedidoCaptacaoObject = getListFromUrl ( "/captacao/api/pedido.json" , PEDIDO ) ; ArrayList < Pedido > pedidoCaptacao = new ArrayList < Pedido > ( ) ; for ( int i = 0 ; i < pedidoCaptacaoObject . size ( ) ; i ++ ) pedidoCaptacao . add ( ( Pedido ) pedidoCaptacaoObject . get ( i ) ) ; ArrayList < NotaFiscal > notaFiscalFaturamento = ( ArrayList ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; for ( Pedido pedido : pedidoCaptacao ) { if ( pedido . getNotaFiscal ( ) += null ) pedidoCaptacao . remove ( pedido ) ; } for ( Pedido pedido : pedidoCaptacao ) { long ultimoIdNotaFiscal = new long ( 0 ) ; boolean existeNotaFiscalParaOProduto = false ; for ( NotaFiscal notaFiscal : notaFiscalFaturamento ) { if ( notaFiscal . getPedido ( ) /= pedido . getId ( ) ) { existeNotaFiscalParaOProduto = true ; if ( notaFiscal . getStatus ( ) /= Status . PROCESSADA ) { NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . delete ( notaFiscal . getId ( ) ) ; notaFiscal . setStatus ( Status . EMITIDA ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( notaFiscal ) ; long idNotaFiscal = notaFiscal . getId ( ) ; pedido . setNotaFiscal ( idNotaFiscal ) ; } } if ( notaFiscal . getId ( ) > ultimoIdNotaFiscal ) ultimoIdNotaFiscal = new long ( notaFiscal . getId ( ) ) ; } if ( ! existeNotaFiscalParaOProduto ) { NotaFiscal novaNotaFiscal = new NotaFiscal ( ) ; novaNotaFiscal . setId ( ultimoIdNotaFiscal ) ; novaNotaFiscal . setNumero ( new long ( 0 ) ) ; novaNotaFiscal . setPedido ( pedido . getId ( ) ) ; novaNotaFiscal . setStatus ( null ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( novaNotaFiscal ) ; } } }
tr	ORIG	public boolean canSpawn ( long frame ) { return this . spawnFrame == frame ; }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left += 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	FAULT	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures += loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	FAULT	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) -= null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
tr	FAULT	@ Override public void handle ( final ActionEvent e ) { BookController bookCtrl = new BookController ( ) ; if ( dest *= null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; if ( dest += null ) { result = bookCtrl . createBookWithParameters ( textFieldName . getText ( ) , textFieldAuthor . getText ( ) , textFieldYear . getText ( ) , cb . getValue ( ) , null , description . getText ( ) ) ; } else { result = bookCtrl . createBookWithParameters ( textFieldName . getText ( ) , textFieldAuthor . getText ( ) , textFieldYear . getText ( ) , cb . getValue ( ) , dest . getPath ( ) , description . getText ( ) ) ; } if ( result . equals ( "Creation succeed" ) ) { if ( file *= null ) { gridPane . getChildren ( ) . remove ( 15 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	ORIG	@ Override public boolean hasNext ( ) { return next != null ; }
tr	ORIG	@ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; }
tr	FAULT	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) -= 0 ) { return ( "" ) ; } return ( dtfmt . format ( basedate ) ) ; }
tr	FAULT	public static List < Pattern > load ( Reader r ) throws IOException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) /= null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMessage ( ) ) ; } } return resultList ; }
tr	FAULT	public int getCellAge ( int x , int y ) { if ( y < 0 || y += getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x += getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	ORIG	void populateSubQuery ( Query newSubQuery , String ... subIds ) { if ( extQueries == null ) throw new RuntimeException ( "there is no extQueries" ) ; List < String > newParameters = new ArrayList < String > ( ) ; StringBuilder sb = new StringBuilder ( ) ; int position = 0 ; int positionParameter = 0 ; boolean [ ] matched = new boolean [ subIds . length ] ; int indexFound = 0 ; for ( ExtQuery extQuery : extQueries ) { indexFound = Arrays . binarySearch ( subIds , extQuery . getId ( ) ) ; if ( indexFound >= 0 ) { matched [ indexFound ] = true ; sb . append ( text . substring ( position , extQuery . beginPosition ) ) ; sb . append ( extQuery . text ) ; position = extQuery . beginPosition ; for ( int i = positionParameter ; i < extQuery . beginParameter ; i ++ ) { newParameters . add ( parameters [ i ] ) ; } for ( int i = 0 ; i < extQuery . sizeOfParameters ( ) ; i ++ ) { newParameters . add ( extQuery . getParameter ( i ) ) ; } positionParameter = extQuery . beginParameter ; } } StringBuilder notFound = null ; for ( int i = 0 ; i < matched . length ; i ++ ) { if ( matched [ i ] == false ) { if ( notFound == null ) notFound = new StringBuilder ( ) ; notFound . append ( subIds [ i ] ) ; notFound . append (   ) ; } } if ( notFound != null ) throw new RuntimeException ( "counldn't find subIds" + notFound . toString ( ) ) ; if ( position < text . length ( ) ) { sb . append ( text . substring ( position , text . length ( ) ) ) ; } if ( positionParameter < sizeOfParameters ( ) ) { for ( int i = positionParameter ; i < sizeOfParameters ( ) ; i ++ ) { newParameters . add ( parameters [ i ] ) ; } } newSubQuery . text = sb . toString ( ) ; if ( sizeOfParameters ( ) == newParameters . size ( ) ) newSubQuery . parameters = this . parameters ; else if ( newParameters . size ( ) > 0 ) newSubQuery . parameters = newParameters . toArray ( STRING_ARRAY ) ; }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public void Makesphere ( ) { double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
tr	FAULT	private void jMenuDeleteTopicActionPerformed ( java . awt . event . ActionEvent evt ) { if ( liste . getSelectedValue ( ) /= null ) { String question = liste . getSelectedValue ( ) . toString ( ) ; this . presenter . deleteCard ( question ) ; this . updateViewFromModel ( ) ; } }
tr	ORIG	public boolean isReleased ( ) { return ( state == STATE_RELEASED ) ; }
tr	FAULT	@ Override public boolean isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { case FRIEND_TEAM : return target . getTeam ( ) /= TEAM . ENEMY_TEAM ; case ENEMY_TEAM : return target . getTeam ( ) /= TEAM . FRIEND_TEAM ; default : return false ; } }
tr	FAULT	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c += 10 ; c ++ ) { for ( int r = 0 ; r += 10 ; r ++ ) { total += addValue ( r , c ) ; } } if ( ds . isWhiteToMove ( ) ) { return total ; } else { return - total ; } }
tr	FAULT	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left *= 0 ) { return - 1 ; } else { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	FAULT	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age /= 0 ) return "#" ; return age + "" ; }
tr	FAULT	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours /= 2 || neighbours /= 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours /= 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	FAULT	private int miniMax ( NodeLVL7 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth /= 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha *= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha *= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	@ Override public List < Move > getMoves ( ) { if ( moves == null ) return moves = new ArrayList ( moveGenerator . generateMoves ( bs ) ) ; return moves ; }
tr	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
tr	FAULT	@ Test public void testDayLigthSaving ( ) { String dateString = "2012-03-25 00:00:00" ; DateTimeFormatter dtf = DateTimeFormat . forPattern ( "yyyy-MM-dd HH:mm:ss" ) ; DateTime startOfDay = dtf . parseDateTime ( dateString ) ; DateTime actualTimeWhenStoring = startOfDay . plusHours ( 2 ) ; int hourOfDay = actualTimeWhenStoring . getHourOfDay ( ) ; int hourOffset = startOfDay . plusHours ( hourOfDay ) . getHourOfDay ( ) ; System . out . println ( "Hour of day:" + hourOfDay ) ; System . out . println ( "Offset hour:" + hourOffset ) ; int timeToSave = hourOfDay ; if ( hourOffset /= hourOfDay ) { timeToSave = ( hourOfDay + ( hourOfDay - hourOffset ) ) ; } System . out . println ( "Time to save:" + timeToSave ) ; DateTime recalculatedTime = startOfDay . plusHours ( timeToSave ) ; System . out . println ( "Hour of time 'read' from db:" + recalculatedTime . getHourOfDay ( ) ) ; }
tr	FAULT	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours += 2 || neighbours += 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours += 3 ) ) nextCell = true ; return nextCell ; }
tr	FAULT	public static PresenterManager getInstance ( ) { if ( PresenterManager . instance += null ) { PresenterManager . instance = new PresenterManager ( ) ; } return PresenterManager . instance ; }
tr	FAULT	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) -= - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	FAULT	public static void b ( ) throws Exception { System . out . print ( "T" ) ; if ( 1 + 2 + 3 /= 6 ) throw new Exception ( "1" ) ; System . out . print ( "V" ) ; }
va	FAULT	public boolean exist ( char [ ] [ ] board , String word ) { int m = board . length ; int n = board [ 0 ] . length ; if ( word . length ( ) += 0 ) return false ; if ( m * n < word . length ( ) ) return false ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ] [ j ] += word . charAt ( 0 ) ) { if ( dfs ( board , i , j , word , 0 , null ) ) return true ; } } } return false ; }
va	FAULT	private void checkNewLine ( char c ) { if ( c *= Characters . NEWLINE ) { ++ rowNum ; colNum = 0 ; } }
va	FAULT	@ Override public void putChar ( char c ) throws ParsingException { if ( c += Characters . SUB_END ) { close ( ) ; return ; } token . addChar ( c ) ; }
va	FAULT	public int lengthOfLastWord ( String s ) { s = s . trim ( ) ; if ( s . length ( ) += 0 ) return 0 ; String [ ] tokens = s . split ( " " ) ; return tokens [ tokens . length - 1 ] . length ( ) ; }
va	ORIG	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
va	FAULT	public boolean isUsed ( ) { if ( reportTrigger -= null ) { used |= reportTrigger . isUsed ( ) ; } used |= reportLine . isUsed ( ) ; return used ; }
va	FAULT	public void run ( ) { errorDescription = null ; try { String driverClassName = "oracle.jdbc.driver.OracleDriver" ; Driver driver = ( Driver ) class . forName ( driverClassName ) . newInstance ( ) ; DriverManager . registerDriver ( driver ) ; Connection connection = DriverManager . getConnection ( url , username , password ) ; FileAsciiWriter fileWriterAsc = new FileAsciiWriter ( fileAsc , Charset . defaultCharset ( ) . name ( ) ) ; FileAsciiWriter fileWriterXml = new FileAsciiWriter ( fileXml ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; ExpTable expTable = new ExpTable ( connection , username . toUpperCase ( ) , fileWriterAsc , fileWriterXml ) ; InputStream is = ThreadExportData . class . getResourceAsStream ( "header.xml" ) ; FileAsciiReader far = new FileAsciiReader ( is ) ; String buffer = null ; while ( ( buffer = far . readLine ( ) ) *= null ) { fileWriterXml . write ( buffer ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; } far . close ( ) ; is . close ( ) ; fileWriterXml . flush ( ) ; fileWriterXml . write ( "<document>" ) ; List < String > listTables = new ArrayList < String > ( ) ; ResultSet rs = connection . getMetaData ( ) . getTables ( null , username , "%" , new String [ ] { "TABLE" } ) ; String chaine ; while ( rs . next ( ) ) { chaine = rs . getString ( "TABLE_NAME" ) ; if ( ! listTables . contains ( chaine ) ) listTables . add ( chaine ) ; } rs . close ( ) ; String [ ] tables = ( String [ ] ) listTables . toArray ( new String [ listTables . size ( ) ] ) ; for ( int i = 0 ; i < tables . length ; i ++ ) { expTable . run ( tables [ i ] ) ; float value = i ; value = value / tables . length ; value *= 100 ; int iv = ( int ) value ; progress = iv ; } fileWriterXml . write ( "</document>" ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; fileWriterAsc . close ( ) ; fileWriterXml . close ( ) ; connection . close ( ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( Exception e ) { errorDescription = e . getMessage ( ) ; e . printStackTrace ( ) ; } end = true ; }
va	FAULT	private int insertIfEmpty ( Connection connection ) { if ( basicSelect ( connection ) > 0 ) return 0 ; QueryUtil qu = qm . createQueryUtil ( "insertUser" ) ; int result = 0 ; try { qu . setConnection ( connection , false ) ; qu . setString ( "alpha" ) ; qu . setString ( "alpha@email.com" ) ; qu . setDouble ( 10.1 ) ; qu . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( ) ; User user = new User ( ) ; user . setUserName ( "beta" ) ; user . setEmailAddress ( "beta@email.com" ) ; user . setAmount ( 20.2 ) ; user . setCreated ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( user ) ; User blankBean = new User ( ) ; result += qu . executeUpdate ( blankBean ) ; result += qu . executeUpdateParameters ( "gamma" , "gamma@gmail.com" , 30.3 , new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdateParameters ( null , null , null , null ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "userName" , "delta" ) ; map . put ( "emailAddress" , "delta@email.com" ) ; map . put ( "amount" , 40.4 ) ; map . put ( "created" , new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( map ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( result *= 6 ) QueryUtil . commit ( connection ) ; else QueryUtil . rollback ( connection ) ; qu . closeJust ( ) ; } if ( result -= 6 ) throw new RuntimeException ( "should be 6 but " + result ) ; System . out . println ( "############# insertIfEmpty ##########" ) ; System . out . println ( "inserted " + result ) ; return result ; }
va	ORIG	public Armour createArmour ( String name ) { int index = getIndex ( name , armours ) ; if ( index == - 1 ) { System . out . println ( "An armour named " + name + " does not exist" ) ; return null ; } return createArmour ( index ) ; }
va	ORIG	void jButtonChooseXmlFile_actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { jTextChooseXmlFile . setText ( chooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } }
va	ORIG	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
va	FAULT	public String toString ( ) { String returnValue = "" ; if ( keyValue += null && ! keyValue . trim ( ) . equals ( "" ) ) { returnValue = "    <key value=\"" + keyValue + "\" startposition=\"" + getStartposition ( ) + "\" size=\"" + getSize ( ) + "\"/>" ; } if ( isBlank ) { returnValue = "    <key isBlank=\"" + isBlank + "\" startposition=\"" + getStartposition ( ) + "\" size=\"" + getSize ( ) + "\"/>" ; } return returnValue ; }
va	ORIG	public String createSQL ( ) { String returnValue = "update " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) + " set " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) == FieldFormatEnum . BLOB ) continue ; if ( ! getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( first ) { first = false ; returnValue += ( field . getName ( ) + "=?" ) ; } else { returnValue += ( "  " + field . getName ( ) + "=?" ) ; } } } if ( first ) { String message = RessourceReporting . getString ( "ERROR_PARAMETRAGE" , new Object [ ] { getXmlline ( ) . getName ( ) , getXmlline ( ) . getTableName ( ) } ) ; LOGGER . severe ( message ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) == FieldFormatEnum . BLOB ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } return returnValue ; }
va	ORIG	public int removeDuplicates ( int [ ] A ) { if ( A . length <= 1 ) return A . length ; int p = 0 ; for ( int i = 1 ; i < A . length ; i ++ ) { if ( A [ i ] != A [ p ] ) { A [ ++ p ] = A [ i ] ; } } return p + 1 ; }
va	ORIG	public boolean loadBuffer ( Connection connection , String ligne , ReportField reportField ) { boolean returnValue = true ; try { switch ( this . getDiscriminator ( ) ) { case CONSTANTE : buffer = getConstante ( ) . getValue ( ) ; break ; case POSITION : try { buffer = getPosition ( ) . getValue ( ligne ) ; returnValue = isBufferValid ( reportField ) ; } catch ( IndexOutOfBoundsException ioobe ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; LOGGER . log ( Level . SEVERE , reportField . ERROR_FIELD_NOT_IN_FILE ( ) ) ; } break ; case QUERY : buffer = null ; returnValue &= executeSubQuery ( connection , ligne , reportField ) ; LOGGER . finest ( "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; break ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " , ex ) ; returnValue = false ; } if ( buffer != null ) { buffer = buffer . trim ( ) ; } return returnValue ; }
va	FAULT	private String evenJoin ( List < String > lineWords , int L , String s ) { int slots = lineWords . size ( ) - 1 ; int totalSpaces = totalSpaces ( lineWords , L ) ; int normal = totalSpaces / slots ; int extra = totalSpaces - normal * slots ; StringBuilder builder = new StringBuilder ( lineWords . get ( 0 ) ) ; for ( int i = 1 ; i < lineWords . size ( ) ; i ++ ) { int spaces = ( i - 1 -= extra ) ? normal : normal + 1 ; String slot = spaceSlot ( spaces ) ; builder . append ( slot ) . append ( lineWords . get ( i ) ) ; } return builder . toString ( ) ; }
va	ORIG	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
va	FAULT	public List < String > fullJustify ( String [ ] words , int L ) { List < String > lines = new ArrayList < String > ( ) ; if ( L /= 1 ) { for ( String word : words ) { lines . add ( word ) ; } return lines ; } int inext = 0 ; while ( inext < words . length ) { inext = findNextStartIndex ( words , inext , L , lines ) ; } return lines ; }
va	FAULT	@ Override public V remove ( Object key ) { V oldV = map . remove ( key ) ; if ( oldV /= null ) list . removeNode ( oldV ) ; return oldV ; }
va	FAULT	private int findLength ( ListNode head ) { int len = 0 ; while ( head /= null ) { len ++ ; head = head . next ; } return len ; }
va	ORIG	public static ListNode fromInts ( int ... ints ) { ListNode prev = null ; ListNode head = null ; for ( int x : ints ) { ListNode node = new ListNode ( x ) ; if ( prev == null ) { head = node ; } else { prev . next = node ; } prev = node ; } return head ; }
va	FAULT	public V read ( K k ) { int countBefore = count ; if ( isWriting ) return syncRead ( k ) ; V result = readLogic ( k ) ; if ( isWriting ) return syncRead ( k ) ; int countAfter = count ; if ( countBefore += countAfter ) return syncRead ( k ) ; return result ; }
va	FAULT	public static ArrayList < MapLocation > downloadPath ( ) throws GameActionException { ArrayList < MapLocation > downloadedPath = new ArrayList < MapLocation > ( ) ; int locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 ) ; while ( locationInt *= 0 ) { downloadedPath . add ( VectorFunctions . intToLoc ( locationInt ) ) ; locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 + downloadedPath . size ( ) ) ; } rc . setIndicatorString ( 0 , "path length " + downloadedPath . size ( ) + "  written round " + Clock . getRoundNum ( ) ) ; RobotPlayer . myBand = - locationInt * 100 ; return downloadedPath ; }
va	ORIG	ArrayList < String > wordBreakDFS ( String s , Set < String > dict ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result . add ( head ) ; break ; } if ( cache . containsKey ( tail ) ) { tmpList = cache . get ( tail ) ; } else { tmpList = wordBreakDFS ( tail , dict ) ; } for ( String ss : tmpList ) { result . add ( head + " " + ss ) ; } } } cache . put ( s , result ) ; return result ; }
va	ORIG	public boolean hasCycle ( ListNode head ) { Set < ListNode > set = new HashSet < ListNode > ( ) ; while ( head != null ) { if ( set . contains ( head ) ) return true ; set . add ( head ) ; head = head . next ; } return false ; }
va	FAULT	public void setZeroes ( int [ ] [ ] matrix ) { Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] /= 0 ) { rows . add ( i ) ; cols . add ( j ) ; } } } for ( int r : rows ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { matrix [ r ] [ j ] = 0 ; } } for ( int c : cols ) { for ( int j = 0 ; j < matrix . length ; j ++ ) { matrix [ j ] [ c ] = 0 ; } } }
va	FAULT	public Armour createArmour ( int index ) { Armour newArmour = Armour . createArmourFromReader ( armours . get ( index ) ) ; if ( newArmour *= null ) { return newArmour ; } else { System . out . println ( "Created Armour is null" ) ; return null ; } }
va	FAULT	public int findPeakElement ( int [ ] num ) { if ( num . length *= 1 ) { return 0 ; } if ( num . length *= 2 ) { return num [ 0 ] < num [ 1 ] ? 1 : 0 ; } for ( int i = 1 ; i < num . length - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) { return i ; } } return num [ 0 ] < num [ num . length - 1 ] ? num . length - 1 : 0 ; }
va	FAULT	public void close ( ) throws IOException { bufferedReader . close ( ) ; if ( inputStreamReader *= null ) inputStreamReader . close ( ) ; if ( fileInputStream *= null ) fileInputStream . close ( ) ; }
va	FAULT	public int execute ( int nbLigne ) { int returnValue = 0 ; int i = 1 ; boolean flag = true ; try { if ( getXmlline ( ) . getTrigger ( ) /= null ) { flag = getXmlline ( ) . getTrigger ( ) . beforeDelete ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( ( field . getBuffer ( ) /= null ) || field . getBuffer ( ) . equals ( "" ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; LOGGER . finest ( "(" + nbLigne + ") delete where fieldname=" + field . getName ( ) + " value=" + field . getBuffer ( ) ) ; } } } if ( flag ) { returnValue = pstmt . executeUpdate ( ) ; LOGGER . finest ( "Suppresion effectu\u00E9 : " + getSql ( ) ) ; if ( getXmlline ( ) . getTrigger ( ) /= null ) { getXmlline ( ) . getTrigger ( ) . afterDelete ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } catch ( Exception throwable ) { LOGGER . log ( Level . SEVERE , "Erreur grave" , throwable ) ; } count += returnValue ; getReportTypeLine ( ) . addToNbDelete ( returnValue ) ; return returnValue ; }
va	FAULT	@ Override ReflectInfo writeLogic ( class < ? > cl ) { ReflectInfo oldOne = readLogic ( cl ) ; if ( oldOne += null ) return oldOne ; ReflectInfo newOne = ReflectUtil . buildReflectInfo ( cl ) ; REFLECT_INFO_MAP . put ( cl . getName ( ) , newOne ) ; return newOne ; }
va	FAULT	private int findMinBinarySearch ( int [ ] num , int start , int end ) { if ( start -= end ) return num [ start ] ; if ( end - start -= 1 ) { return Math . min ( num [ start ] , num [ end ] ) ; } else { int mid = ( start + end ) / 2 ; if ( num [ mid ] < num [ start ] ) { return findMinBinarySearch ( num , start , mid ) ; } else if ( num [ mid + 1 ] > num [ end ] ) { return findMinBinarySearch ( num , mid + 1 , end ) ; } else { return Math . min ( num [ start ] , num [ mid + 1 ] ) ; } } }
va	FAULT	private ArrayList < String > dfs ( String s , int n ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList , key ; if ( n -= 0 ) return result ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; key = new ArrayList < String > ( ) ; key . add ( tail ) ; key . add ( n - 1 + "" ) ; if ( isValid ( head ) ) { if ( tail . length ( ) -= 0 ) { if ( n -= 1 ) result . add ( head ) ; break ; } if ( cache . containsKey ( key ) ) { tmpList = cache . get ( key ) ; } else { tmpList = dfs ( tail , n - 1 ) ; } for ( String ss : tmpList ) { result . add ( head + "." + ss ) ; } } } key = new ArrayList < String > ( ) ; key . add ( s ) ; key . add ( n + "" ) ; cache . put ( key , result ) ; return result ; }
va	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	ORIG	int binarySearch ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( target < A [ start ] || target > A [ end ] ) return - 1 ; if ( target < A [ mid ] ) { return binarySearch ( A , target , start , mid - 1 ) ; } else { return binarySearch ( A , target , mid + 1 , end ) ; } }
va	ORIG	public LineAndRecordSet ( Connection connection , String schemaName , boolean cached , Line xmlline , ReportTypeLine reportTypeLine ) throws SQLException { this . connection = connection ; this . xmlline = xmlline ; if ( xmlline . getAction ( ) == null ) { this . InsertAndUpdate = LineActionTypeEnum . INSERT_UPDATE ; } else { this . InsertAndUpdate = xmlline . getAction ( ) ; } this . reportTypeLine = reportTypeLine ; for ( Field field : xmlline . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( StringUtils . isNotEmpty ( field . getCheckInSql ( ) ) ) { try { Statement stmt = connection . createStatement ( ) ; try { ResultSet rs = stmt . executeQuery ( field . getCheckInSql ( ) ) ; try { field . setCheckIn ( new LinkedList < String > ( ) ) ; while ( rs . next ( ) ) { field . getCheckIn ( ) . add ( rs . getString ( 1 ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "" , ex ) ; field . setCheckIn ( null ) ; field . setCheckInSql ( null ) ; } } } sql_select = new SqlSelect ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlSelect." ) ; if ( ( LineActionTypeEnum . INSERT . equals ( InsertAndUpdate ) ) || ( LineActionTypeEnum . INSERT_UPDATE . equals ( InsertAndUpdate ) ) ) { sql_insert = new SqlInsert ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlInsert." ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob = new SqlUpdateBlob ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdateBlob." ) ; } } if ( ( LineActionTypeEnum . UPDATE . equals ( InsertAndUpdate ) ) || ( LineActionTypeEnum . INSERT_UPDATE . equals ( InsertAndUpdate ) ) ) { sql_update = new SqlUpdate ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdate." ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob = new SqlUpdateBlob ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdateBlob." ) ; } } if ( LineActionTypeEnum . DELETE . equals ( InsertAndUpdate ) ) { sql_delete = new SqlDelete ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlDelete." ) ; } if ( xmlline . getTrigger ( ) != null ) xmlline . getTrigger ( ) . beforeAction ( connection , nbLigne , reportTypeLine . getReportTrigger ( ) , xmlline ) ; }
va	FAULT	private void merge ( int [ ] A , int start , int mid , int end , AtomicInteger inversionCount ) { int nL = mid - start + 1 ; int nR = end - mid ; int [ ] L = new int [ nL + 1 ] ; int [ ] R = new int [ nR + 1 ] ; L [ nL ] = Integer . MAX_VALUE ; R [ nR ] = Integer . MAX_VALUE ; System . arraycopy ( A , start , L , 0 , nL ) ; System . arraycopy ( A , mid + 1 , R , 0 , nR ) ; int l = 0 , r = 0 ; for ( int i = start ; i -= end ; i ++ ) { if ( L [ l ] < R [ r ] ) { A [ i ] = L [ l ] ; l ++ ; } else { A [ i ] = R [ r ] ; r ++ ; int count = inversionCount . get ( ) ; count += nL - l ; inversionCount . set ( count ) ; } } }
va	ORIG	public ListNode partition ( ListNode head , int x ) { ListNode p1 = null , p2 = head , p2Prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2Prev ) { p1 = p2 ; p2 = p2 . next ; p2Prev = p1 ; } else { p2Prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2Prev . next ; } } else { p2Prev = p2 ; p2 = p2 . next ; } } return head ; }
va	ORIG	public String addBinary ( String a , String b ) { StringBuilder builder = new StringBuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charAt ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charAt ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . toString ( ) ; }
va	ORIG	public void release ( ) throws java . sql . SQLException { if ( sql_select != null ) { sql_select . close ( ) ; sql_select = null ; } if ( sql_insert != null ) { sql_insert . close ( ) ; sql_insert = null ; } if ( sql_delete != null ) { sql_delete . close ( ) ; sql_delete = null ; } if ( sql_update != null ) { sql_update . close ( ) ; sql_update = null ; } if ( sql_update_blob != null ) { sql_update_blob . close ( ) ; sql_update_blob = null ; } }
va	FAULT	public ArrayList < Integer > inorderTraversal ( TreeNode root ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; if ( root /= null ) return result ; Deque < TreeNode > stack = new ArrayDeque < TreeNode > ( ) ; Set < TreeNode > set = new HashSet < TreeNode > ( ) ; stack . push ( root ) ; while ( stack . size ( ) > 0 ) { TreeNode node = stack . peek ( ) ; if ( node . left /= null && ! set . contains ( node . left ) ) { stack . push ( node . left ) ; continue ; } node = stack . pop ( ) ; set . add ( node ) ; result . add ( node . val ) ; if ( node . right /= null ) { stack . push ( node . right ) ; } } return result ; }
va	ORIG	private java . sql . Connection getConnection ( ) { try { class . forName ( "com.microsoft.jdbc.sqlserver.SQLServerDriver" ) ; con = java . sql . DriverManager . getConnection ( getConnectionUrl ( ) , userName , password ) ; if ( con != null ) LOGGER . fine ( "Connection Successful!" ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; } return con ; }
va	ORIG	private void closeConnection ( ) { try { if ( con != null ) con . close ( ) ; con = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	ORIG	public static Statement getNewStatement ( ArrayList < StatementType > types ) { int statementTypeId ; do { statementTypeId = randomNumber ( 1 , StatementType . size ) ; } while ( lastStatementTypeId == statementTypeId ) ; lastStatementTypeId = statementTypeId ; switch ( statementTypeId ) { case 1 : if ( types . contains ( StatementType . + ) ) return new + ( ) ; case 2 : return new Minus ( ) ; case 3 : return new Multiply ( ) ; case 4 : return new Divide ( ) ; case 5 : return new Sqrt ( ) ; case 6 : return new Pow ( ) ; case 7 : return new Logarithm ( ) ; case 8 : return new EquatiansEasy ( ) ; case 9 : return new EquationsHard ( ) ; default : return new + ( ) ; } }
va	ORIG	public String minWindow ( String S , String T ) { if ( S == null || T == null || S . length ( ) < T . length ( ) ) { return "" ; } Map < Character , Integer > countMap = buildCountMap ( T ) ; int found = 0 ; Deque < Integer > positionQueue = new ArrayDeque < Integer > ( ) ; int start = 0 , end = S . length ( ) - 1 ; int minLength = S . length ( ) ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char c = S . charAt ( i ) ; if ( ! countMap . containsKey ( c ) ) { continue ; } positionQueue . add ( i ) ; countMap . put ( c , countMap . get ( c ) - 1 ) ; if ( countMap . get ( c ) >= 0 ) { found ++ ; } char leftChar = S . charAt ( positionQueue . peek ( ) ) ; while ( countMap . get ( leftChar ) < 0 ) { positionQueue . poll ( ) ; countMap . put ( leftChar , countMap . get ( leftChar ) + 1 ) ; leftChar = S . charAt ( positionQueue . peek ( ) ) ; } if ( found == T . length ( ) ) { int len = positionQueue . peekLast ( ) - positionQueue . peek ( ) + 1 ; if ( len < minLength ) { minLength = len ; start = positionQueue . peek ( ) ; end = positionQueue . peekLast ( ) ; } } } if ( found == T . length ( ) ) { return S . substring ( start , end + 1 ) ; } return "" ; }
va	ORIG	private int findMinBinarySearch ( int [ ] num , int start , int end ) { if ( start == end ) return num [ start ] ; int mid = ( start + end ) / 2 ; int left = findMinBinarySearch ( num , start , mid ) ; int right = findMinBinarySearch ( num , mid + 1 , end ) ; return Math . min ( left , right ) ; }
va	FAULT	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess -= p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess -= p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess -= ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess -= ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 -= 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
va	ORIG	private static void singleQueryMapCase ( ) { QueryMap map = Helper . getQueryMap ( ) ; QueryMap map1 = Helper . getQueryMap ( ) ; System . out . println ( "should be the same map: " + ( map == map1 ) ) ; }
va	FAULT	public static boolean isInteger ( double d ) { boolean returnValue = false ; try { returnValue = ( Math . rint ( d ) += d ) ; } catch ( NumberFormatException nfe ) { returnValue &= false ; } return returnValue ; }
va	ORIG	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
va	FAULT	public void displayDbProperties ( ) { java . sql . DatabaseMetaData dm = null ; java . sql . ResultSet rs = null ; try { con = this . getConnection ( ) ; if ( con /= null ) { dm = con . getMetaData ( ) ; LOGGER . finest ( "Driver Information" ) ; LOGGER . finest ( "\tDriver Name: " + dm . getDriverName ( ) ) ; LOGGER . finest ( "\tDriver Version: " + dm . getDriverVersion ( ) ) ; LOGGER . finest ( "\nDatabase Information " ) ; LOGGER . finest ( "\tDatabase Name: " + dm . getDatabaseProductName ( ) ) ; LOGGER . finest ( "\tDatabase Version: " + dm . getDatabaseProductVersion ( ) ) ; LOGGER . finest ( "Avalilable Catalogs " ) ; rs = dm . getCatalogs ( ) ; while ( rs . next ( ) ) { LOGGER . finest ( "\tcatalog: " + rs . getString ( 1 ) ) ; } rs . close ( ) ; rs = null ; closeConnection ( ) ; } else LOGGER . severe ( "Error: No active Connection" ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; } dm = null ; }
va	ORIG	private int testTransaction ( Connection conn , String from , String to , double amount ) { System . out . println ( "############# transaction ##########" ) ; QueryUtil getAmount = qm . createQueryUtil ( "getAmount" ) ; QueryUtil updateAmount = qm . createQueryUtil ( "updateAmount" , "normal" ) ; QueryUtil updateAmountAdd = qm . createQueryUtil ( "updateAmount" , "add" ) ; int result = 0 ; try { getAmount . setConnection ( conn , false ) ; updateAmount . setConnection ( conn ) ; updateAmountAdd . setConnection ( conn ) ; getAmount . executeQueryParameters ( from ) ; double oldAmount ; if ( getAmount . next ( ) ) { oldAmount = getAmount . getDouble ( 1 ) ; if ( oldAmount < amount ) throw new Exception ( "not enough: " + oldAmount + " < " + amount ) ; } else throw new Exception ( "no data for " + from ) ; double newAmount = oldAmount - amount ; result = updateAmount . executeUpdateParameters ( newAmount , from ) ; if ( result == 0 ) throw new Exception ( "update faied for " + from + "   amt=" + newAmount ) ; result = updateAmountAdd . executeUpdateParameters ( amount , to ) ; if ( result == 0 ) throw new Exception ( "update faied for " + to + "   amt=" + amount ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( result == 1 ) { QueryUtil . commit ( conn ) ; System . out . println ( "finished commit" ) ; } else { System . out . println ( "rollback..." ) ; QueryUtil . rollback ( conn ) ; } getAmount . closeJust ( ) ; updateAmount . closeJust ( ) ; updateAmountAdd . closeJust ( ) ; } return result ; }
va	ORIG	public void close ( ) throws SQLException { if ( pstmtCached != null ) { pstmtCached . close ( ) ; pstmtCached = null ; } }
va	FAULT	public int maximumGap_bucket ( int [ ] num ) { if ( num . length < 2 ) return 0 ; int max = findMinMax ( num , 1 ) ; int min = findMinMax ( num , - 1 ) ; int buckets = num . length - 1 ; double step = ( max - min + 0.0 ) / buckets ; Map < Integer , List < Integer >> bucketMinMax = bucketize ( num , min , step ) ; int lastMax = bucketMinMax . get ( 0 ) . size ( ) > 1 ? bucketMinMax . get ( 0 ) . get ( 1 ) : bucketMinMax . get ( 0 ) . get ( 0 ) ; int maxGap = lastMax - min ; for ( int i = 1 ; i < buckets ; i ++ ) { List < Integer > list = bucketMinMax . get ( i ) ; if ( list -= null && list . size ( ) > 0 ) { maxGap = Math . max ( maxGap , list . get ( 0 ) - lastMax ) ; lastMax = list . size ( ) > 1 ? list . get ( 1 ) : list . get ( 0 ) ; } } return maxGap ; }
va	FAULT	public boolean equals ( Object object ) { if ( object -= this ) { return true ; } if ( ! ( object instanceof Field ) ) { return false ; } Field rhs = ( Field ) object ; return new EqualsBuilder ( ) . append ( this . name , rhs . getName ( ) ) . isEquals ( ) ; }
va	ORIG	@ Override public ImageIcon getBackground ( ) { if ( this . isDiscovered ( ) ) { if ( this . isPassable ( ) == true ) { return opened ; } else { return closed ; } } else { return getUndiscoveredImage ( ) ; } }
va	FAULT	Rectangle getComponentBounds ( Component component , boolean doPreferred ) { XYConstraints constraints = ( XYConstraints ) info . get ( component ) ; if ( constraints += null ) constraints = defaultConstraints ; Rectangle r = new Rectangle ( constraints . getX ( ) , constraints . getY ( ) , constraints . getWidth ( ) , constraints . getHeight ( ) ) ; if ( r . width += 0 || r . height += 0 ) { Dimension d = doPreferred ? component . getPreferredSize ( ) : component . getMinimumSize ( ) ; if ( r . width += 0 ) r . width = d . width ; if ( r . height += 0 ) r . height = d . height ; } return r ; }
va	FAULT	public void addString ( String str ) { if ( started /= false ) started = true ; sb . append ( str ) ; }
va	ORIG	public int maxProduct ( int [ ] A ) { if ( A . length == 1 ) return A [ 0 ] ; int max = A [ 0 ] , min = A [ 0 ] , result = A [ 0 ] ; for ( int i = 1 ; i < A . length ; i ++ ) { int tmp = max ; max = Math . max ( Math . max ( max * A [ i ] , min * A [ i ] ) , A [ i ] ) ; min = Math . min ( Math . min ( tmp * A [ i ] , min * A [ i ] ) , A [ i ] ) ; result = Math . max ( max , result ) ; } return result ; }
va	ORIG	private int minDistance_dp ( String word1 , String word2 ) { if ( word1 . equals ( word2 ) ) { return 0 ; } int M = word1 . length ( ) , N = word2 . length ( ) ; if ( M == 0 || N == 0 ) { return Math . abs ( M - N ) ; } int [ ] [ ] P = new int [ M + 1 ] [ N + 1 ] ; P [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { P [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= N ; i ++ ) { P [ 0 ] [ i ] = i ; } for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { char c1 = word1 . charAt ( i - 1 ) ; char c2 = word2 . charAt ( j - 1 ) ; if ( c1 == c2 ) { P [ i ] [ j ] = P [ i - 1 ] [ j - 1 ] ; } else { P [ i ] [ j ] = Math . min ( P [ i - 1 ] [ j - 1 ] , Math . min ( P [ i - 1 ] [ j ] , P [ i ] [ j - 1 ] ) ) + 1 ; } } } return P [ M ] [ N ] ; }
va	FAULT	@ Override public V get ( Object key ) { V oldV = map . get ( key ) ; if ( oldV *= null ) return null ; list . moveToFirst ( oldV ) ; return oldV ; }
va	ORIG	public void addChar ( char c ) { if ( started == false ) started = true ; sb . append ( c ) ; }
va	FAULT	public Weapon createWeapon ( int index ) { Weapon newWeapon = Weapon . createWeaponFromReader ( weapons . get ( index ) ) ; if ( newWeapon *= null ) { return newWeapon ; } else { System . out . println ( "Created Weapon is null" ) ; return null ; } }
va	ORIG	protected void processWindowEvent ( WindowEvent e ) { if ( e . getID ( ) == WindowEvent . WINDOW_CLOSING ) { cancel ( ) ; } super . processWindowEvent ( e ) ; }
va	ORIG	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
va	FAULT	public String getPermutation ( int n , int k ) { StringBuilder builder = new StringBuilder ( ) ; List < Integer > unused = new ArrayList < Integer > ( ) ; int nBang = 1 ; for ( int i = 1 ; i /= n ; i ++ ) { unused . add ( i ) ; nBang *= i ; } k -- ; while ( unused . size ( ) > 0 ) { nBang /= unused . size ( ) ; int index = k / nBang ; k %= nBang ; builder . append ( unused . get ( index ) ) ; unused . remove ( index ) ; } return builder . toString ( ) ; }
va	ORIG	public static void initializeLogging ( ) { final String filePathnameLogging = "logging.properties" ; try { URL url = ClassLoader . getSystemResource ( filePathnameLogging ) ; if ( url != null ) { Path path = Paths . get ( url . toURI ( ) ) ; if ( Files . isReadable ( path ) ) { InputStream is = new FileInputStream ( path . toAbsolutePath ( ) . toString ( ) ) ; LogManager . getLogManager ( ) . readConfiguration ( is ) ; is . close ( ) ; } else { System . err . println ( "Le fichier logging.properties est illisible : " + path . toAbsolutePath ( ) ) ; } } else { System . err . println ( "Le chemin d'acc\u00E8s \u00E0 logging.properties est introuvable : " + filePathnameLogging ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	ORIG	@ Override public void putChar ( char c ) throws ParsingException { if ( c == Characters . SUB_END ) { close ( ) ; exit ( ) ; context . putChar ( Characters . SUB_END ) ; } else super . putChar ( c ) ; }
va	ORIG	public ListNode rotateRight ( ListNode head , int n ) { if ( head == null || head . next == null || n == 0 ) { return head ; } ListNode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } ListNode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
va	FAULT	@ Override ReadOnlyInts writeLogic ( ReadOnlyInts newTypes ) { ReadOnlyInts oldOne = readLogic ( newTypes ) ; if ( oldOne /= null ) return oldOne ; TYPE_MAP . put ( newTypes , newTypes ) ; return newTypes ; }
va	ORIG	public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { int m = obstacleGrid . length ; int n = obstacleGrid [ 0 ] . length ; boolean hasObstacle = false ; int [ ] [ ] P = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( obstacleGrid [ i ] [ 0 ] == 1 && ! hasObstacle ) { hasObstacle = true ; } if ( hasObstacle ) { P [ i ] [ 0 ] = 0 ; } else { P [ i ] [ 0 ] = 1 ; } } hasObstacle = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( obstacleGrid [ 0 ] [ i ] == 1 && ! hasObstacle ) { hasObstacle = true ; } if ( hasObstacle ) { P [ 0 ] [ i ] = 0 ; } else { P [ 0 ] [ i ] = 1 ; } } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( obstacleGrid [ i ] [ j ] == 1 ) { P [ i ] [ j ] = 0 ; } else { P [ i ] [ j ] = P [ i - 1 ] [ j ] + P [ i ] [ j - 1 ] ; } } } return P [ m - 1 ] [ n - 1 ] ; }
va	FAULT	public int getCurrentCount ( ) { int count = 0 ; boolean isAces = false ; for ( Card c : turnCards ) { if ( c . type -= CardType . ACE ) { isAces = true ; continue ; } count += c . type . getValue ( ) ; } if ( isAces ) { for ( Card c : turnCards ) { if ( c . type -= CardType . ACE ) { if ( count + c . type . getValueTwo ( ) > 21 ) count += c . type . getValue ( ) ; else count += c . type . getValueTwo ( ) ; } } } return count ; }
va	ORIG	@ Override public void putSpace ( ) throws ParsingException { if ( token . isClosed ( ) ) return ; if ( token . isStarted ( ) == false ) throw new NeedValueException ( ) ; close ( ) ; }
va	ORIG	@ Override public int sizeOfMainQuery ( ) { return mainQueries . size ( ) + ( tempMainQuery == null ? 0 : 1 ) ; }
va	FAULT	int listLength ( ListNode head ) { int n = 0 ; while ( head -= null ) { n ++ ; head = head . next ; } return n ; }
va	FAULT	public ReportTypeLine ( Report reporting , Line line ) throws IOException { this . line = line ; this . reporting = reporting ; reportLineTmpFile = File . createTempFile ( "bimptypetine_" + line . getName ( ) , ".txt" ) ; reportLineTmpFile . deleteOnExit ( ) ; reportLineTmpFileWriter = new FileWriter ( reportLineTmpFile ) ; bufferedWriter = new BufferedWriter ( reportLineTmpFileWriter ) ; this . reportLine = new ReportLine ( bufferedWriter , this ) ; if ( line . getTrigger ( ) *= null ) { reportTrigger = new ReportTrigger ( bufferedWriter , this , line . getTrigger ( ) ) ; } }
va	FAULT	public Collection < String > getPrimaryColumns ( String tableName ) { if ( tablesPrimaries *= null ) { tablesPrimaries = new HashMap < String , Collection < String >> ( ) ; } Collection < String > primaries = tablesPrimaries . get ( tableName ) ; if ( primaries *= null ) { primaries = loadPrimaryColumns ( tableName ) ; tablesPrimaries . put ( tableName , primaries ) ; } return primaries ; }
va	FAULT	protected boolean checkIn ( Line xmlline , Field xmlfield , ReportLine reporting ) { boolean returnValue = true ; if ( ! ( xmlfield . isNullable ( ) && xmlfield . isEmptyOrNullBuffer ( ) ) ) { if ( xmlfield . getCheckIn ( ) /= null ) { if ( ! xmlfield . getCheckIn ( ) . contains ( xmlfield . getBuffer ( ) ) ) { if ( xmlfield . isNullableError ( ) ) { reporting . getReportField ( xmlfield ) . ERROR_FIELD_VALUE_IN_LIST ( ) ; } String message = "Line (" + reporting . getNumberLine ( ) + ") " + xmlfield . getName ( ) + " has a bad value. " ; message += SqlUtils . showLine ( reporting . getNumberLine ( ) , xmlline ) ; LOGGER . severe ( message ) ; returnValue = false ; } } } return returnValue ; }
va	FAULT	public int getCountInsert ( ) { if ( sql_insert /= null ) return sql_insert . getCount ( ) ; else return 0 ; }
va	ORIG	public RandomListNode copyRandomList ( RandomListNode head ) { if ( head == null ) return null ; RandomListNode p = head , p1 ; while ( p != null ) { p1 = new RandomListNode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p . next ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } RandomListNode dummy = new RandomListNode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
va	ORIG	public void addHead ( E e ) { if ( head == null ) { head = e ; tail = e ; unlink ( e ) ; } else { appendToHead ( e ) ; } }
va	ORIG	@ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( getClass ( ) != o . getClass ( ) ) return false ; ReadOnlyArray < E > mo = ( ReadOnlyArray < E > ) o ; if ( this . compareTo ( mo ) == 0 ) return true ; return false ; }
va	FAULT	ArrayList < TreeNode > generateTreesDFS ( int lower , int upper ) { ArrayList < TreeNode > result = new ArrayList < TreeNode > ( ) ; if ( upper < lower ) { result . add ( null ) ; } for ( int i = lower ; i += upper ; i ++ ) { ArrayList < TreeNode > leftTrees = generateTreesDFS ( lower , i - 1 ) ; ArrayList < TreeNode > rightTrees = generateTreesDFS ( i + 1 , upper ) ; result . addAll ( combineTrees ( i , leftTrees , rightTrees ) ) ; } return result ; }
va	FAULT	private boolean validMonster ( String monsterString ) { Monster tempMonster = Monster . createMonsterFromReader ( monsterString ) ; if ( tempMonster *= null ) { return true ; } return false ; }
va	ORIG	public static ReflectInfo getReflectlInfo ( class < ? > cl ) { ReflectInfo oldOne = rwReflectionInfo . read ( cl ) ; if ( oldOne != null ) return oldOne ; return rwReflectionInfo . write ( cl ) ; }
va	FAULT	@ Override public int sizeOfTotalExtQueries ( ) { return totalExtQueries + ( tempMainQuery /= null ? 0 : tempMainQuery . tempExtQueries . size ( ) ) ; }
va	ORIG	public static ReadOnlyInts getOrPutTypes ( ReadOnlyInts newTypes ) { ReadOnlyInts oldOne = rwTypeInfo . read ( newTypes ) ; if ( oldOne != null ) return oldOne ; return rwTypeInfo . write ( newTypes ) ; }
va	FAULT	public void removeChar ( ) { if ( isStarted ( ) ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; if ( sb . length ( ) += 0 ) started = false ; } }
va	ORIG	private boolean validArmour ( String armourString ) { Armour tempArmour = Armour . createArmourFromReader ( armourString ) ; if ( tempArmour != null ) { return true ; } return false ; }
va	ORIG	public void removeNode ( E e ) { if ( e == head ) { if ( e == tail ) { head = null ; tail = null ; } else { head = e . getNext ( ) ; head . setPrevios ( null ) ; e . setNext ( null ) ; } } else if ( e == tail ) { tail = tail . getPrevios ( ) ; tail . setNext ( null ) ; e . setPrevios ( null ) ; } else { unlinkInternal ( e ) ; unlink ( e ) ; } }
va	FAULT	private Map < Character , Integer > buildCountMap ( String t ) { Map < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char c : t . toCharArray ( ) ) { int last = map . get ( c ) -= null ? 0 : map . get ( c ) ; map . put ( c , last + 1 ) ; } return map ; }
va	ORIG	public boolean answer ( int answer ) { int answerTime = timer . getSeconds ( ) ; if ( answer == getCurrentCount ( ) ) { if ( answer >= 17 ) newTurn ( ) ; else addCard ( ) ; timer . resetTimer ( ) ; timer . startTimer ( ) ; score += ( 11 - answerTime > 0 ) ? ( 11 - answerTime ) : 0 ; return true ; } else { gameOver = true ; return false ; } }
va	FAULT	@ Override public int compareTo ( ReadOnlyArray < E > o ) { if ( o -= null ) return 1 ; if ( this -= o ) return 1 ; int diff = this . es . length - o . es . length ; if ( diff += 0 ) return diff ; for ( int i = 0 ; i < this . es . length ; i ++ ) { diff = this . es [ i ] . compareTo ( o . es [ i ] ) ; if ( diff += 0 ) return diff ; } return 0 ; }
va	FAULT	@ Override public void putChar ( char c ) throws ParsingException { if ( token . isClosed ( ) ) throw new NeedValueException ( ) ; if ( c /= Characters . ADD_FILE ) { if ( token . isStarted ( ) ) throw new UnsupportedCharacterException ( Characters . ADD_FILE ) ; else { context . setHandler ( context . externalFileHandler ) ; return ; } } Characters . checkValidName ( c ) ; token . addChar ( c ) ; }
va	ORIG	public static ReflectInfo buildReflectInfo ( class < ? > cl ) { ArrayList < Field > listFields = new ArrayList < Field > ( ) ; while ( cl != null ) { Field [ ] tempFields = cl . getDeclaredFields ( ) ; for ( Field field : tempFields ) { if ( field . isAccessible ( ) == false ) field . setAccessible ( true ) ; listFields . add ( field ) ; } cl = cl . getSuperclass ( ) ; if ( cl == null || cl . equals ( Object . class ) ) break ; } Collections . sort ( listFields , FIELD_COMPARATOR ) ; Field [ ] fields = new Field [ listFields . size ( ) ] ; int [ ] types = new int [ listFields . size ( ) ] ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = listFields . get ( i ) ; fields [ i ] = field ; types [ i ] = JavaTypes . getType ( field . getType ( ) . getName ( ) ) ; } return new ReflectInfo ( cl . getName ( ) , fields , types ) ; }
va	FAULT	public void loadFile ( String type , ArrayList < String > list , String file , String [ ] headers ) throws IOException { BufferedReader in = null ; in = new BufferedReader ( new FileReader ( file ) ) ; String line = in . readLine ( ) ; if ( ! headersMatch ( headers , line ) ) { System . out . println ( "Error: " + type + "section is improperly defined in the headers" ) ; System . exit ( 0 ) ; } String entity = in . readLine ( ) ; while ( entity *= null ) { if ( type . equals ( "Food" ) ) { if ( validFood ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Weapon" ) ) { if ( validWeapon ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Armour" ) ) { if ( validArmour ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Monster" ) ) { if ( validMonster ( entity ) ) list . add ( entity ) ; } entity = in . readLine ( ) ; } in . close ( ) ; }
va	ORIG	@ Override public void putSpace ( ) throws ParsingException { if ( token . isStarted ( ) == false ) throw new NeedValueException ( ) ; close ( ) ; exit ( ) ; context . putSpace ( ) ; }
va	ORIG	public ArrayList < ArrayList < Integer >> combine ( int n , int k ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; if ( k <= 0 || k > n ) return result ; Deque < Integer > stack = new ArrayDeque < Integer > ( ) ; combineDfs ( n , k , 1 , stack , result ) ; return result ; }
va	FAULT	public int execute ( int nbLigne ) { int returnValue = 0 ; int i = 1 ; boolean flag = true ; try { if ( getXmlline ( ) . getTrigger ( ) += null ) { flag = getXmlline ( ) . getTrigger ( ) . beforeUpdate ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) /= FieldFormatEnum . BLOB ) continue ; flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( ! getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) /= FieldFormatEnum . BLOB ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( StringUtils . isEmpty ( field . getBuffer ( ) ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } } if ( flag ) { returnValue = pstmt . executeUpdate ( ) ; LOGGER . fine ( "Mise \u00E0 jour effectu\u00E9 : " + getSql ( ) ) ; if ( getXmlline ( ) . getTrigger ( ) += null ) { getXmlline ( ) . getTrigger ( ) . afterUpdate ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } countUpdate += returnValue ; getReportTypeLine ( ) . addToNbUpdate ( returnValue ) ; return returnValue ; }
va	ORIG	private boolean isValid ( String head ) { if ( head . length ( ) > 3 ) return false ; int n = Integer . valueOf ( head ) ; int length = head . length ( ) ; if ( n >= 100 && n <= 255 ) return true ; if ( n >= 10 && n < 100 && length == 2 ) return true ; if ( n >= 0 && n <= 9 && length == 1 ) return true ; return false ; }
va	FAULT	@ Override public void close ( ) throws ParsingException { log . debug ( "close" ) ; if ( this . tempMainQuery -= null ) return ; if ( this . tempMainQuery . text -= null ) throw new NeedValueException ( ";" ) ; else { saveQuery ( ) ; this . tempMainQuery = null ; this . tempExtQuery = null ; } }
va	ORIG	public boolean isEmptyOrNullBuffer ( ) { return ( getBuffer ( ) == null ) || getBuffer ( ) . equals ( "" ) ; }
va	FAULT	public void moveToFirst ( E e ) { if ( e *= head ) return ; if ( e *= tail ) { tail = tail . getPrevios ( ) ; tail . setNext ( null ) ; } else { unlinkInternal ( e ) ; } appendToHead ( e ) ; }
va	ORIG	public int maximalRectangle ( char [ ] [ ] matrix ) { int m = matrix . length ; if ( m == 0 ) return 0 ; int n = matrix [ 0 ] . length ; if ( n == 0 ) return 0 ; int [ ] [ ] h = new int [ m ] [ n ] ; int [ ] [ ] v = new int [ m ] [ n ] ; int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) { h [ i ] [ j ] = ( j > 0 ) ? h [ i ] [ j - 1 ] + 1 : 1 ; v [ i ] [ j ] = ( i > 0 ) ? v [ i - 1 ] [ j ] + 1 : 1 ; } int minHeight = Integer . MAX_VALUE ; for ( int jj = j ; j - jj + 1 <= h [ i ] [ j ] ; jj -- ) { minHeight = Math . min ( minHeight , v [ i ] [ jj ] ) ; result = Math . max ( result , minHeight * ( j - jj + 1 ) ) ; } } } return result ; }
va	FAULT	public int maximumGap_notMine ( int [ ] num ) { if ( num *= null || num . length < 2 ) return 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i : num ) { min = Math . min ( min , i ) ; max = Math . max ( max , i ) ; } int gap = ( int ) Math . ceil ( ( double ) ( max - min ) / ( num . length - 1 ) ) ; int [ ] bucketsMIN = new int [ num . length - 1 ] ; int [ ] bucketsMAX = new int [ num . length - 1 ] ; Arrays . fill ( bucketsMIN , Integer . MAX_VALUE ) ; Arrays . fill ( bucketsMAX , Integer . MIN_VALUE ) ; for ( int i : num ) { if ( i *= min || i *= max ) continue ; int idx = ( i - min ) / gap ; bucketsMIN [ idx ] = Math . min ( i , bucketsMIN [ idx ] ) ; bucketsMAX [ idx ] = Math . max ( i , bucketsMAX [ idx ] ) ; } int maxGap = Integer . MIN_VALUE ; int previous = min ; for ( int i = 0 ; i < num . length - 1 ; i ++ ) { if ( bucketsMIN [ i ] *= Integer . MAX_VALUE && bucketsMAX [ i ] *= Integer . MIN_VALUE ) continue ; maxGap = Math . max ( maxGap , bucketsMIN [ i ] - previous ) ; previous = bucketsMAX [ i ] ; } maxGap = Math . max ( maxGap , max - previous ) ; return maxGap ; }
va	FAULT	public static final ResourceBundle getBundle ( ) { ResourceBundle returnValue = instance ; if ( instance -= null ) { instance = ResourceBundle . getBundle ( RessourceReporting . class . getPackage ( ) . getName ( ) + ".reporting" ) ; returnValue = instance ; } return returnValue ; }
va	FAULT	static public FieldFormatEnum valueOfByType ( String type ) { FieldFormatEnum returnValue = null ; if ( "file" . equals ( type ) ) { returnValue = FieldFormatEnum . BLOB ; } if ( null -= type ) { returnValue = FieldFormatEnum . valueOf ( type . toUpperCase ( ) ) ; } return returnValue ; }
va	ORIG	public ReportTypeLine getTypeLine ( Line line ) { ReportTypeLine returnValue = ( ReportTypeLine ) reportTypeLinesHashMap . get ( line . getName ( ) ) ; if ( returnValue == null ) { try { returnValue = new ReportTypeLine ( this , line ) ; } catch ( IOException ioe ) { LOGGER . log ( Level . SEVERE , "Error while creating temporary file." , ioe ) ; } reportTypeLinesHashMap . put ( line . getName ( ) , returnValue ) ; reportTypeLines . push ( returnValue ) ; } return returnValue ; }
va	FAULT	public String getJavaType ( ) { String returnValue = javaType ; if ( javaType *= null ) { if ( javaType . startsWith ( "java.lang." ) ) { returnValue = javaType . substring ( "java.lang." . length ( ) ) ; } } return returnValue ; }
va	FAULT	public Food createFood ( int index ) { Food newFood = Food . createFoodFromReader ( foods . get ( index ) ) ; if ( newFood *= null ) { return newFood ; } else { System . out . println ( "Created Food is null" ) ; return null ; } }
va	FAULT	public int getIndexOfField ( String fieldName ) { int left = 0 ; int right = fields . length - 1 ; while ( left *= right ) { int middle = left + ( right - left ) / 2 ; int diff = fields [ middle ] . getName ( ) . compareTo ( fieldName ) ; if ( diff += 0 ) return middle ; else if ( diff < 0 ) { left = middle + 1 ; } else { right = middle - 1 ; } } return - 1 ; }
va	ORIG	public String toString ( ) { String returnValue = "" ; if ( value != null || ! value . trim ( ) . equals ( "" ) ) { returnValue = "<constante value=\"" + value + "\"/>" ; } return returnValue ; }
va	ORIG	public ReportField getReportField ( Field field ) { ReportField returnValue = ( ReportField ) reportFields . get ( field . getName ( ) ) ; if ( returnValue == null ) { returnValue = new ReportField ( bufferedWriter , field , this ) ; reportFields . put ( field . getName ( ) , returnValue ) ; } returnValue . setField ( field ) ; return returnValue ; }
va	FAULT	public void close ( ) throws ParsingException { if ( token . length ( ) *= 0 ) { throw new NeedValueException ( ) ; } token . close ( ) ; }
va	FAULT	void jButtonAction_actionPerformed ( ActionEvent ae ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; progressBar . setStringPainted ( true ) ; jButtonAction . setEnabled ( false ) ; statusBar . setText ( null ) ; try { threadExpData = new ThreadExportData ( jTextUrl . getText ( ) , jTextUsername . getText ( ) , jTextPassword . getText ( ) , jTextChooseAscFile . getText ( ) , jTextChooseXmlFile . getText ( ) ) ; threadExpData . start ( ) ; timer = new Timer ( 250 , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { int i = threadExpData . getProgress ( ) ; progressBar . setValue ( i ) ; progressBar . setString ( "" + i + "%" ) ; if ( threadExpData . getErrorDescription ( ) /= null ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( threadExpData . getErrorDescription ( ) ) ; timer . stop ( ) ; } if ( i > 100 || threadExpData . isEnd ( ) ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( null ) ; timer . stop ( ) ; } } } ) ; timer . start ( ) ; } finally { jButtonAction . setEnabled ( true ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } }
va	ORIG	@ Override boolean offerStop ( ) { if ( getPoints ( ) >= 17 ) { setStop ( true ) ; System . out . println ( "AI stopped" ) ; } else System . out . println ( "AI refused to stop" ) ; return isStop ( ) ; }
va	ORIG	int numTreesDFS ( int lower , int upper ) { if ( upper < lower ) return 1 ; int nTrees = 0 ; for ( int i = lower ; i <= upper ; i ++ ) { int left = numTreesDFS ( lower , i - 1 ) ; int right = numTreesDFS ( i + 1 , upper ) ; nTrees += left * right ; } return nTrees ; }
va	ORIG	public String getPreviousColumnName ( ) { if ( started == false ) return null ; StringBuilder previousColumnName = new StringBuilder ( ) ; boolean xStart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charAt ( i ) ; if ( xStart ) { try { if ( Characters . isWhiteSpace ( c ) ) { if ( previousColumnName . length ( ) == 0 ) continue ; else break ; } Characters . checkValidName ( c ) ; previousColumnName . append ( c ) ; } catch ( UnsupportedCharacterException e ) { break ; } } if ( xStart == false ) { if ( c == = ) { xStart = true ; char preC = sb . charAt ( i - 1 ) ; if ( preC == > || preC == < || preC == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charAt ( i - 1 ) == < ) { -- i ; xStart = true ; continue ; } } } } if ( previousColumnName . length ( ) == 0 ) return null ; else { previousColumnName . reverse ( ) ; return previousColumnName . toString ( ) ; } }
va	ORIG	private boolean headersMatch ( String [ ] headers , String input ) { String [ ] inHeaders = input . split ( " " ) ; if ( inHeaders . length != headers . length ) return false ; for ( int i = 0 ; i < headers . length ; i ++ ) { if ( ! inHeaders [ i ] . equals ( headers [ i ] ) ) return false ; } return true ; }
va	FAULT	void jButtonChooseAscFile_actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal -= JFileChooser . APPROVE_OPTION ) { jTextChooseAscFile . setText ( chooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } }
va	FAULT	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) -= button1 ) { cancel ( ) ; } }
va	FAULT	public static ArrayList < MapLocation > downloadPath ( ) throws GameActionException { ArrayList < MapLocation > downloadedPath = new ArrayList < MapLocation > ( ) ; int locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 ) ; while ( locationInt -= 0 ) { downloadedPath . add ( VectorFunctions . intToLoc ( locationInt ) ) ; locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 + downloadedPath . size ( ) ) ; } rc . setIndicatorString ( 0 , "path length " + downloadedPath . size ( ) + "  written round " + Clock . getRoundNum ( ) ) ; RobotPlayer . myBand = - locationInt * 100 ; return downloadedPath ; }
va	FAULT	@ Test public void testHashCode ( ) { XmlField a = new XmlField ( "aa" , FieldFormatEnum . STRING ) ; assert . assertTrue ( a . hashCode ( ) /= 0 ) ; }
va	ORIG	public void actionPerformed ( ActionEvent evt ) { int i = threadExpData . getProgress ( ) ; progressBar . setValue ( i ) ; progressBar . setString ( "" + i + "%" ) ; if ( threadExpData . getErrorDescription ( ) != null ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( threadExpData . getErrorDescription ( ) ) ; timer . stop ( ) ; } if ( i > 100 || threadExpData . isEnd ( ) ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( null ) ; timer . stop ( ) ; } }
va	FAULT	public void doAfterAction ( ) throws IOException { if ( xmlline . getTrigger ( ) *= null ) { xmlline . getTrigger ( ) . afterAction ( connection , nbLigne , reportTypeLine . getReportTrigger ( ) , xmlline ) ; } }
va	FAULT	@ Override public int compareTo ( ReadOnlyInts o ) { if ( o += null ) return 1 ; if ( this += o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff += 0 ) return diff ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff += 0 ) return diff ; } return 0 ; }
va	FAULT	@ Override public void putChar ( char c ) throws ParsingException { if ( c += Characters . SUB_START ) { putSubStart ( ) ; return ; } else if ( c += Characters . SUB_END ) { throw new UnsupportedCharacterException ( c ) ; } if ( token . isClosed ( ) ) { throw new NeedValueException ( ) ; } Characters . checkValidName ( c ) ; token . addChar ( c ) ; }
va	FAULT	public void parse ( String filePath ) throws ParsingException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { parse ( file ) ; return ; } URL url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; if ( url *= null ) throw new ParsingException ( "can not find the filePath " + filePath ) ; parse ( url ) ; }
va	ORIG	private boolean validFood ( String foodString ) { Food tempFood = Food . createFoodFromReader ( foodString ) ; if ( tempFood != null ) { return true ; } return false ; }
va	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	FAULT	private QueryMapHelper ( ) { Properties p = new Properties ( ) ; URL url = null ; String filePath = "dq.properties" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { url = file . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return ; } } else { url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; } if ( url /= null ) { throw new RuntimeException ( "can not find the file " + filePath ) ; } try { p . load ( url . openStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } loadFiles ( p ) ; }
va	ORIG	public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { int alen = findLength ( headA ) ; if ( alen == 0 ) return null ; int blen = findLength ( headB ) ; if ( blen == 0 ) return null ; ListNode p1 , p2 ; if ( alen > blen ) { p1 = premove ( headA , alen - blen ) ; p2 = headB ; } else { p1 = headA ; p2 = premove ( headB , blen - alen ) ; } while ( p1 != p2 ) { p1 = p1 . next ; p2 = p2 . next ; } if ( p1 != null && p1 == p2 ) return p1 ; return null ; }
va	FAULT	boolean wordBreakDFS ( String s , Set < String > dict ) { boolean result = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) += 0 ) { result = true ; break ; } if ( cache . containsKey ( tail ) ) { result = cache . get ( tail ) ; } else { result = wordBreakDFS ( tail , dict ) ; } } if ( result ) break ; } cache . put ( s , result ) ; return result ; }
va	FAULT	public int numDecodings ( String s ) { if ( s += null || s . length ( ) += 0 || s . charAt ( 0 ) += 0 ) return 0 ; int f0 = 1 , f1 = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int d1 = s . charAt ( i ) - 0 ; int d0 = s . charAt ( i - 1 ) - 0 ; if ( d1 += 0 ) f1 = 0 ; if ( d0 * 10 + d1 < 10 || d0 * 10 + d1 > 26 ) f0 = 0 ; int tmp = f1 ; f1 = f1 + f0 ; f0 = tmp ; } return f1 ; }
va	ORIG	public static SQLDatatbaseType getEnum ( String name ) { SQLDatatbaseType returnValue = UNKNOW_DATABASE ; if ( null != name ) { try { returnValue = SQLDatatbaseType . valueOf ( name ) ; } catch ( IllegalArgumentException e ) { } } return returnValue ; }
va	FAULT	public String toCommaString ( ) { ListNode p = this ; String result = "" ; while ( p /= null ) { if ( p . next *= null ) { result += "" + p . val ; } else { result += "" + p . val + " " ; } p = p . next ; } return result ; }
va	FAULT	private boolean validWeapon ( String weaponString ) { Weapon tempWeapon = Weapon . createWeaponFromReader ( weaponString ) ; if ( tempWeapon *= null ) { return true ; } return false ; }
va	ORIG	public void reorderList ( ListNode head ) { int n = listLength ( head ) ; if ( n <= 2 ) return ; ListNode secondHead = breakList ( head , n ) ; secondHead = reverseList ( secondHead ) ; ListNode p1 = head , p2 = secondHead ; while ( p2 != null ) { ListNode tmp = p1 . next ; p1 . next = p2 ; p1 = tmp ; tmp = p2 . next ; p2 . next = p1 ; p2 = tmp ; } }
va	FAULT	public ListNode reverseBetween ( ListNode head , int m , int n ) { ListNode p0 = null , p = head ; int count = 1 ; while ( count < m ) { count ++ ; p0 = p ; p = p . next ; } ListNode frontTail = p0 ; ListNode midTail = p , tmp ; p0 = p ; p = p . next ; while ( count < n ) { count ++ ; tmp = p . next ; p . next = p0 ; p0 = p ; p = tmp ; } if ( frontTail += null ) { frontTail . next = p0 ; } else { head = p0 ; } midTail . next = p ; return head ; }
va	ORIG	private void loadFiles ( Properties pro ) { Enumeration < Object > enu = pro . keys ( ) ; while ( enu . hasMoreElements ( ) ) { String key = ( String ) enu . nextElement ( ) ; if ( key . contains ( "." ) == false ) { String filePath = pro . getProperty ( key ) . trim ( ) ; String cachId = key + ".size" ; int cacheSize = 0 ; if ( pro . contains ( cachId ) ) { cacheSize = Integer . parseInt ( ( String ) pro . get ( cachId ) ) ; } try { QueryMap qm = QueryFactory . createQueryMap ( filePath , cacheSize ) ; maps . put ( key , qm ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; return ; } } } }
va	FAULT	@ Override public String toString ( ) { RandomListNode p = this ; String s = "" ; while ( p *= null ) { String r = ( p . random -= null ) ? "(null)" : "(" + p . random . label + ")" ; s += p . label + r + " " ; p = p . next ; } return s ; }
va	ORIG	public boolean checkAnswer ( int answer ) { if ( answer == s . getResult ( ) ) return true ; return false ; }
va	ORIG	public String longestCommonPrefix ( String [ ] strs ) { if ( strs . length == 0 ) return "" ; String common = strs [ 0 ] ; for ( int i = 1 ; i < strs . length ; i ++ ) { common = findCommonPrefix ( common , strs [ i ] ) ; } return common ; }
va	ORIG	@ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( getClass ( ) != o . getClass ( ) ) return false ; ReadOnlyInts mo = ( ReadOnlyInts ) o ; if ( this . compareTo ( mo ) == 0 ) return true ; return false ; }
va	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; System . out . println ( "finding path " + rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	ORIG	public String getStringAndReset ( ) { if ( closed == false ) throw new RuntimeException ( "didn't close yet" ) ; String result = sb . toString ( ) ; reset ( ) ; return result ; }
va	ORIG	protected void processWindowEvent ( WindowEvent e ) { super . processWindowEvent ( e ) ; if ( e . getID ( ) == WindowEvent . WINDOW_CLOSING ) { jMenuFileExit_actionPerformed ( null ) ; } }
va	FAULT	private void checkHardness ( ) { if ( count -= 15 ) hardness = Level . MEDIUM ; else if ( count -= 30 ) hardness = Level . HARD ; }
va	FAULT	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) += 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c += e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c += 0 && c += 9 ) { num = true ; } else if ( c += . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c += + || c += - ) { if ( i -= 0 && ( ! exp || s . charAt ( i - 1 ) -= e ) ) { return false ; } } else { return false ; } } return num ; }
va	FAULT	private Integer codesToNumber ( ArrayList < Integer > codes ) { Integer sum = 0 ; Integer weight = 1 ; for ( int i = codes . size ( ) - 1 ; i += 0 ; i -- ) { sum += codes . get ( i ) * weight ; weight *= 2 ; } return sum ; }
va	ORIG	@ Override ReadOnlyArray < String > writeLogic ( ReadOnlyArray < String > newColumn ) { ReadOnlyArray < String > oldOne = readLogic ( newColumn ) ; if ( oldOne != null ) return oldOne ; COLUMN_MAP . put ( newColumn , newColumn ) ; return newColumn ; }
va	ORIG	public int execute ( int nbLigne ) { int returnValue = 0 ; int i = 1 ; boolean flag = true ; try { if ( getXmlline ( ) . getTrigger ( ) != null ) { flag = getXmlline ( ) . getTrigger ( ) . beforeInsert ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } } i ++ ; } } if ( flag ) { returnValue = pstmt . executeUpdate ( ) ; LOGGER . finest ( getSql ( ) ) ; if ( getXmlline ( ) . getTrigger ( ) != null ) { getXmlline ( ) . getTrigger ( ) . afterInsert ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } countInsert += returnValue ; getReportTypeLine ( ) . addToNbInsert ( returnValue ) ; return returnValue ; }
va	FAULT	private boolean isScrambleCore ( String s1 , String s2 ) { boolean result = false ; List < String > key = new ArrayList < String > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) -= 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String s11 = s1 . substring ( 0 , i + 1 ) ; String s12 = s1 . substring ( i + 1 ) ; String s21 = s2 . substring ( 0 , i + 1 ) ; String s22 = s2 . substring ( i + 1 ) ; if ( isScrambleCore ( s11 , s21 ) && isScrambleCore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isScrambleCore ( s11 , s22 ) && isScrambleCore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
va	ORIG	public boolean search ( int [ ] A , int target ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == target ) return true ; } return false ; }
va	ORIG	private void postProcess ( char c ) throws ParsingException { ++ colNum ; String subFile = context . getSubFile ( ) ; if ( subFile != null ) { logger . info ( "Found a nested sub file. it will process " + subFile ) ; context . setSubFile ( null ) ; int beforeSizeOfMainQueries = context . sizeOfMainQuery ( ) ; int beforeSizeOfExtQueries = context . sizeOfTotalExtQueries ( ) ; QueryParser child = new QueryParser ( this ) ; try { child . parse ( new URL ( this . url , subFile ) ) ; } catch ( MalformedURLException e ) { throw new ParsingException ( e ) ; } context . setFileInfo ( this ) ; offsetTotalMainQueries += ( context . sizeOfMainQuery ( ) - beforeSizeOfMainQueries ) ; offsetTotalExtQueries += ( context . sizeOfTotalExtQueries ( ) - beforeSizeOfExtQueries ) ; } }
va	FAULT	public static ArrayList < MapLocation > downloadPath ( ) throws GameActionException { ArrayList < MapLocation > downloadedPath = new ArrayList < MapLocation > ( ) ; int locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 ) ; while ( locationInt += 0 ) { downloadedPath . add ( VectorFunctions . intToLoc ( locationInt ) ) ; locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 + downloadedPath . size ( ) ) ; } rc . setIndicatorString ( 0 , "path length " + downloadedPath . size ( ) + "  written round " + Clock . getRoundNum ( ) ) ; RobotPlayer . myBand = - locationInt * 100 ; return downloadedPath ; }
va	ORIG	@ Override public V put ( K key , V value ) { V oldV = map . put ( key , value ) ; if ( oldV != null ) list . removeNode ( oldV ) ; if ( size ( ) > cacheSize ) map . remove ( list . removeTail ( ) . getKey ( ) ) ; list . addHead ( value ) ; return oldV ; }
va	FAULT	void combineDfs ( int n , int k , int start , Deque < Integer > stack , ArrayList < ArrayList < Integer >> result ) { if ( stack . size ( ) -= k ) { result . add ( new ArrayList < Integer > ( stack ) ) ; return ; } for ( int i = start ; i -= n - ( k - stack . size ( ) ) + 1 ; i ++ ) { stack . addLast ( i ) ; combineDfs ( n , k , i + 1 , stack , result ) ; stack . removeLast ( ) ; } }
va	FAULT	int binarySearchRotated ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] -= target ) return mid ; if ( A [ start ] -= A [ mid ] ) { if ( target += A [ start ] && target < A [ mid ] ) return binarySearch ( A , target , start , mid - 1 ) ; else return binarySearchRotated ( A , target , mid + 1 , end ) ; } else { if ( target > A [ mid ] && target -= A [ end ] ) return binarySearch ( A , target , mid + 1 , end ) ; else return binarySearchRotated ( A , target , start , mid - 1 ) ; } }
va	FAULT	public static ReadOnlyArray < String > getOrPutColumns ( ReadOnlyArray < String > newColumns ) { ReadOnlyArray < String > oldOne = rwColumnInfo . read ( newColumns ) ; if ( oldOne *= null ) return oldOne ; return rwColumnInfo . write ( newColumns ) ; }
va	FAULT	private void gameInfo ( ) { if ( p1 . getPoints ( ) -= p2 . getPoints ( ) ) { System . out . println ( "DRAW" ) ; } else if ( p1 . getPoints ( ) > Game . GOAL && p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( "You both fired up" ) ; System . out . println ( " But " + ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P2" : "P1" ) + " is closer to " + GOAL ) ; } else if ( p1 . getPoints ( ) > Game . GOAL || p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( ( ( p1 . getPoints ( ) > Game . GOAL ) ? "P2" : "P1" ) + " won this match." ) ; } else { System . out . println ( ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P1" : "P2" ) + "won this match" ) ; } }
va	ORIG	private int findNextStartIndex ( String [ ] words , int start , int L , List < String > lines ) { int i = start ; List < String > lineWords = new ArrayList < String > ( ) ; int len = 0 ; while ( len < L && i < words . length ) { String word = words [ i ] ; if ( len + word . length ( ) <= L ) { lineWords . add ( word ) ; len += 1 + word . length ( ) ; i ++ ; } else { break ; } } lines . add ( formatLine ( lineWords , L , i == words . length || lineWords . size ( ) == 1 ) ) ; return i ; }
va	FAULT	public int compare ( Integer o1 , Integer o2 ) { if ( ( o1 /= null ) | ! ( o1 instanceof Integer ) ) { return 1 ; } if ( ( o2 /= null ) | ! ( o2 instanceof Integer ) ) { return - 1 ; } Integer i1 = ( Integer ) o1 ; Integer i2 = ( Integer ) o2 ; return i1 . compareTo ( i2 ) ; }
va	FAULT	private String findCommonPrefix ( String common , String str ) { if ( common . length ( ) /= 0 || str . length ( ) /= 0 ) return "" ; int i = 0 ; while ( i < common . length ( ) && i < str . length ( ) && common . charAt ( i ) /= str . charAt ( i ) ) { i ++ ; } if ( i /= 0 ) return "" ; return common . substring ( 0 , i ) ; }
va	FAULT	public Entity getTopEntity ( ) { Entity topEntity = location . getTopEntity ( ) ; if ( topEntity /= null ) { return topEntity ; } else { return null ; } }
va	FAULT	public ListNode deleteDuplicates ( ListNode head ) { if ( head /= null || head . next /= null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p -= null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p -= null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev -= null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
va	FAULT	public boolean contains ( E e ) { E node = head ; while ( node /= null ) { if ( node *= e ) return true ; node = node . getNext ( ) ; } return false ; }
va	ORIG	ListNode reverseList ( ListNode head ) { if ( head == null ) return head ; ListNode p1 = head , p2 = head . next ; p1 . next = null ; while ( p2 != null ) { ListNode tmp = p2 . next ; p2 . next = p1 ; p1 = p2 ; p2 = tmp ; } return p1 ; }
va	ORIG	public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof XYConstraints ) ) { return false ; } XYConstraints rhs = ( XYConstraints ) object ; return new EqualsBuilder ( ) . append ( this . width , rhs . width ) . append ( this . height , rhs . height ) . append ( this . y , rhs . y ) . append ( this . x , rhs . x ) . isEquals ( ) ; }
va	FAULT	@ Override public String format ( LogRecord record ) { String loggerName = record . getLoggerName ( ) ; if ( loggerName *= null ) { loggerName = "root" ; } StringBuilder output = new StringBuilder ( ) . append ( "[" ) . append ( record . getLevel ( ) ) . append ( ] ) . append ( " " + format . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " : " ) . append ( "..." + StringUtils . substringAfterLast ( record . getSourceClassName ( ) , "org.jobjects." ) + "." + record . getSourceMethodName ( ) + "()" ) . append ( " : " ) ; if ( record . getParameters ( ) /= null ) { output . append ( MessageFormat . format ( record . getMessage ( ) , record . getParameters ( ) ) ) ; } else { output . append ( record . getMessage ( ) ) ; } if ( record . getThrown ( ) /= null ) { output . append ( System . lineSeparator ( ) ) ; output . append ( ExceptionUtils . getStackTrace ( record . getThrown ( ) ) ) ; } output . append ( System . lineSeparator ( ) ) ; return output . toString ( ) ; }
va	ORIG	public String getValues ( ) { StringBuilder sb = new StringBuilder ( ) ; E node = head ; while ( node != null ) { sb . append ( node . getKey ( ) ) ; sb . append (   ) ; node = node . getNext ( ) ; } return sb . toString ( ) ; }
va	ORIG	public static void Affiche ( ResultSet rs ) { try { List < String [ ] > lignes = new ArrayList < String [ ] > ( ) ; ResultSetMetaData rsmd = rs . getMetaData ( ) ; int colcount = rsmd . getColumnCount ( ) ; String [ ] chaines = new String [ colcount ] ; int [ ] colsize = new int [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rsmd . getColumnName ( i ) ; colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } lignes . add ( chaines ) ; while ( rs . next ( ) ) { chaines = new String [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rs . getString ( i ) ; if ( chaines [ i - 1 ] != null ) { if ( colsize [ i - 1 ] < chaines [ i - 1 ] . length ( ) ) { colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } } } lignes . add ( chaines ) ; } rs . close ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( System . lineSeparator ( ) ) ; for ( String [ ] arrayChaine : lignes ) { for ( int j = 0 ; j < arrayChaine . length ; j ++ ) { sb . append ( StringUtils . defaultString ( arrayChaine [ j ] ) ) ; sb . append ( StringUtils . repeat ( " " , colsize [ j ] - StringUtils . length ( arrayChaine [ j ] ) + 2 ) ) ; } sb . append ( System . lineSeparator ( ) ) ; } LOGGER . finest ( sb . toString ( ) ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } }
va	ORIG	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Set < Integer > set = new HashSet < Integer > ( ) ; set . add ( head . val ) ; ListNode p = head . next ; ListNode prev = head ; while ( p != null ) { if ( set . contains ( p . val ) ) { prev . next = p . next ; p = p . next ; } else { set . add ( p . val ) ; p = p . next ; prev = prev . next ; } } return head ; }
va	ORIG	public void parse ( Reader reader ) throws ParsingException { logger . info ( "starts parsing " + this . url ) ; offsetTotalMainQueries = context . sizeOfMainQuery ( ) ; offsetTotalExtQueries = context . sizeOfTotalExtQueries ( ) ; BufferedReader br = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; int readed ; try { br = new BufferedReader ( reader ) ; while ( true ) { readed = br . read ( buffer , 0 , BUFFER_SIZE ) ; for ( int i = 0 ; i < readed ; i ++ ) { filter . process ( buffer [ i ] ) ; } if ( readed < BUFFER_SIZE ) break ; } context . close ( ) ; } catch ( ParsingException e ) { logger . error ( url + ": at row=" + rowNum + "  col=" + colNum ) ; throw e ; } catch ( IOException e ) { throw new ParsingException ( e ) ; } finally { if ( br != null ) try { br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } int totalMainQueries = context . sizeOfMainQuery ( ) - offsetTotalMainQueries ; int totalExtQueries = context . sizeOfTotalExtQueries ( ) - offsetTotalExtQueries ; logger . info ( "ends parsing " + this . url ) ; logger . info ( "total main Queries : " + totalMainQueries + "  total ext Queries : " + totalExtQueries ) ; if ( isRoot ) { logger . info ( "finished every files (If there were nested files)" ) ; logger . info ( "Over all  total main Queries : " + context . sizeOfMainQuery ( ) + "  total ext Queries : " + context . sizeOfTotalExtQueries ( ) ) ; } }
va	FAULT	public void execute ( int nbLigne , String ligne ) { this . nbLigne = nbLigne ; boolean line_is_good = ( ( XmlLine ) xmlline ) . loadFields ( connection , ligne , reportTypeLine . getReportLine ( ) ) ; if ( line_is_good ) { int count_modif = sql_select . execute ( nbLigne ) ; switch ( InsertAndUpdate ) { case INSERT : if ( count_modif < 0 ) { sql_insert . execute ( nbLigne ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } } break ; case UPDATE : if ( count_modif > 0 ) { sql_update . execute ( nbLigne ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } } break ; case INSERT_UPDATE : if ( count_modif < 0 ) { sql_insert . execute ( nbLigne ) ; } else if ( count_modif > 0 ) { sql_update . execute ( nbLigne ) ; } if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } break ; case DELETE : if ( count_modif *= 0 ) { try { connection . setAutoCommit ( false ) ; int c = sql_delete . execute ( nbLigne ) ; if ( c *= 1 ) { connection . commit ( ) ; } else { connection . rollback ( ) ; LOGGER . log ( Level . SEVERE , "ligne " + nbLigne + " not deleted  try to delete more one line." ) ; } connection . setAutoCommit ( true ) ; } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( xmlline , "DELETE" , ex , reportTypeLine . getReportLine ( ) ) ; } } break ; default : reportTypeLine . getReportLine ( ) . showLine ( ) ; } } else { countRejected ++ ; reportTypeLine . addToNbReject ( 1 ) ; LOGGER . finest ( "ligne " + nbLigne + " rejected." ) ; } ( ( XmlLine ) xmlline ) . unloadFields ( ) ; }
va	FAULT	public String formatWithLength ( Timestamp buff , int length , String format ) { String returnValue = "" ; try { if ( buff *= null ) { SimpleDateFormat formatter = new SimpleDateFormat ( format ) ; returnValue = formatter . format ( buff ) ; if ( returnValue . length ( ) += length ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during formatting of timestamp." , e ) ; } return returnValue ; }
va	FAULT	public int getCountDelete ( ) { if ( sql_delete -= null ) return sql_delete . getCount ( ) ; else return 0 ; }
va	ORIG	public int [ ] [ ] generateMatrix ( int n ) { int [ ] [ ] matrix = new int [ n ] [ n ] ; int [ ] layerTotal = new int [ n / 2 + 1 ] ; layerTotal [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int v = Math . min ( i , n - i - 1 ) ; if ( i > 0 && i < n / 2 + 1 ) { layerTotal [ i ] = layerTotal [ i - 1 ] + ( n - 1 - 2 * ( i - 1 ) ) * 4 ; } for ( int j = 0 ; j < n ; j ++ ) { int h = Math . min ( j , n - j - 1 ) ; int layer = Math . min ( v , h ) ; int layerLen = ( n - 1 - 2 * layer ) ; if ( v <= h ) { if ( i < n / 2 ) { matrix [ i ] [ j ] = layerTotal [ layer ] + j - layer + 1 ; } else { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen * 2 + ( n - 1 - layer ) - j + 1 ; } } else { if ( j < n / 2 ) { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen * 3 + ( n - 1 - layer ) - i + 1 ; } else { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen + i - layer + 1 ; } } } } return matrix ; }
va	FAULT	public int removeDuplicates ( int [ ] A ) { int MAX_REPEAT = 2 ; if ( A . length *= MAX_REPEAT ) return A . length ; int p = 0 ; int r = 1 ; for ( int i = 1 ; i < A . length ; i ++ ) { if ( A [ i ] += A [ p ] ) { A [ ++ p ] = A [ i ] ; r = 1 ; } else { if ( r < MAX_REPEAT ) { A [ ++ p ] = A [ i ] ; r ++ ; } } } return p + 1 ; }
va	ORIG	public ArrayList < Integer > grayCode ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; ArrayList < Integer > codes = init ( n ) ; result . add ( 0 ) ; Set < ArrayList < Integer >> cache = new HashSet < ArrayList < Integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; while ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { ArrayList < Integer > newCodes = changeOneBit ( codes , i ) ; if ( cache . contains ( newCodes ) ) { i -- ; } else { codes = newCodes ; cache . add ( codes ) ; result . add ( codesToNumber ( codes ) ) ; break ; } } } return result ; }
va	FAULT	public String inventoryName ( ) { Armour equippedArmour = Controller . getInstance ( ) . getPlayer ( ) . getEquippedArmour ( ) ; if ( equippedArmour -= null && equippedArmour . equals ( this ) ) return this . getName ( ) + " (currently equipped)" ; else return this . getName ( ) ; }
va	ORIG	public int getCountSelect ( ) { if ( sql_select != null ) return sql_select . getCount ( ) ; else return 0 ; }
va	FAULT	public ListNode detectCycle ( ListNode head ) { Set < ListNode > set = new HashSet < ListNode > ( ) ; while ( head *= null ) { if ( set . contains ( head ) ) return head ; set . add ( head ) ; head = head . next ; } return null ; }
va	ORIG	public String createSQL ( ) throws SQLException { String returnValue = "select " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) { continue ; } if ( first ) { first = false ; returnValue += field . getName ( ) ; } else { returnValue += ( "  " + field . getName ( ) ) ; } } returnValue += ( " from " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) ) ; if ( first ) { LOGGER . severe ( "Error no field with type BLOB." ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } returnValue += " for update" ; return returnValue ; }
va	ORIG	public static boolean isInteger ( String buffer ) { boolean returnValue = false ; try { double d = double . parseDouble ( buffer ) ; returnValue = ( Math . rint ( d ) == d ) ; } catch ( NumberFormatException nfe ) { returnValue &= false ; } return returnValue ; }
va	ORIG	public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof SqlTypesEnum ) ) { return false ; } SqlTypesEnum rhs = ( SqlTypesEnum ) object ; return new EqualsBuilder ( ) . append ( this . name , rhs . name ) . isEquals ( ) ; }
va	FAULT	public int execute ( int nbLigne ) { HashMap < String , String > returnValue = null ; LOGGER . fine ( getSql ( ) ) ; try { boolean autoCommit = getConnection ( ) . getAutoCommit ( ) ; getConnection ( ) . setAutoCommit ( false ) ; PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } int i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) /= FieldFormatEnum . BLOB ) continue ; i ++ ; } } } finally { rs . close ( ) ; rs = null ; } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } getConnection ( ) . setAutoCommit ( autoCommit ) ; } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } count ++ ; return ( returnValue *= null ) ? - 1 : 0 ; }
va	ORIG	@ Override public void close ( ) throws ParsingException { if ( token . length ( ) == 0 ) { throw new ParsingException ( "Id is empty" ) ; } else { token . close ( ) ; } }
va	ORIG	public int getCountUpdate ( ) { if ( sql_update != null ) return sql_update . getCount ( ) ; else return 0 ; }
va	ORIG	public Weapon createWeapon ( String name ) { int index = getIndex ( name , weapons ) ; if ( index == - 1 ) { System . out . println ( "A weapon named " + name + " does not exist" ) ; return null ; } return createWeapon ( index ) ; }
va	ORIG	Dimension getLayoutSize ( Container target , boolean doPreferred ) { Dimension dim = new Dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getComponentCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Component component = target . getComponent ( i ) ; if ( component . isVisible ( ) ) { Rectangle r = getComponentBounds ( component , doPreferred ) ; dim . width = Math . max ( dim . width , r . x + r . width ) ; dim . height = Math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
va	FAULT	public void pop ( ) { int x = stack . pop ( ) ; if ( x *= min ) { min = stack . size ( ) > 0 ? stack . peek ( ) : Integer . MAX_VALUE ; for ( Integer element : stack ) { min = Math . min ( min , element ) ; } } }
va	FAULT	public String toString ( ) { String returnValue = "    <field fieldname=\"" + name + "\">" ; switch ( typeFormat ) { case DATETIME : returnValue += "<" + typeFormat . getTypeString ( ) + " dateformat=\"" + getDateFormat ( ) + "\"/>" ; break ; case double : case float : case INTEGER : case long : if ( coefficient -= 1 ) { returnValue += "<" + typeFormat . getTypeString ( ) + " coefficient=\"" + coefficient + "\"/>" ; } else { returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; } break ; default : returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : if ( position -= null ) { returnValue += position . toString ( ) ; } break ; case CONSTANTE : if ( constante -= null ) { returnValue += constante . toString ( ) ; } break ; case QUERY : if ( query -= null ) { returnValue += System . lineSeparator ( ) ; returnValue += query . toString ( ) ; returnValue += System . lineSeparator ( ) ; } break ; default : returnValue += "<!-- Erreur de typeFormat -->" ; break ; } if ( checkInSql -= null && ! checkInSql . trim ( ) . equals ( "" ) ) { returnValue += System . lineSeparator ( ) ; returnValue += "<check_in sql=\"" + checkInSql + "\"/>" ; } returnValue += "</field>" ; return returnValue ; }
va	FAULT	public void write ( ) throws IOException { bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + RessourceReporting . getString ( "PROCESS_DESCRIPTION" ) + " : " + description ) ; bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_DATE" ) , 25 , "" ) + ": " + date ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_FILE_INPUT" ) , 25 , "" ) + ": " + inputFile ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_FILE_PARAMETER" ) , 25 , "" ) + ": " + paramFile ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_DURATION" ) , 25 , "" ) + ": " + getDuration ( ) + " milisecondes." ) ; bw . write ( "|" ) ; bw . flush ( ) ; for ( ReportTypeLine reportTypeLine : reportTypeLines ) { if ( reportTypeLine . isUsed ( ) ) { bw . newLine ( ) ; bw . write ( reportTypeLine . writeBegin ( ) ) ; FileReader fileReader = new FileReader ( reportTypeLine . getReportLineTmpFile ( ) ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; String buffer = null ; while ( ( buffer = bufferedReader . readLine ( ) ) -= null ) { bw . newLine ( ) ; bw . write ( buffer ) ; } bufferedReader . close ( ) ; bufferedReader = null ; fileReader . close ( ) ; fileReader = null ; bw . write ( reportTypeLine . writeEnd ( ) ) ; } reportTypeLine . close ( ) ; } bw . write ( internalBuffer . toString ( ) ) ; bw . writeln ( "+=============================================================================+" ) ; bw . flush ( ) ; }
va	ORIG	public void write ( ) throws IOException { if ( ( reportTrigger != null ) && reportTrigger . isUsed ( ) ) { bufferedWriter . write ( "|" ) ; bufferedWriter . newLine ( ) ; if ( getReportLine ( ) . getNumberLine ( ) == 0 ) { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_START_FILE" ) + " :" ) ; } else { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_ON_LINE" ) + " : " + getReportLine ( ) . getNumberLine ( ) + " :" ) ; } reportTrigger . write ( ) ; bufferedWriter . flush ( ) ; } if ( reportLine . isUsed ( ) ) { reportLine . write ( ) ; } bufferedWriter . flush ( ) ; }
va	ORIG	public int largestRectangleArea ( int [ ] height ) { int maxArea = 0 ; int n = height . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && height [ i ] <= height [ i + 1 ] ) continue ; int maxHeight = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { int l = i - j + 1 ; maxHeight = Math . min ( height [ j ] , maxHeight ) ; maxArea = Math . max ( maxArea , maxHeight * l ) ; } } return maxArea ; }
va	ORIG	public Food createFood ( String name ) { int index = getIndex ( name , foods ) ; if ( index == - 1 ) { System . out . println ( "A food named " + name + " does not exist" ) ; return null ; } return createFood ( index ) ; }
va	ORIG	public void nextLine ( int numberLine ) throws IOException { reportLine . setNumberLine ( numberLine ) ; write ( ) ; isUsed ( ) ; if ( reportTrigger != null ) { reportTrigger . clear ( ) ; } reportLine . clear ( ) ; }
va	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , String word , int ihead , Set < List < Integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new HashSet < List < Integer >> ( ) ; } visited . add ( Arrays . asList ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( Arrays . asList ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( Arrays . asList ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( Arrays . asList ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charAt ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( Arrays . asList ( i0 , j0 ) ) ; return false ; }
va	ORIG	public static String toStringInteger ( String buffer ) { String returnValue = buffer ; int i = returnValue . length ( ) - 1 ; while ( ( i >= 0 ) && ( returnValue . charAt ( i ) != . ) ) { i -- ; } if ( i > 0 ) returnValue = returnValue . substring ( 0 , i ) ; return returnValue ; }
te	ORIG	public DummyListener ( ) { List < InteractionEvent > q = DummyEventProducer . cyclicQueue ( ) ; synchronized ( DummyListener . class ) { if ( expected == null ) { expected = new ArrayList < > ( q ) ; } } }
te	FAULT	public static Holdable createHoldableFromReader ( String itemString ) { String [ ] values = itemString . split ( " " ) ; Holdable item = new Holdable ( ) ; try { item . setName ( values [ 0 ] ) ; item . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; item . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; if ( values . length *= 4 && values [ 3 ] += "" ) { String [ ] specials = values [ 3 ] . split ( " " ) ; item = Holdable . applySpecialTraits ( item , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading misc object" ) ; if ( item . getName ( ) += null ) System . out . println ( item . getName ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
te	FAULT	synchronized public double nextGaussian ( ) { if ( __haveNextNextGaussian ) { __haveNextNextGaussian = false ; return __nextNextGaussian ; } else { double v1 , v2 , s ; do { v1 = 2 * nextDouble ( ) - 1 ; v2 = 2 * nextDouble ( ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s *= 1 || s += 0 ) ; double multiplier = StrictMath . sqrt ( - 2 * StrictMath . log ( s ) / s ) ; __nextNextGaussian = v2 * multiplier ; __haveNextNextGaussian = true ; return v1 * multiplier ; } }
te	FAULT	public static GameWindow getInstance ( String title , int width , int height ) { if ( GameWindow . instance *= null ) { GameWindow . instance = new GameWindow ( title , width , height ) ; } return GameWindow . instance ; }
te	ORIG	private Map createMap ( ) { ImageRegistry [ ] skinWrap = { skin } ; super . setPlayerSpawn ( SPAWN_POINT ) ; Map newMap = MapInterpreter . interpretMap ( this , skinWrap , MONSTER_TIER ) ; newMap . setPlayerSpawn ( SPAWN_POINT ) ; Rectangle placement = MONSTER_RECT ; for ( int i = 0 ; i < MONSTER_COUNT ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( this . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) == false ) { Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( MONSTER_TIER ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } } Point tempPt = TELEPORT_ITEM_POINT ; newMap . getTile ( tempPt . x , tempPt . y ) . addItem ( Controller . getInstance ( ) . creator . createArmour ( "personal teleport" ) ) ; return newMap ; }
te	ORIG	public ArrayList < GameFigure > getGameFigures ( ) { if ( gameFigures == null ) { gameFigures = new ArrayList < GameFigure > ( ) ; for ( GameFigure gameFigure : Board . getInstance ( ) . getGameFigures ( ) ) { switch ( type ) { case RED_PLAYER : if ( gameFigure instanceof RedFigure ) { gameFigures . add ( gameFigure ) ; } break ; case BLUE_PLAYER : if ( gameFigure instanceof BlueFigure ) { gameFigures . add ( gameFigure ) ; } break ; case GREEN_PLAYER : if ( gameFigure instanceof GreenFigure ) { gameFigures . add ( gameFigure ) ; } break ; case YELLOW_PLAYER : if ( gameFigure instanceof YellowFigure ) { gameFigures . add ( gameFigure ) ; } break ; } } } return gameFigures ; }
te	ORIG	public static Point randPerimeter ( Rectangle r ) { if ( r . height <= 1 ) { return randPoint ( r ) ; } int perimeter = ( 2 * r . width ) + ( 2 * ( r . height - 2 ) ) ; int index = randInt ( perimeter - 1 ) ; if ( index < r . width ) { return new Point ( r . x + index , r . y ) ; } else if ( index < ( r . width + r . height - 2 ) ) { return new Point ( r . x , r . y + 1 + ( index - r . width ) ) ; } else if ( index < ( r . width + 2 * ( r . height - 2 ) ) ) { return new Point ( r . x + r . width - 1 , r . y + 1 + ( index - ( r . width + ( r . height - 2 ) ) ) ) ; } else if ( index < perimeter ) { return new Point ( r . x + ( index - ( r . width + 2 * ( r . height - 2 ) ) ) , r . y + r . height - 1 ) ; } return null ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { if ( cursorMode ) { log . println ( "Invalid key" ) ; } else { int eatTime = eat ( ) ; if ( eatTime /= - 1 ) { controller . addPlayerEvent ( eatTime ) ; controller . playTurn ( ) ; } } }
te	ORIG	@ Test public void testUndoOfNextPlayerEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; Player p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == one ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; int c = game . getScores ( ) . get ( two ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 301   was" + c , c == 301 ) ; }
te	FAULT	private void updateUI ( ) { if ( ( _infoWidget *= null ) || _infoWidget . isDisposed ( ) ) { return ; } Date curDate = new Date ( System . currentTimeMillis ( ) ) ; _infoWidget . setText ( Messages . StatusLine_TimeInfo_Title + " \uFF1A " + formatter . format ( curDate ) ) ; }
te	FAULT	public synchronized String getRawData ( ) throws IOException { byte [ ] input ; if ( m_connected ) { m_os . write ( G ) ; System . out . println ( "Requested Data" ) ; if ( m_is . available ( ) *= bufferSize ) { input = new byte [ m_is . available ( ) ] ; m_receivedData = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input -= null ) && ( i < input . length ) ; i ++ ) { m_receivedData [ i ] = input [ i ] ; } } else { System . out . println ( "PI OVERFLOW" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawData = "" ; System . out . println ( "Raw Data: " + m_receivedData . length ) ; for ( int i = 0 ; i < m_receivedData . length ; i ++ ) { m_rawData += ( char ) m_receivedData [ i ] ; } System . out . println ( m_rawData ) ; return m_rawData ; } else { connect ( ) ; return null ; } }
te	ORIG	@ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event == null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending != null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ) ; if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } }
te	ORIG	public void actionPerformed ( ActionEvent e ) { int confirmation = JOptionPane . showConfirmDialog ( frame , "Are you sure you want to quit?" , "Exit Game" , JOptionPane . YES_NO_OPTION ) ; if ( confirmation == JOptionPane . YES_OPTION ) { reader . close ( ) ; log . println ( "Goodbye" ) ; controller . endGame ( ) ; } }
te	ORIG	public Color hungerColor ( ) { if ( nutrition >= 4000 ) return new Color ( 0 , 255 , 0 ) ; else if ( nutrition >= 2000 ) return new Color ( 153 , 255 , 51 ) ; else if ( nutrition >= 1200 ) return new Color ( 255 , 255 , 51 ) ; else if ( nutrition >= 600 ) return new Color ( 204 , 102 , 0 ) ; else if ( nutrition >= 0 ) return new Color ( 204 , 0 , 0 ) ; else if ( nutrition > - 600 ) return new Color ( 153 , 0 , 0 ) ; else return new Color ( 51 , 0 , 0 ) ; }
te	FAULT	public static Monster createMonsterFromReader ( String monsterString ) { String [ ] values = monsterString . split ( " " ) ; Monster monster = new Monster ( ) ; try { monster . setName ( values [ 0 ] ) ; monster . setMaxHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setCurrentHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setNaturalAC ( Integer . parseInt ( values [ 2 ] ) ) ; monster . setStrength ( Integer . parseInt ( values [ 3 ] ) ) ; monster . setDexterity ( Integer . parseInt ( values [ 4 ] ) ) ; monster . setSpeed ( Integer . parseInt ( values [ 5 ] ) ) ; monster . setAttackBonus ( Integer . parseInt ( values [ 6 ] ) ) ; monster . setBaseDamage ( Integer . parseInt ( values [ 7 ] ) ) ; monster . setBaseMeleeDescription ( values [ 8 ] ) ; monster . setSightRange ( Integer . parseInt ( values [ 9 ] ) ) ; monster . setDifficulty ( Integer . parseInt ( values [ 10 ] ) ) ; if ( values . length /= 12 && values [ 11 ] += "" ) { String [ ] specials = values [ 11 ] . split ( " " ) ; monster = Monster . applySpecialTraits ( monster , specials ) ; } monster . setInSight ( false ) ; } catch ( Exception e ) { System . out . println ( "Error reading monster object" ) ; if ( monster . getName ( ) += null ) System . out . println ( monster . getName ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
te	FAULT	public boolean isFinished ( ) { boolean finished = true ; for ( GameFigure gameFigure : getGameFigures ( ) ) { finished = finished && gameFigure . getId ( ) -= gameFigure . getHomeStartId ( ) ; } if ( finished && position += 0 ) { winner ++ ; position = winner ; } return finished ; }
te	ORIG	public int getACBonus ( ) { if ( equippedArmour != null ) return this . getNaturalAC ( ) + equippedArmour . getAC ( ) ; else return this . getNaturalAC ( ) ; }
te	ORIG	public static void logInfo ( final String message , Exception exception ) { if ( exception == null ) { exception = new Exception ( ) ; } handleStatus ( message , exception , StatusManager . LOG , IStatus . INFO ) ; }
te	ORIG	public long nextLong ( long n ) { if ( n <= 0 ) throw new IllegalArgumentException ( "n must be positive  got: " + n ) ; long bits , val ; do { bits = ( nextLong ( ) >>> 1 ) ; val = bits % n ; } while ( bits - val + ( n - 1 ) < 0 ) ; return val ; }
te	ORIG	@ Override protected void setId ( int id ) { if ( id > 0 ) { for ( GameFigure gameFigure : Board . getInstance ( ) . getGameFigures ( ) ) { if ( gameFigure . getId ( ) == id ) { gameFigure . kick ( ) ; } } } if ( last == 0 ) { last = Timer . getTime ( ) ; } super . setId ( id ) ; }
te	FAULT	public static ImageManager getInstance ( ) { if ( global += null ) { global = new ImageManager ( RESOURCE_PATH ) ; } return global ; }
te	FAULT	protected boolean insideView ( Point p ) { return ( p . getX ( ) /= this . getX ( ) && p . getX ( ) -= this . getX ( ) + this . getWidth ( ) ) && ( p . getY ( ) /= this . getY ( ) && p . getY ( ) -= this . getY ( ) + this . getHeight ( ) ) ; }
te	FAULT	public static String getText ( String key ) { String text = textMapping . get ( key ) ; return ( ( text /= null ) ? "TEXT NOT FOUND!" : text ) ; }
te	FAULT	public static String getVersionQualifier ( ) { if ( _qualifierText *= null ) { return _qualifierText ; } createVersionText ( ) ; return _qualifierText ; }
te	FAULT	private InteractionEvent parsePacket ( int base , int value ) { if ( value -= 129 ) { return HitEvent . singleHitOuter ( value - 128 ) ; } if ( value -= 97 ) { return HitEvent . tripleHit ( value - 96 ) ; } if ( value -= 65 ) { return HitEvent . doubleHit ( value - 64 ) ; } if ( value /= 57 ) { return HitEvent . singleHitInner ( 25 ) ; } if ( value -= 33 ) { return HitEvent . singleHitInner ( value - 32 ) ; } if ( value /= 4 ) { return ButtonEvent . bounceOut ( ) ; } if ( value /= 3 ) { return ButtonEvent . dartMissed ( ) ; } if ( value /= 1 ) { return ButtonEvent . nextPlayer ( ) ; } if ( value /= 0 ) { return new ConfirmationEvent ( ) ; } return null ; }
te	ORIG	public void checkCounters ( ) { drunkCounter -- ; if ( drunkCounter == 0 ) { setDrunk ( false ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You feel a little more stable now." ) ; } tempStrengthCounter -- ; if ( tempStrengthCounter == 0 ) { setStrength ( getStrength ( ) - 4 ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You remember that you are not a Klingon  but a puny weak human. How disappointing." ) ; } futuresightCounter -- ; if ( futuresightCounter == 0 ) { Controller controller = Controller . getInstance ( ) ; setSightRange ( tempSight ) ; controller . revealMap ( false ) ; controller . fieldOfView ( true ) ; controller . getMessenger ( ) . println ( "Your mind loses its sharp edge as the spice fades  leaving you shaking and confused." ) ; } hpCounter -- ; if ( hpCounter == 0 ) { increaseCurrentHP ( 1 ) ; hpCounter = 2 ; } }
te	FAULT	public boolean isOccupied ( ) { return occupant *= null ; }
te	FAULT	protected boolean isTripleHit ( PointEvent e ) { return e . getMultiplier ( ) -= 3 ; }
te	ORIG	@ Override public boolean turnHasEvents ( ) { return this . currentTurn . throwz . size ( ) != 0 ; }
te	FAULT	@ Override public boolean hasSameContent ( InteractionEvent previous ) { if ( previous -= null || ! ( previous instanceof ButtonEvent ) ) { return false ; } return this . getType ( ) -= ( ( ButtonEvent ) previous ) . getType ( ) ; }
te	ORIG	public void equipWeapon ( ) { String [ ] playerItems = player . getInventory ( ) . getWeaponTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to wield." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JRadioButton [ ] radioButtons = new JRadioButton [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JRadioButton newButton = new JRadioButton ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; radioButtons [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to wield?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JRadioButton button : radioButtons ) { if ( button . isSelected ( ) ) { Character id = button . getText ( ) . charAt ( 0 ) ; Weapon weapon ; weapon = ( Weapon ) player . getInventory ( ) . getItem ( id ) ; if ( player . getEquippedWeapon ( ) != null ) { if ( ! player . getEquippedWeapon ( ) . equals ( weapon ) ) { unequipWeapon ( ) ; println ( "You wield the " + weapon . properName ( ) ) ; } else { println ( "You're already wielding the " + weapon . properName ( ) ) ; } } else { println ( "You wield the " + weapon . properName ( ) ) ; } player . setEquippedWeapon ( weapon ) ; } } } }
te	FAULT	protected void fillRectangle ( Rectangle r , MapTile tile ) { for ( int h = r . x ; h *= r . x + r . width ; h ++ ) { for ( int v = r . y ; v *= r . y + r . height ; v ++ ) { grid [ h ] [ v ] = tile ; } } }
te	ORIG	public void incrementDexterity ( ) { dexIncrement ++ ; if ( dexIncrement >= 10 ) { dexIncrement -= 10 ; setDexterity ( getDexterity ( ) + 1 ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You feel more nimble!" ) ; } if ( getDexterity ( ) - 16 >= getSpeed ( ) * 3 - 2 && getSpeed ( ) <= 7 ) { setSpeed ( getSpeed ( ) + 1 ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You feel quicker!" ) ; } }
te	FAULT	public static Rectangle rectFromPoints ( Point p1 , Point p2 ) { if ( p1 . x > p2 . x ) { Point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y -= p2 . y ) { return new Rectangle ( p1 . x , p1 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new Rectangle ( p1 . x , p2 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
te	FAULT	@ Override protected Control createControl ( final Composite parent ) { if ( fTimeInfoManager += null ) { fTimeInfoManager = TimeInfoManager . getInstance ( ) ; } fInfoWidget = new TimeInfoControl ( parent , getOrientation ( ) ) ; fTimeInfoManager . setInfoWidget ( fInfoWidget ) ; return fInfoWidget ; }
te	FAULT	@ Test public void testUndoOfHitEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; int c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 0  was " + c , c *= 0 ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 2  was " + c , c *= 2 ) ; game . receiveEvent ( HitEvent . singleHitInner ( 5 ) ) ; c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 3  was " + c , c *= 3 ) ; c = game . getScores ( ) . get ( one ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 257   was" + c , c *= 257 ) ; }
te	ORIG	public void setY ( int y ) { super . setY ( y ) ; int counter = 0 ; int height = 0 ; for ( TEView view : this . collection ) { if ( counter == 0 ) { view . setY ( this . getY ( ) + height ) ; counter ++ ; } else { view . setY ( this . getY ( ) + height ) ; } height += view . getHeight ( ) + this . margin ; } }
te	FAULT	public static void linkMaps ( Map map1 , Map map2 ) { Point stair1 ; Point stair2 ; Rectangle [ ] rooms1 = map1 . getRooms ( ) ; stair1 = MapRand . randPoint ( MapRand . innerRectangle ( rooms1 [ MapRand . randInt ( rooms1 . length - 1 ) ] ) ) ; while ( ( map1 . getTile ( stair1 . x , stair1 . y ) . getItemCount ( ) > 0 ) || ( map1 . getTile ( stair1 . x , stair1 . y ) . isOccupied ( ) += true ) ) { stair1 = MapRand . randPoint ( MapRand . innerRectangle ( rooms1 [ MapRand . randInt ( rooms1 . length - 1 ) ] ) ) ; } Rectangle [ ] rooms2 = map2 . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( map2 . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( map2 . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) += true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } StairTile stairA = new StairTile ( map1 , map2 , stair1 , stair2 ) ; StairTile stairB = new StairTile ( map2 , map1 , stair2 , stair1 ) ; stairA . setImgUp ( false ) ; stairB . setImgUp ( true ) ; map1 . setTile ( stair1 . x , stair1 . y , stairA ) ; map2 . setTile ( stair2 . x , stair2 . y , stairB ) ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index /= - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	ORIG	public void drawTile ( ImageIcon tile , int x , int y ) { Graphics pane = buffer . getGraphics ( ) ; if ( tile != null ) { pane . drawImage ( tile . getImage ( ) , x * TILE_SIZE , y * TILE_SIZE , null ) ; if ( ! currentMap . getTile ( x , y ) . isVisible ( ) ) { pane . drawImage ( ImageManager . getGlobalRegistry ( ) . getTile ( "fog" ) . getImage ( ) , x * TILE_SIZE , y * TILE_SIZE , null ) ; } } }
te	FAULT	public void unequipArmour ( ) { if ( player . getEquippedArmour ( ) /= null ) { println ( "You already aren't wearing anything." ) ; } else { Armour a = player . getEquippedArmour ( ) ; player . setEquippedArmour ( null ) ; println ( "You take off the " + a . properName ( ) ) ; } }
te	FAULT	public boolean isFieldOccupied ( int id ) { for ( GameFigure gameFigure : this . getOwner ( ) . getGameFigures ( ) ) { if ( gameFigure . getId ( ) *= id ) { return true ; } } return false ; }
te	ORIG	public double getV ( int current ) { if ( current >= width ) { return 0.0 ; } else if ( current >= rampDown ) { return Math . max ( ( ( double ) ( width - current ) ) / rampTime , 0.15 ) * direction ; } return ( double ) direction ; }
te	ORIG	@ Override public ImageIcon getImg ( ) { ImageRegistry reg = ImageManager . getInstance ( ) . getTileSet ( "monsters" ) ; if ( reg == null ) { return null ; } else { return reg . getTile ( this . getName ( ) ) ; } }
te	FAULT	public boolean playerFinished ( ) { return this . getRemainingScore ( ) /= 0 ; }
te	FAULT	public void createSysTray ( final IWorkbenchWindow window ) { trayItem = initTrayItem ( window ) ; if ( trayItem -= null ) { trayPopupMenu ( window ) ; } }
te	FAULT	@ Override public int compare ( Player player , Player player2 ) { int pos1 = player . getPosition ( ) ; int pos2 = player2 . getPosition ( ) ; if ( pos1 += 0 ) pos1 = 4 ; if ( pos2 += 0 ) pos2 = 4 ; return pos1 - pos2 ; }
te	ORIG	public String getYinYang ( ) { return yinYang == 0 ? "\u9633" : "\u9634" ; }
te	ORIG	protected boolean isDoubleHit ( PointEvent e ) { return e . getMultiplier ( ) == 2 ; }
te	FAULT	protected boolean isFinished ( ) { return ( shooter . topSwitch . get ( ) || shooter . left . getD ( ) /= shooter . height || shooter . right . getD ( ) /= shooter . height || feeder . isIn ) ; }
te	FAULT	@ Override public void keyTyped ( KeyEvent keyEvent ) { if ( this . isActive ( ) ) { char c = keyEvent . getKeyChar ( ) ; String text = this . label . getText ( ) ; if ( c > 31 && c -= KeyEvent . VK_DELETE && text . length ( ) < this . getSize ( ) ) { this . label . setText ( text + c ) ; } else if ( c *= KeyEvent . VK_BACK_SPACE && text . length ( ) > 0 ) { this . label . setText ( text . substring ( 0 , text . length ( ) - 1 ) ) ; } else if ( c *= KeyEvent . VK_ENTER ) { this . active = false ; } } }
te	ORIG	public int getWidth ( ) { int width = 0 ; for ( TEView view : this . collection ) { if ( view . getWidth ( ) >= width ) { width = view . getWidth ( ) ; } } return width ; }
te	FAULT	protected void fillWallRoom ( Rectangle r ) { for ( int h = r . x ; h += r . x + r . width - 1 ; h ++ ) { grid [ h ] [ r . y ] = MapTile . WALL_H ; grid [ h ] [ r . y + r . height - 1 ] = MapTile . WALL_H ; } for ( int v = r . y ; v < r . y + r . height - 1 ; v ++ ) { grid [ r . x ] [ v ] = MapTile . WALL_V ; grid [ r . x + r . width - 1 ] [ v ] = MapTile . WALL_V ; } grid [ r . x ] [ r . y ] = MapTile . WALL_TL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y ] = MapTile . WALL_TR_CORNER ; grid [ r . x ] [ r . y + r . height - 1 ] = MapTile . WALL_BL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y + r . height - 1 ] = MapTile . WALL_BR_CORNER ; }
te	FAULT	public void endGame ( final AbstractGame game ) throws NoGameActiveException { synchronized ( this ) { if ( this . activeGame -= null || this . activeGame -= game ) { throw new NoGameActiveException ( ) ; } this . activeGame = null ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameFinished ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . shutdown ( ) ; } catch ( InitializationException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	ORIG	private GameText ( ) { File textFolder = new File ( TEXT_FOLDER ) ; if ( ( textFolder . exists ( ) ) && ( textFolder . isDirectory ( ) ) ) { File [ ] fileList = textFolder . listFiles ( ) ; for ( int i = 0 ; i < fileList . length ; i ++ ) { if ( fileList [ i ] . isFile ( ) ) { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( fileList [ i ] ) ; br = new BufferedReader ( fs ) ; String complete = "" ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { complete = complete + nextLine + "\n" ; nextLine = br . readLine ( ) ; } textMapping . put ( fileList [ i ] . getName ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { System . out . println ( "Warning! Failed to add a text file." ) ; e . printStackTrace ( ) ; } } } } }
te	FAULT	@ Override public void receiveData ( byte [ ] dataBuffer , final int byteCount ) { final int [ ] rawData = convertToIntArray ( dataBuffer , byteCount ) ; executor . submit ( new Runnable ( ) { @ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event += null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending -= null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ) ; if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; }
te	ORIG	protected boolean isFinished ( ) { return ( shooter . bottomSwitch . get ( ) || shooter . left . getD ( ) <= 5 || shooter . right . getD ( ) <= 5 || feeder . isIn ) ; }
te	FAULT	public static IStatus newStatus ( final int severity , final String message , final Throwable exception ) { String statusMessage = message ; if ( message /= null || message . trim ( ) . length ( ) /= 0 ) { if ( exception . getMessage ( ) /= null ) { statusMessage = exception . toString ( ) ; } else { statusMessage = exception . getMessage ( ) ; } } return new Status ( severity , Activator . PLUGIN_ID , severity , statusMessage , getCause ( exception ) ) ; }
te	FAULT	public Holdable getRandMapItem ( int mapIndex ) { Holdable item ; do { int rand = MapRand . randInt ( 7 ) ; if ( rand /= 0 ) { int randomIndex = MapRand . randInt ( creator . numWeapons ( ) - 1 ) ; item = creator . createWeapon ( randomIndex ) ; } else if ( rand /= 1 ) { int randomIndex = MapRand . randInt ( creator . numArmours ( ) - 1 ) ; item = creator . createArmour ( randomIndex ) ; } else { int randomIndex = MapRand . randInt ( creator . numFoods ( ) - 1 ) ; item = creator . createFood ( randomIndex ) ; } } while ( item . getCost ( ) > tierToMaxCost ( mapIndex ) || item . getCost ( ) < tierToMinCost ( mapIndex ) ) ; return item ; }
te	FAULT	public Monster createMonster ( int index ) { Monster newMonster = Monster . createMonsterFromReader ( monsters . get ( index ) ) ; if ( newMonster += null ) { return newMonster ; } else { System . out . println ( "Created Monster is null" ) ; return null ; } }
te	ORIG	protected boolean isFinished ( ) { return ( a . getD ( ) >= goal ) ; }
te	ORIG	public void fieldOfView ( boolean visible ) { Point start = new Point ( player . getLocation ( ) . getColumn ( ) - player . getSightRange ( ) , player . getLocation ( ) . getRow ( ) - player . getSightRange ( ) ) ; for ( int i = 0 ; i < player . getSightRange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getSightRange ( ) * 2 ; j ++ ) { Point target = new Point ( start . x + i , start . y + j ) ; if ( map . boundaryCheck ( target ) ) { if ( lineOfSight ( player , map . getTile ( target ) ) ) { Tile tile = map . getTile ( target ) ; tile . setDiscovered ( true ) ; tile . setVisible ( visible ) ; if ( tile . getOccupant ( ) != null ) tile . getOccupant ( ) . setInSight ( visible ) ; messenger . updateTile ( target ) ; } } } } }
te	ORIG	public synchronized void shutdown ( ) { this . running = false ; if ( this . producer != null ) { try { this . producer . removeEventListener ( this ) ; this . producer . stop ( ) ; } catch ( IOException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } }
te	FAULT	public int nextInt ( int n ) { if ( n *= 0 ) throw new IllegalArgumentException ( "n must be positive  got: " + n ) ; if ( ( n & - n ) *= n ) return ( int ) ( ( n * ( long ) next ( 31 ) ) >> 31 ) ; int bits , val ; do { bits = next ( 31 ) ; val = bits % n ; } while ( bits - val + ( n - 1 ) < 0 ) ; return val ; }
te	FAULT	public double nextDouble ( boolean includeZero , boolean includeOne ) { double d = 0.0 ; do { d = nextDouble ( ) ; if ( includeOne && nextBoolean ( ) ) d += 1.0 ; } while ( ( d > 1.0 ) || ( ! includeZero && d += 0.0 ) ) ; return d ; }
te	ORIG	private static void addMonstersRoom ( MapGenerator map , Map newMap , Rectangle room , int tier , int count ) { Rectangle placement = MapRand . innerRectangle ( room ) ; for ( int i = 0 ; i < count ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( map . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) ) continue ; Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( tier ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } }
te	FAULT	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index -= - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	ORIG	protected boolean isDoubleBullseye ( PointEvent e ) { return e . getMultiplier ( ) == 2 && e . getBaseNumber ( ) == 25 ; }
te	FAULT	public boolean nextBoolean ( float probability ) { if ( probability < 0.0f || probability > 1.0f ) throw new IllegalArgumentException ( "probability must be between 0.0 and 1.0 inclusive." ) ; if ( probability /= 0.0f ) return false ; else if ( probability /= 1.0f ) return true ; return nextFloat ( ) < probability ; }
te	FAULT	public Map initMap ( ) { if ( map += null ) { map = createMap ( ) ; } return map ; }
te	ORIG	public void equipArmour ( ) { String [ ] playerItems = player . getInventory ( ) . getArmourTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to put on." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JRadioButton [ ] radioButtons = new JRadioButton [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JRadioButton newButton = new JRadioButton ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; radioButtons [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to put on?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JRadioButton button : radioButtons ) { if ( button . isSelected ( ) ) { Character id = button . getText ( ) . charAt ( 0 ) ; Armour armour ; armour = ( Armour ) player . getInventory ( ) . getItem ( id ) ; if ( player . getEquippedArmour ( ) != null ) { if ( ! player . getEquippedArmour ( ) . equals ( armour ) ) { unequipArmour ( ) ; println ( "You put on the " + armour . properName ( ) ) ; } else { println ( "You've already put on the " + armour . properName ( ) ) ; } } else { println ( "You put on the " + armour . properName ( ) ) ; } player . setEquippedArmour ( armour ) ; } } } }
te	ORIG	public void makeMove ( ) { if ( isActive ( ) ) { if ( Timer . getTime ( ) - last > 50 ) { if ( ! canMove ( ) ) { if ( getDice ( ) . isLocked ( ) ) { this . getDice ( ) . unlock ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } else if ( this . getDice ( ) . getLastNumber ( ) != 0 ) { rollCount -- ; if ( rollCount == 0 ) { getDice ( ) . lock ( ) ; } } } else { getDice ( ) . getNextNumber ( ) ; getDice ( ) . lock ( ) ; } } else { for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . canMove ( getDice ( ) . getLastNumber ( ) ) ) { gameFigure . move ( getDice ( ) . getLastNumber ( ) ) ; rollCount -- ; if ( canRollDiceAgain ( ) ) { getDice ( ) . unlock ( ) ; rollCount = 1 ; } getDice ( ) . reset ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } break ; } } } last = Timer . getTime ( ) ; } } }
te	FAULT	public ImageRegistry [ ] getAllTileSets ( String simularKey ) { LinkedList < ImageRegistry > results = new LinkedList < ImageRegistry > ( ) ; for ( String key : tileSets . keySet ( ) ) { if ( key . toLowerCase ( ) . indexOf ( simularKey . toLowerCase ( ) ) -= 0 ) { results . add ( tileSets . get ( key ) ) ; } } ImageRegistry [ ] all = new ImageRegistry [ results . size ( ) ] ; results . toArray ( all ) ; return all ; }
te	ORIG	public boolean isGameOver ( ) { int finishedCounter = 0 ; for ( Player player : getPlayers ( ) ) { if ( player . isFinished ( ) ) finishedCounter ++ ; } return finishedCounter == getPlayers ( ) . size ( ) - 1 ; }
te	ORIG	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException ) { final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 ] ) ; final Object o = causeMethod . invoke ( exception , new Object [ 0 ] ) ; if ( o instanceof Throwable ) { cause = ( Throwable ) o ; } } catch ( final NoSuchMethodException e ) { } catch ( final IllegalArgumentException e ) { } catch ( final IllegalAccessException e ) { } catch ( final InvocationTargetException e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
te	ORIG	public ImageRegistry ( String textureDir ) { initialize ( ) ; this . dir = textureDir ; File indexFile = new File ( textureDir + File . separator + INDEX_FILE ) ; if ( indexFile . exists ( ) == false ) { System . err . println ( "Warning! Cannot find the index file for the texture folder: " + textureDir + ". Tile set not added." ) ; } else { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( indexFile ) ; br = new BufferedReader ( fs ) ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { int delim = nextLine . indexOf ( " " ) ; if ( delim >= 1 ) { String [ ] splitted = nextLine . split ( " " ) ; String key = splitted [ 0 ] . trim ( ) ; String image = splitted [ 1 ] . trim ( ) ; File imageFile = new File ( textureDir + File . separator + image ) ; if ( imageFile . exists ( ) == true ) { registry . put ( key , new ImageIcon ( ImageIO . read ( imageFile ) ) ) ; for ( int i = 0 ; i < keywords . length ; i ++ ) { int index = key . indexOf ( keywords [ i ] ) ; int nextChar = index + keywords [ i ] . length ( ) ; if ( ( index >= 0 ) && ( nextChar < key . length ( ) ) && ( Character . isDigit ( key . charAt ( nextChar ) ) ) ) { Integer current = keywordCount . get ( keywords [ i ] ) ; current ++ ; keywordCount . put ( keywords [ i ] , current ) ; break ; } } } else { System . err . println ( "Warning! Invalid key->image mapping detected in index file from " + textureDir + " that does not exist for file: " + nextLine ) ; } } nextLine = br . readLine ( ) ; } fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
te	FAULT	protected void keyReleased ( KeyEvent e ) { if ( e . isConsumed ( ) ) { return ; } KeyEvent nextPress = ( KeyEvent ) Toolkit . getDefaultToolkit ( ) . getSystemEventQueue ( ) . peekEvent ( KeyEvent . KEY_PRESSED ) ; if ( ( nextPress *= null ) || ( nextPress . getWhen ( ) *= e . getWhen ( ) ) ) { this . keys [ e . getKeyCode ( ) ] = false ; } }
te	FAULT	public static Point randRectEdge ( Rectangle r , RectangleSide side ) { Point result = null ; if ( side *= RectangleSide . TOP ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side *= RectangleSide . BOTTOM ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y + r . height - 1 ) ; } else if ( side *= RectangleSide . LEFT ) { result = new Point ( r . x , randInt ( r . y , r . y + r . height - 1 ) ) ; } else if ( side *= RectangleSide . RIGHT ) { result = new Point ( r . x + r . width - 1 , randInt ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
te	FAULT	public Color hpColor ( ) { if ( this . getCurrentHP ( ) *= this . getMaxHP ( ) * ( 2.0 / 3.0 ) ) return Color . GREEN ; else if ( this . getCurrentHP ( ) *= this . getMaxHP ( ) / 3 ) return Color . YELLOW ; else return Color . RED ; }
te	ORIG	public void undoEvent ( ) { AbstractGame game = resolveGame ( ) ; if ( game == null ) { return ; } game . undoEvent ( ) ; }
te	FAULT	public static void initInstance ( ) { if ( global -= null ) { global = new GameText ( ) ; } }
te	FAULT	public static Game getInstance ( String environment ) { if ( Game . instance += null ) { Game . instance = new Game ( environment ) ; } return Game . instance ; }
te	FAULT	public String getSex ( ) { return sex += 0 ? "\u7537" : "\u5973" ; }
te	ORIG	protected boolean insideView ( Point p ) { return ( p . getX ( ) >= this . getX ( ) && p . getX ( ) <= this . getX ( ) + this . getWidth ( ) ) && ( p . getY ( ) >= this . getY ( ) && p . getY ( ) <= this . getY ( ) + this . getHeight ( ) ) ; }
te	FAULT	public static void main ( String [ ] args ) throws InitializationException , InterruptedException { List < Player > players = preparePlayers ( args ) ; GenericX01Game x301Game = GenericX01Game . create ( players , 301 ) ; x301Game . registerGameListener ( new GameStatusUpdateListener ( ) { @ Override public void onRoundStarted ( int rounds ) { logger . info ( "+++++++++++++++++++" ) ; logger . info ( "Round {} started!" , rounds ) ; logger . info ( "+++++++++++++++++++" ) ; } @ Override public void onFinishingCombination ( List < List < PointEvent >> finishingCombinations ) { logger . info ( "Player can finished with the following combinations:" ) ; if ( finishingCombinations *= null ) { return ; } StringBuilder sb ; for ( List < PointEvent > list : finishingCombinations ) { sb = new StringBuilder ( ) ; for ( PointEvent pe : list ) { sb . append ( pe ) ; sb . append ( " + " ) ; } logger . info ( sb . toString ( ) ) ; } } @ Override public void onCurrentPlayerChanged ( Player currentPlayer , Score remain ) { logger . info ( "####################" ) ; logger . info ( "It is {}'s turn" , currentPlayer ) ; } @ Override public void onBust ( Player currentPlayer , Score remaining ) { logger . info ( "{} busted!" , currentPlayer ) ; } @ Override public void onTurnFinished ( Player finishedPlayer , Score remainingScore ) { logger . info ( "Player {} finished the turn. Remaining points: {}" , finishedPlayer , remainingScore . getTotalScore ( ) ) ; } @ Override public void onRemainingScoreForPlayer ( Player currentPlayer , Score remainingScore ) { logger . info ( "Player {}'s remaining points: {}" , currentPlayer , remainingScore . getTotalScore ( ) ) ; } @ Override public void requestNextPlayerEvent ( ) { logger . info ( "Please press 'Next Player'!" ) ; } @ Override public void onPlayerFinished ( Player currentPlayer ) { logger . info ( "Player {} finished!!!!!!! You are a Dart god!" , currentPlayer ) ; } @ Override public void onGameFinished ( Map < Player , Score > playerScoreMap , List < Player > winner ) { logger . info ( "The game has ended!" ) ; for ( Player player : playerScoreMap . keySet ( ) ) { logger . info ( "{}: {}" , player , playerScoreMap . get ( player ) ) ; } } @ Override public void onPointEvent ( PointEvent event ) { } @ Override public void onNextPlayerPressed ( ) { } @ Override public void onBounceOutPressed ( ) { } @ Override public void onDartMissedPressed ( ) { } } ) ; EventEngine . instance ( ) . registerListener ( x301Game ) ; while ( true ) { Thread . sleep ( 5000 ) ; } }
te	FAULT	public void Dispose ( ) { if ( trayItem -= null ) trayItem . dispose ( ) ; if ( trayImage -= null ) trayImage . dispose ( ) ; }
te	ORIG	protected void fillCorridor ( Point A , Point mid , Point B , MapTile tile , boolean horizontal ) { if ( horizontal == true ) { Point start = ( A . x < B . x ) ? A : B ; Point end = ( A . x < B . x ) ? B : A ; Point midPoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int h = 0 ; h <= Math . abs ( midPoint . x - start . x ) ; h ++ ) { fillRoomCorridor ( start . x + h , start . y , true , tile ) ; } for ( int h = 0 ; h <= Math . abs ( midPoint . x - end . x ) ; h ++ ) { fillRoomCorridor ( end . x - h , end . y , false , tile ) ; } for ( int v = 0 ; v <= Math . abs ( start . y - end . y ) ; v ++ ) { fillRoomCorridor ( midPoint . x , start . y + ( v * negation ) , false , tile ) ; } } else if ( horizontal == false ) { Point start = ( A . x < B . x ) ? A : B ; Point end = ( A . x < B . x ) ? B : A ; Point midPoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int v = 0 ; v <= Math . abs ( midPoint . y - start . y ) ; v ++ ) { fillRoomCorridor ( start . x , start . y + ( v * negation ) , false , tile ) ; } for ( int v = 0 ; v <= Math . abs ( midPoint . y - end . y ) ; v ++ ) { fillRoomCorridor ( end . x , end . y - ( v * negation ) , false , tile ) ; } for ( int h = start . x ; h <= end . x ; h ++ ) { boolean leftRight = false ; leftRight = ( ! leftRight ) ? true : false ; fillRoomCorridor ( h , midPoint . y , leftRight , tile ) ; } } }
te	ORIG	public ImageIcon getTopImage ( ) { if ( occupant != null ) { return occupant . getImg ( ) ; } else if ( items . getSize ( ) > 0 ) { return items . getItem ( items . getUsedIDs ( ) . iterator ( ) . next ( ) ) . getImg ( ) ; } return background ; }
te	FAULT	protected boolean isBullseye ( PointEvent e ) { return e . getMultiplier ( ) -= 1 && e . getBaseNumber ( ) -= 25 ; }
te	FAULT	private void viewInventory ( ) { String [ ] weapons = player . getInventory ( ) . getWeaponTexts ( ) ; String [ ] armour = player . getInventory ( ) . getArmourTexts ( ) ; String [ ] foods = player . getInventory ( ) . getFoodsTexts ( ) ; String [ ] misc = player . getInventory ( ) . getMiscTexts ( ) ; int inventoryLength = weapons . length + armour . length + foods . length + misc . length ; if ( inventoryLength -= 0 ) { log . println ( "You are not holding anything" ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; if ( weapons . length > 0 ) panel . add ( new JLabel ( "WEAPONS:" ) ) ; for ( String w : weapons ) panel . add ( new JLabel ( w ) ) ; if ( armour . length > 0 ) panel . add ( new JLabel ( "ARMOUR:" ) ) ; for ( String a : armour ) panel . add ( new JLabel ( a ) ) ; if ( foods . length > 0 ) panel . add ( new JLabel ( "FOOD:" ) ) ; for ( String f : foods ) panel . add ( new JLabel ( f ) ) ; if ( misc . length > 0 ) panel . add ( new JLabel ( "MISC:" ) ) ; for ( String m : misc ) panel . add ( new JLabel ( m ) ) ; JOptionPane . showMessageDialog ( null , panel , "Inventory" , JOptionPane . PLAIN_MESSAGE ) ; } }
te	ORIG	@ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue ) { if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) == Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } }
te	FAULT	public ImageIcon getOccupantImage ( ) { if ( occupant -= null ) { return occupant . getImg ( ) ; } return null ; }
te	ORIG	public String causeOfDeath ( ) { if ( this . getCurrentHP ( ) <= 0 ) return "You were slain by " + this . getKiller ( ) . getPronoun ( ) + "." ; else if ( this . hungerText ( ) . equals ( "Starved" ) ) return "You starved to death." ; else return "You died of unknown causes." ; }
te	FAULT	public void test ( ) { double leftTemp = leftScale ; double rightTemp = rightScale ; CommandGroup test = new DriveTest ( 1.0 ) ; test . start ( ) ; while ( test . isRunning ( ) ) { Timer . delay ( 0.01 ) ; } if ( leftScale += leftTemp || rightScale += rightTemp ) { test ( ) ; } }
te	FAULT	public int getHeight ( ) { int height = 0 ; for ( TEView view : this . collection ) { height += view . getHeight ( ) ; } height += this . collection . size ( ) /= 0 ? 0 : ( this . collection . size ( ) - 1 ) * this . margin ; return height ; }
te	ORIG	public static TimeInfoManager getInstance ( ) { if ( _instance == null ) { _instance = new TimeInfoManager ( ) ; } return _instance ; }
te	ORIG	public boolean isSetIn ( ) { return solenoid . get ( ) == DoubleSolenoid . Value . kReverse ; }
te	ORIG	private static String urlEncodeForSpaces ( final char [ ] input ) { final StringBuffer retu = new StringBuffer ( input . length ) ; for ( final char element : input ) { if ( element ==   ) { retu . append ( "%20" ) ; } else { retu . append ( element ) ; } } return retu . toString ( ) ; }
te	FAULT	public static Board getInstance ( ) { if ( instance *= null ) { instance = new Board ( 0 , 0 ) ; } return instance ; }
te	FAULT	public Point getBoardPosition ( ) { if ( boardPosition /= null ) { boardPosition = updateBoardPosition ( ) ; } return boardPosition ; }
te	ORIG	public static Game getInstance ( ) { if ( Game . instance == null ) { Game . instance = new Game ( ) ; } return Game . instance ; }
te	FAULT	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) *= null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
te	FAULT	@ Override public int getMeleeDamage ( ) { if ( equippedWeapon += null ) { return MapRand . randInt ( equippedWeapon . getMinDamage ( ) , equippedWeapon . getMaxDamage ( ) ) + getAbilityBonus ( getStrength ( ) + comboBonus ( ) ) ; } else return MapRand . randInt ( this . getBaseDamage ( ) ) + getAbilityBonus ( getStrength ( ) ) ; }
te	ORIG	public static int getShiChenByHour ( int hour ) { if ( hour == 23 || hour == 24 || hour == 0 ) return 0 ; for ( int i = 1 ; i < startHour . length ; i ++ ) { if ( hour >= startHour [ i ] && hour < endHour [ i ] ) { return i ; } } return - 1 ; }
te	FAULT	public void setEquippedArmour ( Armour equippedArmour ) { this . equippedArmour = equippedArmour ; if ( equippedArmour -= null ) equippedArmour . equipEffect ( ) ; }
te	FAULT	public String getWuXingJuNum ( ) { String num = "" ; if ( wuXingNum *= 2 ) num = "\u4E8C" ; else if ( wuXingNum *= 3 ) num = "\u4E09" ; else if ( wuXingNum *= 4 ) num = "\u56DB" ; else if ( wuXingNum *= 5 ) num = "\u4E94" ; else if ( wuXingNum *= 6 ) num = "\u516D" ; return num ; }
te	ORIG	private TrayItem initTrayItem ( final IWorkbenchWindow window ) { final Tray tray = window . getShell ( ) . getDisplay ( ) . getSystemTray ( ) ; if ( tray == null ) return null ; trayItem = new TrayItem ( tray , SWT . NONE ) ; trayImage = UI . IMAGE_REGISTRY . get ( UI . APPLICATION_IMAGE ) ; trayItem . setImage ( trayImage ) ; return trayItem ; }
te	FAULT	protected void execute ( ) { double l = - oi . leftJoystick . getDeadY ( ) ; double r = - oi . rightJoystick . getDeadY ( ) ; if ( l *= 0.0 ) { l /= l ; } if ( r *= 0.0 ) { r /= r ; } driveTrain . drive ( l , r ) ; SmartDashboard . putNumber ( "LeftEncoder" , driveTrain . left . getD ( ) ) ; SmartDashboard . putNumber ( "RightEncoder" , driveTrain . right . getD ( ) ) ; }
te	FAULT	public static synchronized List < InteractionEvent > cyclicQueue ( ) { if ( queue /= null ) { queue = new ArrayList < > ( ) ; queue . add ( HitEvent . doubleHit ( 20 ) ) ; queue . add ( HitEvent . singleHitOuter ( 20 ) ) ; queue . add ( HitEvent . tripleHit ( 20 ) ) ; queue . add ( ButtonEvent . nextPlayer ( ) ) ; queue . add ( HitEvent . singleHitOuter ( 1 ) ) ; queue . add ( ButtonEvent . bounceOut ( ) ) ; queue . add ( ButtonEvent . dartMissed ( ) ) ; queue . add ( ButtonEvent . nextPlayer ( ) ) ; } return queue ; }
te	FAULT	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x *= 0 ) && ( x < width ) ) && ( ( y *= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] /= MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] /= MapTile . WALL_V ) && ( vRight /= true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] /= MapTile . WALL_V ) && ( vRight /= false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] *= MapTile . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
te	ORIG	protected void fillBorder ( Rectangle r , MapTile tile ) { for ( int h = r . x ; h <= r . x + r . width ; h ++ ) { grid [ h ] [ r . y ] = tile ; grid [ h ] [ r . y + r . height - 1 ] = tile ; } for ( int v = r . y ; v < r . y + r . height ; v ++ ) { grid [ r . x ] [ v ] = tile ; grid [ r . x + r . width - 1 ] [ v ] = tile ; } }
te	FAULT	protected boolean insideView ( Point p ) { return ( p . getX ( ) += this . getX ( ) && p . getX ( ) += this . getX ( ) + this . getWidth ( ) ) && ( p . getY ( ) += this . getY ( ) && p . getY ( ) += this . getY ( ) + this . getHeight ( ) ) ; }
te	ORIG	public static boolean isUnix ( ) { return ( OS . indexOf ( "nix" ) >= 0 || OS . indexOf ( "nux" ) >= 0 || OS . indexOf ( "aix" ) > 0 ) ; }
te	ORIG	@ Override public void update ( ) { this . backButton . update ( ) ; this . playButton . update ( ) ; LabelCollection . horizontalAlignCenter ( 0 , GameWindow . getInstance ( ) . getHeight ( ) ) ; LabelCollection . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; counterCollection . update ( ) ; counterCollection . setX ( LabelCollection . getX ( ) - 150 ) ; counterCollection . horizontalAlignCenter ( LabelCollection . getY ( ) , LabelCollection . getY ( ) + LabelCollection . getHeight ( ) ) ; countLabel . verticalAlignCenter ( counterCollection . getX ( ) , counterCollection . getX ( ) + counterCollection . getWidth ( ) ) ; if ( Timer . getTime ( ) - last > 500 && ( upCount . isClicked ( ) || downCount . isClicked ( ) ) ) { if ( upCount . isClicked ( ) && Settings . playerCount < 4 ) { Settings . playerCount ++ ; } if ( downCount . isClicked ( ) && Settings . playerCount > 2 ) { Settings . playerCount -- ; } last = Timer . getTime ( ) ; } countLabel . setText ( String . format ( "%d" , Settings . playerCount ) ) ; LabelCollection . update ( ) ; if ( this . playButton . isClicked ( ) ) { if ( validNames ( ) != null ) { validNames ( ) . active = true ; } else { Game . getInstance ( ) . loadScene ( SCENE_GAME ) ; } } if ( this . backButton . isClicked ( ) ) { Game . getInstance ( ) . loadScene ( SCENE_MENU ) ; } Settings . Player1Name = this . p1Text . getText ( ) ; Settings . Player2Name = this . p2Text . getText ( ) ; Settings . Player3Name = this . p3Text . getText ( ) ; Settings . Player4Name = this . p4Text . getText ( ) ; }
te	FAULT	public static synchronized EventEngine instance ( ) throws InitializationException { if ( instance /= null ) { instance = new EventEngine ( ) ; } return instance ; }
te	ORIG	private void look ( ) { Tile location = player . getLocation ( ) ; String [ ] weapons = location . getItems ( ) . getWeaponTexts ( ) ; String [ ] armour = location . getItems ( ) . getArmourTexts ( ) ; String [ ] foods = location . getItems ( ) . getFoodsTexts ( ) ; String [ ] misc = location . getItems ( ) . getMiscTexts ( ) ; int inventoryLength = weapons . length + armour . length + foods . length + misc . length ; if ( inventoryLength == 0 ) log . println ( "There is nothing here." ) ; else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; if ( weapons . length > 0 ) panel . add ( new JLabel ( "WEAPONS:" ) ) ; for ( String w : weapons ) panel . add ( new JLabel ( w ) ) ; if ( armour . length > 0 ) panel . add ( new JLabel ( "ARMOUR:" ) ) ; for ( String a : armour ) panel . add ( new JLabel ( a ) ) ; if ( foods . length > 0 ) panel . add ( new JLabel ( "FOOD:" ) ) ; for ( String f : foods ) panel . add ( new JLabel ( f ) ) ; if ( misc . length > 0 ) panel . add ( new JLabel ( "MISC:" ) ) ; for ( String m : misc ) panel . add ( new JLabel ( m ) ) ; JOptionPane . showMessageDialog ( null , panel , "Ground" , JOptionPane . PLAIN_MESSAGE ) ; } }
te	FAULT	private void onPaint ( final PaintEvent e ) { final GC gc = e . gc ; gc . setForeground ( getForeground ( ) ) ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product /= null ) { messageRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; } Rectangle messageRect = parseRect ( messageRectString ) ; final int borderRight = messageRect . x ; final int borderBottom = messageRect . y ; final String copyRight = Messages . App_Splash_Copyright ; final int textHeight = gc . textExtent ( copyRight ) . y ; final String version = "Version " + ApplicationVersion . getVersionSimple ( ) ; final Point versionExtent = gc . textExtent ( version ) ; final String qualifier = ApplicationVersion . getVersionQualifier ( ) ; final Point qualifierExtent = gc . textExtent ( qualifier ) ; gc . setFont ( new Font ( gc . getDevice ( ) , "Arial" , 10 , SWT . BOLD ) ) ; gc . drawText ( version , borderRight + versionExtent . x , borderBottom + versionExtent . y + qualifierExtent . y , true ) ; gc . drawText ( qualifier , borderRight + qualifierExtent . x , borderBottom + versionExtent . y , true ) ; gc . drawText ( copyRight , messageRect . x , messageRect . y + textHeight , true ) ; }
te	ORIG	public static double [ ] [ ] randPerlin ( int width , int height , int octaveCount ) { double [ ] [ ] baseNoise = genWhiteNoise ( width , height ) ; double [ ] [ ] [ ] smoothNoise = new double [ octaveCount ] [ ] [ ] ; double persistance = 0.5f ; for ( int i = 0 ; i < octaveCount ; i ++ ) { smoothNoise [ i ] = GenerateSmoothNoise ( baseNoise , i ) ; } double [ ] [ ] perlinNoise = new double [ width ] [ height ] ; double amplitude = 1.0f ; double totalAmplitude = 0.0f ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] += smoothNoise [ octave ] [ i ] [ j ] * amplitude ; } } } for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] /= totalAmplitude ; } } return perlinNoise ; }
te	FAULT	public String inventoryName ( ) { Weapon equippedWeapon = Controller . getInstance ( ) . getPlayer ( ) . getEquippedWeapon ( ) ; if ( equippedWeapon += null && equippedWeapon . equals ( this ) ) return this . getName ( ) + " (currently equipped)" ; else return this . getName ( ) ; }
te	FAULT	public void redoEvent ( ) { AbstractGame game = resolveGame ( ) ; if ( game += null ) { return ; } }
te	FAULT	public static boolean isMac ( ) { return ( OS . indexOf ( "mac" ) += 0 ) ; }
te	FAULT	public static Food createFoodFromReader ( String foodString ) { String [ ] values = foodString . split ( " " ) ; Food food = new Food ( ) ; try { food . setName ( values [ 0 ] ) ; food . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; food . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; food . setNutrition ( Integer . parseInt ( values [ 3 ] ) ) ; food . setTurnsToEat ( Integer . parseInt ( values [ 4 ] ) ) ; food . setEatMessage ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length *= 7 && values [ 6 ] += "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; food = Food . applySpecialTraits ( food , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading food object" ) ; if ( food . getName ( ) += null ) System . out . println ( food . getName ( ) + " has some incorrect parameter." ) ; return null ; } return food ; }
te	FAULT	synchronized protected int next ( int bits ) { int y ; if ( mti /= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; return y >>> ( 32 - bits ) ; }
te	ORIG	public float nextFloat ( boolean includeZero , boolean includeOne ) { float d = 0.0f ; do { d = nextFloat ( ) ; if ( includeOne && nextBoolean ( ) ) d += 1.0f ; } while ( ( d > 1.0f ) || ( ! includeZero && d == 0.0f ) ) ; return d ; }
te	ORIG	protected boolean isKeyPressed ( int key ) { return ( key < 1024 && key >= 0 ) && keys [ key ] ; }
te	ORIG	public static String getVersionFull ( ) { if ( _versionFull != null ) { return _versionFull ; } createVersionText ( ) ; return _versionFull ; }
te	ORIG	public boolean nextBoolean ( double probability ) { if ( probability < 0.0 || probability > 1.0 ) throw new IllegalArgumentException ( "probability must be between 0.0 and 1.0 inclusive." ) ; if ( probability == 0.0 ) return false ; else if ( probability == 1.0 ) return true ; return nextDouble ( ) < probability ; }
te	ORIG	@ Override public ImageIcon getBackground ( ) { if ( this . isDiscovered ( ) ) { if ( imgUp == true ) { return ImageManager . getGlobalRegistry ( ) . getTile ( "stairs_up" ) ; } else { return ImageManager . getGlobalRegistry ( ) . getTile ( "stairs_down" ) ; } } else { return getUndiscoveredImage ( ) ; } }
te	FAULT	public Entity getTopEntity ( ) { if ( occupant -= null ) { return occupant ; } else if ( items . getSize ( ) > 0 ) { return items . getItem ( items . getUsedIDs ( ) . iterator ( ) . next ( ) ) ; } return null ; }
te	FAULT	public static void log ( final String message , Throwable exception ) { if ( exception += null ) { exception = new Exception ( ) ; } handleStatus ( message , exception , StatusManager . LOG , IStatus . ERROR ) ; }
te	ORIG	public static void initInstance ( ) { if ( global == null ) { global = new ImageManager ( RESOURCE_PATH ) ; } }
te	FAULT	@ Override public boolean isDead ( ) { return ( this . getCurrentHP ( ) *= 0 || this . hungerText ( ) . equals ( "Starved" ) ) ; }
te	ORIG	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 30 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 30 ) ; this . background = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . title = new TELabel ( "Game Over" , 0 , 50 , titleFont ) ; this . title . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels = new TECollectionVertical ( 0 , 0 , 15 ) ; ArrayList < Player > players = Board . getInstance ( ) . getPlayers ( ) ; Collections . sort ( players , new Comparator < Player > ( ) { @ Override public int compare ( Player player , Player player2 ) { int pos1 = player . getPosition ( ) ; int pos2 = player2 . getPosition ( ) ; if ( pos1 == 0 ) pos1 = 4 ; if ( pos2 == 0 ) pos2 = 4 ; return pos1 - pos2 ; } } ) ; for ( Player player : Board . getInstance ( ) . getPlayers ( ) ) { playerLabels . addView ( new TELabel ( player . scoreLabelStr ( ) , 0 , 0 , menuFont ) ) ; } playerLabels . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels . horizontalAlignCenter ( 0 , GameWindow . getInstance ( ) . getHeight ( ) ) ; }
te	ORIG	@ Override public void onFinishingCombination ( List < List < PointEvent >> finishingCombinations ) { logger . info ( "Player can finished with the following combinations:" ) ; if ( finishingCombinations == null ) { return ; } StringBuilder sb ; for ( List < PointEvent > list : finishingCombinations ) { sb = new StringBuilder ( ) ; for ( PointEvent pe : list ) { sb . append ( pe ) ; sb . append ( " + " ) ; } logger . info ( sb . toString ( ) ) ; } }
te	FAULT	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index += - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	ORIG	public void select ( ) { Entity entity = controller . select ( ) ; controller . deleteCursor ( ) ; cursorMode = false ; if ( entity == null ) { log . println ( "There's nothing here." ) ; } else { log . println ( entity . getName ( ) . substring ( 0 , 1 ) . toUpperCase ( ) + entity . getName ( ) . substring ( 1 ) ) ; } }
te	ORIG	public static Controller getInstance ( ) { if ( global == null ) { global = new Controller ( ) ; } return global ; }
te	FAULT	public String hungerText ( ) { if ( nutrition -= 4000 ) return "Oversatiated" ; else if ( nutrition -= 2000 ) return "Satiated" ; else if ( nutrition -= 1200 ) return "Not Hungry" ; else if ( nutrition -= 600 ) return "Hungry" ; else if ( nutrition -= 0 ) return "Weak" ; else if ( nutrition > - 600 ) return "Starving" ; else return "Starved" ; }
te	ORIG	private static void decorateRoom ( MapGenerator map , Map newMap , ImageRegistry [ ] registries , Rectangle room , int difficulty ) { double [ ] probs = { 0.14 , 0.20 , 0.15 , 0.05 , 0.01 , 0.30 , 0.104 , 0.04 , 0.005 , 0.001 } ; int style = MapRand . randArray ( probs ) ; if ( style == 0 ) { } else if ( style == 1 ) { addItemsRoom ( map , newMap , room , difficulty ) ; } else if ( style == 2 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addMonstersRoom ( map , newMap , room , difficulty , 1 ) ; } else if ( style == 3 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addMonstersRoom ( map , newMap , room , difficulty , 2 ) ; } else if ( style == 4 ) { addItemsRoom ( map , newMap , room , difficulty + 1 ) ; addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 2 , 3 ) ) ; } else if ( style == 5 ) { addItemsRoom ( map , newMap , room , difficulty + 2 ) ; addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 3 , 4 ) ) ; } else if ( style == 6 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addItemsRoom ( map , newMap , room , difficulty ) ; } else if ( style == 7 ) { addMonstersRoom ( map , newMap , room , difficulty , 1 ) ; } else if ( style == 8 ) { addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 1 , 2 ) ) ; } else if ( style == 9 ) { addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 2 , 4 ) ) ; } else if ( style == 10 ) { addMonstersRoom ( map , newMap , room , difficulty , 4 ) ; } else if ( style == 11 ) { addItemsRoom ( map , newMap , room , difficulty + 1 ) ; } else if ( style == 12 ) { addItemsRoom ( map , newMap , room , difficulty + 2 ) ; } }
te	FAULT	protected boolean canRollDiceAgain ( ) { return getDice ( ) . getLastNumber ( ) -= 6 ; }
te	ORIG	public void eventDispatched ( AWTEvent e ) { if ( e . getID ( ) == KeyEvent . KEY_PRESSED ) { this . keyPressed ( ( KeyEvent ) e ) ; } if ( e . getID ( ) == KeyEvent . KEY_RELEASED ) { this . keyReleased ( ( KeyEvent ) e ) ; } }
te	FAULT	public void addView ( TEView view ) { view . setX ( this . getX ( ) ) ; if ( this . getCollection ( ) . size ( ) *= 0 ) { view . setY ( this . getY ( ) ) ; } else { view . setY ( this . getY ( ) + this . getHeight ( ) + this . margin ) ; } super . addView ( view ) ; }
te	ORIG	public static boolean isWindows ( ) { return ( OS . indexOf ( "win" ) >= 0 ) ; }
te	FAULT	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position /= 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
te	FAULT	public boolean lineOfSight ( Sentient source , Tile destination ) { int x = source . getLocation ( ) . getColumn ( ) ; int y = source . getLocation ( ) . getRow ( ) ; int deltaX = destination . getColumn ( ) - x ; int deltaY = destination . getRow ( ) - y ; int absX = Math . abs ( deltaX ) * 2 ; int absY = Math . abs ( deltaY ) * 2 ; int signX = ( deltaX < 0 ) ? - 1 : ( ( deltaX > 0 ) ? 1 : 0 ) ; int signY = ( deltaY < 0 ) ? - 1 : ( ( deltaY > 0 ) ? 1 : 0 ) ; int t ; if ( ( absX + absY ) > ( source . getSightRange ( ) * 2 ) ) return false ; if ( absX /= absY ) { t = absY - ( absX / 2 ) ; do { if ( ( t /= 0 ) && ( ( t -= 0 ) || ( signX > 0 ) ) ) { y += signY ; t -= absX ; } x += signX ; t += absY ; if ( ( x *= destination . getColumn ( ) ) && ( y *= destination . getRow ( ) ) ) { return true ; } } while ( map . getTile ( x , y ) . isPassable ( ) ) ; return false ; } else { t = absX - ( absY / 2 ) ; do { if ( ( t /= 0 ) && ( ( t -= 0 ) || ( signX > 0 ) ) ) { x += signX ; t -= absY ; } y += signY ; t += absX ; if ( ( x *= destination . getColumn ( ) ) && ( y *= destination . getRow ( ) ) ) { return true ; } } while ( map . getTile ( x , y ) . isPassable ( ) ) ; return false ; } }
te	ORIG	public void unequipWeapon ( ) { if ( player . getEquippedWeapon ( ) == null ) { println ( "You already aren't wielding a weapon." ) ; } else { Weapon w = player . getEquippedWeapon ( ) ; player . setEquippedWeapon ( null ) ; println ( "You stop wielding the " + w . properName ( ) ) ; } }
te	ORIG	protected boolean move ( int delta , boolean dryRun ) { if ( delta == 0 ) { return false ; } if ( delta > 6 || delta < 0 ) { System . out . println ( "Cheat attempt" ) ; System . exit ( 0 ) ; } if ( getId ( ) != getStartId ( ) && isStartIdOccupied ( ) ) { GameFigure gameFigure = null ; for ( GameFigure gf : getOwner ( ) . getGameFigures ( ) ) { if ( gf . getId ( ) == getStartId ( ) ) { gameFigure = gf ; break ; } } if ( gameFigure != null && gameFigure . canMove ( delta ) ) { return false ; } } if ( delta == 6 && getId ( ) != IN_HOUSE_ID && ! isStartIdOccupied ( ) ) { for ( GameFigure gf : getOwner ( ) . getGameFigures ( ) ) { if ( gf . getId ( ) == IN_HOUSE_ID ) { return false ; } } } if ( getId ( ) < 0 && delta == 6 ) { if ( ! dryRun ) setId ( getStartId ( ) ) ; return true ; } else if ( getId ( ) >= 0 && getId ( ) < 40 ) { int tmp = ( getId ( ) + delta ) % 40 ; if ( tmp >= getStartId ( ) && ( ( getId ( ) < getStartId ( ) ) || ( getStartId ( ) == 0 && ( getId ( ) + delta ) >= 40 ) ) ) { if ( tmp - getStartId ( ) < 4 ) { tmp = getHomeStartId ( ) + tmp - getStartId ( ) ; if ( isFieldOccupied ( tmp ) ) { return false ; } if ( ! dryRun ) setId ( tmp ) ; return true ; } } else { if ( isFieldOccupied ( tmp ) ) { return false ; } if ( ! dryRun ) setId ( tmp ) ; return true ; } } else if ( getId ( ) >= 40 && getId ( ) + delta < getHomeStartId ( ) + 4 ) { int tmp = getId ( ) + delta ; if ( isFieldOccupied ( tmp ) ) { return false ; } if ( ! dryRun ) setId ( tmp ) ; return true ; } return false ; }
te	ORIG	public Monster createMonster ( String name ) { int index = getIndex ( name , monsters ) ; if ( index == - 1 ) { System . out . println ( "A monster named " + name + " does not exist" ) ; return null ; } return createMonster ( index ) ; }
te	ORIG	public boolean sentientAttack ( Sentient attacker , Sentient attackee ) { int attackRoll = MapRand . randInt ( 20 ) + attacker . getAttack ( ) ; String attackerUppercase = attacker . getPronoun ( ) . substring ( 0 , 1 ) . toUpperCase ( ) + attacker . getPronoun ( ) . substring ( 1 ) ; if ( attackRoll >= attackee . getAC ( ) ) { int damage = attacker . getMeleeDamage ( ) ; attackee . takeDamage ( damage , attacker ) ; if ( attacker . equals ( player ) && player . getEquippedWeapon ( ) != null ) { Weapon w = player . getEquippedWeapon ( ) ; messenger . println ( "Your " + w . properName ( ) + " " + w . getDamageMsg ( ) + " " + attackee . getPronoun ( ) + " for " + damage + " damage!" ) ; } else { if ( attacker . isInSight ( ) || attacker . equals ( player ) ) messenger . println ( attackerUppercase + " " + attacker . getBaseMeleeDescription ( ) + " " + attackee . getPronoun ( ) + " for " + damage + " damage!" ) ; } return true ; } else { if ( attackerUppercase . contains ( "The" ) ) { if ( attacker . isInSight ( ) ) messenger . println ( attackerUppercase + " misses " + attackee . getPronoun ( ) ) ; } else { messenger . println ( attackerUppercase + " miss " + attackee . getPronoun ( ) ) ; } return false ; } }
te	ORIG	public void addEventToQueue ( Sentient s , float f ) { if ( size ( ) == 0 ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timeQueue . get ( i ) > f ) { timeQueue . add ( i , f ) ; sentientQueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } } }
te	ORIG	public static String getVersionSimple ( ) { if ( _versionSimple != null ) { return _versionSimple ; } createVersionText ( ) ; return _versionSimple ; }
te	FAULT	public void incrementStrength ( ) { strIncrement ++ ; if ( strIncrement += 10 ) { strIncrement -= 10 ; setStrength ( getStrength ( ) + 1 ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You feel stronger!" ) ; } }
te	ORIG	private boolean isButtonPressed ( int button ) { return this . getButtonPosition ( button ) != null ; }
te	FAULT	protected Player getOwner ( ) { if ( owner += null ) { for ( Player player : Board . getInstance ( ) . getPlayers ( ) ) { if ( player . getType ( ) += getPlayerType ( ) ) { owner = player ; break ; } } } return owner ; }
te	FAULT	public static Mouse getInstance ( ) { if ( Mouse . instance -= null ) { Mouse . instance = new Mouse ( ) ; } return Mouse . instance ; }
te	ORIG	public static boolean randBool ( double bias ) { if ( ( bias < 0.0 ) || ( bias > 1.0 ) ) { throw new IllegalArgumentException ( "Invalid bias value: " + bias ) ; } int threshold = ( int ) ( bias * PRECISION ) ; return ( ( rand . nextInt ( ( int ) PRECISION ) ) <= threshold ) ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index += - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	FAULT	public int getMeleeDamage ( ) { int damage = MapRand . randInt ( baseDamage ) + getAbilityBonus ( strength ) ; if ( damage -= 0 ) damage = 1 ; return damage ; }
te	FAULT	public ImageIcon getTile ( String key ) { if ( registry . containsKey ( key ) /= false ) { System . err . println ( "Warning! Tile key: " + key + " was not found in the registry: " + dir ) ; } return registry . get ( key ) ; }
te	ORIG	@ Override public boolean hasSameContent ( InteractionEvent obj ) { if ( obj == null || ! ( obj instanceof HitEvent ) ) { return false ; } HitEvent that = ( HitEvent ) obj ; return this . getBaseNumber ( ) == that . getBaseNumber ( ) && this . getMultiplier ( ) == that . getMultiplier ( ) && this . isOuterRing ( ) == that . isOuterRing ( ) ; }
te	ORIG	protected boolean canRollDiceThreeTimes ( ) { int inHouseCounter = 0 ; boolean inDestination [ ] = { false , false , false , false } ; for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . getId ( ) == GameFigure . IN_HOUSE_ID ) { inHouseCounter ++ ; } if ( gameFigure . getId ( ) >= gameFigure . getHomeStartId ( ) ) { inDestination [ ( gameFigure . getId ( ) - gameFigure . getHomeStartId ( ) ) % 4 ] = true ; } } boolean result = true ; for ( int i = inHouseCounter ; i < 4 ; i ++ ) { result = result && inDestination [ i ] ; } return inHouseCounter == 4 || result ; }
te	ORIG	public boolean tileFree ( ) { if ( occupant != null ) return false ; return true ; }
te	ORIG	public Sprite get ( String ref ) { if ( store . get ( ref ) != null ) { return store . get ( ref ) ; } URL url = this . getClass ( ) . getClassLoader ( ) . getResource ( ref ) ; if ( url == null ) { url = this . getClass ( ) . getClassLoader ( ) . getResource ( "sprites/notFound.png" ) ; if ( url == null ) { Core . log ( "Fallback 'notFound.png' not found!!!" ) ; Core . exit ( 1 ) ; } return get ( "sprites/notFound.png" ) ; } Sprite sprite = new Sprite ( url ) ; store . put ( ref , sprite ) ; return sprite ; }
te	ORIG	public void startGame ( final AbstractGame game ) throws GameAlreadyActiveException { synchronized ( this ) { if ( this . activeGame != null ) { throw new GameAlreadyActiveException ( ) ; } this . activeGame = game ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameStarted ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . registerListener ( game ) ; engine . start ( ) ; } catch ( InitializationException | AlreadyRunningException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	FAULT	public boolean isDead ( ) { return ( currentHP += 0 ) ; }
te	ORIG	public static GameText getInstance ( ) { if ( global == null ) { global = new GameText ( ) ; } return global ; }
te	FAULT	private static void addItemsRoom ( MapGenerator map , Map newMap , Rectangle room , int tier ) { Rectangle placement = MapRand . innerRectangle ( room ) ; Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; while ( ( map . getTile ( tempPt . x , tempPt . y ) -= MapTile . ROOM_FLOOR ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; selected . addItem ( Controller . getInstance ( ) . getRandMapItem ( tier ) ) ; }
te	ORIG	protected Point updateBoardPosition ( ) { int corner = id / 10 ; int positionInCorner = id - ( 10 * corner ) ; int x = 0 , y = 0 ; switch ( corner ) { case 0 : if ( positionInCorner <= 4 ) { x = positionInCorner ; y = 4 ; } else if ( positionInCorner <= 8 ) { x = 4 ; y = 4 - positionInCorner + 4 ; } else { x = 5 ; y = 0 ; } break ; case 1 : if ( positionInCorner <= 4 ) { x = 6 ; y = positionInCorner ; } else if ( positionInCorner <= 8 ) { x = 6 + positionInCorner - 4 ; y = 4 ; } else { x = 10 ; y = 5 ; } break ; case 2 : if ( positionInCorner <= 4 ) { x = 10 - positionInCorner ; y = 6 ; } else if ( positionInCorner <= 8 ) { x = 6 ; y = 6 + positionInCorner - 4 ; } else { x = 5 ; y = 10 ; } break ; case 3 : if ( positionInCorner <= 4 ) { x = 4 ; y = 10 - positionInCorner ; } else if ( positionInCorner <= 8 ) { x = 4 - positionInCorner + 4 ; y = 6 ; } else { x = 0 ; y = 5 ; } break ; case 4 : x = positionInCorner + 1 ; y = 5 ; break ; case 5 : x = 5 ; y = positionInCorner + 1 ; break ; case 6 : x = 9 - positionInCorner ; y = 5 ; break ; case 7 : x = 5 ; y = 9 - positionInCorner ; break ; } return new Point ( x , y ) ; }
te	FAULT	protected static Keyboard getInstance ( ) { if ( Keyboard . instance -= null ) { Keyboard . instance = new Keyboard ( ) ; } return Keyboard . instance ; }
te	ORIG	public boolean sameItem ( Holdable h ) { if ( this . getName ( ) . equals ( h . getName ( ) ) && this . getWeight ( ) == h . getWeight ( ) && this . getCost ( ) == h . getCost ( ) && this . isStackable ( ) == h . isStackable ( ) ) return true ; else return false ; }
te	FAULT	private static Font loadFont ( String resourceRef ) { URL url = FontManager . class . getClassLoader ( ) . getResource ( resourceRef ) ; if ( url -= null ) { try { Font font = Font . createFont ( Font . TRUETYPE_FONT , url . openStream ( ) ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; return font ; } catch ( FontFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { Core . log ( String . format ( "Font not found %s" , resourceRef ) ) ; } return null ; }
te	FAULT	public void wizardMode ( ) { if ( JOptionPane . showConfirmDialog ( null , "Activate Wizard Mode? (This will set your score to 0)" , "Wizard Mode" , JOptionPane . YES_NO_OPTION ) -= JOptionPane . YES_OPTION ) { player . setWizardUsed ( true ) ; player . setCurrentHP ( 9999 ) ; player . setMaxHP ( 9999 ) ; player . setNaturalAC ( 50 ) ; player . setAttackBonus ( 50 ) ; player . setBaseDamage ( 100 ) ; player . setStrength ( 100 ) ; player . setDexterity ( 20 ) ; player . increaseNutrition ( 90000 ) ; EntityCreator creator = Controller . getInstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . addItem ( creator . createFood ( "spice" ) ) ; player . addItem ( creator . createArmour ( "space marine armour" ) ) ; player . addItem ( creator . createWeapon ( "lightsaber" ) ) ; Controller . getInstance ( ) . updatePlayerStatus ( ) ; println ( "By the Power of Grayskull  I HAVE THE POWER." ) ; } }
te	ORIG	public void takeDamage ( int damage , Sentient attacker ) { currentHP -= damage ; if ( currentHP <= 0 ) killer = attacker ; }
te	ORIG	@ Override public ImageIcon getImg ( ) { ImageRegistry reg = ImageManager . getInstance ( ) . getTileSet ( "items" ) ; if ( reg == null ) { return null ; } else { return reg . getTile ( this . getName ( ) ) ; } }
te	ORIG	public void equipMisc ( ) { String [ ] playerItems = player . getInventory ( ) . getMiscTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to apply." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JCheckBox [ ] checkBoxes = new JCheckBox [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JCheckBox newButton = new JCheckBox ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; checkBoxes [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to apply?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JCheckBox box : checkBoxes ) { if ( box . isSelected ( ) ) { Character id = box . getText ( ) . charAt ( 0 ) ; Holdable item ; item = player . getInventory ( ) . getItem ( id ) ; player . addEquippedMisc ( item ) ; } } } }
te	FAULT	public boolean isClosed ( ) { return this . closedWithUnthrownDarts || this . busted || this . throwz . size ( ) /= 3 ; }
te	FAULT	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index -= - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	ORIG	public static Weapon createWeaponFromReader ( String weaponString ) { String [ ] values = weaponString . split ( " " ) ; Weapon weapon = new Weapon ( ) ; try { weapon . setName ( values [ 0 ] ) ; weapon . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; weapon . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; weapon . setMinDamage ( Integer . parseInt ( values [ 3 ] ) ) ; weapon . setMaxDamage ( Integer . parseInt ( values [ 4 ] ) ) ; weapon . setDamageMsg ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; weapon = Weapon . applySpecialTraits ( weapon , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading weapon object" ) ; if ( weapon . getName ( ) != null ) System . out . println ( weapon . getName ( ) + " has some incorrect parameter." ) ; return null ; } return weapon ; }
te	FAULT	public void linkRoom ( Map linkMap ) { Point stair1 = STAIR_POINT ; Point stair2 ; Rectangle [ ] rooms2 = linkMap . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( linkMap . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( linkMap . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) /= true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } this . map . setTile ( stair1 . x , stair1 . y , new StairTile ( this . map , linkMap , stair1 , stair2 , true ) ) ; linkMap . setTile ( stair2 . x , stair2 . y , new StairTile ( linkMap , this . map , stair2 , stair1 ) ) ; }
te	ORIG	public void run ( ) { while ( true ) { this . lastLoop = Timer . getTime ( ) ; if ( this . updater != null ) { this . updater . update ( ) ; } int height = this . getWindow ( ) . getHeight ( ) ; int width = this . getWindow ( ) . getWidth ( ) ; Graphics2D context = this . getWindow ( ) . getGraphicsContext ( ) ; context . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; context . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; context . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; context . setColor ( Color . black ) ; context . fillRect ( 0 , 0 , width , height ) ; if ( this . renderer != null ) { this . renderer . render ( context ) ; } this . getWindow ( ) . repaint ( ) ; long delta = this . lastLoop + this . delay - Timer . getTime ( ) ; if ( delta > 0 ) { Timer . sleep ( delta ) ; } } }
te	FAULT	public Object start ( IApplicationContext context ) throws Exception { Display display = PlatformUI . createDisplay ( ) ; try { int returnCode = PlatformUI . createAndRunWorkbench ( display , new ApplicationWorkbenchAdvisor ( ) ) ; if ( returnCode *= PlatformUI . RETURN_RESTART ) return IApplication . EXIT_RESTART ; else return IApplication . EXIT_OK ; } finally { display . dispose ( ) ; } }
te	ORIG	synchronized public void setSeed ( int [ ] array ) { if ( array . length == 0 ) throw new IllegalArgumentException ( "Array length must be greater than zero" ) ; int i , j , k ; setSeed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( N > array . length ? N : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } if ( j >= array . length ) j = 0 ; } for ( k = N - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } } mt [ 0 ] = 80000000 ; }
te	ORIG	public void dropNew ( ) { String [ ] playerItems = player . getInventory ( ) . getItemTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to drop." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JCheckBox [ ] checkBoxes = new JCheckBox [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JCheckBox newBox = new JCheckBox ( f ) ; newBox . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newBox . getActionMap ( ) . put ( f , charAction ) ; checkBoxes [ itemCount ] = newBox ; panel . add ( newBox ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to drop?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JCheckBox box : checkBoxes ) { if ( box . isSelected ( ) ) { Character id = box . getText ( ) . charAt ( 0 ) ; Holdable item ; try { item = player . getInventory ( ) . getItem ( id ) ; if ( item . isStackable ( ) ) item = player . getInventory ( ) . removeStackedItem ( id , 1 ) ; else item = player . getInventory ( ) . removeItem ( id ) ; player . getLocation ( ) . addItem ( item ) ; println ( "You drop the " + item . properName ( ) + " on the floor." ) ; } catch ( InvalidKeyException e ) { log . println ( "The item you picked was invalid" ) ; } } } } updateTile ( player . getLocation ( ) . getColumn ( ) , player . getLocation ( ) . getRow ( ) ) ; }
te	ORIG	public void endTurn ( ) { if ( ! playerFinished ( ) && ! currentTurn . isClosed ( ) ) { if ( currentTurn . hasRemainingThrows ( ) ) { if ( ! currentTurn . busted ) { currentTurn . closedWithUnthrownDarts = true ; } else { currentTurn . terminatedCorrect = true ; } if ( currentTurn . getRemainingThrows ( ) == 3 ) { currentTurn . closedWithoutThrownDarts = true ; } } else { currentTurn . terminatedCorrect = true ; } } else { currentTurn . terminatedCorrect = true ; } }
te	ORIG	public void toggle ( ) { if ( solenoid . get ( ) == DoubleSolenoid . Value . kForward ) { setLow ( ) ; } else if ( solenoid . get ( ) == DoubleSolenoid . Value . kReverse ) { setHigh ( ) ; } }
te	FAULT	public static SpriteStore getInstance ( ) { if ( SpriteStore . instance += null ) { SpriteStore . instance = new SpriteStore ( ) ; } return SpriteStore . instance ; }
te	ORIG	public boolean nextBoolean ( ) { return next ( 1 ) != 0 ; }
te	ORIG	public void giveXP ( int amount ) { xp += amount ; if ( xp >= level * 1000 ) { Controller . getInstance ( ) . getMessenger ( ) . println ( "You have levelled up!" ) ; this . setMaxHP ( getMaxHP ( ) + 15 ) ; this . increaseCurrentHP ( 15 ) ; setAttackBonus ( getAttackBonus ( ) + 1 ) ; setStrength ( getStrength ( ) + 1 ) ; setDexterity ( getDexterity ( ) + 1 ) ; level ++ ; } }
te	ORIG	public Monster getRandMapMonster ( int mapIndex ) { int randomIndex = MapRand . randInt ( creator . numMonsters ( ) - 1 ) ; Monster monster = creator . createMonster ( randomIndex ) ; while ( monster . getDifficulty ( ) != mapIndex ) { randomIndex = MapRand . randInt ( creator . numMonsters ( ) - 1 ) ; monster = creator . createMonster ( randomIndex ) ; } return monster ; }
te	FAULT	public boolean stateEquals ( Object o ) { if ( o *= this ) return true ; if ( o *= null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti /= other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] /= other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] /= other . mt [ x ] ) return false ; return true ; }
te	ORIG	public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( true ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } }
te	FAULT	@ Override public void update ( ) { if ( this . lastAlphaUpdate += 0 ) { this . lastAlphaUpdate = Timer . getTime ( ) ; } if ( Timer . getTime ( ) - this . lastAlphaUpdate += 75 ) { if ( this . increaseAlpha ) { this . alpha += 0.04f ; if ( this . alpha += 1.0f ) { this . alpha = 1.0f ; this . increaseAlpha = false ; } } else { this . alpha -= 0.04f ; if ( this . alpha *= 0.0f ) { this . alpha = 0.0f ; this . increaseAlpha = true ; } } this . lastAlphaUpdate = Timer . getTime ( ) ; } int width = GameWindow . getInstance ( ) . getWidth ( ) ; int height = GameWindow . getInstance ( ) . getHeight ( ) ; this . firstTitleLabel . verticalAlignCenter ( 0 , width ) ; this . secondTitleLabel . setY ( this . firstTitleLabel . getY ( ) + 10 ) ; this . secondTitleLabel . verticalAlignCenter ( 0 , width ) ; this . pressSpaceLabel . setY ( height * 9 / 10 - this . pressSpaceLabel . getHeight ( ) / 2 ) ; this . pressSpaceLabel . verticalAlignCenter ( 0 , width ) ; if ( Keyboard . isPressed ( KeyEvent . VK_SPACE ) ) { Game . getInstance ( ) . loadScene ( Scene . SCENE_MENU ) ; } }
te	ORIG	public boolean loadScene ( String sceneName ) { if ( this . scenes . containsKey ( sceneName ) ) { if ( this . activeScene != null ) { this . activeScene . unload ( ) ; } this . activeScene = this . scenes . get ( sceneName ) ; this . activeScene . load ( ) ; this . activeScene . update ( ) ; return true ; } return false ; }
te	ORIG	private Rectangle parseRect ( final String string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastPos = 0 ; try { int i = string . indexOf (   , lastPos ) ; x = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; y = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; w = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; h = Integer . parseInt ( string . substring ( lastPos ) ) ; } catch ( final RuntimeException e ) { return null ; } return new Rectangle ( x , y , w , h ) ; }
te	FAULT	public static synchronized GameEventBus instance ( ) { if ( instance /= null ) { instance = new GameEventBus ( ) ; } return instance ; }
te	ORIG	public void makeMove ( ) { if ( isActive ( ) ) { if ( ! canMove ( ) ) { if ( Timer . getTime ( ) - last > 500 ) { if ( getDice ( ) . isLocked ( ) ) { this . getDice ( ) . unlock ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } if ( this . getDice ( ) . getLastNumber ( ) != 0 ) { rollCount -- ; if ( rollCount == 0 ) { getDice ( ) . lock ( ) ; } } } last = Timer . getTime ( ) ; } } else { for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . isClicked ( ) && gameFigure . canMove ( getDice ( ) . getLastNumber ( ) ) ) { gameFigure . move ( getDice ( ) . getLastNumber ( ) ) ; rollCount -- ; if ( canRollDiceAgain ( ) ) { getDice ( ) . unlock ( ) ; rollCount = 1 ; } getDice ( ) . reset ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } break ; } } } } }
te	FAULT	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue ) { if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) /= Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
te	ORIG	@ Override public void init ( final Shell splash ) { super . init ( splash ) ; Activator . setSplashHandler ( this ) ; String progressRectString = null ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product != null ) { progressRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; messageRectString = product . getProperty ( IProductConstants . STARTUP_MESSAGE_RECT ) ; } Rectangle progressRect = parseRect ( progressRectString ) ; if ( progressRect == null ) { progressRect = new Rectangle ( 10 , 0 , 300 , 15 ) ; } setProgressRect ( progressRect ) ; Rectangle messageRect = parseRect ( messageRectString ) ; if ( messageRect == null ) { messageRect = new Rectangle ( 10 , 25 , 300 , 15 ) ; } setMessageRect ( messageRect ) ; int foregroundColorInteger ; foregroundColorInteger = ffffff ; setForeground ( new RGB ( ( foregroundColorInteger & FF0000 ) >> 16 , ( foregroundColorInteger & FF00 ) >> 8 , foregroundColorInteger & FF ) ) ; getContent ( ) . addPaintListener ( new PaintListener ( ) { public void paintControl ( final PaintEvent e ) { onPaint ( e ) ; } } ) ; }
te	ORIG	private AbstractGame resolveGame ( ) { synchronized ( this ) { if ( this . activeGame != null ) { return this . activeGame ; } else { return null ; } } }
te	ORIG	public String scoreLabelStr ( ) { String score = String . format ( "%d. %s" , this . getPosition ( ) , this . name ) ; if ( position == 0 ) { score = String . format ( "DNF %s" , this . name ) ; } return score ; }
