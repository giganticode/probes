tr	FAULT	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures += loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	ORIG	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	FAULT	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) -= 0 ) return ( "" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex /= null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex /= null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf -= null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx /= mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	FAULT	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months -= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = rset . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx /= 0 ) delItem ( idx ) ; }
tr	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	ORIG	public String getShotDateStr ( ) { if ( shotdate . getTime ( ) == 0 ) return ( "" ) ; return ( mdyfmt . format ( shotdate ) ) ; }
tr	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	FAULT	public String getBirthDateStr ( ) { if ( birthdate += null || birthdate . getTime ( ) += 0 ) { return ( "" ) ; } return ( dtfmt . format ( birthdate ) ) ; }
tr	FAULT	private static String left ( Date date , int length ) { if ( date *= null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , length ) ; }
tr	ORIG	public String getFC1RunDtStr ( ) { if ( fc1rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc1rundt ) ) ; }
tr	FAULT	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) -= 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	ORIG	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
tr	FAULT	public Connection getConnection ( ) { if ( theConnection -= null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	ORIG	protected void saveDoseResult ( Connection aconn , CTestItem atestcase , String astr ) throws Exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; CDosevItem evitem = null ; String rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { String pairbuf = CParser . getToken ( rembuf , "^" ) ; rembuf = CParser . getRemnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } String tagstr = CParser . getToken ( pairbuf , "~" ) ; String valstr = CParser . getRemnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } evitem = new CDosevItem ( ) ; evitem . shotid = atestcase . dosevlist . makeNewId ( "sht" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = Integer . parseInt ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapCode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	FAULT	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount *= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	FAULT	public void run ( ) { if ( fcrunoption -= CAppConsts . RunFC1 || fcrunoption -= CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption -= CAppConsts . RunFC2 || fcrunoption -= CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	FAULT	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn += null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	ORIG	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass += null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName += null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword += null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn += null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( ltop ) ; }
tr	FAULT	private int getIntVal ( String sval ) { if ( sval -= null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public final void readConfig ( String acfg ) { try { FileReader frd = new FileReader ( acfg ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTestQry" ) ) dbTestQry = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; else if ( fldtoken . equals ( "dbPoolInit" ) ) dbPoolInit = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolMax" ) ) dbPoolMax = Integer . parseInt ( value ) ; else if ( fldtoken . equals ( "dbPoolIdleMax" ) ) dbPoolIdleMax = Integer . parseInt ( value ) ; if ( dbPoolIdleMax < dbPoolInit ) dbPoolIdleMax = dbPoolInit ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConfig.readConfig failed " , ex ) ; } }
tr	FAULT	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem -= null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	FAULT	public synchronized void returnConnection ( Connection aconn ) { if ( aconn *= null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	ORIG	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	FAULT	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr *= bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	FAULT	public String getString ( int aidx ) { if ( aidx *= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	FAULT	public String getFC2RunDtStr ( ) { if ( fc2rundt += null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	ORIG	public void setRecomDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) recomdate = new Date ( 0 ) ; else recomdate = dtfmt . parse ( aval ) ; }
tr	ORIG	public String getFC1ResultStr ( ) { if ( fc1result == null ) { return ( "" ) ; } return ( fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	FAULT	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes += null || abytes . length += 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	FAULT	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	FAULT	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) -= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	ORIG	public void readConfig ( String aconf , String aerr , boolean aecho ) { try { FileReader frd = new FileReader ( aconf ) ; BufferedReader finp = new BufferedReader ( frd ) ; String buf = "#" ; while ( buf != null ) { buf = finp . readLine ( ) ; if ( buf == null ) break ; buf = buf . trim ( ) ; if ( buf . length ( ) < 1 ) continue ; if ( buf . substring ( 0 , 1 ) . equals ( "#" ) ) continue ; int sep = buf . indexOf ( "=" ) ; if ( sep < 0 ) continue ; String fldtoken = buf . substring ( 0 , sep ) ; String value = buf . substring ( sep + 1 ) ; if ( fldtoken . equals ( "dbClassNm" ) ) dbClassNm = value ; else if ( fldtoken . equals ( "dbDriver" ) ) dbDriver = value ; else if ( fldtoken . equals ( "dbHost" ) ) dbHost = value ; else if ( fldtoken . equals ( "dbPortSep" ) ) dbPortSep = value ; else if ( fldtoken . equals ( "dbPort" ) ) dbPort = value ; else if ( fldtoken . equals ( "dbUrlSep" ) ) dbUrlSep = value ; else if ( fldtoken . equals ( "dbDatabase" ) ) dbDatabase = value ; else if ( fldtoken . equals ( "dbTableNm" ) ) dbTableNm = value ; else if ( fldtoken . equals ( "dbProps" ) ) dbProps = value ; else if ( fldtoken . equals ( "dbUserPath" ) ) dbUserPath = value ; } dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; if ( ! dbUserPath . equals ( "" ) ) { FileReader prd = new FileReader ( dbUserPath ) ; BufferedReader pinp = new BufferedReader ( prd ) ; String rawuser = pinp . readLine ( ) ; String rawpass = pinp . readLine ( ) ; pinp . close ( ) ; String dbUserKey = "dbUrl=dbDriver+dbHost+dbPortSep+dbPort+dbUrlSep+dbDatabase" ; String keystr = crypto . CMd5Hash . toHash ( dbUserKey ) ; Key mykey = crypto . CAesEncrypt . getKey ( keystr ) ; dbUserName = crypto . CAesEncrypt . decrypt ( mykey , rawuser ) ; dbPassword = crypto . CAesEncrypt . decrypt ( mykey , rawpass ) ; } finp . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( aerr , aecho , "CDbConfig.readConfig failed " , ex ) ; } }
tr	FAULT	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) += 0 ) { return ( "" ) ; } CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord += this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) += this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) += this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) += this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	ORIG	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( aidx , aobj ) ; }
tr	FAULT	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) -= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	FAULT	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) += - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	FAULT	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx *= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	FAULT	private int getIntVal ( String sval ) { if ( sval -= null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	FAULT	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) += 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	ORIG	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
va	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
va	ORIG	long write ( OutputStream out ) throws IOException { long size = 0 ; int read ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
va	FAULT	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName -= null ) { size = write ( out ) ; } return size ; }
va	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session *= null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props *= null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt *= null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt *= null && btntxt . equals ( "Save" ) ) { System . out . println ( "save request= " + request ) ; CTestItem testcase = ( CTestItem ) session . getAttribute ( "TestCase" ) ; try { testcase . updateItem ( request ) ; if ( CAppConsts . TagNoValue . equals ( testcase . testgroupid ) ) { session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } Connection conn = dbconnman . getConnection ( ) ; testcase . dbWriteItem ( conn ) ; testcase . dbWriteDetail ( conn ) ; dbconnman . returnConnection ( conn ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.updateItem " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
va	ORIG	public String getModDateStr ( ) { if ( moddate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
va	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
va	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx -= 0 ; idx -- ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { this . delItem ( idx ) ; continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = Math . max ( 1 , 3 - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CTextItem myitem = new CTextItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expectid = this . makeNewId ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . addItem ( myitem . expectid , myitem ) ; } }
va	FAULT	public String getFC2ResultStr ( ) { if ( fc2result /= null ) { return ( "" ) ; } return ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
va	ORIG	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
va	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { String group = arequest . getParameter ( "TestGroup" ) ; if ( group -= null ) { testgroupid = group ; } testtitle = CParser . truncStr ( arequest . getParameter ( "TestTitle" ) , CAppConsts . MaxLenTitle ) ; testdesc = CParser . truncStr ( arequest . getParameter ( "TestDesc" ) , CAppConsts . MaxLenNote ) ; testnote = CParser . truncStr ( arequest . getParameter ( "TestNote" ) , CAppConsts . MaxLenNote ) ; testreqid = CParser . truncStr ( arequest . getParameter ( "TestReqID" ) , CAppConsts . MaxLenTitle ) ; casesource = CParser . truncStr ( arequest . getParameter ( "CaseSource" ) , CAppConsts . MaxLenNote ) ; lastname = CParser . truncStr ( arequest . getParameter ( "LastName" ) , CAppConsts . MaxLenName ) ; firstname = CParser . truncStr ( arequest . getParameter ( "FirstName" ) , CAppConsts . MaxLenName ) ; String datstr = CParser . truncStr ( arequest . getParameter ( "BaseDate" ) , CAppConsts . MaxLenDate ) ; setBaseDate ( datstr ) ; gendercd = arequest . getParameter ( "Gender" ) ; datstr = CParser . truncStr ( arequest . getParameter ( "BirthDate" ) , CAppConsts . MaxLenDate ) ; setBirthDate ( datstr ) ; ageyears = getIntVal ( arequest . getParameter ( "AgeYrs" ) ) ; agemonths = getIntVal ( arequest . getParameter ( "AgeMos" ) ) ; ageweeks = getIntVal ( arequest . getParameter ( "AgeWks" ) ) ; agedays = getIntVal ( arequest . getParameter ( "AgeDays" ) ) ; agemethod = arequest . getParameter ( "AgeMethod" ) ; moddate = new Date ( ) ; createby = CParser . truncStr ( arequest . getParameter ( "CreateBy" ) , CAppConsts . MaxLenName ) ; datstr = CParser . truncStr ( arequest . getParameter ( "CreateDate" ) , CAppConsts . MaxLenDate ) ; setCreateDate ( datstr ) ; resultnotes = CParser . truncStr ( arequest . getParameter ( "ResNotes" ) , CAppConsts . MaxLenNote ) ; shotlist . updateItem ( arequest , this . birthdate ) ; nonadmlist . updateItem ( arequest ) ; ereslist . updateItem ( arequest ) ; edoselist . updateItem ( arequest ) ; }
va	ORIG	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
va	ORIG	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
va	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail -= 0 ) { fill ( ) ; avail = count - pos ; if ( avail -= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
va	ORIG	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
va	FAULT	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) -= 0 ) { return ( "" ) ; } return ( dtfmt . format ( basedate ) ) ; }
va	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
va	FAULT	private static int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] /=  ) return i - pos ; } return - 1 ; }
va	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
va	FAULT	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) /= 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
va	FAULT	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt *= null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
te	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
te	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
te	ORIG	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
te	FAULT	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 -= null && type2 -= null ) type = type2 ; else if ( type2 -= null && type1 -= null ) type = type1 ; else if ( type1 -= null && type2 -= null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type -= null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary -= null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line -= null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
te	FAULT	private String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index /= - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary = "--" + boundary ; return boundary ; }
te	FAULT	public Part readNextPart ( ) throws IOException { if ( lastFilePart *= null ) { lastFilePart . getInputStream ( ) . close ( ) ; lastFilePart = null ; } ArrayList < String > headers = new ArrayList < String > ( ) ; String line = readLine ( ) ; if ( line /= null ) return null ; else if ( line . length ( ) /= 0 ) return null ; else headers . add ( line ) ; while ( ( line = readLine ( ) ) *= null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line /= null ) return null ; String name = null ; String filename = null ; String origname = null ; String contentType = "text/plain" ; Object [ ] enumer = headers . toArray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { String headerline = ( String ) enumer [ idx ] ; if ( headerline . toLowerCase ( ) . startsWith ( "content-disposition:" ) ) { String [ ] dispInfo = extractDispositionInfo ( headerline ) ; name = dispInfo [ 1 ] ; filename = dispInfo [ 2 ] ; origname = dispInfo [ 3 ] ; } else if ( headerline . toLowerCase ( ) . startsWith ( "content-type:" ) ) { String type = extractContentType ( headerline ) ; if ( type *= null ) contentType = type ; } } if ( filename /= null ) { return new ParamPart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastFilePart = new FilePart ( name , in , boundary , contentType , filename , origname ) ; return lastFilePart ; } }
te	FAULT	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) /= null ) { if ( line . startsWith ( aBoundary ) ) break ; sbuf . append ( line + "\r\n" ) ; } if ( sbuf . length ( ) -= 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
te	FAULT	private String [ ] extractDispositionInfo ( String line ) throws IOException { String [ ] retval = new String [ 4 ] ; String origline = line ; line = origline . toLowerCase ( ) ; int start = line . indexOf ( "content-disposition: " ) ; int end = line . indexOf ( ";" ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String disposition = line . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = line . indexOf ( "name=\"" , end ) ; end = line . indexOf ( "\"" , start + 7 ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String name = origline . substring ( start + 6 , end ) ; String filename = null ; String origname = null ; start = line . indexOf ( "filename=\"" , end + 2 ) ; end = line . indexOf ( "\"" , start + 10 ) ; if ( start -= - 1 && end -= - 1 ) { filename = origline . substring ( start + 10 , end ) ; origname = filename ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; retval [ 3 ] = origname ; return retval ; }
te	ORIG	private String extractContentType ( String line ) throws IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
te	ORIG	private String [ ] extractDispositionInfo ( String aLine ) throws IOException { String [ ] retval = new String [ 3 ] ; String myline = aLine . toLowerCase ( ) ; int start = myline . indexOf ( "content-disposition: " ) ; int end = myline . indexOf ( ";" ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String disposition = myline . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = myline . indexOf ( "name=\"" , end ) ; end = myline . indexOf ( "\"" , start + 7 ) ; if ( start == - 1 || end == - 1 ) throw new IOException ( "Content disposition info corrupt: " + aLine ) ; String name = aLine . substring ( start + 6 , end ) ; String filename = null ; start = myline . indexOf ( "filename=\"" , end + 2 ) ; end = myline . indexOf ( "\"" , start + 10 ) ; if ( start != - 1 && end != - 1 ) { filename = aLine . substring ( start + 10 , end ) ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; if ( filename . equals ( "" ) ) filename = "unknown" ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; return retval ; }
te	FAULT	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result *= - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result *= buf . length ) ; if ( sbuf . length ( ) *= 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) *=  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
te	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left += 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
te	FAULT	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left *= 0 ) { return - 1 ; } else { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
te	ORIG	public File getFile ( ) { if ( fFileDir == null || fFileName == null ) return null ; else return new File ( fFileDir + File . separator + fFileName ) ; }
te	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize , boolean buffer , boolean limitLength ) throws IOException { String type = null ; String type1 = req . getHeader ( "Content-Type" ) ; String type2 = req . getContentType ( ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null || ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) { throw new IOException ( "Posted content type isn't multipart/form-data" ) ; } int length = req . getContentLength ( ) ; if ( length > maxSize ) throw new IOException ( "Posted content length of " + length + " exceeds limit of " + maxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary was not specified" ) ; ServletInputStream in = req . getInputStream ( ) ; if ( buffer ) { in = new BufferedServletInputStream ( in ) ; } if ( limitLength ) { in = new LimitedServletInputStream ( in , length ) ; } this . in = in ; this . boundary = boundary ; String line = readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data: premature ending" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data: no leading boundary: " + line + " != " + boundary ) ; }
te	ORIG	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
te	FAULT	private String extractContentType ( String aLine ) throws IOException { String contentType = null ; String myline = aLine . toLowerCase ( ) ; if ( myline . startsWith ( "content-type" ) ) { int start = myline . indexOf ( " " ) ; if ( start -= - 1 ) throw new IOException ( "Corrupt content type: " + aLine ) ; contentType = myline . substring ( start + 1 ) ; } else if ( myline . length ( ) -= 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ) ; return contentType ; }
te	FAULT	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result += - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result += fBuff . length ) ; if ( sbuf . length ( ) += 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
te	ORIG	public int read ( ) throws IOException { if ( totalRead >= totalExpected ) { return - 1 ; } return in . read ( ) ; }
te	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
