tr	REPL	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw java new . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	REPL	public EDFShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTexture ( new TextureLoader ( ) . loadTexture TEXTURE_PATH ( ) ) ; setColor ( new Color ( 0f , 0.8f , 1f ) ) ; setY ( ELEVATION ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setElevation ( ELEVATION ) ; }
tr	ORIG	public void reset ( int num_tiles ) { removeAll ( ) ; myNumTiles = num_tiles ; myBoardSize = ( int ) Math . ceil ( num_tiles / 2.0 ) ; setLayout ( new GridLayout ( myBoardSize , myBoardSize , 0 , - 5 ) ) ; setPreferredSize ( new Dimension ( myBoardSize * AbstractTile . TILE_WIDTH , myBoardSize * AbstractTile . TILE_HEIGHT + myBoardSize ) ) ; myStartingTile = myStartingTileFactory . manufactureTile ( ( int ) Math . ceil ( myBoardSize / 2.0 - 1 ) , ( int ) Math . ceil ( myBoardSize / 2.0 - 1 ) ) ; myTiles = new TilePanel [ myBoardSize ] [ myBoardSize ] ; for ( int i = 0 ; i < myBoardSize ; i ++ ) { for ( int j = 0 ; j < myBoardSize ; j ++ ) { myTiles [ i ] [ j ] = new TilePanel ( i , j ) ; add ( myTiles [ i ] [ j ] ) ; } } myTiles [ myStartingTile . getRow ( ) ] [ myStartingTile . getCol ( ) ] . setTile ( myStartingTile ) ; centerView ( ) ; revalidate ( ) ; repaint ( ) ; }
tr	REPL	public EDFCharacterController ( ) { BackGroundColor . BLACK . set ( ) ; earth = add new ( EDFEarth ( this ) ) ; ship = add ( new EDFShip ( this ) ) ; ship . equipLeft ( new BasicWeapon ( this , ship , LR . LEFT ) ) ; ship . equipRight ( new BasicWeapon ( this , ship , LR . RIGHT ) ) ; }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ShotList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; retstr . append ( shot . exportItem ( ) ) ; } retstr . append ( "</ShotList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( <= rand 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	REPL	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex { ) dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
tr	REPL	@ Override protected void dead ( ) { super . dead ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { getParentScene ( ) . shoot ( new BasicEffect ( getParentScene ( ) , this ) ) ; } ( ( EDFScene ) getParentScene ( ) ) . addMoney ( 10 ; ) }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( ) : new Base64 ( 0 ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; } if ( isChunked ) { len += ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big  output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; if ( b64 . buf != buf ) { b64 . readResults ( buf , 0 , buf . length ) ; } return buf ; }
tr	ORIG	private void updateObjects ( ) { for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; ite . remove ( ) ; friendlieCharas . remove ( go ) ; enemieCharas . remove ( go ) ; bullets . remove ( go ) ; } } }
tr	ORIG	public void update ( int pos , int keyweights , List lengthDist , PriorityQueue q ) throws IllegalArgumentException { ArrayList EtSedges = ( ArrayList ) EtS . get ( keyweights ) ; Iterator k = EtSedges . iterator ( ) ; if ( ! k . hasNext ( ) ) { return ; } WeightedEdge we = ( WeightedEdge ) k . next ( ) ; int i = we . getSource ( ) ; int j = we . getTarget ( ) ; if ( colors [ j ] != 2 ) { int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; return ; } while ( colors [ j ] == 2 ) { k . remove ( ) ; if ( k . hasNext ( ) ) { we = ( WeightedEdge ) k . next ( ) ; j = we . getTarget ( ) ; } else { break ; } } if ( colors [ j ] != 2 ) { i = we . getSource ( ) ; int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; } }
tr	REPL	private static void getContentAsDefined ( ) { StringTokenizer _tempTokens ; File _tempFile = new File ( FileName ) ; Scanner _fileScanner ; String _line ; String token ; int _tokenCount ; try { _fileScanner = new Scanner ( _tempFile ) ; while ( _fileScanner . hasNextLine ( ) ) { _line = _fileScanner . nextLine ( ) ; if ( _line . startsWith ( "Date & Time" ) ) { System . out . println ( _line ) ; continue ; } if ( _line . startsWith ( "++++++" ) ) { if ( true ) _fileScanner . nextLine ( ) ; continue ; } _tempTokens = new StringTokenizer ( _line ) ; _tokenCount = _tempTokens . countTokens ( ) ; if ( _tokenCount == 1 ) { forLinuxServers ( _fileScanner ) ; continue ; } for ( int _index = 0 ; _index < _tokenCount ; _index ++ ) { token = _tempTokens . nextToken ) ( ; if ( _index == 4 ) System . out . print ( token ) ; if ( _index == 5 ) System . out . println ( "\t\t\t" + token ) ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	REPL	@ Override public void update ( ) { setAngle ( owner . getAngle ( ) ) ; super . update ( ) ; double theta = Math . toRadians ( getAngle ( ) ) ; setX ( owner . getX ( ) + ( 5 * ( float ) Math . sin ( - theta ) ) ) ; setY ( owner . getY ( ) + ( 5 * ( float ) Math . cos ( - theta ) ) ) ; setX ( getX ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . cos ( theta ) ) ) ; setY ( getY ( ) + ( getDistanceFromOwner ) ( * equipLR . signum ( ) * ( float ) Math . sin ( theta ) ) ) ; remainShootDelayFrame -- ; }
tr	REPL	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; = height Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	public void makeItem ( CEvalItem aitem ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . copyItem ( aitem ) ; myitem . evalid = this . makeNewId ( "res" , 6 ) ; this . addItem ( myitem . evalid , myitem ) ; }
tr	ORIG	public String getString ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	ORIG	public String getTestStatus ( ) { String mystat = CAppConsts . StatusNone ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( CAppConsts . StatusFail . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusFail ) ; } else if ( CAppConsts . StatusNone . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusNone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	REPL	public CEvalItem ( ) { evalid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = "" ; doseord = 0 ; acceldate new = Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) return ( "" ) ; StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<NonAdminList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</NonAdminList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	private void jButton4ActionPerformed ( java . awt . event . ActionEvent evt ) { try { HashMap < String , Object > = map new HashMap < String , Object > ( ) ; map . put ( "startTime" , jTextField1 . getText ( ) . toString ( ) ) ; map . put ( "endTime" , jTextField2 . getText ( ) . toString ( ) ) ; Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\Tax.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	REPL	public CStringList ( boolean asorted ) { mystrings = new < ArrayList String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = asorted ; wasfound = false ; }
tr	REPL	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add ( go ) ; if ( go instanceof ShootingBulletCharacter ) { bullets . add ( ( ShootingBulletCharacter ) go ) ; } else if ( go . getTeam ( ) == TEAM . FRIEND_TEAM ) { friendlieCharas . add ( go ) ; } else if ( go . getTeam ( ) == TEAM ENEMY_TEAM . ) { enemieCharas . add ( go ) ; } return go ; }
tr	REPL	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt close . ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	ORIG	private void updatePieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) ) whites ++ ; else if ( Draughts . isBlack ( piece ) ) blacks ++ ; } String status = "" + whites + " - " + blacks ; numberOfPiecesLabel . setText ( status ) ; }
tr	REPL	public void drawMyFigure ( Graphics g , int w , int h , Matrix m ) { this . w = ; w this . h = h ; for ( int f = 0 ; f < faces . length ; f ++ ) { for ( int f2 = 0 ; f2 < faces [ f ] . length ; f2 ++ ) { int i = faces [ f ] [ f2 ] ; int j = faces [ f ] [ ( f2 + 1 ) % faces [ f ] . length ] ; m . transform ( vertices [ j ] , point1 ) ; m . transform ( vertices [ i ] , point0 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } } }
tr	ORIG	public static String getFCname ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FNAME ] ) ; else return ( "" ) ; }
tr	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	REPL	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 row ; < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	LimitedServletInputStream public ( ServletInputStream in , int totalExpected ) { this . in = in ; this . totalExpected = totalExpected ; }
tr	REPL	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + + dbHost dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
tr	ORIG	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt == null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TShotHistTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	private void CancelActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( false ) ; textField1 . setEnabled ( false ) ; textField1 . setText ( "" ) ; textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField2 . setText ( "" ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField3 . setText ( "" ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; textField4 . setText ( "" ) ; jComboBox1 . setEnabled ( false ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setEnabled ( false ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; }
tr	REPL	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = . dbconf dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
tr	REPL	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . ( set 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	REPL	public int read ( ) throws IOException { if ( count - pos <= 2 ) { fill ( ) ; if ( count - pos <= 2 ) return - 1 ; } return buf [ pos ++ ] & ; ff }
tr	ORIG	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	REPL	public EDFEarth ( ShootingScene scene ) { super ( scene , float . MAX_VALUE , 10 ) ; setTexture ( TextTextureMaker . createText ( "\u25CB" , FontDef . RICTY_64 ) ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setVAngle ( JITEN ) ; setColor ( COLOR ) ; hpCaption = new TextCharacter ( getHpText ( ) ) ; hpCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.3f ) . setColor ( ( getCaptionColor getHP ( ) ) ) ; }
tr	REPL	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { String qstr = "Select PassHash From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { curhash = rset . getString ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts ErrorFile . , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	REPL	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ; ) }
tr	ORIG	@ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries == 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; }
tr	ORIG	public CMapCode ( Connection aconn , String atable , String acode , String amap , int atype ) { super ( true ) ; tablenm = atable ; codefld = acode ; mapfld = amap ; maptyp = atype ; dbReadList ( aconn ) ; }
tr	ORIG	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
tr	ORIG	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "startTime" , jTextField1 . getText ( ) . toString ( ) ) ; map . put ( "endTime" , jTextField2 . getText ( ) . toString ( ) ) ; Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\SalesLog.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public CDosevItem ( ) { = shotid "" ; dosenum = 0 ; validflag = "" ; invalidcd = "" ; }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize ) throws IOException { this ( req , maxSize , true , true ) ; }
tr	ORIG	public void delete ( MsgTypePk pk ) throws MsgTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public static void print ( int indent , Node node ) { if ( node instanceof Comment ) { printIndent ( indent , "// " + ( ( Comment ) node ) . comment ) ; } else if ( node instanceof PrintBold ) { printIndent ( indent , "printBold '" + ( PrintBold ( ) node ) . message + "'" ) ; } else if ( node instanceof Print ) { printIndent ( indent , "print '" + ( ( Print ) node ) . message + "'" ) ; } else if ( node instanceof Block ) { printIndent ( indent , "begin" ) ; print ( indent + 1 , ( ( Block ) node ) . first ) ; print ( indent + 1 , ( ( Block ) node ) . second ) ; printIndent ( indent , "end" ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
tr	ORIG	@ Test public void testEqualsOperations ( ) { testOcl ( "self.firstname = self.firstname" , to , true ) ; testOcl ( "self.firstname = self.lastname" , to , false ) ; testOcl ( "self.firstname <> self.firstname" , to , false ) ; testOcl ( "self.firstname <> self.lastname" , to , true ) ; testOcl ( "self.female = self.female" , to , true ) ; testOcl ( "self.female = self.male" , to , false ) ; testOcl ( "self.male <> self.female" , to , true ) ; testOcl ( "self.male <> self.male" , to , false ) ; testOcl ( "self.age = self.age" , to , true ) ; testOcl ( "self.age = self.children" , to , ( to . getAge ( ) == to . getChildren ( ) ) ) ; testOcl ( "self.age <> self.age" , to , false ) ; testOcl ( "self.age <> self.children" , to , ( to . getAge ( ) != to . getChildren ( ) ) ) ; testOcl ( "self.income = self.income" , to , true ) ; testOcl ( "self.income = self.outcome" , to , ( to . getIncome ( ) == to . getOutcome ( ) ) ) ; testOcl ( "self.income <> self.income" , to , false ) ; testOcl ( "self.income <> self.outcome" , to , ( to . getIncome ( ) != to . getOutcome ( ) ) ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
tr	REPL	public Hoge ( LR lr ShootingWeaponCharacter , weapon ) { setWeapon ( weapon ) ; setX ( Commons . CENTER_X + ( 165 * lr . signum ( ) ) ) ; setY ( 40 ) ; weaponView . setX ( getX ( ) ) . setY ( getY ( ) + 5 ) . setWidth ( weapon . getWidth ( ) ) . setHeight ( weapon . getHeight ( ) ) . setScale ( 2 ) . setColor ( weapon . getColor ( ) ) ; remainBulletView . setX ( getX ( ) ) . setY ( getY ( ) - 25 ) . setScale ( 0.3f ) . setColor ( Color . white ) ; }
tr	ORIG	public static void setGlColor4f ( final Color color , final float alpha ) { if ( color == null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	ORIG	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	REPL	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL6 node = new NodeLVL6 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 0 ; int finishedDepth = 0 ; while ( ) true { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; } return bestMove ; }
tr	REPL	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) } ; catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	public String makeOptions ( String acode ) { return ( makeOptions ( CAppConsts . TagNoValue , acode ) ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectResTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	public int read ( ) throws IOException { if ( totalRead >= totalExpected ) { return - 1 ; return } in . read ( ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public Toolbar ( Content content , MouseModeProvider mouseModeProvider ) { NewAction newAction = new NewAction ( content ) ; LoadAction loadAction = new LoadAction ( this , content ) ; SaveAction saveAction = new SaveAction ( this , content ) ; FrechetAction frechetAction = new FrechetAction ( content ) ; Frechet2Action frechet2Action = new Frechet2Action ( content ) ; MouseAction selectAction = new MouseAction ( "select" , MouseMode . SELECT , mouseModeProvider ) ; MouseAction editAction = new MouseAction ( "edit" , MouseMode . EDIT , mouseModeProvider ) ; MouseAction moveAction = new MouseAction ( "move" , MouseMode . MOVE , mouseModeProvider ) ; MouseAction deleteAction = new MouseAction ( "delete" , MouseMode . DELETE , mouseModeProvider ) ; JToggleButton buttonSelect = new JToggleButton ( selectAction ) ; JToggleButton buttonEdit = new JToggleButton ( editAction ) ; JToggleButton buttonMove = new JToggleButton ( moveAction ) ; JToggleButton buttonDelete = new JToggleButton ( deleteAction ) ; add ( newAction ) ; add ( loadAction ) ; add ( saveAction ) ; add ( buttonSelect ) ; add ( buttonEdit ) ; add ( buttonMove ) ; add ( buttonDelete ) ; add ( frechetAction ) ; add ( frechet2Action ) ; }
tr	ORIG	public MapBoard ( ) { initComponents ( ) ; mouse = new Point ( - 1 , - 1 ) ; addMouseMotionListener ( new MouseMotionListener ( ) { @ Override public void mouseDragged ( MouseEvent e ) { } @ Override public void mouseMoved ( MouseEvent e ) { mouse = e . getPoint ( ) ; } } ) ; try { posBuffer = new ArrayList < > ( ) ; for ( int i = 0 ; i < Game . players . size ( ) ; i ++ ) { posBuffer . add ( 0.0 ) ; } } catch ( NullPointerException err ) { System . out . println ( "Error: " + err . getMessage ( ) ) ; } try { diceimg = ImageIO . read ( new File ( "images/DICE.png" ) ) ; } catch ( IOException ex ) { System . out . println ( "Could not find image..." ) ; Logger . getLogger ( MapBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public EDFScene ( ) { BackGroundColor . BLACK . set ( ) ; characterController = add ( new EDFCharacterController ( ) ) ; stageController = add ( EDFStageController new ( this ) ) ; add ( new EDFMoneyCaption ( this ) ) ; add ( new EDFWeaponCaption ( characterController ) ) ; }
tr	REPL	public int ( read byte b [ ] ) throws IOException { return read ( b , 0 , b . length ) ; }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	REPL	public void setTestResult ( CEvalItem aitem ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aitem . seriescd ) ) { myitem . setTestResult ( aitem ) ; return ; } } }
tr	REPL	public int getStatusCnt ( String astat ) { int statcnt = 0 ; for ( int itst = 0 ; < itst this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; if ( myitem . testresult . equals ( astat ) ) { statcnt ++ ; } } return ( statcnt ) ; }
tr	ORIG	@ Override public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { String sql = "INSERT INTO articlestat (uniquevisitor  pageview  visit  date  articleid  articletitle  " + "articleurl  site_id) VALUES (?  ?  ?  ?  ?  ?  ?  ?)" ; PreparedStatement ps = con . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; return ps ; }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( DemoPattern2 . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	REPL	public int available ( ) throws IOException { int avail = ( count - pos - 2 ) + in . available ( ) ; return avail ( < 0 ? 0 : avail ) ; }
tr	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public List < String > seperateTables ( List < String > data List , < Integer > lineNums ) { List tables = new ArrayList < String > ( ) ; for ( int k = 0 ; k < lineNums . size ( ) ; k ++ ) { int start = lineNums . get ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; String [ ] entry = new String [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } String [ ] blub = ( String [ ] ) tables . get ( 0 ) ; return tables ; }
tr	REPL	public void setLastRunFC1 ( ) { fc1result = edoselist . ( getTestStatus ) ; fc1rundt = new Date ( ) ; }
tr	REPL	public void initialize ( ) { config = VMConfiguration . getInstance ( ) ; alarmCount = 0 ; logger . info ( "Executing python script" ) ; if ( Controller . getConfig ( ) . getdoTest ( ) != 1 ) { MinMaxMetricVal = new double [ 2 ] [ 2 ] ; ProcessBuilder p = new ProcessBuilder ( "python" , "./resources/TrainDataPreprocess.py" ) ; Process proc ; try { proc = p . start ( ) ; BufferedReader output = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader error = new BufferedReader ( new InputStreamReader proc ( . getErrorStream ( ) ) ) ; String ligne = "" ; int counter = 0 ; while ( ( ligne = output . readLine ( ) ) != null ) { if ( counter > 13 ) break ; double d = double . parseDouble ( ligne ) ; MinMaxMetricVal [ ( int ) ( counter / 2 ) ] [ ( int ) ( counter % 2 ) ] = d ; counter ++ ; } } catch ( Exception e ) { logger . error ( e . getMessage ( ) ) ; } } }
tr	REPL	@ Override public boolean put ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value . ( longValue ) ) { return false ; } else { values [ offset ] = value . longValue ( ) ; return true ; } } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; checkResize ( reprobes ) ; return true ; }
tr	REPL	public static void main ( String [ ] args ) { InMemoryAuctionService imas = new InMemoryAuctionService ( ) ; Auction a = new Auction ( 12 , "pizza" , 5 ) ; Auction a1 = new Auction ( 33 , "something" , 8 ) ; System . out . println ( a . toString ( ) ) ; System . out . println ( "The auction object was printed out." ) ; System . out . println ( a . equals ( a ) ) ; System . out . println ( . a equals ( a1 ) ) ; System . out . println ( "Search results for 'Computer'" ) ; Auction [ ] results = imas . search ( "Computer" ) ; for ( int i = 0 ; i < results . length ; i ++ ) { System . out . println ( results [ i ] . toString ( ) ) ; } System . out . println ( "Search results for 'something'" ) ; Auction [ ] falseResults = imas . search ( "something" ) ; for ( int i = 0 ; i < falseResults . length ; i ++ ) { System . out . println ( falseResults [ i ] . toString ( ) ) ; } }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	REPL	@ Override public void update ( ) { frame ++ ; for ( Iterator < SpawnData > ite = spawns . iterator ( ) ; ite . hasNext ( ; ) ) { SpawnData data = ite . next ( ) ; if ( data . canSpawn ( frame ) ) { doSpawn ( data ) ; ite . remove ( ) ; } } }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
tr	REPL	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , ) response ; }
tr	REPL	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ ] i [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	private void ButtonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { try { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; ButtonSaveDelete . setVisible ( false ) ; DbUtil . deleteUser ( list1 . getSelectedItem ( ) . toString ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	ORIG	public void delete ( InviteResPk pk ) throws InviteResDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getInviteRes ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteResDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	REPL	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category != response . category ) { return false ; } if ( code != response . code ) { return false ; } if ( httpStatusCode != response . httpStatusCode ) { return false ; } if ( message != null ? ! message . equals ( response . message ) : response . message != null ) { return false ; } if ( reference != null ? ! reference . equals ( response . reference ) : response . reference != null ) { return false ; } if ( details != null ? ! details . equals ( response . details ) : response . details != null ) { return false ; } if ( responseBody != null ? ! responseBody . equals ( response . responseBody ) : . response responseBody != null ) { return false ; } return true ; }
tr	REPL	private String extractContentType ( String aLine ) throws IOException { String contentType = null ; String myline = aLine . toLowerCase ( ) ; if ( myline . startsWith ( "content-type" ) ) { int start = myline . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Corrupt content type: " + aLine ) ; contentType = myline . substring ( start + 1 ) ; } else if ( myline . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ; ) return contentType ; }
tr	ORIG	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; JRadioButton fourStar = new JRadioButton ( Strings . BUTTON_SOURCE_FOURSTAR , true ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( fourStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( fourStar ) ; }
tr	REPL	public void dbReadDetail ( Connection aconn ) { shotlist . dbReadList ( aconn , testgroupid , testid ) nonadmlist ; . dbReadList ( aconn , testgroupid , testid ) ; ereslist . dbReadList ( aconn , testgroupid , testid ) ; edoselist . dbReadList ( aconn , testgroupid , testid ) ; evallist . dbReadList ( aconn , testgroupid , testid ) ; dosevlist . dbReadList ( aconn , testgroupid , testid ) ; }
tr	ORIG	public void load ( String name ) { clearAll ( ) ; try { coordToName . clear ( ) ; graph . clear ( ) ; FileInputStream fis = new FileInputStream ( name ) ; ObjectInput ois = new ObjectInputStream ( fis ) ; List < SerializableVertex > l = ( List < SerializableVertex > ) ois . readObject ( ) ; ois . close ( ) ; for ( SerializableVertex v : l ) { graph . addVertex ( v . x , v . y , v . name ) ; } for ( SerializableVertex v : l ) { for ( Edge e : v . adj ) { graph . addEdge ( e . src . name , e . dest . name , e . cost ) ; } } for ( Vertex v : graph . getVertices ( ) ) { coordToName . put ( new Point ( v . x , v . y ) , v . name ) ; } repaint ( ) ; } catch ( Exception ex ) { Logger . getLogger ( Drawing . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public int readLine ( byte b [ ] , int off , int ) len throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	ORIG	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	REPL	public List < String > computeGreedyMotifSearch ( ) { List < String > bestMotif ; String consensus ; List < String > kMer ; int bestScore ; bestMotif = generateInitialMotif ( this . dnaList ) ; consensus = generateConsensusString ( bestMotif ) ; bestScore = calculateMotifScore ( bestMotif , consensus ) ; kMer = generateKMer ( this . dnaList . get ( 0 ) ) ; for ( String s : kMer ) { List < String > profileList = new ArrayList < String > ( ) ; profileList . add ( s ) ; for ( int i = 2 1 - ; i <= t - 1 ; i ++ ) { String profile = createProfile ( profileList ) ; MostProbableKMer mostProbableKMer = new MostProbableKMer ( this . dnaList . get ( i ) , k , profile ) ; profileList . add ( ( String ) mostProbableKMer . calculateMostProbableKMer ( ) . get ( 0 ) . get ( 1 ) ) ; } String newConsensusString = generateConsensusString ( profileList ) ; int motifScore = calculateMotifScore ( profileList , newConsensusString ) ; if ( bestScore > motifScore ) { bestScore = motifScore ; bestMotif = profileList ; } } return bestMotif ; }
tr	REPL	public File getFile ( ) if { ( fFileDir == null || fFileName == null ) return null ; else return new File ( fFileDir + File . separator + fFileName ) ; }
tr	REPL	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = CNonadItem ( ) this . getItem ( idx ) ; myitem . nonadmdate . setTime ( myitem . nonadmdate . getTime ( ) + adiff ) ; } }
tr	REPL	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectResultList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr . append myitem ( . exportItem ( ) ) ; } retstr . append ( "</ExpectResultList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	@ SuppressWarnings ( "null" ) public static int maxDepth2 ( TreeNode root ) { if ( root == null ) return 0 ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; stack . push ( root ) ; TreeNode prev = null ; int max = 0 ; while ( ! stack . isEmpty ( ) ) { TreeNode cur = stack . peek ( ) ; if ( prev == null || prev left . == cur || prev . right == cur ) { if ( cur . left != null ) stack . push ( cur . left ) ; else if ( cur . right != null ) stack . push ( cur . right ) ; } else if ( cur . left == prev ) { if ( cur . right != null ) stack . push ( cur . right ) ; } else { System . out . println ( stack . pop ( ) . val ) ; } prev = cur ; if ( stack . size ( ) > max ) max = stack . size ( ) ; } return max ; }
tr	REPL	@ Override public void update ( Observable o , Object arg { ) MechanicalMan m = ( MechanicalMan ) o ; ctrTest . setText ( "Not tested" ) ; wallTest . setText ( "Not tested" ) ; if ( m . motorOn ( ) ) { motor . setText ( "On" ) ; } else { motor . setText ( "Off" ) ; } if ( m . standingUp ( ) ) { posture . setText ( "Standing" ) ; } else { posture . setText ( "Sitting" ) ; } location . setText ( m . location ( ) . toString ( ) ) ; if ( m . areArmsUp ( ) ) { arms . setText ( "Up" ) ; } else { arms . setText ( "Down" ) ; } facing . setText ( m . dir ( ) . toString ( ) ) ; if ( m . foundWall ( ) ) wallTest . setText ( "Yes" ) ; else wallTest . setText ( "No" ) ; if ( m . ctrZero ( ) ) ctrTest . setText ( "Yes" ) ; else ctrTest . setText ( "No" ) ; counter . setText ( "" + m . counter ( ) ) ; }
tr	REPL	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if ( ( request . getParameter ( "contenido" ) != null ) ) { oEntrada . setContenido ( request . getParameter ( "contenido" ) ) ; } if ( ( request . getParameter ( "id_hilo" ) != null ) ) { oEntrada . getHilo ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_hilo" ) ) ) ; } if ( ( request . getParameter ( "id_usuario" ) != null ) ) { oEntrada . getUsuario ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_usuario" ) ) ) ; } if ( ( request . getParameter ( "fecha" ) != null ) ) { oEntrada . setFecha ( new SimpleDateFormat ( "dd-MM-yyyy" ) . parse ( request . getParameter ( "fecha" ) ) ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p < 0 ) { p = 0 ; } if ( p < displayBorder ) { p = displayBorder ; } return p ; }
tr	REPL	public int [ ] searchRange0 ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if nums ( [ mid ] == target ) { for ( int i = mid - 1 ; i >= - 1 ; i -- ) { if ( i == - 1 || nums [ i ] != target ) { pos [ 0 ] = i + 1 ; break ; } } for ( int i = mid + 1 ; i <= nums . length ; i ++ ) { if ( i == nums . length || nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
tr	ORIG	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
tr	REPL	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( , errfile errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	REPL	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else return { ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( "--------------------------------------------" ) ; System . out . println ( "\u8BF7\u9009\u62E9\u8981\u6267\u884C\u7684\u65B9\u6CD5:\u6CD51\uFF0C\u4E0D\u6253\u5370\u7A7A\u6587\u4EF6\u5939\uFF0C\u6CD52\uFF0C\u6253\u5370\u7A7A\u6587\u4EF6\u5939\u3002" ) ; System . out . println ( "\u8F93\u51651\uFF0C\u6267\u884C\u65B9\u6CD51\uFF0C\u8F93\u51652\uFF0C\u6267\u884C\u65B9\u6CD52\uFF0C\u8F93\u5165\u5176\u4ED6int\u503C\uFF0C\u9000\u51FA\u6B64\u7A0B\u5E8F\u3002" ) ; System . out . println ( "--------------------------------------------" ) ; Scanner in = new Scanner ( System . in ) ; String [ ] list = String new [ ] { } ; ArrayList < String > fileList ; ; while ( true ) { int num = in . nextInt ( ) ; switch ( num ) { case 1 : fileList = new ArrayList < String > ( ) ; list = listfiles1 ( new File ( "e:\\test" ) , "" , fileList ) ; break ; case 2 : fileList = new ArrayList < String > ( ) ; list = listfiles2 ( new File ( "e:\\test" ) , "" , fileList ) ; break ; } if ( num != 1 && num != 2 ) break ; for ( int i = 0 ; i < list . length ; i ++ ) { System . out . println ( list [ i ] ) ; } } }
tr	ORIG	public static double [ ] [ ] getNormalizedSimilarityMatrix ( String [ ] words1 , String [ ] words2 , RelatednessCalculator rc ) { double [ ] [ ] scores = getSimilarityMatrix ( words1 , words2 , rc ) ; double bestScore = 1 ; for ( int i = 0 ; i < scores . length ; i ++ ) { for ( int j = 0 ; j < scores [ i ] . length ; j ++ ) { if ( scores [ i ] [ j ] > bestScore && scores [ i ] [ j ] != double . MAX_VALUE ) { bestScore = scores [ i ] [ j ] ; } } } for ( int i = 0 ; i < scores . length ; i ++ ) { for ( int j = 0 ; j < scores [ i ] . length ; j ++ ) { if ( scores [ i ] [ j ] == double . MAX_VALUE ) { scores [ i ] [ j ] = 1 ; } else { scores [ i ] [ j ] /= bestScore ; } } } return scores ; }
tr	ORIG	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx >= 0 ) delItem ( idx ) ; }
tr	REPL	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ; ) fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public void dbDeleteResult1 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc1 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult1 cannot delete item. " , ex ) ; } }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	public static String postpadStr ( String astr , String , apad int alen ) { String rstr = astr ; while ( rstr . length ( ) < alen ) rstr = rstr + apad ; return ( rstr ) ; }
tr	REPL	public static void main ( String [ ] args ) throws Exception { line String = "" ; double amount , apr ; int years ; line = readLine ( "Please enter the amount you would like to borrow: " ) ; amount = double . parseDouble ( line ) ; line = readLine ( "Please enter the annual percentage rate used to repay the loan: " ) ; apr = double . parseDouble ( line ) ; line = readLine ( "Please enter the term  in years  over which the loan is repaid: " ) ; years = Integer . parseInt ( line ) ; try { AmortizationScheduler as = new AmortizationScheduler ( amount , apr , years ) ; List < AmortizationMonthly > monthly = as . getSchedule ( ) ; String formatString = "%1$-14s%2$-14s%3$-20s%4$s   %5$s   %6$-20s\n" ; printf ( formatString , "PaymentNumber" , "PaymentAmount" , "PaymentInterest" , "CurrentBalance" , "TotalPayments" , "TotalInterestPaid" ) ; formatString = "%1$-16d%2$-12.2f%3$-20.2f%4$.2f   %5$.2f   %6$.2f\n" ; for ( AmortizationMonthly m : monthly ) { printf ( formatString , m . getPaymentNumber ( ) , m . getCurrentMonthlyPaymentAmount ( ) , m . getCurrentMonthlyInterest ( ) , m . getCurrentBalance ( ) , m . getTotalPayments ( ) , m . getTotalInterestPaid ( ) ) ; } } catch ( IllegalArgumentException e ) { System . err . println ( "Unable to process the values entered. Terminating program.\n" ) ; } }
tr	REPL	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) int ; baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	REPL	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , , asort "" , "" ) ; }
tr	REPL	public static Map sortByValue ( Map < Integer , float > map , final boolean reverse ) { List = list new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	private void readValues ( Stream stream , int i ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; int dummy ; if ( j == 1 ) stream . readUnsignedByte ( ) ; else if ( j == 2 ) stream . readUnsignedByte ( ) ; else if ( j == 3 ) anIntArray703 [ anInt702 ++ ] = i ; else if ( j == 4 ) dummy = 2 ; else if ( j == 5 ) anInt709 = stream . readUnsignedWord ( ) ; else if ( j == 6 ) dummy = 2 ; else if ( j == 7 ) stream . readDWord ( ) ; else if ( j == 8 ) aBoolean713 = true ; else if ( j == 10 ) stream . readString ( ) ; else if ( j == 11 ) aBoolean713 = true ; else if ( j == 12 ) stream . readDWord ( ) ; else if ( j == 13 ) dummy = 2 ; System else . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	ORIG	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	REPL	public void batchInsert ( final List < RecordSiteStatModel > recordSiteStatModelList ) { String sql = "INSERT INTO recordsitestat (uniquevisitor  uniquevisitordate  " + "pageview  pageviewdate  visit  visitdate  site_id) (? VALUES  ?  ?  ?  ?  ?  ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return recordSiteStatModelList . size ( ) ; } } ) ; }
tr	ORIG	public Date parseDate ( String adstr ) { Date mydate = new Date ( 0 ) ; try { mydate = dtfmt . parse ( adstr ) ; } catch ( Exception ex ) { } return ( mydate ) ; }
tr	REPL	private void listSolicitudesMouseClicked ( java . awt . event . MouseEvent evt ) { int no ; no = listSolicitudes . getSelectedIndex ( ) ; int reply = JOptionPane . showConfirmDialog ( null , "Desea agregara a " + listaS . get ( no - 1 ) . nombre + "(" + listaS . get ( no - 1 ) . usuario + ")" , "Solicitud de Amistad" , JOptionPane . YES_NO_OPTION ) ; String resp = "<solicitud_amistad>\n" ; if ( reply == JOptionPane . YES_OPTION ) { resp += "<respuesta> Si </respuesta>\n" ; } else { resp += "<respuesta> No </respuesta>\n" ; } usuario usuario = servidor . getUsuario ( txtUser . getText ( ) ) ; resp += "<destinatario>" + listaS . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + . txtUser getText ( ) + "</usuario>\n" + "<nombre> " + usuario . getNombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listaS . remove ( no - 1 ) ; listSolicitudes . updateUI ( ) ; servidor . actualizarSolicitudes2 ( listaS , usuario . getUsername ( ) ) ; writeUTF ( resp ) ; listSolicitudes . repaint ( ) ; System . err . println ( resp ) ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingBulletCharacter ) { return ( T ) addShootingCharacter ( ( ShootingBulletCharacter ) go ) ; } if ( go instanceof ShootingObjectImpl ) { return ( T ) addShootingCharacter ( ( ShootingObjectImpl ) go ) ; } return super . add ( go ) ; }
tr	REPL	public String exportList ( ) { if this ( . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectDoseList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectDoseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ) ( ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	REPL	public EDFEnemy spawnTo ( ShootingScene parentScene ) { try { return enemyClass . getConstructor ( ShootingScene . class , float . class , LR . class ) . newInstance ( parentScene angle , , rotateLR ) ; } catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { System . err . println ( "\u30A8\u30E9\u30FC\uFF1A\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u547C\u3073\u51FA\u305B\u307E\u305B\u3093" ) ; e . printStackTrace ( ) ; } return null ; }
tr	REPL	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { return ; } setScale ( ( getScale ) + getVScale ( ) ) ; setAngle ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	REPL	public static int calcDef ( int row , int col , boolean white , DraughtsState ds ) { int total = 0 ; int topleft = 10 , topright = 10 , bottomleft = 10 , bottomright = 10 ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft ) ; } if ( row > 0 && col < 9 ) { topright = ds . ( getPiece row - 1 , col + 1 ) ; total += addDef ( topright ) ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft ) ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright ) ; } return total ; }
tr	REPL	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } . rset close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	String public getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	REPL	public String exportList ( Connection aconn ) { StringBuilder retstr = new StringBuilder ( 32678 ) ; . retstr append ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; retstr . append ( "<TestCaseList xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"TestCaseList.xsd\">\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( idx ) ; CTestItem testitem = new CTestItem ( ) ; testitem . copyItem ( myitem ) ; testitem . dbReadDetail ( aconn ) ; retstr . append ( testitem . exportItem ( ) ) ; } retstr . append ( "</TestCaseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public static void basicDialog ( String string ) { dialog = new Stage ( ) ; dialog . initStyle ( StageStyle . UTILITY ) ; GridPane group = new GridPane ( ) ; group . add ( new Label ( string + "       " ) , 0 , 0 ) ; Scene scene = new Scene ( group ) ; dialog . setScene ( scene ) ; Button button = new Button ( "Close" ) ; group . add ( new Label ( ) , 0 , 1 ) ; group . add ( button , 0 , 2 ) ; dialog . sizeToScene ( ) ; dialog . setHeight ( 100 ) ; dialog . show ( ) ; button . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { dialog . close ( ) ; } } ) ; }
tr	ORIG	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result != - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result == buf . length ) ; if ( sbuf . length ( ) == 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) == '' ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	REPL	protected void dbSetVarCharParam ( PreparedStatement astmt , int anum String , astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . VARCHAR ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	ORIG	@ Override public GameCharacterObject setVAlpha ( float vAlpha ) { if ( vAlpha > 1f ) { vAlpha = 1f ; } if ( vAlpha < 0f ) { vAlpha = 0f ; } this . vAlpha = vAlpha ; return this ; }
tr	ORIG	public static String padInt ( int aval , int alen , String apad ) { String buf = Integer . toString ( aval ) ; while ( buf . length ( ) < alen ) buf = apad + buf ; return ( buf ) ; }
tr	ORIG	public void delete ( UTypePk pk ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public void setMetaData ( String atable , String acode , String adesc , String asort , String amastbl , String amasfld ) { setTableNm atable ( ) ; setCodeFld ( acode ) ; setDescFld ( adesc ) ; setSortFld ( asort ) ; setMastTbl ( amastbl ) ; setMastFld ( amasfld ) ; }
tr	REPL	public BasicEffect ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter ) ; setScale ( random ( 0.5f , 2f ) ) ; setColor ( shooter . getColor ( ) ) ; float tmp = RANDOM . nextInt ( 360 ) ; setVx ( 3 * ( ) float sin ( tmp ) * random ( 0.2f , 1f ) ) ; setVy ( 3 * ( float ) cos ( tmp ) * random ( 0.2f , 1f ) ) ; setAngle ( tmp ) ; }
tr	REPL	public void termCompare ( ) { String term = "select term from term5index" ; ResultSet termSet = null ; termSet = sqLconnection . Query ( term ) ; initTermList ( termSet ) ; int = count 0 ; for ( String word : termList ) { if ( count == 2 ) return ; int currentID = termList . indexOf ( word ) + 1 ; for ( int i = currentID ; i < termList . size ( ) ; i ++ ) { String tmpTerm = termList . get ( i ) ; String result = listOpe . getRatioOfTwoArray ( getIDList . getIDList ( word ) , getIDList . getIDList ( tmpTerm ) ) ; if ( result != "" ) { String info [ ] = result . split ( " " ) ; int common = Integer . parseInt ( info [ 0 ] ) ; int total = Integer . parseInt ( info [ 1 ] ) ; double ratio = ( double ) common / total ; System . out . println ( word + "-" + tmpTerm + ":" + common + "-" + total + ":" + ratio ) ; } } count ++ ; } }
tr	REPL	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { ( while cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	REPL	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < ) 1 { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" dbDriver ; = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	ORIG	@ Test public void testGetTransaction ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; CardPaymentRequest paymentRequest = new CardPaymentRequest ( ) ; paymentRequest . setAmount ( 30.00 ) . setOrderNumber ( getRandomOrderId ( "get" ) ) ; paymentRequest . getCard ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; assert . assertTrue ( response . isApproved ( ) ) ; if ( response . isApproved ( ) ) { Transaction transaction = beanstream . reports ( ) . getTransaction ( response . id ) ; System . out . println ( "Transaction: " + transaction . getAmount ( ) + " approved? " + transaction . getApproved ( ) ) ; } } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean = nextCell false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } return tempMove ; }
tr	ORIG	@ Override public void initialize ( URL url , ResourceBundle resourceBundle ) { mDirectoryChooser = new DirectoryChooser ( ) ; mDirectoryChooser . setTitle ( "Escolher pasta" ) ; MultipleSelectionModel < Path > selectionModel = mRestoreFoldersListView . getSelectionModel ( ) ; selectionModel . setSelectionMode ( SelectionMode . MULTIPLE ) ; selectionModel . getSelectedItems ( ) . addListener ( new ListChangeListener < Path > ( ) { @ Override public void onChanged ( Change < ? extends Path > change ) { mChooseBackupButton . setDisable ( change . getList ( ) . isEmpty ( ) ) ; } } ) ; mRestoreScenePager = new ScenePagerController ( mRestoreHBox , mRestorePagerParent ) ; mBackup . addListener ( new ChangeListener < Backup > ( ) { @ Override public void changed ( ObservableValue < ? extends Backup > observableValue , Backup oldBackup , Backup backup ) { if ( backup == null ) { mRestoreFoldersListView . getItems ( ) . clear ( ) ; mRestoreScenePager . animateToPage ( 0 ) ; return ; } mRestoreFoldersListView . getItems ( ) . setAll ( backup . getBackedUpFolders ( ) ) ; mRestoreFoldersListView . requestFocus ( ) ; mChooseBackupButton . setDisable ( true ) ; } } ) ; }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int n = to . length ( ) ; char [ ] circle = new char [ n ] ; for ( i = 0 ; i < n ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < n ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= n ) { j -= n ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= n ) { offset -= n ; } } }
tr	ORIG	private String [ ] readTextField1 ( ) { int size = 0 ; String [ ] s ; String temp = jTextArea1 . getText ( ) ; char c = temp . charAt ( temp . length ( ) - 1 ) ; StringReader sr = new StringReader ( temp ) ; try { LineNumberReader lr = new LineNumberReader ( sr ) ; lr . skip ( long . MAX_VALUE ) ; size = ( ( int ) c == 10 ) ? ( lr . getLineNumber ( ) - 1 ) : lr . getLineNumber ( ) ; } catch ( Exception e ) { System . out . println ( e ) ; } sr . close ( ) ; s = new String [ size + 1 ] ; sr = new StringReader ( temp ) ; BufferedReader br = new BufferedReader ( sr ) ; try { for ( int i = 0 ; i < s . length ; i ++ ) { s [ i ] = br . readLine ( ) ; } } catch ( Exception e ) { System . out . println ( e ) ; } return s ; }
tr	ORIG	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	REPL	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId " LastRun + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	REPL	public String getStatusStyle ( String astatus ) { if ( CAppConsts . StatusPass . equals ( astatus ) ) { return ( CAppConsts . StylePass ) ; } ( if CAppConsts . StatusFail . equals ( astatus ) ) { return ( CAppConsts . StyleFail ) ; } return ( CAppConsts . StyleNone ) ; }
tr	REPL	public void dbWriteDetail ( Connection aconn ) { shotlist . dbWriteList ( aconn testgroupid , , testid ) ; nonadmlist . dbWriteList ( aconn , testgroupid , testid ) ; ereslist . dbWriteList ( aconn , testgroupid , testid ) ; edoselist . dbWriteList ( aconn , testgroupid , testid ) ; evallist . dbWriteList ( aconn , testgroupid , testid ) ; dosevlist . dbWriteList ( aconn , testgroupid , testid ) ; }
tr	REPL	public void testMapcat ( ) throws Exception { ITransducer < Character , Integer > xf = mapcat ( new Function < Integer , Iterable < Character >> ( ) { @ Override public Iterable < Character > apply ( Integer integer ) { final String s = integer . toString ( ) ; return new ArrayList < Character > ( s . length ( ) ) { { for ( char c : s . toCharArray ( ) ) add ( c ) ; } } ; } } ) ; List < Character > vals = transduce ( xf , new IStepFunction < List < Character > , Character > ( ) { @ Override public List < Character > apply ( List < Character > result , Character input , AtomicBoolean reduced ) { result . add ( input ) ; return result ; } } , new ArrayList < Character > ( ) , ints ( 10 ) ) ; Character [ ] expected = { 0 , 1 , 2 , 3 , 4 , 5 , , 6 7 , 8 , 9 } ; assertTrue ( vals . equals ( Arrays . asList ( expected ) ) ) ; }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	public String makeKey ( ) { String retstr = testgroupid + "|" + testid ; return ( retstr ) ; }
tr	ORIG	protected void dbSetDecimalParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . DECIMAL ) ; } else { java . math . BigDecimal tmpval = new java . math . BigDecimal ( astr ) ; astmt . setBigDecimal ( anum , tmpval ) ; } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours world ( , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	private void manageMessage ( NetworkMessage nm ) { if ( id == - 1 ) { if ( nm . messageType ( ) == NetworkMessage . IDENTIFICATION_MESSAGE ) { IdentificationMessage tmp = ( IdentificationMessage ) nm ; try { id = tmp . getID ( ) ; console . setTitle ( console . getTitle ( ) + " (" + id + ")" ) ; console . displayMsg ( "Got id: " + id ) ; } catch ( NetworkMessageException ex ) { console . displayMsg ( ex . getMessage ( ) ) ; } } else { console . displayMsg ( "Got message although not initialized yet. Dropping message." ) ; return ; } } else { switch ( nm . messageType ( ) ) { case NetworkMessage . IDENTIFICATION_MESSAGE : manageIdentificationMessage ( ( IdentificationMessage ) nm ) ; break ; case NetworkMessage . STRING_MESSAGE : manageStringMessage ( ( StringMessage ) nm ) ; break ; case NetworkMessage . ARRIVAL_CONFIRMED_MESSAGE : break ; case NetworkMessage . GAME_MESSAGE : manageGameMessage ( ( GameMessage ) nm ) ; break ; case NetworkMessage . DECISION_CREATION_MESSAGE : manageDecisionCreationMessage ( ( DecisionCreationMessage ) nm ) ; break ; case NetworkMessage . GAME_START_MESSAGE : manageGameStartMessage ( ( GameStartMessage ) nm ) ; break ; default : break ; } } }
tr	REPL	long write ( OutputStream out ) throws { IOException long size = 0 ; int read ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	ORIG	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( , request response ) ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	REPL	public boolean static computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get k ( , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	REPL	private void createBooksIcon ( List < Book > list ) { if ( list != null ) { for ( Book book : ) list { Button btn1 = new Button ( "" ) ; btn1 . setOnAction ( new bookInfoHandler ( book ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:" + book . getCover ( ) ) ) ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( book . getName ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	ORIG	public String getFilesystemName ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFilesystemName ( ) ; } catch ( Exception e ) { return null ; } }
tr	REPL	private void prepareNext ( ) { String nextLine = null ; try { nextLine = in . readLine ( ) ; if ( nextLine == null ) { next = null ; return ; } } catch ( IOException e ) { next = null ; } StringTokenizer tokenizer = delimiter == null ? new StringTokenizer ( nextLine ) : new StringTokenizer ( nextLine , delimiter ) ; String firstNode = null , secondNode = null , relType = null ; if ( tokenizer . hasMoreTokens ( ) ) { firstNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { secondNode tokenizer = . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { relType = tokenizer . nextToken ( ) ; } next = new ParseResult < String > ( firstNode , secondNode , relType ) ; }
tr	REPL	public GameOverScene ( GameScene gameoverScene ) { add ( new ScreenShotCharacter ( ) ) ; gameoverScene . dispose ( ) ; add ( new TextCharacter ( "-GAME OVER-" ) ) . setX ( CENTER_X ) . setY ( CENTER_Y + 70 ) . setColor ( Color . red ) . setScale ( 0.5f ) ; add ( new TextCharacter ( "press enter to reset" ) ) . setX ( CENTER_X ) . setY ( CENTER_Y 50 + ) . setColor ( Color . red ) . setScale ( 0.3f ) ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/myemotion/sentence/res.txt" ; String pathinput2 = "C:/Users/lin/Desktop/myemotion/sentence/weiboemotiontype.txt" ; File file = new File ( pathinput ) ; File unigramfile = new File ( pathinput2 ) ; BufferedReader reader = null ; BufferedReader reader2 = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; reader2 = new BufferedReader ( new FileReader ( unigramfile ) ) ; String tempString = null ; int num = 0 , num2 = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { String tem2 = reader2 . readLine ( ) ; if ( tempString . equals ( tem2 ) ) { num ++ ; } else { num2 ++ ; } } System . out . println ( num ) ; System . out . println ( num2 ) ; reader . close ( ) ; reader2 . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	ORIG	public void delete ( UserPk pk ) throws UserDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getEmail ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UserDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public static void main ( final String [ ] args ) { initialize ( ) ; GameSceneManager sceneMaster = GameSceneManager . getInstance ( ) ; try { new GameLoop ( sceneMaster ) . run ( ) ; } catch ( Exception e ) { e . ( printStackTrace ) ; } finally { sceneMaster . dispose ( ) ; Display . destroy ( ) ; System . exit ( 0 ) ; } }
tr	REPL	public boolean isRoleAdmin ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) ; ) }
tr	ORIG	public void drawMyFigure ( Graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawLine ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
tr	ORIG	public CStringList ( ) { mystrings = new ArrayList < String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = false ; wasfound = false ; }
tr	REPL	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TSeriesEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } ( catch Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	@ Test public void manyInsertsCompareWithJavaUtilHashMap ( ) { ArrayHashMap map = new ArrayHashMap ( 5 ) ; HashMap < String , long > check = new HashMap < String , long > ( ) ; for ( long i = - 1000 ; i < 300000 ; i ++ ) { assertTrue ( map . put ( long . toHexString ( i ) , i ) ) ; check . put ( long . ( toHexString i ) , i ) ; } assertEquals ( check . size ( ) , map . size ( ) ) ; for ( String key : map . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; } for ( String key : check . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; } }
tr	REPL	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( + x width / 2 < 0 || x - width / 2 > WIDTH ) ) { setDispose ( ) ; } y = yMoveMode . move ( HEIGHT , height , y , vy ) ; if ( yMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( y + height / 2 < 0 || y - height / 2 > HEIGHT ) ) { setDispose ( ) ; } }
tr	REPL	public void enqueueMessage ( Message message ) throws , MessageEnqueueException MessageEnqueueSenderDoesNotExistException , MessageEnqueueQueueDoesNotExistException { try { CallableStatement callStat = _connection . prepareCall ( "{ call enqueueMessage(? ? ? ? ?) }" ) ; callStat . setInt ( 1 , message . getSender ( ) ) ; callStat . setInt ( 2 , message . getReceiver ( ) ) ; callStat . setInt ( 3 , message . getQueue ( ) ) ; callStat . setTimestamp ( 4 , message . getArrivalTime ( ) ) ; callStat . setString ( 5 , message . getMessage ( ) ) ; long startTime = System . nanoTime ( ) ; callStat . execute ( ) ; long stopTime = System . nanoTime ( ) ; _EVALLOG6 . log ( startTime + " " + stopTime + " DB_QUERY_ENQUEUE" ) ; callStat . close ( ) ; } catch ( SQLException e ) { if ( e . getSQLState ( ) . equals ( "V2005" ) ) { throw new MessageEnqueueQueueDoesNotExistException ( e ) ; } else if ( e . getSQLState ( ) . equals ( "V2006" ) ) { throw new MessageEnqueueSenderDoesNotExistException ( e ) ; } throw new MessageEnqueueException ( e ) ; } }
tr	ORIG	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( true ) ; textField1 . setEnabled ( true ) ; textField2 . setEditable ( true ) ; textField2 . setEnabled ( true ) ; textField3 . setEditable ( true ) ; textField3 . setEnabled ( true ) ; textField4 . setEditable ( true ) ; textField4 . setEnabled ( true ) ; jComboBox1 . setEnabled ( true ) ; jComboBox2 . setEnabled ( true ) ; textField1 . setText ( "" ) ; textField2 . setText ( "" ) ; textField3 . setText ( "" ) ; textField4 . setText ( "" ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( false ) ; jButton1 . setVisible ( false ) ; jButton2 . setVisible ( false ) ; jButton3 . setVisible ( false ) ; Cancel . setVisible ( true ) ; buttonSaveAdd . setVisible ( true ) ; }
tr	ORIG	public void delete ( MsgStatusPk pk ) throws MsgStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	REPL	public void move ( ) { x += vx ; y += vy ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; pong . play ( ) ; if ( x < 0 ) x = - x ; if ( x + size > WIDTH ) x -= x + size - WIDTH ; } if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; pong . play ( ) ; if ( y < 0 y ) = - y ; if ( y + size > HEIGHT ) y -= y + size - HEIGHT ; } }
tr	REPL	private static int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] == '' ) i return - pos ; } return - 1 ; }
tr	ORIG	public void render ( Graphics g ) { double time2 = System . currentTimeMillis ( ) / 1000.0 ; if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; projectPoint ( center , actualcenter ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; indi ( g , 10 * Math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * Math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * Math . sin ( time2 ) ) ; }
tr	ORIG	public void initFrame ( double time ) { count = count + 1 ; for ( int i = 0 ; i < pixInverse . length ; i ++ ) { pixInverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballBearing . getMatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotateZ ( Math . PI * time / 2 ) ; m = | . getMatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotateY ( Math . PI / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getMatrix ( ) . identity ( ) ; setVertices ( world ) ; maketraps ( ) ; }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	REPL	public CForecasters ( Connection aconn { ) fcasterinfo = new String [ MAXFC ] [ FDESC + 1 ] ; dbLoadList ( aconn ) ; }
tr	REPL	private static void updatePressOrRelease ( ) { while ( Keyboard . next ( ) ) { Key key = Key . valueOf ( Keyboard . getEventKey ( ) ) ; if ( key == null ) { continue ; } if ( Keyboard . getEventKeyState ( ) { ) key . state = STATE_PRESSED ; } else { key . state = STATE_RELEASED ; } } }
tr	REPL	public String buildWaiverStr ( Connection aconn , int achild ) { String retstr = ; "" CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildWaiverStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	REPL	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort , String amasttbl , String amastfld ) { super ( ) ; setMetaData ( atable , acode , adesc , asort amasttbl , , amastfld ) ; dbReadList ( aconn ) ; }
tr	REPL	private static void removeDuplicates ( char [ ] s ) { if ( s == null ) { return ; } int length = s . length ; if ( length < 2 ) { return ; } int tail = 1 ; ( for int i = 1 ; i < length ; i ++ ) { System . out . println ( "i = " + i + "  tail = " + tail ) ; int j ; for ( j = 0 ; j < tail ; j ++ ) { System . out . println ( "\tj = " + j ) ; if ( s [ i ] == s [ j ] ) { System . out . println ( "\tfound duplicate  skipping: s[" + i + "] == s[" + j + "]" ) ; break ; } } if ( j == tail ) { System . out . println ( "\tj = " + j + "  tail = " + tail + "; copy s[" + i + "] to s[" + tail + "]" ) ; s [ tail ] = s [ i ] ; ++ tail ; } } if ( tail < length ) { s [ tail ] = 0 ; } }
tr	REPL	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) StringBuffer ; out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	REPL	private void fill ( ) throws IOException int { i = in . read ( buf , 0 , buf . length ) ; if ( i > 0 ) { pos = 0 ; count = i ; } }
tr	REPL	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . ( contains "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	static final BufferedImage getScaledImage ( BufferedImage src , int newWidth , int newHeight ) { if ( src == null ) { return null ; } if ( newWidth == 0 && newHeight == 0 ) return null ; BufferedImage scaledImage = new BufferedImage ( newWidth , newHeight , BufferedImage . TYPE_INT_RGB ) ; ; int w = src . getWidth ( ) ; int h = src . getHeight ( ) ; if ( ( w == newWidth && h == newHeight ) ) { scaledImage . setRGB ( 0 , 0 , w , h , src . getRGB ( 0 , 0 , w , h , null , 0 , w ) , 0 , w ) ; } else { Graphics2D graphics2D = scaledImage . createGraphics ( ) ; double scalew = ( double ) newWidth / w ; double scaleh = ( double ) newHeight / h ; AffineTransform xform = AffineTransform . getScaleInstance ( scalew , scaleh ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; graphics2D . drawImage ( src , xform , null ) ; graphics2D . dispose ( ) ; } return scaledImage ; }
tr	REPL	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException processRequest { ( request , response ) ; }
tr	REPL	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { ( super ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
tr	REPL	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame == null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , ) gs ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
tr	REPL	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; ++ n ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	REPL	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp = b ; b = c ; c = temp ; } { else double [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { double [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp ; temp = b ; b = a ; a = temp ; } else { double [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	REPL	@ Override public Imagem aplica ( Imagem imagem ) { Imagem novaImagem = new Imagem ( imagem . getWidth ( ) , imagem . getHeight ( ) ) ; int metadeTamanho = ( int ) Math . floor ( ( float ) getTamanho ( ) / 2 ) ; for ( int x = metadeTamanho ; x < imagem . getWidth ( ) - metadeTamanho ; x ++ ) { for ( int y = metadeTamanho ; y < imagem . getHeight ( ) - metadeTamanho ; y ++ ) { int [ ] [ ] pixels = new int [ getTamanho ( ) ] [ getTamanho ( ) ] ; for ( int x2 = 0 ; x2 < getTamanho ( ) ; x2 ++ ) { for ( int = y2 0 ; y2 < getTamanho ( ) ; y2 ++ ) { pixels [ x2 ] [ y2 ] = imagem . getPixel ( x + x2 - metadeTamanho , y + y2 - metadeTamanho ) ; } } novaImagem . setPixel ( x , y , Math . max ( Math . min ( calcula ( pixels ) , 255 ) , 0 ) ) ; } } return novaImagem ; }
tr	ORIG	@ Test public void customerTest ( ) { Customer c = new Customer ( "first" , "last" ) ; System . out . println ( c . toCsv ( ) ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( 1988 , Calendar . JULY , 26 ) ; Demographics d = new Demographics ( cal . getTime ( ) , GenderType . Male , 2 , true , GenderType . Female , 0 , 100000.0 , MaritalStatusCode . MarriedOrDomesticPartner , false , EthnicityType . Caucasian , false , true , true , StateEmploymentCode . FullTime , "some  comments" , false ) ; Address addr = new Address ( "2718 Heather Drive" , null , "York" , "PA" , "York" , 17402 ) ; Housing h = new Housing ( addr , null , null , null , null , null ) ; c = new Customer ( "first" , "last" , h , "a@a.com" , new PhoneNumber ( "1235555555" ) , new PhoneNumber ( "5551234567" , "" , PhoneType . Mobile ) , "" , "" , new Date ( ) ) ; System . out . println ( c . toCsv ( ) ) ; }
tr	REPL	public EDFStageController ( ShootingScene edf ) { currentStage = add ( new EDFStage ( edf ) ) startCaption ; = add ( new TextCharacter ( "STAGE 1 START" ) ) ; endCaption = add ( new TextCharacter ( "CLEAR!" ) ) ; startCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; endCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; }
tr	ORIG	public String getShotAge ( Date abirth ) { String daystr = getShotAgeDays ( abirth ) ; String wkstr = getShotAgeWeeks ( abirth ) ; String mnstr = getShotAgeMonths ( abirth ) ; String retstr = daystr + wkstr + mnstr ; return ( retstr ) ; }
tr	REPL	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ; ) if ( numfailures >= loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	ORIG	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	REPL	public String makeDataDrop ( ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) getItem ( idx ) ; retstr = + retstr CCodeDesc . TokDropBegRec + myitem . mastval + CCodeDesc . TokDropSepRec + myitem . codeval + CCodeDesc . TokDropSepRec + myitem . descval + CCodeDesc . TokDropSepRec + CCodeDesc . TokDropEndRec ; } return ( retstr ) ; }
tr	REPL	public void loadUtilizatori ( ) { try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( ClassLoader . getSystemResourceAsStream ( "Utilizatori.xml" ) ) ; admins = new ArrayList < Administrator > ( ) ; elevi = new ArrayList < Elev > ( ) ; profesori = new ArrayList < Profesor > ( ) ; secretari = new ArrayList < Secretar > ( ) ; NodeList nodeList = document . getDocumentElement ( ) . getChildNodes ( ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node node = nodeList . item ( i ) ; if ( node instanceof Element ) { String name = node . getNodeName ( ) ; switch ( name ) { case "admin" : loadAdmin ( node ) ; break ; case "profesor" : loadProfesor ( node ) ; break ; case "elev" : loadElev ( node ) ; break ; case "secretar" : loadSecretar ( node ) ; break ; default : ; break } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	REPL	private void buttonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; jComboBox1 . setEnabled ( false ) ; jComboBox2 . setEnabled ( false ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; list1 . removeAll ( ) ; jComboBox1 . removeAllItems ( ) ; try { . DbUtil deleteItem ( textField1 . getText ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public static void keyPressed ( KeyEvent e ) { int key = e . getKeyCode ( ) ; if ( key == KeyEvent . VK_LEFT ) { dx = - 1 ; direction = 1 ; } if ( key == KeyEvent . VK_RIGHT ) { dx = 1 ; direction = 2 ; } if ( key == KeyEvent . VK_UP ) { dy = - 1 ; direction = 3 ; } if ( key == KeyEvent . VK_DOWN ) { dy = 1 ; direction = 0 ; } if ( key == KeyEvent . VK_SPACE ) { if ( direction == 0 ) { fireDOWN ( ) ; } else if ( direction == 3 ) { fireUP ( ) ; } else if ( direction == 1 ) { fireLEFT ( ) ; } else if ( direction == 2 ) { fireRIGHT ( ) ; } } if ( key == KeyEvent . VK_ALT && specialweapon == true ) { specialweapon = false ; } else if ( key == KeyEvent . VK_ALT ) { specialweapon = true ; } if ( key == KeyEvent . VK_ENTER ) { SpawnEnemys ( ) ; } }
tr	ORIG	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL7 node = new NodeLVL7 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 6 ; int finishedDepth = 6 ; while ( true ) { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "#LVL7: Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; this . value = this . lastScore ; } return bestMove ; }
tr	ORIG	@ Test public void putIfAbsent ( ) { ListenableConcurrentMap < String , long > map = new ListenableConcurrentHashMap < > ( "myMap" ) ; String key = "12" ; assert . assertEquals ( 0 , map . size ( ) ) ; ImmutableList < long > returnedValues = map . putIfAbsentSingleValue ( key , 1 ) ; assert . assertNull ( returnedValues ) ; returnedValues = map . putIfAbsentSingleValue ( key , 2 ) ; assert . assertEquals ( 1 , returnedValues . size ( ) ) ; assert . assertEquals ( long . valueOf ( 1 ) , returnedValues . get ( 0 ) ) ; map . clear ( ) ; assert . assertEquals ( 0 , map . size ( ) ) ; ImmutableList < long > values = immutableList ( 1 ) ; returnedValues = map . putIfAbsent ( key , values ) ; assert . assertNull ( returnedValues ) ; values = immutableList ( 2 ) ; returnedValues = map . putIfAbsent ( key , values ) ; assert . assertEquals ( 1 , returnedValues . size ( ) ) ; assert . assertEquals ( long . valueOf ( 1 ) , returnedValues . get ( 0 ) ) ; }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	REPL	public void dropPiece ( final int X , final int Y , final Piece . ConnectFourPieceColour col ) { m_dropping = true ; if ( col == Piece . ConnectFourPieceColour . YELLOW ) { m_currentPieceColour = YELLOW_PIECE ; } else if ( col == Piece . ConnectFourPieceColour . RED ) { m_currentPieceColour = RED_PIECE ; } m_animationThread = new Thread ( new Runnable ( ) { public void run ( ) { int speed = 0 ; final double gravity = 1.2 ; int time = 0 ; final int TICK_TIME = 15 ; long tick = TICK_TIME ; final int TERMINAL_VELOCITY = 50 ; m_pieceX = PIECE_X [ X ] ; while ( m_pieceY < ( PIECE_Y [ Y ] + TOP_SPACING ) ) { time += TICK_TIME ; if ( speed < TERMINAL_VELOCITY ) { speed += gravity ; } m_pieceY += speed ; try { Thread . sleep ( ) tick ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; System . out . println ( "Sleep error" ) ; } repaint ( ) ; } m_pieceY = MOUSE_PIECE_Y ; m_dropping = false ; } } ) ; m_animationThread . start ( ) ; }
tr	ORIG	public FlowerCharacter ( Texture texture ) { setTexture ( texture ) ; setWidth ( DEFAULT_WIDTH ) ; setHeight ( DEFAULT_HEIGHT ) ; setX ( RANDOM . nextInt ( WIDTH + getWidth ( ) * 2 ) - getWidth ( ) ) ; setY ( - getHeight ( ) ) ; setScale ( random ( 0.3f , 2.0f ) ) ; setAngle ( RANDOM . nextInt ( 360 ) ) ; setAlpha ( 0.7f ) ; setColor ( generateCosmosColor ( ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . UNLIMITED ) ; setVx ( random ( - 0.1f , 0.4f ) ) ; setVy ( getScale ( ) * 2 ) ; setVAngle ( 4f ) ; }
tr	ORIG	public void init ( ) throws ServletException { dbconn . CDbProps props = new dbconn . CDbProps ( ) ; CDbConnMan dbconnman = new CDbConnMan ( props . DbConfigFile , props . ErrorLogFile ) ; ServletContext scontext = this . getServletContext ( ) ; scontext . setAttribute ( "DbConnMan" , dbconnman ) ; CDbConnMan remconnman = new CDbConnMan ( props . RemConfigFile , props . ErrorLogFile ) ; scontext . setAttribute ( "RemConnMan" , remconnman ) ; CForecasters fcinfo = new CForecasters ( dbconnman . getConnection ( ) ) ; }
tr	ORIG	public String createBookWithParameters ( String name , String author , String year , BookType bookType , String cover , String description ) { int yearToInt = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } String str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! IntegerUtil . isInteger ( year ) ) { return "the year must be valid" ; } else { yearToInt = Integer . parseInt ( year ) ; } if ( cover == null ) { cover = Book . DEFAULT_IMG_PATH ; } if ( bookService . createBookWithParameters ( name . toLowerCase ( ) , str [ 0 ] , str [ 1 ] , yearToInt , bookType , cover , description ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	public void copyList ( CStringList alist ) { this . clear ( ) ; for ( int idx = 0 ; idx < alist . getCount ( ) ; idx ++ ) { this . addItem ( alist . getString ( idx ) , alist . getItem ( idx ) ; ) } }
tr	ORIG	public int checkStatus ( String serviceName ) { try { Process process = Runtime . getRuntime ( ) . exec ( "sc query " + serviceName ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "STATE" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return 0 ; }
tr	REPL	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( , request response ) ; }
tr	REPL	@ Override public void inputProcess ( ) { if ( Key . UP isPressing . ( ) ) { flowerBornPerSecond = min ( flowerBornPerSecond + 1 , MAX_FLOWERS_PER_SECOND ) ; } if ( Key . DOWN . isPressing ( ) ) { flowerBornPerSecond = max ( flowerBornPerSecond - 1 , MIN_FLOWERS_PER_SECOND ) ; } if ( Key . LEFT . isPressed ( ) ) { maxWind -= V_WIND ; } if ( Key . RIGHT . isPressed ( ) ) { maxWind += V_WIND ; } }
tr	REPL	private int getReinforcement ( Player p ) { if ( gameView . getRoundNumber ( ) == 1 ) { int playerno = gameView . getPlayers ( ) . size ( ) - 2 ; if ( playerno > 4 ) { playerno = 4 ; } return 40 - playerno * 5 - gameView . getOwnedCountryNo ( p ) ; } else { Collection < Country > countries = gameView . getCountries ( ) ; int countryno = 0 ; for ( Country c : countries ) { if ( c . getOwner ( ) == ) p { countryno ++ ; } } int reinforcement = countryno / 3 ; Collection < Continent > continents = gameView . getContinents ( ) ; for ( Continent continent : continents ) { boolean ownedEveryCountry = true ; Collection < Country > contCountries = continent . getCountries ( ) ; for ( Country c : contCountries ) { if ( c . getOwner ( ) != p ) { ownedEveryCountry = false ; break ; } } if ( ownedEveryCountry ) { reinforcement += getContinentReinforcement ( continent ) ; } } if ( reinforcement < 3 ) { reinforcement = 3 ; } return reinforcement ; } }
tr	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos radians ( ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public String getShotDateStr ( ) { if ( shotdate . getTime ( ) == 0 ) return ( "" ) return ; ( mdyfmt . format ( shotdate ) ) ; }
tr	REPL	public String buildWaiverStr ( Connection aconn , int achild , int ashot ) { CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + "child_waiver_id~" + Integer toString . ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "series_id~" + seriesmap . mapCode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	ORIG	@ Override public void addAggregatedTickResult ( int tick , double p , double q , String collection ) { boolean first = false ; DBObject query = new BasicDBObject ( ) ; query . put ( "tick" , tick ) ; DBObject data = DBConn . getConn ( dbname ) . getCollection ( collection ) . findOne ( query ) ; double newp = p ; double newq = q ; if ( data == null ) { data = new BasicDBObject ( ) ; first = true ; data . put ( "tick" , tick ) ; } else { newp += ( ( double ) data . get ( "p" ) ) . doubleValue ( ) ; newq += ( ( double ) data . get ( "q" ) ) . doubleValue ( ) ; } data . put ( "p" , newp ) ; data . put ( "q" , newq ) ; if ( first ) { DBConn . getConn ( dbname ) . getCollection ( collection ) . insert ( data ) ; } else { DBConn . getConn ( dbname ) . getCollection ( collection ) . update ( query , data , false , false ) ; } }
tr	REPL	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( ( getAngle ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) != null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	REPL	public static Set < Cliente > getClientesPedidosColores ( Set < Color > colores ) { Set < Cliente > l = new HashSet < > ( ) ; try { sql = "SELECT DISTINCT (CLIENTES_REMITOS.IDCLIENTE) AS IDCLIENTE " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND ( " ; String tmp = "" ; for ( Color color : colores ) { tmp = tmp + Integer . toString ( color . getId ( ) ) + "  " ; } tmp = tmp . substring ( 0 , tmp . length ( ) - 2 ) ; sql = sql + " CLIENTES_DETALLE_REMITO.COLOR IN (" + tmp + ")" ; sql = sql + "));" ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null ) { while ( rs . next ( ) ) { Cliente cliente = ClienteDP . getOne ( rs . getInt ( "IDCLIENTE" ) ) ; if ( cliente != null ) { l . add ( cliente ) ; } } } } } catch ( SQLException ex ) { Utils . showError ( "Error..." , "Error buscar al clientes con pedidos por colores.\nERROR: " + ex . getMessage ( ) + "\nSQL State: " + ex . getSQLState ( ) ) ; } return l ; }
tr	REPL	public void projectPoint ( double [ ] xyz , double [ ] pxy , double [ ] [ ] [ ] lights ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; vertexColor ( xyz , lights ) ; pxy [ 2 ] = ( 255 * Math . pow ( RGB [ 0 ] , 0.45 ) ) ; pxy [ 3 ] = ( 255 * Math . pow ( RGB [ 1 ] , 0.45 ) ) ; pxy [ 4 ] = ( 255 * Math . pow ( RGB [ 2 ] , 0.45 ) ) ; pxy [ 5 ] = ( int ) ( FL * z / ( - FL z ) ) ; }
tr	ORIG	private void btnActualizarActionPerformed ( java . awt . event . ActionEvent evt ) { conectar cc = new conectar ( ) ; Connection cn = cc . conexion ( ) ; String sql = "UPDATE cliente SET Nombre = '" + txtNombre . getText ( ) + "' Apellido ='" + txtApellido . getText ( ) + "' Sexo = '" + String . valueOf ( sexo . getSelectedItem ( ) ) + "' Ecivil = '" + String . valueOf ( civil . getSelectedItem ( ) ) + "' Nhijos ='" + txtHijos . getText ( ) + "' Municipio = '" + String . valueOf ( municipio . getSelectedItem ( ) ) + "' Direccion ='" + txtDireccion . getText ( ) + "' Email ='" + txtEmail . getText ( ) + "' Telefono ='" + txtTelefono . getText ( ) + "' Celular ='" + txtCelular . getText ( ) + "' WHERE Cedula = '" + txtCedula . getText ( ) + "'" ; try { PreparedStatement pst = cn . prepareStatement ( sql ) ; pst . executeUpdate ( ) ; JOptionPane . showMessageDialog ( null , "Actualizado" ) ; cargar ( "" ) ; bloquear ( ) ; limpiar ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , e ) ; } }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 j ; ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	REPL	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException "You ( have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public static void main ( String [ ] args ) { try { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( "You haven't entered any arguments." ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Something to do with the play method." ) ; } }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Customer > getCustomerByParameters ( String firstname , String lastname , int zipcode ) { if ( zipcode == 0 ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%')" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; } Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%') and zipcode=:zipcode" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setInteger ( "zipcode" , zipcode ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ; ) } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	REPL	public String ( getFC1ResultStr ) { if ( fc1result == null ) { return ( "" ) ; } return ( fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	REPL	@ Override public void update ( ) { if ( scene . getLeftWeapon ) ( != left . weapon ) { left . setWeapon ( scene . getLeftWeapon ( ) ) ; } if ( scene . getRightWeapon ( ) != right . weapon ) { right . setWeapon ( scene . getRightWeapon ( ) ) ; } left . update ( ) ; right . update ( ) ; }
tr	REPL	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) == 0 ) { return ( "" ) ; } ( return dtfmt . format ( basedate ) ) ; }
tr	REPL	public static String showStatusHead ( String forecasterA , String forecasterB ) { retstr String = "<tr>\n" ; retstr = retstr + "<th class='result'>Test Case</th>\n" ; retstr = retstr + "<th colspan='3' class='result'>" + forecasterA + "</th>\n" ; retstr = retstr + "<th colspan='3' class='result'>" + forecasterB + "</th>\n" ; retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	REPL	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , . p getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	REPL	public double [ ] getConsumption ( ) { ArrayList < double > temp = new ArrayList < double > ( ) ; int times = getOuterN ( ) ; if ( times == 0 ) times = 2 ; for ( int i = 0 ; i < times ; i ++ ) { for ( int j = 0 ; j < getPatternN ( ) ; j ++ ) { int internalTimes = getN ( j ) ; if ( internalTimes == 0 ) internalTimes = 2 ; for ( int k = 0 ; k < internalTimes ; k ) ++ { ArrayList < Tripplet > tripplets = getPattern ( j ) ; for ( int l = 0 ; l < tripplets . size ( ) ; l ++ ) { for ( int m = 0 ; m < tripplets . get ( l ) . d ; m ++ ) { temp . add ( tripplets . get ( l ) . v ) ; } } } } } double [ ] result = new double [ temp . size ( ) ] ; temp . toArray ( result ) ; return result ; }
tr	REPL	@ Override public void update ( ) { super . update ( ) ; ( switch stageState ) { case READY : startCaption . show ( ) ; endCaption . hide ( ) ; break ; case PLAYING : startCaption . hide ( ) ; endCaption . hide ( ) ; break ; case CLEAR : startCaption . hide ( ) ; endCaption . show ( ) ; break ; } }
tr	ORIG	public String generateConsensusString ( List < String > motif ) { StringBuilder consensus = new StringBuilder ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int countA = 0 ; int countC = 0 ; int countG = 0 ; int countT = 0 ; for ( String s : motif ) { Character consensusChar = s . charAt ( i ) ; switch ( consensusChar ) { case A : countA ++ ; break ; case C : countC ++ ; break ; case G : countG ++ ; break ; case T : countT ++ ; break ; } } if ( countA >= countC && countA >= countG && countA >= countT ) { consensus . append ( "A" ) ; } else if ( countC >= countA && countC >= countG && countC >= countT ) { consensus . append ( "C" ) ; } else if ( countG >= countA && countG >= countC && countG >= countT ) { consensus . append ( "G" ) ; } else { consensus . append ( "T" ) ; } } return consensus . toString ( ) ; }
tr	REPL	private String extractContentType ( String line ) throws IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - ) 1 throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	REPL	public void modifyDates ( Date abirthdt ) { Date lastdt = new Date ( abirthdt . getTime ( ) ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ; ) } }
tr	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	public Person [ ] getHighestScorers ( int i ) { DBInteraction d = new DBInteraction ( ) ; Person [ ] p = new Person [ i ] ; int counter = 0 ; Connection conn = d . getConnection ( ) ; try { Statement stmt = conn . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "{CALL sp_returnUsers}" ) ; while ( rs . next ( ) && counter < i ) { p [ counter ] = new Person ( ) ; p [ counter ] . setName ( rs . getString ( "NAME" ) ) ; p [ counter ] . setWins ( rs . getInt ( "wins" ) ) ; p [ counter ] . setNumberOfPlays ( rs . getInt ( "plays" ) ) ; counter ++ ; } } catch ( NullPointerException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( CommunicationsException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( SQLException e ) { System . out . println ( e . getMessage ( ) ) ; } return p ; }
tr	REPL	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += ; 0 break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
tr	REPL	public void reset ( List < Player > players ) { myPlayers = players ; removeAll ( ) ; setLayout ( new BorderLayout ( ) ) ; JPanel meeplePanel = new JPanel ( ) ; meeplePanel . setLayout ( new GridLayout ( 1 , players . size ( ) ) ) ; JPanel playerPanel = new JPanel ( ) ; int numCols = ( int ) Math . ceil ( players . size ( ) / 3 ) ; playerPanel . setLayout ( new GridLayout ( 3 , numCols ) ) ; for ( Player player : players ) { JLabel meeple = new JLabel getPlayerInfo ( ( player ) , new ImageIcon ( Meeple . getBufferedImage ( Meeple . getColor ( player . getID ( ) ) ) ) , 0 ) ; meeplePanel . add ( meeple ) ; JLabel pLabel = new JLabel ( "Player " + player . getID ( ) + ": " + player . getScore ( ) + " " ) ; playerPanel . add ( pLabel ) ; } add ( meeplePanel , BorderLayout . CENTER ) ; add ( playerPanel , BorderLayout . WEST ) ; revalidate ( ) ; repaint ( ) ; }
tr	ORIG	public static String getRemnant ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( "" ) ; return ( abuf . substring ( sep + 1 ) ) ; }
tr	REPL	public static String getFCdesc ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if i ( < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FDESC ] ) ; else return ( "" ) ; }
tr	ORIG	@ Override public void render ( ) { if ( ! isEnable ( ) ) { return ; } draw ( ) ; }
tr	ORIG	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	@ Test public void testSanity ( ) throws Exception { File storeDir = new File ( "target/foo" ) ; storeDir . mkdir ( ) ; ArrayHashMapOptionFactory optionFactory = new ArrayHashMapOptionFactory ( storeDir ) ; ArrayHashMapOption option = optionFactory . wrap ( new ArrayHashMap ( 3 ) , "000" ) ; assertTrue ( option . inMemory ( ) ) ; String reallyLongString = "@@@@@@@@@@@@@@@@@FFFFFFFFFFFFf\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long fooValue = new long ( 1333243243243243211 ) ; option . getValue ( ) . put ( reallyLongString , fooValue ) ; assertTrue ( option . inMemory ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; assertTrue ( option . inMemory ( ) ) ; option . persist ( ) ; assertFalse ( option . inMemory ( ) ) ; assertNull ( option . getValue ( ) ) ; option . restore ( ) ; assertTrue ( option . inMemory ( ) ) ; assertNotNull ( option . getValue ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; }
tr	ORIG	public EDFMoneyCaption ( EDFScene edfScene ) { super ( getCaption ( edfScene . getMoney ( ) ) ) ; this . scene = edfScene ; setBasePont ( GameCharacterBasePoint . LEFTTOP ) ; setScale ( 0.4f ) ; setX ( 5 ) ; setY ( HEIGHT - 5 ) ; setColor ( Color . orange . brighter ( ) ) ; }
tr	ORIG	public void GetInRelation ( Integer id ) { inauthorMap = new HashMap < > ( ) ; authors = new ArrayList < > ( ) ; String query = "select name inauthors from inauthor where paperid=" + id ; ResultSet set = sqLconnection . Query ( query ) ; String author , inauthor ; try { while ( set . next ( ) ) { author = set . getString ( "name" ) ; inauthor = set . getString ( "inauthors" ) ; authors = Arrays . asList ( author . substring ( 1 , author . length ( ) - 1 ) . split ( "  " ) ) ; String [ ] tmp = inauthor . substring ( 1 , inauthor . length ( ) - 1 ) . split ( "  " ) ; if ( tmp . length % 2 == 0 ) { for ( int i = 0 ; i < tmp . length / 2 ; i ++ ) { inauthorMap . put ( tmp [ i * 2 ] , Integer . parseInt ( tmp [ i * 2 + 1 ] ) ) ; } } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	@ Override public void inputProcess ( ) { switch ( stageState ) { case READY : if ( Key . SPACE . isPressed ( ) ) { stageState = StageState . PLAYING ; } break ; case PLAYING : if ( currentStage . isClear ( ) ) { stageState = StageState . CLEAR ; } break ; case CLEAR : if ( Key . SPACE . isPressed ( ) ) { nextStage ( ) ; stageState = StageState . READY ; } break ; } }
tr	ORIG	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current == null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	ORIG	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	REPL	public final Var_declContext var_decl ( ) throws RecognitionException { Var_declContext _localctx = new Var_declContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 12 , RULE_var_decl ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 110 ) ; match ( TIPO ) ; { setState ( 111 ) ; match ( ID ) ; } setState ( 116 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( _la == , ) { { { setState ( 112 ) ; match ( , ) ; setState ( 113 ) ; match ( ID ) ; } } setState ( 118 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 119 ) ; match ( ; ) ; linea ++ ; arbol . add ( "Declara Variable " + ) linea ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	ORIG	public static void main ( String [ ] args ) { MessageConfig messageConfig = MessageConfig . parse ( XmlTest . class . getClassLoader ( ) . getResourceAsStream ( "demo.xml" ) ) ; System . out . println ( messageConfig . toString ( ) ) ; for ( Client client : messageConfig . getClient ( ) ) { System . out . println ( "----client----" ) ; System . out . println ( client . getUrl ( ) ) ; System . out . println ( client . getUser ( ) ) ; System . out . println ( client . getPwd ( ) ) ; } for ( Destination destination : messageConfig . getDestination ( ) ) { System . out . println ( "----destination---" ) ; System . out . println ( destination . getClient ( ) ) ; System . out . println ( destination . getName ( ) ) ; System . out . println ( destination . getType ( ) ) ; System . out . println ( "params thread:" + destination . getParams ( ) . getThreads ( ) ) ; System . out . println ( "params autostart:" + destination . getParams ( ) . getAutostart ( ) ) ; } }
tr	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING + calcDef ( r , c , false , ds ) ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT + calcDef ( r , c , false , ds ) ; } return 0 ; }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	REPL	@ Override boolean public isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { case FRIEND_TEAM : return target . getTeam ( ) == TEAM . ENEMY_TEAM ; case ENEMY_TEAM : return target . getTeam ( ) == TEAM . FRIEND_TEAM ; default : return false ; } }
tr	ORIG	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName != null ) { size = write ( out ) ; } return size ; }
tr	REPL	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel i ( , j , pixels ) ; } } } } }
tr	REPL	public void modifyDates ( long adiff ) { for ( idx int = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . acceldate . setTime ( myitem . acceldate . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
tr	ORIG	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	public void destroy ( ) { ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; dbconnman . shutdown ( ) ; scontext . removeAttribute ( "DbConnMan" ) ; CDbConnMan actconnman = ( CDbConnMan ) scontext . getAttribute ( "ActConnMan" ) ; actconnman . shutdown ( ) ; scontext . removeAttribute ( "ActConnMan" ) ; actconnman . drivercleanup ( ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectDoseTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public String buildShotStr ( int achild ) { String shotstr = "" ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; shotstr = shotstr + shot . buildShotStr ( achild , shotnum ) ; shotnum ++ ; } return ( shotstr ) ; }
tr	ORIG	public CParseXml ( ) { super ( ) ; curstr = "" ; testcaselist = new CTestList ( ) ; testcaseitem = new CTestItem ( ) ; shotitem = new CShotItem ( ) ; nonaditem = new CNonadItem ( ) ; expresitem = new CTextItem ( ) ; expdoseitem = new CDoseItem ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	REPL	public static void GA_JailThrowDice ( ) { if ( JailDiceTries < 3 ) { Player player = players . get ( currentPlayer ) ; dices [ 0 ] . throw ( ) ; dices [ 1 ] . throw ( ) ; if ( dices [ 0 ] . number == dices [ 1 ] . number ) { player . InPrison = false ; player . PrisonTurns = 0 ; player . ChangePosition ( ( dices 0 [ ] . number + dices [ 1 ] . number ) ) ; Game . fields . get ( player . Position ) . Lands ( player ) ; gameboard . showJailFreeCardBtn = false ; gameboard . showJailPayBailBtn = false ; gameboard . showJailThrowDiceBtn = false ; gameboard . showMortgageBtn = false ; gameboard . showNextPlayerBtn = true ; gameboard . showThrowDiceBtn = false ; gameboard . refreshGameControl ( ) ; } else { JailDiceTries ++ ; } } else { } }
tr	ORIG	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
tr	ORIG	@ Override public void handle ( final ActionEvent e ) { CustomerController customerCtrl = new CustomerController ( ) ; if ( dest != null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; Date current = new Date ( new GregorianCalendar ( ) . getTime ( ) . getTime ( ) ) ; result = customerCtrl . createCustomerWithParameters ( firstNameTf . getText ( ) , lastNameTf . getText ( ) , numberTf . getText ( ) , streetTf . getText ( ) , cityTf . getText ( ) , zipCodeTf . getText ( ) , current ) ; if ( result . equals ( "Creation succeed" ) ) { if ( file != null ) { gridPane . getChildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	REPL	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( . agingButton isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	REPL	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ; ) stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	public CShotItem ( ) { shotid = "" ; shotdate = new Date ( ) ; vaccinecd = CAppConsts . TagNoValue ; mfrcd = CAppConsts . TagNoValue ; mdyfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; vacnote = "" ; vageyears = 0 ; vagemonths = 0 ; vageweeks = 0 ; vagedays = 0 ; }
tr	REPL	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell true = ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	public static boolean writeStationsFile ( String pathName , ArrayList < String > sNames , ArrayList < String [ ] > sCoordinates , ArrayList < String > sStates ) { File file = new File ( pathName ) ; try { if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } BufferedWriter bufferedW = new BufferedWriter ( new FileWriter ( file ) ) ; String name ; String [ ] coordinates = new String [ 2 ] ; String state ; for ( int i = 0 ; i < sNames . size ( ) ; i ++ ) { name = sNames . get ( i ) ; coordinates = sCoordinates . get ( i ) ; state = sStates . get ( i ) ; bufferedW . append ( name + ";" + coordinates [ 0 ] + ";" + coordinates [ 1 ] + ";" + state ) ; bufferedW . newLine ( ) ; } bufferedW . close ( ) ; } catch ( IOException e ) { System . err . println ( "Error writing Stations file." ) ; e . printStackTrace ( ) ; return false ; } return true ; }
tr	REPL	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) != null ) { if ( line . startsWith ( aBoundary ) ) break ; sbuf . ( append line + "\r\n" ) ; } if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	REPL	private void ButtonSaveNewActionPerformed ( java . awt . event . ActionEvent evt ) { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField1 . setEditable ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible true ( ) ; ButtonSaveNew . setVisible ( false ) ; DbUtil . addUser ( jTextField1 . getText ( ) , jTextField2 . getText ( ) , jComboBox1 . getSelectedIndex ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ) ex ; } }
tr	ORIG	private void processRightMove ( ) { if ( ! RIGHT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( - DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) - ROTATE_SPEED ) ; }
tr	REPL	@ Override public GameCharacterObject setAngle ( float angle ) { super . setAngle ( angle ) ; double theta = Math . toRadians ( - angle ) ; setX ( CENTER_X + getElevation ( ) * ( float ) Math . sin ( theta ) ) ; setY ( CENTER_Y + getElevation ( ) * ( float ) Math . cos theta ( ) ) ; return this ; }
tr	REPL	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Contexto oContexto = ( Contexto ) request . getAttribute ( "contexto" ) ; oContexto . setVista ( "jsp/mensaje.jsp" ) ; String result ; UsuarioBean oUsuario1 = new UsuarioBean ( ) ; UsuarioParam oUsuarioParam = new UsuarioParam ( request ) ; try { oUsuario1 = oUsuarioParam . load ( oUsuario1 ) ; } catch ( NumberFormatException ) e { return "Tipo de dato incorrecto en uno de los campos del formulario" ; } UsuarioBean oUsuario2 = new UsuarioBean ( ) ; UsuarioDao oUsuarioDao = new UsuarioDao ( oContexto . getEnumTipoConexion ( ) ) ; oUsuario2 . setLogin ( oUsuario1 . getLogin ( ) ) ; oUsuario2 = oUsuarioDao . getFromLogin ( oUsuario2 ) ; oUsuarioDao . type ( oUsuario2 ) ; if ( oUsuario2 . getId ( ) != 0 && oUsuario2 . getPassword ( ) . equals ( oUsuario1 . getPassword ( ) ) ) { result = "Bienvenido/a " + oUsuario2 . getLogin ( ) + " Has entrado en la aplicaci\u00F3n. Ahora puedes operar con los men\u00FAs." ; request . getSession ( ) . setAttribute ( "usuarioBean" , oUsuario2 ) ; } else { result = "Login o password incorrectos. No has entrado en la aplicaci\u00F3n." ; } ContextParam oContextParam = new ContextParam ( request ) ; oContexto = oContextParam . loadSession ( oContexto ) ; return result ; }
tr	REPL	public static void drawTexture ( final Texture texture , final int width , final int height ) texture { . bind ( ) ; glBegin ( GL_QUADS ) ; texture . point ( texture . getWidth ( ) , 0 ) ; glVertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glVertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getHeight ( ) ) ; glVertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getWidth ( ) , texture . getHeight ( ) ) ; glVertex3f ( width / 2 , - height / 2 , 0 ) ; glEnd ( ) ; }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( DemoPattern . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	REPL	int alphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha max = ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	REPL	public String exportItem ( ) { StringBuilder retstr = StringBuilder new ( 128 ) ; retstr . append ( "<NonAdminItem>\n" ) ; retstr . append ( "<NonadmDate>" + dtfmt . format ( nonadmdate ) + "</NonadmDate>\n" ) ; retstr . append ( "<AntSeriesCd>" + seriescd + "</AntSeriesCd>\n" ) ; retstr . append ( "<ReasonCd>" + reasoncd + "</ReasonCd>\n" ) ; retstr . append ( "</NonAdminItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	@ Override public void update ( ) { inputProcess ( ) ; updateWind ( ) ; addFlowerIfNecessary ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { FlowerCharacter flower = ( FlowerCharacter ) ite . next ( ) ; flower update . ( wind ) ; if ( flower . canDispose ( ) ) { ite . remove ( ) ; } } }
tr	ORIG	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	@ Test public void readMoreLocationsWithSize ( ) { WorldMap top = WorldMapReader . readFromString ( "region 1" + "\n\tplace 1 - 5x4" + "\n\tplace 2 - 6x7" + "\nregion 2" + "\n\tplace 3 - 1x2" + "\n\tplace 4 - 4x3" ) ; assertEquals ( new HashSet < > ( Arrays . asList ( "region 1" , "region 2" ) ) , top . regions ( ) ) ; assertEquals ( new HashSet < > ( Arrays . asList ( new Location ( "region 1" , "place 1" ) , new Location ( "region 1" , "place 2" ) , new Location ( "region 2" , "place 3" ) , new Location ( "region 2" , "place 4" ) ) ) , top . locations ( ) ) ; assertEquals ( new LocalMap ( 5 , 4 ) , top . localMap ( new Location ( "region 1" , "place 1" ) ) ) ; assertEquals ( new LocalMap ( 6 , 7 ) , top . localMap ( new Location ( "region 1" , "place 2" ) ) ) ; assertEquals ( new LocalMap ( 1 , 2 ) , top . localMap ( new Location ( "region 2" , "place 3" ) ) ) ; assertEquals ( new LocalMap ( 4 , 3 ) , top . localMap ( new Location ( "region 2" , "place 4" ) ) ) ; }
tr	REPL	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G packedPixels ; [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	REPL	public String getYmdStr ( ) { SimpleDateFormat ymdfmt = new ( SimpleDateFormat CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( shotdate ) ) ; }
tr	REPL	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; char q ; for ( int r = 0 ; r < k ; r ++ ) { String path = input . next ( ) ; int count = 0 , y = 0 , x for ; ( int i = 0 ; i < path . length ( ) ; i ++ ) { q = path . charAt ( i ) ; x = 0 ; if ( q == . ) { while ( q != # ) { x ++ ; q = path . charAt ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } System . out . println ( count ) ; } }
tr	ORIG	public String getFC2RunDtStr ( ) { if ( fc2rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	REPL	@ Override protected void setTextPosition ( Graphics2D g2d ) { FontMetrics fm = g2d . getFontMetrics ( ) ; fm . stringWidth ( componentText ) ; Rectangle2D r = fm . getStringBounds ( componentText , g2d ) ; int shape = LCARS . getShape ( style ) ; switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_NW : textY = ( int ) ( scaledArea . getBounds ( ) . height - textInsetY * scaleFactor ) ; break ; case LCARS . ES_SHAPE_SE : case LCARS . ES_SHAPE_SW : textY = ( int ) ( scaledArea . getBounds ( ) . y + r . getHeight ( ) ) ; break ; default : break ; } switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_SE : textX = ( int ) ( scaledArea . getBounds ( ) . width - barV * scaleFactor + textInsetX * scaleFactor ) ; break ; case LCARS . ES_SHAPE_NW : case LCARS . ES_SHAPE_SW : = textX ( int ) ( barV * scaleFactor - r . getWidth ( ) - textInsetX * scaleFactor ) ; break ; default : break ; } }
tr	REPL	@ Override void protected doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	private void fillTable ( List < Game > schedule ) { TableModel model new = DefaultTableModel ( new String [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( Game game : schedule ) { model . setValueAt ( game . first . getName ( ) , row , 0 ) ; model . setValueAt ( game . second . getName ( ) , row , 1 ) ; model . setValueAt ( game . getResult ( ) , row , 2 ) ; row = row + 1 ; } gamesTable . setModel ( model ) ; if ( model . getRowCount ( ) > 0 ) { gamesTable . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } }
tr	REPL	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" "" , , "" , "" ) ; }
tr	ORIG	private void removeEdges ( String vertexName ) { Vertex v = vertexMap . get ( vertexName ) ; for ( int i = 0 ; i < v . adj . size ( ) ; i ++ ) { Vertex u = v . adj . get ( i ) . dest ; int index = 0 ; for ( Edge e : u . adjEntering ) { if ( e . src . name . equals ( v . name ) ) { break ; } index ++ ; } u . adjEntering . remove ( index ) ; } for ( int i = 0 ; i < v . adjEntering . size ( ) ; i ++ ) { Vertex u = v . adjEntering . get ( i ) . src ; int index = 0 ; for ( Edge e : u . adj ) { if ( e . dest . name . equals ( v . name ) ) { break ; } index ++ ; } u . adj . remove ( index ) ; } v . adj . clear ( ) ; v . adjEntering . clear ( ) ; }
tr	REPL	@ Override public int getY int ( y , int height ) { return y + ( height / 2 ) ; }
tr	REPL	protected void appendItem ( String astr , Object aobj ) { mystrings . add ( ) astr ; myobjects . add ( aobj ) ; }
tr	REPL	public void delete ( UStatusPk pk ) throws UStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUStatus ( ) ; ) int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public static void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; try { String url = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/life.txt" ; List < Pattern > list = PatternLoader . loadFromURL ( url ) ; gui . patternPanel . setPatterns ( list ) ; World w = gui . controlPanel . initialiseWorld ( list . get ( 1 ) ) ; gui . gamePanel . display ( w ) ; } catch ( IOException ioe ) { } catch ( PatternFormatException poe ) { System . out . println ( poe . getMessage ) ( ) ; } gui . setVisible ( true ) ; }
tr	REPL	@ Test public void testLimitBuy2 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . LimitBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) MarketData ; bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.15 , 1.05 , 1.20 , 1.00 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.16 , 1.06 , 1.21 , 1.01 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.16 , 0.0001 ) ; }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectResultItem>\n" ) ; retstr . append ( "<ExpectTxt>" + expecttxt + "</ExpectTxt>\n" ) ; retstr . append ( "<ResultTxt>" + expecttxt + "</ResultTxt>\n" ) ; retstr . append ( "</ExpectResultItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) manapp { . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	private JPanel createButtons ( ) { final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _submitButton = new JButton ( "Submit" ) ; springLayout . putConstraint ( SpringLayout . WEST , _submitButton , SPACING , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , _submitButton , 0 , SpringLayout . NORTH , jPanel ) ; _submitButton . addActionListener ( this ) ; _submitButton . setEnabled ( true ) ; jPanel . add ( _submitButton ) ; _nextButton = new JButton ( "Next" ) ; springLayout . putConstraint ( SpringLayout . WEST , _nextButton , SPACING , SpringLayout . EAST , _submitButton ) ; springLayout . putConstraint ( SpringLayout . NORTH , _nextButton , 0 , SpringLayout . NORTH , jPanel ) ; _nextButton . addActionListener ( this ) ; _nextButton . setEnabled ( false ) ; jPanel . add ( _nextButton ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , SPACING , SpringLayout . EAST , _nextButton ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , SPACING , SpringLayout . SOUTH , _nextButton ) ; return jPanel ; }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p - characterSize / 2 < 0 ) { p = characterSize / 2 ; } if ( displayBorder < p + characterSize / 2 ) { p = displayBorder - characterSize / 2 ; } return p ; }
tr	ORIG	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public void UpdateInfoAdmin ( String [ ] data ) { if ( CheckExistName ( data [ 3 ] + " " + data [ 2 ] , Integer . valueOf ( data [ 0 ] ) , false ) ) { JOptionPane . showMessageDialog ( null , "You are already register.." ) ; } else { try { StartConnection ( ) ; stmt = conn . createStatement ( ) ; String query = "UPDATE Employee" + " SET " + "    Admin='" + data [ 1 ] + "'   First_Name='" + data [ 2 ] + "'   Last_Name='" + data [ 3 ] + "'   Birthdate='" + data [ 4 ] + "'   Gender='" + data [ 5 ] + "'   Position='" + data [ 6 ] + "'   Contact='" + data [ 7 ] + "'   Address='" + data [ 8 ] + "' WHERE Id=" + data [ 0 ] ; PreparedStatement preparedStmt = conn . prepareStatement ( query ) ; System . out . println ( "Update info  ok!" ) ; JOptionPane . showMessageDialog ( null , "success update info!" ) ; preparedStmt . execute ( ) ; StopConnection ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "UpdateInfoAdmin().\n>: " + e ) ; StopConnection ( ) ; } } }
tr	REPL	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] ] [ nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public static String getToken ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( abuf ) ; return ( abuf . substring ( 0 , sep ) ) ; }
tr	ORIG	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	REPL	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectDoseItem>\n" ) ; retstr . append "<SeriesCd>" ( + seriescd + "</SeriesCd>\n" ) ; retstr . append ( "<ResultCd>" + resultcd + "</ResultCd>\n" ) ; retstr . append ( "<NextDoseNum>" + Integer . toString ( doseord ) + "</NextDoseNum>\n" ) ; retstr . append ( "<AccelDate>" + dtfmt . format ( acceldate ) + "</AccelDate>\n" ) ; retstr . append ( "<RecomDate>" + dtfmt . format ( recomdate ) + "</RecomDate>\n" ) ; retstr . append ( "<OverdueDate>" + dtfmt . format ( overduedate ) + "</OverdueDate>\n" ) ; retstr . append ( "</ExpectDoseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	void public dbDeleteItem ( Connection aconn ) { try { String qstr = "Delete From TestCaseTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteItem cannot delete item. " , ex ) ; } }
tr	REPL	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get 0 ( ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public void evolutionWithoutPredict ( ) throws InterruptedException , IOException , ExecutionException , NRException { Chromosome ch_max ; List < Chromosome > population ; population = createRandomPopulation ( startSize ) ; population = parallelComputeFitness ( population , train , dev ) ; population = sortPopulation ( population ) ; printPopulation ( population ) ; ch_max = population . get ( 0 ) ; System . err . println ( "------------------------ \n" ) ; System . err . println ( "Ch max: " + ch_max . getFitness ( ) ) ; for ( int i = 1 ; i < numberGeneration ; i ++ ) { System . err . println ( "Generation " + ( i + 1 ) ) ; population = createNewPopulation2 ( population ) ; population = parallelComputeFitness ( population , train , dev ) population ; = sortPopulation ( population ) ; ch_max = population . get ( 0 ) ; System . out . println ( "------------------------ \n" ) ; printPopulation ( population ) ; System . out . println ( "------------------------ \n" ) ; System . out . println ( "Ch max:" + ch_max . getFitness ( ) ) ; System . out . println ( util . Convert . convertToString ( ch_max ) ) ; } }
tr	REPL	public static String getFCurl ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i [ ] FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FURL ] ) ; else return ( "" ) ; }
tr	REPL	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result return ; result ; } }
tr	ORIG	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	ORIG	public void execute ( ) { Logger . info ( "AI: Taking my turn...\n" ) ; final LinkedList < OthelloCell > cells = getOccupiedCells ( ) ; Logger . info ( "AI cells = %s\n" , cells ) ; final LinkedList < OthelloCellCapturePath > paths = getCapturePaths ( cells ) ; Logger . info ( "AI paths = %s\n" , paths ) ; if ( ! paths . isEmpty ( ) ) { Collections . sort ( paths , PATH_COMPARATOR ) ; boolean done = false ; while ( ! done && ! paths . isEmpty ( ) ) { final OthelloCellCapturePath path = paths . removeLast ( ) ; Logger . info ( "AI path = %s\n" , path ) ; Logger . info ( "AI placement of %s at {%d %d} \n" , pieceAI , path . getColumnEnd ( ) , path . getRowEnd ( ) ) ; Collection < OthelloCellCapturePath > actions = board . placePiece ( path . getColumnEnd ( ) , path . getRowEnd ( ) , pieceAI ) ; done = ! actions . isEmpty ( ) ; if ( ! done ) { actions = board . placePiece ( path . getColumnStart ( ) , path . getRowStart ( ) , pieceAI ) ; done = ! actions . isEmpty ( ) ; } } } }
tr	REPL	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( <= ) 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	ORIG	public void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( speed , nabiki ) ; } }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	@ Override public float move ( int displayBorder , int characterSize , float p , final float ) vp { p += vp ; if ( p < 0 ) { p = - p ; } if ( displayBorder < p ) { p = displayBorder - p + displayBorder ; } return p ; }
tr	ORIG	@ Override public synchronized boolean put ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for put() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . put ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	REPL	private String static left ( Date date , int length ) { if ( date == null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , length ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	ORIG	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	REPL	public static String prepadStr ( String astr , String apad , int alen ) { String rstr = astr ; while rstr ( . length ( ) < alen ) rstr = apad + rstr ; return ( rstr ) ; }
tr	ORIG	@ Override public boolean putIfAbsent ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( false ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
tr	ORIG	public String makeNewId ( String aprefix , int alen ) { return ( makeNewId ( "" , aprefix , alen ) ) ; }
tr	REPL	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection size pool " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	REPL	public static void setComments ( String articleId , ArrayList < CommentEntityDS > commments ) { Connection conn ; try { conn = DatabaseManager . getInstance ( ) . getConnection ( ) ; StringBuffer insertQuerry = new StringBuffer ( ) ; for ( CommentEntityDS comm : commments ) { insertQuerry . append ( "(" ) . append ( comm . getId ( ) ) . append ( " '" ) . append ( articleId ) . append ( "' '" ) . append ( StringEscapeUtils . escapeHtml4 ( comm . getCommentHTML ( ) ) . replace ( ' ,   ) ) . append ( "' \"" ) . ( append CommentEntityDS . vectorToString ( comm . getVector ( ) ) ) . append ( "\")   " ) ; } insertQuerry . replace ( 0 , insertQuerry . length ( ) - 1 , insertQuerry . substring ( 0 , insertQuerry . length ( ) - 2 ) ) ; String querry = insertQuerry . toString ( ) ; PreparedStatement sqlQuerry = conn . prepareStatement ( "INSERT IGNORE INTO comments (comment_id article_id html vector) VALUES " + querry + ";" ) ; sqlQuerry . execute ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	REPL	private void configureSpawnRequest ( GameObjectSpawnRequest spawnRequest ) { int uid = 0 ; int id = - 1 ; int type = 0 ; int face = 0 ; if ( spawnRequest . objectType == 0 ) uid = worldController . getWallObjectHash ( spawnRequest . x , spawnRequest . y , spawnRequest . z ) ; if ( spawnRequest . objectType == 1 ) uid = worldController . getWallDecorationHash ( spawnRequest . x , spawnRequest . y , spawnRequest . z ) ; if ( spawnRequest . objectType == 2 ) uid = worldController . getInteractibleObjectHash ( spawnRequest . x , spawnRequest . y , spawnRequest . z ) ; if ( spawnRequest . objectType == 3 ) uid = worldController . getGroundDecorationHash ( spawnRequest . x , spawnRequest . y , spawnRequest . z ) ; if ( uid != 0 ) { int config = worldController . getConfig ( uid , spawnRequest . x , spawnRequest . y , spawnRequest . z ) ; id = uid >> 14 & 7fff ; type = config & 1f ; face = config >> 6 ; } spawnRequest . id = id ; spawnRequest . type = type ; spawnRequest . face face = ; }
tr	REPL	public static int getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( name . equals ( "int" ) || name . equals ( "java.lang.Integer" ) ) return INTEGER ; if ( name . equals ( "double" ) || name . equals ( "java.lang.Double" ) ) return double ; if ( name . equals ( "long" ) || name . equals ( "java.lang.Long" ) ) return long ; if ( name . equals ( "float" ) || name . equals ( "java.lang.Float" ) ) return float ; if ( name . equals "java.util.Date" ( ) ) return DATE ; if ( name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return boolean ; return - 1 ; }
tr	REPL	public static void main ( String [ ] args ) { List < Integer > list0 = Arrays . asList ( 0 ) ; List < Integer > = list1 Arrays . asList ( 1 , 2 , 3 ) ; List < Integer > list2 = Arrays . asList ( 4 , 5 ) ; List < Integer > list3 = Arrays . asList ( 6 , 7 , 8 , 9 ) ; List < Integer > list4 = Arrays . asList ( 10 ) ; LinkedList < Iterator < Integer >> list = new LinkedList < > ( ) ; list . add ( list0 . iterator ( ) ) ; list . add ( list1 . iterator ( ) ) ; list . add ( list2 . iterator ( ) ) ; list . add ( list3 . iterator ( ) ) ; list . add ( list4 . iterator ( ) ) ; AlternatingIterator iter = new AlternatingIterator ( list ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) + " " ) ; } System . out . println ( ) ; }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell false = ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	private void manageStringMessage ( int senderID , StringMessage msg ) throws NetworkMessageException { msg . setSender ( senderID ) ; if ( msg . getAcceptor ( ) == 0 ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == msg . getSender ( ) ) { continue ; } clients . get ( i ) . sendMessage ( msg ) ; } console . displayMessage ( getClientNameByID ( msg . getSender ( ) ) + ": " + msg . getStr ( ) ) ; } else { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == msg . ( getAcceptor ) ) { clients . get ( i ) . sendMessage ( msg ) ; break ; } } console . displayMessage ( getClientNameByID ( msg . getSender ( ) ) + " to " + getClientNameByID ( msg . getAcceptor ( ) ) + ": " + msg . getStr ( ) ) ; } }
tr	REPL	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr length . ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	REPL	private int insert ( ) { String strfecha = fecha == null ? "'" + new DataCtrl ( ) . getDataSQL ( ) + "' " : "'" + new DataCtrl ( fecha ) . getDataSQL ( ) + "' " ; String SQL1 = "INSERT INTO clasesanotadas (idProfesores idProfesoresReal " + " fecha idHorasCentro idGrupAsig) VALUES('" + this . + idProfesores "' " + "'" + this . idProfesoresReal + "' " + strfecha + " '" + this . idHorasCentro + "' " + " '" + this . idGrupAsig + "')" ; int nup = getSgd ( ) . executeUpdateID ( SQL1 ) ; if ( nup > 0 ) { this . id = nup ; { Log log = getLogger ( ) ; log . setTabla ( "ClasesAnotadas" ) ; log . setDatos ( "id=" + this . id + ";id=" + this . id ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . INSERT ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } } return nup ; }
tr	ORIG	public String getContentType ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getContentType ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	ORIG	public File getFile ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFile ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public String getYmdStr ( Date adate ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( adate ) ) ; }
tr	ORIG	public String getYmdStr ( Date adate ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( adate ) ) ; }
tr	ORIG	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
tr	ORIG	@ Transactional ( propagation = Propagation . REQUIRES_NEW , readOnly = false ) public void batchInsert ( final List < SiteStatModel > siteStatModelList ) { String sql = "INSERT IGNORE INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return siteStatModelList . size ( ) ; } } ) ; }
tr	ORIG	public String buildShotStr ( int achild , int ashot ) { String shotstr = "line~" + Integer . toString ( ashot ) + "^" + "shot_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "shot_dt~" + getYmdStr ( ) + "^" + "vaccine_cd~" + vaccinecd + "^" + "mfr_cd~" + mfrcd + "^" ; return ( shotstr ) ; }
tr	REPL	public String getParameter ( String aName ) { try { String param = ( String ) fParameters . get ( aName ) ; if ( param . equals ( "" ) ) return null ; return param ; } catch ( Exception e ) { return null ; } }
tr	REPL	public static void main ( String [ ] args ) { int [ ] [ ] i = new int [ 2 ] [ 2 ] ; int [ ] [ ] j = { i [ 1 ] , { 1 , 2 , 3 } { , 4 , 5 , 6 , 7 } } ; int [ ] [ ] [ ] k = { i , j } ; System . out . println ( k [ 0 ] [ 1 ] [ 0 ] ++ ) ; System . out . println ( ++ k [ 1 ] [ 0 ] [ 0 ] ) ; System . out . println ( i [ 1 ] [ 0 ] ) ; System . out . println ( -- j [ 0 ] [ 0 ] ) ; }
tr	REPL	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state getMoves . ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + myitem . expecttxt + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . resulttxt + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	public HashMap < Integer , BeanTipoObservaciones > getMapObservaciones ( ) { if ( mapObservaciones != null { ) return mapObservaciones ; } mapObservaciones = new HashMap < Integer , BeanTipoObservaciones > ( ) ; String SQL1 = "SELECT * FROM tipoobservaciones" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { BeanTipoObservaciones bean = new BeanTipoObservaciones ( ) ; int id = rs1 . getInt ( "id" ) ; bean . setId ( id ) ; bean . setDescripcion ( rs1 . getString ( "descripcion" ) ) ; bean . setNombre ( rs1 . getString ( "nombre" ) ) ; bean . setTipo ( rs1 . getString ( "tipo" ) ) ; mapObservaciones . put ( id , bean ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( TipoObservaciones . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return mapObservaciones ; }
tr	REPL	public String getFC1RunDtStr ( ) { if ( == fc1rundt null ) { return ( "" ) ; } return ( dtfmt . format ( fc1rundt ) ) ; }
tr	ORIG	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	REPL	private void list1MouseClicked ( java . awt . event . MouseEvent evt ) { selected = list1 . getSelectedIndex ( ) ; textField1 . setText ( itemsLoad [ selected ] [ 0 ] ) ; textField2 . setText ( itemsLoad [ selected ] [ 1 ] ) ; jComboBox1 . setSelectedIndex ( Integer . parseInt ( categories [ Integer . parseInt ( itemsLoad [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) - 1 ) ; System . out . println ( categories [ Integer . parseInt ( itemsLoad [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) ; textField3 . setText ( itemsLoad [ selected ] [ 3 ] ) ; . jComboBox2 setSelectedIndex ( Integer . parseInt ( itemsLoad [ selected ] [ 4 ] ) ) ; textField4 . setText ( itemsLoad [ selected ] [ 5 ] ) ; }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; if ( go instanceof StarCharacter ) { ( ( StarCharacter ) go ) . update ( getTimeScale ( ) ) ; } else { go . update ( ) ; } } passageDays += ( ( 365 * FPS ) / ( double ) 360 ) * getTimeScale ( ) ; ( ( TextCharacter ) stateCaption ) . updateText ( getStateString ( ) ) ; }
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	REPL	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { . astream defaultReadObject ( ) ; theConnection = null ; }
tr	ORIG	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp = b ; b = c ; c = temp ; } else { double [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { double [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp ; temp = b ; b = a ; a = temp ; } else { double [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	ORIG	public void delete ( FriendshStatusPk pk ) throws FriendshStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getFriendshStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	ORIG	@ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } }
tr	ORIG	@ Override public String format ( LogRecord record ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( dateFormat . format ( record . getMillis ( ) ) ) . append ( " [" ) . append ( record . getLevel ( ) ) . append ( "] " ) ; String msg = record . getMessage ( ) ; if ( msg != null ) { Object [ ] parameters = record . getParameters ( ) ; if ( parameters != null ) { msg = String . format ( msg , parameters ) ; } sb . append ( msg ) ; } Throwable thrown = record . getThrown ( ) ; if ( thrown != null ) { PrintWriter pw = null ; try { StringWriter sw = new StringWriter ( ) ; pw = new PrintWriter ( sw ) ; thrown . printStackTrace ( pw ) ; sb . append ( LINE_SEPARATOR ) . append ( sw . toString ( ) ) ; } finally { if ( pw != null ) { pw . close ( ) ; } } } return sb . append ( LINE_SEPARATOR ) . toString ( ) ; }
tr	ORIG	public String getModDateStr ( ) { if ( moddate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
tr	ORIG	public static String unescapeHtmlAndCapitalizeAndReplaceDash ( String inputText ) { if ( StringUtils . isEmpty ( inputText ) ) { return inputText ; } String cleanText ; cleanText = StringEscapeUtils . unescapeHtml ( inputText ) ; cleanText = cleanText . replaceAll ( "-" , " " ) ; cleanText = cleanText . replaceFirst ( "^\\s" , "" ) ; if ( Character . isLetter ( cleanText . charAt ( 0 ) ) ) { cleanText = StringUtils . capitalize ( cleanText ) ; } else { char [ ] stringArray = cleanText . toCharArray ( ) ; for ( int i = 0 ; i < cleanText . length ( ) ; i ++ ) { if ( Character . isLetter ( cleanText . charAt ( i ) ) ) { stringArray [ i ] = Character . toUpperCase ( stringArray [ i ] ) ; cleanText = new String ( stringArray ) ; break ; } } } return cleanText ; }
tr	ORIG	public void initialize ( ) { m1 = new Material ( ) ; m2 = new Material ( ) ; m1 . setSpecularPower ( 10 ) ; m2 . setSpecularPower ( 10 ) ; m1 . setAmbient ( new double [ ] { 0.6 , 0.2 , 0.3 } ) ; m1 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setSpecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m2 . setAmbient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setSpecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; for ( int i = 0 ; i < lights . length ; i ++ ) { normalize ( lights [ i ] [ 0 ] ) ; normalize ( lights [ i ] [ 1 ] ) ; } }
tr	ORIG	public void startAll ( ) { for ( int i = 0 ; i < games . size ( ) ; i ++ ) { System . out . println ( "Starting game #" + i + "." ) ; int sleep ; Game g = games . get ( i ) ; switch ( g . getSpeed ( ) ) { case Game . GAME_SPEED_SLOW : sleep = GAME_SPEED_SLOW_SLEEP ; break ; case Game . GAME_SPEED_MEDIUM : sleep = GAME_SPEED_MEDIUM_SLEEP ; break ; case Game . GAME_SPEED_FAST : sleep = GAME_SPEED_FAST_SLEEP ; break ; default : sleep = GAME_SPEED_MEDIUM_SLEEP ; break ; } GameRunnerImpl gameRunner = new GameRunnerImpl ( i , g , sleep ) ; Thread t = new Thread ( gameRunner , "Game #" + i ) ; threads . add ( t ) ; t . start ( ) ; } for ( Iterator < Thread > i = threads . iterator ( ) ; i . hasNext ( ) ; ) { Thread t = i . next ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } System . out . println ( "All games ended. Exiting." ) ; }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
tr	REPL	public int [ ] [ ] getHistogramFromBin ( int index ) { int [ ] [ ] res = null ; if ( dist . containsKey ( index ) ) { Map < Integer , Integer > m = dist . get ( index ) ; if ( m . isEmpty ( ) ) { return new int [ 0 ] [ 2 ] ; } List < Integer > s = General . asSortedList ( m . keySet ( ) ) ; int last = s . get ( s . size ( ) - 1 ) ; int first = s . get ( 0 ) ; res = new int [ ( last - first ) + 1 ] [ 2 ] ; int i = 0 ; for ( int c = first ; c <= last ; c ++ ) { res [ i ] [ 0 ] = c ; res [ i ] [ 1 ] = m . containsKey ( c ) ? m . get ( c ) : 0 ; i ++ ; } } else { System . out . println ( not "index found!" ) ; } return res ; }
tr	ORIG	public HBox searchBar ( ) { HBox hbox = new HBox ( ) ; hbox . setSpacing ( 5 ) ; hbox . getStyleClass ( ) . add ( "hbox-search-bar" ) ; hbox . getChildren ( ) . add ( new Label ( "FirstName" ) ) ; txtFieldFirstname . setPromptText ( "First Name" ) ; hbox . getChildren ( ) . add ( txtFieldFirstname ) ; hbox . getChildren ( ) . add ( new Label ( "LastName" ) ) ; txtFieldLastname . setPromptText ( "Last Name" ) ; hbox . getChildren ( ) . add ( txtFieldLastname ) ; hbox . getChildren ( ) . add ( new Label ( "ZipCode" ) ) ; txtFieldZipCode . setPromptText ( "Zip Code" ) ; hbox . getChildren ( ) . add ( txtFieldZipCode ) ; hbox . setStyle ( "-fx-padding: 10px;" ) ; Button searchButton = new Button ( "Search" ) ; hbox . getChildren ( ) . add ( searchButton ) ; searchButton . setOnAction ( new searchHandler ( ) ) ; return hbox ; }
tr	ORIG	private void initComponents ( ) { add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_TO . toString ( ) ) ) ) ; add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_FROM . toString ( ) ) ) , "wrap" ) ; fromListModel = new DefaultListModel ( ) ; fromFileList = new JList ( fromListModel ) ; fromFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane fromScrollPane = new JScrollPane ( fromFileList ) ; add ( fromScrollPane ) ; toListModel = new DefaultListModel ( ) ; toFileList = new JList ( toListModel ) ; toFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane toScrollPane = new JScrollPane ( toFileList ) ; add ( toScrollPane ) ; toFiles = new ArrayList < File > ( ) ; result = frm . preview ( replacer , fromFiles ) ; for ( Entry < File , File > entry : result . entrySet ( ) ) { fromListModel . addElement ( entry . getKey ( ) ) ; toListModel . addElement ( entry . getValue ( ) ) ; toFiles . add ( entry . getValue ( ) ) ; } }
tr	ORIG	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	ORIG	@ Test public void sanityCheck ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "1" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
tr	ORIG	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( DemoReflection . class . getPackage ( ) . getName ( ) ) ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new ( Dumper prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jLabel1 = new javax . swing . JLabel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; setResizable ( false ) ; jLabel1 . addContainerListener ( new java . awt . event . ContainerAdapter ( ) { public void componentAdded ( java . awt . event . ContainerEvent evt ) { jLabel1ComponentAdded ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , javax . swing . GroupLayout . PREFERRED_SIZE , 800 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 600 , short . MAX_VALUE ) ) ; pack ( ) ; }
tr	ORIG	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon != null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
tr	REPL	@ Test public void testEquals ( ) { Card a = new Card ( 8 , d ) ; Card b = new Card ( 9 s , ) ; Card c = new Card ( T , h ) ; Card d = new Card ( 7 , d ) ; Card e = new Card ( 2 , c ) ; Combination instance = new Combination ( a , b , c , d , e ) ; Combination anotherInstance = new Combination ( b , e , c , a , d ) ; boolean expResult = true ; boolean result = instance . equals ( anotherInstance ) ; assertEquals ( expResult , result ) ; instance . setCards ( a , b , new Card ( Q , d ) , d , e ) ; expResult = false ; result = instance . equals ( anotherInstance ) ; assertEquals ( expResult , result ) ; expResult = false ; result = instance . equals ( null ) ; assertEquals ( expResult , result ) ; expResult = true ; result = instance . equals ( instance ) ; assertEquals ( expResult , result ) ; }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i length < ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	ORIG	public MultipartStreamHandler ( ServletInputStream aStream , String aBoundary , int aExpected ) { this . fInStream = aStream ; this . fBoundary = aBoundary ; this . fNumExpected = aExpected ; }
tr	REPL	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if ( ( request . getParameter ( "contenido" ) != null ) ) { oEntrada . setContenido ( request . getParameter ( "contenido" ) ) ; } if ( ( request . getParameter ( "id_hilo" ) != null ) ) { oEntrada . getHilo ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_hilo" ) ) ) ; } if ( ( request . getParameter ( "id_usuario" ) != null ) ) { oEntrada . getUsuario ( ) . setId ( . Integer parseInt ( request . getParameter ( "id_usuario" ) ) ) ; } if ( ( request . getParameter ( "fecha" ) != null ) ) { oEntrada . setFecha ( new SimpleDateFormat ( "dd-MM-yyyy" ) . parse ( request . getParameter ( "fecha" ) ) ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Book > getBooksByParameters ( String name , String author , int year , String bookType , String series , boolean availibility ) { Transaction readTransaction = session . beginTransaction ( ) ; if ( year == 0 ) { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } else { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and year = :year and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setInteger ( "year" , year ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } }
tr	ORIG	@ Override public void run ( ) { FPSManager fpsManager = FPSManager . getInstance ( ) ; while ( ! Display . isCloseRequested ( ) ) { initBuffer ( ) ; Key . update ( ) ; sceneManager . update ( ) ; sceneManager . render ( ) ; fpsManager . update ( ) ; } }
tr	ORIG	private Expression3 < T > lexem ( ) { Expression3 < T > result ; Lexem . LexemType lexemType = lexems . get ( idx ) . type ; String s ; switch ( lexemType ) { case const : result = new const < > ( ( ( NumLex < T > ) lexems . get ( idx ) ) . getValue ( ) ) ; idx ++ ; break ; case STRING : s = ( ( StringLex ) lexems . get ( idx ) ) . getName ( ) ; idx ++ ; result = new FunctionExpr < > ( s , lexem ( ) , functions ) ; break ; case VARIABLE : s = ( ( VarLex ) lexems . get ( idx ) ) . getName ( ) ; result = new Variable < > ( s ) ; idx ++ ; break ; case MINUS : idx ++ ; result = new Negative < > ( lexem ( ) ) ; break ; case OPEN_BRACKET : idx ++ ; result = evalLexem ( 1 ) ; idx ++ ; break ; default : throw new RuntimeException ( ) ; } return result ; }
tr	ORIG	public QueryProcess ( ) throws FileNotFoundException { Query query = readQuery ( ) ; queryVar = query . getQueryVar ( ) ; conditions = query . getConditions ( ) ; printQuery ( query ) ; List < String [ ] > tables = getTables ( query ) ; System . out . println ( "-----" ) ; System . out . println ( "Printing tables in QueryProcess..." ) ; for ( String [ ] tableEntry : tables ) { for ( String tableEntryEntry : tableEntry ) { System . out . println ( tableEntryEntry ) ; } } if ( checkConditions ( tables . get ( 0 ) ) ) { System . out . println ( "true" ) ; } else { System . out . println ( "false" ) ; } }
tr	ORIG	@ Override public Object call ( Object [ ] params , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { String encodedCall = encoder . encode ( params ) ; String url = "http://" + serviceAddress . hostName + ":" + serviceAddress . port + "/" + serviceAddress . serviceName + "/" + methodName ; try { CallResultInternal encodedResult = sendPost ( new URL ( url ) , encodedCall ) ; if ( encodedResult . errorCode == CallResultInternal . NO_ERROR ) { if ( encodedResult . encodedResult . isEmpty ( ) ) { return null ; } return encoder . decode ( encodedResult . encodedResult , returnType ) ; } else { ExceptionWrapper result = encoder . decode ( encodedResult . encodedResult , ExceptionWrapper . class ) ; throw makeException ( encodedResult . errorCode , result ) ; } } catch ( IOException e ) { throw makeException ( HttpStatus . BAD_REQUEST_400 , new ExceptionWrapper ( "Malformed URL: " + url , "" ) ) ; } }
tr	ORIG	public CNonadItem ( ) { nonadmid = "" ; nonadmdate = new Date ( ) ; seriescd = CAppConsts . TagNoValue ; reasoncd = CAppConsts . TagNoValue ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; nageyears = 0 ; nagemonths = 0 ; nageweeks = 0 ; nagedays = 0 ; }
tr	REPL	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove == null ) { Collections . shuffle ( moves ) ; return moves . get ( ) 0 ; } return bestMove ; }
tr	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power , float hp ) { super ( parentScene , power , hp ) ; this . shooter = shooter ; this . remainRange = getBulletRange ( ) ; setTeam ( shooter . getTeam ( ) ) ; setX ( shooter . getX ( ) ) ; setY ( shooter . getY ( ) ) ; setWidth ( getBulletSize ( ) ) ; setHeight ( getBulletSize ( ) ) ; setTexture ( getBulletTexture ( ) ) ; }
tr	REPL	void public initialize ( ) { world = new Geometry ( H , W ) ; ballBearing = new Geometry ( H , W ) ; | = new Geometry ( H , W ) ; wheel = new Geometry ( H , W ) ; ballBearing . MakeCylinder ( 50 , 50 ) ; ballBearing . selfColor = new int [ ] { 50 , 50 , 500 } ; | . MakeCube ( ) ; | . selfColor = new int [ ] { 100 , 50 , 25 } ; allShapes . add ( ballBearing ) ; allShapes . add ( | ) ; world . add ( ballBearing ) ; ballBearing . add ( | ) ; for ( Geometry shapes : allShapes ) { shapes . makeTriangles ( ) ; shapes . trapazoids = new ArrayList < int [ ] [ ] > ( ) ; for ( int i = 0 ; i < shapes . triangles . size ( ) * 2 ; i ++ ) { shapes . trapazoids . add ( new int [ 4 ] [ 2 ] ) ; } } }
tr	ORIG	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	protected void dbSetCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . char ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	REPL	public BasicWeapon ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , owner , equipLR ) ; setTexture ( WEAPON_TEXTURE ) ; setHeight ( 20 ) ; setWidth ( 10 ) ; setColor ( Color . ) white ; setTeam ( owner . getTeam ( ) ) ; }
tr	ORIG	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
tr	REPL	public String buildTiterStr ( Connection aconn , int achild , int ashot ) { CMapCode antigenmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "AntigenId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + + "child_titer_id~" Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "antigen_id~" + antigenmap . mapCode ( seriescd ) + "^" + "titer_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	ORIG	public String getDescByCode ( String acode ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
tr	ORIG	@ Test public void testStopBuy1 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . StopBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.15 , 1.05 , 1.30 , 1.00 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.16 , 1.06 , 1.31 , 1.01 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.20 , 0.0001 ) ; }
tr	ORIG	public String unmapCode ( String aval ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CMapItem myitem = ( CMapItem ) this . getItem ( idx ) ; if ( myitem . mapval . equals ( aval ) ) return ( myitem . codeval ) ; } return ( CAppConsts . TagNoValue ) ; }
tr	REPL	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result != - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result == fBuff . length ; ) if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	ORIG	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; ErrMsgEcho = props . getProperty ( "ErrMsgEcho" ) . equals ( "true" ) ; ConfDir = AppDir + props . getProperty ( "ConfDir" ) ; LogDir = AppDir + props . getProperty ( "LogDir" ) ; ImportDir = AppDir + props . getProperty ( "ImportDir" ) ; ErrorLogFile = LogDir + props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	ORIG	public long persist ( ) throws IOException { if ( wrapped == null ) { return - 1 ; } long bytesWritten = 0 ; RandomAccessFile writer = new RandomAccessFile ( store , "rw" ) ; writer . setLength ( 0 ) ; writer . writeInt ( wrapped . getKeys ( ) . length ) ; bytesWritten += 4 ; writer . writeInt ( wrapped . size ( ) ) ; bytesWritten += 4 ; String currentKey ; for ( int i = 0 ; i < wrapped . getKeys ( ) . length ; i ++ ) { currentKey = wrapped . getKeys ( ) [ i ] ; if ( currentKey == null || ArrayHashMap . Tombstone . equals ( currentKey ) ) continue ; writer . writeInt ( currentKey . length ( ) ) ; bytesWritten += 4 ; writer . writeChars ( currentKey ) ; bytesWritten += currentKey . length ( ) * 2 ; writer . writeLong ( wrapped . getValues ( ) [ i ] ) ; bytesWritten += 8 ; } wrapped = null ; writer . close ( ) ; return bytesWritten ; }
tr	REPL	private void setPlugins ( String pluginName , List < P > players , final List < P > enabledPlayers ) { groupCheckBox . setText ( pluginName ) ; groupCheckBox . setSelected ( true ) ; for ( final P p : players ) { final JCheckBox checkBox = new JCheckBox ( p . getName ( ) ) ; checkBox . setSelected ( true ) ; . checkBox addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( checkBox . isSelected ( ) ) { enabledPlayers . add ( p ) ; } else { enabledPlayers . remove ( p ) ; } } } ) ; playerPanel . add ( checkBox ) ; enabledPlayers . add ( p ) ; } }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	REPL	@ Test public void testLimitBuy1 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . LimitBuy ( product , "2015-09-07 00:00:00" , 1.10 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.20 , 1.00 , 1.20 , 1.00 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.25 , 1.05 , 1.25 , 1.05 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals p ( . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.10 , 0.0001 ) ; }
tr	REPL	private void ButtonSaveEditActionPerformed ( java . awt . event . ActionEvent evt ) { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; ButtonSaveEdit . setVisible ( false ) ; try { DbUtil . userUpdate ( jTextField1 . getText ( ) , jTextField2 . getText ( ) , jComboBox1 . getSelectedIndex ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; try { onCreate ( ) ; } catch ( SQLException ex { ) Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	public void projectPoint ( double [ ] xyz , double [ ] pxy ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; double nx = xyz [ 3 ] ; double ny = xyz [ 4 ] ; double nz = xyz [ 5 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; pxy [ 2 ] = ( nx + 1 ) * 255 / 2 ; pxy [ 3 ] = ( ny + 1 ) * 255 / 2 ; pxy [ 4 ] = ( nz + 1 ) * 255 / 2 ; pxy [ 5 ] = ( int ) ( FL * z / ( FL - z ) ) ; }
tr	ORIG	public void manageSecurityEnvironment ( int mode , byte [ ] keyId , byte algSpec ) throws CardServiceException { try { byte p2 = 0 ; switch ( mode ) { case MSE_AUTH : p2 = ( byte ) a4 ; break ; case MSE_SIGN : p2 = ( byte ) b6 ; break ; case MSE_DEC : p2 = ( byte ) b8 ; break ; default : throw new CardServiceException ( "Wrong mode." ) ; } ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( ( byte ) 84 ) ; apduData . write ( ( byte ) keyId . length ) ; apduData . write ( keyId ) ; apduData . write ( ( byte ) 80 ) ; apduData . write ( 01 ) ; apduData . write ( algSpec ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_MSE , 41 , p2 , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "manageSecureEnvironment failed: " ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	REPL	public void setDbUrl ( String aurl ) { if ( ! dbUrl . equals ( aurl ) ) { ( shutDown ) ; dbUrl = aurl ; } }
tr	REPL	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; int , = . query indexOf ( "|" ) ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { String pair = query . substring ( , + 1 , nextComma ) ; addToMap ( pair ) ; , = nextComma ; } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
tr	ORIG	@ Override public int getX ( int x , int width ) { return x - ( width / 2 ) ; }
tr	ORIG	public StatusMessage ( byte buffer [ ] ) { time = ( new Date ( ) ) . getTime ( ) ; msCount = ByteBuffer . wrap ( buffer , 0 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; stepHA = ByteBuffer . wrap ( buffer , 4 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; stepDE = ByteBuffer . wrap ( buffer , 8 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; uStepHA = ByteBuffer . wrap ( buffer , 12 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; uStepDE = ByteBuffer . wrap ( buffer , 16 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; moveSpeedRA = ByteBuffer . wrap ( buffer , 20 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; moveSpeedDE = ByteBuffer . wrap ( buffer , 24 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; ticks = parseInt ( buffer [ 28 ] , buffer [ 29 ] ) ; }
tr	REPL	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) ; advanceSolution ( newOne , ore , mineral , yield , tax ) ; if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addAll ( solveForMineral ( newOne , nextOne , ores , yield , tax ) ) ; } } } return solutions ; } else if mineral ( != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveForMineral ( input , nextOne , ores , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	ORIG	public void characters ( char [ ] ch , int start , int length ) throws SAXException { curstr = new String ( ch , start , length ) ; }
tr	REPL	public List < String > anagrams ( final String [ ] strs ) { final Map < String , LinkedList < String >> map = new HashMap < String , LinkedList < String >> ( ) ; for ( int i = 0 ; i < strs . length i ; ++ ) { final String str = strs [ i ] ; if ( str . isEmpty ( ) ) { continue ; } final char [ ] c = str . toCharArray ( ) ; Arrays . sort ( c ) ; final String sorted = String . valueOf ( c ) ; if ( map . containsKey ( sorted ) ) { map . get ( sorted ) . add ( str ) ; } else { final LinkedList < String > linkedList = new LinkedList < String > ( ) ; linkedList . add ( str ) ; map . put ( sorted , linkedList ) ; } } final List < String > list = new LinkedList < String > ( ) ; for ( final LinkedList < String > strings : map . values ( ) ) { list . addAll ( strings ) ; } return list ; }
tr	REPL	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException IOException , { processRequest ( request , response ) ; }
tr	REPL	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator String < > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	ORIG	private void updateWind ( ) { if ( ( maxWind < 0 && wind < maxWind ) || ( 0 < maxWind && maxWind < wind ) ) { wind += - maxWind / ( FPS * 2 ) ; } else { wind += maxWind / ( FPS * 2 ) ; } }
tr	ORIG	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LOGIN . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new LOGIN ( ) . setVisible ( true ) ; } } ) ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	REPL	@ Override public int getX ( int , x int width ) { return x + ( width / 2 ) ; }
tr	ORIG	public int getLastID ( String table , String nameID ) { int n = 0 ; try { con = DriverManager . getConnection ( url , user , password ) ; Statement stmt ; stmt = con . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; ResultSet rs = stmt . executeQuery ( "select * from " + table + " order by " + nameID ) ; rs . last ( ) ; rs . getInt ( 1 ) ; n = rs . getInt ( 1 ) ; } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } finally { try { if ( pst != null ) { pst . close ( ) ; } if ( con != null ) { con . close ( ) ; } } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } return n ; }
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	REPL	public void MakeSquare ( ) { double vertices [ ] [ ] { = { 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , - 1 , 1 , 0 , 0 , 1 } , { 1 , - 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , - 1 , - 1 , 0 , 0 , - 1 } , { - 1 , - 1 , - 1 , 0 , 0 , - 1 } , } ; int faces [ ] [ ] = { { 0 , 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	REPL	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { image = new TextureLoader ( ) . createImageData ( width , height ) ; g = image . createGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , height - 3 ) ; return new TextureLoader ( ) . loadTexture ( image ; ) } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	ORIG	@ Override public GameCharacterObject setHeight ( int height ) { assert ( height % 2 == 0 ) : "height\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . height = height ; return this ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; for ( go GameObject : gameObjects ) { go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; gameObjects . remove ( go ) ; } } }
tr	REPL	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; DbConfigFile = props . getProperty ( "DbConfigFile" ) RemConfigFile ; = props . getProperty ( "RemConfigFile" ) ; DebugLogFile = props . getProperty ( "DebugLogFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	REPL	public static void findLoop ( long world ) { long [ ] history = new long [ ] 100 ; history [ 0 ] = world ; for ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] == history [ j ] ) { System . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	REPL	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR int , endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	ORIG	public String createCustomerWithParameters ( String firstname , String lastname , String number , String street , String city , String zipcode , Date date ) { if ( firstname . equals ( "" ) & lastname . equals ( "" ) ) { return "the customer name is empty" ; } if ( firstname . equals ( "" ) ) { return "the customer firstname is empty" ; } if ( lastname . equals ( "" ) ) { return "the customer lastname is empty" ; } if ( number . equals ( "" ) ) { return " the customer adress is empty" ; } if ( ! IntegerUtil . isInteger ( zipcode ) ) { return "zipcode is not integer" ; } int zipInt = Integer . parseInt ( zipcode ) ; if ( customerService . createCustomerWithParameters ( firstname . toLowerCase ( ) , lastname . toLowerCase ( ) , number , street . toLowerCase ( ) , city . toLowerCase ( ) , zipInt , date ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	REPL	public void copyItem ( CEvalItem aitem ) { evalid = aitem . evalid ; seriescd = aitem . seriescd ; resultcd = aitem . resultcd ; doseord = aitem . ; doseord acceldate . setTime ( aitem . acceldate . getTime ( ) ) ; recomdate . setTime ( aitem . recomdate . getTime ( ) ) ; overduedate . setTime ( aitem . overduedate . getTime ( ) ) ; if ( resultcd . equals ( CAppConsts . ResComplete ) || resultcd . equals ( CAppConsts . ResImmune ) ) { doseord = 0 ; acceldate . setTime ( 0 ) ; recomdate . setTime ( 0 ) ; overduedate . setTime ( 0 ) ; } }
tr	REPL	public String getFC2ResultStr ( ) { if ( fc2result == null ) { return ( ) "" ; } return ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
tr	REPL	public void reset ( ) try { { valid = false ; theConnection . close ( ) ; theConnection = makeConnection ( ) ; valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , e ) ; } }
tr	ORIG	@ Test public void testStopBuy2 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . StopBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.25 , 1.15 , 1.40 , 1.10 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.26 , 1.16 , 1.41 , 1.11 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.26 , 0.0001 ) ; }
tr	REPL	public int getNumAnswers ( String [ ] lines ) { String first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexOf ( " " ) ) ; int answers = 0 ; for ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i . ] indexOf ( " " ) ; String current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
tr	REPL	private String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary "--" = + boundary ; return boundary ; }
tr	REPL	public static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin . start ( ) ; LOG . log ( Level . INFO , "adding plugin {0}!" , plugin . getName ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no plugins were found!!" ) ; } } catch ( ServiceConfigurationError | Exception e ) { LOG . log ( Level SEVERE . , "service configuration error {0}" , e . toString ( ) ) ; } return result ; }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int n = to . length ( ) ; char [ ] circle = new char [ n ] ; for ( i = 0 ; i < n ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i n < ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= n ) { j -= n ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= n ) { offset -= n ; } } }
tr	REPL	public static void main ( String [ ] args ) { InMemoryAuctionService imas = new InMemoryAuctionService ( ) ; Auction a = new Auction ( 12 , "pizza" , 5 ) ; Auction a1 = new Auction ( 33 , "something" , 8 ) ; System . out . println ( a . toString ( ) ) ; System . out . println ( "The auction object was printed out." ) ; System . out . println ( a . equals ( a ) ) ; System . out . println ( a . equals ( a1 ) ) ; System . out . println ( "Search results for 'Computer'" ) ; Auction [ ] results = imas . search ( "Computer" ) ; for ( int i = 0 ; i < results . length ; i ++ ) { System . out . println ( results [ i ] . toString ( ) ) ; } System . out . println ( "Search results for 'something'" ) ; Auction [ ] falseResults = imas . search ( "something" ) ; for ( int i = 0 ; i < falseResults . length ; i ++ ) { System . out . println ( falseResults [ i ] toString . ( ) ) ; } }
tr	ORIG	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ShotItem>\n" ) ; retstr . append ( "<ShotDate>" + mdyfmt . format ( shotdate ) + "</ShotDate>\n" ) ; retstr . append ( "<VaccineCd>" + vaccinecd + "</VaccineCd>\n" ) ; retstr . append ( "<MfrCd>" + mfrcd + "</MfrCd>\n" ) ; retstr . append ( "</ShotItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	ORIG	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
tr	ORIG	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( aidx , aobj ) ; }
tr	ORIG	public void initTestResults ( ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . testresult = CAppConsts . StatusNone ; } }
tr	ORIG	public int insertQuestion ( final AbstractQuestion aq ) { final Type type = aq . getType ( ) ; if ( type . equals ( Type . RadioButton ) ) { final DatabaseRadioButton drb = new DatabaseRadioButton ( _databaseName ) ; return drb . set ( ( RadioButton ) aq ) ; } else if ( type . equals ( Type . CheckBox ) ) { final DatabaseCheckBox dcb = new DatabaseCheckBox ( _databaseName ) ; return dcb . set ( ( CheckBox ) aq ) ; } else if ( type . equals ( Type . BlankAnswer ) ) { final DatabaseBlankAnswer dba = new DatabaseBlankAnswer ( _databaseName ) ; return dba . set ( ( BlankAnswer ) aq ) ; } else if ( type . equals ( Type . FillInTheBlanks ) ) { final DatabaseFillInTheBlanks dba = new DatabaseFillInTheBlanks ( _databaseName ) ; return dba . set ( ( FillInTheBlanks ) aq ) ; } else if ( type . equals ( Type . ShortCut ) ) { final DatabaseShortCut dba = new DatabaseShortCut ( _databaseName ) ; return dba . set ( ( ShortCut ) aq ) ; } throw new RuntimeException ( "TYPE NOT SUPPORTED" ) ; }
tr	REPL	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( . dtfmt format ( acceldate ) ) ; }
tr	ORIG	PartInputStream ( ServletInputStream in , String boundary ) throws IOException { super ( in ) ; this . boundary = boundary ; }
tr	REPL	public BasicBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter , BULLET_POWER ; ) setColor ( Color . white ) ; double theta = Math . toRadians ( - getShooter ( ) . getAngle ( ) ) ; setVx ( SPEED * ( float ) Math . sin ( theta ) ) ; setVy ( SPEED * ( float ) Math . cos ( theta ) ) ; setVAngle ( 12 ) ; }
tr	REPL	public void MakeSquare ( ) { double [ vertices ] [ ] = { { 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , - 1 , 1 , 0 , 0 , 1 } , { 1 , - 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , - 1 , - 1 , 0 , 0 , - 1 } , { - 1 , - 1 , - 1 , 0 , 0 , - 1 } , } ; int faces [ ] [ ] = { { 0 , 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	@ Override public float move ( int displayBorder , int characterSize , p float , float vp ) { return p + vp ; }
tr	REPL	protected void doPost ( HttpServletRequest request , response HttpServletResponse ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public String buildTiterStr ( Connection aconn , achild int ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildTiterStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	ORIG	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 1 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
tr	REPL	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname "" = ; lastname = "" ; }
tr	REPL	@ Override public GameCharacterObject setWidth ( int width ) { assert ( % width 2 == 0 ) : "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . width = width ; return this ; }
tr	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , , 3 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( DemoCasting2 . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) . ) go ( ) ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = ( getCell world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	private void editCell ( Worker input ) { int i = this . scheduleTable . getSelectedRow ( ) ; int j = this . scheduleTable . getSelectedColumn ( ) ; if ( this . scheduleTable . getValueAt ( i , j ) != null ) { System . out . println ( this . scheduleTable . getColumnName ( j ) ) ; String job = this . scheduleTable . getValueAt ( i , j ) . toString ( ) . split ( ":" ) [ 0 ] ; String date = this . scheduleTable . getColumnName ( j ) . split ( " " ) [ 1 ] ; date = date . substring ( 1 , date . length ( ) - 1 ) ; String [ ] dateNums = date . split ( "/" ) ; date = dateNums [ 2 ] + "/" + dateNums [ 0 ] + "/" + dateNums [ 1 ] ; System . out . println ( date ) ; this . scheduleMap . get ( date ) . put ( job , input ) ; this . scheduleTable . setValueAt ( job + ": " + input . getName ( ) , i , j ) ; } }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TDoseEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	@ Override public boolean checkHitAndAction ( ShootingObject target ) { if ( ! isEnemyForces ( target ) || hittedObjects . contains ( target ) || ! checkHit ( target ) ) { return false ; } hitEffectTo ( target ) ; target . hitEffectTo ( this ) ; return true ; }
tr	ORIG	private String readDocument ( File file ) { String text = "" ; if ( file != null ) { Path path = Paths . get ( file . getAbsolutePath ( ) ) ; try ( BufferedReader reader = Files . newBufferedReader ( path , Charset . defaultCharset ( ) ) ) { String line = null ; boolean firstBlankLineFound = false ; while ( ( line = reader . readLine ( ) ) != null && ! firstBlankLineFound ) { if ( line . isEmpty ( ) || line . trim ( ) . equals ( "" ) || line . trim ( ) . equals ( "\n" ) ) firstBlankLineFound = true ; } while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( ">" ) && ! line . startsWith ( "-" ) && ! ( line . isEmpty ( ) || line . trim ( ) . equals ( "" ) || line . trim ( ) . equals ( "\n" ) ) ) text = text + line + " " ; } } catch ( java . lang . Exception ex ) { } } return text ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TNonAdminTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . doFinal ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return null ; } }
tr	REPL	HelloActionWorld2 ( ) { super ( "Hello Action" ) ; final JLabel label ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = new JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ActionListener ( ) { private int count = 0 ; public void actionPerformed ActionEvent ( e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; } } ) ; setSize ( 320 , 240 ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	REPL	public String getBirthDateStr ( ) { if ( birthdate == null || . birthdate getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( birthdate ) ) ; }
tr	REPL	public static void addURL ( URL u ) throws IOException { URLClassLoader sysLoader = ( URLClassLoader ) ClassLoader . getSystemClassLoader ( ) ; for ( URL url : sysLoader . getURLs ( ) ) { if ( url . toString ( ) . equalsIgnoreCase ( u . toString ( ) ) ) { logger . log ( Level . INFO "URL , {0} is already in the CLASSPATH" , u ) ; return ; } } class sysclass = URLClassLoader . class ; try { Method method = sysclass . getDeclaredMethod ( "addURL" , parameters ) ; method . setAccessible ( true ) ; method . invoke ( sysLoader , new Object [ ] { u } ) ; } catch ( NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException t ) { t . printStackTrace ( ) ; throw new IOException ( "Error  could not add URL to system classloader" ) ; } }
tr	ORIG	public static void criarClientePadraoParaTeste ( ) { XMLGregorianCalendar today = null ; try { today = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( 2008 , 10 , 1 ) ) ; } catch ( DatatypeConfigurationException e ) { e . printStackTrace ( ) ; } Cliente c1 = new Cliente ( ) ; c1 . setCelular ( "999999999" ) ; c1 . setId ( ( long ) 1 ) ; c1 . setNome ( "TESTEID28" ) ; c1 . setCpf ( "111.111.111-11" ) ; c1 . setEmail ( "joaninha@teste.com" ) ; c1 . setDataNascimento ( today ) ; adicionarNovosClientesNaCaptacaoParaTeste ( c1 ) ; }
tr	REPL	void retstat ( ) { FuncState fs = this . fs ; ExpDesc e = new ExpDesc ( ) ; int first , nret ; this . next ( ) ; if ( block_follow ( this . t . token ) || this . t . token == ; ) first = nret = 0 ; else { nret = this . explist1 ( e ) ; if ( hasmultret ( e . k ) ) { fs . setmultret ( e ) ; if ( e . k == VCALL && nret == 1 ) { FuncState . SET_OPCODE ( fs . getcodePtr ( e ) , FuncState . OP_TAILCALL ) ; FuncState . _assert ( FuncState . GETARG_A ( fs . getcode e ( ) ) == fs . nactvar ) ; } first = fs . nactvar ; nret = FuncState . LUA_MULTRET ; } else { if ( nret == 1 ) first = fs . exp2anyreg ( e ) ; else { fs . exp2nextreg ( e ) ; first = fs . nactvar ; FuncState . _assert ( nret == fs . freereg - first ) ; } } } fs . ret ( first , nret ) ; }
tr	ORIG	private void train ( InputIterable < String > trainData ) { int firstHash = 1 ; int secondHash = - 1 ; int firstInsertCount = 0 ; int secondInsertCount = 0 ; WrappedObject first , second ; for ( ParseResult < String > row : trainData ) { first = new WrappedObject ( row . getFirstNode ( ) ) ; second = new WrappedObject ( row . getSecondNode ( ) ) ; if ( ! hash . containsKey ( first ) ) { if ( firstInsertCount > 10000 ) { firstInsertCount = 0 ; firstHash ++ ; } else { firstInsertCount ++ ; } hash . put ( first , firstHash ) ; } if ( ! hash . containsKey ( second ) ) { if ( secondInsertCount > 10000 ) { secondInsertCount = 0 ; secondHash -- ; } else { secondInsertCount ++ ; } hash . put ( second , secondHash ) ; } } }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	REPL	@ Test public void testMoveResult ( ) throws Exception { System . out . println ( "parse MoveResult" ) ; String toParse = "MOVERESULT [[x o x _ _ o _ ] [x o o _ _ x _ ] [o _ _ _ _ x _ ] [_ _ _ _ _ _ _ ] [_ _ _ _ _ _ _ ] [_ _ _ _ _ _ _ ] ] KITstudent" ; String [ ] [ ] board = { { "x" , "o" , "x" , "_" , "_" , "o" , "_" } , { "x" , "o" , "o" , "_" , "_" , "x" , "_" } , { "o" , "_" , "_" , "_" , "_" , "x" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } } ; Command expResult = new MoveResult ( board , ) "KITstudent" ; Command result = Parser . parse ( toParse ) ; assertEquals ( expResult , result ) ; }
tr	REPL	@ Override public synchronized boolean putIfAbsent ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ; ) store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for putIfAbsent() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . putIfAbsent ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	ORIG	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours 2 == || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p + characterSize / 2 < 0 ) { p = displayBorder - p ; } else if ( displayBorder < p - characterSize / 2 ) { p = - p displayBorder + ; } return p ; }
tr	ORIG	FilePart ( String name , ServletInputStream in , String boundary , String contentType , String fileName , String filePath ) throws IOException { super ( name ) ; this . fileName = fileName ; this . filePath = filePath ; this . contentType = contentType ; partInput = new PartInputStream ( in , boundary ) ; }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ( ) col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	ORIG	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 == 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	ORIG	private CallResultInternal sendPost ( URL url , String encodedCall ) throws IOException { HttpURLConnection httpcon = ( HttpURLConnection ) url . openConnection ( ) ; httpcon . setDoOutput ( true ) ; httpcon . setRequestProperty ( "Content-Type" , encoder . contentType ( ) ) ; httpcon . setRequestProperty ( "Accept" , encoder . contentType ( ) ) ; httpcon . setRequestMethod ( "POST" ) ; final OutputStreamWriter osw = new OutputStreamWriter ( httpcon . getOutputStream ( ) , encoder . charset ( ) ) ; osw . write ( encodedCall ) ; osw . close ( ) ; int responseCode = httpcon . getResponseCode ( ) ; if ( HttpStatus . isClientError ( responseCode ) || HttpStatus . isServerError ( responseCode ) ) { return new CallResultInternal ( responseCode , readString ( httpcon . getErrorStream ( ) ) ) ; } return new CallResultInternal ( CallResultInternal . NO_ERROR , readString ( httpcon . getInputStream ( ) ) ) ; }
tr	REPL	public Object getObject ( String astr ) { int idx = getIndex ( astr ) ; if ( idx < 0 ) return ( null ) ; return ( getItem ( idx ) ; ) }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row 0 = ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	ORIG	public static String [ ] [ ] loadCategories ( ) throws SQLException { ResultSet rsCat ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from categories order by displayOrder" ; rsCat = conn . createStatement ( ) . executeQuery ( sql ) ; rsCat . last ( ) ; String categoriesLoad [ ] [ ] = new String [ rsCat . getRow ( ) ] [ 3 ] ; rsCat . beforeFirst ( ) ; while ( rsCat . next ( ) ) { categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 0 ] = rsCat . getString ( "catagoryId" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 1 ] = rsCat . getString ( "category_name" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 2 ] = rsCat . getString ( "displayOrder" ) ; } return categoriesLoad ; } }
tr	REPL	public boolean isSeriesDose ( String aseries ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aseries ) ) { ( return true ) ; } } return ( false ) ; }
tr	ORIG	public boolean isSubset ( String [ ] subset , String [ ] set ) { for ( String subElem : subset ) { if ( subElem . equals ( subset [ 0 ] ) ) { continue ; } if ( subElem . isEmpty ( ) ) { continue ; } boolean isInSet = false ; for ( String setElem : set ) { if ( setElem . isEmpty ( ) ) { continue ; } if ( subElem . equals ( setElem ) ) { isInSet = true ; } } if ( ! isInSet ) { return false ; } } return true ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	REPL	public void run ( ) { if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } { else fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	REPL	public static void main ( String [ ] args ) { int [ ] array = new int [ ] { 1 , 1 , 2 , 3 , 3 , 4 , 4 } ; System . out . println ( findNumOfUniqueElements ( array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; array = new int [ ] { 3 , 2 , 1 , 5 , 4 } ; System . out . println ( ( findNumOfUniqueElements array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; array = new int [ ] { 3 , 3 , 1 , 1 , 2 , 2 } ; System . out . println ( findNumOfUniqueElements ( array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; array = new int [ ] { 5 , 3 , 1 , 1 , 4 , 5 , 2 } ; System . out . println ( findNumOfUniqueElements ( array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; }
tr	REPL	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . ( setString 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	REPL	public void close ( ) throws IOException { if ( ! eof { ) while ( read ( buf , 0 , buf . length ) != - 1 ) ; } }
tr	REPL	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { return + p vp ; }
tr	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir ) throws IOException { this ( aRequest , aSaveDir , DefMaxPostSize ) ; }
tr	REPL	public void shutDown ( ) { try { = valid false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	REPL	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ltop ( + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( ltop ) ; }
tr	REPL	public Map < String , float > askVar ( ) { String varName ; float value ; Map < String , float > vars = new HashMap < > ( ) ; Scanner in = new Scanner ( System . in ) ; System . out . println ( "Enter a random variable: " ) ; varName = in . nextLine ( ) ; System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; boolean loop = true ; Scanner sc = new Scanner ( System . in ) ; while ( loop ) { System . out . println ( "Enter another random variable or press Enter " + "to continue:" ) ; varName = . sc nextLine ( ) ; if ( varName . equals ( "" ) ) { break ; } System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; } return vars ; }
tr	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
tr	REPL	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail count = - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	public static addValue int ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	public void drawMyFigure ( Graphics g , int w , int h , Matrix m ) { this . w = w ; this . h = h ; for ( int f = 0 ; f < faces . length ; f ++ ) { for ( int f2 = 0 ; f2 < faces [ f ] . length ; f2 ++ ) { int i = faces [ f ] [ f2 ] ; int j = faces [ f ] [ ( f2 + 1 ) % faces [ f ] . length ] ; m . transform ( vertices [ j ] , point1 ) ; m . transform ( vertices [ i ] , point0 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } } }
tr	REPL	void public setDbClass ( String adbclass ) { try { class . forName ( adbclass ) ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error loading class:" , e ) ; } }
tr	REPL	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO recordsitestat  (uniquevisitor uniquevisitordate  " + "pageview  pageviewdate  visit  visitdate  site_id) VALUES (?  ?  ?  ?  ?  ?  ?)" ; PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , recordSiteStatModel . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , recordSiteStatModel . getPageView ( ) ) ; ps . setLong ( 4 , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , recordSiteStatModel . getVisit ( ) ) ; ps . setLong ( 6 , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , recordSiteStatModel . getSite ( ) . getId ( ) ) ; log . trace ( "Prepared statement created as" + ps . toString ( ) ) ; log . debug ( "ps: {}" , ps . toString ( ) ) ; return ps ; }
tr	ORIG	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	ORIG	public static Map < Integer , LinkedList < Node >> buildLinkedLists ( Node root ) { Queue < NodeDepth > queue = new LinkedList < > ( ) ; int idx = 0 ; queue . add ( new NodeDepth ( idx , root ) ) ; Map < Integer , LinkedList < Node >> result = new HashMap < > ( ) ; while ( ! queue . isEmpty ( ) ) { NodeDepth n = queue . remove ( ) ; if ( ! result . containsKey ( n . depth ) ) { result . put ( n . depth , new LinkedList < Node > ( ) ) ; } result . get ( n . depth ) . add ( n . node ) ; if ( n . node . left != null ) { queue . add ( new NodeDepth ( n . depth + 1 , n . node . left ) ) ; } if ( n . node . right != null ) { queue . add ( new NodeDepth ( n . depth + 1 , n . node . right ) ) ; } } return result ; }
tr	ORIG	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp = b ; b = c ; c = temp ; } else { int [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { int [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp ; temp = b ; b = a ; a = temp ; } else { int [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	ORIG	public synchronized boolean removeDirectory ( String dirname ) throws IOException , ConnectionException { cwd ( dirname ) ; ArrayList < FTPFile > list = list ( ) ; ArrayList < FTPFile > directoriesList = new ArrayList < FTPFile > ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } for ( FTPFile directory : directoriesList ) { if ( ! ( directory . getFilename ( ) . equals ( ".." ) ) ) removeDirectory ( directory . getFilename ( ) ) ; } list = list ( ) ; directoriesList . clear ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } if ( directoriesList . size ( ) == 1 ) { cwd ( ".." ) ; sendLine ( "RMD " + dirname ) ; String response = getAllResponses ( "250" , read . readLine ( ) ) ; return response . startsWith ( "250 " ) ; } return true ; }
tr	REPL	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not which specified cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public void printQuery ( String queryVar , Map < String , float > vars ) { System . out . print ( "P( " + queryVar + " | " ) ; Set < String > keySet = vars . keySet ( ) ; Iterator < String > keySetIterator = keySet . iterator ( ) ; String key = keySetIterator . next ( ) ; System . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keySetIterator . hasNext ( ) ) { key = keySetIterator . next ( ) ; System . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } System . out . print ( ")" ) ; }
tr	REPL	public static Node compile ( Node node ) { if ( node instanceof Comment ) { return node ; } else if ( node instanceof PrintBold ) { return new Block ( new Print ( "**" ) , new Block ( new Print ( ( ( PrintBold ) node ) . message ) , new Print ( "**" ) ) ) ; } else if ( node instanceof Print ) { return node ; } else if ( node instanceof Block ) { Block block = ( Block ) node ; boolean fc = block . first instanceof Comment ; boolean sc = block . second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return compile ( block . second ) ; if ( sc ) return compile ( block . first ) ; return new Block ( compile ( block . first ) , compile ( block . second ) ) ; } else { System . err . println ( "ERR: match no for node." ) ; System . exit ( 42 ) ; return null ; } }
tr	ORIG	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	ORIG	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
tr	REPL	public getRecomDateStr String ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	REPL	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { groupCheckBox = new JCheckBox ( ) ; jScrollPane2 = new JScrollPane ( ) ; playerPanel = new JPanel ( ) ; filler1 = new Box . Filler ( new Dimension ( 5 , 0 ) new , Dimension ( 15 , 0 ) , new Dimension ( 5 , 0 ) ) ; setLayout ( new BorderLayout ( ) ) ; groupCheckBox . setText ( "group name" ) ; groupCheckBox . setEnabled ( false ) ; add ( groupCheckBox , BorderLayout . NORTH ) ; jScrollPane2 . setBorder ( null ) ; playerPanel . setLayout ( new BoxLayout ( playerPanel , BoxLayout . Y_AXIS ) ) ; jScrollPane2 . setViewportView ( playerPanel ) ; add ( jScrollPane2 , BorderLayout . CENTER ) ; add ( filler1 , BorderLayout . WEST ) ; }
tr	ORIG	@ SuppressWarnings ( { "unused" , "resource" } ) public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; BigDecimal N = new BigDecimal ( 8.0 ) ; BigDecimal K = new BigDecimal ( 8.0 ) ; BigDecimal Check = new BigDecimal ( 0.0 ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { N = in . nextBigDecimal ( ) ; K = in . nextBigDecimal ( ) ; try { BigDecimal R [ ] = N . divideAndRemainder ( K ) ; System . out . println ( R [ 0 ] + " " + R [ 1 ] ) ; } catch ( Exception e ) { System . out . println ( "0 " + N ) ; } } }
tr	ORIG	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) == 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	ORIG	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
tr	REPL	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , ) c ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	ORIG	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem == null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	REPL	@ Override public int getX ( int x , int width ) { return x + ( width / ) 2 ; }
tr	REPL	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; setTexture ( null ) } ; }
tr	REPL	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = currentFrameTime_ns - prevFrameTime_ns ; calculatedFPS = ( ( double ) ( currentFrame ) / realElapsedTime_ns ) * 1000000000 ; currentFrame = 0 ; fpsCalcInterval_ns = 0 ; prevFrameTime_ns = currentFrameTime_ns } ; updateDisplay ( ) ; }
tr	ORIG	public LoginScreen ( ) { super ( ) ; gridPane . add ( userName , 0 , 0 ) ; userName . setPromptText ( "Username" ) ; gridPane . setVgap ( 15 ) ; gridPane . add ( password , 0 , 1 ) ; password . setPromptText ( "password" ) ; userName . setPrefHeight ( 50 ) ; password . setPrefHeight ( 50 ) ; gridPane . add ( submitBtn , 0 , 2 ) ; submitBtn . setPrefSize ( 450 , 100 ) ; gridPane . setAlignment ( Pos . CENTER ) ; this . setCenter ( gridPane ) ; this . setStyle ( "-fx-background-color: #090a0c linear-gradient(#6B7E8F 0%  #495561 20%  #4A5766 100%) linear-gradient(#53626F  #3E4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitBtn . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) != null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	ORIG	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	REPL	public static Map sortByValue ( Map < Integer , float > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . ( getValue ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn close . ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	ORIG	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) != 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	ORIG	public CRunTest ( CAppProps aprops , CDbConnMan alocman , CDbConnMan aremman , String agroup , String atest , String afc1 , String afc2 , int runoption ) { super ( ) ; locconnman = alocman ; remconnman = aremman ; props = aprops ; testgrpid = agroup ; testid = atest ; fc1 = afc1 ; fc2 = afc2 ; fcrunoption = runoption ; }
tr	ORIG	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	REPL	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . ( add idx , aobj ) ; } } else { idx = getIndex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	REPL	public void setRecomDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) recomdate = new Date ( ) 0 ; else recomdate = dtfmt . parse ( aval ) ; }
tr	REPL	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList padInt . ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	REPL	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total copy , ) ; pos += copy ; total += copy ; } return total ; }
tr	REPL	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count buf < . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	ORIG	UploadedFile ( String aFileDir , String aFileName , String aContType ) { this . fFileDir = aFileDir ; this . fFileName = aFileName ; this . fContType = aContType ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	public EDFEnemy ( ShootingScene parentScene , float bornAngle , LR lr ) { super ( parentScene , POWER , HP ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setElevation ( WIDTH / 2 ) ; setVElevation ( - FALL_SPEED ) ; setAngle ( bornAngle ) ; setVAngle ( ROTATE_SPEED * lr . signum ( ) ) ; setTexture ( TEXTURE ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setColor ( Color . orange ) ; }
tr	REPL	private void checkHit ( ) { List < ShootingObject > soList = new LinkedList < > ( ) ; soList . addAll ( enemieCharas ) ; soList . addAll ( friendlieCharas ) ; soList . ( addAll bullets ) ; for ( int i = 0 ; i < soList . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < soList . size ( ) ; j ++ ) { soList . get ( i ) . checkHitAndAction ( soList . get ( j ) ) ; } } }
tr	ORIG	private void reflectClassWrapper ( Map < Type , Set < GeneTrait >> genePool , String className , int parameterCount , List < String > parameterTypes , int parametersSet ) throws ClassNotFoundException { if ( parametersSet < parameterCount ) { for ( BreedingClassSetup classSetup : Settings . getSettings ( ) . getClasses ( ) ) { if ( ! rawTypesClassMap . containsKey ( classSetup . className ) ) { if ( parameterTypes . size ( ) >= parametersSet + 1 ) { parameterTypes . remove ( parametersSet ) ; } parameterTypes . add ( parametersSet , classSetup . className ) ; reflectClassWrapper ( genePool , className , parameterCount , parameterTypes , parametersSet + 1 ) ; } } } else { class < ? > clazz = rawTypesClassMap . get ( className ) ; if ( clazz == null ) { clazz = class . forName ( className ) ; } Type classType = Type . getType ( className + ( ( parameterCount == 0 ) ? "" : ( "<" + Tools . implode ( parameterTypes , " " ) + ">" ) ) ) ; reflectClass ( genePool , clazz , className , classType , parameterTypes ) ; } }
tr	REPL	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd forward . ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	REPL	public String static encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	REPL	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) if ; ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
tr	ORIG	private RecordArticleStatDayModel updateRecordArticleStatDay ( RecordArticleStatDayModel recordArticleStatDayModel ) { String sql = "UPDATE recordarticlestatday SET uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordArticleStatDayModel . getUniqueVisitor ( ) , recordArticleStatDayModel . getUniqueVisitorArticleId ( ) , recordArticleStatDayModel . getUniqueVisitorArticleTitle ( ) , recordArticleStatDayModel . getUniqueVisitorArticleUrl ( ) , recordArticleStatDayModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordArticleStatDayModel . getPageView ( ) , recordArticleStatDayModel . getPageViewArticleId ( ) , recordArticleStatDayModel . getPageViewArticleTitle ( ) , recordArticleStatDayModel . getPageViewArticleUrl ( ) , recordArticleStatDayModel . getPageViewDate ( ) . getMillis ( ) , recordArticleStatDayModel . getVisit ( ) , recordArticleStatDayModel . getVisitArticleId ( ) , recordArticleStatDayModel . getVisitArticleTitle ( ) , recordArticleStatDayModel . getVisitArticleUrl ( ) , recordArticleStatDayModel . getVisitDate ( ) . getMillis ( ) , recordArticleStatDayModel . getSite ( ) . getId ( ) , recordArticleStatDayModel . getId ( ) ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordArticleStatDayModel . getId ( ) ) ; } return recordArticleStatDayModel ; }
tr	REPL	@ Test public void testEvict ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK evict . ( "1" ) ; assertNull ( topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; topK . evict ( "2" ) ; assertNull ( topK . suggest ( ) ) ; topK . evict ( "2" ) ; assertNull ( topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; }
tr	REPL	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , { IOException processRequest ( request , response ) ; }
tr	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	ORIG	public void dbDeleteResult2 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc2 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult2 cannot delete item. " , ex ) ; } }
tr	REPL	private static void setPreSettingsFor2DGame ( ) { glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_CULL_FACE ) ; glCullFace ( GL_BACK ) ; glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; glOrtho ( 0 , WIDTH 0 , , HEIGHT , - DEPTH / 2 , DEPTH / 2 ) ; glMatrixMode ( GL_MODELVIEW ) ; AlphaBlend . AlphaBlend . config ( ) ; }
tr	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } this . lastScore = tempScore ; return tempMove ; }
tr	REPL	private static String left ( String text , int length ) { String result = text + "                                              " ; result = result . substring ( 0 , length ) ; return "| " + result ; }
tr	ORIG	private void method89 ( Class30_Sub1 class30_sub1 ) { int i = 0 ; int j = - 1 ; int k = 0 ; int l = 0 ; if ( class30_sub1 . anInt1296 == 0 ) i = worldController . method300 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 1 ) i = worldController . method301 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 2 ) i = worldController . method302 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 3 ) i = worldController . method303 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( i != 0 ) { int i1 = worldController . method304 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 , i ) ; j = i >> 14 & 7fff ; k = i1 & 1f ; l = i1 >> 6 ; } class30_sub1 . anInt1299 = j ; class30_sub1 . anInt1301 = k ; class30_sub1 . anInt1300 = l ; }
va	REPL	public ArrayList < Integer > inorderTraversal ( TreeNode root ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; Deque < TreeNode > stack = new ArrayDeque < TreeNode > ( ) ; Set < TreeNode > set = new HashSet < TreeNode > ( ) ; stack . push ( root ) ; while ( stack . size ( ) > 0 ) { TreeNode node = . stack peek ( ) ; if ( node . left != null && ! set . contains ( node . left ) ) { stack . push ( node . left ) ; continue ; } node = stack . pop ( ) ; set . add ( node ) ; result . add ( node . val ) ; if ( node . right != null ) { stack . push ( node . right ) ; } } return result ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public RandomListNode copyRandomList ( RandomListNode head ) { if ( head == null ) return null ; RandomListNode p = head , p1 ; while ( p != null ) { p1 = new RandomListNode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p next . ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } RandomListNode dummy = new RandomListNode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
va	ORIG	public void wizardMode ( ) { if ( JOptionPane . showConfirmDialog ( null , "Activate Wizard Mode? (This will set your score to 0)" , "Wizard Mode" , JOptionPane . YES_NO_OPTION ) == JOptionPane . YES_OPTION ) { player . setWizardUsed ( true ) ; player . setCurrentHP ( 9999 ) ; player . setMaxHP ( 9999 ) ; player . setNaturalAC ( 50 ) ; player . setAttackBonus ( 50 ) ; player . setBaseDamage ( 100 ) ; player . setStrength ( 100 ) ; player . setDexterity ( 20 ) ; player . increaseNutrition ( 90000 ) ; EntityCreator creator = Controller . getInstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . addItem ( creator . createFood ( "spice" ) ) ; player . addItem ( creator . createArmour ( "space marine armour" ) ) ; player . addItem ( creator . createWeapon ( "lightsaber" ) ) ; Controller . getInstance ( ) . updatePlayerStatus ( ) ; println ( "By the Power of Grayskull  I HAVE THE POWER." ) ; } }
va	ORIG	public static boolean anyKeyPressed ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_PRESSED ) { return true ; } } return false ; }
va	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
va	REPL	private static int getNextNumber ( ) { int returnValue = 0 ; String filePath = SystemUtils . USER_HOME + SystemUtils . FILE_SEPARATOR + ".reportnumber.asc" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { FileAsciiReader fileAsciiReader = new FileAsciiReader ( filePath ) ; String chaine = fileAsciiReader . readLine ( ) ; fileAsciiReader . close ( ) ; fileAsciiReader = null ; if ( StringUtils . isNumeric ( chaine ) ) { returnValue = Integer . parseInt ( chaine ) ; } } catch ( IOException e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } } try { FileAsciiWriter fileAsciiWriter = new FileAsciiWriter ( filePath ) ; fileAsciiWriter . write ( "" + ( ++ returnValue ) ) ; fileAsciiWriter . close ( ) ; fileAsciiWriter = null ; } catch ( IOException ) e { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } LOGGER . config ( "filePath=" + filePath + " => " + returnValue ) ; return returnValue ; }
va	REPL	public void importResource ( RDFDataset result , Resource subject ) { final String subj = getID ( subject ) ; final StmtIterator statements = subject . getModel ( ) . listStatements ( subject , ( Property ) null , ( RDFNode ) null ) ; while ( statements . hasNext ( ) ) { final Statement statement = statements . next ( ) ; final Property predicate = statement . getPredicate ( ) ; final RDFNode object = statement . getObject ( ) ; if ( object . isLiteral ( ) ) { final Literal = literal object . asLiteral ( ) ; final String value = literal . getLexicalForm ( ) ; final String datatypeURI = literal . getDatatypeURI ( ) ; String language = literal . getLanguage ( ) ; if ( "" . equals ( language ) ) { language = null ; } result . addTriple ( subj , predicate . getURI ( ) , value , datatypeURI , language ) ; } else { final Resource resource = object . asResource ( ) ; final String res = getID ( resource ) ; result . addTriple ( subj , predicate . getURI ( ) , res ) ; } } }
va	REPL	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = ( createImage mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	private void nextMove ( int type ) { if ( type == 0 ) { holdable = true ; generateNextTokens ( ) ; } else { currentType = type ; } switch ( currentType ) { case 1 : setPositionForCase1 ( currentTokens , 3 ) ; rotater = new RotaterI ( tokens ) ; break ; case 2 : setPositionForCase2 ( currentTokens , 3 ) ; rotater = new RotaterJ ( tokens ) ; break ; case 3 : setPositionForCase3 ( currentTokens , 3 ) ; rotater = new RotaterL ( tokens ) ; break ; case 4 : setPositionForCase4 ( currentTokens , 3 ) ; rotater = new RotaterO ( tokens ) ; break ; case 5 : setPositionForCase5 ( currentTokens , 3 ) ; rotater = new RotaterS ( tokens ) ; break ; case 6 : setPositionForCase6 ( currentTokens , 3 ) ; rotater = new RotaterT ( tokens ) ; break ; default : setPositionForCase7 ( currentTokens , 3 ) ; rotater = new RotaterZ ( tokens ) ; } if ( checkIsLose ( ) ) { lose ( ) ; return ; } setCurrentTokens ( currentType ) ; setDirectingTokens ( ) ; rotateCount = 0 ; refresh ( ) ; }
va	ORIG	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	ORIG	@ Override public float damage ( float damage ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
va	ORIG	public void shoot ( ) { if ( remainBullet <= 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
va	REPL	@ Override public boolean getObjectFromDatabase ( Connection conn ) { java . sql . PreparedStatement pStmt ; try { conn . setAutoCommit ( false ) ; pStmt = conn . prepareStatement ( "select * from st_notes   where stn_user_id=? and stn_period_id=? order by stn_id desc" ) ; pStmt . setInt ( 1 , stn_user_id ) ; pStmt . setInt ( 2 , ) stn_period_id ; ResultSet rs = pStmt . executeQuery ( ) ; if ( rs . next ( ) ) { this . stn_user_notes = rs . getString ( "stn_user_notes" ) ; this . stn_dt = rs . getDate ( "stn_dt" ) ; this . stn_period_id = rs . getInt ( "stn_period_id" ) ; this . stn_user_id = rs . getInt ( "stn_user_id" ) ; System . out . println ( "Deptt: " + this . stn_user_notes + "" ) ; } else { try { throw ( new ProvisionException ( 6 , "Notes not found" ) ) ; } catch ( ProvisionException e ) { e . printStackTrace ( ) ; } } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; try { conn . rollback ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return true ; }
va	REPL	private GameText ( ) { File textFolder = new File ( TEXT_FOLDER ; ) if ( ( textFolder . exists ( ) ) && ( textFolder . isDirectory ( ) ) ) { File [ ] fileList = textFolder . listFiles ( ) ; for ( int i = 0 ; i < fileList . length ; i ++ ) { if ( fileList [ i ] . isFile ( ) ) { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( fileList [ i ] ) ; br = new BufferedReader ( fs ) ; String complete = "" ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { complete = complete + nextLine + "\n" ; nextLine = br . readLine ( ) ; } textMapping . put ( fileList [ i ] . getName ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { System . out . println ( "Warning! Failed to add a text file." ) ; e . printStackTrace ( ) ; } } } } }
va	ORIG	ArrayList < String > wordBreakDFS ( String s , Set < String > dict ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result . add ( head ) ; break ; } if ( cache . containsKey ( tail ) ) { tmpList = cache . get ( tail ) ; } else { tmpList = wordBreakDFS ( tail , dict ) ; } for ( String ss : tmpList ) { result . add ( head + " " + ss ) ; } } } cache . put ( s , result ) ; return result ; }
va	ORIG	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; . temp set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . ( set 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	@ Test public void testSubquery ( ) throws ParsingException { QueryMap qm = QueryFactory . createQueryMap ( "test.sql" ) ; Query main = qm . getQuery ( "main" ) ; assertArrayEquals ( new String [ ] { "name" , "id" } , main . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . text ) ; Query sub1 = qm . getQuery ( main , "sub1" ) ; assertArrayEquals ( new String [ ] { "name" , "city" , "id" } , sub1 . parameters ) ; assertEquals ( "select id  ?   zip  ?   email\nfrom tb where id=?  and zip is not null" , sub1 . text ) ; Query sub2 = qm . getQuery ( main , "sub2" ) ; assertArrayEquals ( new String [ ] { "name" , "id" , "email" } , sub2 . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=? and email =?  and zip is null" not , sub2 . text ) ; Query sub12 = qm . getQuery ( main , "sub2" , "sub1" ) ; assertArrayEquals ( new String [ ] { "name" , "city" , "id" , "email" } , sub12 . parameters ) ; assertEquals ( "select id  ?   zip  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub12 . text ) ; }
va	REPL	void paintFrame ( Graphics g ) { buf_gfx = g ; setColor ( g , el . fg_color ) ; setFont ( el . msg_font ) ; try { paintFrame ( ) ; } catch ( JGameError ex ) { exitEngine ( dbgExceptionToString ( ex ) ) ; } catch ( Exception ex ) { dbgShowException ( "MAIN" , ex ) ; } invokeGameStateMethods ( "paintFrame" , el . gamestate ) ; if ( ( debugflags & GAMESTATE_DEBUG ) != 0 ) { String state "{" = ; for ( Enumeration e = el . gamestate . elements ( ) ; e . hasMoreElements ( ) ; ) { state += ( String ) e . nextElement ( ) ; if ( e . hasMoreElements ( ) ) state += " " ; } state += "}" ; setFont ( el . msg_font ) ; setColor ( g , el . fg_color ) ; drawString ( state , el . viewWidth ( ) , el . viewHeight ( ) - ( int ) getFontHeight ( g , el . msg_font ) , 1 ) ; } if ( ( debugflags & MSGSINPF_DEBUG ) != 0 ) paintDbgFrameLogs ( buf_gfx ) ; buf_gfx = null ; }
va	ORIG	public final Texture loadTexture ( final ByteBuffer buffer , int width , int height ) { try { return loadTexture ( writePixels ( buffer , width , height ) ) ; } catch ( IOException e ) { System . err . println ( ) ; e . printStackTrace ( ) ; return null ; } }
va	ORIG	public boolean isActive ( String ligne ) { boolean returnValue = true ; String buffer = null ; for ( Key key : xmlline . getKeys ( ) ) { if ( ! key . isBlank ( ) ) { if ( ( key . getStartposition ( ) > ligne . length ( ) ) || ( ( key . getStartposition ( ) + key . getSize ( ) ) > ligne . length ( ) ) ) { returnValue &= false ; break ; } else { buffer = key . getValue ( ligne ) ; returnValue &= buffer . equals ( key . getKeyValue ( ) ) ; } } else { buffer = key . getValue ( ligne ) ; returnValue &= ! ( key . isBlank ( ) ^ StringUtils . isEmpty ( buffer . trim ( ) ) ) ; } } return returnValue ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public < T > T unmap ( Map < String , ? > genericised , class < T > type ) { ReMapperMeta meta = extractMeta ( genericised ) ; if ( meta == null ) { System . err . println ( "__ null meta: umm... what now?" ) ; } if ( meta != null ) { class < ? > metaType = meta . getType ( ) ; if ( ! type . isAssignableFrom ( metaType ) ) throw new RuntimeException ( "Type " + metaType + " is not a subclass of expected type " + type ) ; Object instance ; try { instance = metaType . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } for ( String fieldName : genericised . keySet ( ) ) { if ( fieldName . equals ( metaTagName ) ) continue ; PersistentFieldMeta persistentFieldMeta = getPersistentFieldMeta ( metaType , fieldName ) ; if ( persistentFieldMeta == null ) continue ; Object value = fullUnmap ( genericised . get ( fieldName ) , persistentFieldMeta . getType ( ) ) ; persistentFieldOperator . set ( instance , persistentFieldMeta , value ) ; } return ( T ) instance ; } throw new RuntimeException ( "Unable to unmap: " + genericised ) ; }
va	REPL	public String writeEnd ( ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|  ---------------------------------------------------------------------------+" ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|" ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_SELECT" ) + "     : " + nbSelected ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_INSERT" ) + "      : " + nbInsert ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|   "  + RessourceReporting . getString ( "INFO_NUMBER_OF_UPDATE" ) + "      : " + nbUpdate ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_DELETE" ) + "     : " + nbDelete ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|" ) ; return sb . toString ( ) ; }
va	REPL	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { &= packed ~ ( ( long ) 1 << position ) ; } return packed ; }
va	REPL	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row 0 < ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
va	ORIG	@ Override public void update ( ) { if ( FPSManager . totalFrame ( ) % 45 == 0 ) { pressStartText . toggleVisible ( ) ; } if ( ! Key . ESCAPE . isPressed ( ) && Key . anyKeyPressed ( ) ) { GameSceneManager . getInstance ( ) . changeSceneIfNotNull ( nextScene ) ; } }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileCsv ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.csv" ) ) ; String fileSource = new File ( ClassLoader getSystemResource . ( "org/jobjects/dbimp/userfilename.csv" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "ISO-8859-1" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename-csv.xml" ) . toURI ( ) ) . getAbsolutePath ( ) ; boolean cached = false ; boolean verbose = true ; String fileNameReport = File . createTempFile ( "imp" , ".txt" ) . getAbsolutePath ( ) ; LOGGER . fine ( "fileNameReport=" + fileNameReport ) ; Importation . importFile ( fileSource , fileSourceEncoding , fileNameParameter , conn , DerbyConstantes . SCHEMA_NAME , cached , verbose , fileNameReport ) ; assert . assertTrue ( true ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	ORIG	public MyShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "tokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( getHeight ( ) ) ; setColor ( new Color ( 0.6f , 0.6f , 1f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
va	REPL	public static FPSManager getInstance ( ) if { ( instance == null ) { instance = new FPSManager ( ) ; } return instance ; }
va	REPL	public void damageUpdate ( ) { if ( ! damaging ) { return ; } dmgVibMove *= 0.95f ; dmgVibThita += 1 ; setX ( getPixcelX ( ) + dmgVibMove * float ( ) sin ( dmgVibThita ) ) ; if ( dmgVibMove < 0.5 ) { damaging = false ; } }
va	ORIG	protected static KDPlusNode ins ( HPoint key , Object val , KDPlusNode t , int lev , int K , KDPlusTree owner ) { if ( t == null ) { t = new KDPlusNode ( key , val ) ; if ( owner . end != null ) { owner . end . next = t ; t . previous = owner . end ; } owner . end = t ; } else if ( key . equals ( t . k ) ) { t . v = val ; if ( t . deleted ) { t . deleted = false ; t . v = val ; } } else if ( key . coord [ lev ] > t . k . coord [ lev ] ) { t . balance -- ; t . right = ins ( key , val , t . right , ( lev + 1 ) % K , K , owner ) ; } else { t . balance ++ ; t . left = ins ( key , val , t . left , ( lev + 1 ) % K , K , owner ) ; } return t ; }
va	ORIG	public final BufferedImage createImageData ( final int width , final int height ) { WritableRaster raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , width , height , 4 , null ) ; BufferedImage bufferedImage = new BufferedImage ( glAlphaColorModel , raster , true , new Hashtable < > ( ) ) ; return bufferedImage ; }
va	REPL	public static void example12 ( ) { WorldSet myWorld = new WorldSet ( ) ; myWorld . addFormula ( a . e . EMPTY_FORMULA ; ) DefaultRule rule1 = new DefaultRule ( ) ; rule1 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule1 . setJustificatoin ( "B" ) ; rule1 . setConsequence ( "C" ) ; DefaultRule rule2 = new DefaultRule ( ) ; rule2 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule2 . setJustificatoin ( "~B" ) ; rule2 . setConsequence ( "D" ) ; RuleSet myRules = new RuleSet ( ) ; myRules . addRule ( rule1 ) ; myRules . addRule ( rule2 ) ; DefaultReasoner loader = new DefaultReasoner ( myWorld , myRules ) ; HashSet < String > extensions = loader . getPossibleScenarios ( ) ; a . e . println ( "This example is titled Commitment to assumptions" ) ; a . e . println ( "Given the world: \n\t" + myWorld . toString ( ) + "\n And the rules \n\t" + myRules . toString ( ) ) ; a . e . println ( "Possible Extensions" ) ; for ( String c : extensions ) { a . e . println ( "\t Ext: Th(W U (" + c + "))" ) ; } }
va	ORIG	@ Override public void hitEffectTo ( ShootingObject target ) { hittedObjects . add ( target ) ; target . damage ( getPower ( ) ) ; }
va	REPL	public static ArrayList < Question > findById_AllQuestions ( int id , BaseSetting bs ) { Connection connection = bs . getConnection ( ) ; ArrayList < Question > alq = new ArrayList < Question > ( ) ; try { String query = "SELECT * FROM Contains WHERE id_e = ?" ; PreparedStatement p_statement = connection . prepareStatement ( query ) ; p_statement . setInt ( 1 , id ) ; ResultSet rs = p_statement . executeQuery ( ) ; while ( rs . next ( ) ) { int idq = rs . getInt ( "id_q" ) ; if ( QuestionCalculation . findById ( idq , bs ) != null ) alq . add ( QuestionCalculation . findById ( idq , bs ) ) ; if ( QuestionFraction . findById ( idq , bs ) != null ) alq . add ( QuestionFraction . findById ( idq , bs ) ) ; if ( QuestionEquation . findById ( idq , bs ) != null ) alq . add ( QuestionEquation . findById ( idq , bs ) ) ; } } catch ( SQLException sqle ) { System . out . println ( "ERREUR" ) ; sqle . printStackTrace ( ) } ; return alq ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math cos . ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	@ Test public void testColumnWidthIsDecidedByRowBuilder ( ) { int columns = 4 ; PokemonStats pokemonStats1 = mock ( PokemonStats . class ) ; PokemonStats pokemonStats2 = mock ( PokemonStats . class ) ; Object [ ] row1 = { 9 , 6 , 3 , 2 } ; Object [ ] row2 = { 8 , 7 , 4 , 1 } ; when ( rowBuilder . buildRow ( pokemonStats1 ) ) . thenReturn ( row1 ) ; when ( rowBuilder . buildRow ( pokemonStats2 ) ) . thenReturn ( row2 ) when ; ( rowBuilder . getColumnCount ( ) ) . thenReturn ( columns ) ; List < PokemonStats > statsCollection = Arrays . asList ( pokemonStats1 , pokemonStats2 ) ; tableModel . setPokemonStats ( statsCollection ) ; assertEquals ( columns , tableModel . getColumnCount ( ) ) ; Object [ ] [ ] grid = { row1 , row2 } ; for ( int r = 0 ; r < 2 ; ++ r ) { for ( int c = 0 ; c < columns ; ++ c ) { assertEquals ( grid [ r ] [ c ] , tableModel . getValueAt ( r , c ) ) ; } } }
va	REPL	Skeleton ( JMSRemoteSystem remoteSystem , JMSRemoteRef ref , Object target ) { this . remoteSystem = remoteSystem ; try { this . target = target ; class < ? > clazz = this . target . getClass ( ) ; if ( CGLibProxyAdapter . isProxyClass ( ref . getProxy ( ) . getClass ( ) ) ) { for ( Method method : clazz . getMethods ( ) ) { if ( method . getDeclaringClass ( ) == Object . class ) { continue ; } String sig = JMSRemoteSystem . signature ( method ) ; methods . put ( sig , clazz . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ) ; } } else { for ( class < ? > intf : ref . getInterfaces ( ) ) { for Method ( method : intf . getMethods ( ) ) { String sig = JMSRemoteSystem . signature ( method ) ; methods . put ( sig , intf . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ) ; } } } } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "target should implement all of the interfaces provided" , e ) ; } }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public static void main ( String [ ] args ) throws InvalidArgumentException { System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 1 , 1 , 2 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 8 , 8 , 20 , 100 , 100 , 100 , 100 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 4 , 4 , 4 } ) ) ; }
va	REPL	private void initPreGameMenu ( ) { topPanel = new JPanel ( ) ; this . add ( topPanel ) ; middlePanel = new JPanel ( ) ; this . add ( middlePanel ) ; topPanel . setLayout ( new BoxLayout ( topPanel , BoxLayout . LINE_AXIS ) ) ; middlePanel . setLayout ( new BoxLayout ( middlePanel , BoxLayout . LINE_AXIS ) ) ; timerOption = new JCheckBox ( "Timer" , true ) ; middlePanel . add ( timerOption ) ; acceptButton = new JButton ( "START" ) ; acceptButton . addActionListener ( new ActionListener ( ) { @ Override void public actionPerformed ( ActionEvent e ) { setRules ( ) ; getContentPane ( ) . removeAll ( ) ; initGame ( ) ; } } ) ; topPanel . add ( acceptButton ) ; acceptButton . setHorizontalAlignment ( SwingConstants . RIGHT ) ; this . getRootPane ( ) . setDefaultButton ( acceptButton ) ; this . pack ( ) ; this . setInTheMiddle ( ) ; }
va	ORIG	@ Override public < T extends GameObject > T add ( T go ) { bookingObjects . add ( go ) ; return go ; }
va	REPL	@ Test public void testBooleanData ( ) { Command command = CommandFactory . sensor ( 8 ) ; BooleanData response = command . getResponse ( new byte [ ] { 00 } ) ; assertTrue ( response . getFlag ( ) . isPresent ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , false ) ; response = command . getResponse ( new byte [ ] { 01 } ) ; assertTrue ( response . getFlag ( ) . isPresent ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , true ) ; command = CommandFactory . sensor ( 10 ) response ; = command . getResponse ( new byte [ ] { 00 } ) ; assertTrue ( response . getFlag ( ) . isPresent ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , false ) ; response = command . getResponse ( new byte [ ] { 01 } ) ; assertTrue ( response . getFlag ( ) . isPresent ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , true ) ; }
va	REPL	private void list ( Connection conn ) { System . out . println ( "############# list ##########" ) ; QueryUtil qu = qm . createQueryUtil ( "selectAll" ) ; try { qu . setConnection ( conn ) ; qu . executeQuery ( ) ; System . out . println ( "--bean list " ) ; List < User > userList = qu . ( list User . class ) ; System . out . println ( "user list size=" + userList . size ( ) ) ; System . out . println ( userList . get ( 0 ) . getUserName ( ) ) ; qu . executeQuery ( ) ; System . out . println ( "--object list " ) ; List < Object [ ] > objectArrayList = qu . listArray ( ) ; System . out . println ( "array list size=" + objectArrayList . size ( ) ) ; System . out . println ( objectArrayList . get ( 0 ) [ 1 ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { qu . closeJust ( ) ; } }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; setElevation ( getElevation ( ) + getvElevation ( ) ) ; }
va	ORIG	public TextCharacter ( String text , FontDef fontDef ) { this . fontDef = fontDef ; updateText ( text ) ; }
va	REPL	static final public void Entry ( ) throws ParseException { Token t ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SERVICE_NAME : t = jj_consume_token ( SERVICE_NAME ) ; currName = t . image ; break ; case SERVICE_PORT : t = jj_consume_token ( ) SERVICE_PORT ; int port = Integer . parseInt ( t . image . split ( "/" ) [ 0 ] ) ; if ( port < 1024 ) { currProt = t . image . split ( "/" ) [ 1 ] ; if ( currProt . equalsIgnoreCase ( "tcp" ) && tcpServices [ port - 1 ] == null ) { tcpServices [ port - 1 ] = currName ; } else if ( currProt . equalsIgnoreCase ( "udp" ) && udpServices [ port - 1 ] == null ) { udpServices [ port - 1 ] = currName ; } int [ ] portObj = { port } ; portHash . put ( currName , portObj ) ; } break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } }
va	REPL	public void draw ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Composite curComp = g2 . getComposite ( ) ; g2 . setComposite ( composite ) ; g2 . setColor ( color ) ; g2 . fillOval ( ( int ) x , ( int ) y , size , size ) ; g2 . setComposite ( ) curComp ; }
va	REPL	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int ) joinSquadNo throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	REPL	public static boolean anyKeyReleased ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_RELEASED ) return { true ; } } return false ; }
va	REPL	public static void main ( String [ ] args ) { int [ ] array = { 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 1 , 2 } ; System . out . println ( findMinElement ( array ) ) ; int [ ] array2 = { 2 , 3 , 4 , 1 } ; System . out . println ( findMinElement ( array2 ) ) ; int [ ] array3 = { 1 , 2 , 3 , 4 } ; System . out . println ( findMinElement ( array3 ) ) ; int [ ] array4 = { } ; System . out . println ( findMinElement ( array4 ) ) ; int [ ] array5 = { 3 , , 4 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; System . out . println ( findMinElement ( array5 ) ) ; }
va	ORIG	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
va	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; . temp set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public ( ShootingStarCharacter ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ) ; setX ( WIDTH ) ; setY ( HEIGHT ) ; setVx ( - 3 ) ; setVy ( - 2 ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setMoveModeX ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setMoveModeY ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setColor ( Color . yellow ) ; }
va	ORIG	public void move ( ) { if ( Key . UP . isPressing ( ) ) vy -= accele ; if ( Key . DOWN . isPressing ( ) ) vy += accele ; if ( Key . LEFT . isPressing ( ) ) vx -= accele ; if ( Key . RIGHT . isPressing ( ) ) vx += accele ; super . move ( ) ; }
va	ORIG	public ShootingCharacter ( ShootingScene scene , float power , float hp ) { super ( scene , power , hp ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	private void updateDisplay ( ) { Display . update ( ) ; Display . sync ( FPS ) ; Display . setTitle ( "FRAME:" + String . valueOf ( cycleFrame ( ) ) + "FPS:" + floatTo0d0 ( calculatedFPS ) ) ; }
va	ORIG	public void factoryUnit ( Unit u ) { Graphics2D g2 = ( Graphics2D ) this . getGraphics ( ) ; g2 . setColor ( Color . BLACK ) ; g2 . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; if ( u == null ) return ; g2 . drawImage ( ModelManager . getModel ( u . getModelName ( ) ) . getImage ( u . getTeam ( ) ) , 30 , 15 , 50 , 50 , this ) ; g2 . setColor ( Color . LIGHT_GRAY ) ; g2 . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; g2 . drawString ( u . getName ( ) , 100 , 39 ) ; g2 . drawString ( "Land Attack: " + ( u . getLandAttack ( ) ) , 170 , 25 ) ; g2 . drawString ( "Air Attack: " + ( u . getAirAttack ( ) ) , 170 , 50 ) ; g2 . drawString ( "Defense: " + u . getDefense ( ) , 350 , 25 ) ; g2 . drawString ( "Speed: " + u . getShift ( ) , 350 , 50 ) ; }
va	ORIG	public void insertBedList ( List < Bed > beds ) throws SQLException , ServiceLocatorException { Connection con = null ; try { con = services . createConnection ( ) ; for ( Bed bed : beds ) { PreparedStatement stmt = con . prepareStatement ( "insert into beds (hostelId date room bed price state)" + " values (? ? ? ? ? ?);" ) ; stmt . setInt ( 1 , bed . getHostelId ( ) ) ; stmt . setDate ( 2 , new java . sql . Date ( bed . getDate ( ) . getTime ( ) ) ) ; stmt . setInt ( 3 , bed . getRoomNumber ( ) ) ; stmt . setInt ( 4 , bed . getBedNumber ( ) ) ; stmt . setInt ( 5 , bed . getPrice ( ) ) ; stmt . setString ( 6 , bed . getState ( ) . name ( ) ) ; stmt . execute ( ) ; stmt . close ( ) ; } } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } finally { if ( con != null ) { con . close ( ) ; } } }
va	REPL	@ public Override float damage ( float damage ) { if ( undead ) { return float . MAX_VALUE ; } hp -= damage ; if ( hp < 0 ) { hp = 0 ; } return hp ; }
va	REPL	public void updateUniforms ( Matrix4f worldMatrix , Matrix4f projectedMatrix , Material material , Vector3f playerPos ) { if ( material . getTexture ( ) != null ) material . getTexture ( ) . bind ( ) ; else RenderUtil . unbindTextures ( ) ; setUniform ( "transformProjected" , projectedMatrix ) ; setUniform ( "transform" , worldMatrix ) ; setUniform ( "baseColor" , material . getColor ( ) ) ; setUniform ( "ambientLight" , ambientLight ) ; setUniform ( "directionalLight" , directionalLight ) ; for ( int i = 0 ; i < pointLights . length ; i ++ ) setUniform ( "pointLights[" + i + "]" , pointLights [ i ] ) ; for ( int i = 0 ; i < spotLights . length ; i ++ ) setUniform ( "spotLights[" + i + "]" , spotLights [ ] i ) ; setUniformf ( "specularIntensity" , material . getSpecularIntensity ( ) ) ; setUniformf ( "specularPower" , material . getSpecularPower ( ) ) ; setUniform ( "eyePos" , Transform . getCamera ( ) . getPos ( ) ) ; if ( playerPos == null ) playerPos = new Vector3f ( 0 , 0 , 0 ) ; setUniform ( "playerPos" , playerPos ) ; }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public Ball ( int x , int y , int vx , int vy , int size ) { this . x = x ; this . y = y ; this . vx = vx ; this . vy = vy ; this . size = size ; this pong . = Applet . newAudioClip ( getClass ( ) . getResource ( "../mediaResources/pong.wav" ) ) ; this . color = Color . blue ; }
va	REPL	public void draw ( Graphics g ) { g . setColor ( Color . black ) ; g . drawLine ( ( int ) p1 . getX ( ) , ( int ) p1 . getY ( ) , ( int ) p2 . getX ( ) , int ( ) p2 . getY ( ) ) ; }
va	REPL	@ Override public float damage ( damage float ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
va	REPL	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; checkHit ( ; ) updateObjects ( ) ; }
va	ORIG	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
va	REPL	private void gameInfo ( ) { if ( p1 . getPoints ( ) == p2 . getPoints ( ) ) { System . out . println ( "DRAW" ) ; } else if ( p1 . getPoints ( ) > Game . GOAL && p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( "You both fired up" ) ; System . out . println ( " But " + ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ? ) "P2" : "P1" ) + " is closer to " + GOAL ) ; } else if ( p1 . getPoints ( ) > Game . GOAL || p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( ( ( p1 . getPoints ( ) > Game . GOAL ) ? "P2" : "P1" ) + " won this match." ) ; } else { System . out . println ( ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P1" : "P2" ) + "won this match" ) ; } }
va	ORIG	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
va	ORIG	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 2 , 0 , 1 , 0 , 0 , - 1 } , { 0 , 2 , 1 , 0 , 0 , - 1 } , { - 2 , 0 , 1 , 0 , 0 , - 1 } , { 1 , 0 , 1 , 0 , 0 , - 1 } , { 0 , - 1 , 1 , 0 , 0 , - 1 } , { - 1 , 0 , 1 , 0 , 0 , - 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } } ; this . vertices = vertices ; this . faces = faces ; }
va	ORIG	public BallGravity ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; Random rnd = new Random ( ) ; this . color = new Color ( rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) ) ; }
va	REPL	@ Test ( groups = "MaSuite" ) public void parseFile ( ) { try { XmlParams xmlParams = new XmlParams ( ) ; URL url = class . class . getResource ( "/org/jobjects/dbimp/userfilename-asc.xml" ) ; XmlDocument xmld = xmlParams . parseFile ( new File ( url . toURI ( ) ) ) ; StringBuffer sb = new StringBuffer ( ) ; LinkedList < Line > lines = xmld . getLines ( ) ; for ( Line xmlLine lines : ) { sb . append ( xmlLine . getName ( ) + System . lineSeparator ( ) ) ; for ( Field field : xmlLine . getFields ( ) ) { XmlField xmlField = ( XmlField ) field ; sb . append ( "- " + xmlField . getName ( ) + " (" + xmlField . getTypeFormat ( ) + ")" + System . lineSeparator ( ) ) ; } } LOGGER . info ( sb . toString ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	ORIG	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 1 } , { - 1 , 0 , 1 } , { 1 , 0 , 1 } , { 0 , - 1 , 1 } , { - 1 , 0 , 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } , { 3 , 4 , 5 } } ; this . vertices = vertices ; this . faces = faces ; }
va	REPL	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) == ) 0 { return null ; } else { return releasePoints . remove ( 0 ) ; } }
va	REPL	public static long nextGeneration ( long world ) { long nextWorld = 0 ; ( for int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	REPL	private static String reverseWords ( String str ) { String [ ] split = str . split ( " " ) ; int start = 0 ; int end = split . length - 1 ; for ( int i = 0 ; i < split . length ; i ++ ) { if ( ! split [ i ] . isEmpty ( ) ) { start = i ; break ; } } for ( int i = split . length - 1 ; i >= 0 ; i -- ) { if ( ! split [ i ] . isEmpty ( ) ) { end = i ; break ; } } String [ ] newSplit = Arrays . copyOfRange ( split , start , end + 1 ) ; List < String > reverse = new ArrayList < > ( ) ; for ( int i = newSplit . length - 1 ; i >= 0 ; i -- ) { if ( ! newSplit [ i ] . isEmpty ( ) ) reverse { . add ( newSplit [ i ] ) ; } } return reverse . stream ( ) . collect ( Collectors . joining ( " " ) ) ; }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileAsc ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.asc" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.asc" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "ISO-8859-1" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename-asc.xml" ) . toURI ( ) ) . getAbsolutePath ( ) ; boolean cached = false ; boolean verbose = true ; String fileNameReport = File . createTempFile ( "imp" , ".txt" ) . getAbsolutePath ( ) ; LOGGER . fine ( "fileNameReport=" + fileNameReport ) ; Importation . importFile ( fileSource , fileSourceEncoding , fileNameParameter , conn , DerbyConstantes . SCHEMA_NAME , cached , verbose , fileNameReport ) ; assert . assertTrue ( true ; ) } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	REPL	private void nextMove ( int type ) { if ( type == 0 ) { holdable = true ; generateNextTokens ( ; ) } else { currentType = type ; } switch ( currentType ) { case 1 : setPositionForCase1 ( currentTokens , 3 ) ; rotater = new RotaterI ( tokens ) ; break ; case 2 : setPositionForCase2 ( currentTokens , 3 ) ; rotater = new RotaterJ ( tokens ) ; break ; case 3 : setPositionForCase3 ( currentTokens , 3 ) ; rotater = new RotaterL ( tokens ) ; break ; case 4 : setPositionForCase4 ( currentTokens , 3 ) ; rotater = new RotaterO ( tokens ) ; break ; case 5 : setPositionForCase5 ( currentTokens , 3 ) ; rotater = new RotaterS ( tokens ) ; break ; case 6 : setPositionForCase6 ( currentTokens , 3 ) ; rotater = new RotaterT ( tokens ) ; break ; default : setPositionForCase7 ( currentTokens , 3 ) ; rotater = new RotaterZ ( tokens ) ; } if ( checkIsLose ( ) ) { lose ( ) ; return ; } setCurrentTokens ( currentType ) ; setDirectingTokens ( ) ; rotateCount = 0 ; refresh ( ) ; }
va	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	@ public Override void shoot ( ShootingBulletCharacter bullet ) { bullet . setParentScene ( parentScene ) ; parentScene . shoot ( bullet ) ; }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	private boolean isValido ( ) { if ( ( ! tfHost . getText ( ) . equals ( "" ) ) && ( ! tfUsuario . getText ( ) . equals ( "" ) ) && ( pfSenha . getPassword ( ) . length != 0 ) && ( ! snPorta . getValue ( ) . equals ( "" ) ) ) { return true ; } else { lbCampos . setText ( "Os campos em vermelho s\u00E3o obrigat\u00F3rios!" ) ; lbCampos . setVisible ( true ) ; if ( tfHost . getText ( ) . equals ( "" ) ) { tfHost . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( tfUsuario . getText ( ) . equals ( "" ) ) { tfUsuario . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( pfSenha . getPassword ( ) . length == 0 ) { pfSenha . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } return false ; } }
va	ORIG	public void resetSize ( ) { setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; }
va	REPL	public void fieldOfView ( boolean visible ) { Point start = new Point ( player . getLocation ( ) . getColumn ( ) - player . getSightRange ( ) , player . getLocation ( ) getRow . ( ) - player . getSightRange ( ) ) ; for ( int i = 0 ; i < player . getSightRange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getSightRange ( ) * 2 ; j ++ ) { Point target = new Point ( start . x + i , start . y + j ) ; if ( map . boundaryCheck ( target ) ) { if ( lineOfSight ( player , map . getTile ( target ) ) ) { Tile tile = map . getTile ( target ) ; tile . setDiscovered ( true ) ; tile . setVisible ( visible ) ; if ( tile . getOccupant ( ) != null ) tile . getOccupant ( ) . setInSight ( visible ) ; messenger . updateTile ( target ) ; } } } } }
va	ORIG	public final Texture loadTexture ( final String imagePath ) { AlphaBlend . AlphaBlend . config ( ) ; try { return loadTexture ( ImageIO . read ( new FileInputStream ( imagePath ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
va	ORIG	@ Override public List < Placard > getAllPlacard ( ) { conn = DB . getConn ( ) ; try { pstmt = conn . prepareStatement ( "select * from T_Placard" ) ; List < Placard > placardList = new ArrayList < Placard > ( ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { Placard placard = new Placard ( ) ; placard . setPlacardID ( rs . getInt ( 1 ) ) ; placard . setPlacardTitle ( rs . getString ( 2 ) ) ; placard . setPlacardContent ( rs . getString ( 3 ) ) ; placard . setIssueDate ( rs . getDate ( 4 ) ) ; placard . setExpireDate ( rs . getDate ( 5 ) ) ; placard . setCreater ( rs . getString ( 6 ) ) ; placard . setCreateDate ( rs . getDate ( 7 ) ) ; placard . setUpdater ( rs . getString ( 8 ) ) ; placard . setUpdateDate ( rs . getDate ( 9 ) ) ; placardList . add ( placard ) ; } return placardList ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }
va	ORIG	public ShootingObjectImpl ( ShootingScene scene , float power , float hp ) { this . parentScene = scene ; this . power = power ; this . hp = hp ; }
va	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power ) { this ( parentScene , shooter , power , 1 ) ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp set . ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public Vector < Vector < String >> getRevisionInfoTable ( ) { Vector < Vector < String >> revisionData = new Vector < > ( ) ; List < RevisionInfo > revisions = getRevisionInfo ( ) ; Collections . sort ( revisions ) ; logger . debug ( "Found " + revisions . size ( ) + " entries for " + path . toString ( ) ) ; ( for RevisionInfo revision : revisions ) { Vector < String > row = new Vector < String > ( ) ; row . add ( GuiUtility . formatDate ( revision . time ) ) ; row . add ( GuiUtility . humanReadableBytes ( revision . filesize , false ) ) ; if ( revision . delta < 0 ) { row . add ( "<html><span style=\"color: red;\">" + GuiUtility . humanReadableBytes ( revision . delta , false ) ) ; } else if ( revision . delta > 0 ) { row . add ( "<html><span style=\"color: green;\">+" + GuiUtility . humanReadableBytes ( revision . delta , false ) ) ; } else { row . add ( "<html><span style=\"color: gray;\">" + GuiUtility . humanReadableBytes ( revision . delta , false ) ) ; } revisionData . add ( row ) ; } return revisionData ; }
va	REPL	@ Override public void rotateY ( double radians ) for { ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && getDisposeTimer ( ) % ( FPS / 4 ) == 0 ) { shoot ( new Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
va	REPL	@ Override public void disposeAfter ( float seconds ) { disposeTimer = ( int ) ( FPS * seconds ; ) }
va	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char ; c int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	ORIG	public String addBinary ( String a , String b ) { StringBuilder builder = new StringBuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charAt ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charAt ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . toString ( ) ; }
va	ORIG	@ Override public void render ( ) { glLoadIdentity ( ) ; setTranslate ( this ) ; setGlColor4f ( getColor ( ) , 1f ) ; glRotatef ( ( float ) jitenAngle , 0 , 0 , 1 ) ; drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; }
va	ORIG	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
va	ORIG	int binarySearchRotated ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( A [ start ] <= A [ mid ] ) { if ( target >= A [ start ] && target < A [ mid ] ) return binarySearch ( A , target , start , mid - 1 ) ; else return binarySearchRotated ( A , target , mid + 1 , end ) ; } else { if ( target > A [ mid ] && target <= A [ end ] ) return binarySearch ( A , target , mid + 1 , end ) ; else return binarySearchRotated ( A , target , start , mid - 1 ) ; } }
va	REPL	protected JPanel getFontStylePanel ( ) { if ( fontStylePanel == null ) { fontStylePanel = new JPanel ( ) ; fontStylePanel . setLayout ( new BorderLayout ( ) ) ; fontStylePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; fontStylePanel . setPreferredSize ( new Dimension ( 140 , 130 ) ) ; JScrollPane scrollPane = new JScrollPane ( getFontStyleList ) ( ) ; scrollPane . getVerticalScrollBar ( ) . setFocusable ( false ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( getFontStyleTextField ( ) , BorderLayout . NORTH ) ; p . add ( scrollPane , BorderLayout . CENTER ) ; JLabel label = new JLabel ( ( "Font Style" ) ) ; label . setHorizontalAlignment ( JLabel . LEFT ) ; label . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontStyleTextField ( ) ) ; label . setDisplayedMnemonic ( Y ) ; fontStylePanel . add ( label , BorderLayout . NORTH ) ; fontStylePanel . add ( p , BorderLayout . CENTER ) ; } return fontStylePanel ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = boolean . parseBoolean ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
va	REPL	public void moveDown ( boolean isUserTriggered ) { if ( || freezing ! isGameOn ) { return ; } if ( ! checkMovable ( "DOWN" ) ) { for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] ; int y = currentTokens [ i ] [ 1 ] ; tokens [ y ] [ x ] . setFrozen ( true ) ; } if ( ! checkBlowLines ( ) ) { placeTokenWithFlash ( ) ; nextMove ( 0 ) ; setChanged ( ) ; notifyObservers ( "Place" ) ; } return ; } setCurrentTokens ( 0 ) ; if ( isUserTriggered ) { increaseScore ( 1 ) ; setChanged ( ) ; notifyObservers ( "Move" ) ; } for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] ; int y = currentTokens [ i ] [ 1 ] + 1 ; tokens [ y ] [ x ] . setType ( currentType ) ; currentTokens [ i ] [ 1 ] = y ; } refresh ( ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	REPL	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x >= 0 ) && ( x < width ) ) && ( ( y >= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] == MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] MapTile != . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
va	ORIG	public ArrayList < Integer > grayCode ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; ArrayList < Integer > codes = init ( n ) ; result . add ( 0 ) ; Set < ArrayList < Integer >> cache = new HashSet < ArrayList < Integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; while ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { ArrayList < Integer > newCodes = changeOneBit ( codes , i ) ; if ( cache . contains ( newCodes ) ) { i -- ; } else { codes = newCodes ; cache . add ( codes ) ; result . add ( codesToNumber ( codes ) ) ; break ; } } } return result ; }
va	ORIG	private double getMinIntensity ( ) throws ValidationException { String minAbsIntensityText = this . minAbsIntTextField . getText ( ) ; String message ; double minInt = 0.0 ; if ( minAbsIntensityText . trim ( ) . length ( ) == 0 ) { minAbsIntensityText = this . minPercIntTextField . getText ( ) ; if ( minAbsIntensityText . trim ( ) . length ( ) == 0 ) { message = "Please fill in a minimum intensity value." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } else { try { minInt = double . parseDouble ( minAbsIntensityText ) ; if ( minInt < 0 || minInt > 100 ) { message = "The peak intensity need to be between " + "0 to 100% of the maximum peak intensity" ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } this . absMinIntensity = false ; return minInt ; } catch ( NumberFormatException ne ) { message = "The minimum intensity value" + minAbsIntensityText + " cannot be parsed as a valid number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } } } else { try { minInt = double . parseDouble ( minAbsIntensityText ) ; this . absMinIntensity = true ; return minInt ; } catch ( NumberFormatException ne ) { message = "The minimum intensity value" + minAbsIntensityText + "cannot be parsed as a valid number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } } }
va	REPL	@ Test public void testSetFieldValue ( ) throws Exception { ReflectInfo info = ReflectUtil . buildReflectInfo ( User . class ) ; final double amountNew = amountOld + 100 ; final String idNew = idOld + "new" ; final String userNameNew = userNameOld + "new" ; final Timestamp createdNew = new Timestamp ( 2000 ) ; info . setFieldValue ( 0 , u , amountNew ) ; assertEquals ( amountNew , u . getAmount ( ) . doubleValue ( ) , 0 ) ; info . setFieldValue ( 3 , u , idNew ) ; assertEquals ( idNew , u . getId ( ) ) ; info . setFieldValue ( 5 , u , userNameNew ) ; assertEquals ( userNameNew , u . getUserName ( ) ) ; info . ( setFieldValue 1 , u , createdNew ) ; assertEquals ( createdNew , u . getCreated ( ) ) ; }
va	ORIG	public ShootingEffectCharacter ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter , 0 ) ; disposeAfter ( getLifeTime ( ) ) ; setTeam ( TEAM . NO_TEAM ) ; }
va	ORIG	public void mouseMoved ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
va	ORIG	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	REPL	public void draw ( Graphics g { ) for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { Rain rain = it . next ( ) ; if ( rain . isEnd ( length ) ) { it . remove ( ) ; continue ; } rain . draw ( g , speed , nabiki , length ) ; } }
va	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . isPressed ( ) ) { setScale ( getScale ( ) * 2 ) ; } if ( Key . DOWN . isPressed ( ) ) { setScale ( getScale ( ) / 2 ) ; } if ( Key . LEFT . isPressed ( ) ) { setAngle ( getAngle ( ) + 5f ) ; } if ( Key . RIGHT . isPressed ( ) ) { setAngle ( getAngle ( ) - 5f ) ; } }
va	ORIG	public void mouseDragged ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	Dimension getLayoutSize ( Container target , boolean doPreferred ) { Dimension dim = new Dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getComponentCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Component component = target . getComponent ( i ) ; if ( component . isVisible ( ) ) { Rectangle r = getComponentBounds ( component , doPreferred ) ; dim . width = Math . max ( dim . width , r . x + r . width ) ; dim . height = Math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
va	ORIG	public static void main ( String [ ] args ) { int intAngle = 180 - 60 ; int size = 100 ; Turtle turtle = new Turtle ( ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; java . awt . geom . Point2D . double pos1 = turtle . getPos ( ) ; turtle . penUp ( ) ; for ( int i = 0 ; i < 300 ; i ++ ) { turtle . forward ( 1 ) ; turtle . left ( 1 ) ; } turtle . penDown ( ) ; java . awt . geom . Point2D . double pos2 = turtle . getPos ( ) ; turtle . right ( 90 ) ; turtle . forward ( distance ( pos1 , pos2 ) ) ; for ( int i = 0 ; i < 360 ; i ++ ) { turtle . forward ( 1 ) ; turtle . left ( 1 ) ; } }
va	REPL	public void linkRoom ( Map linkMap ) { Point stair1 = STAIR_POINT ; Point stair2 ; Rectangle [ ] rooms2 = linkMap . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( linkMap . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( linkMap . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) == true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } this . map . setTile ( . stair1 x , stair1 . y , new StairTile ( this . map , linkMap , stair1 , stair2 , true ) ) ; linkMap . setTile ( stair2 . x , stair2 . y , new StairTile ( linkMap , this . map , stair2 , stair1 ) ) ; }
va	REPL	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 1 1 , ) ; temp . set ( 0 , 2 , Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public TestEnemyShip ( ShootingScene scene ) { super ( scene , 1 ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "DotTokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( HEIGHT - getHeight ( ) ) ; setColor ( new Color ( 1f , 0.6f , 0.6f ) ; ) setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
va	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	REPL	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W H , , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	REPL	public ScreenShotCharacter ( ) { setTexture ( new TextureLoader ( ) . getScreenShot ( ) ) ; setWidth ( WIDTH ) ; setHeight ( HEIGHT ) ; setX ( CENTER_X ) setY ; ( CENTER_Y ) ; }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileCsvAll ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "UTF-8" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv.xml" ) . toURI ( ) ) . getAbsolutePath ( ) ; boolean cached = false ; boolean verbose = true ; String fileNameReport = File . createTempFile ( "imp" , ".txt" ) . getAbsolutePath ( ) ; LOGGER . fine ( "fileNameReport=" + fileNameReport ) ; Importation . importFile ( fileSource , fileSourceEncoding , fileNameParameter , conn , DerbyConstantes . SCHEMA_NAME , , cached verbose , fileNameReport ) ; assert . assertTrue ( true ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	REPL	private static void addMonstersRoom ( MapGenerator map , Map newMap , Rectangle room , int tier , int count ) { Rectangle placement = MapRand . innerRectangle ( room ) ; for ( int i = 0 ; i < count ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; ( while ( ( map . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) ) continue ; Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( tier ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } }
va	REPL	public static Holdable createHoldableFromReader ( String itemString ) { String [ ] values = itemString . split ( " " ) ; Holdable item = new Holdable ( ) ; try { item . setName ( values [ 0 ] ) ; item . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; item . setWeight ( Integer . parseInt values ( [ 2 ] ) ) ; if ( values . length == 4 && values [ 3 ] != "" ) { String [ ] specials = values [ 3 ] . split ( " " ) ; item = Holdable . applySpecialTraits ( item , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading misc object" ) ; if ( item . getName ( ) != null ) System . out . println ( item . getName ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
va	REPL	private static Font createFont ( FontDef fontDef ) { try { InputStream is = new FileInputStream ( fontDef . filePath ) ; return Font . createFont ( Font . TRUETYPE_FONT , is ) . deriveFont ( fontDef . size ) } ; catch ( FontFormatException | IOException e ) { e . printStackTrace ( ) ; return null ; } }
va	ORIG	public void userCreate ( String userName , String password , String firstName , String lastName , String patronymic ) { String email = userName + "@email.local" ; String code = "123456" ; String addDate = "" ; String editDate = "" ; String ip = "ip" ; long approved = new long ( 1 ) ; long status = new long ( 1 ) ; long group = new long ( 1 ) ; User user = new User ( ) ; user . setUserName ( userName ) ; user . setPassword ( password ) ; user . setFirstName ( firstName ) ; user . setLastName ( lastName ) ; user . setPatronymic ( patronymic ) ; user . setEmail ( email ) ; user . setCode ( code ) ; user . setCreatedDate ( new Date ( ) ) ; user . setEditDate ( new Date ( ) ) ; user . setCreatedBy ( "zzz" ) ; user . setEditBy ( "zzz" ) ; user . setIp ( ip ) ; user . setApproved ( approved ) ; user . setUserStatusId ( status ) ; user . setGroupId ( group ) ; userDAO . add ( user ) ; }
va	ORIG	@ Override public void run ( ) { long before = 0 ; long after = 0 ; long delta = 0 ; long sleep = 0 ; long overSleep = 0 ; long fpsDelta = 0 ; int fpsCounter = 0 ; int delays = 0 ; fps = 1e9f / sleepTime ; isRunning = true ; while ( isRunning ) { before = System . nanoTime ( ) ; engine . update ( delta ) ; engine . render ( ) ; after = System . nanoTime ( ) ; sleep = ( sleepTime - ( after - before ) ) - overSleep ; if ( sleep > 0 ) { EngineUtilities . sleepNanos ( sleep ) ; overSleep = ( System . nanoTime ( ) - after ) - sleep ; } else { overSleep = 0 ; if ( ++ delays >= delaysPerYield ) { delays = 0 ; Thread . yield ( ) ; } } delta = System . nanoTime ( ) - before ; fpsCounter ++ ; fpsDelta += delta ; while ( fpsDelta >= fpsUpdateTime ) { fpsDelta -= fpsUpdateTime ; fps = fpsCounter * ( 1e9f / fpsUpdateTime ) ; fpsCounter = 0 ; } } }
va	ORIG	public static Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . intVal == intVal ) { return key ; } } return null ; }
va	REPL	public Ball launch ( Point point , int size ) { p2 = point ; return new BallGravity ( p1 . x - size / 2 , p1 . y - size / 2 , ( int ) ( p1 . getX ( ) - p2 . getX ( ) ) / 3 , ( int ) ( p1 . getY ) ( - p2 . getY ( ) ) / 3 , size ) ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
va	REPL	@ Override public String getValue ( String ligne ) { String returnValue = null ; switch ( filetype ) { case FILE_TEXT : returnValue = StringUtils . substring ( ligne , getStartposition ( ) , getStartposition ( ) + getSize ( ) ) ; break ; case FILE_CSV : String separatorChar = StringUtils . defaultString ( separateur , " " ) ; String [ ] champs = StringUtils . split ( ligne , separatorChar ) ; returnValue = champs [ getStartposition ( ) ] ; break ; default : StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Type de fichier :" ) . append ( filetype ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Startposition" ) . append ( getStartposition ( ) ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Size" ) . append ( getSize ( ) ) . append ( System . lineSeparator ( ) ) ; sb append . ( "Ligne :" ) . append ( ligne ) ; throw new IllegalArgumentException ( sb . toString ( ) ) ; } return returnValue ; }
va	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ) ( ; } }
va	REPL	public static HashMap < String , Integer > sortByValue ( Map < String , Integer > map ) { List < Map . Entry < String , Integer >> list = new LinkedList < Map . Entry < String , Integer >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < String , Integer >> ( ) { public int compare ( Map . Entry < String , Integer > m1 , Map . Entry < String , Integer > m2 ) { int res = m2 . getValue ( ) . compareTo ( m1 . getValue ( ) ) ; if ( res == 0 ) res = m1 . getKey ( ) . compareTo ( m2 . getKey ( ) ) ; return res ; } } ) ; Map < String , Integer > result = new LinkedHashMap < String , Integer > ( ) ; for ( Map . Entry String < , Integer > entry : list ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ( HashMap < String , Integer > ) result ; }
va	REPL	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get world ( , ( col + row * 8 ) ) ; return tmp ; } }
va	REPL	@ Override public void update ( ) { thita += 1 / ( float ) FPS ; setX ( CENTER_X + 100 * ( float ) sin ( thita ) ) ; setY ( CENTER_Y + 100 * ( float ) cos ( thita ) ) ; damageUpdate ( ) ; super . update ) ( ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public static void print ( long world ) { System . out . println ( ) "-" ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	ORIG	@ Override public void update ( ) { changeSceneIfNotNull ( SceneCollection . scanChangeScene ( ) ) ; currentScene . update ( ) ; }
va	REPL	public void insert ( char x ) { hp . add ( x ) ; for ( int i = hp . size ( ) - 1 ; x > hp . get ( ( i - 1 ) / 2 ; ) i = ( i - 1 ) / 2 ) { hp . set ( i , hp . get ( ( i - 1 ) / 2 ) ) ; hp . set ( ( i - 1 ) / 2 , x ) ; } }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	REPL	public ShootingObjectImpl ( ShootingScene scene , float power ) { this . parentScene scene = ; this . power = power ; this . undead = true ; }
va	REPL	public static void main ( String [ ] args ) { char c ; MaxHeap h = new MaxHeap ( h "CAMBRIDGEALGORITHMS" , ) ; c = h . getMax ( ) ; System . out . println ( c ) ; h . insert ( Z ) ; h . insert ( A ) ; c = h . getMax ( ) ; System . out . println ( c ) ; c = h . getMax ( ) ; System . out . println ( c ) ; }
va	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 z , ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	REPL	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && c <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( != i 0 && ( ! exp || s . charAt ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
va	ORIG	@ Override public void dispose ( ) { addBookingObjects ( ) ; for ( GameObject go : gameObjects ) { go . dispose ( ) ; } }
va	ORIG	public Path getRevisionInfo ( long timestamp ) { DbConnection db = DbConnection . getInstance ( ) ; RevisionInfo revision = db . getSpecificRevision ( file , timestamp ) ; Path pathToTempFile = null ; PrintWriter output = null ; String [ ] fileNameSplit = file . getFileName ( ) . toString ( ) . split ( "\\." ) ; String extension = fileNameSplit [ fileNameSplit . length - 1 ] ; if ( fileNameSplit . length > 1 ) { extension = "." + extension ; } try { pathToTempFile = Files . createTempFile ( "revision" , "." + extension ) ; if ( revision . diff != null ) { Files . write ( pathToTempFile , revision . diff . getBytes ( ) ) ; } else { Files . write ( pathToTempFile , revision . binary ) ; } logger . info ( "Created temporary file at " + pathToTempFile . toString ( ) + " for revision " + file . toString ( ) + " (" + timestamp + ")" ) ; } catch ( IOException e ) { Errors . nonfatalError ( "Could not create temporary file for revision." , e ) ; } finally { if ( output != null ) { output . close ( ) ; } } return pathToTempFile ; }
va	ORIG	public StarCharacter ( StarCharacter parentStar , String caption , float scale , Color color , double koten , double jiten ) { this . parentStar = parentStar ; setTexture ( TextTextureMaker . createText ( caption , FontDef . RICTY_48 ) ) ; setScale ( scale ) ; setColor ( color ) ; this . kotenSpeed = koten ; this . jitenSpeed = jiten ; }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; remainRange -= sqrt ( pow ( getVX ( ) , 2 ) + pow ( getVY ( ) , 2 ) ) ; if ( remainRange <= 0 ) { setDispose ( ) ; } }
va	REPL	public String ( disListSearch ) { String patientId = "" ; String diagnoseDate = "" ; String department = "" ; String patientName = "" ; String userName = "" ; String id = "" ; String str = "select u.user_name p.patient_id pc.id pc.diagnose_date u.department p.patient_name  from user u patient p patient_case pc where pc.status=2 and pc.patient_id=p.patient_id and pc.bydoctor_id=u.user_id order by pc.diagnose_date desc;" ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { patientId = num . getString ( "patient_id" ) ; diagnoseDate = num . getString ( "diagnose_date" ) ; department = num . getString ( "department" ) ; patientName = num . getString ( "patient_name" ) ; userName = num . getString ( "user_name" ) ; id = num . getString ( "id" ) ; sb . append ( " <tr> <td>" + diagnoseDate + "</td><td>" + department + "</td><td><a href=\"diseaseDetail.jsp?patientId=" + patientId + "&id=" + id + "\">" + patientName + "</a></td> <td>" + userName + "</td></tr> " ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
va	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set 1 ( , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	protected void setNull ( PreparedStatement pstmt , int i , Field field ) throws SQLException { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; break ; case INTEGER : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case long : pstmt . setNull ( i , java . sql . Types INTEGER . ) ; break ; case float : pstmt . setNull ( i , java . sql . Types . float ) ; break ; case double : pstmt . setNull ( i , java . sql . Types . double ) ; break ; case DATETIME : pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; break ; case BLOB : pstmt . setNull ( i , java . sql . Types . BLOB ) ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
va	ORIG	public final Texture getScreenShot ( ) { glReadBuffer ( GL_FRONT ) ; int width = WINDOW_WIDTH ; int height = WINDOW_HEIGHT ; int bpp = 4 ; ByteBuffer buffer = BufferUtils . createByteBuffer ( width * height * bpp ) ; glReadPixels ( 0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE , buffer ) ; return loadTexture ( buffer , width , height ) ; }
va	REPL	public RotateShootingCharacter ( ShootingScene scene , float power , float hp ) { super ( , scene power , hp ) ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; . this rightMultiply ( temp ) ; }
va	REPL	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this rightMultiply . ( temp ) ; }
va	REPL	private void initMenu ( ) { JPanel titlePanel = new JPanel ( ) ; this . add ( titlePanel ) ; JLabel title = new JLabel ( "Card Counting Training" ) ; titlePanel . add ( title ) ; JPanel inputPanel = new JPanel ( ) ; this . add ( inputPanel ) ; input = new JTextField ( 2 ) ; input . setText ( "6" ) ; inputPanel . add ( input ) ; JPanel startPanel = new JPanel ( ) ; this . add ( startPanel ) ; JButton startBtn = new JButton ( "START" ) ; getRootPane ( ) . setDefaultButton ( startBtn ) ; . startPanel add ( startBtn ) ; startBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { game . runGame ( byte . parseByte ( input . getText ( ) ) ) ; } catch ( Exception ex ) { game . runGame ( ( byte ) 6 ) ; } finally { initGameForm ( ) ; } } } ) ; this . pack ( ) ; setInTheMiddle ( ) ; }
va	ORIG	@ Override public int compareTo ( Text other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = boolean . valueOf ( isSetOrignalText ( ) ) . compareTo ( other . isSetOrignalText ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetOrignalText ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . orignalText , other . orignalText ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetCleanText ( ) ) . compareTo ( other . isSetCleanText ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetCleanText ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . cleanText , other . cleanText ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
va	REPL	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == null ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else { setTranslate ( * . parentStar ) ; ( glRotatef ( float ) * . kotenAngle , 0 , 0 , 1 ) ; glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; glRotatef ( ( float ) - * . kotenAngle , 0 , 0 , 1 ) ; } }
va	ORIG	@ Override public void disable ( ) { enable = false ; hide ( ) ; setVx ( 0 ) ; setVy ( 0 ) ; setVAlpha ( 0 ) ; setVScale ( 0 ) ; }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	@ Override public int compareTo ( Location other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = boolean . valueOf ( isSetLatitude ( ) ) . compareTo ( other . isSetLatitude ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetLatitude ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . latitude , other . latitude ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetLongitude ( ) ) . compareTo ( other . isSetLongitude ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetLongitude ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . longitude , other . longitude ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
va	ORIG	protected JPanel getFontFamilyPanel ( ) { if ( fontNamePanel == null ) { fontNamePanel = new JPanel ( ) ; fontNamePanel . setLayout ( new BorderLayout ( ) ) ; fontNamePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; fontNamePanel . setPreferredSize ( new Dimension ( 180 , 130 ) ) ; JScrollPane scrollPane = new JScrollPane ( getFontFamilyList ( ) ) ; scrollPane . getVerticalScrollBar ( ) . setFocusable ( false ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( getFontFamilyTextField ( ) , BorderLayout . NORTH ) ; p . add ( scrollPane , BorderLayout . CENTER ) ; JLabel label = new JLabel ( ( "Font Name" ) ) ; label . setHorizontalAlignment ( JLabel . LEFT ) ; label . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontFamilyTextField ( ) ) ; label . setDisplayedMnemonic ( F ) ; fontNamePanel . add ( label , BorderLayout . NORTH ) ; fontNamePanel . add ( p , BorderLayout . CENTER ) ; } return fontNamePanel ; }
va	REPL	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * ) j ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	REPL	public void mouseReleased ( final MouseEvent e ) { releasePoints . add ( new Point ( e . getX ( ) / , 2 e . getY ( ) / 2 ) ) ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp set . ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public void setZeroes ( int [ ] [ ] matrix ) { Set < Integer rows > = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] == 0 ) { rows . add ( i ) ; cols . add ( j ) ; } } } for ( int r : rows ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { matrix [ r ] [ j ] = 0 ; } } for ( int c : cols ) { for ( int j = 0 ; j < matrix . length ; j ++ ) { matrix [ j ] [ c ] = 0 ; } } }
va	REPL	public Dragon ( ) { name = "Dragon" ; Normal normal = new Normal ( 0 ) ; Fighting fighting = new Fighting ( 0 ) ; Flying flying = new Flying ( 0 ) ; Poison poison = new Poison ( 0 ) ; Ground ground = new Ground ( 0 ) ; Rock rock = new Rock ( 0 ) ; Bug bug = new Bug ( 0 ) ; Steel = steel new Steel ( 0 ) ; Fire fire = new Fire ( 0 ) ; Water water = new Water ( 0 ) ; Grass grass = new Grass ( 0 ) ; Electric electric = new Electric ( 0 ) ; Psychic psychic = new Psychic ( 0 ) ; Ice ice = new Ice ( 0 ) ; Dragon dragon = new Dragon ( 0 ) ; Dark dark = new Dark ( 0 ) ; Ghost ghost = new Ghost ( 0 ) ; effectiveTypes = new Type [ 1 ] ; effectiveTypes [ 0 ] = dragon ; resistantTypes = new Type [ 1 ] ; resistantTypes [ 0 ] = steel ; immuneTypes = new Type [ 0 ] ; }
va	ORIG	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p != null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p != null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev != null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
va	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	ORIG	public void mousePressed ( final MouseEvent e ) { pressPoints . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
va	REPL	@ Override public void render ( ) { for ( GameObject go : gameObjects ) { go . render ( ) } ; }
va	REPL	public static create Texture ( String str , Color color , FontDef fontDef ) { Font font = FontCollector . getFont ( fontDef ) ; float width = ( fontDef . size / 2 ) * getByteLength ( str ) ; float height = fontDef . size ; return createText ( str , color , font , width , height ) ; }
va	ORIG	private BackGroundColor ( float red , float green , float blue , float alpha ) { this . red = red ; this . green = green ; this . blue = blue ; this . alpha = alpha ; }
va	ORIG	public static void main ( String [ ] args ) { Sample ex = new Sample ( ) ; Connection conn = null ; try { ex . init ( ) ; ex . testSQL ( ) ; ex . testSubSQL ( ) ; conn = ex . getConnection ( ) ; ex . deleteAll ( conn ) ; ex . select ( conn ) ; ex . insertIfEmpty ( conn ) ; ex . select ( conn ) ; ex . basicSelect ( conn ) ; ex . list ( conn ) ; ex . select ( conn ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "me" , 1 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 1000 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 2 ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; } QueryUtil . closeConnection ( conn ) ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( ) radians ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	REPL	private JSONObject readObject ( ) throws JSONException { JSONObject result = new JSONObject ( ) ; int first = nextCleanInternal ( ) ; if ( first == } ) { return result ; } else if ( first != - 1 ) { pos -- ; } while ( true ) { Object name = nextValue ( ) ; if ( ! ( name instanceof String ) ) { if ( name == null ) { throw syntaxError ( "Names cannot be null" ) ; } else { throw syntaxError ( "Names must be strings  but " + name + " is of type " + name . getClass ( ) . getName ( ) ) ; } } int separator = nextCleanInternal ( ) ; if ( separator != : && separator != = ) { throw syntaxError ( "Expected ':' after " + name ) ; } if ( pos < in . length ( ) && in . charAt ( pos ) == > ) { pos ++ ; } result . put ( ( String ) name , nextValue ( ) ) ; switch ( nextCleanInternal ( ) ) { case } : return result ; case ; : case   : continue ; default : throw syntaxError ( "Unterminated object" ) ; } } }
va	ORIG	public void drawMap ( Map map ) { clearDisplay ( ) ; this . currentMap = map ; for ( int i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getHeight ( ) ; j ++ ) { drawTile ( map . getTile ( i , j ) . getBackground ( ) , i , j ) ; if ( currentMap . getTile ( i , j ) . isVisible ( ) ) { drawTile ( map . getTile ( i , j ) . getTopItemImage ( ) , i , j ) ; drawTile ( map . getTile ( i , j ) . getOccupantImage ( ) , i , j ) ; } } } this . width = map . getWidth ( ) * TILE_SIZE ; this . height = map . getHeight ( ) * TILE_SIZE ; this . setPreferredSize ( new java . awt . Dimension ( width , height ) ) ; repaintSuper ( ) ; }
va	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public void setFaces ( ) { for ( int i = 0 ; i < m i ; ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	REPL	public static GameSceneManager getInstance ( ) { if ( null == instance ) instance { = new GameSceneManager ( ) ; } return instance ; }
va	ORIG	@ Override public void hit ( K key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } Node < K > previous = findPrevious ( key ) ; if ( previous == null ) { Node < K > toInsert = new Node < K > ( ) ; toInsert . content = key ; toInsert . next = head . next ; head . next = toInsert ; if ( lru == head ) { lru = toInsert ; } } else { Node < K > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
va	REPL	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * ) 8 , value ) ; return tmp ; } }
va	ORIG	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
va	ORIG	public ShootingWeaponCharacter ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , 0f ) ; this . owner = owner ; this . equipLR = equipLR ; this . remainBullet = getMaxCharge ( ) ; }
va	REPL	public static float random ( final float min , final float max ) float { dist = max - min ; return ( float ) ( Math . random ( ) * dist + min ) ; }
va	ORIG	public DotTestCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "dotTokiIcon.png" ) ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; setColor ( Color . red ) ; }
va	ORIG	public void moveRandomly ( Sentient s ) { ArrayList < Point > directions = new ArrayList < Point > ( 4 ) ; Tile location = s . getLocation ( ) ; if ( location . getRow ( ) > 0 ) directions . add ( new Point ( 0 , - 1 ) ) ; if ( location . getRow ( ) < map . getHeight ( ) - 1 ) directions . add ( new Point ( 0 , 1 ) ) ; if ( location . getColumn ( ) < map . getWidth ( ) - 1 ) directions . add ( new Point ( 1 , 0 ) ) ; if ( location . getColumn ( ) > 0 ) directions . add ( new Point ( - 1 , 0 ) ) ; int random = MapRand . randInt ( directions . size ( ) - 1 ) ; moveSentient ( s , directions . get ( random ) . x , directions . get ( random ) . y ) ; }
va	REPL	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 0 , 0 , 0 , - 1 } , { 0 , 1 , 0 , 0 , 0 , - 1 } , { - 1 , 0 , 0 , 0 , 0 , - 1 } , { 1 , 0 1 , , 0 , 0 , - 1 } , { 0 , - 1 , 1 , 0 , 0 , - 1 } , { - 1 , 0 , 1 , 0 , 0 , - 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } } ; this . vertices = vertices ; this . faces = faces ; }
te	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
te	REPL	@ Override public SiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { model SiteStatModel = new SiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setHour ( new DateTime ( rs . getLong ( "hour" ) ) ) ; model . setVideo ( rs . getInt ( "video" ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
te	ORIG	protected void makeActions ( IWorkbenchWindow window ) { register ( ActionFactory . QUIT . create ( window ) ) ; register ( ActionFactory . OPEN_NEW_WINDOW . create ( window ) ) ; register ( ActionFactory . EDIT_ACTION_SETS . create ( window ) ) ; register ( ActionFactory . PREFERENCES . create ( window ) ) ; register ( ActionFactory . SAVE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . RESET_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_ALL_PERSPECTIVES . create ( window ) ) ; IWorkbenchAction help = ActionFactory . DYNAMIC_HELP . create ( window ) ; help . setText ( Messages . App_Action_Help ) ; register ( help ) ; IWorkbenchAction intro = ActionFactory . INTRO . create ( window ) ; intro . setText ( Messages . App_Action_Intro ) ; register ( intro ) ; IWorkbenchAction about = ActionFactory . ABOUT . create ( window ) ; about . setText ( Messages . App_Action_About ) ; register ( about ) ; }
te	ORIG	@ Override public void run ( ) { ReferenceQueue < byte [ ] > q = new ReferenceQueue < byte [ ] > ( ) ; SoftReference < byte [ ] > r = new SoftReference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { System . out . println ( " +++ Trying to remove" ) ; q . remove ( ) ; System . out . println ( " +++ removed" ) ; } catch ( InterruptedException e ) { System . out . println ( "----------------> Interrupted" ) ; return ; } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; }
te	REPL	@ Test public void testTransitions ( ) { ReplacementStrategy < String > topK = new TopK String < > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "3" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value } ; }
te	REPL	public static boolean isInsideTriangle ( double aX , double aY , double bX , double bY , double cX , double cY , double pX , double pY ) { double ax , ay , bx , by , cx , cy , apx , apy , bpx , bpy , cpx , cpy ; double cCROSSap , bCROSScp , aCROSSbp ; ax = cX - bX ; ay = cY - bY ; bx = aX - cX ; by = aY - cY ; cx = bX - aX ; cy = bY - aY ; apx = pX - aX ; apy = pY - aY ; bpx = pX - bX ; bpy = pY - bY ; cpx = pX - cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx cpy * - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
te	REPL	final private void convertToPostfix ( ) { for ( Token t : this . m_tokenizedExpression ) { if ( t instanceof Function ) { handleFunction ( ( Function ) t ) ; } else if ( t instanceof Operator ) { handleOperator ( ( Operator ) t ) ; } else if ( t instanceof Value ) { addToOutput ( t ) ; } else if ( t instanceof OpenParenthesis ) { handleOpenParen ( ( OpenParenthesis ) t ) ; } else if ( t instanceof CloseParenthesis ) { handleCloseParen ( ( CloseParenthesis ) t ) ; } else if ( t instanceof , ) { handleComma ( ( , ) t ) ; } else if ( t instanceof Value ) { addToOutput ( t ) ; } else { throw new RuntimeException ( Text . Calculate . UNRECOGNIZED_EXPRESSION_ERROR + t . getRepresentation ( ) ) ; } } while ( this . m_operatorsStack . size ( ) > 0 ) { if ( this . m_operatorsStack . peek ( ) instanceof OpenParenthesis ) { throw new RuntimeException Text ( . Calculate . MISMATCHED_PARENTHESES_ERROR ) ; } addToOutput ( this . m_operatorsStack . pop ( ) ) ; } }
te	REPL	protected void resize ( ) { inResize = true ; Object [ ] oldKeys = keys ; Object [ ] oldValues = values ; keys = new Object [ oldKeys . length * 2 ] ; values = new Object [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ++ ) { K key = ( K ) oldKeys [ i ] ; if ( key == null || key == Tombstone ) { continue ; } put ( key , ( V ) oldValues [ i ] ) } ; inResize = false ; }
te	REPL	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ) { double hiPrec [ ] = new double [ 2 ] ; final double lores = log ( xpa , hiPrec ) ; if ( double . isInfinite ( lores ) ) { return lores ; } double fx1 = xpb / xpa ; double epsilon 0.5 = * fx1 + 1.0 ; epsilon = epsilon * fx1 ; return epsilon + hiPrec [ 1 ] + hiPrec [ 0 ] ; } double y = x * 0.333333333333333 - 0.5 ; y = y * x + 1.0 ; y = y * x ; return y ; }
te	REPL	private static void createDisplay ( ) { try { Display . setDisplayMode ( new ( DisplayMode WINDOW_WIDTH , WINDOW_HEIGHT ) ) ; Display . setTitle ( PRODUCT_TITLE ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; } }
te	REPL	protected void resize ( ) { inResize = true ; String [ ] oldKeys = keys ; long [ ] oldValues = values ; keys = new String [ oldKeys . length * 2 ] ; values = new long [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ) ++ { String key = oldKeys [ i ] ; if ( key == null || key == Tombstone ) { continue ; } put ( key , oldValues [ i ] ) ; } inResize = false ; }
te	ORIG	@ Override public void run ( ) { CountDownLatch latch = null ; long lastExtraRequestTime = 0 ; try { while ( fetchStatus ) { if ( System . currentTimeMillis ( ) - lastExtraRequestTime >= EXTRA_INFO_DELAY ) { lastExtraRequestTime = System . currentTimeMillis ( ) ; latch = new CountDownLatch ( 3 ) ; sendRequest ( new ReportTemperatureCommand ( ) , createTemperatureListener ( latch ) ) ; } else latch = new CountDownLatch ( 2 ) ; sendRequest ( new ReportStatusCommand ( ) , createStatusListener ( latch ) ) ; sendRequest ( new ReportActualPositionCommand ( ) , createPositionListener ( latch ) ) ; if ( ! latch . await ( ROBOT_TIMEOUT , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onConnect ( ) ; } } } catch ( Exception ex ) { if ( ex . getClass ( ) == TimeoutException . class ) { if ( connected ) System . err . println ( "Connection to the motors timed out" ) ; } else ex . printStackTrace ( ) ; reset ( ) ; } }
te	ORIG	@ Override public void update ( ) { super . update ( ) ; Point destination = toPixel ( getBoardPosition ( ) ) ; if ( Math . abs ( destination . x - getX ( ) ) > 1 || Math . abs ( destination . y - getY ( ) ) > 1 ) { float dx = 0 ; float dy = 0 ; long tmp = Timer . getTime ( ) - last ; dx = ( float ) easeInOut ( tmp , getX ( ) , destination . x - getX ( ) , 600 ) ; dy = ( float ) easeInOut ( tmp , getY ( ) , destination . y - getY ( ) , 600 ) ; setLocation ( dx , dy ) ; } else { setLocation ( destination . x , destination . y ) ; last = 0 ; } }
te	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ [ ] ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; create ( world , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; }
te	REPL	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ { ) for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	ORIG	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
te	ORIG	@ Override public synchronized long remove ( String key ) { WrappedString toRemove = new WrappedString ( key ) ; strategy . remove ( toRemove ) ; ArrayHashMapOption temp = store . get ( toRemove ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } size -= temp . getValue ( ) . size ( ) ; long toReturn = temp . getValue ( ) . remove ( key ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
te	ORIG	@ Test public void testUndoOfNextPlayerEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; Player p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == one ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; int c = game . getScores ( ) . get ( two ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 301   was" + c , c == 301 ) ; }
te	REPL	private void runRaid ( RaidSettings raidSettings ) throws CantRunRaidException { Raid raid = new Raid ( raidSettings ) ; raid . run ( ) ; this . messagesToDisplay . addAll ( raid . getMessagesToDisplayOnceRaidIsOver ( ) ) ; List < Survivor > deadSurvivors = raid . getSurvivorsHurtDuringRaid ( ) ; for ( Survivor poorBastard : deadSurvivors ) this { . addMessageToDisplay ( poorBastard . getName ( ) + " has been bitten during the raid. " + ( poorBastard . isFemale ( ) ? "She" : "He" ) + " was put out of " + ( poorBastard . isFemale ( ) ? "her" : "his" ) + " misery." ) ; if ( poorBastard . getWeapon ( ) != null ) { this . mainBase . getAvailableWeapons ( ) . add ( poorBastard . getWeapon ( ) ) ; poorBastard . setWeapon ( null ) ; } this . removeSurvivorFromGame ( poorBastard ) ; } for ( Survivor newSurvivor : raid . getNewSurvivorsFound ( ) ) { try { this . recruitNewSurvivor ( newSurvivor ) ; } catch ( AlreadyThereException e ) { e . printStackTrace ( ) ; this . addMessageToDisplay ( e . getMessage ( ) ) ; } } this . rations += raid . getLoot ( ) ; }
te	REPL	Override @ public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; for ( int i = 0 ; i < 2 ; i ++ ) { shoot ( new Effect ( getParentScene ( ) , this ) ) ; } }
te	REPL	private void tallyTree ( Tree < String > tree , Counter < String > symbolCounter , Counter < UnaryRule > unaryRuleCounter , Counter < BinaryRule > binaryRuleCounter ) { if ( tree . isLeaf ( ) ) return ; if ( tree . isPreTerminal ( ) ) return ; if ( tree . getChildren ( ) . size ( ) == 1 ) { UnaryRule unaryRule = makeUnaryRule ( tree ) ; symbolCounter . incrementCount ( tree . getLabel ( ) , 1.0 ) ; unaryRuleCounter . incrementCount ( unaryRule , 1.0 ) ; } if ( tree . getChildren ( ) . size ( ) == 2 ) { BinaryRule binaryRule = makeBinaryRule ( tree ) ; symbolCounter . incrementCount ( tree . getLabel ( ) , 1.0 ) ; binaryRuleCounter . ( incrementCount binaryRule , 1.0 ) ; } if ( tree . getChildren ( ) . size ( ) < 1 || tree . getChildren ( ) . size ( ) > 2 ) { throw new RuntimeException ( "Attempted to construct a Grammar with an illegal tree (unbinarized?): " + tree ) ; } for ( Tree < String > child : tree . getChildren ( ) ) { tallyTree ( child , symbolCounter , unaryRuleCounter , binaryRuleCounter ) ; } }
te	REPL	private Rectangle parseRect ( final String string ) { ( if string == null ) { return null ; } int x , y , w , h ; int lastPos = 0 ; try { int i = string . indexOf (   , lastPos ) ; x = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; y = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; w = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; h = Integer . parseInt ( string . substring ( lastPos ) ) ; } catch ( final RuntimeException e ) { return null ; } return new Rectangle ( x , y , w , h ) ; }
te	ORIG	@ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
te	ORIG	private String getRemainBullet ( ShootingWeaponCharacter weapon ) { return weapon . getRemainBullet ( ) + " / " + weapon . getMaxCharge ( ) ; }
te	ORIG	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; }
te	ORIG	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
te	REPL	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y [ ] x ] = 1000 ; } }
te	ORIG	public static void init ( ) { driveTrain = new DriveTrain ( ) ; feeder = new Feeder ( ) ; shooter = new Shooter ( ) ; compressor = new PurpleCompressor ( ) ; feederSolenoid = new FeederSolenoid ( ) ; driveSolenoid = new DriveSolenoid ( ) ; oi = new OI ( ) ; SmartDashboard . putData ( "Toggle Feeder" , new ToggleFeeder ( ) ) ; SmartDashboard . putData ( "Manage Feeder" , new ManageFeeder ( ) ) ; SmartDashboard . putData ( "Reverse Feeder" , new ReverseFeeder ( ) ) ; SmartDashboard . putBoolean ( "ShooterIsIn" , true ) ; SmartDashboard . putData ( "EncodersReset" , new EncodersReset ( ) ) ; SmartDashboard . putNumber ( "LeftEncoder" , driveTrain . left . getD ( ) ) ; SmartDashboard . putNumber ( "RightEncoder" , driveTrain . right . getD ( ) ) ; SmartDashboard . putNumber ( "LeftDriveScale" , driveTrain . leftScale ) ; SmartDashboard . putNumber ( "RightDriveScale" , driveTrain . rightScale ) ; }
te	REPL	public static boolean box_box ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , by0 double , double bx1 , double by1 ) { double topA = FastMath . min ( ay0 , ay1 ) ; double botA = FastMath . max ( ay0 , ay1 ) ; double leftA = FastMath . min ( ax0 , ax1 ) ; double rightA = FastMath . max ( ax0 , ax1 ) ; double topB = FastMath . min ( by0 , by1 ) ; double botB = FastMath . max ( by0 , by1 ) ; double leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA <= topB || botB <= topA || rightA <= leftB || rightB <= leftA ) return false ; return true ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public Vector2D offsetPursuit ( SpriteV2 leader , Vector2D offset ) { maths . Vector2D offset_maths = new maths . Vector2D ( offset . x , offset . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( offset_maths , heading_maths , side_maths , pos_maths ) ; Vector2D worldOffsetPos = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D toOffset = worldOffsetPos . minus ( parent . position ) ; double lookAheadTime = toOffset . length ( ) / ( parent . getMaxSpeed ( ) + leader . getMaxSpeed ( ) ) ; Vector2D newVel = arrive ( leader . velocity . scalarMult ( lookAheadTime ) . + ( worldOffsetPos ) , Deceleration . FAST ) ; return newVel ; }
te	ORIG	@ Override public void dispose ( ) { left . dispose ( ) ; right . dispose ( ) ; }
te	REPL	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) for { ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
te	ORIG	@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndNumb ; i ++ ) { if ( i == rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; }
te	ORIG	@ Override public void dispose ( ) { super . dispose ( ) ; weaponView . dispose ( ) ; remainBulletView . dispose ( ) ; }
te	ORIG	private void processLeftMove ( ) { if ( ! LEFT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) + ROTATE_SPEED ) ; }
te	ORIG	@ Test public void callsServicePassedAsParameter ( ) { ServiceAddress remoteServiceAddress = new ServiceAddress ( "localhost" , port , serviceName ) ; RemoteService remoteService = proxyMaker . make ( remoteServiceAddress , RemoteService . class ) . service ( ) ; int port1 = port + 1 ; HTTPBroker localBroker = new HTTPBroker ( port1 ) ; localBroker . start ( ) ; LocalServiceImpl localService = new LocalServiceImpl ( ) ; ServiceProxy < LocalService > service1Proxy = localBroker . registerService ( "serviceName1" , localService , LocalService . class ) ; Result result = remoteService . callWithProxy ( service1Proxy , 10 ) ; assertThat ( result . param1 , is ( localService . result . param1 ) ) ; assertThat ( result . param2 , is ( localService . result . param2 ) ) ; localBroker . stop ( ) ; localBroker . join ( ) ; }
te	ORIG	private static void setLwjglNativeLibrary ( ) { System . setProperty ( LWJGL_NATIVE_PROPERTY_NAME , new File ( WINDOWS_NATIVE_FOLDER_STRING ) . getAbsolutePath ( ) ) ; }
te	REPL	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
te	REPL	public static set long ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { ArticleStatModel model = articleStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; }
te	ORIG	@ Override public Object visitCallExpr ( CallExpr expr , Integer arg ) { MethodDecl md = ( MethodDecl ) expr . functionRef . decl ; for ( int i = expr . argList . size ( ) - 1 ; i >= 0 ; i -- ) { expr . argList . get ( i ) . visit ( this , null ) ; } if ( md . isStatic ) { patches . put ( Machine . nextInstrAddr ( ) , new Code ( md , true ) ) ; Machine . emit ( Op . CALL , Reg . CB , 0 ) ; } else { if ( expr . functionRef instanceof QualifiedRef ) { QualifiedRef ref = ( QualifiedRef ) expr . functionRef ; ref . ref . visit ( this , null ) ; } else { Machine . emit ( Op . LOADA , Machine . addressSize , Reg . OB , 0 ) ; } patches . put ( Machine . nextInstrAddr ( ) , new Code ( md , true ) ) ; Machine . emit ( Op . CALLI , Reg . CB , 0 ) ; } return null ; }
te	ORIG	@ Test public void generatesProxyCorrectly ( ) { final int value = 10 ; final String expectedMethodName = ServiceInterface . class . getMethods ( ) [ 0 ] . getName ( ) ; final Object [ ] args = { value } ; context . checking ( new Expectations ( ) { { oneOf ( serviceCaller ) . call ( args , expectedMethodName , serviceAddress , void . TYPE ) ; will ( returnValue ( null ) ) ; } } ) ; ServiceInterface ft = proxyMaker . make ( serviceAddress , ServiceInterface . class ) . service ( ) ; ft . call ( value ) ; context . assertIsSatisfied ( ) ; }
te	REPL	@ Test public void testSanity ( ) { ReplacementStrategy < String > strategy = new LeastRecentlyUsed < String > ( ) ; assertNull ( strategy . suggest ( ) ) ; strategy . hit ( "foo" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . hit ( "bar" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . evict ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; assertEquals ( "bar" , strategy . ( suggest ) ) ; strategy . evict ( "bar" ) ; assertNull ( strategy . suggest ( ) ) ; }
te	REPL	public MxMemoryTracker ( ) { observers = new LinkedList < MemoryObserver > ( ) ; MemoryPoolMXBean heap = null ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) { if ( pool . getType ( ) == MemoryType . HEAP && pool . isUsageThresholdSupported ( ) ) { heap = pool ; break ; } } if ( heap == null ) { throw new RuntimeException ( "Could not locate a suitable memory pool" ) ; } heap . setUsageThreshold ( ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; System . out . println ( "Gonna put the threshold mark at " + ( long ) ( heap . getUsage ( ) . getMax ( * ) 0.75 ) ) ; }
te	ORIG	public boolean isClear ( ) { if ( ! spawns . isEmpty ( ) ) { return false ; } for ( EDFEnemy enemy : spawnedEnemies ) { if ( ! enemy . isDisposed ( ) ) { return false ; } } return true ; }
te	REPL	public static Rectangle rectFromPoints ( Point p1 , Point p2 ) { if ( p1 . x > p2 . x ) { Point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y <= p2 . y ) { return new Rectangle ( p1 . x , p1 . y , Math . abs ( p2 . x - p1 . x ) + 1 , . Math abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new Rectangle ( p1 . x , p2 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
te	ORIG	public void draw ( Graphics2D g2d ) { if ( imgdir < direction ) { imgdir += 5 ; } else if ( imgdir > direction ) { imgdir -= 5 ; } drawRotatedSprite ( g2d , sprite . getCurrentImage ( ) , x , y , imgdir ) ; if ( isOnFire ( ) ) { g2d . drawImage ( fireSprite . getCurrentImage ( ) , ( int ) x , ( int ) y , null ) ; } g2d . setColor ( Color . black ) ; g2d . fillRect ( ( int ) x - 4 , ( int ) y - 52 , 32 , 32 ) ; g2d . setColor ( Color . WHITE ) ; g2d . setFont ( new Font ( Font . SERIF , 14 , 14 ) ) ; g2d . drawString ( ( int ) health + "" , ( int ) x - 4 , ( int ) y - 37 ) ; g2d . setColor ( Color . blue ) ; g2d . drawString ( ( int ) protection + "" , ( int ) x - 4 , ( int ) y - 24 ) ; }
te	REPL	private void setWeapon ( ShootingWeaponCharacter weapon ) { this weapon . = weapon ; currentRemainBullet = weapon . getRemainBullet ( ) ; weaponView . setTexture ( weapon . getTexture ( ) ) ; remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; }
te	ORIG	public Vector2D offsetPursuit ( Sprite leader , Vector2D offset ) { maths . Vector2D offset_maths = new maths . Vector2D ( offset . x , offset . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( offset_maths , heading_maths , side_maths , pos_maths ) ; Vector2D worldOffsetPos = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D toOffset = worldOffsetPos . minus ( parent . position ) ; double lookAheadTime = toOffset . length ( ) / ( parent . dMaxSpeed + leader . dMaxSpeed ) ; Vector2D newVel = arrive ( leader . velocity . scalarMult ( lookAheadTime ) . + ( worldOffsetPos ) , Deceleration . FAST ) ; return newVel ; }
te	ORIG	public JEditorPane getTxtLocationsHelp ( ) { if ( txtLocationsHelp == null ) { txtLocationsHelp = new JEditorPane ( ) ; txtLocationsHelp . setEditable ( false ) ; txtLocationsHelp . setBounds ( new Rectangle ( 10 , 270 , 395 , 197 ) ) ; txtLocationsHelp . setContentType ( "text/html" ) ; txtLocationsHelp . setBackground ( SystemColor . info ) ; txtLocationsHelp . setFont ( new Font ( "Tahoma" , Font . PLAIN , 13 ) ) ; txtLocationsHelp . setText ( Messages . getString ( "GeoLogMain.txtLocationsHelp.text" ) ) ; txtLocationsHelp . addHyperlinkListener ( new HyperlinkListener ( ) { @ Override public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { try { if ( java . awt . Desktop . isDesktopSupported ( ) ) { java . awt . Desktop desktop = java . awt . Desktop . getDesktop ( ) ; desktop . browse ( hle . getURL ( ) . toURI ( ) ) ; } } catch ( Exception e ) { log . error ( "Error" , e ) ; } } } } ) ; } return txtLocationsHelp ; }
te	ORIG	public Bans ( Connection irc , SyncManager sync ) { this . irc = irc ; this . sync = sync ; irc . addMessageHandler ( new MessageHandler ( ) { public void handle ( MessageEvent e ) { parseLine ( e ) ; } } ) . addCode ( MessageCode . RPL_STATSGLINE ) ; irc . addMessageHandler ( glinesHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!glines.*" ) ) ; irc . addMessageHandler ( delHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!del.*" ) ) ; irc . addMessageHandler ( zlineHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!zline.*" ) ) ; irc . addMessageHandler ( showHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!show.*" ) ) ; irc . addMessageHandler ( setexpHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!setexp.*" ) ) ; }
te	ORIG	private SceneCollection ( Key trigger , class < ? extends GameScene > callClass ) { this . trigger = trigger ; this . sceneClass = callClass ; }
te	ORIG	private void moveStart ( float huga ) { dashSpeed = huga ; dashStartFrame = FPSManager . totalFrame ( ) ; }
te	ORIG	public static boolean line_line ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; return ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) ; } return false ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	ORIG	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
te	REPL	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . ( getVisit ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; return ps ; }
te	ORIG	@ Override public void onResponse ( ReportActualPositionResponse response ) { double [ ] displacement = new double [ motors . length ] ; for ( int i = 0 ; i < motors . length ; i ++ ) { Motor motor = motors [ i ] ; int count = response . getEncoderCount ( ) [ i ] ; if ( i >= motors . length / 2 ) count = - count ; double lastPosition = motor . getPosition ( ) ; motor . setEncoderCount ( count ) ; motor . setPosition ( MotorUtils . countsToDistance ( count ) ) ; displacement [ i ] = motor . getPosition ( ) - lastPosition ; } double left = displacement [ displacement . length / 2 ] ; double right = displacement [ 0 ] ; if ( left != 0 && right != 0 ) { getPosition ( ) . move ( left , right ) ; if ( positionListener != null ) positionListener . onNewPosition ( getPosition ( ) , response . getTimestamp ( ) ) ; } latch . countDown ( ) ; }
te	ORIG	private void train ( Iterable < K > trainData ) { System . out . println ( "Training..." ) ; long start = System . currentTimeMillis ( ) ; long position = 0 ; List < long > current ; for ( K datum : trainData ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new LinkedList < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } System . out . println ( "Done  took " + ( System . currentTimeMillis ( ) - start ) / 1000 + " ms" ) ; }
te	REPL	@ Override public RecordSiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { RecordSiteStatModel model = new RecordSiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setUniqueVisitorDate ( new DateTime ( rs . getLong ( "uniquevisitordate" ) ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setPageViewDate ( new DateTime ( rs . getLong ( "pageviewdate" ) ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setVisitDate ( new DateTime ( rs . getLong ( "visitdate" ) ) ) ; model . setSite ( siteDao findById . ( rs . getLong ( "site_id" ) ) ) ; return model ; }
te	REPL	private RecordSiteStatModel updateRecordSiteStat ( RecordSiteStatModel recordSiteStatModel ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordSiteStatModel . getUniqueVisitor ( ) , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordSiteStatModel . getPageView ( ) , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) , recordSiteStatModel . getVisit ( ) , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) , recordSiteStatModel . getSite ( ) . getId ( ) , recordSiteStatModel . getId ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowAffect != 1 ) log { . warn ( "No recordsitestat id = {} found to be updated" , recordSiteStatModel . getId ( ) ) ; } return recordSiteStatModel ; }
te	REPL	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; ( while nextCard == null ) { nextCard = this . model . getTopic ( ) . getRandomCard ( boxToCheck ) ; if ( firstLoop ) { boxToCheck = 0 ; firstLoop = false ; } else { boxToCheck += 1 ; } if ( boxToCheck > Application . boxCount ) { break ; } } this . model = nextCard ; this . cardShown = new Date ( ) . getTime ( ) ; this . view . cardChanged ( ) ; }
te	REPL	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int = location 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
te	ORIG	public void propertyChange ( PropertyChangeEvent evt ) { if ( calendar != null ) { Calendar c = ( Calendar ) calendar . clone ( ) ; if ( evt . getPropertyName ( ) . equals ( "day" ) ) { c . set ( Calendar . DAY_OF_MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "month" ) ) { c . set ( Calendar . MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "year" ) ) { c . set ( Calendar . YEAR , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "date" ) ) { c . setTime ( ( Date ) evt . getNewValue ( ) ) ; setCalendar ( c , true ) ; } } }
te	REPL	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue { ) if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) == Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
te	ORIG	public String toString ( String indent ) { return ( new StringBuffer ( 1024 ) . append ( '' ) . append ( indent ) . append ( AMF0Body . class . getName ( ) ) . append ( " {" ) . append ( '' ) . append ( indent ) . append ( "  target = " ) . append ( getTarget ( ) ) . append ( '' ) . append ( indent ) . append ( "  serviceName = " ) . append ( getServiceName ( ) ) . append ( '' ) . append ( indent ) . append ( "  serviceMethodName = " ) . append ( getServiceMethodName ( ) ) . append ( '' ) . append ( indent ) . append ( "  response = " ) . append ( getResponse ( ) ) . append ( '' ) . append ( indent ) . append ( "  type = " ) . append ( getObjectTypeDescription ( type ) ) . append ( '' ) . append ( indent ) . append ( "  value = " ) . append ( printValue ( value , indent + "  " ) ) . append ( '' ) . append ( indent ) . append ( } ) . toString ( ) ) ; }
te	ORIG	public GameWindow ( String title , int width , int height ) { this . frame = new JFrame ( title ) ; JPanel panel = ( JPanel ) this . frame . getContentPane ( ) ; panel . setPreferredSize ( new Dimension ( width , height ) ) ; setBounds ( 0 , 0 , width , height ) ; panel . add ( this ) ; this . setIgnoreRepaint ( true ) ; this . frame . setResizable ( false ) ; this . frame . setVisible ( true ) ; this . frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; this . frame . pack ( ) ; this . frame . setLocationRelativeTo ( null ) ; this . requestFocus ( ) ; this . createBufferStrategy ( 2 ) ; this . strategy = this . getBufferStrategy ( ) ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	ORIG	public synchronized Response sendRequest ( int address , RequestCommand command , int timeout ) throws SerialPortException , TimeoutException { final CountDownLatch latch = new CountDownLatch ( 1 ) ; ResponseListener < Response > listener = new ResponseListener < Response > ( ) { @ Override public void onResponse ( Response response ) { lastResponse = response ; latch . countDown ( ) ; } } ; subscribe ( listener , command . getResponseType ( ) ) ; send ( ( char ) ( BCAST_ADDRESS + address ) + command . toString ( ) ) ; try { if ( latch . await ( timeout , TimeUnit . MILLISECONDS ) ) return lastResponse ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } unsubscribe ( listener , command . getResponseType ( ) ) ; throw new TimeoutException ( ) ; }
te	REPL	@ Override public void update ( ) { if ( checkPause ( ) || checkGameover ( ) ) { return ; } super . ( update ) ; }
te	REPL	public void move ( double l , double r ) { double elapsed = ( System . currentTimeMillis ( ) - lastTime ) / 1000.0 ; double d = ( l + r ) / 2.0 ; double th = ( r - l ) / Configuration . getRobot ( ) . getWidth ( ) ; double x = Math . cos ( th ) * d ; double y = - Math . sin ( th ) * d ; . this lastTime = System . currentTimeMillis ( ) ; this . dx = d / elapsed ; this . dr = th / elapsed ; this . x = this . x + ( Math . cos ( this . yaw ) * x - Math . sin ( this . yaw ) * y ) ; this . y = this . y + ( Math . sin ( this . yaw ) * x + Math . cos ( this . yaw ) * y ) ; if ( th != 0 ) this . yaw = this . yaw + th ; }
te	ORIG	public static void main ( String [ ] args ) { System . out . print ( "C" ) ; try { a ( ) ; } catch ( Exception e ) { System . out . print ( e . getMessage ( ) ) ; } System . out . println ( "A" ) ; }
te	ORIG	public void generatePortals ( int numPortals ) { portals = new Portal [ numPortals * 2 ] ; for ( int i = 0 ; i < portals . length ; i += 2 ) { int hPadding = ( SQUARE_SIZE - Portal . orange . getWidth ( null ) ) / 2 ; int vPadding = ( SQUARE_SIZE - Portal . orange . getHeight ( null ) ) / 2 ; Portal a = new Portal ( ( int ) ( Math . random ( ) * ( columns - 1 ) ) * SQUARE_SIZE + hPadding , ( int ) ( Math . random ( ) * ( rows - 1 ) ) * SQUARE_SIZE + vPadding , true ) ; Portal b = new Portal ( ( int ) ( Math . random ( ) * ( columns - 1 ) ) * SQUARE_SIZE + hPadding , ( int ) ( Math . random ( ) * ( rows - 1 ) ) * SQUARE_SIZE + vPadding , false ) ; a . setEndPortal ( b ) ; b . setEndPortal ( a ) ; portals [ i ] = a ; portals [ i + 1 ] = b ; } }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] col [ ] = value ; } }
te	ORIG	public BigCache ( String dir , CacheConfig config ) throws IOException { this . cacheDir = dir ; if ( ! this . cacheDir . endsWith ( File . separator ) ) { this . cacheDir += File . separator ; } if ( ! FileUtil . isFilenameValid ( this . cacheDir ) ) { throw new IllegalArgumentException ( "Invalid cache data directory : " + this . cacheDir ) ; } FileUtil . deleteDirectory ( new File ( this . cacheDir ) ) ; this . storageManager = new StorageManager ( this . cacheDir , config . getCapacityPerBlock ( ) , config . getInitialNumberOfBlocks ( ) , config . getStorageMode ( ) , config . getMaxOffHeapMemorySize ( ) ) ; this . readWriteLock = new StripedReadWriteLock ( config . getConcurrencyLevel ( ) ) ; ses = new ScheduledThreadPoolExecutor ( 2 ) ; ses . scheduleWithFixedDelay ( new CacheCleaner ( this ) , config . getPurgeInterval ( ) , config . getPurgeInterval ( ) , TimeUnit . MILLISECONDS ) ; ses . scheduleWithFixedDelay ( new CacheMerger ( this ) , config . getMergeInterval ( ) , config . getMergeInterval ( ) , TimeUnit . MILLISECONDS ) ; dirtyRatioThreshold = config . getDirtyRatioThreshold ( ) ; }
te	REPL	private GameScene newInstance ( ) { try { return sceneClass . newInstance ( ) ; } catch ( InstantiationException | e IllegalAccessException ) { System . err . println ( sceneClass . getName ( ) + " \u30AF\u30E9\u30B9\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3067\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" ) ; e . printStackTrace ( ) ; return null ; } }
te	REPL	@ Override public < T extends > GameObject T add ( T go ) { if ( go instanceof ShootingObject ) { return characterController . add ( go ) ; } return super . add ( go ) ; }
te	REPL	private Thread createConsoleThread ( ) { Thread t = new Thread ( new Runnable ( ) { public void run ( ) { while ( ! Thread . interrupted ( ) ) { context . putValue ( Context . KEY_COMMAND_LINE_ARGS , null ) ; boolean handled = false ; String line = readInput ( prompt . getValue ( context ) ) ; if ( line == null || line . trim ( ) . isEmpty ( ) ) continue ; context . putValue ( Context . KEY_COMMAND_LINE_INPUT , line ) ; if ( controllersExist ( ) ) { for ( InputController controller : controllers { ) Pattern pattern = controller . respondsTo ( ) ; boolean enabled = controller . isEnabled ( ) ; if ( pattern != null && pattern . matcher ( line ) . matches ( ) && enabled ) { boolean ctrlResult = controller . handle ( context ) ; handled = handled || ctrlResult ; } } if ( ! handled ) { writeOutput ( String . format ( "%nCommand unhandled. " + "%nNo controller found to respond to [%s].%n%n" , line ) ) ; } } else { writeOutput ( String . format ( "Warning: no controllers(s) found.%n" ) ) ; } } } } ) ; return t ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	ORIG	public ArticlePanel ( Article article ) throws SQLException { initComponents ( ) ; ArrayList < Category > categories = GoodsService . readCategories ( ) ; Category [ ] items = new Category [ categories . size ( ) + 1 ] ; System . arraycopy ( categories . toArray ( new Category [ 0 ] ) , 0 , items , 1 , items . length - 1 ) ; categoryComboBox . setModel ( new DefaultComboBoxModel ( items ) ) ; validationGroup . add ( priceTextField , StringValidators . REQUIRE_VALID_NUMBER ) ; validationGroup . add ( fullNameTextField , StringValidators . REQUIRE_NON_EMPTY_STRING ) ; validationGroup . add ( categoryComboBox , StringValidators . REQUIRE_NON_EMPTY_STRING ) ; if ( article != null ) { this . article = article ; for ( Category category : categories ) { if ( category . getId ( ) == article . getCategoryId ( ) ) { categoryComboBox . setSelectedItem ( category ) ; break ; } } fullNameTextField . setText ( article . getName ( ) ) ; priceTextField . setText ( article . getPrice ( ) . toString ( ) ) ; } else { this . article = new Article ( ) ; } }
te	ORIG	public void run ( ) { try { captrueOutputStream = new BufferedOutputStream ( s . getOutputStream ( ) ) ; } catch ( IOException ex ) { return ; } AudioFormat format = new AudioFormat ( 8000 , 16 , 2 , true , true ) ; DataLine . Info info = new DataLine . Info ( TargetDataLine . class , format ) ; try { line = ( TargetDataLine ) AudioSystem . getLine ( info ) ; line . open ( format , line . getBufferSize ( ) ) ; } catch ( Exception ex ) { return ; } byte [ ] data = new byte [ 1024 ] ; int numBytesRead = 0 ; line . start ( ) ; while ( thread != null ) { numBytesRead = line . read ( data , 0 , 128 ) ; try { captrueOutputStream . write ( data , 0 , numBytesRead ) ; } catch ( Exception ex ) { break ; } } line . stop ( ) ; line . close ( ) ; line = null ; try { captrueOutputStream . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
te	ORIG	private void moveImportedFile ( String exportFileLocation , String fileName ) { try { File doneFolder = new File ( exportFileLocation + "article_done" ) ; if ( ! doneFolder . exists ( ) ) { doneFolder . mkdir ( ) ; } String sourceFilePath = exportFileLocation + fileName ; String doneLocation = exportFileLocation + "article_done" + File . separator + fileName ; File sourceFile = new File ( sourceFilePath ) ; if ( sourceFile . exists ( ) ) { if ( sourceFile . renameTo ( new File ( doneLocation ) ) ) { log . debug ( "Import done move file {} to done dir" , fileName ) ; } else { throw new MoveFileException ( "Can not move finish article file to done folder" ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	REPL	@ Override public void update ( ) { if ( currentRemainBullet != weapon . getRemainBullet ( ) { ) remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; currentRemainBullet = weapon . getRemainBullet ( ) ; } }
te	REPL	@ Test @ Ignore public void test ( ) throws Exception { DatabaseHandler database = Mappings . DB ; database . registerMapping ( Baz . class , BAZ ) ; Query < Baz > bazQuery = new Query < > ( database , Baz . class ) ; SampleEmbeddable embeddable = new SampleEmbeddable ( "Baz" , 123 ) ; Baz baz = new Baz ( ) ; baz . created = new Date ( ) ; baz . embeddable = embeddable ; bazQuery . insert ( baz ) ; assertTrue ( baz . id > 0 ) ; int id = baz . id ; baz = bazQuery . select ( byId ( id ) ) . get ( 0 ) ; assertSame ( id , baz . id ) ; assertSame ( embeddable . someIntVlaue , baz . embeddable . someIntVlaue ) ; assertSame ( embeddable . someStringValue , baz . embeddable . someStringValue ) ; baz . embeddable . someStringValue = "BazBaz" ; . bazQuery update ( baz ) ; baz = bazQuery . select ( byId ( id ) ) . get ( 0 ) ; assertSame ( baz . embeddable . someStringValue , "BazBaz" ) ; }
te	REPL	public static boolean getCell ( boolean ] [ [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public ArrayList < String > getAsString ( String select , String relation , String ... constrains ) { HashMap < String , ArrayList < String >> query ; if ( constrains . length == 0 ) { query = get ( select , relation ) ; } else { query = get ( select , relation , constrains ) ; } ArrayList < String > result = new ArrayList < String > ( ) ; boolean first = true ; for ( String a : query . keySet ( ) ) { if ( first ) { for ( int i = 0 ; i < query . get ( a ) . size ( ) ; i ++ ) { result . add ( query . get ( a ) . get ( i ) ) ; } first = false ; } else { for ( int i = 0 ; i < query . get ( a ) . size ( ) ; i ++ ) { result . set ( i , result . get ( i ) + "  " + query . get ( a ) . get ( i ) ) ; } } } return result ; }
te	REPL	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . . out print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	@ Override public void update ) ( { int width = Game . getInstance ( ) . getWindow ( ) . getWidth ( ) ; int height = Game . getInstance ( ) . getWindow ( ) . getHeight ( ) ; this . header . verticalAlignCenter ( 0 , width ) ; this . btnCollection . verticalAlignCenter ( 0 , width ) ; this . btnCollection . horizontalAlignCenter ( 0 , height ) ; int counter = 0 ; this . btnCollection . update ( ) ; for ( TEView view : this . btnCollection . getCollection ( ) ) { TEButton btn = ( TEButton ) view ; if ( btn . isClicked ( ) ) { switch ( counter ) { case 0 : Game . getInstance ( ) . loadScene ( Scene . SCENE_SETTINGS ) ; return ; case 1 : Game . getInstance ( ) . loadScene ( SCENE_CREDITS ) ; return ; } } counter ++ ; } }
te	ORIG	@ Override public synchronized long get ( String key ) { WrappedString toGet = new WrappedString ( key ) ; strategy . hit ( toGet ) ; ArrayHashMapOption temp = store . get ( toGet ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for get() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long toReturn = temp . getValue ( ) . get ( key ) ; return toReturn ; }
te	REPL	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ; ) final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
te	REPL	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException { ) final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 ] ) ; final Object o = causeMethod . invoke ( exception , new Object [ 0 ] ) ; if ( o instanceof Throwable ) { cause = ( Throwable ) o ; } } catch ( final NoSuchMethodException e ) { } catch ( final IllegalArgumentException e ) { } catch ( final IllegalAccessException e ) { } catch ( final InvocationTargetException e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	REPL	public static double [ ] line_line_infinite ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double [ ] result = NONE ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 - ) g2 * ( x2 - x0 ) ) / det ; result = new double [ ] { x0 + f1 * s , y0 + g1 * s } ; } return result ; }
te	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
te	ORIG	public Syllabicator ( ) { sep = "-" ; separator = Pattern . compile ( sep ) ; rules = new String [ 10 ] ; rules [ 1 ] = i + h + i ; rules [ 2 ] = a + h + i ; rules [ 3 ] = i + h + a ; rules [ 4 ] = v + c + v ; rules [ 5 ] = l + pp + v ; rules [ 6 ] = pp + v ; rules [ 7 ] = l + c + c + v ; rules [ 8 ] = a + a ; rules [ 9 ] = l ; String all = "(" + rules [ 1 ] + ")|(" + rules [ 2 ] + ")|(" + rules [ 3 ] + ")|(" + rules [ 4 ] + ")|(" + rules [ 5 ] + ")|(" + rules [ 6 ] + ")|(" + rules [ 7 ] + ")|(" + rules [ 8 ] + ")|(" + rules [ 9 ] + ")" ; pattern = Pattern . compile ( all , Pattern . CASE_INSENSITIVE ) ; }
te	REPL	@ Override public void checkAnswer ( String answer ) { long curTime = new Date ( ) . getTime ( ) ; long spentTime = curTime - this . cardShown ; curBox = this . model . getBox ( ) ; if ( this . model . check ( answer ) ) { if ( this . model . getSpentTime ( ) < spentTime ) { this . view . answerRightSlow ( ) ; else } { this . view . answerRightFast ( ) ; } this . model . setSpentTime ( spentTime ) ; } else { this . view . answerWrong ( ) ; } this . onCheckCard . refresh ( ) ; }
te	REPL	public void render ( Graphics2D context ) { Color color = context . getColor ( ) ; Stroke stroke = context . getStroke ( ) ; if ( this . isClicked ( ) ) { context . setColor ( this . getClickedColor ( ) ) ; } else { context . setColor ( this . getColor ( ) ) ; } context . setStroke ( new BasicStroke ( this . ( getBorderSize ) ) ) ; context . drawRect ( this . getX ( ) + this . getBorderSize ( ) / 2 , this . getY ( ) + this . getBorderSize ( ) / 2 , this . getWidth ( ) - this . getBorderSize ( ) , this . getHeight ( ) - this . getBorderSize ( ) ) ; if ( this . state ) { this . renderEnabledState ( context ) ; } else { this . renderDisabledState ( context ) ; } context . setColor ( color ) ; context . setStroke ( stroke ) ; }
te	ORIG	public Response addChar ( byte c ) { if ( c == ( byte ) c2 ) { if ( sb . length ( ) != 0 ) reset ( ) ; } else { if ( source == - 1 ) { source = ( c & FF ) - SerialCom . BCAST_ADDRESS ; timestamp = System . currentTimeMillis ( ) ; } else { sb . append ( ( char ) c ) ; if ( currentResponse == null ) { String responseString = sb . toString ( ) ; for ( RequestCommand comm : commandTypes ) if ( comm . isResponse ( responseString ) ) currentResponse = comm . createResponse ( source , timestamp ) ; } else { if ( currentResponse . isValid ( sb . toString ( ) ) ) { currentResponse . parse ( sb . toString ( ) ) ; Response r = currentResponse ; reset ( ) ; return r ; } } } } return null ; }
te	ORIG	public static void store ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { if ( i < 2 ) { fib [ i ] = 1 ; } else { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } }
te	ORIG	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
te	ORIG	public void endGame ( final AbstractGame game ) throws NoGameActiveException { synchronized ( this ) { if ( this . activeGame == null || this . activeGame != game ) { throw new NoGameActiveException ( ) ; } this . activeGame = null ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameFinished ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . shutdown ( ) ; } catch ( InitializationException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	REPL	private void doSpawn ( SpawnData spawnData ) { spawnedEnemies . add ( parentScene . add ( spawnData . spawnTo ( parentScene ) ) ) ; }
te	ORIG	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 + " kb" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; } } ) ; running . setDaemon ( true ) ; running . start ( ) ; }
te	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.2f , 0.4f ) ) ; }
te	REPL	public void expectationMaximization ( String fileName ) { TextReader txreader = new TextReader ( fileName , WordType . LETTERS ) ; String word ; Value < State > times = new Value < State > ( ) ; HashMap < State , Value < Character >> restart = new HashMap < State , Value < Character >> ( ) ; for ( State s Q : ) { restart . put ( s , new Value < Character > ( ) ) ; } try { while ( ( word = txreader . nextWord ( ) ) != null ) { trainWord ( word , times , restart ) ; } for ( State q : Q ) { if ( times . containsKey ( q ) ) { q . setTimes ( times . get ( q ) ) ; q . setRestart ( restart . get ( q ) ) ; } else { q . clean ( ) ; } } } catch ( java . io . IOException x ) { System . err . println ( x ) ; } catch ( NullPointerException np ) { np . printStackTrace ( ) ; System . exit ( 0 ) ; } }
te	REPL	public < T > ServiceProxy < T > registerService ( final T service , final String serviceName , class < T > interfaceClass ) { checkNotRegistered ( serviceName ) ; try { final String address = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; ServiceProxyImpl < T > serviceProxy = new ServiceProxyImpl < > ( new ( ServiceAddress address , broker . getPort ( ) , serviceName ) , service , interfaceClass ) ; services . put ( serviceName , serviceProxy ) ; return serviceProxy ; } catch ( UnknownHostException shouldNeverHappen ) { throw new RuntimeException ( shouldNeverHappen ) ; } }
te	REPL	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , , col row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	public BasicInfo ( Date birthday , int s , int curYear ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( birthday ) ; yinLi = birthday ; year = calendar . get ( Calendar . YEAR ) ; month = calendar . get ( Calendar . MONTH ) ; day = calendar . get ( Calendar . ) DAY_OF_MONTH ; hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; sex = s ; age = curYear - year + 1 ; shiChen = ShiChenBiao . getShiChenByHour ( hour ) ; tianGan = LiuShiJiaZiBiao . getTianGanByYear ( year ) ; diZhi = LiuShiJiaZiBiao . getDiZhiByYear ( year ) ; yinYang = LiuShiJiaZiBiao . getYinYangByYear ( year ) ; mingZhu = MingShenZhuBiao . mingZhuBiao [ diZhi ] ; shenZhu = MingShenZhuBiao . shenZhuBiao [ diZhi ] ; nowTianGan = LiuShiJiaZiBiao . getTianGanByYear ( curYear ) ; nowDiZhi = LiuShiJiaZiBiao . getDiZhiByYear ( curYear ) ; }
te	ORIG	@ Override public void inputProcess ( ) { if ( Key . O . isPressed ( ) ) { GameSceneManager . getInstance ( ) . gameover ( ) ; } }
te	REPL	public void update ( float wind ) { setX ( getX ( ) + ( wind * getScale ( ) ) ) ; if ( getPixcelY ( ) > + HEIGHT getHeight ( ) / 2 ) { setDispose ( ) ; } super . update ( ) ; }
te	REPL	public void equipLeft ( BasicWeapon ) weapon { if ( leftWeapon != null ) { leftWeapon . dispose ( ) ; } leftWeapon = getParentScene ( ) . add ( weapon ) ; }
te	REPL	public static void play ( boolean [ ] [ ] ) world throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 row || < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	ORIG	public void run ( ) { AudioFormat format = new AudioFormat ( 8000 , 16 , 2 , true , true ) ; BufferedInputStream playbackInputStream ; try { playbackInputStream = new BufferedInputStream ( new AudioInputStream ( s . getInputStream ( ) , format , 2147483647 ) ) ; } catch ( IOException ex ) { return ; } DataLine . Info info = new DataLine . Info ( SourceDataLine . class , format ) ; try { line = ( SourceDataLine ) AudioSystem . getLine ( info ) ; line . open ( format , bufSize ) ; } catch ( LineUnavailableException ex ) { return ; } byte [ ] data = new byte [ 1024 ] ; int numBytesRead = 0 ; line . start ( ) ; while ( thread != null ) { try { numBytesRead = playbackInputStream . read ( data ) ; line . write ( data , 0 , numBytesRead ) ; } catch ( IOException e ) { break ; } } if ( thread != null ) { line . drain ( ) ; } line . stop ( ) ; line . close ( ) ; line = null ; }
te	REPL	public static void setCell ( boolean [ ] [ ] , world int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	REPL	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { MemoryMXBean mbean = ManagementFactory . getMemoryMXBean ( ) ; NotificationEmitter emitter = ( NotificationEmitter ) mbean ; emitter . addNotificationListener ( new NotificationListener ( ) { @ Override public void handleNotification ( Notification notification , Object handback ) if { ( notification . getType ( ) . equals ( MemoryNotificationInfo . MEMORY_THRESHOLD_EXCEEDED ) ) { for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } } } } , null , null ) ; } } ) ; running . setDaemon ( true ) ; running . start ( ) ; }
te	REPL	private Color getCaptionColor ( float hp ) { return new Color ( 255 , ( int ) ( hp * 17.5 ) , ( int ) ( hp * 17.5 ) ) ; }
te	REPL	public void testWriteZip ( ) throws IOException { OpenDocumentArchive archive = new OpenDocumentArchive ( ) ; Writer mimetypeWriter = archive . getEntryWriter ( OpenDocumentArchive . ENTRY_MIMETYPE ) mimetypeWriter ; . write ( "application/x-test" ) ; mimetypeWriter . close ( ) ; Writer contentWriter = archive . getEntryWriter ( OpenDocumentArchive . ENTRY_CONTENT ) ; contentWriter . write ( "test content" ) ; contentWriter . close ( ) ; File documentFile = File . createTempFile ( "document" , ".zip" ) ; OpenDocumentIO . writeZip ( archive , new FileOutputStream ( documentFile ) ) ; assertTrue ( "file not created" , documentFile . exists ( ) && documentFile . length ( ) > 0 ) ; ZipInputStream zipInputStream = new ZipInputStream ( new FileInputStream ( documentFile ) ) ; ZipEntry firstEntry = zipInputStream . getNextEntry ( ) ; assertNotNull ( "zip file has no entries" , firstEntry ) ; assertEquals ( "first entry not 'mimetype' as required by OpenDocument" , OpenDocumentArchive . ENTRY_MIMETYPE , firstEntry . getName ( ) ) ; assertEquals ( "first entry compressed" , ZipEntry . STORED , firstEntry . getMethod ( ) ) ; String mimetype = IOUtils . toString ( zipInputStream ) ; assertEquals ( "mimetype content" , "application/x-test" , mimetype ) ; zipInputStream . close ( ) ; documentFile . delete ( ) ; }
te	REPL	@ Override public void update ( ) { . super update ( ) ; updateText ( getCaption ( scene . getMoney ( ) ) ) ; }
te	ORIG	@ Test public void testRemove ( ) { ReplacementStrategy < String > strategy = new LeastRecentlyUsed < String > ( ) ; strategy . remove ( "foo" ) ; strategy . hit ( "foo" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . remove ( "foo" ) ; strategy . evict ( "foo" ) ; assertNull ( strategy . suggest ( ) ) ; strategy . hit ( "bar" ) ; strategy . hit ( "bar2" ) ; strategy . remove ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; strategy . evict ( "bar" ) ; strategy . remove ( "bar" ) ; assertEquals ( "bar2" , strategy . suggest ( ) ) ; }
te	REPL	public static Point randRectEdge ( Rectangle r , RectangleSide side ) { Point result = null ; if ( side == RectangleSide . TOP ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side == RectangleSide . BOTTOM ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r y . + r . height - 1 ) ; } else if ( side == RectangleSide . LEFT ) { result = new Point ( r . x , randInt ( r . y , r . y + r . height - 1 ) ) ; } else if ( side == RectangleSide . RIGHT ) { result = new Point ( r . x + r . width - 1 , randInt ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
te	REPL	@ Override public void onDataReceived ( AsyncReadEvent e ) { try { JSONObject obj = new JSONObject ( e . getData ( ) ) ; if ( obj . has ( "op" ) ) { String op = obj . getString ( "op" ) ; if ( op . equals ( "sync" ) ) { username = obj . getString ( "assignedName" ) ; System . out . println ( "Assigned " + username ) ; frame . setTitle ( "Dobby: " + username ) ; String text = obj . getString ( "text" ) ; try { document . removeDocumentListener ( this ) ; document . insertString ( 0 , text , null ) ; document . addDocumentListener ( this ) ; } catch ( BadLocationException e1 ) { e1 . printStackTrace ( ) ; } } if else ( op . equals ( "Ins" ) ) { InsertRequest request = InsertRequest . fromJSON ( obj ) ; handleInsertRequest ( request ) ; } else if ( op . equals ( "Del" ) ) { DeleteRequest request = DeleteRequest . fromJSON ( obj ) ; handleDeleteRequest ( request ) ; } } } catch ( JSONException e1 ) { e1 . printStackTrace ( ) ; } }
te	REPL	@ Override public Object [ ] decode ( String callParametersString , Type [ ] parameterTypes ) { if ( callParametersString . isEmpty ( ) && parameterTypes . length == 0 ) { return new Object [ 0 ] ; } JsonArray parametersArray = jsonParser . parse ( callParametersString ) . getAsJsonArray ( ) ; Object [ ] result = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { result [ i ] = gson . fromJson ( parametersArray . get ( i ) , TypeToken . get ( ( ) Type parameterTypes [ i ] ) . getType ( ) ) ; } return result ; }
te	ORIG	public void updateAI ( long timeElapsed ) { if ( parent instanceof AIShip ) { if ( currentState == STATE_DISCOVER ) { discover ( ) ; } else if ( currentState == STATE_ATTACK ) { attack ( target ) ; } else if ( currentState == STATE_DEFEND ) { defend ( target ) ; } else if ( currentState == STATE_FOLLOW ) { Vector v = new Vector ( ) ; v . add ( target . getX ( ) ) ; v . add ( target . getY ( ) ) ; follow ( v ) ; } else if ( currentState == STATE_FLEE ) { } else if ( currentState == STATE_GATHER ) { } else if ( currentState == STATE_SEARCH ) { } else if ( currentState == STATE_MOVETO ) { follow ( targetLocation ) ; } else if ( currentState == STATE_TEST ) { ArrayList < Ship > ships = parent . parent . parent . getMap ( ) . getAIShips ( ) ; if ( ships . indexOf ( parent ) == 0 ) { } else { } } } }
te	REPL	public FlowerStormScene ( ) { BackGroundColor . WHITE set . ( ) ; flowerTexture = new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ; }
te	REPL	public static void create ( boolean [ ] [ ] world , int iter , String file ) throws Exception { OutputAnimatedGif gif = new OutputAnimatedGif ( file ) ; for ( int i = 0 ; i < iter ; i ++ ) { gif addFrame . ( world ) ; world = nextGeneration ( world ) ; } }
te	REPL	public static boolean isInsideTriangle ( double aX , double aY , double bX , double bY , double cX , double cY , double pX , double pY ) { double ax , ay , bx , by , cx , cy , apx , apy , bpx , bpy , cpx , cpy ; double cCROSSap , bCROSScp , aCROSSbp ; ax = cX - bX ; ay = cY - bY ; bx = aX - cX ; by = aY - cY ; cx = bX - aX ; cy = bY - aY ; apx = pX - aX ; apy = pY - aY ; bpx = pX - bX ; bpy = pY - bY ; cpx = - pX cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx * cpy - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
te	ORIG	@ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "OCHN(" ) ; builder . append ( type ) ; builder . append ( " " ) ; builder . append ( byte . toString ( channel ) ) ; builder . append ( " " ) ; builder . append ( parity ) ; builder . append ( " " ) ; builder . append ( Integer . toString ( baud ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( stopBits ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( dataBits ) ) ; builder . append ( " " ) ; builder . append ( mode ) ; builder . append ( ")" ) ; return builder . toString ( ) ; }
te	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.5f , 0.8f ) ) ; }
te	ORIG	@ Override public void render ( ) { weaponView . render ( ) ; remainBulletView . render ( ) ; }
te	REPL	public OutputAnimatedGif ( String file ) throws IOException { this . output = new FileImageOutputStream ( new File ( file ) ) ; this . writer = ImageIO . getImageWritersByMIMEType ( "image/gif" ) . next ( ) ; this . writer . setOutput ( output ) this ; . writer . prepareWriteSequence ( null ) ; }
te	REPL	private void socketLifeCycle ( ) { notifyConnection ( ) ; if ( isSendHello ( ) ) sendHello ( ) ; try { waitLines ( ) ; Logger . getLogger ( getClass ( ) ) . info ( "Disconnected!" ) ; } catch ( SocketException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( SocketTimeoutException e ) { Logger . getLogger ( getClass ) ( ) . warn ( e . getMessage ( ) ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } finally { if ( getRawSocket ( ) != null ) Logger . getLogger ( getClass ( ) ) . info ( new StringBuffer ( "Disconnect from " ) . append ( getRawSocket ( ) . getInetAddress ( ) . getHostName ( ) ) ) ; try { disconnect ( ) ; notifyDisconnection ( ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } } }
te	REPL	public WeatherStation ( ) throws ParsingException , IOException { Builder builder = new Builder ( ) ; Document doc = builder . build ( "http://tinyurl.com/rd4r72" ) ; Element root = doc getRootElement . ( ) ; Element simple = root . getFirstChildElement ( "simpleforecast" ) ; Elements days = simple . getChildElements ( "forecastday" ) ; for ( int current = 0 ; current < days . size ( ) ; current ++ ) { Element day = days . get ( current ) ; Element high = day . getFirstChildElement ( "high" ) ; Element highF = high . getFirstChildElement ( "fahrenheit" ) ; Element low = day . getFirstChildElement ( "low" ) ; Element lowF = low . getFirstChildElement ( "fahrenheit" ) ; Element icon = day . getFirstChildElement ( "icon" ) ; lowTemp [ current ] = - 1 ; highTemp [ current ] = - 1 ; try { lowTemp [ current ] = Integer . parseInt ( lowF . getValue ( ) ) ; highTemp [ current ] = Integer . parseInt ( highF . getValue ( ) ) ; } catch ( NumberFormatException nfe ) { } conditions [ current ] = icon . getValue ( ) ; } }
te	ORIG	private void addFlowerIfNecessary ( ) { if ( FPSManager . totalFrame ( ) % ( FPS / flowerBornPerSecond ) == 0 ) { add ( new FlowerCharacter ( flowerTexture ) ) ; } }
te	REPL	@ Override public boolean check ( String answer ) { this . statisticDateLastLearned = new java . util . Date ( ) . getTime ( ) ; if ( answer . equals ( this . answer ) ) { this . statisticCountRight += 1 ; this . moveUp ( ) ; System . out . println ( "answer true" ) ; System . out . println ( "Count right: " + statisticCountRight ) ; return true ; } System . out println . ( "answer false" ) ; this . statisticCountWrong += 1 ; this . setBox ( 1 ) ; System . out . println ( "Count wrong " + statisticCountWrong ) ; return false ; }
te	ORIG	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
te	ORIG	protected JPanel getFontSizePanel ( ) { if ( fontSizePanel == null ) { fontSizePanel = new JPanel ( ) ; fontSizePanel . setLayout ( new BorderLayout ( ) ) ; fontSizePanel . setPreferredSize ( new Dimension ( 70 , 130 ) ) ; fontSizePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JScrollPane scrollPane = new JScrollPane ( getFontSizeList ( ) ) ; scrollPane . getVerticalScrollBar ( ) . setFocusable ( false ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( getFontSizeTextField ( ) , BorderLayout . NORTH ) ; p . add ( scrollPane , BorderLayout . CENTER ) ; JLabel label = new JLabel ( ( "Font Size" ) ) ; label . setHorizontalAlignment ( JLabel . LEFT ) ; label . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontSizeTextField ( ) ) ; label . setDisplayedMnemonic ( S ) ; fontSizePanel . add ( label , BorderLayout . NORTH ) ; fontSizePanel . add ( p , BorderLayout . CENTER ) ; } return fontSizePanel ; }
te	REPL	private void drawPolygon ( Graphics2D g2 , Polygon polygonToDraw , Color color , boolean isTransparent ) { Stroke strokeMem = g2 . getStroke ( ) ; g2 . setColor ( color ) ; if ( ! isTransparent ) { g2 . setStroke ( new BasicStroke ( 2 ) ) ; g2 . setColor ( Color . BLACK ) ; } g2 . drawPolygon ( polygonToDraw . getI_tab_xPoints ( ) , polygonToDraw . getI_tab_yPoints ( ) , polygonToDraw . getI_tab_xPoints ( ) . length ) ; if ( ! isTransparent ) { g2 . setStroke ( strokeMem ) ; g2 . setColor ( color ) ; } if ( isTransparent ) g2 . setComposite ( java . awt . AlphaComposite . getInstance ( java . awt . AlphaComposite . SRC_OVER , Math . min ( 0.3f 1.0f , ) ) ) ; g2 . fillPolygon ( polygonToDraw . getI_tab_xPoints ( ) , polygonToDraw . getI_tab_yPoints ( ) , polygonToDraw . getI_tab_xPoints ( ) . length ) ; if ( isTransparent ) g2 . setComposite ( java . awt . AlphaComposite . getInstance ( java . awt . AlphaComposite . SRC_OVER , Math . min ( 1.0f , 1.0f ) ) ) ; hasMooved = false ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	ORIG	@ Override public void update ( ) { setVx ( getVX ( ) * 0.95f ) ; setVy ( getVY ( ) * 0.95f ) ; super . update ( ) ; }
te	ORIG	private boolean checkGameover ( ) { if ( characterController . earthArrive ( ) ) { return false ; } GameSceneManager . getInstance ( ) . gameover ( ) ; return true ; }
te	REPL	private Prediction combine ( List < PredictionData > predictionSets ) { Collections . sort ( predictionSets ) ; double weightedProbability = 0 ; double totalConfidence = 0 ; int lowestBitsPerCollection = 0 ; for ( int dataIndex = 0 ; dataIndex < predictionSets . size ( ) dataIndex ; ++ ) { PredictionData dataSet = predictionSets . get ( dataIndex ) ; if ( dataSet . getConfidence ( ) > Parameters . CONFIDENCE_THRESHOLD [ dataSet . getDelta ( ) ] [ dataSet . tier ( ) ] || dataIndex == predictionSets . size ( ) - 1 ) { weightedProbability += dataSet . getProbability ( ) * dataSet . getConfidence ( ) ; totalConfidence += dataSet . getConfidence ( ) ; lowestBitsPerCollection = dataSet . getBitsPerCollection ( ) ; break ; } else if ( dataSet . getConfidence ( ) > Parameters . CONTRIBUTION_CONFIDENCE [ dataSet . getDelta ( ) ] [ dataSet . tier ( ) ] ) { double confidence = dataSet . getConfidence ( ) ; weightedProbability += dataSet . getProbability ( ) * confidence ; totalConfidence += confidence ; } } weightedProbability /= totalConfidence ; return new Prediction ( lowestBitsPerCollection , weightedProbability , totalConfidence ) ; }
te	REPL	public void startGame ( final AbstractGame game ) throws GameAlreadyActiveException { synchronized ( this ) { if ( this . activeGame != null ) { throw new ( GameAlreadyActiveException ) ; } this . activeGame = game ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameStarted ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . registerListener ( game ) ; engine . start ( ) ; } catch ( InitializationException | AlreadyRunningException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	ORIG	private void renderDisabledState ( Graphics2D context ) { context . setColor ( this . getColor ( ) ) ; context . fillRect ( this . getX ( ) + this . getBorderSize ( ) , this . getY ( ) + this . getBorderSize ( ) , this . getWidth ( ) / 2 - this . getBorderSize ( ) , this . getHeight ( ) - 2 * this . getBorderSize ( ) ) ; this . label . setText ( "0" ) ; this . label . horizontalAlignCenter ( this . getY ( ) , this . getY ( ) + this . getHeight ( ) ) ; this . label . verticalAlignCenter ( this . getX ( ) + this . getWidth ( ) / 2 , this . getX ( ) + this . getWidth ( ) ) ; this . label . render ( context ) ; }
te	ORIG	private void initComponets ( ) { view . getMnuMyStation ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { TabPaneModel tabPaneModel = ( TabPaneModel ) getRegisteredModel ( TabPaneModel . MODEL_KEY ) ; tabPaneModel . setPanelIndex ( 3 ) ; } } ) ; view . getMenuViewCache ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { LocatorEditor editor = new LocatorEditor ( ) ; editor . setVisible ( true ) ; } } ) ; view . getMenuCleanCache ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int response ; response = JOptionPane . showConfirmDialog ( view . getMainPanel ( ) , Messages . getString ( "MenuController.sureQuestion" ) ) ; if ( response == 0 ) { try { DerbyManager . getInstance ( ) . cleanDatabase ( ) ; JOptionPane . showInternalMessageDialog ( view . getMainPanel ( ) , Messages . getString ( "MenuController.cacheRemoved" ) ) ; } catch ( SQLException e1 ) { log . error ( "Error" , e1 ) ; } } } } ) ; }
te	REPL	@ Override public void ( dispose ) { super . dispose ( ) ; hpCaption . dispose ( ) ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; ps . setLong ( 8 , model . getId ( ) ) ; }
te	ORIG	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == null ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
te	REPL	@ Override public ArticleStatModel mapRow ( ResultSet , rs int rowNum ) throws SQLException { ArticleStatModel model = new ArticleStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setDate ( new DateTime ( rs . getLong ( "date" ) ) ) ; model . setArticleId ( rs . getString ( "articleid" ) ) ; model . setArticleTitle ( rs . getString ( "articletitle" ) ) ; model . setArticleUrl ( rs . getString ( "articleurl" ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
te	ORIG	public void calculateSiteStatRecord ( ) { log . info ( "Starting calculateSiteStatRecord" ) ; long firstDayInLong = siteStatDao . findFirstDateTime ( ) ; long lastDayInLong = siteStatDao . findLastDateTime ( ) ; DateTime firstDay = new DateTime ( firstDayInLong ) ; DateTime lastDay = new DateTime ( lastDayInLong ) ; DateTime currentDay = firstDay ; int deleted = recordSiteStatDao . deleteAllSiteStatRecord ( ) ; log . info ( "Clear all data in sitestatrecord deleted {} records" , deleted ) ; calculateRecordForSiteStat ( lastDay . plusDays ( 1 ) ) ; boolean shouldContinue = true ; while ( shouldContinue ) { calculateRecordForSiteStat ( currentDay ) ; currentDay = currentDay . plusDays ( 1 ) ; if ( currentDay . getMillis ( ) > lastDay . toDateMidnight ( ) . toDateTime ( ) . getMillis ( ) ) { shouldContinue = false ; } } log . info ( "calculateSiteStatRecord finished" ) ; }
te	ORIG	private InteractionEvent parsePacket ( int base , int value ) { if ( value >= 129 ) { return HitEvent . singleHitOuter ( value - 128 ) ; } if ( value >= 97 ) { return HitEvent . tripleHit ( value - 96 ) ; } if ( value >= 65 ) { return HitEvent . doubleHit ( value - 64 ) ; } if ( value == 57 ) { return HitEvent . singleHitInner ( 25 ) ; } if ( value >= 33 ) { return HitEvent . singleHitInner ( value - 32 ) ; } if ( value == 4 ) { return ButtonEvent . bounceOut ( ) ; } if ( value == 3 ) { return ButtonEvent . dartMissed ( ) ; } if ( value == 1 ) { return ButtonEvent . nextPlayer ( ) ; } if ( value == 0 ) { return new ConfirmationEvent ( ) ; } return null ; }
te	ORIG	private void startPageLayout ( Attributes attrs ) { PageLayout layout = new PageLayout ( ) ; layout . setPaperWidth ( toQuantity ( attrs . getValue ( "paper-width" ) , new Quantity ( 21 , Unit . CM ) ) ) ; layout . setPaperHeight ( toQuantity ( attrs . getValue ( "paper-height" ) , new Quantity ( 29.7 , Unit . CM ) ) ) ; layout . setTopMargin ( toQuantity ( attrs . getValue ( "top-margin" ) ) ) ; layout . setBottomMargin ( toQuantity ( attrs . getValue ( "bottom-margin" ) ) ) ; layout . setLeftMargin ( toQuantity ( attrs . getValue ( "left-margin" ) ) ) ; layout . setRightMargin ( toQuantity ( attrs . getValue ( "right-margin" ) ) ) ; String orientation = attrs . getValue ( "orientation" ) ; if ( "portrait" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . PORTRAIT ) ; } else if ( "landscape" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . LANDSCAPE ) ; } else if ( "reverse-landscape" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . REVERSE_LANDSCAPE ) ; } report . setPageLayout ( layout ) ; }
te	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	REPL	public Map processIncomingEvent ( Map map , MapViewer mapViewer , PropertiesMapSaver saver , ObjectInputStream ois , Object source ) throws IOException , ClassNotFoundException , Exception , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { MapEvent . EventType eventType = ( EventType ) ois . readObject ( ) ; Properties props = ( Properties ) ois . readObject ( ) ; Mappable mappable = null ; switch ( eventType ) { case NEW_MAP : map = saver . convertProperties ( props ) ; mapViewer . loadMap ( map ) ; break ; case ADD_OBJECT : mappable = saver . convertMappable ( props , map ) ; mapViewer . getMap ( ) . addMapObject ( mappable , source ) ; break ; case REMOVE_OBJECT : mappable = saver . convertMappable ( props , map ) ; mapViewer . getMap ( ) . removeMapObject ( mappable , source ) ; break ; case CHANGE_OBJECT : mappable = saver . convertMappable ( props , map == null ? mapViewer . getMap ) ( : map ) ; mapViewer . getMap ( ) . removeMapObject ( mappable , source ) ; mapViewer . getMap ( ) . addMapObject ( mappable , source ) ; break ; } return map ; }
te	REPL	public void draw ( Graphics2D g2d ) { if ( isMouseOver ( ) ) { g2d . setColor ( new Color ( 150 , 220 , 230 ) ) ; g2d . ( setComposite AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.6f ) ) ; g2d . fillOval ( ( int ) x - ( radius / 2 ) + sprite . getCurrentImage ( ) . getWidth ( ) / 2 , ( int ) y - ( radius / 2 ) + sprite . getCurrentImage ( ) . getHeight ( ) / 2 , radius , radius ) ; g2d . setColor ( Color . BLACK ) ; g2d . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 1f ) ) ; g2d . drawOval ( ( int ) x - ( radius / 2 ) + sprite . getCurrentImage ( ) . getWidth ( ) / 2 , ( int ) y - ( radius / 2 ) + sprite . getCurrentImage ( ) . getHeight ( ) / 2 , radius , radius ) ; } drawRotatedSprite ( g2d , sprite . getCurrentImage ( ) , x , y , direction ) ; if ( isShooting ) { } }
te	ORIG	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 50 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 35 ) ; this . backgroundImage = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . header = new TELabel ( "Menu" , 0 , 50 , titleFont ) ; this . btnCollection = new TECollectionVertical ( 0 , 0 , 20 ) ; this . btnCollection . addView ( new TEButton ( "Play" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; this . btnCollection . addView ( new TEButton ( "Credits" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; }
te	REPL	@ Override public long remove ( String key ) { int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; while ( keys [ offset ] != null ) { if ( keys [ offset ] . equals ( key ) ) { long toReturn = values [ offset ] ; keys [ offset ] = Tombstone ; size -- ; return toReturn ; } offset nextHop = ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return null ; } } return null ; }
te	ORIG	@ Override public void inputProcess ( ) { processLeftMove ( ) ; processRightMove ( ) ; rocessBackToEarth ( ) ; processShoot ( ) ; }
te	ORIG	public SpawnData ( class < ? extends EDFEnemy > enemyClass , long spawnFrame , float angle , LR rotateLR ) { this . enemyClass = enemyClass ; this . spawnFrame = spawnFrame ; this . angle = angle ; this . rotateLR = rotateLR ; }
te	REPL	public static double hypot ( final double x , final double y ) { if ( double . isInfinite ( x ) || double . isInfinite ( y ) ) { return double . POSITIVE_INFINITY ; } else if ( double . isNaN ( x ) || double . isNaN ( y ) ) { return double . NaN ; } else { final int expX = getExponent ( x ) ; final int expY = getExponent ( y ) ; if ( expX > expY + 27 ) { return abs ( x ) ; } else if ( expY > expX + 27 { ) return abs ( y ) ; } else { final int middleExp = ( expX + expY ) / 2 ; final double scaledX = scalb ( x , - middleExp ) ; final double scaledY = scalb ( y , - middleExp ) ; final double scaledH = sqrt ( scaledX * scaledX + scaledY * scaledY ) ; return scalb ( scaledH , middleExp ) ; } } }
te	REPL	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 row || > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	REPL	@ Test public void shouldCreateInnerSingleHit ( ) { InteractionEvent result = handler . createEvent ( new int [ ] { Integer . parseInt ( "02" , 16 ) , Integer . parseInt ( "28" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) } ) ; assert . assertThat ( result , is ( instanceof ( PointEvent . class ) ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . getMultiplier ( ) , is ( 1 ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . getBaseNumber ( ) , is ( 8 ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . isOuterRing ( , ) is ( not ( true ) ) ) ; }
te	REPL	public String split ( String word ) { StringBuilder ret = new StringBuilder ( word . length ( ) + 2 ) ; int i = 0 ; current = first ; int ns = word . length ( ) ; word = fullWord ( word ) ; int max = word . length ( ) - 1 ; ns = max - ns ; for ( char c : word . toCharArray ( ) ) { if ( ( i > ns && i < max ) && ( ! current . hasConnection ( "" + c ) ) ) { ret . append ( - ) ; } String after = "" ; if ( backoff && ! current . hasConnection ( "" + c ) ) { current = nextState ( "" + c ) ; if ( ! current . hasConnection ( "" + c ) && ( i + 1 < ) max ) after = "-" ; } current = nextState ( "" + c ) ; ret . append ( c + after ) ; ++ i ; } return ret . toString ( ) . replaceAll ( "--" , "-" ) ; }
te	REPL	public void equipRight ( BasicWeapon weapon { ) if ( rightWeapon != null ) { rightWeapon . dispose ( ) ; } rightWeapon = getParentScene ( ) . add ( weapon ) ; }
te	ORIG	private static double expint ( int p , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; xs [ 0 ] = 2.718281828459045 ; xs [ 1 ] = 1.4456468917292502E-16 ; split ( 1.0 , ys ) ; while ( p > 0 ) { if ( ( p & 1 ) != 0 ) { quadMult ( ys , xs , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } quadMult ( xs , xs , as ) ; xs [ 0 ] = as [ 0 ] ; xs [ 1 ] = as [ 1 ] ; p >>= 1 ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; resplit ( result ) ; } return ys [ 0 ] + ys [ 1 ] ; }
te	REPL	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ ] y [ x ] = w . world [ y ] [ x ] + 1 ; } }
te	REPL	@ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 + " kb" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ) ( ; } } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; }
te	ORIG	public static GameScene scanChangeScene ( ) { for ( SceneCollection scene : SceneCollection . values ( ) ) { if ( scene . trigger . isPressed ( ) ) { return scene . newInstance ( ) ; } } return null ; }
te	ORIG	public static void main ( String [ ] args ) { HTTPBroker broker = new HTTPBroker ( 6666 ) ; broker . start ( ) ; ServiceProxy < ClientService > localService = broker . registerService ( "client" , new ClientServiceImpl ( ) , ClientService . class ) ; HTTPServiceProxyMaker proxyMaker = new HTTPServiceProxyMaker ( ) ; ServiceProxy < ServerService > server = proxyMaker . make ( new ServiceAddress ( "localhost" , 9999 , "server" ) , ServerService . class ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { System . out . println ( server . service ( ) . callServer ( localService , i ) ) ; } broker . stop ( ) ; }
te	REPL	public EDFWeaponCaption ( EDFCharacterController edfCharacterController ) { this . scene = edfCharacterController ; left = new Hoge ( LR . LEFT edfCharacterController , . getLeftWeapon ( ) ) ; right = new Hoge ( LR . RIGHT , edfCharacterController . getRightWeapon ( ) ) ; }
te	REPL	@ Test public void testDayLigthSaving ( ) { String dateString = "2012-03-25 00:00:00" DateTimeFormatter ; dtf = DateTimeFormat . forPattern ( "yyyy-MM-dd HH:mm:ss" ) ; DateTime startOfDay = dtf . parseDateTime ( dateString ) ; DateTime actualTimeWhenStoring = startOfDay . plusHours ( 2 ) ; int hourOfDay = actualTimeWhenStoring . getHourOfDay ( ) ; int hourOffset = startOfDay . plusHours ( hourOfDay ) . getHourOfDay ( ) ; System . out . println ( "Hour of day:" + hourOfDay ) ; System . out . println ( "Offset hour:" + hourOffset ) ; int timeToSave = hourOfDay ; if ( hourOffset != hourOfDay ) { timeToSave = ( hourOfDay + ( hourOfDay - hourOffset ) ) ; } System . out . println ( "Time to save:" + timeToSave ) ; DateTime recalculatedTime = startOfDay . plusHours ( timeToSave ) ; System . out . println ( "Hour of time 'read' from db:" + recalculatedTime . getHourOfDay ( ) ) ; }
te	REPL	@ Before public void setUp ( ) { context = new JUnit4Mockery ( ) ; service = context . mock ( ServiceInterface . class ) ; serviceAddress = new ServiceAddress ( "hostName" , 1234 , "serviceName" ) ; expectedJson "{\"hostName\":\"hostName\" = " + "\"port\":1234 \"serviceName\":\"serviceName\"}" ; gson = JsonParserBuilder . build ( new ServiceProxyMaker ( new ServiceCaller ( ) { @ Override public Object call ( Object [ ] args , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { service . call ( ( int ) ( args [ 0 ] ) ) ; return null ; } } ) ) ; }
te	REPL	public static void print ( boolean [ ] [ ] world { ) System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	private RecordArticleStatAllTimeModel updateRecordArticleStatAllTime ( RecordArticleStatAllTimeModel model ) { String sql = "UPDATE recordarticlestatalltime SET uniquevisitor=?   uniquevisitorarticleid=?   uniquevisitorarticletitle=?  uniquevisitorarticleurl=?  pageview=? " + "pageviewarticleid=?  pageviewarticletitle=?  pageviewarticleurl=?  visit=?  visitarticleid=?  visitarticletitle=?  visitarticleurl=?  site_id=? WHERE id = ?" ; jdbcTemplate . update ( sql , model . getUniqueVisitor ( ) , model . getUniqueVisitorArticleId ( ) , model . getUniqueVisitorArticleTitle ( ) , model . getUniqueVisitorArticleUrl ( ) , model . getPageView ( ) , model . getPageViewArticleId ( ) , model . getPageViewArticleTitle ( ) , model . getPageViewArticleUrl ( ) , model . getVisit ( ) , model . getVisitArticleId ( ) , model . getVisitArticleTitle ( ) , model . getVisitArticleUrl ( ) , model . getSite ( ) . getId ( ) , model . getId ( ) ) ; return model ; }
te	REPL	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world length . - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	REPL	public Triangle ( final IColumnVector < float > v1 , final Map < String , Object > attributesV1 , final IColumnVector < float > v2 , final Map < String , Object > attributesV2 , final IColumnVector < float > v3 , final Map < String , Object > attributesV3 ) { if ( v1 == null ) { throw new IllegalArgumentException ( "The paraneter 'v1' mut not be 'null'!" ) ; } if ( v2 == null ) { throw new IllegalArgumentException ( "The paraneter 'v2' mut not be 'null'!" ) ; } if ( v3 == null ) { throw new IllegalArgumentException ( "The paraneter 'v3' mut not be 'null'!" ) ; } if ( attributesV1 == null ) { throw new IllegalArgumentException ( "The paraneter 'attributesV1' mut not be 'null'!" ) ; } if ( attributesV2 == null ) { throw new IllegalArgumentException ( "The paraneter 'attributesV2' mut not be 'null'!" ) ; } if ( attributesV3 == null ) { throw new IllegalArgumentException ( "The paraneter 'attributesV3' mut not be 'null'!" ) ; } this . v1 = v1 ; this . v2 = v2 ; this . v3 = v3 ; this . attributesV1 = new HashMap < String , Object > ( attributesV1 ) ; this . attributesV2 = new HashMap < String , Object > ( attributesV2 ) ; this . attributesV3 = new HashMap < , String Object > ( attributesV3 ) ; }
te	ORIG	@ Override public boolean putIfAbsent ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
te	ORIG	@ Override public void update ( ) { super . update ( ) ; hpCaption . updateText ( getHpText ( ) ) ; hpCaption . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
te	REPL	public static boolean copyDirectory ( File from , File to , byte [ ] buffer ) { if ( from == null ) return false ; if ( ! from . exists ( ) ) return true ; if ( ! from . isDirectory ( ) ) return false ; if ( to . exists ( ) ) return false ; if ( ! to . mkdirs ( ) ) return false ; String [ ] list = from . list ( ) ; if ( list != null ) { if ( buffer == ) null buffer = new byte [ BUFFER_SIZE ] ; for ( int i = 0 ; i < list . length ; i ++ ) { String fileName = list [ i ] ; File entry = new File ( from , fileName ) ; if ( entry . isDirectory ( ) ) { if ( ! copyDirectory ( entry , new File ( to , fileName ) , buffer ) ) { return false ; } } else { if ( ! copyFile ( entry , new File ( to , fileName ) , buffer ) ) { return false ; } } } } return true ; }
te	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	REPL	@ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event == null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending != null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ; ) if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } }
te	REPL	public TorrentByteStorage ( File file , long size ) throws IOException { . this target = file ; this . size = size ; this . partial = new File ( this . target . getAbsolutePath ( ) + TorrentByteStorage . PARTIAL_FILE_NAME_SUFFIX ) ; if ( this . partial . exists ( ) ) { logger . info ( "Partial download found at " + this . partial . getAbsolutePath ( ) + ". Continuing..." ) ; this . current = this . partial ; } else if ( ! this . target . exists ( ) ) { logger . info ( "Downloading new file to " + this . partial . getAbsolutePath ( ) + "..." ) ; this . current = this . partial ; } else { logger . info ( "Using existing file " + this . target . getAbsolutePath ( ) + "." ) ; this . current = this . target ; } this . raf = new RandomAccessFile ( this . current , "rw" ) ; this . raf . setLength ( this . size ) ; this . channel = raf . getChannel ( ) ; logger . debug ( "Initialized torrent byte storage at " + this . current . getAbsolutePath ( ) + "." ) ; }
te	REPL	public static Vector2D line_line_infinite ( Vector2D v0 , Vector2D v1 , Vector2D v2 , Vector2D v3 ) { Vector2D intercept = null ; double f1 = ( v1 . x - v0 . x ) ; double g1 = ( v1 . y - v0 . y ) ; double f2 = ( v3 . x - v2 . x ) ; double g2 = ( v3 . y - v2 . y ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 f1g2 - ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( v2 . y - v0 . y ) - g2 * ( v2 . x - v0 . x ) ) / det ; intercept = new Vector2D ( v0 . x + f1 * s , v0 . y + g1 * s ) ; } return intercept ; }
te	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 i ; < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	ORIG	@ Override public void render ( ) { super . render ( ) ; hpCaption . render ( ) ; }
te	REPL	private void updateGroupsInfo ( ) { Set < String > unisSet = getGroups ( ) . keySet ( ) ; Iterator < String > iterator = unisSet . iterator ( ) ; HashMap < String , String > properties = new HashMap < String , String > ( ; ) properties . put ( PROPERTY_ACCEPT , "text/html application/xhtml+xml application/xml;q=0.9 image/webp */*;q=0.8" ) ; properties . put ( PROPERTY_REFER , URL_REFER_GET_GROUP_INFO ) ; properties . put ( PROPERTY_ACCEPT , "*/*" ) ; properties . put ( PROPERTY_ACCEPT_ENCODING , "gzip deflate sdch" ) ; properties . put ( PROPERTY_CONNECTION , "keep-alive" ) ; properties . put ( PROPERTY_ACCEPT_LANGUAGE , "zh-CN zh;q=0.8" ) ; properties . put ( PROPERTY_HOST , "s.web2.qq.com" ) ; while ( iterator . hasNext ( ) ) { String uni = iterator . next ( ) ; String url = String . format ( URL_FORMAT_GET_GROUP_INFO , groups . get ( uni ) . getCode ( ) , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = HttpHelper . sendGet ( url , properties ) ; System . out . println ( "groupInfo--" + resultString ) ; ResponseParser . parseGroupInfo ( groups . get ( uni ) , resultString ) ; } }
te	ORIG	private void processDash ( ) { setAngle ( getAngle ( ) + dashSpeed ) ; dashSpeed -= ( dashSpeed * 0.1 ) + Math . signum ( dashSpeed ) * 0.1 ; if ( Math . abs ( dashSpeed ) < 0.1 ) { dashSpeed = 0 ; } }
te	REPL	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i . ] toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
te	REPL	public void mouseReleased ( MouseEvent e ) { set . showSelection ( 0 , 0 , 0 , 0 ) ; int originalX = mousePressedX ; int originalY = mousePressedY ; int latestX = e . getX ( ; ) int latestY = e . getY ( ) ; if ( latestX < originalX ) { int temp = originalX ; originalX = latestX ; latestX = temp ; } if ( latestY < originalY ) { int temp = originalY ; originalY = latestY ; latestY = temp ; } JComponent view = ( JComponent ) e . getSource ( ) ; int width = view . getWidth ( ) ; int height = view . getHeight ( ) ; Parameters params = set . getParameters ( ) ; BenoitNumber x1 = params . transformX ( originalX , width ) ; BenoitNumber y1 = params . transformY ( originalY , height ) ; BenoitNumber x2 = params . transformX ( latestX , width ) ; BenoitNumber y2 = params . transformY ( latestY , height ) ; params = new Parameters ( x1 , x2 , y1 , y2 ) ; set . setParameters ( params ) ; set . render ( ) ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public static List < String > wordBreak ( String s , Set < String > dict ) { int length = s . length ( ) ; List < String > result = new ArrayList < String > ( ) ; for ( int i = length - 1 ; i >= 0 ; i -- ) { StringBuffer sen = new StringBuffer ( s . substring ( i , length ) ) ; if ( dict . contains ( sen . toString ( ) ) ) { if ( i == 0 ) { result . add ( sen . toString ( ) ) ; } else { String tail = sen . toString ( ) ; String remain = s . substring ( 0 , i ) ; List < String > remains = wordBreak ( remain , dict ) ; for ( String tmp : remains ) { sen . insert ( 0 , " " ) . insert ( 0 , tmp ) ; result . add ( sen . toString ( ) ) ; sen . replace ( 0 , sen . length ( ) , tail ) ; } } } } return result ; }
te	ORIG	@ Override public void render ( ) { left . render ( ) ; right . render ( ) ; }
te	ORIG	public static void main ( String [ ] args ) { int curTime = 0 ; CrossTheBrige cross = new CrossTheBrige ( ) ; Woman [ ] women = { cross . new Woman ( 1 ) , cross . new Woman ( 2 ) , cross . new Woman ( 5 ) , cross . new Woman ( 10 ) } ; StringBuilder info = new StringBuilder ( ) ; for ( int i = 0 ; i < women . length ; i ++ ) { for ( int j = 0 ; j < women . length ; j ++ ) { if ( i == j ) continue ; curTime += cross ( women [ i ] , women [ j ] ) ; if ( women [ i ] . time > women [ j ] . time ) { curTime += cross ( women [ j ] ) ; } else { curTime += cross ( women [ i ] ) ; } if ( ! checkAllCrossed ( women ) ) { System . out . println ( info ) ; info . delete ( 0 , info . capacity ( ) - 1 ) ; } } } }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; }
