tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	9X	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	3	public String getMimetype ( String paramString ) { int i = paramString . lastIndexOf ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramString . length ( ) ) ) { String str1 = paramString . substring ( i + 1 ) ; if ( this . extensionToMimetypeMap . keySet ( ) . contains ( str1 ) ) { String str2 = ( String ) this . extensionToMimetypeMap . get ( str1 ) ; logger . info ( "Recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "Extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "File name has no extension  mime type cannot be recognised for: " + paramString ) ; } return "application/octet-stream" ; }
tr	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	7	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	9X	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	8	public static Object subtract ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) - ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) - ( ( Number ) val1 ) . intValue ( ) ; } return val0 == null ? null : val1 == null ? val0 : Classes . toString ( val0 ) . replace ( Classes . toString ( val1 ) , "" ) ; }
tr	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	5	public static Integer createOfficeObject ( Integer OFFICE_OBJECT_TYPE_ID ) { Integer id = getUniqueId ( ) ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , id ) ; ps . setString ( 2 , "" ) ; ps . setInt ( 3 , OFFICE_OBJECT_TYPE_ID ) ; ps . setInt ( 4 , OfficeObject . ALL_IS_OK ) ; ps . executeUpdate ( ) ; } catch ( MySQLIntegrityConstraintViolationException e ) { e . printStackTrace ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return id ; }
tr	9X	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	1	@ Override public boolean equals ( Object other ) { if ( other instanceof NewId ) { return this . equals ( ( NewId ) other ) ; } return false ; }
tr	7	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	5	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	5	public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Card ) ) return false ; Card aCard = ( Card ) o ; if ( ( aCard . suitID == this . suitID ) && ( aCard . nonTrumpCardValue == this . nonTrumpCardValue ) && ( aCard . trumpCardValue == this . trumpCardValue ) ) return true ; return false ; }
tr	8	public List < HackResult > grok ( Reader reader ) throws IOException { long t0 = System . currentTimeMillis ( ) ; _HackContainer o = new _HackContainer ( ) ; Type t = new TypeToken < _HackContainer > ( ) { } . getType ( ) ; o = GSON . fromJson ( reader , t ) ; if ( o == null ) throw new IOException ( "GSON returned null!" ) ; L . info ( "Claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new IOException ( "GSON did not find objects!" ) ; List < HackResult > res = new ArrayList < HackResult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int canGetUltraCount = 0 ; for ( _HackRow r : o . rows ) { ++ count ; HackResult h = r . doc ; h . sourceLine = count ; if ( h . resos == null || h . hacker == null ) { L . warn ( "Skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( L . isTraceEnabled ( ) ) L . trace ( String . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hasCanGetUltra ( ) ) canGetUltraCount ++ ; total += h . getItemCount ( ) ; res . add ( h ) ; } long t1 = System . currentTimeMillis ( ) ; L . info ( "*** " + res . size ( ) + " hacks for " + total + " items  canGetUltraCount=" + canGetUltraCount + "  lengthCheck=" + ( res . size ( ) != o . total_rows ? "WARNING" : "OK" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	3	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	6	public static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	2	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterEscreva ( this ) ; }
tr	8	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	3	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	3	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	8	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	9X	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	6	@ Override public int loginUsuario ( String login , String password ) throws RemoteException { int result = - 1 ; ArrayList < UsuarioInt > usuarios = obtenerUsuarios ( ) ; for ( UsuarioInt usuario : usuarios ) { if ( login . compareTo ( usuario . getLogin ( ) ) == 0 && password . compareTo ( usuario . getPassword ( ) ) == 0 ) { if ( usuario . getAdmin ( ) ) { result = 2 ; } else { result = 1 ; } } else if ( login . compareTo ( usuario . getLogin ( ) ) == 0 || password . compareTo ( usuario . getPassword ( ) ) == 0 ) { result = 0 ; } } return result ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Menu ( ) . setVisible ( true ) ; } } ) ; }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	5	@ Test public void buildsGraph ( ) { Point p1 = vc . addPoint ( 0 , 0 ) ; Point p2 = vc . addPoint ( 1 , - 1 ) ; Point p3 = vc . addPoint ( 1 , 1 ) ; Point p4 = vc . addPoint ( 1.5 , 0.0 ) ; Point p5 = vc . addPoint ( 4 , - 1 ) ; Point p6 = vc . addPoint ( 4 , 1 ) ; p1 . setRight ( p2 ) ; p2 . setLeft ( p1 ) ; p3 . setRight ( p1 ) ; p1 . setLeft ( p3 ) ; p2 . setRight ( p3 ) ; p3 . setLeft ( p2 ) ; p4 . setRight ( p5 ) ; p5 . setLeft ( p4 ) ; p6 . setRight ( p4 ) ; p4 . setLeft ( p6 ) ; p5 . setRight ( p6 ) ; p6 . setLeft ( p5 ) ; vc . buildGraph ( ) ; Tree < Vertex > testadj1 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj2 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj3 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj4 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj5 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj6 = new Tree < > ( new VertexComparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; assertTrue ( p1 . getAdjacents ( ) . equals ( testadj1 ) && p2 . getAdjacents ( ) . equals ( testadj2 ) && p3 . getAdjacents ( ) . equals ( testadj3 ) && p4 . getAdjacents ( ) . equals ( testadj4 ) && p5 . getAdjacents ( ) . equals ( testadj5 ) && p6 . getAdjacents ( ) . equals ( testadj6 ) ) ; }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	8	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
tr	9X	public boolean isMatching ( StringBuffer word , int wordPos ) { boolean matching = true , inMulti = false , multiMatch = false ; char matchCh ; for ( int matchPos = 0 ; matchPos < match . length ; matchPos ++ ) { matchCh = match [ matchPos ] ; if ( matchCh == STARTMULTI || matchCh == ENDMULTI ) { inMulti = ! inMulti ; if ( ! inMulti ) matching = matching & multiMatch ; else multiMatch = false ; } else { if ( matchCh != word . charAt ( wordPos ) ) { if ( inMulti ) multiMatch = multiMatch | false ; else matching = false ; } else { if ( inMulti ) multiMatch = multiMatch | true ; else matching = true ; } if ( ! inMulti ) wordPos ++ ; if ( ! matching ) break ; } } if ( end && wordPos != word . length ( ) ) matching = false ; return matching ; }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	9X	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	4	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	7	public void connect ( TreeLinkNode root ) { if ( root == null || root . left == null || root . right == null ) { return ; } if ( root . left != null ) { root . left . next = root . right ; } if ( root . right != null && root . next != null ) { root . right . next = root . next . left == null ? null : root . next . left ; } connect ( root . left ) ; connect ( root . right ) ; }
tr	2	private void selectElement ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON1 && e . getSource ( ) != table ) table . clearSelection ( ) ; }
tr	9X	@ Override public Orientation getStepOrientation ( int lineIndex ) { switch ( lineIndex ) { case 0 : case 5 : return Orientation . DOWN_LEFT ; case 1 : case 6 : return Orientation . UP_LEFT ; case 2 : case 7 : return Orientation . CENTER ; case 3 : case 8 : return Orientation . UP_RIGHT ; case 4 : case 9 : return Orientation . DOWN_RIGHT ; default : return Orientation . NONE ; } }
tr	9X	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	4	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	5	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	4	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	2	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	2	@ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof abort_result ) return this . equals ( ( abort_result ) that ) ; return false ; }
tr	7	public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( DB_URL , USER , PASS ) ; stmt = conn . createStatement ( ) ; String sql ; sql = "SELECT * FROM Transport" ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; System . out . print ( "ID: " + id ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se2 ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } }
tr	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	9X	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c ==  || c ==  ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	7	static final public void sum ( ) throws ParseException { term ( ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : case MINUS : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : jj_consume_token ( + ) ; break ; case MINUS : jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } term ( ) ; } }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	9X	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	2	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	4	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt || der instanceof TipoFloat ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return new TipoBooleano ( ) ; } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
tr	4	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	2	@ Override public void close ( final String guiName ) { if ( ! guiThreads . get ( guiName ) . isAlive ( ) ) { return ; } running = false ; try { guiThreads . get ( guiName ) . join ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	1	public List < SchoolVO > getSchools ( ) { if ( schools == null ) { schools = new ArrayList < SchoolVO > ( ) ; } return this . schools ; }
tr	9X	public static GregorianCalendar lireDate ( String date ) { boolean ok = false ; String [ ] champsDate ; int jour = 1 ; int mois = 0 ; int an = 0 ; GregorianCalendar dateSaisie = null ; champsDate = date . split ( "/" ) ; ok = true ; if ( champsDate . length >= 1 ) { try { mois = Integer . parseInt ( champsDate [ 0 ] ) ; if ( ( mois < 1 ) || ( mois > 12 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { mois = moisCourant ( ) ; } if ( champsDate . length == 2 ) { try { an = Integer . parseInt ( champsDate [ 1 ] ) ; if ( ( an < 1900 ) || ( an > 2100 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { an = anneeCourante ( ) ; } if ( ok ) { dateSaisie = new GregorianCalendar ( an , mois - 1 , jour ) ; return dateSaisie ; } else { return null ; } }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	3	private void timeButtonMouseClicked ( java . awt . event . MouseEvent evt ) { JOptionPane infoPopup = new JOptionPane ( ) ; int n = JOptionPane . showConfirmDialog ( null , "Are you sure you want to quit?" , "End game" , JOptionPane . YES_NO_OPTION ) ; Result r = new Result ( ) ; ResultContainer cont = new ResultContainer ( ) ; String s = new String ( ) ; if ( n == JOptionPane . YES_OPTION ) { s = JOptionPane . showInputDialog ( null , "Please type your name below: " , "Type your name" , JOptionPane . PLAIN_MESSAGE ) ; System . out . println ( s ) ; if ( s != null ) r . setName ( s ) ; if ( this . empire . getTotalSeconds ( ) > 0 ) r . setSeconds ( this . empire . getTotalSeconds ( ) ) ; infoPopup . setVisible ( false ) ; cont . addAndSerialize ( r ) ; System . exit ( 0 ) ; } }
tr	2	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	2	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	7	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	2	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	5	@ Override public boolean onRequest ( HttpRequest request , HttpResponse response ) throws Exception { String filePath = request . getRequestedFilePath ( ) ; if ( urlToMapTo != null ) { if ( ! filePath . startsWith ( urlToMapTo ) ) return false ; filePath = filePath . substring ( urlToMapTo . length ( ) ) ; } File file = new File ( directory , filePath ) ; if ( ! file . isFile ( ) || ! file . canRead ( ) || ! file . getAbsolutePath ( ) . startsWith ( directory . getAbsolutePath ( ) ) ) return false ; IOFileChannelInputBuffer buffer = new IOFileChannelInputBuffer ( new FileInputStream ( file ) . getChannel ( ) ) ; response . setHeader ( "content-type" , mimeNameMap . getContentTypeFor ( file . getAbsolutePath ( ) ) ) ; response . setBodyBuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	9X	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case FVB : description = "FVB" ; break ; case RVB : description = "RVB" ; break ; case RPB : description = "RPB" ; break ; case FPB : description = "FPB" ; break ; case FVW : description = "FVW" ; break ; case RVW : description = "RVW" ; break ; case RPW : description = "RPW" ; break ; case FPW : description = "FPW" ; break ; case static : description = "Static" ; break ; case OTHER : description = "Other" ; break ; } return description ; }
tr	3	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	@ Override public boolean equals ( Object obj ) { if ( obj instanceof GRGProteinNode ) { GRGProteinNode other = ( GRGProteinNode ) obj ; return this . node . equals ( other . node ) ; } else { return false ; } }
tr	7	private void computerNextTurn ( ) { if ( ! getGame ( ) . gameWon ( ) ) { new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( ANIMATION_TIME ) ; } catch ( Exception e ) { } if ( ! getGame ( ) . getPlayer ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS ) . getPlayerType ( ) . equals ( "Human" ) ) { int playerTurn = getGame ( ) . getPlayerTurn ( ) ; int x ; if ( ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_ONE && m_playerOneType == "Computer: Easy" ) || ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_TWO && m_playerTwoType == "Computer: Easy" ) ) { ConnectFourEasyComputerPlayer player = ( ConnectFourEasyComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } else { ConnectFourHardComputerPlayer player = ( ConnectFourHardComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } performMove ( x ) ; getGame ( ) . incrementTurn ( ) ; } } } ) . start ( ) ; } }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	6	protected final Object computeRange ( ) { final List < double [ ] > raRange = new ArrayList < double [ ] > ( ) ; final double [ ] decRange = new double [ 2 ] ; if ( this . isPolesCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isNorthPoleCollision ( ) ) { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isSouthPoleCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; if ( this . isBorderRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMaxRaCollision ( ) ) { raRange . add ( new double [ ] { raUser - sizeArray [ 0 ] / 2.0 , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMinRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , raUser + sizeArray [ 0 ] / 2.0 } ) ; raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } } return Arrays . asList ( raRange , decRange ) ; }
tr	8	public static String [ ] splitbyLetter2 ( CharSequence text ) { list . clear ( ) ; int pos = 0 ; int len = text . length ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charAt ( i ) ; if ( c > 58 ) { if ( first ) { first = false ; buffer [ pos ++ ] = c ; continue ; } list . add ( new String ( buffer , 0 , pos ) ) ; pos = 0 ; buffer [ pos ++ ] = c ; } else if ( c == 32 || c == 10 || c == 47 || c == 13 || c == 9 ) { } else { buffer [ pos ++ ] = c ; } } list . add ( new String ( buffer , 0 , pos ) ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
tr	5	protected void doNext ( ) { doStop ( ) ; runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { selectedIndex ++ ; setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	5	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	6	public Map < String , String > readAdjNounSent ( ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "unsupervisedClauseMarkup.readAdjNounSent" ) ; if ( this . myDataHolder == null ) { return null ; } Map < String , String > myAdjNounSent = new HashMap < String , String > ( ) ; Iterator < SentenceStructure > iter = this . myDataHolder . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String modifier = sentenceObject . getModifier ( ) ; String tag = sentenceObject . getTag ( ) ; myLogger . trace ( "tag: " + tag ) ; if ( ( modifier != null ) && ( tag != null ) ) { if ( ( ! ( modifier . equals ( "" ) ) ) && ( tag . matches ( "^\\[.*$" ) ) ) { modifier = modifier . replaceAll ( "\\[.*?\\]" , "" ) . trim ( ) ; myAdjNounSent . put ( tag , modifier ) ; } } } return myAdjNounSent ; }
tr	2	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
tr	4	public static ArrayList < String > getCluster ( String token ) { if ( singleton == null ) { singleton = new BrownFeaturizer ( ) ; singleton . init ( new Model ( ) ) ; } ArrayList < String > list = new ArrayList < String > ( ) ; String cluster = singleton . mappingS . get ( token ) ; if ( cluster == null ) { cluster = "NONE" ; } else { for ( int len : LEN ) { if ( cluster . length ( ) >= len ) { String pf = cluster . substring ( 0 , len ) ; list . add ( "CLUST_" + len + "_" + pf ) ; } } list . add ( "CLUST_ALL_" + cluster ) ; } return list ; }
tr	9X	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	5	public String checkDataEntry ( ) { if ( efastAnalysisPanel1 . parameterScreen . directoryChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) . equals ( "" ) || efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . parametersModel . contains ( "None Entered" ) ) { return "No parameters have been selected" ; } else { try { Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) ) ; Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Number of curves and parameter samples must be integers" ; } } }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	6	public synchronized void doRanking ( ) { calculate_tf_idf_q ( ) ; Query q ; for ( String term : queryTerms . keySet ( ) ) { term = term . trim ( ) ; q = queryTerms . get ( term ) ; q . setPostings ( getPostingsFor ( term ) ) ; if ( q . getPostings ( ) == null ) { System . out . println ( "sry. no postings found" ) ; continue ; } for ( Posting p : q . getPostings ( ) . getPostings ( ) ) { float value = ( float ) ( q . getTf_idf ( ) * calculate_tf_idf_d ( p , q . getPostings ( ) . getOverallFrequency ( ) ) ) ; Score s = new Score ( ) ; s . setScore ( value ) ; s . setId ( p . getDocID ( ) ) ; if ( ! scores . containsKey ( p . getDocID ( ) ) ) { scores . put ( p . getDocID ( ) , s ) ; } else { Score sc = scores . get ( p . getDocID ( ) ) ; float score = sc . getScore ( ) ; score += value ; sc . setScore ( score ) ; scores . put ( p . getDocID ( ) , sc ) ; } } } float newScore , lengthV ; Score s ; for ( String id : scores . keySet ( ) ) { s = scores . get ( id ) ; try { newScore = s . getScore ( ) / length . get ( id ) . floatValue ( ) ; s . setScore ( newScore ) ; scores . put ( id , s ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	3	@ Override public void setInitialized ( short mask , float value ) { switch ( mask ) { case Constants . F_MASK : f = value ; break ; case Constants . X_MASK : x = value ; break ; case Constants . Y_MASK : y = value ; break ; default : break ; } }
tr	1	@ Test public void testIdentifierOptionalPresentButNull ( ) throws TemplateException { Identifier variable = new Identifier ( "$variable?" , new Cursor ( "-:l1:c1" ) ) ; populateModel ( "variable" , null ) ; try { variable . writeObject ( null , model , null ) ; fail ( "An exception must be raised." ) ; } catch ( TemplateIgnoreRenderingException e ) { assertEquals ( "Ignore rendering because key 'variable' is not present or has null value in the model map at position '-:l1:c1'." , e . getMessage ( ) ) ; } }
tr	0	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
tr	1	public static void input ( float delta ) { if ( nextScene != null ) { updateLoadScene ( ) ; } rootNode . input ( delta ) ; }
tr	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
tr	9X	private void setDebug ( final ComponentWrapper parentW , boolean b ) { if ( b && ( debugTimer == null || debugTimer . getDelay ( ) != getDebugMillis ( ) ) ) { if ( debugTimer != null ) debugTimer . stop ( ) ; ContainerWrapper pCW = parentW . getParent ( ) ; final Component parent = pCW != null ? ( Component ) pCW . getComponent ( ) : null ; debugTimer = new Timer ( getDebugMillis ( ) , new MyDebugRepaintListener ( ) ) ; if ( parent != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Container p = parent . getParent ( ) ; if ( p != null ) { if ( p instanceof JComponent ) { ( ( JComponent ) p ) . revalidate ( ) ; } else { parent . invalidate ( ) ; p . validate ( ) ; } } } } ) ; } debugTimer . setInitialDelay ( 100 ) ; debugTimer . start ( ) ; } else if ( ! b && debugTimer != null ) { debugTimer . stop ( ) ; debugTimer = null ; } }
tr	1	@ Override public void setDataVector ( Vector newData , Vector columnNames ) { if ( newData == null ) { throw new IllegalArgumentException ( "setDataVector1() - Null parameter" ) ; } super . setDataVector ( dataVector , columnNames ) ; dataVector = newData ; attributiveModel = new DefaultCellAttribute ( dataVector . size ( ) , columnIdentifiers . size ( ) ) ; newRowsAdded ( new TableModelEvent ( this , 0 , getRowCount ( ) - 1 , TableModelEvent . ALL_COLUMNS , TableModelEvent . INSERT ) ) ; }
tr	7	public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
tr	6	public void start ( ) throws IllegalStateException { if ( instructions == null || endgamewindow == null || gameboard == null || lobby == null || loginsingup == null || newgame == null ) throw new IllegalStateException ( ) ; done = false ; attempConnection ( ) ; setState ( ModelStates . loginsingup ) ; newgame . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; endgamewindow . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; Thread myThread = new Thread ( this ) ; myThread . start ( ) ; }
tr	3	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
tr	9X	public void initConvexe ( ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; next . convexe = new Convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { Classe classe = vectClasses . elementAt ( classes [ i ] ) ; if ( classe . envDessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getK ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . envDessinee ) { next . convexe . calculBarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	2	public void update ( float deltaTimeElapsedMs ) { speedX = bg1 . getSpeedX ( ) * 5 ; tileX += Util . factorByElapsedTimeMs ( speedX , deltaTimeElapsedMs ) ; tileBoundary . setBounds ( tileX , tileY , 40 , 40 ) ; if ( tileBoundary . intersects ( Player . perimeter ) && type != 0 ) { checkHorizontalCollision ( ) ; checkVerticalCollision ( ) ; } }
tr	1	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	2	private static List < List < String >> clone ( List < List < String >> original ) { List < List < String >> clone = new ArrayList < List < String >> ( original . size ( ) ) ; for ( List < String > oStrings : original ) { List < String > cStrings = new ArrayList < String > ( oStrings . size ( ) ) ; for ( String oString : oStrings ) { cStrings . add ( oString ) ; } clone . add ( cStrings ) ; } return clone ; }
tr	8	public HashMap < Integer , Integer > getSgd2iesdhcmap ( ) { if ( sgd2iesdhcmap != null ) { return sgd2iesdhcmap ; } sgd2iesdhcmap = new HashMap < Integer , Integer > ( ) ; String SQL1 = "SELECT id  TIME_FORMAT(inicio '%H:%i') AS inicio  TIME_FORMAT(fin '%H:%i') AS fin FROM horascentro" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getInt ( "id" ) ; String inicio = rs1 . getString ( "inicio" ) ; String fin = rs1 . getString ( "fin" ) ; String SQL2 = "SELECT codigo from sig_hores_classe WHERE inicio='" + inicio + "' AND fin='" + fin + "'" ; Statement st2 = getMysql ( ) . createStatement ( ) ; ResultSet rs2 = getMysql ( ) . getResultSet ( SQL2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { sgd2iesdhcmap . put ( id , rs2 . getInt ( 1 ) ) ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( HoraCentro . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return sgd2iesdhcmap ; }
tr	4	public void testFetchGroupsForUser ( ) { Group [ ] groups = ga . fetchGroupsForUser ( 1 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 2 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 3 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 1 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 1 ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 5 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 2 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 2 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 2 ] . isIsactive ( ) ) ; } }
tr	9X	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	5	public double readDouble ( String prompt , double low , double high ) { String msg = null ; while ( true ) { String line = readLine ( prompt ) ; try { double d = double . valueOf ( line ) . doubleValue ( ) ; if ( d >= low && d <= high ) return d ; msg = "Value is outside the range [" + low + ":" + high + "]" ; } catch ( NumberFormatException ex ) { msg = "Illegal numeric format" ; } showErrorMessage ( msg ) ; if ( prompt == null ) prompt = "Retry: " ; } }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case QUEUE_NAME : if ( value == null ) { unset_queue_name ( ) ; } else { set_queue_name ( ( String ) value ) ; } break ; case MAX_ITEMS : if ( value == null ) { unset_max_items ( ) ; } else { set_max_items ( ( Integer ) value ) ; } break ; case TIMEOUT_MSEC : if ( value == null ) { unset_timeout_msec ( ) ; } else { set_timeout_msec ( ( Integer ) value ) ; } break ; case AUTO_ABORT_MSEC : if ( value == null ) { unset_auto_abort_msec ( ) ; } else { set_auto_abort_msec ( ( Integer ) value ) ; } break ; } }
tr	4	public static void create ( String [ ] args ) { Vector < vslFileDataChunk > chunks = null ; if ( args . length < 3 ) { System . err . println ( "Missings args: create <dbfile> <source>" ) ; System . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkFile ( source ) ; vslDataType < vslFileDataChunk > fileData = new vslDataType < vslFileDataChunk > ( ) ; StringTokenizer st = new StringTokenizer ( source , "/" ) ; String fname = "UNSET" ; while ( st . hasMoreTokens ( ) ) { fname = st . nextToken ( ) ; } fileData . setName ( fname ) ; for ( vslFileDataChunk chunk : chunks ) { fileData . addNewChunk ( chunk ) ; } core . addEntry ( fileData ) ; core . debugShow ( ) ; core . save ( ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	1	public int getMaxQuantity ( int quantity ) { if ( currentQuantity + quantity > maxQuantity ) { throw new StoreProblemException ( ) ; } return currentQuantity + quantity ; }
tr	6	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	4	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	4	public graph ( String C , String type , String interval , String r ) throws SQLException { super ( "Bar Chart" ) ; connnect = new sqlConnection ( ) ; sql = new selectQueries ( ) ; sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; int inte = Integer . parseInt ( interval ) ; ResultSet item = sql . getGraph1 ( conn , type , inte ) ; int i = 0 ; ResultSetMetaData md = item . getMetaData ( ) ; int count = md . getColumnCount ( ) ; String [ ] list = new String [ count ] ; int i1 = 0 ; while ( item . next ( ) ) { list [ i1 ] = item . getString ( "rcm_id" ) ; i1 ++ ; } BarChart chart = new BarChart ( ) ; Object [ ] col = new Object [ ] { Color . red , Color . green , Color . blue , Color . black , Color . pink , Color . yellow , Color . DARK_GRAY } ; for ( int p = 0 ; p < count ; p ++ ) { if ( p == col . length - 1 ) { break ; } try { chart . addBar ( ( Color ) col [ p ] , Integer . parseInt ( list [ p ] ) ) ; } catch ( Exception e ) { System . out . println ( "Exception occured here" ) ; } } getContentPane ( ) . setBackground ( Color . CYAN ) ; getContentPane ( ) . add ( chart ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; pack ( ) ; setVisible ( true ) ; }
tr	6	public void advance ( ) { timeUntilNext -- ; if ( timeUntilNext <= 0 ) { stoppingAt ( ) ; if ( ! reverse && nextStation . getNext ( ) == null ) { reverse = true ; timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; return ; } if ( reverse && nextStation . getPrev ( ) == null ) { reverse = false ; timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; return ; } if ( reverse ) { timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; } else { timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; } } }
tr	8	private QuerySet < T > isNull ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . trim ( ) . toLowerCase ( ) ; query = query . replace ( "__isnull" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; boolean isNull = boolean . parseBoolean ( queryComponents [ 1 ] ) ; Field field = null ; try { if ( fieldName . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { if ( isNull ) { if ( field . get ( model ) == null ) { querySet . add ( model ) ; } } else { if ( field . get ( model ) != null ) { querySet . add ( model ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	1	protected void checkKey ( K k ) { if ( k == null ) { throw new InvalidKeyException ( "Invalid key: null." ) ; } }
tr	5	public Calendar getMaxDueDate ( ) { Calendar result = Calendar . getInstance ( ) ; Calendar max = null ; Calendar toCheck ; if ( tasks != null && tasks . size ( ) > 0 ) { for ( Task t : tasks ) { toCheck = t . getDueDate ( ) ; if ( max == null || toCheck . compareTo ( max ) > 0 ) { max = toCheck ; } } result . set ( Calendar . YEAR , max . get ( Calendar . YEAR ) ) ; result . set ( Calendar . MONTH , max . get ( Calendar . MONTH ) ) ; result . set ( Calendar . DAY_OF_MONTH , max . get ( Calendar . DAY_OF_MONTH ) ) ; } return result ; }
tr	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	5	@ Test public void testPacketSending ( ) throws SocketException { MicroSecondsTimeStamp stamper = mock ( MicroSecondsTimeStamp . class ) ; when ( stamper . timeStamp ( ) ) . thenReturn ( 0 ) ; UtpAlgorithm algorithm = new UtpAlgorithm ( stamper , new InetSocketAddress ( 51235 ) ) ; UtpAlgConfiguration . SEND_IN_BURST = true ; UtpAlgConfiguration . MAX_BURST_SEND = 3 ; int packetLength = 1000 ; algorithm . setMaxWindow ( packetLength * 10 ) ; UtpTimestampedPacketDTO pkt5 = createPacket ( 5 , packetLength ) ; UtpTimestampedPacketDTO pkt6 = createPacket ( 6 , packetLength ) ; UtpTimestampedPacketDTO pkt7 = createPacket ( 7 , packetLength ) ; UtpTimestampedPacketDTO pkt8 = createPacket ( 8 , packetLength ) ; UtpTimestampedPacketDTO pkt9 = createPacket ( 9 , packetLength ) ; algorithm . markPacketOnfly ( pkt5 . utpPacket ( ) , pkt5 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt6 . utpPacket ( ) , pkt6 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt7 . utpPacket ( ) , pkt7 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt8 . utpPacket ( ) , pkt8 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt9 . utpPacket ( ) , pkt9 . dataGram ( ) ) ; assertEquals ( 5 * ( UtpPacketUtils . DEF_HEADER_LENGTH + packetLength ) , algorithm . getCurrentWindow ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; algorithm . setMaxWindow ( packetLength * 4 ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } algorithm . setMaxWindow ( 10 * packetLength ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; }
tr	6	private void comparePackageParts ( TIPP p1 , TIPP p2 ) throws Exception { Collection < TIPPSection > s1 = p1 . getSections ( ) ; Collection < TIPPSection > s2 = p2 . getSections ( ) ; assertNotNull ( s1 ) ; assertNotNull ( s2 ) ; for ( TIPPSection s : s1 ) { TIPPSectionType type = s . getType ( ) ; List < ? extends TIPPFile > o1 = s . getFileResources ( ) ; TIPPSection _s = p2 . getSection ( type ) ; assertEquals ( s , _s ) ; List < ? extends TIPPFile > o2 = _s . getFileResources ( ) ; assertNotNull ( o1 ) ; assertNotNull ( o2 ) ; assertEquals ( o1 , o2 ) ; Iterator < ? extends TIPPFile > fit1 = o1 . iterator ( ) ; Iterator < ? extends TIPPFile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasNext ( ) ) { TIPPFile f1 = fit1 . next ( ) ; assertTrue ( fit2 . hasNext ( ) ) ; TIPPFile f2 = fit2 . next ( ) ; assertEquals ( f1 , f2 ) ; try ( InputStream is1 = p1 . getFile ( f1 ) ; InputStream is2 = p2 . getFile ( f2 ) ) { verifyBytes ( is1 , is2 ) ; } } } }
tr	7	public static void main ( String [ ] args ) { BigInteger totalSum = BigInteger . ZERO ; for ( int i = 2 ; i <= 4 ; i ++ ) { BigInteger [ ] [ ] arrangements = new BigInteger [ 51 ] [ 50 ] ; for ( int j = 0 ; j <= 50 ; j ++ ) for ( int k = 0 ; k < 50 ; k ++ ) arrangements [ j ] [ k ] = BigInteger . ZERO ; arrangements [ 1 ] [ 0 ] = BigInteger . ONE ; for ( int j = 1 ; j < 50 ; j ++ ) { for ( int k = 1 ; k <= 50 ; k ++ ) arrangements [ k ] [ j ] = arrangements [ k - 1 ] [ j - 1 ] ; for ( int k = i ; k <= 50 ; k ++ ) arrangements [ 0 ] [ j ] = arrangements [ 0 ] [ j ] . add ( arrangements [ k ] [ j ] ) ; } for ( int j = 0 ; j < 50 ; j ++ ) totalSum = totalSum . add ( arrangements [ j ] [ 49 ] ) ; } System . out . println ( totalSum ) ; }
tr	7	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	5	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	9X	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) != null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) != null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
tr	6	public static class getType ( class c ) { if ( c == null ) { Logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getActualType ( c . getGenericSuperclass ( ) ) ; if ( ct != null ) return ct ; Type [ ] interfaces = c . getGenericInterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( Type t : interfaces ) { ct = getActualType ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	4	public boolean saveToFile ( String path ) { logger . info ( "Write all shares into " + path ) ; if ( path == null || ! path . endsWith ( ".ht" ) ) { throw new IllegalArgumentException ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { FileWriter writer = new FileWriter ( path , false ) ; writer . write ( convertSharesToString ( ) ) ; writer . close ( ) ; } catch ( FileNotFoundException e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( IOException e ) { logger . warning ( "Could not write to file '" + path + "' - " + e . getMessage ( ) ) ; return false ; } return true ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSuppliersEntity that = ( PhpposSuppliersEntity ) o ; if ( personId != that . personId ) return false ; if ( accountNumber != null ? ! accountNumber . equals ( that . accountNumber ) : that . accountNumber != null ) return false ; return true ; }
tr	2	public OptionSet getMatchingSet ( boolean ignoreUnmatched , boolean requireDataLast ) { for ( String setName : optionSets . keySet ( ) ) if ( check ( setName , ignoreUnmatched , requireDataLast ) ) return optionSets . get ( setName ) ; return null ; }
tr	7	protected synchronized void update ( ) { Date now = new Date ( ) ; long delta = now . getTime ( ) - lastUpdate . getTime ( ) ; if ( isDead ( ) ) return ; Point oldPos = new Point ( x , y ) ; Point dir = new Point ( speed . getDirectionX ( ) , speed . getDirectionY ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updatePosX ( delta ) ; if ( dir . y != 0 ) blocked |= ! updatePosY ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldPos . equals ( this ) ) lastUpdate = now ; }
tr	5	private Chunk loadChunk ( String [ ] [ ] s , Renderer rend ) { Point p1 = new Point ( Integer . decode ( s [ 0 ] [ 0 ] ) , Integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; Chunk c ; const . debug ( "(SaveHandler:loadChunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(SaveHandler:loadChunk): spawn will be loaded" ) ; c = new SpawnChunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(SaveHandler:loadChunk): underground will be loaded" ) ; c = new UndergroundChunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(SaveHandler:loadChunk): sky will be loaded" ) ; c = new SkyChunk ( map , p1 , true , rend ) ; } else { const . debug ( "(SaveHandler:loadChunk): surface will be loaded" ) ; c = new SurfaceChunk ( map , p1 , true , rend , false ) ; ( ( SurfaceChunk ) c ) . biome = Integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { System . err . println ( "error while loading chunk  wrong selection" ) ; System . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	4	private static Object [ ] subseq ( Object [ ] ary , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == ary . length ) return ary ; else { int len = hi - lo ; Object [ ] a = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) a [ i ] = ary [ i + lo ] ; return a ; } }
tr	3	public static void initConfig ( String path ) { FileInputStream fis = null ; try { fis = new FileInputStream ( path ) ; SYSTEM_CONFIG . load ( fis ) ; } catch ( Exception e ) { logger . error ( "System config file init fail !" , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	8	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
tr	6	public void addEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null ) { vFrom = new Vertex ( vi ) ; vs . add ( vFrom ) ; } if ( vi != vj ) { if ( vTo == null ) { vTo = new Vertex ( vj ) ; vs . add ( vTo ) ; } vFrom . adjacent . add ( vTo ) ; vTo . adjacent . add ( vFrom ) ; } else { vFrom . adjacent . add ( vFrom ) ; } }
tr	5	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	3	private void carregaPreuTipusHabitacions ( ) { String [ ] nomsHotels = { "Palace" , "Hilton" , "Metropolitan" , "Arts" , "Catalunya" , "Pensi\u00F3n Pepe" , "Bonjour" , "Oulala" } ; String [ ] nomsTipus = { "Individual" , "Doble" , "Matrimoni" } ; float [ ] preus = { 100 , 200 , 250 } ; for ( int i = 0 ; i < nomsHotels . length ; ++ i ) { for ( int j = 0 ; j < nomsTipus . length ; ++ j ) { PreuTipusHabitacio pth = new PreuTipusHabitacio ( ) ; pth . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pth . setPreu ( preus [ j ] ) ; if ( j == 0 ) { AbsoluteDiscountPreuStrategy adps = new AbsoluteDiscountPreuStrategy ( ) ; adps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; adps . setDescompte ( 30 ) ; pth . setStrategy ( adps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( adps ) ; } else { PercentDiscountPreuStrategy pdps = new PercentDiscountPreuStrategy ( ) ; pdps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pdps . setPerc ( 0.7F ) ; pth . setStrategy ( pdps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( pdps ) ; } } } }
tr	7	private void ulozitActionPerformed ( java . awt . event . ActionEvent evt ) { PanelRegistraceTymu fr = PanelRegistraceTymu . this ; EntityManager em = DBTools . getInstance ( ) . getEm ( ) ; EntityTransaction tx = DBTools . getInstance ( ) . getTx ( ) ; System . out . println ( "" ) ; System . out . println ( "ULOZIT" ) ; System . out . println ( "" ) ; String sql = "select * from kategorie where nazev=?" ; Query query = DBTools . getInstance ( ) . getEm ( ) . createNativeQuery ( sql , Kategorie . class ) ; query . setParameter ( 1 , fr . kategorieCombo . getSelectedItem ( ) . toString ( ) ) ; Kategorie kat = ( Kategorie ) query . getSingleResult ( ) ; tx . begin ( ) ; Tym tym = Tym . createTym ( fr . JmenoTymuField . getText ( ) , kat ) ; em . persist ( tym ) ; tx . commit ( ) ; tym = em . find ( Tym . class , tym . getTym_id ( ) ) ; System . out . println ( tym ) ; tx . begin ( ) ; TableModel jtm = fr . jezdecTable . getModel ( ) ; for ( int i = 0 ; i < jtm . getRowCount ( ) ; i ++ ) { long val = ( long ) jtm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyl vybran jezdec!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; tho . setJe_jezdec ( true ) ; em . persist ( tho ) ; } } TableModel ptm = fr . prisediciTable . getModel ( ) ; for ( int i = 0 ; i < ptm . getRowCount ( ) ; i ++ ) { long val = ( long ) ptm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni prisedici!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; em . persist ( tho ) ; } } TableModel ktm = fr . koneTable . getModel ( ) ; for ( int i = 0 ; i < ktm . getRowCount ( ) ; i ++ ) { long val = ( long ) ktm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni kone!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Kun k = em . find ( Kun . class , val ) ; System . out . println ( k ) ; TymyHasKone thk = TymyHasKone . createTymMaKone ( tym . getTym_id ( ) , k . getKun_id ( ) ) ; em . persist ( thk ) ; } } try { tx . commit ( ) ; tx . begin ( ) ; tym . setZavodId ( em . find ( Zavody . class , 1 ) ) ; em . persist ( tym ) ; tx . commit ( ) ; dispose ( ) ; } catch ( RollbackException e ) { System . out . println ( "ERROR -> rollback" ) ; JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Do\u0161lo k chyb\u011B: " + e . getMessage ( ) , "Chyba" , JOptionPane . ERROR_MESSAGE ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; } }
tr	5	private int findShortestPath ( ) throws IllegalStateException { int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= graph . V ( ) ; i ++ ) { for ( int j = 1 ; j <= graph . V ( ) ; j ++ ) { if ( i == j && d [ i ] [ j ] [ graph . V ( ) ] < 0 ) { throw new IllegalStateException ( "Negative cycle!" ) ; } if ( d [ i ] [ j ] [ graph . V ( ) ] < min ) { min = d [ i ] [ j ] [ graph . V ( ) ] ; } } } return min ; }
tr	2	public Rectangle union ( Rectangle rect ) { if ( rect == null || rect . isEmpty ( ) ) return this ; return union ( rect . x , rect . y , rect . width , rect . height ) ; }
tr	3	public NotebookJTableModel ( NotebookDao dbSource , String query ) { if ( dbSource == null ) { throw new IllegalArgumentException ( "Notebook table model ben\u00F6tigt eine Datenbankquelle != null" ) ; } this . dbSource = dbSource ; if ( query == null || query . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Notebook table model query String darf nicht null oder leer sein!" ) ; } this . query = query ; this . getDBContents ( ) ; }
tr	3	private void createNewKeyWithLoad ( BigInteger value , int load ) { if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( ! this . allKeys . add ( new Key ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; }
tr	3	public double getDistanceAB ( ArrayList < Object > path ) { ArrayList < Object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new ArrayList < Object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( Road road : roads ) { if ( road . getNodesAttached ( ) . containsAll ( nodes ) ) { distance += road . getDistance ( ) ; } } } distance = UtilCalc . round ( distance , 2 ) ; return distance ; }
tr	9X	private static void saveSystemState ( String filename ) { String out = getParameterValueList ( ) + "\n" ; out += "Changed per state \n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( systemStateChangeds != null ) { for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += systemStateChangeds . get ( systemTestType ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( lastSystemTestPoints != null ) for ( String s : lastSystemTestPoints . keySet ( ) ) { out += "\t" + s + "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Mayority" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Confidence" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Weight" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Missfire" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\n" ; } File f = new File ( filename ) ; try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; FileWriter w = new FileWriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ScienceTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	public boolean method537 ( ) { if ( anIntArray658 == null ) return true ; boolean flag = true ; for ( int j = 0 ; j < anIntArray658 . length ; j ++ ) if ( ! Model . method463 ( anIntArray658 [ j ] ) ) flag = false ; return flag ; }
tr	1	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
tr	0	public Parler ( String message ) { this ( 0 , message ) ; }
tr	3	@ Override public String toString ( ) { String name = getName ( ) ; String append = "" ; if ( name != null && ! name . equals ( "" ) ) { append = "(\"" + this . getName ( ) + "\")" ; } StringBuilder bldr = new StringBuilder ( ) ; bldr . append ( "TAG_List" + append + ": " + value . size ( ) + " entries of type " + NBTUtils . getTypeName ( type ) + "\r\n{\r\n" ) ; for ( Tag t : value ) { bldr . append ( "   " + t . toString ( ) . replaceAll ( "\r\n" , "\r\n   " ) + "\r\n" ) ; } bldr . append ( "}" ) ; return bldr . toString ( ) ; }
tr	4	@ Test public void testNaissanceSoldats ( ) { SalleSoldat testSoldat = new SalleSoldat ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testSoldat . naissanceSoldats ( 2 , sn ) ; assertEquals ( 1 , testSoldat . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testSoldat . naissanceSoldats ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testSoldat . naissanceSoldats ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
tr	2	public static void onAllROute ( Individual individual ) { ProblemInstance problemInstance = individual . problemInstance ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { mutateRouteBy2_Opt ( individual , period , vehicle ) ; } } }
tr	5	public static Method findVisitMethod ( MatchProcessor visitor , Match node ) { Method visitMethod = null ; class < ? > visitorClass = visitor . getClass ( ) ; Map < String , Method > visitMethods = __visitMethodCache . get ( visitorClass ) ; if ( visitMethods == null ) __visitMethodCache . put ( visitorClass , visitMethods = new HashMap < String , Method > ( ) ) ; String methodName = node . getParser ( ) . getLabel ( ) ; methodName = "process" + methodName . substring ( 0 , 1 ) . toUpperCase ( ) + methodName . substring ( 1 ) ; visitMethod = visitMethods . get ( methodName ) ; if ( visitMethod == null ) { try { visitMethod = visitorClass . getMethod ( methodName , Match . class ) ; visitMethods . put ( methodName , visitMethod ) ; } catch ( Exception e ) { } } if ( visitMethod == null ) return __defaultVisitMethod ; return visitMethod ; }
tr	2	protected void execute ( ) { if ( shooter . left . getD ( ) - accuracy > pos ) { shooter . set ( - holdVel ) ; } else if ( shooter . left . getD ( ) + accuracy < pos ) { shooter . set ( holdVel ) ; } else { shooter . set ( 0.0 ) ; } }
tr	1	public SimulatorView ( Simulator sim ) { super ( sim ) ; colors = new LinkedHashMap < class < ? > , Color > ( ) ; fieldView = new FieldView ( 100 , 100 ) ; }
tr	9X	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } MarketData currBar = this . bidTs . get ( i ) ; MarketData prevBar = this . bidTs . get ( i - 1 ) ; if ( ! order . HasPosition ( product ) ) { state = 0 ; } double currBody = currBar . getClose ( ) - currBar . getOpen ( ) ; double prevBody = prevBar . getClose ( ) - prevBar . getOpen ( ) ; double point = CurrencyTable . getPoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevBody > 0 && currBody < 0 ; boolean cond2 = currBar . getOpen ( ) >= prevBar . getClose ( ) ; boolean cond3 = currBar . getClose ( ) <= prevBar . getOpen ( ) ; boolean cond4 = currBody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bidTs . get ( i ) . getClose ( ) ; order . MarketSell ( product , entryTime , entryPrice , 2 ) ; this . stopPrice = prevBar . getClose ( ) + 100 * point ; this . r = this . stopPrice - this . entryPrice ; this . takeProfit = this . entryPrice - r ; order . StopBuy ( product , entryTime , this . stopPrice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { order . MarketBuy ( product , currBar . getStart ( ) , this . takeProfit , 1 ) ; order . CancelAllPendingOrders ( product ) ; this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . CancelAllPendingOrders ( product ) ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; } } }
tr	9X	private Map < String , List < String >> decodeParams ( String s ) { Map < String , List < String >> params = new LinkedHashMap < String , List < String >> ( ) ; String name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addParam ( params , name , "" ) ; } return params ; }
tr	1	public int [ ] getAction_Per_State_As_Array ( ) { int ret [ ] = new int [ noOfStates ] ; for ( int i = 0 ; i < noOfStates ; i ++ ) { ret [ i ] = action_Per_State . get ( i ) ; } return ret ; }
tr	1	public User getByID ( Line line ) { try { return getByID ( line . getString ( "userid" ) ) ; } catch ( Exception ex ) { } return getByID ( line . toString ( ) ) ; }
tr	7	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	0	public void setGame ( Game game ) { this . game = game ; }
tr	3	public RegularAnalyzer ( List < Rule > rules ) { Set < String > definedRuleNames = new HashSet < String > ( ) ; List < Rule > observedRules = new ArrayList < Rule > ( ) ; observedRules . addAll ( rules ) ; boolean foundRegular ; do { foundRegular = false ; for ( int index = observedRules . size ( ) - 1 ; index >= 0 ; index -- ) { Set < String > dependent = observedRules . get ( index ) . getElements ( ) . getDependentRuleNames ( ) ; if ( definedRuleNames . containsAll ( dependent ) ) { definedRuleNames . add ( observedRules . get ( index ) . getRuleName ( ) . toString ( ) ) ; regularRules . add ( observedRules . get ( index ) ) ; observedRules . remove ( index ) ; foundRegular = true ; continue ; } } } while ( foundRegular ) ; observedRules . clear ( ) ; }
tr	1	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	0	public String getFirstName ( ) { return firstName ; }
tr	4	private static class < ? > getPrimitiveClass ( final class < ? > componentType ) { if ( Integer . class . isAssignableFrom ( componentType ) ) { return int . class ; } if ( double . class . isAssignableFrom ( componentType ) ) { return double . class ; } throw new UnsupportedOperationException ( "Mapping not implemented" ) ; }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	9X	public void generate ( Point start ) { Stack < Point > waysToExpand = new Stack < > ( ) ; exitFound = false ; final List < Point > nextOptions = new ArrayList < > ( 4 ) ; waysToExpand . add ( start ) ; while ( ! waysToExpand . isEmpty ( ) ) { Point p = waysToExpand . pop ( ) ; if ( canBecomeWhite ( p ) ) { arr . setWhite ( p ) ; if ( onTheEdge ( p ) && p . differsFrom ( start ) ) { exitFound = true ; } if ( isBlack ( p . up ( ) ) && canBecomeWhite ( p . up ( ) ) ) nextOptions . add ( p . up ( ) ) ; if ( isBlack ( p . down ( ) ) && canBecomeWhite ( p . down ( ) ) ) nextOptions . add ( p . down ( ) ) ; if ( isBlack ( p . left ( ) ) && canBecomeWhite ( p . left ( ) ) ) nextOptions . add ( p . left ( ) ) ; if ( isBlack ( p . right ( ) ) && canBecomeWhite ( p . right ( ) ) ) nextOptions . add ( p . right ( ) ) ; Collections . shuffle ( nextOptions ) ; int c = 0 ; for ( Point t : nextOptions ) { waysToExpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextOptions . clear ( ) ; } } }
tr	9X	private static void horizLeftRight ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int row = 0 ; row < 6 ; row ++ ) { for ( int col = 0 ; col < 4 ; col ++ ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 2 , row ) . getState ( ) == 0 ) ) { if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 1 ) ; } if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == player2Color ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } } } } }
tr	2	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	4	@ Override public void run ( ) { try { while ( active ) { synchronized ( messages ) { if ( messages . isEmpty ( ) ) { messages . wait ( 200 ) ; } else { NetworkMessage nm = messages . remove ( 0 ) ; out . write ( nm . getData ( ) ) ; } } } } catch ( InterruptedException ex ) { System . err . println ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
tr	7	protected static void addObject ( IUnknown o ) { if ( apartmentInitialized . get ( ) == false ) { ComThread . InitSTA ( false ) ; apartmentInitialized . set ( true ) ; } if ( ! AUTO_GC ) return ; ReferenceQueue < IUnknown > deadObjects = deadPool . get ( ) ; objects . put ( new PointerWeakReference ( o , deadObjects ) , false ) ; if ( GC_COUNT != - 1 && ( count % GC_COUNT ) == 0 ) { System . gc ( ) ; } if ( ( count ++ % CULL_COUNT ) == 0 ) { int numberCulled = cullDeadPool ( deadObjects , objects ) ; if ( IUnknown . isDebugEnabled ( ) ) { if ( numberCulled > 0 ) { IUnknown . debug ( "ROT: added instance of " + o . getClass ( ) . getSimpleName ( ) + "->[+1  -" + numberCulled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	4	public boolean contain ( Ticket ticket ) { if ( ! parkIsNull ( ) && park . contain ( ticket ) ) { return true ; } for ( ParkBoy boy : this . parkBoyList ) { if ( boy . contain ( ticket ) ) { return true ; } } return false ; }
tr	5	public boolean isDefined ( ) { return ( this . x1 != null && this . x2 != null && this . y1 != null && this . y2 != null && this . z1 != null && this . z2 != null ) ; }
tr	4	private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c ==  || c ==  || excluded . indexOf ( c ) != - 1 ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
tr	4	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	1	public void renderLow ( Parameters params ) { if ( renderer == null ) { throw new IllegalStateException ( "renderer not set" ) ; } image = newImage ( ) ; showImage ( image ) ; int width = image . getWidth ( null ) ; int height = image . getHeight ( null ) ; params . adjustAspect ( width , height ) ; setParameters ( params ) ; imageComponent . setCursor ( waitCursor ) ; renderThread = new Thread ( new RenderRunner ( image , params , renderer ) ) ; renderThread . start ( ) ; }
tr	1	private int insert ( final BeanMissatge bean ) { String SQL1 = "INSERT INTO sig_missatgeria (idEntrevista destinatari idMateria materia actitud notes feina comentaris dataContestat idMensajeProfesor) " + " VALUES(? ? ? ? ? ? ? ? ? ?)" ; Object [ ] objs = new Object [ ] { bean . idEntrevista , bean . destinatari_abrev , bean . idMateria , bean . materia , bean . actitud , bean . notes , bean . feina , bean . comentari , bean . dataContestat , bean . idMensajeProfesor } ; int nup = client . getMysql ( ) . preparedUpdateID ( SQL1 , objs ) ; if ( nup > 0 ) { bean . setId ( nup ) ; } return nup ; }
tr	3	@ Override public int storeProject ( String name , String description ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newProjectId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (name  description)" ) . append ( " VALUES " ) . append ( "('" + name + "'  '" + description + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newProjectId = rs . getInt ( 1 ) ; } rs . getStatement ( ) . close ( ) ; rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newProjectId ; }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	8	public static void release ( Object ... releasables ) { for ( Object obj : releasables ) { if ( obj != null ) { try { if ( obj instanceof ServerSocket ) { ( ( ServerSocket ) obj ) . close ( ) ; } else if ( obj instanceof Socket ) { ( ( Socket ) obj ) . close ( ) ; } else if ( obj instanceof Process ) { ( ( Process ) obj ) . destroy ( ) ; } else if ( obj instanceof Closeable ) { ( ( Closeable ) obj ) . close ( ) ; } else { throw new IllegalArgumentException ( "This method does not not how to release objects of type " + obj . getClass ( ) ) ; } } catch ( IOException ex ) { } catch ( RuntimeException ex ) { } } } }
tr	7	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	7	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	9X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	1	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
tr	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
tr	3	public int getPort ( ) { String num = getString ( "Port" ) ; if ( num == null || num . equals ( "" ) ) { return DEFAULT_PORT ; } try { return Integer . parseInt ( num , 10 ) ; } catch ( NumberFormatException ex ) { logger . warning ( "Bad value for listening port (" + num + ")" ) ; throw new IllegalStateException ( "Bad value for listening port (" + num + ")" , ex ) ; } }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	5	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	0	public String getMateria ( ) { return materia ; }
tr	5	@ Override public int hashCode ( ) { int result = iduser ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( lastName != null ? lastName . hashCode ( ) : 0 ) ; result = 31 * result + ( email != null ? email . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( activateKey != null ? activateKey . hashCode ( ) : 0 ) ; return result ; }
tr	4	@ Override public void processDrawing ( ) { if ( rsAlreadyLoaded || loadingError || genericLoadingError ) { showErrorScreen ( ) ; return ; } drawCycle ++ ; if ( ! loggedIn ) drawLoginScreen ( false ) ; else drawGameScreen ( ) ; anInt1213 = 0 ; }
tr	3	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	9X	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	7	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	3	public void add ( T item ) { Node node = new Node ( item ) ; if ( current == null ) { node . next = head ; node . prev = null ; if ( head != null ) head . prev = node ; head = node ; } else { node . next = current . next ; node . prev = current ; if ( current . next != null ) current . next . prev = node ; current . next = node ; } ++ idx ; current = node ; ++ size ; }
tr	6	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new BSTNode ( data ) ; return ; } BSTNode currentNode = overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new BSTNode ( data ) ; return ; } currentNode = currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new BSTNode ( data ) ; return ; } currentNode = currentNode . right ; } } }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	5	public static void main ( String [ ] args ) { r1 = new Thread ( ) { public void run ( ) { while ( i < 100 ) { if ( i % 10 == 0 ) { if ( r2 . isAlive ( ) ) r2 . notify ( ) ; else r2 . run ( ) ; } i ++ ; } r1 . interrupt ( ) ; r2 . interrupt ( ) ; } } ; r2 = new Thread ( ) { public void run ( ) { System . out . println ( i ) ; try { if ( r2 . isAlive ( ) ) { r2 . wait ( ) ; r1 . notify ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; r1 . run ( ) ; }
tr	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
tr	2	public void update ( ) { super . update ( ) ; if ( this . isClicked ( ) && ( Timer . getTime ( ) - this . lastClick ) > 200 ) { this . state = ! this . state ; this . lastClick = Timer . getTime ( ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new RelVendasPorVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	5	public boolean getRGBPixels ( int x , int y , int width , int height , int [ ] pixels ) { if ( getRGBPixelsMethod != null ) try { if ( getRGBPixelsMethodType == 0 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 1 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { new Rectangle ( x , y , width , height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 2 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , new Rectangle ( x , y , width , height ) , pixels } ) ; else getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; return true ; } catch ( Exception ex ) { } int [ ] tmp = getRGBPixels ( new Rectangle ( x , y , width , height ) ) ; System . arraycopy ( tmp , 0 , pixels , 0 , width * height ) ; return false ; }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	3	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPath ) return this . equals ( ( ASPath ) o ) ; return false ; }
tr	5	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	9X	@ Override public void actionPerformed ( ActionEvent ae ) { if ( ae . getActionCommand ( ) . compareTo ( "comboBoxChanged" ) == 0 ) { if ( ae . getSource ( ) == combo_url ) { loadUrlData ( ) ; } else if ( ae . getSource ( ) == combo_grantType ) { if ( combo_grantType . getSelectedIndex ( ) == AUTHORIZATION_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . AUTHORIZATION_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == PASSWORD_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . PASWORD_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == CLIENT_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) ; setupPanels ( ) ; } } } else if ( ae . getActionCommand ( ) . compareTo ( ABOUT_MENUITEM ) == 0 ) { JOptionPane . showMessageDialog ( applicationFrame , "OAuthTestClient\nAn OAuth 2.0 Test Application\nWritten by Ronnie Mitra.\n\nhttps://github.com/mitraman/OAuthTestClient    \n\n" , "About OAuthTestClient" , JOptionPane . QUESTION_MESSAGE ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SETTINGS_MENUITEM ) == 0 ) { SettingsDialog settingsDialog = new SettingsDialog ( applicationFrame ) ; settingsDialog . setVisible ( true ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SAVE_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( "./OAuthTestClient.cfg" ) ; if ( fileChooser . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . saveProperties ( file ) ; } } else if ( ae . getActionCommand ( ) . compareTo ( LOAD_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( ) ; if ( fileChooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . loadProperties ( file ) ; } } else { System . out . println ( ae . getActionCommand ( ) + " " + ae . getID ( ) ) ; } }
tr	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
tr	4	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	1	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new Application ( ) ) ; app . setDisplayMode ( SCREEN_WIDTH , SCREEN_HEIGHT , false ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	7	public static String extractTitleFrom ( String filePath ) { String title = null ; try { Mp3File mp3File = new Mp3File ( filePath ) ; if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; title = id3v2Tag . getTitle ( ) ; } else if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; title = id3v1Tag . getTitle ( ) ; } } catch ( UnsupportedTagException e ) { e . printStackTrace ( ) ; } catch ( InvalidDataException e ) { System . out . print ( "Invalid Data" ) ; return " - Unknown Title" ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( title == null ) { int lastSlash = filePath . lastIndexOf ( \ ) ; if ( filePath . lastIndexOf ( / ) > lastSlash ) lastSlash = filePath . lastIndexOf ( / ) ; title = filePath . substring ( lastSlash + 1 ) . replaceAll ( "\\.mp3$" , "" ) ; } return title ; }
tr	7	@ Override protected void handleMethodAttribute ( final String name , final byte [ ] data , final int offset , final long length , final ConstantPool constantPool ) { if ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Signature . equals ( name ) ) { parseSignature ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Deprecated . equals ( name ) ) { parseDeprecated ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_Synthetic . equals ( name ) ) { parseSynthetic ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Exceptions . equals ( name ) ) { parseExceptions ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Code . equals ( name ) ) { parseCode ( data , offset , constantPool ) ; } else { System . err . println ( "Unhandled method attribute: " + name ) ; } }
tr	6	public int [ ] getActions ( Game game , long timeDue ) { int pacmanLoc = game . getCurPacManLoc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostRequiresAction ( i ) ) { if ( isCrowded ( game ) && ! closeToMsPacMan ( game , game . getCurGhostLoc ( i ) ) ) dirs [ i ] = getRetreatActions ( game , i ) ; else if ( game . getEdibleTime ( i ) > 0 || closeToPower ( game ) ) dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , false , Game . DM . PATH ) ; else dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , true , Game . DM . PATH ) ; } } return dirs ; }
tr	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	9X	public int getConfig ( int uid , int x , int y , int z ) { Ground tile = groundArray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallObject != null && tile . wallObject . uid == uid ) return tile . wallObject . objConf & ff ; if ( tile . wallDecoration != null && tile . wallDecoration . uid == uid ) return tile . wallDecoration . objConf & ff ; if ( tile . groundDecoration != null && tile . groundDecoration . uid == uid ) return tile . groundDecoration . objConf & ff ; for ( int e = 0 ; e < tile . entityCount ; e ++ ) if ( tile . interactiveObjects [ e ] . uid == uid ) return tile . interactiveObjects [ e ] . objConf & ff ; return - 1 ; }
tr	4	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	9X	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	7	private String getMPatternCode ( ) { int posIni = _position ; for ( ; ; ) { if ( _mumpsPattern . length ( ) <= _position ) { break ; } if ( isQuantifier ( _mumpsPattern . charAt ( _position ) ) || ( _mumpsPattern . charAt ( _position ) == ( ) || ( _mumpsPattern . charAt ( _position ) ==   ) || ( _mumpsPattern . charAt ( _position ) == ) ) ) { break ; } if ( ! patternAtomTranslateTable . containsKey ( _mumpsPattern . charAt ( _position ) ) ) { throw new IllegalArgumentException ( "Code Pattern inv\u00E1lido encontrado: " . concat ( _mumpsPattern . substring ( _position , _position + 1 ) ) . concat ( ". Na posi\u00E7\u00E3o: " . concat ( String . valueOf ( _position ) ) ) ) ; } _position ++ ; } return _mumpsPattern . substring ( posIni , _position ) ; }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	6	public void doService ( ) { Message message = parser . nextMessage ( ) ; while ( message != null ) { switch ( message . getType ( ) ) { case CONNECT : writer . println ( "ALREADY CONNECTED!" ) ; writer . flush ( ) ; break ; case DISCONNECT : server . broadcaster . remove ( connection ) ; break ; case TEXTMSG_CLIENT : broadcastMessage ( message ) ; break ; case IMAGE_CLIENT : server . setImage ( ImageUtils . decodeImage ( message . getMatcher ( ) . group ( 1 ) ) ) ; broadcastMessage ( message ) ; break ; default : AbstractTool tool = AbstractTool . getTool ( message . getType ( ) ) ; if ( tool != null ) { server . updateImage ( tool , message ) ; broadcastMessage ( message ) ; } break ; } message = parser . nextMessage ( ) ; } }
tr	5	public boolean move ( Direction direction , StringBuffer output ) throws EndGameException { boolean hasMoved = false ; if ( myPosition . isCrossable ( direction ) ) { if ( myPosition . hasCharacter ( direction ) ) { Character defender = myPosition . getCharacter ( direction ) ; if ( attack ( defender ) ) { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You attacked and killed " + defender + ". You moved " + direction ) ; hasMoved = true ; } else { if ( isDead ( ) ) throw new EndGameException ( "Player has died. GAME OVER!" ) ; output . append ( "You attacked: \n" + defender . toString ( ) + "\n" + this . toString ( ) ) ; } } else { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You moved " + direction + "." ) ; hasMoved = true ; } } else { output . append ( checkIfLockedExit ( direction ) ) ; } if ( hasMoved ) { notifyPositionChanged ( direction . getOppositeDirection ( ) ) ; } return hasMoved ; }
tr	6	protected Shape createTriangle ( float fx , float fy , float tx , float ty , boolean rot ) { int size = 15 ; float dx = tx - fx ; float dy = ty - fy ; float D = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float z = ( dx <= 0 ) ? fx - D : fx + D ; float mid = ( dx <= 0 ) ? fx - D / 2 : fx + D / 2 ; float dec = ( dx <= 0 ) ? size : - size ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy + size / 2 ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; if ( rot ) { gp . moveTo ( mid + dec , fy - size / 2 ) ; gp . curveTo ( mid , fy - size , mid , fy + size , mid + dec , fy + size / 2 ) ; } double alpha = ( dx > 0 ) ? Math . asin ( dy / D ) : - Math . asin ( dy / D ) ; return alpha != 0 ? gp . createTransformedShape ( AffineTransform . getRotateInstance ( alpha , fx , fy ) ) : gp ; }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	5	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
tr	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	5	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	8	public static Mineral find ( int remoteId ) { switch ( remoteId ) { case 34 : return Tritanium ; case 35 : return Pyerite ; case 36 : return Mexallon ; case 37 : return Isogen ; case 38 : return Nocxium ; case 39 : return Zydrine ; case 40 : return Megacyte ; case 11399 : return Morphite ; default : { throw new RuntimeException ( "Id does not represent mineral" ) ; } } }
tr	7	public synchronized void tick ( ) { handleEvents ( ) ; updateWorkers ( ) ; for ( Sponsor sponsor : new ArrayList < Sponsor > ( sponsors ) ) { if ( sponsor . getMSLeft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } Random r = new Random ( ) ; if ( sponsors . size ( ) < MAX_SPONSORS && r . nextInt ( ( int ) ( 1500 / Math . log ( getRenown ( ) + 2 ) ) ) == 0 ) { addSponsor ( ) ; } if ( getRenown ( ) <= 0 ) { showWindow ( null , new GameOverWindow ( ) ) ; } if ( r . nextInt ( DIFFICULTY ) == 0 ) { setRenown ( getRenown ( ) - 1 ) ; } if ( firstTick ) showWindow ( null , new HelpWindow ( ) ) ; firstTick = false ; }
tr	3	public int maximum ( Node root ) { int root_val , left_val , right_val , max = Integer . MIN_VALUE ; if ( root != null ) { root_val = root . key ; left_val = maximum ( root . left ) ; right_val = maximum ( root . right ) ; if ( left_val > right_val ) max = left_val ; else max = - right_val ; if ( root_val > max ) max = root_val ; } return max ; }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
tr	9X	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	3	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	9X	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	7	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	2	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	9X	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	9X	String formatOption ( OptionMetadata metadata , CommandLineConfiguration config ) { String formattedOption = null ; if ( metadata . isParameterAccepted ( ) ) { boolean isParamRequired = ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . isRequired ( ) ) ; String paramDelim = StringUtil . formatDelimValue ( config . getCommandLineProperties ( ) . getOptionParameterDelim ( ) ) ; String paramUsageStr = "" ; if ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . getParameterType ( ) != ParameterType . NONE ) { String paramName = "" ; if ( metadata . getParameterMetadata ( ) . getParameterType ( ) == ParameterType . CUSTOM ) { paramName = metadata . getParameterMetadata ( ) . getIdentifier ( ) ; } else { paramName = metadata . getParameterMetadata ( ) . getParameterType ( ) . name ( ) ; } paramUsageStr = String . format ( ( isParamRequired ) ? "%s<%s>" : "[%s<%s>]" , paramDelim , paramName ) ; if ( metadata . isMultiValued ( ) ) { paramUsageStr += "..." ; } } String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) , paramUsageStr ) ; } else { formattedOption = String . format ( "%s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , paramUsageStr ) ; } } else { String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) ) ; } else { formattedOption = String . format ( "%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) ) ; } } return formattedOption ; }
tr	3	public void switchFullscreen ( ) { if ( fullscreen == false ) { throw new IllegalStateException ( "This window not supports fullscreen mode!" ) ; } if ( state == WindowState . WINDOW ) { Rectangle rc = this . getBounds ( ) ; boolean resizable = this . isResizable ( ) ; this . properties = new FrameProperties ( getX ( ) , getY ( ) , ( int ) rc . getWidth ( ) , ( int ) rc . getHeight ( ) , resizable ) ; } if ( device . getFullScreenWindow ( ) == null ) { FrameProperties properties = new FrameProperties ( 0 , 0 , getFullWidth ( ) , getFullHeight ( ) , false ) ; this . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; this . state = WindowState . FULLSCREEN ; properties . append ( this ) ; device . setFullScreenWindow ( this ) ; updateDisplay ( ) ; return ; } device . setFullScreenWindow ( null ) ; this . setExtendedState ( JFrame . NORMAL ) ; this . state = WindowState . WINDOW ; properties . append ( this ) ; updateDisplay ( ) ; }
tr	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( declaration == null ) ? 0 : declaration . hashCode ( ) ) ; result = prime * result + ( ( ident == null ) ? 0 : ident . hashCode ( ) ) ; result = prime * result + ( ( statementSequence == null ) ? 0 : statementSequence . hashCode ( ) ) ; return result ; }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } Ѕtring data = Ѕtring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	5	@ Override public String toString ( ) { switch ( this ) { case uneEtoile : return "\u2605" ; case deuxEtoiles : return "\u2605\u2605" ; case troisEtoiles : return "\u2605\u2605\u2605" ; case quatreEtoiles : return "\u2605\u2605\u2605\u2605" ; case cinqEtoiles : return "\u2605\u2605\u2605\u2605\u2605" ; } return null ; }
tr	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	2	private boolean isValidUserInput ( final String hostname , final String port ) { final String methodName = "isValidUserInput" ; ControllerLogger . entering ( CLASS_NAME , methodName , hostname , port ) ; try { if ( GUIUtils . isEmptyValue ( hostname ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_HOSTNAME_MESSAGE ) ; return false ; } if ( ! GUIUtils . isPortNumberValid ( port ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_PORT_NUMBER_MESSAGE ) ; return false ; } return true ; } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	4	public static boolean intersects ( final IShape shape1 , final Vector3f vertex ) { simplex . clear ( ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , vertex , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS ) { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , vertex , v ) ; if ( v . . ( e . v ) > 0 ) { return false ; } if ( simplex . contains ( e . v ) ) break ; simplex . addElement ( ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } return true ; }
tr	5	public static Pair < Integer , Integer > linearCongruence ( int a , int b , final int n ) { positiveCheck ( n ) ; a = normalizeIntModulo ( a , n ) ; b = normalizeIntModulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new Pair < > ( 0 , 1 ) ; final int numberOfSolutions = gcd ( a , n ) ; if ( b % numberOfSolutions != 0 ) return new Pair < > ( ) ; int bezoutCoefficientA ; if ( a > n ) bezoutCoefficientA = bezout ( a , n ) . get ( 1 ) ; else bezoutCoefficientA = bezout ( n , a ) . get ( 2 ) ; final int shiftedModulus = n / numberOfSolutions ; int x = ( bezoutCoefficientA * b ) / numberOfSolutions ; x = normalizeIntModulo ( x , shiftedModulus ) ; return new Pair < > ( x , shiftedModulus ) ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ComplexNumber that = ( ComplexNumber ) o ; if ( double . compare ( that . im , im ) != 0 ) return false ; if ( double . compare ( that . re , re ) != 0 ) return false ; return true ; }
tr	7	public List < CodeList > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < CodeList > codeLists = new ArrayList < CodeList > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeList" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { CodeList cl = processCodeList ( se , eventReader ) ; codeLists . add ( cl ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeLists" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { endTagReached = true ; } break ; } } return codeLists ; }
tr	9X	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
tr	8	private boolean interpolateCollection ( Object obj , String basePath , Field field ) throws IllegalAccessException , InterpolationException { Collection c = ( Collection ) field . get ( obj ) ; if ( c != null && ! c . isEmpty ( ) ) { List originalValues = new ArrayList ( c ) ; try { c . clear ( ) ; } catch ( UnsupportedOperationException e ) { warningCollector . add ( new ObjectInterpolationWarning ( "Field is an unmodifiable collection. Skipping interpolation." , basePath + "." + field . getName ( ) , e ) ) ; return true ; } for ( Object value : originalValues ) { if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { c . add ( interpolated ) ; } else { c . add ( value ) ; } } else { c . add ( value ) ; if ( value . getClass ( ) . isArray ( ) ) { evaluateArray ( value , basePath + "." + field . getName ( ) ) ; } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "." + field . getName ( ) ) ) ; } } } else { c . add ( value ) ; } } } return false ; }
tr	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	4	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append (  ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
tr	8	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	4	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
tr	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
tr	9X	private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; }
tr	2	private Expression expression0 ( ) throws RequiredTokenException { enterRule ( NonTerminal . EXPRESSION0 ) ; Expression lhs = expression1 ( ) ; if ( firstSetSatisfied ( NonTerminal . OP0 ) ) { Token op = null ; try { op = op0 ( ) ; lhs = Command . newExpression ( lhs , op , expression1 ( ) ) ; } catch ( FirstSetUnsatisfiedException e ) { lhs = new Error ( ( ( Command ) lhs ) . lineNumber ( ) , ( ( Command ) lhs ) . charPosition ( ) , String . format ( "First set unsatisfied for nonterminal of type \"%s\"." , e . Unsatisfied ) ) ; } } exitRule ( ) ; return lhs ; }
tr	9X	public PaymentDialog ( Member member , ClassType ct , String message , int flag ) { messageTextArea . setText ( message ) ; globalMember = member ; globalClassType = ct ; globalFlag = flag ; makePaymentButton = new JButton ( "Make Payment" ) ; makePaymentButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Common . makePayment ( paymentTypeList . getSelectedValue ( ) , globalMember , ( Date ) utilDateModel . getValue ( ) , getPaymentAmount ( ) ) ; updatePaymentStatus ( globalMember , globalClassType ) ; dispose ( ) ; new PaymentDialog ( globalMember , globalClassType , "Payment made for " + globalMember . getName ( ) + "\n of " + getPaymentAmount ( ) + " for " + paymentTypeList . getSelectedValue ( ) . getPaymentTypeName ( ) + "\n up to date: " + ( ( Date ) utilDateModel . getValue ( ) ) . toString ( ) , globalFlag ) ; } } ) ; makePaymentButton . setEnabled ( false ) ; exitButton = new JButton ( "Exit" ) ; exitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { dispose ( ) ; if ( globalFlag == 0 ) new MemberCheckInInterface ( globalClassType ) ; } } ) ; BufferedImage tkdIcon = CommonUI . getTkdIcon ( ) ; BufferedImage skyIcon = CommonUI . getSkyIcon ( ) ; BufferedImage kickIcon = CommonUI . getKickIcon ( ) ; Image img = null ; switch ( ct ) { case TAEKWONDO : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; break ; case SKYBOXING : img = new ImageIcon ( skyIcon ) . getImage ( ) ; break ; case KICKBOXING : img = new ImageIcon ( kickIcon ) . getImage ( ) ; break ; case OTHER : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; default : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; } setIconImage ( img ) ; this . setTitle ( "Enter Payment for " + member . getName ( ) ) ; utilDateModel . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { System . out . println ( "DateModel changed" ) ; setDateSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; panel . add ( paymentToPanel , BorderLayout . CENTER ) ; paymentTypeList . setListData ( Common . getPaymentTypes ( ct ) . toArray ( new PaymentType [ 1 ] ) ) ; paymentTypeList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { JList < PaymentType > tempList = ( JList < PaymentType > ) arg0 . getSource ( ) ; PaymentType pt = tempList . getSelectedValue ( ) ; paymentAmountTextField . setText ( String . format ( "%9.2f" , pt . getPaymentAmount ( ) ) ) ; setPaymentAmountFieldSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; listPanel . add ( paymentTypeList ) ; panel . add ( listPanel , BorderLayout . WEST ) ; paymentAmountPanel . add ( paymentAmountLabel ) ; paymentAmountPanel . add ( paymentAmountTextField ) ; buttonPanel . add ( paymentAmountPanel , BorderLayout . NORTH ) ; buttonPanel . add ( makePaymentButton , BorderLayout . WEST ) ; buttonPanel . add ( exitButton , BorderLayout . SOUTH ) ; panel . add ( buttonPanel , BorderLayout . SOUTH ) ; paymentStatusPanel . add ( paymentStatusTextArea , BorderLayout . NORTH ) ; paymentStatusPanel . add ( messageTextArea , BorderLayout . SOUTH ) ; updatePaymentStatus ( member , ct ) ; panel . add ( paymentStatusPanel , BorderLayout . EAST ) ; this . getContentPane ( ) . add ( panel ) ; this . setSize ( CommonUI . FULLSCREEN ) ; this . setVisible ( true ) ; }
tr	2	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	9X	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	8	public boolean IsInverse ( GameDirection Direction ) { if ( this == GameDirection . UP && Direction == GameDirection . DOWN ) return true ; if ( this == GameDirection . DOWN && Direction == GameDirection . UP ) return true ; if ( this == GameDirection . LEFT && Direction == GameDirection . RIGHT ) return true ; if ( this == GameDirection . RIGHT && Direction == GameDirection . LEFT ) return true ; return false ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	9X	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
tr	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
tr	2	@ Override public String filterReplacedString ( FilterBypass fb , int offset , int length , String str , AttributeSet attrs ) { if ( str == null ) return "" ; int remaining = limit - fb . getDocument ( ) . getLength ( ) + length ; if ( remaining > str . length ( ) ) { return str ; } else { return str . substring ( 0 , remaining ) ; } }
tr	4	public String getKeterangan ( ) { char idx = getIndex ( ) ; switch ( idx ) { case A : return "Sangat Baik" ; case B : return "Baik" ; case C : return "Cukup" ; case D : return "Kurang" ; default : return "Sangat Kurang" ; } }
tr	9X	private Object readLiteral ( ) throws JSONException { String literal = nextToInternal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } else if ( "null" . equalsIgnoreCase ( literal ) ) { return JSONObject . null ; } else if ( "true" . equalsIgnoreCase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsIgnoreCase ( literal ) ) { return boolean . false ; } if ( literal . indexOf ( . ) == - 1 ) { int base = 10 ; String number = literal ; if ( number . startsWith ( "0x" ) || number . startsWith ( "0X" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startsWith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longValue = long . parseLong ( number , base ) ; if ( longValue <= Integer . MAX_VALUE && longValue >= Integer . MIN_VALUE ) { return ( int ) longValue ; } else { return longValue ; } } catch ( NumberFormatException e ) { } } try { return double . valueOf ( literal ) ; } catch ( NumberFormatException ignored ) { } return new String ( literal ) ; }
tr	7	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
tr	7	public Vector < String > enumDatabases ( ) { Vector < String > instances = new Vector < String > ( ) ; Connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errMsg = "Can't connect to management database" ; return instances ; } Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { while ( r . next ( ) ) { String name = r . getString ( "datname" ) ; instances . add ( name ) ; } } } errMsg = null ; } catch ( SQLException e ) { errMsg = e . getMessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( SQLException e ) { } } return instances ; }
tr	2	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	3	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	9X	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	2	@ Override public void removeUser ( Identifier id ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException { if ( id == null ) { throw new InvalidIdentifierException ( "Id is invalid" ) ; } if ( Users . remove ( id ) == null ) { throw new IdentifierNotFoundException ( "Id not found" ) ; } Users . remove ( id ) ; write ( USERS ) ; }
tr	3	public static void filledCircle ( double x , double y , double r ) { if ( r < 0 ) throw new IllegalArgumentException ( "circle radius must be nonnegative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * r ) ; double hs = factorY ( 2 * r ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
tr	8	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
tr	6	LocalSocket ( Socket socket , PassthroughConnection ptc ) { this . ptc = ptc ; this . socket = socket ; DataInputStream inLocal = null ; DataOutputStream outLocal = null ; try { inLocal = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream to client" ) ; if ( inLocal != null ) { try { inLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream to client" ) ; } } in = null ; out = null ; success = false ; return ; } try { outLocal = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream from client" ) ; if ( outLocal != null ) { try { outLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream from client" ) ; } } in = null ; out = null ; success = false ; return ; } in = inLocal ; out = outLocal ; success = true ; }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	3	@ Override public void delete ( TypeAttribute typeAttribute ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . delete ( typeAttribute ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	8	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	9X	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
tr	8	private void method117 ( Stream stream ) { stream . initBitAccess ( ) ; int j = stream . readBits ( 1 ) ; if ( j == 0 ) return ; int k = stream . readBits ( 2 ) ; if ( k == 0 ) { anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 1 ) { int l = stream . readBits ( 3 ) ; myPlayer . moveInDir ( false , l ) ; int k1 = stream . readBits ( 1 ) ; if ( k1 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 2 ) { int i1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , i1 ) ; int l1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 3 ) { plane = stream . readBits ( 2 ) ; int j1 = stream . readBits ( 1 ) ; int i2 = stream . readBits ( 1 ) ; if ( i2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; int k2 = stream . readBits ( 7 ) ; int l2 = stream . readBits ( 7 ) ; myPlayer . setPos ( l2 , k2 , j1 == 1 ) ; } }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	9X	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	1	public final ProgramaContext programa ( ) throws RecognitionException { ProgramaContext _localctx = new ProgramaContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_programa ) ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 10 ) ; seqComando ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	6	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	1	public void makeEven ( ) { if ( population . size ( ) % 2 == 1 ) { population . remove ( 0 ) ; } }
tr	5	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	5	public Iterable < Position < E >> findRange ( E minValue , E maxValue ) { List < Position < E >> l = new ArrayList < > ( ) ; List < Position < E >> todas = ( List < Position < E >> ) this . positions ( ) ; for ( Position < E > pos : todas ) { E curValue = pos . element ( ) ; int compMin = findComparator . compare ( curValue , minValue ) ; int compMax = findComparator . compare ( curValue , maxValue ) ; boolean overMin = ( ( compMin == 0 ) || ( compMin == 1 ) ) ; boolean underMax = ( ( compMax == 0 ) || ( compMax == - 1 ) ) ; if ( overMin && underMax ) { l . add ( pos ) ; } } return l ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
tr	3	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	3	public void modifyCourse ( ClassInfo classInfo ) { ClassInfo cInfoData = getCourse ( classInfo . getClassNumber ( ) ) ; if ( cInfoData != null ) { if ( ! classInfo . getCourseName ( ) . equalsIgnoreCase ( cInfoData . getCourseName ( ) ) ) { Course crs = new Course ( ) ; crs . setCourseID ( classInfo . getCourseNumber ( ) ) ; crs . setCourseName ( classInfo . getCourseName ( ) ) ; saveDataModify ( crs ) ; } if ( ! classInfo . getCourseSection ( ) . equalsIgnoreCase ( cInfoData . getCourseSection ( ) ) ) { SchoolClass cls = new SchoolClass ( ) ; cls . setClassNumber ( classInfo . getClassNumber ( ) ) ; cls . setClassSection ( classInfo . getCourseSection ( ) ) ; saveDataModify ( cls ) ; } } }
tr	4	private int calcNumPattern ( int n , int r ) { if ( n == r ) return 1 ; else if ( n == 1 ) return 1 ; else if ( r == 1 ) return n ; if ( dp [ n ] [ r ] == 0 ) dp [ n ] [ r ] = ( calcNumPattern ( n - 1 , r - 1 ) + calcNumPattern ( n - 1 , r ) ) % NUM_MOD ; return dp [ n ] [ r ] ; }
tr	6	public boolean equals ( Grade g ) { if ( ! this . assignmentId . equals ( g . getAssignmentId ( ) ) ) { return false ; } else if ( ! this . comments . equals ( g . getComments ( ) ) ) { return false ; } else if ( this . courseId != g . getCourseId ( ) ) { return false ; } else if ( this . ptsEarn != g . getPointsEarned ( ) ) { return false ; } else if ( this . ptsPoss != g . getPointsPossible ( ) ) { return false ; } else if ( ! this . title . equals ( g . getTitle ( ) ) ) { return false ; } else { return true ; } }
tr	1	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	7	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	6	public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( m == n ) return head ; ListNode dumy = new ListNode ( 0 ) ; dumy . next = head ; ListNode pre = dumy ; ListNode cur = head ; ListNode tail = null ; ListNode start = null ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) { tail = cur ; start = pre ; start . next = cur . next ; pre = cur ; cur = cur . next ; } else if ( i > m && i < n ) { start . next = cur . next ; cur . next = pre ; pre = cur ; cur = start . next ; } else if ( i == n ) { tail . next = cur . next ; cur . next = pre ; } else { pre = cur ; cur = cur . next ; } } return dumy . next ; }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Apply" ) ) { this . dispose ( ) ; System . out . println ( "aaaa" ) ; Tuple < String , Tuple < String , Integer >> player1Data = player1 . getPlayerData ( ) ; Tuple < String , Tuple < String , Integer >> player2Data = player2 . getPlayerData ( ) ; int deadFields = this . deadFields . getDeadFieldNumber ( ) ; System . out . println ( deadFields ) ; System . out . println ( "bbb" ) ; Player [ ] players = { new Player ( player1Data . getFirstElement ( ) , player1Data . getSecondElement ( ) . getFirstElement ( ) , "w" , player1Data . getSecondElement ( ) . getSecondElement ( ) ) , new Player ( player2Data . getFirstElement ( ) , player2Data . getSecondElement ( ) . getFirstElement ( ) , "b" , player2Data . getSecondElement ( ) . getSecondElement ( ) ) , } ; System . out . println ( "ccc" ) ; try { masterGui . newGame ( players , deadFields ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "ddd" ) ; } }
tr	8	@ Override public void run ( ) { isRunning = true ; while ( isRunning ) { if ( mediaPlayer != null ) { if ( ! warningPassed && passedTime > TIME_GREEN ) { warningPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "dong03.wav" ) ; } if ( ! finishPassed && passedTime > TIME_YELLOW ) { finishPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "end.wav" ) ; } } try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { repaint ( ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } Thread . yield ( ) ; } }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	2	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	5	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	4	private void mnuSaveAsTemplateActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser jfc = new JFileChooser ( ) ; jfc . setFileFilter ( new FileNameExtensionFilter ( "xml Datei" , "xml" ) ) ; if ( jfc . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File f = jfc . getSelectedFile ( ) ; if ( ! f . getName ( ) . endsWith ( ".xml" ) ) f = new File ( f . getAbsolutePath ( ) + ".xml" ) ; try { SemesterLoader . saveAsTemplate ( f , semesterList ) ; } catch ( JDOMException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	6	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	1	private int getMaxLen ( ) throws ValidationException { String text = this . maxLenTextField . getText ( ) ; try { int M = Integer . parseInt ( text ) ; return M ; } catch ( Exception e ) { String message = "The maximum length is not an integer number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	6	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	3	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	4	private static Expr resolveNoneParamExpr ( SyntaxTreeNode node ) { LexToken token = node . getToken ( ) ; String text = token . getText ( ) ; switch ( ( NagisaLexTokenType ) token . getType ( ) ) { case LITERAL_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerLiteral , text ) ; case IDENTIFIER_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerVariableRef , text ) ; case LITERAL_STRING : return new Expr ( ExprType . String , ExprOperator . StringLiteral , text ) ; case IDENTIFIER_STRING : return new Expr ( ExprType . String , ExprOperator . StringVariableRef , text ) ; default : throw new UnsupportedOperationException ( token . toString ( ) ) ; } }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	2	@ Override public int compareTo ( PathNode o ) { if ( cost < o . cost ) return - 1 ; if ( cost > o . cost ) return 1 ; return 0 ; }
tr	5	public static Integer convertStringToNumber ( String str ) { str = str . toLowerCase ( ) ; int num = ones . indexOf ( str ) ; if ( num > - 1 ) { return num ; } num = tens . indexOf ( str ) ; if ( num > - 1 ) { return num * 10 ; } String arr [ ] = str . split ( " |-" ) ; if ( arr . length == 2 ) { num = tens . indexOf ( arr [ 0 ] ) * 10 ; if ( num > - 1 ) { num += ones . indexOf ( arr [ 1 ] ) ; if ( num > 20 ) { return num ; } } } return null ; }
tr	6	public Editor ( DefaultMutableTreeNode node , DefaultTreeModel model ) throws InvalidNodeRepresentationException { _node = node ; _model = model ; _children = new ArrayList < > ( ) ; if ( _node . getUserObject ( ) instanceof Song ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = ( Song ) node . getUserObject ( ) ; _playlist = null ; _artist = new JTextField ( _song . getArtist ( ) ) ; _title = new JTextField ( _song . getTitle ( ) ) ; _album = new JTextField ( _song . getAlbum ( ) ) ; _genre = new JTextField ( _song . getGenre ( ) ) ; _year = new JTextField ( _song . getYear ( ) ) ; _name = null ; JLabel artist = new JLabel ( "Artist:" ) ; JLabel title = new JLabel ( "Title:" ) ; JLabel album = new JLabel ( "Album:" ) ; JLabel genre = new JLabel ( "Genre:" ) ; JLabel year = new JLabel ( "Year:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( artist ) ; add ( _artist ) ; add ( title ) ; add ( _title ) ; add ( album ) ; add ( _album ) ; add ( genre ) ; add ( _genre ) ; add ( year ) ; add ( _year ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , artist , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _artist , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _artist , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . WEST , title , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . EAST , _title , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _title , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . WEST , album , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . EAST , _album , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _album , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . WEST , genre , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . EAST , _genre , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _genre , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . WEST , year , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . EAST , _year , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _year , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _year ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _year ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else if ( _node . getUserObject ( ) instanceof Playlist ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = null ; _playlist = ( Playlist ) node . getUserObject ( ) ; _artist = null ; _title = null ; _album = null ; _genre = null ; _year = null ; _name = new JTextField ( _playlist . getName ( ) ) ; JLabel name = new JLabel ( "Title:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( name ) ; add ( _name ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , name , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _name , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _name , 5 , SpringLayout . EAST , name ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _name ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _name ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else { throw new InvalidNodeRepresentationException ( "Node must represent a Song or Playlist" ) ; } }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	2	private int validateProtocol ( ) throws IOException { int resp = this . sendDummyRequest ( ) ; if ( ! this . sc . isSecureConnection ( ) ) { this . sc . setSecureConnection ( true ) ; try { resp = this . sendDummyRequest ( ) ; } catch ( SSLException e ) { this . sc . setSecureConnection ( false ) ; } } return resp ; }
tr	5	public void Editar ( Produto produto ) throws Exception { if ( produto == null ) { throw new Exception ( "Selecione um produto" ) ; } if ( produto . getIdProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o id do produto." ) ; } if ( produto . getNomeProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir o nome do produto." ) ; } if ( produto . getTipoProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir tipo do produto." ) ; } if ( produto . getValorProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o valor unit\u00E1rio do produto." ) ; } ProdutoController . obterInstancia ( ) . Editar ( produto ) ; }
tr	7	public Object getValueAt ( Object node , int column ) { FileNode fn = ( FileNode ) node ; try { switch ( column ) { case 0 : return fn . getFile ( ) . getName ( ) ; case 1 : if ( fn . isTotalSizeValid ( ) ) { return new Integer ( ( int ) ( ( FileNode ) node ) . totalSize ( ) ) ; } return null ; case 2 : return fn . isLeaf ( ) ? "File" : "Directory" ; case 3 : return fn . lastModified ( ) ; } } catch ( SecurityException se ) { } return null ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	7	public static String encode ( String text , int offset ) { char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { int c = chars [ i ] ; if ( c >= a && c <= z ) { c += offset ; if ( c > z ) { c = a + ( c - z - 1 ) ; } else if ( c < a ) { c = z - ( a - c ) + 1 ; } } else { c += offset ; if ( c > Z ) { c = A + ( c - Z - 1 ) ; } else if ( c < A ) { c = Z - ( A - c ) + 1 ; } } chars [ i ] = ( char ) c ; } return new String ( chars ) ; }
tr	5	public void paintTriangle ( Graphics g , int x , int y , int size ) { for ( int i = 0 ; i < size ; i ++ ) { switch ( facing ) { case UP : g . drawLine ( x - i , y - size / 2 + i , x + i , y - size / 2 + i ) ; break ; case DOWN : g . drawLine ( x - i , y + size / 2 - i , x + i , y + size / 2 - i ) ; break ; case LEFT : g . drawLine ( x - size / 2 + i , y - i , x - size / 2 + i , y + i ) ; break ; case RIGHT : g . drawLine ( x + size / 2 - i , y - i , x + size / 2 - i , y + i ) ; break ; } } }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	9X	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
tr	4	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Schedule schedule = ( Schedule ) o ; if ( id != schedule . id ) return false ; if ( seqNumber != schedule . seqNumber ) return false ; return true ; }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_BitcoinAcct ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	9X	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
tr	4	public Tile cross ( Tile currentTile , Character crosser ) { if ( crosser == null || currentTile == null ) { throw new IllegalArgumentException ( "currentTile and crosser cannot be null" ) ; } if ( ! crosser . equals ( currentTile . getCharacter ( ) ) ) { throw new IllegalArgumentException ( "The given character must be on the given tile" ) ; } if ( ! canCross ( crosser ) ) { throw new IllegalArgumentException ( "The given character is not capable of crossing this edge" ) ; } Tile destination = getOtherTile ( currentTile ) ; currentTile . removeCharacter ( ) ; destination . addCharacter ( crosser ) ; return destination ; }
tr	6	private static RubixPermutation parseMove ( char m ) { switch ( m ) { case F : return RubixPermutation . FRONT ; case B : return RubixPermutation . BACK ; case L : return RubixPermutation . LEFT ; case R : return RubixPermutation . RIGHT ; case U : return RubixPermutation . UP ; case D : return RubixPermutation . DOWN ; default : return RubixPermutation . IDENTITY ; } }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	8	public SharingPanel ( int w , int h ) { super ( ) ; this . width = w ; this . height = h ; this . isSelected = false ; this . setBackground ( Constants . backColor ) ; this . setLayout ( null ) ; this . selectedInfo = "" ; bgImg = new JLabel ( new ImageIcon ( Constants . BackgroudPath . shareListBG . getPath ( ) ) ) ; bgImg . setBounds ( 0 , 0 , width , height ) ; shareTo = new ImageIcon [ 3 ] ; shareTo [ 0 ] = new ImageIcon ( Constants . IconPath . shareToIcon1 . getPath ( ) ) ; shareTo [ 1 ] = new ImageIcon ( Constants . IconPath . shareToIcon2 . getPath ( ) ) ; shareTo [ 2 ] = new ImageIcon ( Constants . IconPath . shareToIcon3 . getPath ( ) ) ; shareFrom = new ImageIcon [ 3 ] ; shareFrom [ 0 ] = new ImageIcon ( Constants . IconPath . shareFromIcon1 . getPath ( ) ) ; shareFrom [ 1 ] = new ImageIcon ( Constants . IconPath . shareFromIcon2 . getPath ( ) ) ; shareFrom [ 2 ] = new ImageIcon ( Constants . IconPath . shareFromIcon3 . getPath ( ) ) ; handler = new ActionHandler ( ) ; tableModel = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; tableModel . setColumnIdentifiers ( new String [ ] { "    User ID" , "    Directory" , "  Status" , "" , "" , "" } ) ; table = new JTable ( ) { public class getColumnClass ( int column ) { return getValueAt ( 0 , column ) . getClass ( ) ; } } ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . setRowHeight ( 30 ) ; table . setFont ( Constants . Font1 ) ; table . setModel ( tableModel ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 130 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 150 ) ; table . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 100 ) ; for ( int i = 3 ; i < 6 ; i ++ ) { table . getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMinWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMaxWidth ( 0 ) ; } table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) && ! editMode ) { isSelected = true ; selectedInfo = "" ; if ( table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareTo [ 0 ] ) || table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareFrom [ 0 ] ) ) { initialize ( ) ; if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Target" ) ) { selectedInfo = "Target" ; } else if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Requester" ) ) { selectedInfo = "Requester" ; } } changePanel ( ) ; } } } ) ; header = table . getTableHeader ( ) ; header . setFont ( Constants . Font2 ) ; header . setEnabled ( false ) ; renderer = new DefaultTableCellRenderer ( ) ; renderer . setHorizontalAlignment ( JLabel . CENTER ) ; renderer . setFont ( getFont ( ) . deriveFont ( 80f ) ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( renderer ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( renderer ) ; scroll = new JScrollPane ( table , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setBounds ( 200 , 200 , 400 , 250 ) ; btn = new JButton [ 4 ] ; btn [ 0 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . confirmBtn1 . getPath ( ) ) ) ; btn [ 0 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . confirmBtn2 . getPath ( ) ) ) ; btn [ 1 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . cancelBtn1 . getPath ( ) ) ) ; btn [ 1 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . cancelBtn2 . getPath ( ) ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) { btn [ i ] . setBounds ( 420 + ( i * 100 ) , 160 , 80 , 30 ) ; btn [ i ] . addActionListener ( handler ) ; } this . add ( scroll ) ; this . add ( bgImg ) ; }
tr	5	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	8	private void updateClaim ( boolean choice1 ) { switch ( claim . getStatus ( ) ) { case UnRanked : claim . rank ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ; JOptionPane . showMessageDialog ( form , "The claim has been ranked " + ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ) ; break ; case Ranked : claim . setStatus ( choice1 ? Claim . Status . Confirmed : Claim . Status . Declined ) ; if ( choice1 ) { String billingInfo = AutomaticCustomerEmulator . sendForm ( ) ; storage . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , billingInfo ) ; } else AutomaticCustomerEmulator . sendMail ( "Your claim was denied" ) ; JOptionPane . showMessageDialog ( form , "The claim has been " + ( choice1 ? "confirmed" : "declined" ) ) ; break ; default : return ; } storage . updateClaim ( claim ) ; if ( listener != null ) { listener . actionPerformed ( new ActionEvent ( this , 0 , null ) ) ; } }
tr	6	public int [ ] likertJakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	1	@ Test public void setFormat_shouldThrowAnException_whenTypeIsNotStringAndFormatIsTime ( ) throws Exception { SimpleTypeSchema schema = new SimpleTypeSchema ( ) ; schema . setType ( SimpleType . NUMBER ) ; try { schema . setFormat ( "time" ) ; fail ( "Expected an exception" ) ; } catch ( IllegalArgumentException e ) { } }
tr	1	public void executar ( AmbienteExecucao ambiente ) { try { comando . executar ( ambiente ) ; } catch ( IdentificadorJaDeclaradoException | IdentificadorNaoDeclaradoException e ) { e . printStackTrace ( ) ; } }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	4	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	8	@ Override protected void process ( ) { StringTokenizer t = new StringTokenizer ( fileL . getListString ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasMoreTokens ( ) ; files ++ ) { String s = t . nextToken ( ) ; String title = Print . titleString ( "--" , s ) ; if ( showAllFiles ) { Print . ln ( title ) ; title = null ; } int i = 0 ; try ( BufferedReader in = new BufferedReader ( new FileReader ( s ) ) ) { for ( int line = 1 ; ( s = in . readLine ( ) ) != null ; line ++ ) if ( fnameFilter . accept ( s ) ) { if ( title != null ) { Print . ln ( title ) ; title = null ; } Print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( IOException ioe ) { Sys . warning ( ioe . toString ( ) ) ; } if ( i > 0 || showAllFiles ) { Print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } Print . ln ( Print . separator ( "==========================" ) ) ; Print . ln ( "Totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	2	private DefaultConstructorFactory getDefaultConstructorFactory ( ) { lock . lock ( ) ; try { DefaultConstructorFactory factory = null ; try { factory = new SunDefaultConstructorFactory ( ) ; } catch ( Exception e ) { } if ( factory == null ) factory = new NoDefaultConstructorFactory ( ) ; return factory ; } finally { lock . unlock ( ) ; } }
tr	6	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	4	@ Override public void run ( ) { try { String hostname = NetBase . theNetBase ( ) . hostname ( ) ; if ( hostname != null ) { if ( hostname . isEmpty ( ) ) System . out . println ( "Host: root" ) ; else System . out . println ( "Host: '" + hostname + "'" ) ; } else System . out . println ( "Host: none" ) ; RPCService rpcService = ( RPCService ) NetBase . theNetBase ( ) . getService ( "rpc" ) ; if ( rpcService != null ) System . out . println ( "IP: " + IPFinder . localIP ( ) + "  Port: " + rpcService . localPort ( ) ) ; else System . out . println ( "No RPC service is running on this node." ) ; } catch ( Exception e ) { System . out . println ( "Caught exception: " + e . getMessage ( ) ) ; } }
tr	8	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p >= N && q >= N ) { return false ; } else if ( a >= M && b >= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	7	protected void prepare_sample_reading ( Header header , int allocation , int channel , float [ ] factor , int [ ] codelength , float [ ] c , float [ ] d ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) { groupingtable [ channel ] = table_cd_groupingtables [ allocation ] ; factor [ 0 ] = table_cd_factor [ allocation ] ; codelength [ 0 ] = table_cd_codelength [ allocation ] ; c [ 0 ] = table_cd_c [ allocation ] ; d [ 0 ] = table_cd_d [ allocation ] ; } else { if ( subbandnumber <= 2 ) { groupingtable [ channel ] = table_ab1_groupingtables [ allocation ] ; factor [ 0 ] = table_ab1_factor [ allocation ] ; codelength [ 0 ] = table_ab1_codelength [ allocation ] ; c [ 0 ] = table_ab1_c [ allocation ] ; d [ 0 ] = table_ab1_d [ allocation ] ; } else { groupingtable [ channel ] = table_ab234_groupingtables [ allocation ] ; if ( subbandnumber <= 10 ) { factor [ 0 ] = table_ab2_factor [ allocation ] ; codelength [ 0 ] = table_ab2_codelength [ allocation ] ; c [ 0 ] = table_ab2_c [ allocation ] ; d [ 0 ] = table_ab2_d [ allocation ] ; } else if ( subbandnumber <= 22 ) { factor [ 0 ] = table_ab3_factor [ allocation ] ; codelength [ 0 ] = table_ab3_codelength [ allocation ] ; c [ 0 ] = table_ab3_c [ allocation ] ; d [ 0 ] = table_ab3_d [ allocation ] ; } else { factor [ 0 ] = table_ab4_factor [ allocation ] ; codelength [ 0 ] = table_ab4_codelength [ allocation ] ; c [ 0 ] = table_ab4_c [ allocation ] ; d [ 0 ] = table_ab4_d [ allocation ] ; } } } }
tr	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
tr	6	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	9X	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
tr	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	9X	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	3	public NodeUnion ( Link [ ] links ) { if ( links == null || links . length < 2 || links . length > 4 ) { throw new IllegalArgumentException ( "Links size must be >=2 and <=4" ) ; } this . links = links ; }
tr	7	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	6	private void method130 ( int j , int k , int l , int i1 , int j1 , int k1 , int l1 , int i2 , int j2 ) { Class30_Sub1 class30_sub1 = null ; for ( Class30_Sub1 class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetFirst ( ) ; class30_sub1_1 != null ; class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetNext ( ) ) { if ( class30_sub1_1 . anInt1295 != l1 || class30_sub1_1 . anInt1297 != i2 || class30_sub1_1 . anInt1298 != j1 || class30_sub1_1 . anInt1296 != i1 ) continue ; class30_sub1 = class30_sub1_1 ; break ; } if ( class30_sub1 == null ) { class30_sub1 = new Class30_Sub1 ( ) ; class30_sub1 . anInt1295 = l1 ; class30_sub1 . anInt1296 = i1 ; class30_sub1 . anInt1297 = i2 ; class30_sub1 . anInt1298 = j1 ; method89 ( class30_sub1 ) ; aClass19_1179 . insertHead ( class30_sub1 ) ; } class30_sub1 . anInt1291 = k ; class30_sub1 . anInt1293 = k1 ; class30_sub1 . anInt1292 = l ; class30_sub1 . anInt1302 = j2 ; class30_sub1 . anInt1294 = j ; }
tr	9X	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	8	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	3	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	8	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	4	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
tr	0	public int process_id ( ) { return 2 ; }
tr	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
tr	4	private void addSegmentsFor ( Obstacle source , Obstacle target ) { if ( source . intersects ( target ) ) addAllSegmentsBetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addSegmentsTargetAboveSource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addSegmentsTargetAboveSource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addSegmentsTargetBesideSource ( source , target ) ; else addSegmentsTargetBesideSource ( target , source ) ; }
tr	8	private void createGame ( ) { gameName = fieldGameName . getText ( ) ; playerNameHost = fieldPlayerName . getText ( ) ; Enumeration < NetworkInterface > nets = null ; try { nets = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e1 ) { } Vector < String > l = new Vector < String > ( ) ; for ( NetworkInterface netint : Collections . list ( nets ) ) { Enumeration < InetAddress > inetAddresses = netint . getInetAddresses ( ) ; for ( InetAddress inetAddress : Collections . list ( inetAddresses ) ) { l . add ( netint . getDisplayName ( ) + " (" + inetAddress . toString ( ) . substring ( 1 ) + ")" ) ; } } Object selVal = JOptionPane . showInputDialog ( this , "Choose interface to bind" , "Input" , JOptionPane . INFORMATION_MESSAGE , null , l . toArray ( ) , l . elementAt ( 0 ) ) ; String ip = selVal . toString ( ) ; int beg = ip . lastIndexOf ( ( ) ; int end = ip . lastIndexOf ( ) ) ; String ipAddr = selVal . toString ( ) . substring ( beg + 1 , end ) ; try { addr = InetAddress . getByName ( ipAddr ) ; } catch ( UnknownHostException e1 ) { } if ( gameName == null || gameName . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each game needs a name" , "Game Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( playerNameHost == null || playerNameHost . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each player needs a name" , "Player Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } dispose ( ) ; s = new Server ( ipAddr ) ; adapter . connectToServer ( addr , playerNameHost ) ; hostFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; hostFrame . setTitle ( "Snake on Lan - Host Game" ) ; hostFrame . setVisible ( true ) ; hostFrame . setResizable ( false ) ; hostFrame . setLocationRelativeTo ( null ) ; StartSnakeGame . frame . dispose ( ) ; }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	7	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; xa = shell . facing * 2 ; ya = - 5 ; flyDeath = true ; if ( spriteTemplate != null ) spriteTemplate . isDead = true ; deadTime = 100 ; winged = false ; hPic = - hPic ; yPicO = - yPicO + 16 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	6	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf (   ) + 1 ; final int endOfTag = line . indexOf (   , startOfTag + 1 ) ; if ( startOfTag < 1 || endOfTag < 1 ) { return ; } final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { final double timeLong = double . parseDouble ( strTimeTag ) ; final Date timeTag = new Date ( ( long ) timeLong . doubleValue ( ) * 1000 ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVisualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	3	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	5	public void next ( boolean respectRandom ) { if ( ! randomOrder || ! respectRandom ) { index ++ ; if ( index >= record . getRecordCount ( ) ) { index = 0 ; } } else if ( respectRandom ) { index = rand . nextInt ( record . getRecordCount ( ) ) ; } currentRecord = record . getRecordNumber ( index , false ) ; if ( currentRecord . getExtra1 ( ) . indexOf ( "rem=s" ) >= 0 ) { next ( ) ; } }
tr	1	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
tr	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	8	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	3	private ArraySchema parseArraySchema ( JsonNode rawSchema , URL schemaLocation ) { ArraySchema result = new ArraySchema ( ) ; JsonNode rawItems = rawSchema . get ( "items" ) ; if ( rawItems != null ) { result . setItems ( parse ( rawItems , schemaLocation ) ) ; } JsonNode rawMinItems = rawSchema . get ( "minItems" ) ; if ( rawMinItems != null ) { result . setMinItems ( rawMinItems . intValue ( ) ) ; } JsonNode rawMaxItems = rawSchema . get ( "maxItems" ) ; if ( rawMaxItems != null ) { result . setMaxItems ( rawMaxItems . intValue ( ) ) ; } return result ; }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	9X	private static boolean isUnreserved ( char c ) { return ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || c == . || c == - || c == _ || c == ~ ; }
tr	5	public boolean isWallhugPosition ( int x , int y ) { if ( getFreeCount ( x , y ) != 2 ) return false ; else if ( isEmpty ( moveLeft ( x ) , y ) && isEmpty ( moveRight ( x ) , y ) ) return false ; else if ( isEmpty ( x , moveUp ( y ) ) && isEmpty ( x , moveDown ( y ) ) ) return false ; else return true ; }
tr	6	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	8	private void waitForAndConnectClients ( ) { boolean afterFirstPlayer ; try { ServerSocket serverSocket = new ServerSocket ( PORT ) ; Socket clientSocket = new Socket ( ) ; acceptConnections ( serverSocket , clientSocket ) ; } catch ( SocketTimeoutException ste ) { System . out . println ( "SocketTimeoutException occured in Server" ) ; boolean exitLoop = false ; if ( Server . numOfClients >= 2 ) { this . startupPG . broadcastMessage ( "sBegin" ) ; while ( exitLoop == false ) { if ( this . startupPG . arePlayersReadyToPlay ( ) == true ) { cGame45 . beginRound ( ) ; exitLoop = true ; } else { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { System . err . println ( "Server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { System . out . println ( "Timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( IOException ioe ) { System . out . println ( "IO Exception occured in Server" ) ; } catch ( SecurityException sc ) { System . out . println ( "SecurityExceptionException occured in Server" ) ; } catch ( IllegalBlockingModeException ibme ) { System . out . println ( "IllegalBlockingModeException occured in Server" ) ; } }
tr	9X	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
tr	6	private void readPolar ( ) throws IOException { long currTime ; while ( isRead ) { currTime = System . currentTimeMillis ( ) ; int msg = inputStream . read ( ) ; if ( msg == 254 ) { printMessage ( "\n" + System . currentTimeMillis ( ) + ": " ) ; polarMessageTmp = new PolarMessage ( System . currentTimeMillis ( ) ) ; } else if ( msg == - 1 ) { System . out . println ( "Roz\u0142\u0105czono" ) ; stopRead ( ) ; break ; } else if ( polarMessageTmp != null && polarMessageTmp . setNextValue ( msg ) ) { message = new PolarMessage ( System . currentTimeMillis ( ) ) ; message . setHr ( polarMessageTmp . getHr ( ) ) ; } if ( currTime - System . currentTimeMillis ( ) > 3000 ) { System . out . println ( "Zbyt d\u0142ugi czas oczekiwania" ) ; } printMessage ( " " + msg ) ; } }
tr	1	@ Override public BigDecimal evaluate ( String mathExpression ) throws EvaluationException { EvaluationContext context = new EvaluationContext ( mathExpression ) ; try { return run ( context ) ; } catch ( Exception ex ) { throw new EvaluationException ( ex . getMessage ( ) , context . getCurrentPosition ( ) ) ; } }
tr	8	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	9X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	6	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
tr	9X	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	2	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	2	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	2	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; if ( filterByID ( spg . getSquareNeighbors ( x , y , 1 ) , juggernaut . id ) . isEmpty ( ) ) { Location loc = spg . getFirstSquareNeighborLocation ( x , y , 2 , zombie . id ) ; spg . moveEntity ( x , y , loc == null ? Location . wander ( x , y , 1 ) : Location . away ( x , y , loc , 2 ) ) ; } }
tr	4	@ Override public void run ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Message > responses ) { responses . add ( MSG ( msgInfo . ROOM , msgInfo . NICK + " has been marked as away.  Use !back to rejoin." ) ) ; Name name = gameManager . m_nickToNameMap . get ( msgInfo . NICK ) ; ata . m_activePlayers . remove ( name ) ; if ( ata . m_activePlayers . size ( ) < 3 ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botendgame " + msgInfo . ROOM ) ) ; } if ( ata . m_judge . equals ( msgInfo . NICK ) ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botcleanup " + msgInfo . ROOM ) ) ; } else if ( ata . m_state == State . PLAY ) { ata . m_waiting . remove ( name ) ; if ( ata . m_waiting . size ( ) == 0 ) { ata . m_waiting . remove ( name ) ; responses . add ( MSG ( gameManager . getName ( ) , "!botchoose " + msgInfo . ROOM ) ) ; } } }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	4	public void onSessionStatusChanged ( O2GSessionStatusCode status ) { System . out . println ( "Status: " + status . toString ( ) ) ; switch ( status ) { case TRADING_SESSION_REQUESTED : if ( mSessionID . isEmpty ( ) ) { System . out . println ( "Argument for trading session ID is missing" ) ; } else { mSession . setTradingSession ( mSessionID , mPin ) ; } break ; case CONNECTED : mConnected = true ; mDisconnected = false ; mSemaphore . release ( ) ; break ; case DISCONNECTED : mConnected = false ; mDisconnected = true ; mSemaphore . release ( ) ; break ; } }
tr	4	static void createNewPearltree ( Panel panel , boolean active ) { final Label item = createLabel ( ) ; final FlowPanel description = new FlowPanel ( ) ; item . setText ( "a new pearltree" ) ; if ( WebContent . onIpad ) { description . setStylePrimaryName ( PRIMARY_STYLE_NEWPEARLTREE ) ; panel . add ( description ) ; HTML newPearltreeBox = PopupElements . createHtml ( ) ; newPearltreeBox . setStylePrimaryName ( PopupElements . PRIMARY_STYLE_AVATARBOX ) ; newPearltreeBox . addStyleDependentName ( PopupElements . STYLE_SPECIAL_PADDING ) ; newPearltreeBox . setHTML ( NEW_PEARLTREE ) ; description . add ( newPearltreeBox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! WebContent . onIpad ) { item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_BOLD ) ; item . addStyleDependentName ( STYLE_PADDING ) ; } item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_ITEM ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { if ( WebContent . onIpad ) { description . addStyleDependentName ( STYLE_SELECTED_TIMER ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { DOM . removeElementAttribute ( TreeListUI . panelInside . getElement ( ) , "id" ) ; PopupControl . changeUI ( PopupUIs . NewTree ) ; } } ; t . schedule ( 120 ) ; } else { PopupControl . changeUI ( PopupUIs . NewTree ) ; } } } ) ; } else { item . addStyleDependentName ( STYLE_INACTIVE ) ; } }
tr	7	private Bed getBed ( CommandLine cmd ) { Bed bed = null ; if ( cmd . hasOption ( "hostel_id" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "bed_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setNumber ( new Integer ( cmd . getOptionValue ( "bed_number" ) ) ) ; } if ( cmd . hasOption ( "room_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setRoomNo ( new Integer ( cmd . getOptionValue ( "room_number" ) ) ) ; } if ( bed != null ) bed . setTariff ( null ) ; return bed ; }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . suit . equals ( leadSuit ) && o2 . suit . equals ( leadSuit ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . suit . equals ( leadSuit ) ) { return 1 ; } else if ( o2 . suit . equals ( leadSuit ) ) { return - 1 ; } else { return 0 ; } } }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	7	public void put ( String key , MqttPersistable message ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; File backupFile = new File ( clientDir , key + MESSAGE_FILE_EXTENSION + MESSAGE_BACKUP_FILE_EXTENSION ) ; if ( file . exists ( ) ) { boolean result = file . renameTo ( backupFile ) ; if ( ! result ) { backupFile . delete ( ) ; file . renameTo ( backupFile ) ; } } try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( message . getHeaderBytes ( ) , message . getHeaderOffset ( ) , message . getHeaderLength ( ) ) ; if ( message . getPayloadBytes ( ) != null ) { fos . write ( message . getPayloadBytes ( ) , message . getPayloadOffset ( ) , message . getPayloadLength ( ) ) ; } fos . getFD ( ) . sync ( ) ; fos . close ( ) ; if ( backupFile . exists ( ) ) { backupFile . delete ( ) ; } } catch ( IOException ex ) { throw new MqttPersistenceException ( ex ) ; } finally { if ( backupFile . exists ( ) ) { boolean result = backupFile . renameTo ( file ) ; if ( ! result ) { file . delete ( ) ; backupFile . renameTo ( file ) ; } } } }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ProjectUser ) ) { return false ; } ProjectUser other = ( ProjectUser ) object ; if ( ( this . projectUserPK == null && other . projectUserPK != null ) || ( this . projectUserPK != null && ! this . projectUserPK . equals ( other . projectUserPK ) ) ) { return false ; } return true ; }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	9X	public static String getTypeName ( class < ? extends Tag > clazz ) { if ( clazz . equals ( ByteArrayTag . class ) ) { return "TAG_Byte_Array" ; } else if ( clazz . equals ( ByteTag . class ) ) { return "TAG_Byte" ; } else if ( clazz . equals ( CompoundTag . class ) ) { return "TAG_Compound" ; } else if ( clazz . equals ( DoubleTag . class ) ) { return "TAG_Double" ; } else if ( clazz . equals ( EndTag . class ) ) { return "TAG_End" ; } else if ( clazz . equals ( FloatTag . class ) ) { return "TAG_Float" ; } else if ( clazz . equals ( IntArrayTag . class ) ) { return "TAG_Int_Array" ; } else if ( clazz . equals ( IntTag . class ) ) { return "TAG_Int" ; } else if ( clazz . equals ( ListTag . class ) ) { return "TAG_List" ; } else if ( clazz . equals ( LongTag . class ) ) { return "TAG_Long" ; } else if ( clazz . equals ( ShortTag . class ) ) { return "TAG_Short" ; } else if ( clazz . equals ( StringTag . class ) ) { return "TAG_String" ; } else if ( clazz . equals ( ListStringArrayTag . class ) ) { return "TAG_ListString_Array" ; } else if ( clazz . equals ( ListItemStackArrayTag . class ) ) { return "TAG_ListItemStack_Array" ; } else { throw new IllegalArgumentException ( "Invalid tag classs (" + clazz . getName ( ) + ")." ) ; } }
tr	2	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	3	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c ==  || c ==  ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	4	@ Override public int attachSoundEffect ( SoundEffect effect , int channel ) { if ( channel > chEffects . size ( ) ) throw new IndexOutOfBoundsException ( "Channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getChannelCount ( ) != channelCount ) throw new IllegalArgumentException ( "The effects channel count must be same as this mixers channel count!" ) ; mEffects . add ( effect ) ; return mEffects . size ( ) - 1 ; } else { if ( effect . getChannelCount ( ) != getInputChannelOutputChannelCount ( channel ) ) throw new IllegalArgumentException ( "The effects channel count must be the same as input channels channel count!" ) ; ArrayList < SoundEffect > e = chEffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	8	@ Override protected void handleInboxItem ( InboxItem inboxItem ) { super . handleInboxItem ( inboxItem ) ; if ( inboxItem . getMessage ( ) instanceof TokenMessage ) { executeTurn ( ) ; } if ( inboxItem . getMessage ( ) instanceof LeaderElectionMessage ) { LeaderElectionMessage message = ( LeaderElectionMessage ) inboxItem . getMessage ( ) ; switch ( message . getLeaderElectionMessageType ( ) ) { case ASK_FOR_ROLL : { doRoll ( inboxItem . getSender ( ) ) ; break ; } case LEADER_ELECTED : { initRound ( ) ; ownPlayer . setActive ( true ) ; if ( message . getValue ( ) == ownEndpoint . getId ( ) ) { isDealer = true ; logger . info ( "New Dealer" ) ; sendToken ( getPreviousPlayer ( ) ) ; } else { logger . info ( "Player " + message . getValue ( ) + " is new dealer." ) ; } break ; } case ROLLED : { gatherRoll ( inboxItem . getSender ( ) , message ) ; break ; } } } if ( inboxItem . getMessage ( ) instanceof StatusMessage ) { handleStatusMessage ( ( StatusMessage ) inboxItem . getMessage ( ) ) ; } if ( inboxItem . getMessage ( ) instanceof DealerMessage ) { handleDealerMessage ( inboxItem . getSender ( ) , ( DealerMessage ) inboxItem . getMessage ( ) ) ; } }
tr	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	6	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	9X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	4	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
tr	2	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	7	@ Override public boolean done ( ArrayList < Node > nw , int fab ) { int a = ( ( BeaconFAB ) nw . get ( 0 ) . getFAB ( fab ) ) . A ; Set < Integer > armies = new HashSet < Integer > ( ) ; int min = Integer . MAX_VALUE ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( Node N : nw ) { armies . add ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A ) ; sw = ( ( BeaconFAB ) N . getFAB ( fab ) ) . D ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A != a ) { res = false ; } } return res ; }
tr	8	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	2	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; return ; } else if ( e . getSource ( ) == sparastangB ) { transaction ( true ) ; return ; } }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = opt ( key ) ; if ( object == null ) { put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	6	public static String replaceAll ( String origin , String oldPart , String replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldPart == null || oldPart . length ( ) == 0 ) { return origin ; } int index = origin . indexOf ( oldPart ) ; if ( index < 0 ) { return origin ; } StringBuffer sb = new StringBuffer ( origin ) ; do { sb . replace ( index , index + oldPart . length ( ) , replacement ) ; origin = sb . toString ( ) ; index = origin . indexOf ( oldPart ) ; } while ( index != - 1 ) ; return origin ; }
tr	3	public void eval ( Environment e ) { switch ( type ) { case Value : e . value ( e . thing ( this ) ) ; break ; case Name : e . value ( this ) ; break ; case Call : e . call ( this ) ; break ; default : throw new Error ( String . format ( "Primitive '%s' not implemented!" , value ) ) ; } }
tr	8	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	8	private final static boolean isVowel ( String in , int at , int length ) { if ( ( at < 0 ) || ( at >= length ) ) return false ; char it = in . charAt ( at ) ; if ( ( it == A ) || ( it == E ) || ( it == I ) || ( it == O ) || ( it == U ) || ( it == Y ) ) return true ; return false ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	5	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	8	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
tr	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
tr	5	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	8	protected FileRequestResponseMessage handleResponse ( InputStream in ) throws UnsupportedEncodingException { FileRequestResponseMessage try_again = new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . TRY_AGAIN_LATER , 0 ) ; int probe_len = FileRequestResponseMessage . TYPE_FIELD . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not read response stream: '" + e . getMessage ( ) + "' - assuming 'NEVER TRY AGAIN'" ) ; return try_again ; } String responseHeader = new String ( buffer , Message . ENCODING ) . trim ( ) ; switch ( responseHeader . toUpperCase ( ) ) { case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "OK" : String str_expectedTransferVolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != Message . MESSAGE_SPERATOR ) if ( next == - 1 ) { Thread . sleep ( 500 ) ; } else { str_expectedTransferVolume += new String ( new byte [ ] { ( byte ) next } , Message . ENCODING ) ; } } catch ( IOException | InterruptedException e ) { logger . log ( Level . SEVERE , "Could not understand response header" ) ; transferState = TransferStatus . LostConnection ; closeSocket ( ) ; return null ; } try { long expectedTransferVolume = long . valueOf ( str_expectedTransferVolume ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . OK , expectedTransferVolume ) ; } catch ( NumberFormatException ex ) { logger . log ( Level . SEVERE , "Response contained invalid 'expected transfer volume' - assuming 'TRY AGAIN LATER'" ) ; return try_again ; } case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "TRY" : logger . log ( Level . INFO , "Received 'try again later from host'" ) ; return try_again ; case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "NEV" : logger . log ( Level . INFO , "Received 'never try agiain from host'" ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . NEVER_TRY_AGAIN , 0 ) ; default : logger . log ( Level . INFO , "Received garbage: '" + responseHeader + "'" ) ; return try_again ; } }
tr	8	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	3	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
tr	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
tr	7	private String getOrientationString ( Orientations o ) { String os = "unknown" ; if ( o == Orientations . horizontal ) os = "horizontal" ; if ( o == Orientations . left ) os = "90\u00B0 left" ; if ( o == Orientations . right ) os = "90\u00B0 right" ; if ( o == Orientations . upside ) os = "180\u00B0" ; if ( myTFTType == TFTTypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( myTFTType == TFTTypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( myTFTType == TFTTypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	7	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	6	public MainFrame ( ) { initComponents ( ) ; preferences = Preferences . userRoot ( ) . node ( this . getClass ( ) . getName ( ) ) ; final String pathToPDFLaTeXFile = preferences . get ( "pathToPDFLaTeXFile" , null ) ; final String pathToPDFExportFolder = preferences . get ( "pathToPDFExportFolder" , null ) ; if ( ( pathToPDFLaTeXFile == null ) || ( pathToPDFExportFolder == null ) ) Config . initPreferences ( preferences ) ; if ( ( pathToPDFLaTeXFile != null ) && ( ! pathToPDFLaTeXFile . equals ( Config . default ) ) ) Config . setPDFLaTeXFile ( new File ( pathToPDFLaTeXFile ) ) ; if ( ( pathToPDFExportFolder != null ) && ( ! pathToPDFExportFolder . equals ( Config . default ) ) ) Config . setPDFExportFolder ( new File ( pathToPDFExportFolder ) ) ; parameterLabelArray = new javax . swing . JLabel [ ] { parameter1Label , parameter2Label , parameter3Label , parameter4Label } ; parameterArray = new javax . swing . JTextField [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problemPartComponentsArray = new JComponent [ ] { userAnswerField , checkButton , showSolutionLaTeXButton , showSolutionPlaintextButton , copyToClipboardButton , exportToPDFButton , resetButton } ; }
tr	7	private void insertDatabaseOperation ( Object object , Connection connection , DatabaseOperation databaseOperation ) { try { if ( ! object . getClass ( ) . isAnnotationPresent ( Table . class ) ) { throw new JStrykerException ( "Object(" + object + ") isn't Entity" ) ; } Table table = object . getClass ( ) . getAnnotation ( Table . class ) ; StringBuilder builder = new StringBuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isAnnotationPresent ( transient . class ) ) { continue ; } Column annotation = field . getAnnotation ( Column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getName ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; String string = builder . toString ( ) ; execute ( null , connection , new ByteArrayInputStream ( string . getBytes ( ) ) , databaseOperation ) ; } catch ( IllegalAccessException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	5	@ Override public void enter ( BlockNode block , Deque < BlockNode > stack ) { ChangeNode previous = null ; Iterator < Node > nodes = block . - . iterator ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . next ( ) ; if ( n instanceof ChangeNode ) { ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) { previous = null ; continue ; } if ( previous != null && cn . type == previous . type ) { previous . change += cn . change ; nodes . remove ( ) ; } else { previous = cn ; } } else { previous = null ; } } }
tr	8	@ Override public String replace ( String [ ] args , Page page ) { String image = "" ; String link = "" ; String alt = "image" ; for ( String arg : args ) { if ( arg . startsWith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startsWith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startsWith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startsWith ( "http:" ) ) { image = arg ; } else if ( arg . endsWith ( ".gif" ) || arg . endsWith ( ".png" ) ) { image = arg ; } else { throw new UnsupportedOperationException ( "Unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	2	public static void changeSize ( final File file , final long newSize ) { try { RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; randomAccessFile . setLength ( newSize ) ; randomAccessFile . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
tr	2	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	2	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	1	private Meter getSelectedMeter ( ) { Account temp = getSelectedAccount ( ) ; if ( temp != null ) { Meter m = temp . getMeter ( getSelectedMeterID ( ) ) ; return m ; } else return null ; }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	7	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Location" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</Location>\n" ; } return kml ; }
tr	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } else if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { Node < E > tmp = getIndex ( index - 1 ) ; tmp . setNext ( tmp . getNext ( ) . getNext ( ) ) ; _lenght -- ; } }
tr	4	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	9X	public static void main ( String [ ] args ) { boolean a , b ; System . out . println ( "a\tb\ta and b\ta or b\tnot a\tnot b \n" ) ; a = 3 > 5 ; b = 12 != 8 ; System . out . print ( "(3>5)\t(12!=8)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 5 >= 6 ; b = 3 != 3 ; System . out . print ( "(5>=6)\t(3!=3)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = - 7 == 8 ; System . out . print ( "(-7=8)\t(22)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + " NO SE PUEDE USAR EL 22\n" ) ; a = 21 != 12 ; b = true ; System . out . print ( "21!=12\t(true)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 4 == 2 ; b = 7 >= - 9 ; System . out . print ( "(4==2)\t(7>=-9)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	9X	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
tr	8	private int getKingAxisVal ( int loc ) { switch ( loc ) { case 0 : case 7 : return - 4 ; case 1 : case 6 : return - 2 ; case 2 : case 5 : return 2 ; case 3 : case 4 : return 4 ; default : return 0 ; } }
tr	7	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	2	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	3	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	9X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
va	6	public String pillcaseSearch ( String pillId ) { String status = "" ; String payer = "" ; String pillAmount = "" ; String number = "" ; String pillName = "" ; String pillNum = "" ; String str = "select distinct pl.payer p.pill_num rl.status pl.pill_amount p.number p.pill_name from pill p pill_list pl recepit_list rl where pl.id='" + pillId + "' and  p.pill_num=pl.pill_id and rl.receipt_id=pl.id and rl.pillOrEquip='1' order by p.pill_name;" ; System . out . println ( "pillcaseSearch________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; sb . append ( "<tr> <td>\u836F\u54C1\u540D\u79F0</td> <td>\u6570\u91CF</td> <td>\u5E93\u5B58\u6570\u91CF</td> </tr> " ) ; while ( num . next ( ) ) { pillNum = num . getString ( "pill_num" ) ; status = num . getString ( "status" ) ; payer = num . getString ( "payer" ) ; pillAmount = num . getString ( "pill_amount" ) ; number = num . getString ( "number" ) ; pillName = num . getString ( "pill_name" ) ; sb . append ( " <tr><td><input type=\"text\" value=\"" + pillName + "\" readonly><input type=\"text\" value=\"" + pillNum + "\" style=\"display:none\" name=\"pillid\"></td>" ) ; sb . append ( "<td><input type=\"text\" value=\"" + pillAmount + "\" name=\"pillAmount\" readonly> </td><td><input type=\"text\" value=\"" + number + "\" name=\"pillNum\" readonly></td></tr>" ) ; sb . append ( "<input type=\"text\"  value=\"" + pillId + "\" name=\"id\" style=\"display:none\">" ) ; } if ( status . equals ( "1" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u672A\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } else if ( status . equals ( "2" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u5DF2\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } if ( payer == null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u672A\u4ED8\u836F</td> </tr>" ) ; } else if ( payer != null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u5DF2\u4ED8\u836F</td> </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
va	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
va	2	protected void pausePlayback ( ) { if ( m_line != null ) { if ( m_status == PLAYING ) { m_line . stop ( ) ; m_status = PAUSED ; notifyEvent ( BasicPlayerEvent . PAUSED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_line . drain ( ) ; } } }
va	9X	public void checkCollisionsWithEnemies ( ArrayList < Enemy > list , Level1State state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getKilledByTop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getPlayerState ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
va	8	public void decode ( InputStream stream , int length , CharBuffer buffer ) throws IllegalArgumentException , IOException { if ( stream == null ) throw new IllegalArgumentException ( "stream cannot be null" ) ; if ( length < 0 ) throw new IllegalArgumentException ( "length [" + length + "] must be >= 0." ) ; if ( buffer == null ) throw new IllegalArgumentException ( "buffer cannot be null and must be a CharBuffer with a large enough capacity to hold at least 'length' (" + length + ") characters." ) ; if ( length > buffer . capacity ( ) ) throw new IllegalArgumentException ( "length [" + length + "] is larger than the capacity [" + buffer . capacity ( ) + "] of the given buffer; the CharBuffer must be big enough to contain all the characters decoded from the given InputStream." ) ; if ( length == 0 ) buffer . clear ( ) ; else { bBuffer . clear ( ) ; buffer . clear ( ) ; decoder . reset ( ) ; int read = 0 ; while ( length > 0 && ( read = stream . read ( rBuffer , 0 , length ) ) != - 1 ) { length -= read ; bBuffer . position ( 0 ) ; bBuffer . limit ( read ) ; decoder . decode ( bBuffer , buffer , ( length == 0 ) ) ; } if ( length > 0 ) throw new IOException ( "End of Stream encountered before all requested bytes [" + ( length + read ) + "] could be read. Unable to read the last " + length + " remaining bytes." ) ; decoder . flush ( buffer ) ; } }
va	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
va	6	private void startLevel ( ) { if ( currentlesson . isNoteLevel ( ) ) { if ( ! noteLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + noteLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isRhythmLevel ( ) ) { if ( ! rhythmLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + rhythmLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isScoreLevel ( ) ) { if ( ! scoreLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + scoreLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } }
va	6	protected KeyboardEventListener parseKeyboardListener ( String keyboardListenerString ) { KeyboardEventListener rc = null ; if ( ! "" . equals ( keyboardListenerString ) ) { switch ( keyboardListenerString ) { case ( "SplashScreenKeyboardEventListener" ) : rc = new SplashScreenKeyboardEventListener ( ) ; break ; case ( "MenuKeyboardEventListener" ) : rc = new MenuKeyboardEventListener ( ) ; break ; case ( "OptionsMenuItemKeyboardEventListener" ) : rc = new OptionsMenuItemKeyboardEventListener ( ) ; break ; case ( "ExitMenuItemKeyboardEventListener" ) : rc = new ExitMenuItemKeyboardEventListener ( ) ; break ; case ( "OptionsMenuBackKeyboardEventListener" ) : rc = new OptionsMenuBackKeyboardEventListener ( ) ; break ; default : } } return rc ; }
va	4	private List < Word > getCandidates ( Word word , Map < Character , Character > l2lEncrypt ) { List < Word > candidates = new LinkedList < Word > ( ) ; Map < Integer , List < Word >> wordsMap = dict . get ( word . getLength ( ) ) ; if ( wordsMap == null ) { return candidates ; } List < Word > words = wordsMap . get ( word . getNbrSimilarLetters ( ) ) ; if ( words == null ) { return candidates ; } for ( Word w : words ) { if ( w . equals ( word , l2lEncrypt ) ) { candidates . add ( w ) ; } } return candidates ; }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; int p1 ; int p2 ; p0 = new String [ ] { "kenta" , "kentaro" , "ken" } ; p1 = 2 ; p2 = 3 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "hideo" , "hideto" , "hideki" , "hide" } ; p1 = 2 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "aya" , "saku" , "emi" , "ayane" , "sakura" , "emika" , "sakurako" } ; p1 = 3 ; p2 = 24 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "taro" , "jiro" , "hanako" } ; p1 = 2 ; p2 = 0 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "alice" , "bob" , "charlie" } ; p1 = 1 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "ryota" , "ryohei" , "ryotaro" , "ryo" , "ryoga" , "ryoma" , "ryoko" , "ryosuke" , "ciel" , "lun" , "ryuta" , "ryuji" , "ryuma" , "ryujiro" , "ryusuke" , "ryutaro" , "ryu" , "ryuhei" , "ryuichi" , "evima" } ; p1 = 3 ; p2 = 276818566 ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	8	private String subscribe ( String msg , iKPIC_subscribeHandler2 handler ) { deb_print ( "KpCore:subscribe method" ) ; int ret = 0 ; System . out . println ( "HERE!" ) ; if ( handler == null ) { this . KP_ERROR_ID = this . ERR_EVENT_HANDLER_NULL ; err_print ( "EVENT HANDLER IS NULL!!!" ) ; return null ; } deb_print ( "KpCore:SSAP:XML MESSAGE:\n" + msg ) ; deb_print ( "KpCore:SSAP:Open connection..." ) ; ret = openConnect ( ) ; if ( ret != this . ERR_Conected ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:connection error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Send message..." ) ; ret = send ( msg ) ; if ( ret != this . ERR_MsgSent ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:send error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Message Sent..." ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; msg = "" ; int charRead = 0 ; try { while ( ( charRead = in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { builder . append ( buffer , 0 , charRead ) ; msg = builder . toString ( ) ; if ( msg . contains ( "<SSAP_message>" ) && msg . contains ( "</SSAP_message>" ) ) { if ( this . xmlTools . isSubscriptionConfirmed ( msg ) ) { this . KP_ERROR_ID = this . ERR_Subscription_DONE ; System . out . println ( "1" ) ; kpSocket . setKeepAlive ( true ) ; Subscription s = new Subscription ( kpSocket , handler ) ; return msg ; } else { System . out . println ( "[90] UNKNOW MESSAGE:" + msg ) ; break ; } } } deb_print ( "KpCore:readByteXByteSIBmsg:READ LOOP TERMINATED" ) ; closeConnection ( ) ; } catch ( Exception e ) { err_print ( "KPICore:readByteXByteSIBmsg:Exception on EVENT HANDLER:RECEIVE:\n" + e ) ; this . KP_ERROR_ID = this . ERR_SOCKET_TIMEOUT ; } this . KP_ERROR_ID = this . ERR_Subscription_NOT_DONE ; deb_print ( "KpCore:SSAP:Message received:(" + msg + ")" ) ; return msg ; }
va	2	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
va	4	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
va	6	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
va	3	public static void insertTrainingStatus ( TrainingStatus status , Student student ) { boolean assigned = status . getAssigned ( ) ; String assignedDate = null ; if ( assigned == true ) assignedDate = status . getAssignedDate ( ) ; String supervisor = status . getSupervisor ( ) ; String thesis = status . getThesisTopic ( ) ; boolean plan = status . getIndividualPlan ( ) ; String approvalDate = status . getApprovalDate ( ) ; long studentId = student . getStudentId ( ) ; String insertSQL = "insert into Monitoring " + "(Date) " + "values (?)" ; try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "TrainingStatus not inserted" ) ; dbPrepStmnt = dbConn . prepareStatement ( "use phdStudent;" ) ; dbPrepStmnt . executeUpdate ( ) ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setString ( 1 , status . getMonitoring ( ) . getMonitoringDate ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . getMonitoring ( ) . setMonitoringId ( dbRset . getLong ( 1 ) ) ; insertSQL = "insert into TrainingStatus " + "(studentId  assigned  assignedDate  supervisor  thesis " + "individualPlan  approvalDate  monitoringId) " + "values (?  ?  ?  ?  ?  ?  ?  ?)" ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setLong ( 1 , studentId ) ; dbPrepStmnt . setBoolean ( 2 , assigned ) ; dbPrepStmnt . setString ( 3 , assignedDate ) ; dbPrepStmnt . setString ( 4 , supervisor ) ; dbPrepStmnt . setString ( 5 , thesis ) ; dbPrepStmnt . setBoolean ( 6 , plan ) ; dbPrepStmnt . setString ( 7 , approvalDate ) ; dbPrepStmnt . setLong ( 8 , status . getMonitoring ( ) . getMonitoringId ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . setTrainingStatusId ( dbRset . getLong ( 1 ) ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
va	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
va	6	public void scores ( Player player ) { switch ( player . getScore ( ) ) { case LOVE : player . setScore ( FIFTEEN ) ; break ; case FIFTEEN : player . setScore ( THIRTY ) ; break ; case THIRTY : determineFortyOrDeuce ( player ) ; break ; case DEUCE : determineAdvantageOrDeuce ( player ) ; break ; case FORTY : case ADVANTAGE : player . setScore ( WIN ) ; } }
va	7	public void actionPerformed ( ActionEvent ae ) { ADocument aDoc = ( ADocument ) textPane . getDocument ( ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; ^ ^ = textPane . getCaret ( ) ; int . = ^ . getDot ( ) ; int mark = ^ . getMark ( ) ; if ( . != mark ) return ; ADocumentFragment fragment = null ; try { Transferable tr = clipboard . getContents ( this ) ; DataFlavor flavor = new DataFlavor ( ADocumentFragment . MIME_TYPE ) ; if ( tr . isDataFlavorSupported ( flavor ) ) fragment = ( ADocumentFragment ) tr . getTransferData ( flavor ) ; else { flavor = new DataFlavor ( "application/x-java-serialized-object; class=java.lang.String" ) ; if ( tr . isDataFlavorSupported ( flavor ) ) { String s = new String ( ( ( ( String ) tr . getTransferData ( flavor ) ) ) ) ; fragment = new ADocumentFragment ( s , null , null ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( fragment == null ) return ; aDoc . startCompoundEdit ( ) ; ADocument . pasteADocFragment ( aDoc , . , fragment ) ; aDoc . endCompoundEdit ( null ) ; aDoc . fireADocumentChanged ( ) ; }
va	2	public void setAttributes ( Point leftest , Point rightest ) { if ( leftest != null ) { leftAngle = Tools . round ( src . getDirection ( leftest ) , 10000 ) ; leftDist = src . getDistance ( leftest ) ; } if ( rightest != null ) { rightAngle = Tools . round ( src . getDirection ( rightest ) , 10000 ) ; rightDist = src . getDistance ( rightest ) ; } }
va	8	@ Override public void visit ( CannyEvent cannyEvent ) { try { if ( model . getCurrentImagePath ( ) == null || model . getCurrentImagePath ( ) . isEmpty ( ) ) { throw new Exception ( "Brak pliku wej\u015Bciowego!" ) ; } String low_treshold_str = defaultViewChanger . showCannyParametersDialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new NumberFormatException ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } String high_treshold_str = defaultViewChanger . showCannyParametersDialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new NumberFormatException ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } Canny canny = new Canny ( low_treshold , high_treshold ) ; BufferedImage source ; System . out . println ( "Wczytuje plik \u017Ar\u00F3d\u0142owy..." ) ; source = ImageIO . read ( new File ( model . getCurrentImagePath ( ) ) ) ; System . out . println ( "Uruchamiam algorytm..." ) ; BufferedImage canny_image = canny . process ( source ) ; String output_name = "output/canny.png" ; saveImageToFile ( output_name , canny_image ) ; System . out . println ( "Wy\u015Bwietlam zdj\u0119cie..." ) ; defaultViewChanger . showModImage ( output_name ) ; } catch ( Exception e ) { if ( defaultViewChanger != null ) defaultViewChanger . showInformationDialog ( e . getMessage ( ) , "B\u0142\u0105d" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PairImpl < ? > other = ( PairImpl < ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
va	3	private String findTag ( String text , String startToken , String endToken , int fromIndex ) { int startIndex = text . indexOf ( startToken , fromIndex ) ; int endIndex = text . indexOf ( endToken , startIndex ) ; if ( startIndex >= 0 && endIndex > 0 && endIndex > startIndex ) return text . substring ( startIndex , endIndex + endToken . length ( ) ) ; return null ; }
va	7	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	2	public void open ( URL location , String referer ) throws IOException { String host = location . getHost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; String path = location . getPath ( ) + "?" + location . getQuery ( ) ; int port = location . getPort ( ) ; if ( port == - 1 ) port = 80 ; socket . setSoTimeout ( 5000 ) ; socket . connect ( new InetSocketAddress ( host , port ) , 5000 ) ; PrintWriter pw = new PrintWriter ( socket . getOutputStream ( ) , true ) ; pw . println ( "GET " + path + " HTTP/1.1" ) ; pw . println ( "Host: " + host ) ; pw . println ( "Referer: " + referer ) ; pw . println ( "Accept: */*" ) ; pw . println ( "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" ) ; pw . println ( "Connection: Keep-Alive" ) ; pw . println ( ) ; instream = socket . getInputStream ( ) ; getResponse ( ) ; }
va	8	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
va	8	public static void changeProtocolMetadataFile ( String tmpMetadataFile , String identifier ) { String newMetadataFile = "/tmp/PRO" + System . currentTimeMillis ( ) + ".xml" ; FileWriter fichero = null ; PrintWriter pw = null ; File archivo = new File ( tmpMetadataFile ) ; try { fichero = new FileWriter ( newMetadataFile ) ; BufferedReader in = new BufferedReader ( new FileReader ( archivo ) ) ; pw = new PrintWriter ( fichero ) ; String data = "" ; data = in . readLine ( ) ; String spaces = "" ; boolean secId = false ; while ( data != null ) { if ( data . indexOf ( "<identifier>" ) != - 1 ) { secId = true ; } int s = data . indexOf ( "<entry>" ) ; if ( s != - 1 && secId ) { secId = false ; for ( int i = 0 ; i < s ; i ++ ) spaces += " " ; data = spaces + "<entry>" + identifier + "</entry>" ; } pw . println ( data ) ; data = in . readLine ( ) ; } in . close ( ) ; } catch ( IOException e ) { System . out . println ( "unable to find file" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; Process proc = Runtime . getRuntime ( ) . exec ( "cp " + newMetadataFile + " " + tmpMetadataFile ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } }
va	9X	final public void edgeRHS ( ) throws ParseException { ASTedgeRHS jjtn000 = new ASTedgeRHS ( JJTEDGERHS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { edgeop ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ID : node_id ( ) ; break ; case SUBGRAPH : case { : subgraph ( ) ; break ; default : jj_la1 [ 11 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EDGE_UNDIRECTED : case EDGE_DIRECTED : edgeRHS ( ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } }
va	2	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
va	0	public JButton getButtonClose ( ) { return btnClose ; }
va	7	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
va	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
va	2	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
va	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
va	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final SondageReponse other = ( SondageReponse ) obj ; if ( this . id != other . id ) { return false ; } if ( this . id_sondage != other . id_sondage ) { return false ; } if ( this . choix != other . choix ) { return false ; } return true ; }
va	3	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
va	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Token:" ) ; sb . append ( "\n  type: " ) ; sb . append ( type . toString ( ) ) ; if ( accessToken != null ) { sb . append ( "\n  access token: " ) ; sb . append ( accessToken ) ; } if ( refreshToken != null ) { sb . append ( "\n  refresh token: " ) ; sb . append ( refreshToken ) ; } if ( keyId != null ) { sb . append ( "\n  kid: " ) ; sb . append ( keyId ) ; } if ( macKey != null ) { sb . append ( "\n  mac key: " ) ; sb . append ( macKey ) ; } if ( macAlgorithm != null ) { sb . append ( "\n  mac algorithm: " ) ; sb . append ( macAlgorithm ) ; } if ( expiresIn != - 1 ) { sb . append ( "\n  expires in: " ) ; sb . append ( expiresIn ) ; } return sb . toString ( ) ; }
va	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
va	7	public static boolean logIn ( String username , String password , JFrame frame ) { try { System . out . println ( "Checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The username is invalid  please try an other one." , "Invalid Username" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The password is invalid  please try an other one." , "Invalid Password" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=existsPlayer&name=" + username ) ) { JOptionPane . showMessageDialog ( frame , "The player does not exits." + "Please try an other username." , "Player does not exist" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=login&name=" + username + "&pass=" + password ) ) { JOptionPane . showMessageDialog ( frame , "The combination of username and passowrd is incorrect." + System . lineSeparator ( ) + "Please try again.'" + System . lineSeparator ( ) + "If you have forgotten your password  visit sinius15.com." , "Invalid login" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "There seems to be a problem with the connection to the server" + System . lineSeparator ( ) + "You can start the game in offline mode if you still want to play." + System . lineSeparator ( ) + "We are verry sorry for the inconvenience caused." , "Problem" , JOptionPane . ERROR_MESSAGE ) ; return false ; } return true ; }
va	6	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
va	4	public static String readAsString ( File file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; InputStream is = null ; try { is = new FileInputStream ( file ) ; is . read ( bytes ) ; } catch ( IOException e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ex ) { return null ; } } try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
va	8	public boolean baca ( String no_beli ) { boolean adaKesalahan = false ; Connection cn = null ; this . no_beli = no_beli ; listKwitansi = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select * from kwitansi where no_beli='" + no_beli + "'" ; sta = cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; listKwitansi = new Object [ rset . getRow ( ) ] [ 4 ] ; rset . first ( ) ; int i = 0 ; do { if ( ! rset . getString ( "kode_buku" ) . equals ( "" ) ) { listKwitansi [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getInt ( "jumlah" ) , rset . getInt ( "harga" ) } ; } i ++ ; } while ( rset . next ( ) ) ; sta . close ( ) ; rset . close ( ) ; if ( listKwitansi . length > 0 ) { adaKesalahan = false ; } } catch ( Exception ex ) { adaKesalahan = true ; } } } return ! adaKesalahan ; }
va	1	public static void writeStringToFile ( String content , String filename , boolean append ) { FileWriter fw ; try { fw = new FileWriter ( filename , append ) ; fw . append ( content ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
va	9X	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) Math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) Math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
va	2	public int priseTerritoire ( Territoire t , int nbUnite ) { if ( this . nbUniteBonus >= nbUnite - 1 ) { this . nbUniteBonus -= nbUnite - 1 ; nbUnite = 1 ; } else { nbUnite -= this . nbUniteBonus ; this . nbUniteBonus = 0 ; } this . nbUniteEnMain -= nbUnite ; t . setNbUnite ( nbUnite ) ; t . setOccupant ( this ) ; this . territoiresOccupes . add ( t ) ; this . actionPriseTerritoire ( t ) ; if ( hasPower ( ) ) { this . pouvoir . actionPriseTerritoire ( t ) ; } return nbUnite ; }
va	7	public RegisterFrame ( ServerManager theServer , String theUrl , int thePort , int theListenPort ) { super ( "Registrar Usuario" ) ; controller = new RegisterController ( theServer , theUrl , thePort ) ; server = theServer ; url = theUrl ; port = thePort ; listenPort = theListenPort ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { createLoginFrame ( ) ; } } ) ; setBounds ( 100 , 100 , 661 , 403 ) ; contentPane = new JPanel ( ) ; contentPane . setBackground ( Color . WHITE ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new BorderLayout ( 0 , 10 ) ) ; JLabel lblRegistrarUsuario = new JLabel ( "Registrar Usuario" ) ; lblRegistrarUsuario . setFont ( new Font ( "Tahoma" , Font . BOLD , 18 ) ) ; lblRegistrarUsuario . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( lblRegistrarUsuario , BorderLayout . NORTH ) ; JPanel panelBotton = new JPanel ( ) ; panelBotton . setBackground ( Color . WHITE ) ; contentPane . add ( panelBotton , BorderLayout . SOUTH ) ; panelBotton . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 ) ) ; JButton btnRegister = new JButton ( "Registrarse" ) ; btnRegister . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { try { controller . register ( usernameTxt . getText ( ) , new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) , firstNameTxt . getText ( ) , lastNameTxt . getText ( ) , emailTxt . getText ( ) ) ; JOptionPane . showMessageDialog ( null , "Registro exitoso!  ahora podra usar el servicio de chat" , "Registro exitoso" , JOptionPane . INFORMATION_MESSAGE ) ; createLoginFrame ( ) ; } catch ( RegisterException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; btnRegister . setIcon ( new ImageIcon ( RegisterFrame . class . getResource ( "/chat/client/view/resources/registerIcon.png" ) ) ) ; panelBotton . add ( btnRegister ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { createLoginFrame ( ) ; } } ) ; panelBotton . add ( btnCancel ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new GridLayout ( 0 , 2 , 0 , 0 ) ) ; ImagePanel imagePanel = new ImagePanel ( Toolkit . getDefaultToolkit ( ) . getImage ( RegisterFrame . class . getResource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagePanel ) ; JPanel panel_1 = new JPanel ( ) ; panel_1 . setBackground ( Color . WHITE ) ; panel . add ( panel_1 ) ; GridBagLayout gbl_panel_1 = new GridBagLayout ( ) ; gbl_panel_1 . columnWidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowHeights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnWeights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowWeights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setLayout ( gbl_panel_1 ) ; JLabel label = new JLabel ( "Nombre de Usuario:" ) ; label . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernameTxt = new JTextField ( ) ; usernameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidUsername ( usernameTxt . getText ( ) ) ) { lblUserNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblUserNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; usernameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; usernameTxt . setColumns ( 20 ) ; GridBagConstraints gbc_usernameTxt = new GridBagConstraints ( ) ; gbc_usernameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_usernameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_usernameTxt . gridx = 1 ; gbc_usernameTxt . gridy = 0 ; panel_1 . add ( usernameTxt , gbc_usernameTxt ) ; lblUserNameError = new JLabel ( "" ) ; lblUserNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblUserNameError = new GridBagConstraints ( ) ; gbc_lblUserNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblUserNameError . gridx = 2 ; gbc_lblUserNameError . gridy = 0 ; panel_1 . add ( lblUserNameError , gbc_lblUserNameError ) ; JLabel label_1 = new JLabel ( "Contrase\u00F1a:" ) ; label_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_1 = new GridBagConstraints ( ) ; gbc_label_1 . anchor = GridBagConstraints . EAST ; gbc_label_1 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordTxt = new JPasswordField ( ) ; passwordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! controller . isValidPassword ( new String ( passwordTxt . getPassword ( ) ) ) ) { lblPasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblPasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; passwordTxt . setColumns ( 20 ) ; passwordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_passwordTxt = new GridBagConstraints ( ) ; gbc_passwordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_passwordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordTxt . gridx = 1 ; gbc_passwordTxt . gridy = 1 ; panel_1 . add ( passwordTxt , gbc_passwordTxt ) ; lblPasswordError = new JLabel ( "" ) ; lblPasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblPasswordError = new GridBagConstraints ( ) ; gbc_lblPasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblPasswordError . gridx = 2 ; gbc_lblPasswordError . gridy = 1 ; panel_1 . add ( lblPasswordError , gbc_lblPasswordError ) ; JLabel label_2 = new JLabel ( "Repetir contrase\u00F1a:" ) ; label_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_2 = new GridBagConstraints ( ) ; gbc_label_2 . anchor = GridBagConstraints . EAST ; gbc_label_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; rePasswordTxt = new JPasswordField ( ) ; rePasswordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isRePasswordEqualToPassword ( new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) ) ) { lblRepasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblRepasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; rePasswordTxt . setColumns ( 20 ) ; rePasswordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_rePasswordTxt = new GridBagConstraints ( ) ; gbc_rePasswordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_rePasswordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_rePasswordTxt . gridx = 1 ; gbc_rePasswordTxt . gridy = 2 ; panel_1 . add ( rePasswordTxt , gbc_rePasswordTxt ) ; lblRepasswordError = new JLabel ( "" ) ; lblRepasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblRepasswordError = new GridBagConstraints ( ) ; gbc_lblRepasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblRepasswordError . gridx = 2 ; gbc_lblRepasswordError . gridy = 2 ; panel_1 . add ( lblRepasswordError , gbc_lblRepasswordError ) ; JLabel label_3 = new JLabel ( "Nombre(s):" ) ; label_3 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_3 = new GridBagConstraints ( ) ; gbc_label_3 . anchor = GridBagConstraints . EAST ; gbc_label_3 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstNameTxt = new JTextField ( ) ; firstNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidFirstName ( firstNameTxt . getText ( ) ) ) { lblFirstNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblFirstNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; firstNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; firstNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_firstNameTxt = new GridBagConstraints ( ) ; gbc_firstNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_firstNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_firstNameTxt . gridx = 1 ; gbc_firstNameTxt . gridy = 3 ; panel_1 . add ( firstNameTxt , gbc_firstNameTxt ) ; lblFirstNameError = new JLabel ( "" ) ; lblFirstNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblFirstNameError = new GridBagConstraints ( ) ; gbc_lblFirstNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblFirstNameError . gridx = 2 ; gbc_lblFirstNameError . gridy = 3 ; panel_1 . add ( lblFirstNameError , gbc_lblFirstNameError ) ; JLabel label_4 = new JLabel ( "Apellido(s):" ) ; label_4 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_4 = new GridBagConstraints ( ) ; gbc_label_4 . anchor = GridBagConstraints . EAST ; gbc_label_4 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastNameTxt = new JTextField ( ) ; lastNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidLastName ( lastNameTxt . getText ( ) ) ) { lblLastNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblLastNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; lastNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lastNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_lastNameTxt = new GridBagConstraints ( ) ; gbc_lastNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_lastNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lastNameTxt . gridx = 1 ; gbc_lastNameTxt . gridy = 4 ; panel_1 . add ( lastNameTxt , gbc_lastNameTxt ) ; lblLastNameError = new JLabel ( "" ) ; lblLastNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblLastNameError = new GridBagConstraints ( ) ; gbc_lblLastNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblLastNameError . gridx = 2 ; gbc_lblLastNameError . gridy = 4 ; panel_1 . add ( lblLastNameError , gbc_lblLastNameError ) ; JLabel label_5 = new JLabel ( "E-mail:" ) ; label_5 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_5 = new GridBagConstraints ( ) ; gbc_label_5 . anchor = GridBagConstraints . EAST ; gbc_label_5 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailTxt = new JTextField ( ) ; emailTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidEmail ( emailTxt . getText ( ) ) ) { lblEmailError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblEmailError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; emailTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; emailTxt . setColumns ( 50 ) ; GridBagConstraints gbc_emailTxt = new GridBagConstraints ( ) ; gbc_emailTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_emailTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_emailTxt . gridx = 1 ; gbc_emailTxt . gridy = 5 ; panel_1 . add ( emailTxt , gbc_emailTxt ) ; lblEmailError = new JLabel ( "" ) ; lblEmailError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblEmailError = new GridBagConstraints ( ) ; gbc_lblEmailError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblEmailError . gridx = 2 ; gbc_lblEmailError . gridy = 5 ; panel_1 . add ( lblEmailError , gbc_lblEmailError ) ; lblError = new JLabel ( "" ) ; lblError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblError = new GridBagConstraints ( ) ; gbc_lblError . gridwidth = 3 ; gbc_lblError . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblError . gridx = 0 ; gbc_lblError . gridy = 6 ; panel_1 . add ( lblError , gbc_lblError ) ; }
va	1	public boolean createAccount ( String login , String password ) { if ( logins . containsKey ( login + password ) ) { return false ; } else { logins . put ( login + password , null ) ; return true ; } }
va	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
va	1	public void awaitTermination ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { String message = "awaitTermination() method was interrupted!" ; throw new UnsupportedOperationException ( message , e ) ; } }
va	0	public void setRing ( boolean ring ) { this . ring = ring ; }
va	9X	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
va	4	private void setUsersState ( int state ) { final int columnId = 0 ; if ( tableUsers . getSelectedRow ( ) != - 1 ) { int userId = ( Integer ) tableUsers . getValueAt ( tableUsers . getSelectedRow ( ) , columnId ) ; Statement statement = null ; ResultSet result = null ; try { statement = usersDAO . getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( usersDAO . getAllQuery ( ) ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == userId ) { break ; } } result . updateInt ( "USERSTATE" , state ) ; result . updateRow ( ) ; usersDAO = new UsersDAO ( ) ; usersDAO . initTableModel ( tableUsers , usersDAO . listAll ( ) ) ; } catch ( SQLException exc ) { JOptionPane . showMessageDialog ( this , "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } } else { JOptionPane . showMessageDialog ( this , "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435!" ) ; return ; } }
va	2	public void setValue ( int value ) { if ( value < this . minValue ) { this . value = minValue ; } else if ( value > maxValue ) { this . value = maxValue ; } else { this . value = value ; } this . slider . reactToChanges ( new CustomSliderEvent ( slider , this . value ) ) ; this . textField . reactToChanges ( new CustomTextFieldEvent ( textField , Integer . toString ( this . value ) ) ) ; }
va	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
va	4	private Constant simplifySub ( AbstractBinaryOperator binaryOperator , AbstractMutableFormula left , AbstractMutableFormula right ) { if ( binaryOperator instanceof SubOperator && left instanceof Variable && right instanceof Variable && ( ( Variable ) left ) . getName ( ) . equals ( ( ( Variable ) right ) . getName ( ) ) ) { return new Constant ( 0 ) ; } return null ; }
va	5	public Type get ( int index ) { if ( index >= length ) return new BooleanValue ( false ) ; else if ( index < 0 && Math . abs ( index ) <= length ) return elements [ length + index ] ; else if ( index < 0 && Math . abs ( index ) > length ) return new BooleanValue ( false ) ; return elements [ index ] ; }
va	8	public void executePowerUp ( PowerupNode node ) { PowerupPlayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsFeature ) { case BOMB_MAX_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case BOMB_TEMP_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case CAN_JUMP : break ; case CAN_PUSH : break ; case FLAME_LENGTH : combatSystem . updateBombLayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case SPEED : movementSystem . updateMoveable ( node . entity_target , powerup . amount ) ; break ; case DAMAGE : combatSystem . updateBombLayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
va	5	private int [ ] setDistancePriority ( int xdiff , int ydiff ) { int priority [ ] = { - 1 , - 1 , - 1 , - 1 } ; if ( ( Math . abs ( xdiff ) > ( Math . abs ( ydiff ) ) ) ) { if ( ( xdiff ) > 0 ) { priority [ 0 ] = 180 ; priority [ 3 ] = 0 ; } else { priority [ 0 ] = 0 ; priority [ 3 ] = 180 ; } if ( ( ydiff ) > 0 ) { priority [ 1 ] = 90 ; priority [ 2 ] = 270 ; } else { priority [ 1 ] = 270 ; priority [ 2 ] = 90 ; } } else { if ( ( ydiff ) > 0 ) { priority [ 0 ] = 90 ; priority [ 3 ] = 270 ; } else { priority [ 0 ] = 270 ; priority [ 3 ] = 90 ; } if ( ( xdiff ) > 0 ) { priority [ 1 ] = 180 ; priority [ 2 ] = 0 ; } else { priority [ 1 ] = 0 ; priority [ 2 ] = 180 ; } } return priority ; }
va	9X	public static String nullSafeToString ( Object obj ) { if ( obj == null ) { return NULL_STRING ; } if ( obj instanceof String ) { return ( String ) obj ; } if ( obj instanceof Object [ ] ) { return nullSafeToString ( ( Object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return nullSafeToString ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return nullSafeToString ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return nullSafeToString ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return nullSafeToString ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return nullSafeToString ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return nullSafeToString ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return nullSafeToString ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return nullSafeToString ( ( short [ ] ) obj ) ; } String str = obj . toString ( ) ; return ( str != null ? str : EMPTY_STRING ) ; }
va	3	public static final void closeWindow ( ) { if ( clickListener != null ) { clickListener . removeHandler ( ) ; } if ( keyPressListener != null ) { keyPressListener . removeHandler ( ) ; } if ( blurListener != null ) { blurListener . removeHandler ( ) ; } Alerts . closeWindow ( ) ; }
va	2	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
va	9X	public static int testPublic ( int testNum ) { String inputFilename = String . format ( "tests/test%02d.crx" , testNum ) ; String outputFilename = String . format ( "tests/test%02d.rea" , testNum ) ; String expectedFilename = String . format ( "tests/test%02d.out" , testNum ) ; String astFilename = String . format ( "tests/test%02d.ast" , testNum ) ; Scanner s = null ; try { s = new Scanner ( new FileReader ( inputFilename ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return NOT_ACCESSABLE ; } Parser p = new Parser ( s ) ; ast . Command syntaxTree = p . parse ( ) ; try { PrintStream outputStream = new PrintStream ( outputFilename ) ; PrintStream astStream = new PrintStream ( astFilename ) ; if ( p . hasError ( ) ) { outputStream . println ( "Error parsing file." ) ; outputStream . println ( p . errorReport ( ) ) ; outputStream . close ( ) ; astStream . println ( "Error parsing file." ) ; astStream . println ( p . errorReport ( ) ) ; astStream . close ( ) ; } else { PrettyPrinter pretty = new PrettyPrinter ( ) ; syntaxTree . accept ( pretty ) ; astStream . println ( pretty . toString ( ) ) ; astStream . close ( ) ; types . TypeChecker tc = new types . TypeChecker ( ) ; tc . check ( syntaxTree ) ; if ( tc . hasError ( ) ) { outputStream . println ( "Error type-checking file." ) ; outputStream . println ( tc . errorReport ( ) ) ; outputStream . close ( ) ; } else { outputStream . println ( "Crux Program has no type errors." ) ; } } } catch ( IOException e ) { System . err . println ( "Error opening output file: \"" + outputFilename + "\"" ) ; e . printStackTrace ( ) ; return IO_ERROR ; } BufferedReader bufferedexpected ; BufferedReader bufferedoutput ; String lineExpected ; String lineOutput ; try { bufferedexpected = new BufferedReader ( new FileReader ( expectedFilename ) ) ; bufferedoutput = new BufferedReader ( new FileReader ( outputFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return IO_ERROR ; } int result = PASS ; try { while ( ( lineExpected = bufferedexpected . readLine ( ) ) != null ) { lineOutput = bufferedoutput . readLine ( ) ; if ( lineOutput == null ) { result = FAIL ; break ; } lineExpected = lineExpected . replaceAll ( "\\s+$" , "" ) ; lineOutput = lineOutput . replaceAll ( "\\s+$" , "" ) ; if ( ! lineExpected . equals ( lineOutput ) ) { result = FAIL ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; result = IO_ERROR ; } try { bufferedoutput . close ( ) ; bufferedexpected . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; }
va	7	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
va	3	public void update ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
va	4	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
va	5	static void updatestatus ( int m ) { switch ( m ) { case 1 : status . setText ( "Drag to create an entity" ) ; break ; case 2 : status . setText ( "Drag to create an bubble" ) ; break ; case 3 : status . setText ( "Drag to create an data store" ) ; break ; case 4 : status . setText ( "Drag to create an data flow arrow" ) ; break ; case 6 : status . setText ( "Drag to create an control flow arrow" ) ; break ; default : status . setText ( "" ) ; } }
va	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
va	3	private Object firstKey ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return ary [ 0 ] ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) { if ( node . key instanceof EquivalentMap ) return ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) . key ; else return node . key ; } else return firstKey ( node . left ) ; } }
va	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
va	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Window3 ( ) . setVisible ( true ) ; } } ) ; }
va	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
va	7	@ Override public void setFailState ( int failState ) { if ( this . failstate == Fallible . DEAD && failState != Fallible . DEAD ) throw new IllegalStateException ( "Cannot change fail state: node is already DEAD" ) ; switch ( failState ) { case OK : this . failstate = Fallible . OK ; break ; case DEAD : this . index = - 1 ; this . failstate = Fallible . DEAD ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof Cleanable ) { ( ( Cleanable ) this . protocol [ i ] ) . onKill ( ) ; } break ; case DOWN : this . failstate = Fallible . DOWN ; break ; default : throw new IllegalArgumentException ( "failState=" + failState ) ; } }
va	2	@ Override public String toString ( ) { final StringBuilder bld = new StringBuilder ( this . getClass ( ) . getSimpleName ( ) ) . append ( ": " ) ; if ( ! PRIMITIVES . contains ( this . name ) ) { bld . append ( this . packageName != null ? this . packageName : "[default package]" ) . append ( "." ) ; } return bld . append ( this . name ) . toString ( ) ; }
va	8	public void run ( ) { while ( ! mServerDisconnected ) { ArrayList < NetworkMessage > messages = GetMessages ( mUnsanitizedMessages ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { NetworkMessage current = messages . get ( i ) ; current . Sanatize ( ) ; String message = current . GetMessage ( ) ; StringTokenizer st = new StringTokenizer ( message ) ; try { int id = Integer . parseInt ( st . nextToken ( ) ) ; ConnectedClient client = GetClient ( id ) ; if ( client != null ) { client . MessageRecieved ( ) ; } String command = st . nextToken ( ) ; if ( command . equalsIgnoreCase ( "ping" ) ) { client . PingRecieved ( ) ; } else if ( command . equalsIgnoreCase ( "connect" ) ) { if ( client == null ) { System . out . println ( "someone connected" ) ; ConnectedClient newClient = new ConnectedClient ( GetNextID ( ) , current . GetAddress ( ) , current . GetPort ( ) ) ; mClients . add ( newClient ) ; } } else { throw new Exception ( ) ; } } catch ( Exception e ) { AddMessage ( message , current . GetAddress ( ) , current . GetPort ( ) , mMessages ) ; } } try { Thread . sleep ( 10 ) ; } catch ( Exception e ) { } } }
va	1	public static SoundManager create ( class < ? > clazz ) throws IllegalArgumentException { return create ( clazz , new String ( ) ) ; }
va	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
va	9X	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
va	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
va	5	@ Override public final void instantiate ( ) { instanceId = generateInstanceId ( ) ; if ( this instanceof ParentTrait ) { ParentTrait parentThis = ( ParentTrait ) this ; for ( int i = 0 ; i < parentThis . getChildCount ( ) ; i ++ ) { if ( ! ( parentThis instanceof ReferenceTrait ) || ! ( ( ReferenceTrait ) parentThis ) . isBackReference ( i ) ) { GeneTrait childGene = parentThis . getChild ( i ) ; if ( childGene != null ) { childGene . instantiate ( ) ; } } } } }
va	1	public void saveLang ( ) { try { lang . save ( langFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
va	8	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
va	8	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
va	6	public void removePriceStep ( double startPrice , double endPrice ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; if ( startPrice < 0 || endPrice < 0 ) throw new PriceStepNegativeArgumentException ( ) ; PriceStep removeStep = null ; for ( PriceStep storedStep : priceSteps ) { if ( storedStep . getStartPrice ( ) == startPrice && storedStep . getEndPrice ( ) == endPrice ) { removeStep = storedStep ; } } if ( removeStep == null ) { throw new PriceStepIntervalNotFoundException ( ) ; } else { priceSteps . remove ( removeStep ) ; } }
va	6	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; dead = true ; xa = 0 ; ya = 1 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
va	4	public void testFileContent ( ) throws IOException { long start = System . currentTimeMillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; long end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
va	5	@ Override public void actionPerformed ( ActionEvent e ) { JMenuItem popup = ( JMenuItem ) e . getSource ( ) ; String name = popup . getName ( ) ; switch ( name ) { case "add track" : List < TrackBean > selectedTracks = view . getSelectedTracks ( ) ; model . addTracksToPlaylist ( selectedTracks ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "add album" : AlbumBean selectedAlbum = view . getSelectedAlbum ( ) ; model . addTracksToPlaylist ( selectedAlbum . getTracks ( ) ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "clear playlist" : model . stopSong ( false ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "remove track" : removeTracks ( ) ; break ; case "get info" : view . displayInfoDialog ( view . getSelectedTracks ( ) . get ( 0 ) ) ; break ; } }
va	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
va	4	public Rectangle2D getDrawableArea ( Unit unit ) { double w = paperWidth . getValue ( unit ) ; double x = 0 ; if ( leftMargin != null ) { x = leftMargin . getValue ( unit ) ; w -= x ; } if ( rightMargin != null ) { w -= rightMargin . getValue ( unit ) ; } double h = paperHeight . getValue ( unit ) ; double y = 0 ; if ( topMargin != null ) { y = topMargin . getValue ( unit ) ; h -= y ; } if ( bottomMargin != null ) { h -= bottomMargin . getValue ( unit ) ; } return new Rectangle2D . double ( x , y , w , h ) ; }
va	5	public boolean isIsAndOrSentenceHelper ( List < String > words , String sentencePtn , String ptn1 , String ptn2 ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.isIsAndOrSentence" ) ; sentencePtn = sentencePtn . toLowerCase ( ) ; sentencePtn = sentencePtn . replaceAll ( "t" , "m" ) ; Pattern p1 = Pattern . compile ( ptn1 ) ; Matcher m1 = p1 . matcher ( sentencePtn ) ; Pattern p2 = Pattern . compile ( ptn2 ) ; Matcher m2 = p2 . matcher ( sentencePtn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { String matchedWords = StringUtils . join ( words . subList ( 0 , end ) , " " ) ; String regex = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( matchedWords , regex ) ) { myLogger . trace ( "Case 1" ) ; return false ; } myLogger . trace ( "Case 2" ) ; return true ; } myLogger . trace ( "Case 3" ) ; return false ; }
va	5	public Identifier AddUser ( User info ) { try { if ( info . getContact ( ) == null || info . getContact ( ) . getEmail ( ) == null || info . getFirstName ( ) == null || info . getLastName ( ) == null ) { return null ; } return Users . getInstance ( ) . create ( info ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { System . err . println ( "Failed to Add user. " + e . getMessage ( ) ) ; return null ; } }
va	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
va	4	private static String readLine ( int lineNumber ) { BufferedReader reader = null ; String line = "" ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; int i = 0 ; for ( String curLine ; ( curLine = reader . readLine ( ) ) != null ; i ++ ) { if ( i == lineNumber ) line = curLine ; } } catch ( IOException e ) { } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } return line ; }
va	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
va	5	public int getPerceptIndex ( String percept ) { if ( percept . equals ( SOLVED ) ) { return ( getPerceptsNumber ( ) - 1 ) ; } else { int [ ] values = new int [ 2 ] ; int k = 0 ; try { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( percept ) ) ; while ( k < 2 && tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . ttype == StreamTokenizer . TT_NUMBER ) { values [ k ] = ( int ) ( tokenizer . nval ) ; k ++ ; } } return values [ 0 ] * DIGITS + values [ 1 ] ; } catch ( Exception e ) { return - 1 ; } } }
va	1	public Labels getLabels ( ) { if ( labels == null ) { labels = new Labels ( ) ; } return labels ; }
va	9X	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
va	8	public void connect1 ( TreeLinkNode root ) { if ( root == null ) return ; Queue < TreeLinkNode > curLev = new LinkedList < TreeLinkNode > ( ) ; curLev . add ( root ) ; while ( ! curLev . isEmpty ( ) ) { Queue < TreeLinkNode > nextLev = new LinkedList < TreeLinkNode > ( ) ; while ( ! curLev . isEmpty ( ) ) { TreeLinkNode cur = curLev . poll ( ) ; if ( cur . left != null ) nextLev . add ( cur . left ) ; if ( cur . right != null ) nextLev . add ( cur . right ) ; if ( ! curLev . isEmpty ( ) ) { TreeLinkNode curNext = curLev . peek ( ) ; if ( curNext . left != null ) nextLev . add ( cur . left ) ; if ( curNext . right != null ) nextLev . add ( cur . right ) ; cur . next = curNext ; } } curLev = nextLev ; } }
va	3	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
va	7	private Object difference ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == null || subtree1 == subtree2 ) return null ; else if ( subtree2 == null ) return split ( subtree1 , lo , hi ) ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) return difference ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else { Node n2 = ( Node ) subtree2 ; Object elt2 = n2 . element ; Object elt1 = findEquiv ( subtree1 , elt2 ) ; Object new_left = difference ( trim ( subtree1 , lo , elt2 ) , trim ( n2 . left , lo , elt2 ) , lo , elt2 ) ; Object new_right = difference ( trim ( subtree1 , elt2 , hi ) , trim ( n2 . right , elt2 , hi ) , elt2 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } } else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; Object elt2 = findEquiv ( subtree2 , elt1 ) ; Object new_left = difference ( n1 . left , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) ; Object new_right = difference ( n1 . right , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } }
va	7	public String reverseWords ( String s ) { if ( s . length ( ) == 0 ) return s ; String [ ] arr = s . split ( " " ) ; ArrayList < String > aa = new ArrayList < String > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; String ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
va	3	public void saveGame ( ) throws CannotSaveException { try { SaveFile saveFile = new SaveFile ( GameSaver . AUTO_SAVE_LOCATION ) ; FileOutputStream saveStream = new FileOutputStream ( saveFile . getFile ( ) ) ; ObjectOutputStream save = new ObjectOutputStream ( saveStream ) ; save . writeObject ( GameState . getInstance ( ) ) ; save . close ( ) ; } catch ( CannotCreateFileException e ) { throw new CannotSaveException ( "Cannot create file" ) ; } catch ( FileNotFoundException e ) { throw new CannotSaveException ( "File not found" ) ; } catch ( IOException e ) { throw new CannotSaveException ( "IO Exception" ) ; } }
va	9X	private Object readValue ( ) throws JSONException { switch ( read ( 2 ) ) { case 0 : return new Integer ( read ( ! bit ( ) ? 4 : ! bit ( ) ? 7 : 14 ) ) ; case 1 : byte [ ] bytes = new byte [ 256 ] ; int length = 0 ; while ( true ) { int c = read ( 4 ) ; if ( c == endOfNumber ) { break ; } bytes [ length ] = bcd [ c ] ; length += 1 ; } Object value ; try { value = JSONObject . stringToValue ( new String ( bytes , 0 , length , "US-ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new JSONException ( e ) ; } this . values . register ( value ) ; return value ; case 2 : return getAndTick ( this . values , this . bitreader ) ; case 3 : return readJSON ( ) ; default : throw new JSONException ( "Impossible." ) ; } }
va	8	public ArrayList < ArrayList < State >> printTrace ( String string , ArrayList < Automaton > disTA ) { String actions [ ] = string . split ( " " ) ; ArrayList < ArrayList < State >> states ; for ( ArrayList < State > state : startStates ) { states = new ArrayList < ArrayList < State >> ( ) ; ArrayList < State > searchState = state ; states . add ( searchState ) ; for ( String action : actions ) { boolean matchFound = false ; if ( adjList != null ) { Set < EdgeOfZoneGraph > edges = adjList . get ( searchState ) ; if ( edges != null ) { Iterator < EdgeOfZoneGraph > it = edges . iterator ( ) ; while ( it . hasNext ( ) ) { EdgeOfZoneGraph edge = ( EdgeOfZoneGraph ) it . next ( ) ; if ( edge . getAction ( ) . equals ( action ) ) { states . add ( edge . getEndState ( ) ) ; searchState = edge . getEndState ( ) ; matchFound = true ; break ; } } } } if ( ! matchFound ) { return null ; } } if ( isFinal ( states . get ( states . size ( ) - 1 ) , disTA ) ) { return states ; } } return null ; }
va	6	private void createUnits ( ) { ArrayList < Building > buildings = g . map . getPlayersBuildings ( this ) ; boolean hasMoney = true ; while ( hasMoney ) { for ( Building building : buildings ) { if ( building instanceof Factory ) { ( ( Factory ) building ) . recruitTank ( g . map , building . getCell ( ) , true ) ; } if ( building instanceof Barracks ) { ( ( Barracks ) building ) . recruitMarine ( g . map , building . getCell ( ) , true ) ; } } if ( buildings . contains ( Barracks . class ) ) { hasMoney = this . getMoney ( ) >= Marine . cost ; } else if ( buildings . contains ( Factory . class ) ) { hasMoney = this . getMoney ( ) >= Tank . cost ; } else { hasMoney = false ; } } }
va	5	public static void merge ( int [ ] a , int [ ] aux , int lo , int mid , int hi ) { assert isSorted ( a , lo , mid ) ; assert isSorted ( a , mid + 1 , hi ) ; for ( int k = lo ; k <= hi ; k ++ ) aux [ k ] = a [ k ] ; int i = lo , j = mid + 1 ; for ( int k = lo ; k <= hi ; k ++ ) { if ( i > mid ) { a [ k ] = aux [ j ++ ] ; } else if ( j > hi ) { a [ k ] = aux [ i ++ ] ; } else if ( less ( aux [ j ] , aux [ i ] ) ) { a [ k ] = aux [ j ++ ] ; } else { a [ k ] = aux [ i ++ ] ; } } assert isSorted ( a , lo , hi ) ; }
va	2	public static boolean isPrime ( long n ) { log ( "Checking " + n ) ; boolean isPrime = n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; if ( isPrime ) log ( "Prime found " + n ) ; return isPrime ; }
va	0	public Prenotazione ( ) { super ( ) ; }
va	1	@ Test public void acceptedTestAStar ( ) { Automaton a = new RegExp ( "a*" ) . toAutomaton ( ) ; String [ ] expected = { "" , "a" , "aa" , "aaa" , "aaaa" , "aaaaa" , "aaaaaa" , "aaaaaaa" , "aaaaaaaa" , "aaaaaaaaa" } ; int i = 0 ; for ( String s : AutomatonHelper . accepted ( a , 10 ) ) { assertEquals ( expected [ i ++ ] , s ) ; } }
va	5	public int generateDurability ( int blockY ) { int durability = baseDurability_ ; if ( variance_ > 0 ) { durability += Citadel . getRandom ( ) . nextInt ( ) % ( variance_ * 2 + 1 ) ; durability -= variance_ ; } if ( yAdjustment_ < 0.00001 || yAdjustment_ > 0.00001 ) { durability += ( int ) ( ( float ) blockY * yAdjustment_ ) ; } if ( durability < minDurability_ ) { return minDurability_ ; } if ( durability > maxDurability_ ) { return maxDurability_ ; } return durability ; }
va	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && Region . plane != plane ) { gameScreenImageProducer . initDrawingArea ( ) ; fontPlain . drawCentredText ( "Loading - please wait." , 257 , 151 , 0 ) ; fontPlain . drawCentredText ( "Loading - please wait." , 256 , 150 , ffffff ) ; gameScreenImageProducer . drawGraphics ( 4 , super . gameGraphics , 4 ) ; loadingStage = 1 ; loadRegionTime = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int successful = initialiseRegionLoading ( ) ; if ( successful != 0 && System . currentTimeMillis ( ) - loadRegionTime > 360000 ) { signlink . reporterror ( enteredUsername + " glcfb " + serverSessionKey + " " + successful + " " + lowMemory + " " + caches [ 0 ] + " " + onDemandFetcher . immediateRequestCount ( ) + " " + plane + " " + regionX + " " + regionY ) ; loadRegionTime = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != lastRegionId ) { lastRegionId = plane ; renderMinimap ( plane ) ; } }
va	0	public Client ( String dni , String nom , String cognoms , String email ) { this . dni = dni ; this . nom = nom ; this . cognoms = cognoms ; this . email = email ; }
va	4	@ Override public final Element get ( int index ) { final int size = elements . size ( ) ; if ( index >= 0 ) { if ( index < size ) { return elements . get ( index ) ; } else { return null ; } } else { final int calculated = size + index ; if ( calculated >= 0 && calculated < size ) { return elements . get ( calculated ) ; } else { return null ; } } }
va	0	public void actionPerformed ( ActionEvent event ) { Main . newSet ( ) ; }
va	5	@ Override public void run ( ) { String author = item . getAuthor ( ) ; String title = item . getTitle ( ) ; String dir = "./cache" ; String localCover = dir + "/cover/" + title + "-" + author + ".jpg" ; String localSong = dir + "/song/" + title + "-" + author + ".mp3" ; try { if ( item . getCover ( ) != null && item . getCover ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localCover , item . getCover ( ) ) ; item . setCover ( localCover ) ; } onCoverComplete ( item ) ; if ( item . getCover ( ) != null && item . getPath ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localSong , item . getPath ( ) ) ; item . setPath ( localSong ) ; item . setLocal ( true ) ; } onSongComplete ( item ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	public boolean RemoveContact ( long nIndexContact ) { return otapiJNI . AddressBook_RemoveContact ( swigCPtr , this , removeRefContact ( nIndexContact ) ) ; }
va	5	private static int mixLightness ( int colour , int lightness , int drawType ) { if ( ( drawType & 2 ) == 2 ) { if ( lightness < 0 ) lightness = 0 ; else if ( lightness > 127 ) lightness = 127 ; lightness = 127 - lightness ; return lightness ; } lightness = lightness * ( colour & 7f ) >> 7 ; if ( lightness < 2 ) lightness = 2 ; else if ( lightness > 126 ) lightness = 126 ; return ( colour & ff80 ) + lightness ; }
va	0	public char nextChar ( ) { return ( char ) ( next ( 16 ) ) ; }
va	6	public void start ( String args [ ] ) { try { this . host = args [ 0 ] ; this . tcpPort = Integer . parseInt ( args [ 1 ] ) ; this . analyticServerRef = args [ 2 ] ; } catch ( NumberFormatException e ) { logger . error ( "Seconds argument has to be an integer" ) ; } catch ( ArrayIndexOutOfBoundsException e ) { logger . error ( "Too few arguments" ) ; } PropertyConfigurator . configure ( "src/log4j.properties" ) ; readProperties ( ) ; managementClient = new ManagementClient ( analyticServerRef ) ; managementClient . start ( ) ; managementClient . processInput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { LoadTestClient client = new LoadTestClient ( host , tcpPort ) ; testClients . add ( client ) ; if ( auctionsPerMin > 0 ) client . createAuctions ( auctionsPerMin , auctionDuration ) ; if ( bidsPerMin > 0 ) client . bidAuctions ( bidsPerMin ) ; executorService . execute ( client ) ; } LoadTestClient updater = new LoadTestClient ( host , tcpPort ) ; testClients . add ( updater ) ; updater . updateList ( updateIntervalSec ) ; executorService . execute ( updater ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { input . readLine ( ) ; input . close ( ) ; } catch ( IOException ex ) { logger . error ( "IO Exception on System Standard Input" ) ; } shutdown ( ) ; }
va	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Type other = ( Type ) obj ; if ( collectionType != other . collectionType ) return false ; if ( javaClass == null ) { if ( other . javaClass != null ) return false ; } else if ( ! javaClass . equals ( other . javaClass ) ) return false ; return true ; }
va	5	public void PrOkObteHabitacions ( String pob , Date dIni , Date dFi , int numOcup ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( dIni ) ; long dataIni = c . getTimeInMillis ( ) ; c . setTime ( dFi ) ; long dataFi = c . getTimeInMillis ( ) ; if ( ( dataFi < dataIni ) || dataFi - dataIni < 1000 ) { vista . mostraMissatge ( "Dates incorrectes" , 1 ) ; return ; } try { Set < DadesHotel > resultat = domini . buscarHabitacio ( pob , dIni , dFi , numOcup ) ; DadesReserva basicData = new DadesReserva ( ) ; basicData . pob = pob ; basicData . dIni = dIni ; basicData . dFi = dFi ; basicData . numOc = numOcup ; vista . mostraHabitacions ( basicData , resultat ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null && e . getMessage ( ) . equals ( "hotelsNoDisp" ) ) { vista . mostraMissatge ( "No hi ha hotels disponibles en aquesta poblaci\u00F3" , 1 ) ; } else e . printStackTrace ( ) ; } }
va	2	private Activity getActivity ( String edgeType ) throws ProvBuildException { if ( _current == null || ! ( _current instanceof Activity ) ) { throw new ProvBuildException ( edgeType + " only applies to activities" ) ; } return ( Activity ) _current ; }
va	4	@ Override public < T extends AggregateRoot < ? >> T loadOneBy ( final class < T > aggregateRoot , final Specification < T > specification ) { @ SuppressWarnings ( "unchecked" ) final DomainRepositoryDriver < T , ? > driver = ( DomainRepositoryDriver < T , ? > ) drivers . get ( aggregateRoot ) ; if ( driver == null ) { throw new RuntimeException ( "Can't find any driver for the given aggregate: " + aggregateRoot ) ; } return driver . loadOneBySpecification ( specification ) ; }
va	5	public String getLatestTransmissionAttempt ( ) { if ( transmissionAttempts == 0 ) { return "no attempt yet" ; } switch ( transmissionAttempts ) { case 1 : return "first attempt" ; case 2 : return "second attempt" ; case 3 : return "third attempt" ; case 4 : return "fourth attempt" ; default : return "attempt #" + transmissionAttempts ; } }
va	8	static int entrance ( List < Point > points , int k ) { int size = points . size ( ) ; Map < String , Integer > indexHash = new HashMap < > ( ) ; Map < String , Point > pointHash = new HashMap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Point p = points . get ( i ) ; indexHash . put ( p . x + " " + p . y , i ) ; pointHash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { Point from = points . get ( i ) ; int max = 0 ; Set < Point > rangePoints = rangePonints ( from , k , pointHash ) ; for ( Point p : rangePoints ) { Integer index = indexHash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxPathValue > max ) { max = p . maxPathValue ; } } from . maxPathValue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxPathValue ; } return - 1 ; }
va	4	private static HashMap < String , Integer > addToEndGroup ( HashMap < String , Integer > endGroups , String endGroup , int end ) { if ( endGroup != null ) { if ( endGroups == null ) endGroups = new HashMap < String , Integer > ( 2 ) ; Integer oldEnd = endGroups . get ( endGroup ) ; if ( oldEnd == null || end > oldEnd ) endGroups . put ( endGroup , end ) ; } return endGroups ; }
va	5	public boolean recordLogin ( InetAddress origin , String userName ) { boolean ret = false ; Watch time = new Watch ( ) ; String incQuery = "UPDATE History SET lastLoginIndex = lastLoginIndex + 1 MOD length WHERE userName = '" + userName + "';" ; String delQuery = "DELETE LogIn FROM LogIn JOIN History ON(LogIn.hid = History.hid) WHERE LogIn.index = ((History.lastLoginIndex + 1) MOD length) AND History.userName = '" + userName + "';" ; String query = "INSERT INTO LogIn(hid  ip  month  day  year  `index`  hours  minutes)" + " SELECT hid  INET_ATON('" + origin . getHostAddress ( ) + "')  " + time . getMonth ( ) + "  " + time . getDate ( ) + "  " + time . getYear ( ) + "  lastLoginIndex MOD length  " + time . getHours ( ) + "  " + time . getMinutes ( ) + " " + "FROM History " + "WHERE userName = '" + userName + "';" ; try { connect ( ) ; Statement stmt = connection . createStatement ( ) ; stmt . executeUpdate ( delQuery ) ; connection . setAutoCommit ( false ) ; stmt . executeUpdate ( incQuery ) ; stmt . executeUpdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( SQLException e ) { e . printStackTrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( SQLException e1 ) { e1 . printStackTrace ( ) ; } } finally { if ( connection != null ) try { connection . setAutoCommit ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return ret ; }
va	7	public static int [ ] getPrimes ( int max ) { int [ ] primes = new int [ max + 1 ] ; for ( int i = 2 ; i <= max ; i ++ ) { primes [ i ] = i ; } int total = max - 1 ; for ( int i = 2 ; i <= Math . sqrt ( max ) ; i ++ ) { for ( int j = i ; j <= max ; ) { j += i ; if ( j <= max && primes [ j ] > 0 ) { primes [ j ] = 0 ; total -- ; } } } int [ ] totalprimes = new int [ total ] ; int temp = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > 0 ) { totalprimes [ temp ] = primes [ i ] ; temp ++ ; } } return totalprimes ; }
va	7	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
va	5	static public void LU_ver ( double a [ ] [ ] ) { int n = a . length ; int i , j , k ; double suma ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i - 1 ; j ++ ) { ver ( i , j , 0 ) ; System . out . print ( "(" ) ; ver ( i , j , 1 ) ; suma = 0 ; for ( k = 0 ; k <= j - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = ( a [ i ] [ j ] - suma ) / a [ j ] [ j ] ; ver ( j , j , 4 ) ; System . out . println ( ) ; } for ( j = i ; j < n ; j ++ ) { suma = 0 ; ver ( i , j , 0 ) ; ver ( i , j , 1 ) ; for ( k = 0 ; k <= i - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = a [ i ] [ j ] - suma ; System . out . println ( ) ; } } }
va	3	@ Override public Connection getConnection ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { return connection ; } else { connection = DriverManager . getConnection ( "jdbc:hsqldb:file:" + db + ";shutdown=true" , user , pass ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return connection ; }
va	4	protected final void measure ( int width , int height ) { Debug . log ( "MEASURING %s" , this ) ; if ( width == LayoutParameters . MATCH_PARENT ) { width = getParentWidth ( ) ; } if ( height == LayoutParameters . MATCH_PARENT ) { height = getParentHeight ( ) ; } onMeasure ( width , height ) ; if ( measuredWidth == NOT_SET || measuredHeight == NOT_SET ) { throw new IllegalStateException ( "View subclass (" + this + ") does not properly set the measured width or height." ) ; } Debug . log ( "MEASURED DIMENSIONS FOR (%s): width=%s  height=%s" , this , measuredWidth , measuredHeight ) ; }
va	4	public void render ( Graphics g ) { i ++ ; if ( i >= 8 ) { animationStep ++ ; animationStep %= 9 ; image = sheet . getSprite ( "monster_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 5 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
va	5	private void initiateMalesAndFemales ( Habitat habitat ) { numberOfLonelyFemales = 0 ; males . clear ( ) ; lonelyFemales . clear ( ) ; for ( IndividualsGroupState group : habitat . getGroupsStates ( ) . values ( ) ) { if ( group . isMatureMale ( ) && group . strength > 0 ) males . add ( group ) ; else if ( group . isMatureFemale ( ) && group . getNotMultipliedst ( ) > 0 ) { lonelyFemales . add ( group ) ; numberOfLonelyFemales += group . getNotMultipliedst ( ) ; } } }
va	2	public void requestOpenPose ( int id ) { boolean continueToOpen = true ; if ( ! saved ) { continueToOpen = promptToSave ( ) ; } if ( continueToOpen ) { promptToOpen ( id ) ; } }
va	1	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
va	9X	private boolean checkBackDiagonal ( int j , int i , ConnectFourPiece [ ] [ ] m_Pieces ) { boolean gameWon = false ; int secondPieceDDiagonalColoumn = i - 1 ; int thirdPieceDDiagonalColoumn = i - 2 ; int fourthPieceDDiagonalColoumn = i - 3 ; int secondPieceDDiagonalRow = j + 1 ; int thirdPieceDDiagonalRow = j + 2 ; int fourthPieceDDiagonalRow = j + 3 ; if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == RED_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; } else if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == YELLOW_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; } gameWon = true ; } } } return gameWon ; }
va	3	@ Override public int resolve ( ) throws Exception { Room room = getMyRoom ( ) ; if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENDOWN ) ) { room . getTurtle ( ) . setPenStatus ( true ) ; return CommandConstants . COMMAND_RETURN_TRUE ; } else if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENUP ) ) { room . getTurtle ( ) . setPenStatus ( false ) ; return CommandConstants . COMMAND_RETURN_FALSE ; } else { if ( room . getTurtle ( ) . getPenStatus ( ) ) { return CommandConstants . COMMAND_RETURN_TRUE ; } else { return CommandConstants . COMMAND_RETURN_FALSE ; } } }
va	9X	public void outDem ( String s , int color , boolean bold ) { String sortie = "" ; sortie += "\u001B[" ; if ( bold ) sortie += "1;" ; switch ( color ) { case 0 : sortie += "30" ; break ; case 1 : sortie += "31" ; break ; case 2 : sortie += "32" ; break ; case 3 : sortie += "33" ; break ; case 4 : sortie += "34" ; break ; case 5 : sortie += "35" ; break ; case 6 : sortie += "36" ; break ; case 7 : sortie += "37" ; break ; } sortie += "mServeur " + Global . TCP_PORT + " : " + s + "\u001B[0m\n" ; try { Thread . sleep ( ( int ) Math . abs ( Math . random ( ) * 20 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . print ( sortie ) ; }
va	6	public String next ( int n ) throws JSONException { if ( n == 0 ) { return "" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( "Substring bounds error" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; }
va	9X	public String fillStaffInfo ( String staffPos ) { DB . db . openConnection ( ) ; ResultSet rs = DB . db . staff ( ) ; StringBuffer info = new StringBuffer ( ) ; try { info . append ( "<table>" ) ; while ( rs . next ( ) ) { ResultSet res = DB . db . position ( rs . getInt ( "posid" ) ) ; while ( res . next ( ) ) { if ( res . getString ( "posdesc" ) . equalsIgnoreCase ( staffPos ) ) { if ( staffPos . equalsIgnoreCase ( "gp" ) ) { info . append ( "<tr><td>Dr. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ns" ) ) { info . append ( "<tr><td>R.N. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ma" ) ) { info . append ( "<tr><td>Med.As. <b>" ) ; } info . append ( rs . getString ( "lname" ) ) ; info . append ( "  " + rs . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( rs . getString ( "phone" ) + "</b></td></tr>" ) ; ResultSet ress = DB . db . qualification ( rs . getInt ( "qualid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Qualification: <b>" ) ; info . append ( ress . getString ( "qualdesc" ) + "</b></td></tr>" ) ; } ResultSet rss = DB . db . staffSchedule ( rs . getInt ( "id" ) ) ; while ( rss . next ( ) ) { ress = DB . db . hospital ( rss . getInt ( "hospid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Hospital: <b>" ) ; info . append ( ress . getString ( "name" ) + "</b></td></tr>" ) ; } } info . append ( "<tr></tr>" ) ; } } } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StartMedOfficer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
va	0	public Builder buying ( double price ) { this . price = price ; return this ; }
va	0	public boolean isInterested ( ) { return this . interested ; }
va	8	private MoveInfo IterativeDeepeningRoot2 ( GameState position ) { current_best_score = - SCORE_INFINITY ; current_search_depth = 0 ; ArimaaMove best_move = null ; this . initial_position = position ; GameState initial_gs = position ; resetStats ( ) ; enable_search ( ) ; GameState new_position = new GameState ( ) ; eval . PreProcessRootPosition ( position ) ; MoveList root_moves = genRootMoves ( initial_gs ) ; ProcessRootMoves ( initial_position , root_moves ) ; int offset = setup_search ( initial_gs ) ; LogFile . message ( "Score Offset: " + offset ) ; try { for ( int depth = initial_search_depth ; depth <= max_search_depth ; depth ++ ) { current_search_depth = depth ; int iteration_best_score = - SCORE_INFINITY ; int new_beta = SCORE_INFINITY ; root_moves . sort ( ) ; for ( ArimaaMove move : root_moves ) { int temp_score ; if ( move . move_ordering_value >= 30000 || move . move_ordering_value <= - 30000 ) { temp_score = move . move_ordering_value ; } else { new_position . play ( move , initial_position ) ; temp_score = SearchPosition ( new_position , depth , iteration_best_score , new_beta ) ; } move . move_ordering_value = temp_score ; if ( temp_score > iteration_best_score ) { iteration_best_score = temp_score ; current_best_score = temp_score ; best_move = move ; hash_table . RecordHash ( initial_position . getPositionHash ( ) , depth , iteration_best_score , HashTable . LOWER_BOUND , move , false ) ; String text = "D:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 8 , convertScore ( iteration_best_score ) ) ; text += "     " + getPV ( initial_position ) ; LogFile . message ( text ) ; MoveInfo mi = new MoveInfo ( ) ; mi . eval_score = current_best_score ; mi . move_text = gen_turn . getOfficialArimaaNotation ( initial_position , best_move ) ; mi . pv = getPV ( position ) ; mi . nodes_searched = this . ab_nodes_searched ; mi . ply = depth ; mi . search_time_ms = time_control . getElapsedSearchTime ( ) ; thread_mi = mi ; if ( iteration_best_score >= SCORE_FORCED_WIN ) { break ; } } } String text = "F:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 7 , convertScore ( current_best_score ) ) ; text += "     " ; text += " Nodes: " + ab_nodes_searched ; text += " QNodes: " + q_nodes_searched ; text += " kNPS: " + ab_nodes_searched / ( time_control . getElapsedSearchTime ( ) + 1 ) ; LogFile . message ( text ) ; if ( isMateScore ( iteration_best_score ) ) { break ; } } } catch ( AbortSearchException ex ) { LogFile . message ( "Search Aborted!" ) ; } engine_search_completed = true ; return thread_mi ; }
va	9X	private void parsePacket ( ) throws MpegDecodeException , IOException { Statistics . startLog ( PARSE_PACKET_STRING ) ; System . out . println ( "Parsing packet" ) ; if ( m_ioTool . getBits ( 24 ) != 1 ) { Debug . println ( Debug . ERROR , "Synchronization error in packet" ) ; throw new MpegDecodeException ( "Synchronization error in packet" ) ; } int streamId = m_ioTool . getBits ( 8 ) ; int pktLength = m_ioTool . getBits ( 16 ) ; if ( streamId != PRIVATE_STREAM2 ) { pktLength -= parseTimeStamps ( ) ; } if ( ( streamId & E0 ) == C0 ) { decodeAudio ( pktLength ) ; } else { if ( ( F0 & streamId ) == E0 ) { decodeVideo ( pktLength ) ; } else if ( ( F0 & streamId ) == F0 ) { ; } else { switch ( streamId ) { case RESERVED_STREAM : case PRIVATE_STREAM1 : case PADDING_STREAM : case PRIVATE_STREAM2 : break ; default : Debug . println ( Debug . ERROR , "Unknown Stream: " + streamId ) ; throw new MpegDecodeException ( "Unknown Stream: " + streamId ) ; } } } Statistics . endLog ( PARSE_PACKET_STRING ) ; }
va	8	@ Test public void testPertenece2 ( ) { boolean expected = false ; boolean actual = arbolito . pertenece ( 8 ) && arbolito . pertenece ( 3 ) && arbolito . pertenece ( 6 ) && arbolito . pertenece ( 1 ) && arbolito . pertenece ( 16 ) && arbolito . pertenece ( 4 ) && arbolito . pertenece ( 7 ) && arbolito . pertenece ( 14 ) && arbolito . pertenece ( 13 ) ; assertEquals ( expected , actual ) ; }
va	1	public Set < String > keySet ( ) { if ( mode == Mode . Map ) { return map . keySet ( ) ; } throw new PerlHashTypeException ( "Not a map" ) ; }
va	2	private ArrayList < AtomExecutableCommand > populateExecutableCommandList ( String serverId , ArrayList < AtomExecutableCommand > commandList ) { AtomExecutableCommand _commandDet ; ArrayList < AtomExecutableCommand > _commandList ; int index = 0 ; int _countExecutables ; _commandList = new ArrayList < AtomExecutableCommand > ( ) ; _countExecutables = commandList . size ( ) ; while ( _countExecutables > index ) { _commandDet = commandList . get ( index ) ; if ( serverId . equals ( _commandDet . getServerID ( ) ) ) { _commandList . add ( _commandDet ) ; } index ++ ; } return _commandList ; }
va	2	public AdditionalGradeEntries read ( Integer id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AdditionalGradeEntries instance = null ; try { instance = ( AdditionalGradeEntries ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
va	4	private void updateItemsBorrowed ( ) { String attribute = null ; if ( studentJRadioButton . isSelected ( ) ) { attribute = studentJTextField . getText ( ) ; memberId = studentJTextField . getText ( ) ; } else if ( facultyJRadioButton . isSelected ( ) ) { attribute = facultyJTextField . getText ( ) ; memberId = facultyJTextField . getText ( ) ; } String query = "UPDATE members SET ItemsBorrowed=(ItemsBorrowed+1) WHERE MemberId='" + attribute + "' " ; String query2 = "UPDATE books SET IsBorrowed=1 WHERE ((Name='" + title . getTitleName ( ) + "') AND (ItemNo='" + title . getItemNo ( ) + "')) " ; try { pst = connection . prepareStatement ( query ) ; pst = connection . prepareStatement ( query2 ) ; pst . addBatch ( query ) ; pst . addBatch ( query2 ) ; pst . executeBatch ( ) ; JOptionPane . showMessageDialog ( null , "All tables are up-to-date.\nYou can now lend the Item to Member" , "Successful lending" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } }
va	3	public static Matrix4 multiply ( Matrix4 m1 , Matrix4 m2 ) { Matrix4 C = new Matrix4 ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) C . A [ i ] [ j ] += m1 . A [ i ] [ k ] * m2 . A [ k ] [ j ] ; return C ; }
va	4	public static StroopTest createRandomColourTest ( int wordSize , TestType type ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; Random randomizer = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { int next = randomizer . nextInt ( 2 ) ; switch ( next ) { case 0 : { words . add ( WordFactory . createRandomPlainColourWord ( ) ) ; break ; } case 1 : { words . add ( WordFactory . createRandomColourWord ( ) ) ; break ; } case 2 : { words . add ( WordFactory . createRandomMixedColourWord ( ) ) ; break ; } } } return new StroopTest ( words , type , "RANDOM" , "" ) ; }
va	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location newLocation = findFood ( ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
va	6	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
va	6	public void openFile ( String fileName ) { if ( m_bMpegPlaying ) { m_bKeepRunning = false ; } if ( m_inputStream != null ) { try { m_inputStream . close ( ) ; } catch ( IOException e ) { showDialog ( WARNING , e . getMessage ( ) ) ; } } if ( fileName != null ) { try { try { URL url = new URL ( fileName ) ; m_inputStream = new java . io . BufferedInputStream ( url . openStream ( ) ) ; } catch ( MalformedURLException e ) { m_inputStream = new java . io . BufferedInputStream ( new FileInputStream ( fileName ) ) ; } } catch ( IOException e ) { showDialog ( ERROR , e . getMessage ( ) ) ; } } else showDialog ( ERROR , "null FileName" ) ; }
va	2	public boolean isLeap ( ) { return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) || ( year % 400 == 0 ) ) ; }
va	3	@ Override public void tick ( ) { counter ++ ; if ( counter == tickDivider ) { counter = 0 ; if ( enemyUnits . size ( ) > 0 ) { Slime slime = new Slime ( ) ; rune . modifySlime ( slime ) ; for ( EnemyUnit enemy : enemyUnits ) { enemy . gotSlowed ( slime ) ; } } } }
va	6	public Vector < Vector < Object >> getFolderContentsTable ( ) { Vector < Vector < Object >> tableData = new Vector < > ( ) ; List < FileInfo > files = getFolderContents ( ) ; logger . debug ( "Found " + files . size ( ) + " entries for " + path . toString ( ) ) ; for ( FileInfo file : files ) { Vector < Object > row = null ; if ( file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/folder.png" ) ) ; } else { row . add ( new ImageIcon ( "res/folder_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } for ( FileInfo file : files ) { Vector < Object > row = null ; if ( ! file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/file.png" ) ) ; } else { row . add ( new ImageIcon ( "res/file_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } return tableData ; }
va	3	public void addFAB ( NodeFAB f , boolean clear ) { if ( clear ) fabs . clear ( ) ; int numB = 5 ; fabs . add ( f . make ( ) ) ; for ( Node N : network ) { if ( clear ) { N . clearFABS ( ) ; } N . addFAB ( f . make ( ) ) ; N . initFAB ( N . getNumFab ( ) - 1 , 0 ) ; } }
va	2	@ Override public boolean hasNext ( ) { while ( index < menu . size ( ) ) { if ( menu . get ( index ) . getCalories ( ) <= maxCalories ) { return true ; } else { index ++ ; } } return false ; }
va	8	public < T > Put insert ( T instance ) { try { Field key = clazz . getField ( "key" ) ; byte [ ] keyRow = ( byte [ ] ) key . get ( instance ) ; Put update = new Put ( keyRow ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( f . isAnnotationPresent ( HRowKey . class ) ) { continue ; } else if ( f . isAnnotationPresent ( HMapFamily . class ) ) { Map m = ( Map ) f . get ( instance ) ; HMapFamily annotation = f . getAnnotation ( HMapFamily . class ) ; update = insertMapFamily ( update , m , annotation ) ; } else if ( f . isAnnotationPresent ( HProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HProperty annotation = f . getAnnotation ( HProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HMapProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HMapProperty annotation = f . getAnnotation ( HMapProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HListProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HListProperty annotation = f . getAnnotation ( HListProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else { log . debug ( String . format ( "Skipping field %s as it has no supported annotations" , f . getName ( ) ) ) ; } } return update ; } catch ( NoSuchFieldException e ) { log . error ( "Field not found" , e ) ; return null ; } catch ( IllegalAccessException e ) { log . error ( "Access exception" , e ) ; return null ; } }
va	8	private String handleRequest ( String input ) throws IOException , IllegalArgumentException { System . out . println ( input ) ; String nameReg = "[a-zA-Z0-9\\.]+" ; String regex = "(boards)|(newBoard " + nameReg + ")|" + "(switch " + nameReg + " " + nameReg + " " + nameReg + ")|" + "(exit " + nameReg + ")|(users " + nameReg + ")|" + "(checkAndAddUser " + nameReg + " " + nameReg + ")|" + "(draw " + nameReg + "( " + nameReg + ")+)" ; if ( ! input . matches ( regex ) ) { System . out . println ( "Invalid input: " + input ) ; return null ; } String [ ] tokens = input . split ( " " ) ; if ( tokens [ 0 ] . equals ( "boards" ) ) { return boards ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "newBoard" ) ) { return newBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "switch" ) ) { return switchBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "exit" ) ) { return exit ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "draw" ) ) { return draw ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "checkAndAddUser" ) ) { return checkAndAddUser ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "users" ) ) { return users ( tokens ) ; } throw new UnsupportedOperationException ( ) ; }
va	1	public void clearFeedback ( ) { for ( ValueSource vs : valueSources ) { vs . clearFeedback ( ) ; } }
va	4	@ Override public IBSTree < T > delete ( T value ) { BSTree < T > parent = null ; BSTree < T > curr = this ; for ( int cmp = value . compareTo ( curr . data ) ; cmp != 0 ; cmp = value . compareTo ( curr . data ) ) { if ( cmp < 0 ) { if ( curr . left == null ) { return null ; } parent = curr ; curr = curr . getTypedLeft ( ) ; } else { if ( curr . right == null ) { return null ; } parent = curr ; curr = curr . getTypedRight ( ) ; } } return curr . delete ( parent ) ; }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int p1 ; p0 = new int [ ] { 5 , 1 , 2 } ; p1 = 4 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 4 } ; p1 = 8 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 2 , 7 } ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 94512 , 2 , 87654 , 81316 , 6 , 5 , 6 , 37151 , 6 , 139 , 1 , 36 , 307 , 1 , 377 , 101 , 8 , 37 , 58 , 1 } ; p1 = 1092 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 883 , 66392 , 3531 , 28257 , 1 , 14131 , 57 , 1 , 25 , 88474 , 4 , 1 , 110 , 6 , 1769 , 220 , 442 , 7064 , 7 , 13 } ; p1 = 56523 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 3 } ; p1 = 1 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	5	private String generateRandomId ( ) { StringBuilder sb = new StringBuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idLength ) { char ch = ( char ) rnd . nextInt ( ) ; if ( Utils . isUriLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containsKey ( sb . toString ( ) ) ) { sb . delete ( 0 , idLength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > RETRY_COUNT ) ; return sb . toString ( ) ; }
va	0	private void finaliza ( ) { this . dispose ( ) ; }
va	9X	@ Override public Party getEnemyParty ( int level ) { Party party = new Party ( ) ; Random gen = new Random ( ) ; if ( level == 1 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Goblin ( ) ) ; else party . add ( new Rat ( ) ) ; } else if ( level == 2 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Orc ( ) ) ; else party . add ( new Zombie ( ) ) ; } else if ( level == 3 ) { party . add ( new Spider ( ) ) ; } else if ( level == 5 ) { party . add ( new Ogre ( ) ) ; } else if ( level == 7 ) { party . add ( new Gargoyle ( ) ) ; } else if ( level == 15 ) { party . add ( new Dragon ( ) ) ; } else { do { int enemy = gen . nextInt ( level ) + 1 ; party . addAll ( getEnemyParty ( enemy ) ) ; level = level - enemy ; } while ( level != 0 ) ; } return party ; }
va	7	private void updatePlayerList ( Buffer stream , int count ) { while ( stream . bitPosition + 10 < count * 8 ) { int pId = stream . readBits ( 11 ) ; if ( pId == 2047 ) break ; if ( players [ pId ] == null ) { players [ pId ] = new Player ( ) ; if ( playerAppearanceData [ pId ] != null ) players [ pId ] . updatePlayerAppearance ( playerAppearanceData [ pId ] ) ; } localPlayers [ localPlayerCount ++ ] = pId ; Player player = players [ pId ] ; player . lastUpdateTick = tick ; int observed = stream . readBits ( 1 ) ; if ( observed == 1 ) playersObserved [ playersObservedCount ++ ] = pId ; int teleported = stream . readBits ( 1 ) ; int x = stream . readBits ( 5 ) ; if ( x > 15 ) x -= 32 ; int y = stream . readBits ( 5 ) ; if ( y > 15 ) y -= 32 ; player . setPos ( localPlayer . waypointX [ 0 ] + y , localPlayer . waypointY [ 0 ] + x , teleported == 1 ) ; } stream . finishBitAccess ( ) ; }
va	9X	public static Method getMostSpecificMethod ( Method method , class < ? > targetClass ) { if ( method != null && isOverridable ( method , targetClass ) && targetClass != null && ! targetClass . equals ( method . getDeclaringClass ( ) ) ) { try { if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { try { return targetClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException ex ) { return method ; } } else { Method specificMethod = ReflectionUtils . findMethod ( targetClass , method . getName ( ) , method . getParameterTypes ( ) ) ; return ( specificMethod != null ? specificMethod : method ) ; } } catch ( SecurityException ex ) { } } return method ; }
va	9X	public Geometry patch ( int m , int n , double basisMatrix [ ] [ ] , double data [ ] ) { newRectangularMesh ( m + 2 , n + 2 ) ; faces = new int [ m * n ] [ 4 ] ; for ( int k = 1 ; k < n + 1 ; k ++ ) for ( int j = 1 ; j < m + 1 ; j ++ ) { int f = ( k - 1 ) * m + j - 1 ; int v = k * ( m + 3 ) + j ; faces [ f ] [ 0 ] = v ; faces [ f ] [ 1 ] = v + 1 ; faces [ f ] [ 2 ] = v + m + 3 + 1 ; faces [ f ] [ 3 ] = v + m + 3 ; } double G [ ] [ ] [ ] = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) G [ k ] [ i ] [ j ] = data [ 12 * i + 3 * j + k ] ; Coefs = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int k = 0 ; k < 3 ; k ++ ) constructBicubicCoefficients ( G [ k ] , basisMatrix , Coefs [ k ] ) ; int N = 0 ; for ( int j = - 1 ; j <= n + 1 ; j ++ ) { double v = ( double ) j / n ; for ( int i = - 1 ; i <= m + 1 ; i ++ ) { double u = ( double ) i / m ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = evalBicubic ( Coefs [ k ] , u , v ) ; N ++ ; } } computedMeshNormals = false ; return this ; }
va	3	public User Authenticate ( String username , String password ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM users WHERE username = \"" + username + "\"" ) ; try { if ( rs . next ( ) ) { password = GenerateHash ( password ) ; if ( rs . getString ( "password" ) . equals ( password ) ) { UserFactory factory = UserFactory . sharedInstance ( ) ; User user = factory . getUserFromID ( rs . getInt ( "id" ) ) ; return user ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return null ; }
va	5	public Model method578 ( int i , int j , int k , int l , int i1 , int j1 , int k1 ) { Model model = method581 ( i , k1 , j ) ; if ( model == null ) return null ; if ( aBoolean762 || aBoolean769 ) model = new Model ( aBoolean762 , aBoolean769 , model ) ; if ( aBoolean762 ) { int l1 = ( k + l + i1 + j1 ) / 4 ; for ( int i2 = 0 ; i2 < model . anInt1626 ; i2 ++ ) { int j2 = model . anIntArray1627 [ i2 ] ; int k2 = model . anIntArray1629 [ i2 ] ; int l2 = k + ( ( l - k ) * ( j2 + 64 ) ) / 128 ; int i3 = j1 + ( ( i1 - j1 ) * ( j2 + 64 ) ) / 128 ; int j3 = l2 + ( ( i3 - l2 ) * ( k2 + 64 ) ) / 128 ; model . anIntArray1628 [ i2 ] += j3 - l1 ; } model . method467 ( ) ; } return model ; }
va	6	public void run ( ) { Message m = Parser . extractRequest ( fromClient ) ; Node child = m . contents . getFirstChild ( ) ; if ( ! child . getLocalName ( ) . equals ( Parser . connectRequest ) ) { return ; } System . out . println ( "Receiving: " + m ) ; String xmlString = Message . responseHeader ( m . id ( ) ) + "<connectResponse id='" + id + "'/></response>" ; Message r = new Message ( xmlString ) ; if ( ! sendMessage ( r ) ) { System . err . println ( "Unable to respond to connect Request from remote Client." ) ; return ; } Server . register ( id , this ) ; while ( ( m = Parser . extractRequest ( fromClient ) ) != null ) { Message response = handler . process ( this , m ) ; if ( ! sendMessage ( response ) ) { break ; } } if ( handler instanceof IShutdownHandler ) { ( ( IShutdownHandler ) handler ) . logout ( Server . getState ( id ) ) ; } Server . unregister ( id ) ; try { fromClient . close ( ) ; toClient . close ( ) ; client . close ( ) ; } catch ( IOException e ) { System . err . println ( "Unable to close connection:" + e . getMessage ( ) ) ; } }
va	8	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) { return true ; } if ( p == null && q != null ) { return false ; } if ( p != null && q == null ) { return false ; } return ( p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ) ; }
va	1	public void onUnitDestroy ( Unit unit ) { if ( eventListener != null ) { eventListener . onUnitDestroy ( unit ) ; } }
va	2	private void getReply ( DatagramSocket socket ) { while ( true ) { try { byte [ ] replybuffer = new byte [ 1024 ] ; DatagramPacket reply = new DatagramPacket ( replybuffer , replybuffer . length ) ; socket . receive ( reply ) ; System . out . println ( new String ( reply . getData ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
va	3	@ Override public void printOptions ( ) { if ( getSuccessors ( ) == null || getSuccessors ( ) . size ( ) == 0 ) { return ; } Printer . print ( Settings_Output . OUT_OPTION_HEAD , "Please choose an option" ) ; Integer i = 0 ; for ( final IAction action : getSuccessors ( ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , action . getName ( ) , action . getDescription ( ) ) ; i ++ ; } }
va	8	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
va	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
va	4	public Questionnaire getQuestionnaireById ( long id ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; Questionnaire questionnaire = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Retrieving questionnaire " + id + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUESTIONNAIRE ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUESTIONNAIRE ) ; statement . setLong ( 1 , id ) ; rs = statement . executeQuery ( ) ; if ( rs . next ( ) ) { questionnaire = fillQuestionnaire ( rs ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questionnaire ; }
va	4	protected String getJarName ( URL url ) { String fileName = url . getFile ( ) ; if ( fileName . contains ( "?" ) ) { fileName = fileName . substring ( 0 , fileName . indexOf ( "?" ) ) ; } if ( fileName . endsWith ( ".pack.lzma" ) ) fileName = fileName . replaceAll ( ".pack.lzma" , "" ) ; else if ( fileName . endsWith ( ".pack" ) ) fileName = fileName . replaceAll ( ".pack" , "" ) ; else if ( fileName . endsWith ( ".lzma" ) ) { fileName = fileName . replaceAll ( ".lzma" , "" ) ; } return fileName . substring ( fileName . lastIndexOf ( / ) + 1 ) ; }
va	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
va	3	@ Override public void dispose ( ) { for ( ObjectMap < String , Object > entry : data . values ( ) ) { for ( Object resource : entry . values ( ) ) { if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } }
va	1	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getPolicyNames ( ) != null ) sb . append ( "PolicyNames: " + getPolicyNames ( ) + " " ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
va	1	@ Override public double getOutputError ( double [ ] outputError ) { double squareErrorSum = 0d ; for ( double error : outputError ) squareErrorSum += ( error * error ) * 0.5 ; return squareErrorSum ; }
va	4	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } int [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
va	0	@ Override public FullVersion getVersion ( ) { return version ; }
va	9X	public void setCurrentVar ( int mag_idx ) { assert ( mag_idx >= - 1 && mag_idx < PaneData . magnetList . size ( ) ) ; setVisible ( false ) ; this . removeAll ( ) ; this . mag_idx = mag_idx ; if ( mag_idx == - 1 ) { log . severe ( "Magnet Pane - Magnet unselected." ) ; setVisible ( true ) ; return ; } Magnet mag = ( Magnet ) PaneData . magnetList . get ( mag_idx ) ; String mag_name = mag . getMagnetName ( ) ; for ( int i = 0 ; i < PaneData . var_names . size ( ) ; i ++ ) { String var_name = ( String ) PaneData . var_names . get ( i ) ; if ( var_name . equalsIgnoreCase ( mag_name ) ) { this . var_idx = i ; break ; } } log . severe ( "Magnet Pane - [" + PaneData . var_names . get ( var_idx ) + "] is selected." ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; setLayout ( new GridBagLayout ( ) ) ; constraints . fill = GridBagConstraints . BOTH ; strMeasure = ( String ) PaneData . var_measures . get ( var_idx ) ; strType = ( String ) PaneData . var_types . get ( var_idx ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; assert PaneData . values_min . get ( var_idx ) instanceof Integer ; assert PaneData . values_max . get ( var_idx ) instanceof Integer ; int min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; chkboxList = new JCheckBox [ max - min + 1 ] ; ArrayList repelList = mag . getRepelList ( ) ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( var_idx ) ; chkboxList [ i ] = new JCheckBox ( label . get ( min + i ) + " (" + Integer . toString ( min + i ) + ")" ) ; if ( repelList == null ) chkboxList [ i ] . setSelected ( false ) ; else chkboxList [ i ] . setSelected ( ( ( boolean ) repelList . get ( i ) ) . booleanValue ( ) ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.05 ; constraints . gridx = 0 ; constraints . gridy = 3 + i ; add ( chkboxList [ i ] , constraints ) ; } } else if ( strMeasure . equals ( "Q" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; double threshold = new double ( mag . getThreshold ( ) ) ; if ( strType . equals ( "I" ) ) { int min , max ; min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , min , max , threshold . intValue ( ) ) ; sliderRepel . setMinorTickSpacing ( ( max - min ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( max - min ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; } else if ( strType . equals ( "D" ) ) { double dmin , dmax ; dmin = ( ( double ) PaneData . values_min . get ( var_idx ) ) . doubleValue ( ) ; dmax = ( ( double ) PaneData . values_max . get ( var_idx ) ) . doubleValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , dmin , dmax , threshold . doubleValue ( ) , 1 ) ; sliderRepel . setMinorTickSpacing ( ( dmax - dmin ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( dmax - dmin ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getDoubleValue ( ) + "]" ) ; } } ) ; } else { assert false ; } constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 3 ; add ( sliderRepel , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
va	7	@ Override public void notificarCicloFinalizado ( ) { Tablero tablero = this . vp . obtenerTablero ( ) ; GameLoop gameLoop = this . vp . obtenerGameLoop ( ) ; ArrayList < Barco > listaBarco = tablero . getDestruidos ( ) ; for ( Barco barco : listaBarco ) { for ( Parte parte : barco . getCuerpo ( ) ) { ObjetoDibujable vista = MapaDeVistasDePartes . get ( parte ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( parte ) ; } } } ArrayList < Disparo > listaDisparo = tablero . getDisparosDetonados ( ) ; for ( Disparo disparo : listaDisparo ) { ObjetoDibujable vista = MapaDeVistasDeDisparos . get ( disparo ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( disparo ) ; } } listaDisparo . clear ( ) ; this . vp . obtenerEtiquetaPuntaje ( ) . setText ( "Puntaje: " + tablero . getPuntos ( ) ) ; if ( tablero . estaPerdido ( ) ) { JOptionPane . showMessageDialog ( null , "Lamentablemente Usted Perdio" ) ; this . reiniciarTablero ( ) ; } else if ( tablero . estaGanado ( ) ) { JOptionPane . showMessageDialog ( null , "Gano!!!!" ) ; this . reiniciarTablero ( ) ; } }
va	7	public CardCertificatesPane ( boolean ca , ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; String label = null ; baseIndex = ca ? 0 : 3 ; clearButtons = new JButton [ 3 ] ; viewButtons = new JButton [ 3 ] ; certNames = new JTextField [ 3 ] ; if ( ! ca ) { verifyButtons = new JButton [ 3 ] ; verifyFlags = new JTextField [ 3 ] ; } totalCerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalCerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; if ( ca ) { label = "CA Cert" ; } else { label = ulabels [ i ] + " Cert" ; } add ( new JLabel ( label + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; button = new JButton ( "Get from Card" ) ; button . setActionCommand ( "cardgetcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Load..." ) ; button . setActionCommand ( "loadcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certNames [ i ] = new JTextField ( 30 ) ; certNames [ i ] . setFont ( MainGUI . FONT ) ; certNames [ i ] . setEditable ( false ) ; components . add ( certNames [ i ] ) ; add ( certNames [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Clear" ) ; button . setActionCommand ( "clearcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; clearButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcardcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; viewButtons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new JButton ( "Verify" ) ; button . setActionCommand ( "verifycert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; verifyButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyFlags [ i ] = new JTextField ( 6 ) ; verifyFlags [ i ] . setFont ( MainGUI . FONT ) ; verifyFlags [ i ] . setEditable ( false ) ; components . add ( verifyFlags [ i ] ) ; add ( verifyFlags [ i ] , c ) ; } c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } updateCertsStatus ( ) ; setBorder ( BorderFactory . createTitledBorder ( ( ca ? "CA" : "User" ) + " Certificates" ) ) ; }
va	7	@ Deprecated static List < Object > graphToRDF ( Map < String , Object > graph , UniqueNamer namer ) { final List < Object > rval = new ArrayList < Object > ( ) ; for ( final String id : graph . keySet ( ) ) { final Map < String , Object > node = ( Map < String , Object > ) graph . get ( id ) ; final List < String > properties = new ArrayList < String > ( node . keySet ( ) ) ; Collections . sort ( properties ) ; for ( String property : properties ) { final Object items = node . get ( property ) ; if ( "@type" . equals ( property ) ) { property = RDF_TYPE ; } else if ( isKeyword ( property ) ) { continue ; } for ( final Object item : ( List < Object > ) items ) { final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; if ( id . indexOf ( "_:" ) == 0 ) { subject . put ( "type" , "blank node" ) ; subject . put ( "value" , namer . getName ( id ) ) ; } else { subject . put ( "type" , "IRI" ) ; subject . put ( "value" , id ) ; } final Map < String , Object > predicate = new LinkedHashMap < String , Object > ( ) ; predicate . put ( "type" , "IRI" ) ; predicate . put ( "value" , property ) ; if ( isList ( item ) ) { listToRDF ( ( List < Object > ) ( ( Map < String , Object > ) item ) . get ( "@list" ) , namer , subject , predicate , rval ) ; } else { final Object object = objectToRDF ( item , namer ) ; final Map < String , Object > tmp = new LinkedHashMap < String , Object > ( ) ; tmp . put ( "subject" , subject ) ; tmp . put ( "predicate" , predicate ) ; tmp . put ( "object" , object ) ; rval . add ( tmp ) ; } } } } return rval ; }
va	1	public String toString ( ) { StringBuilder out = new StringBuilder ( ) ; for ( ArrayPlace arrayPlace : arrayPlaces ) out . append ( arrayPlace ) . append ( "=" ) ; out . append ( expression ) ; return out . toString ( ) ; }
va	9X	public static Object getDummyObject ( class cls ) { Object obj = null ; try { Constructor < ? > ctor = cls . getDeclaredConstructor ( ) ; Reflector . ensureIsAccessible ( ctor ) ; obj = ctor . newInstance ( ) ; } catch ( NoSuchMethodException e1 ) { final Constructor < ? > ctor = cls . getConstructors ( ) [ 0 ] ; class [ ] paramTypes = ctor . getParameterTypes ( ) ; List < Object > params = new ArrayList < Object > ( ) ; for ( class paramType : paramTypes ) params . add ( paramType . isPrimitive ( ) ? getTypeDefaultValue ( paramType . getName ( ) ) : null ) ; try { obj = ctor . newInstance ( params . toArray ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } catch ( SecurityException e1 ) { e1 . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } finally { return obj ; } }
va	1	public void showHideDeleteBtn ( ) { if ( ! btnVisible ) { deletePanel . setVisible ( true ) ; this . repaint ( ) ; btnVisible = true ; } else { deletePanel . setVisible ( false ) ; this . repaint ( ) ; btnVisible = false ; } }
va	6	protected void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c ==  ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case  : prevCharIsCR = true ; break ; case  : prevCharIsLF = true ; break ; case 	 : column -- ; column += ( tabSize - ( column % tabSize ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; }
va	9X	public Card [ ] pickCards ( SelectCardOptions sco , Card [ ] allcards ) { GameQuery p = new GameQuery ( QueryType . GETCARD , QueryType . CARD ) . setObject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . CARD ) return null ; if ( p . o instanceof Card [ ] || p . o instanceof String [ ] ) { String [ ] selected ; if ( p . o instanceof Card [ ] ) { ArrayList < String > a = new ArrayList < String > ( ) ; for ( Card c : ( Card [ ] ) p . o ) a . add ( c . getName ( ) ) ; selected = a . toArray ( new String [ 0 ] ) ; } else selected = ( String [ ] ) p . o ; ArrayList < Card > ret = new ArrayList < Card > ( ) ; ArrayList < Card > all = new ArrayList < Card > ( Arrays . asList ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toArray ( new Card [ 0 ] ) ; } return null ; }
va	2	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; if ( "writeObj" . equals ( method . getName ( ) ) ) { Object obj = args [ 0 ] ; serializer . serialize ( pWriter , obj ) ; } else if ( "readObj" . equals ( method . getName ( ) ) ) { deSerList = deSerializer . deSerialize ( ) ; return deSerList ; } return null ; }
va	9X	public static void main ( String argv [ ] ) { try { if ( argv . length != 1 ) { System . err . println ( "USBD [ start | stop ]" ) ; System . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { Host host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USBD:  USB is not available." ) ; System . exit ( 1 ) ; } if ( host instanceof Remote ) { System . err . println ( "USBD: proxy already registered" ) ; System . exit ( 1 ) ; } try { HostProxy proxy = new HostProxy ( host ) ; Naming . bind ( rmiName , proxy ) ; System . err . println ( "USBD:  Bound RMI name " + rmiName ) ; } catch ( Exception e ) { System . err . println ( "USBD:  Couldn't bind to: " + rmiName ) ; if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { System . err . println ( "USBD: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { System . err . println ( "USBD: no '" + argv [ 0 ] + "' command" ) ; System . exit ( 1 ) ; } } catch ( Exception e ) { if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } }
te	2	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
te	8	public boolean initHeaderComponents ( ) { locationLabel = new JLabel ( "Project Location" ) ; locationLabel . setBounds ( 5 , 5 , 100 , 25 ) ; locationField = new JTextField ( ) ; locationField . setBounds ( 105 , 5 , 400 , 25 ) ; includeLabel = new JLabel ( "Include File type" ) ; includeLabel . setBounds ( 5 , 35 , 100 , 25 ) ; includeTextField = new JTextField ( ) ; includeTextField . setBounds ( 105 , 35 , 400 , 25 ) ; nonIncludeLabel = new JLabel ( "Non include" ) ; nonIncludeLabel . setBounds ( 5 , 65 , 100 , 25 ) ; nonIncludeTextField = new JTextField ( ) ; nonIncludeTextField . setBounds ( 105 , 65 , 400 , 25 ) ; configIncludeAndNonInclude ( ) ; openFileButton = new JButton ( "File.." ) ; openFileButton . setBounds ( 515 , 5 , 80 , 25 ) ; openFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileChooser = new JFileChooser ( new File ( "c:" ) ) ; int i = fileChooser . showOpenDialog ( header ) ; if ( i == JFileChooser . APPROVE_OPTION ) { locationField . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; configButton = new JButton ( "Config.." ) ; configButton . setBounds ( 515 , 45 , 80 , 25 ) ; configButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { configIncludeAndNonInclude ( ) ; } } ) ; loadButton = new JButton ( "Load" ) ; loadButton . setBounds ( 605 , 5 , 80 , 80 ) ; loadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( locationField . getText ( ) == null || locationField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "File cannot be null!" ) ; return ; } if ( includeTextField . getText ( ) == null || includeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Include cannot be null!" ) ; return ; } if ( nonIncludeTextField . getText ( ) == null || nonIncludeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Non-Include cannot be null!" ) ; return ; } if ( sourceCounter == null ) { sourceCounter = new SourceCounter ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) , includeTextField . getText ( ) , nonIncludeTextField . getText ( ) ) ; } else { sourceCounter . setFiles ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) ) ; sourceCounter . repaint ( ) ; } } } ) ; header . add ( locationLabel ) ; header . add ( locationField ) ; header . add ( includeLabel ) ; header . add ( includeTextField ) ; header . add ( nonIncludeLabel ) ; header . add ( nonIncludeTextField ) ; header . add ( openFileButton ) ; header . add ( configButton ) ; header . add ( loadButton ) ; return false ; }
te	4	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
te	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
te	6	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
te	8	public static Application parseApplicationDescription ( JSONObject topJson , boolean store ) throws DBException { try { JSONObject appJson ; appJson = topJson . getJSONObject ( "application" ) ; if ( ! appJson . has ( "USER_id" ) ) { appJson . put ( "USER_id" , ( User . getByName ( appJson . getString ( "USER_name" ) ) ) . getId ( ) ) ; } Application app = new Application ( appJson ) ; if ( store ) app . store ( ) ; LOG . debug ( "loading description for app:" + app . getDescription ( ) ) ; JSONArray modules = appJson . getJSONArray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { JSONObject m = modules . getJSONObject ( i ) ; m . put ( "APPLICATION_id" , app . getId ( ) ) ; Module module = new Module ( m ) ; if ( store ) module . store ( ) ; LOG . debug ( "parsed Module:" + module ) ; JSONArray components = m . getJSONArray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { JSONObject c = components . getJSONObject ( j ) ; c . put ( "MODULE_id" , "" + module . getId ( ) ) ; if ( ! c . has ( "RESOURCE_TYPE_id" ) ) { ResourceType rt = ResourceType . getByName ( c . getString ( "resource_type" ) ) ; c . put ( "RESOURCE_TYPE_id" , rt . getId ( ) ) ; } Component component = new Component ( c ) ; if ( store ) component . store ( ) ; LOG . debug ( "parsed component: " + component ) ; } } return app ; } catch ( JSONException ex ) { System . err . println ( "parsing not successfull" ) ; ex . printStackTrace ( ) ; } return null ; }
te	4	protected boolean isInGrabBar ( int mouseX , int mouseY ) { mouseY = Standards . W_HEIGHT - mouseY - 1 ; if ( ( mouseX > ScreenX ) && ( mouseX < ScreenX + Width ) ) { if ( ( mouseY > ScreenY ) && ( mouseY < ScreenY + GrabBarHeight ) ) { return true ; } } return false ; }
te	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
te	5	private static void loadVersionProperties ( ) { ClassLoader loader = ReleaseInfo . class . getClassLoader ( ) ; Properties info = new Properties ( ) ; InputStream stream = loader . getResourceAsStream ( PROPERTY_FILE ) ; if ( stream == null ) stream = loader . getResourceAsStream ( "/" + PROPERTY_FILE ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildVersion = info . getProperty ( "version" ) ; buildDate = info . getProperty ( "build.date" ) ; } catch ( IOException e ) { } } if ( buildVersion == null ) buildVersion = "unknown" ; if ( buildDate == null ) buildDate = "unknown" ; }
te	1	public static final < T extends Node < T >> void checkSameGraphs ( final Graph < T > g1 , final Graph < T > g2 ) { if ( g1 . getName ( ) . equals ( g2 . getName ( ) ) == false ) { throw new IllegalStateException ( "The two graphs are not same." ) ; } }
te	6	public Integer checkFields ( ) { if ( buttonGroup . getSelection ( ) == null ) { return null ; } else { final Enumeration < AbstractButton > elements = buttonGroup . getElements ( ) ; Integer num = null ; while ( elements . hasMoreElements ( ) ) { final JRadioButton button = ( JRadioButton ) elements . nextElement ( ) ; if ( button != null ) { if ( button . isSelected ( ) ) { num = Integer . parseInt ( button . getText ( ) . substring ( button . getText ( ) . lastIndexOf ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkFields ( num ) ) { return num ; } else { JOptionPane . showMessageDialog ( null , "***ERROR***: Incorrect search options" ) ; } } } return null ; }
te	4	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
te	5	public static void print ( JTextComponent textComponent ) throws TextComponentUtilException { InputStream is = null ; try { PrintService [ ] printServices = PrintServiceLookup . lookupPrintServices ( DocFlavor . INPUT_STREAM . AUTOSENSE , null ) ; if ( printServices . length > 0 ) { PrintRequestAttributeSet printRequestAttributeSet = new HashPrintRequestAttributeSet ( ) ; printRequestAttributeSet . add ( new JobName ( "JAligner" , null ) ) ; PrintService service = ServiceUI . printDialog ( null , 50 , 50 , printServices , PrintServiceLookup . lookupDefaultPrintService ( ) , DocFlavor . INPUT_STREAM . AUTOSENSE , printRequestAttributeSet ) ; if ( service != null ) { DocPrintJob printJob = service . createPrintJob ( ) ; PrintJobMointor printJobMointor = new PrintJobMointor ( printJob ) ; is = new ByteArrayInputStream ( textComponent . getText ( ) . getBytes ( ) ) ; DocumentName documentName = new DocumentName ( "JAligner" , null ) ; HashDocAttributeSet docAttributeSet = new HashDocAttributeSet ( ) ; docAttributeSet . add ( documentName ) ; Doc doc = new SimpleDoc ( is , DocFlavor . INPUT_STREAM . AUTOSENSE , docAttributeSet ) ; printJob . print ( doc , printRequestAttributeSet ) ; printJobMointor . waitForPrintJob ( ) ; } } else { throw new TextComponentUtilException ( "No print service found!" ) ; } } catch ( Exception e ) { throw new TextComponentUtilException ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Failed closing input stream: " + e . getMessage ( ) , e ) ; } } } }
te	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
te	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
te	1	public static String SQLdecrypted ( String decrypt ) { String decrypted = "" ; try { SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "DES" ) ; DESKeySpec keySpec = new DESKeySpec ( secretSalt . getBytes ( ) ) ; SecretKey key = keyFactory . generateSecret ( keySpec ) ; DesEncrypter encrypter = new DesEncrypter ( key ) ; decrypted = encrypter . decrypt ( decrypt ) ; } catch ( Exception e ) { Error_Frame . Error ( e . toString ( ) ) ; } return decrypted ; }
te	4	@ Override public boolean hasNext ( ) { if ( end ) { return false ; } if ( next != null ) { return true ; } peeked = true ; while ( iterator . hasNext ( ) ) { final T n = iterator . next ( ) ; if ( predicate . evaluate ( n ) ) { next = n ; return true ; } } end = true ; return false ; }
te	5	public static String toString ( float [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
te	0	public void setWeight ( int weight ) { this . weight = weight ; }
te	2	public void addThird ( Timeslot t ) { if ( t instanceof Lab ) { addThirdLab ( t ) ; } else if ( t instanceof Tutorial ) { addThirdTut ( t ) ; } }
te	9X	public int moveToMe ( MyStore < T > other ) { if ( other . size == 0 ) return 0 ; if ( this . size == 0 ) { this . moveAll ( other . size , other . head , this . tail , other ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return this . size ; } int initialMySize = this . size ; int initialOtherSize = other . size ; Container < T > thisOld = this . head ; Container < T > otherOld = other . head ; Container < T > thisCurrent = this . head . next ; Container < T > otherCurrent = other . head . next ; int otherRemaining = other . size ; int moved = 0 ; boolean done = false ; while ( true ) { int result = this . compare ( thisCurrent . el , otherCurrent . el ) ; if ( result == 0 ) { if ( otherCurrent . next != null ) { otherOld = otherCurrent ; otherCurrent = otherCurrent . next ; otherRemaining -- ; } else { done = true ; break ; } if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } else if ( result > 0 ) { otherOld . next = otherCurrent . next ; other . size -- ; thisOld . next = otherCurrent ; otherCurrent . next = thisCurrent ; this . size ++ ; moved ++ ; thisOld = otherCurrent ; if ( other . tail == otherCurrent ) { other . tail = otherOld ; } if ( otherOld . next != null ) { otherCurrent = otherOld . next ; otherRemaining -- ; } else { done = true ; break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } if ( ! done ) { this . moveAll ( otherRemaining , otherOld , thisCurrent , other ) ; moved += otherRemaining ; } assert ( this . size == initialMySize + moved ) ; assert ( other . size == initialOtherSize - moved ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return moved ; }
te	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
te	1	private static CC getCC ( ComponentWrapper comp , Map < ComponentWrapper , CC > ccMap ) { CC cc = ccMap . get ( comp ) ; return cc != null ? cc : new CC ( ) ; }
te	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
te	5	public MyPopulation ( int populationSize , int dataSize , IMyFitnessTestFunction < U > fitnessTester , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( populationSize < 4 ) { throw new Exception ( "population size should be 4 or greater" ) ; } if ( dataSize < MyIndividual . MIN_DATA_SIZE ) { throw new Exception ( "data size should be 4 or greater" ) ; } if ( fitnessTester == null ) { throw new Exception ( "fitnessTester function Cannot be null" ) ; } population = new ArrayList < > ( ) ; try { for ( int i = 0 ; i < populationSize ; i ++ ) { population . add ( new MyIndividual ( dataSize , true , 0.99 , true , fitnessTester , rFunc ) ) ; } } catch ( Exception e ) { System . err . println ( "ex in individual's constructor:" + e . getMessage ( ) ) ; } }
te	4	public void update ( final long newCurrent , final String optStatus ) { if ( this . upperLimit == - 1 ) { throw new IllegalArgumentException ( "This progress printer has not been initialized" ) ; } this . ownPos = newCurrent ; long sumOfSubProgresses = 0 ; this . currentPos = 0 ; for ( final ProgressPrinter subProgress : this . subProgress . keySet ( ) ) { double percentFinishedSubProgress = subProgress . getPercent ( ) / 100.0 ; long totalNumberStepsSubProgress = this . subProgress . get ( subProgress ) ; this . currentPos += ( percentFinishedSubProgress * totalNumberStepsSubProgress ) ; sumOfSubProgresses += totalNumberStepsSubProgress ; } final long remainingPart = this . upperLimit - sumOfSubProgresses ; if ( remainingPart < 0 ) { throw new IllegalArgumentException ( "Invalid part-sums of sub progresses" ) ; } this . currentPos += this . ownPos ; final float newPercent = this . currentPos > 0 ? ( ( float ) ( this . currentPos ) / this . upperLimit * 100.0f ) : 0.0f ; this . optStatus = optStatus ; this . % = newPercent ; this . fireChangeListener ( ) ; }
te	4	public void equipWeapon ( Survivor survivor , Weapon weapon ) throws CantEquipWeaponException { if ( ! this . survivors . contains ( survivor ) ) { throw new CantEquipWeaponException ( CantEquipWeaponException . notInTheTeam ( survivor ) ) ; } else if ( ! this . mainBase . getAvailableWeapons ( ) . contains ( weapon ) ) { throw new CantEquipWeaponException ( "Weapon must be one of those stored in base to equip" ) ; } else { Survivor owner = this . alreadyEquipped ( weapon ) ; if ( owner != null ) { throw new CantEquipWeaponException ( "Weapon is already equipped by " + owner . getName ( ) ) ; } else { Weapon oldWeapon = survivor . getWeapon ( ) ; this . mainBase . getAvailableWeapons ( ) . remove ( weapon ) ; survivor . setWeapon ( weapon ) ; if ( oldWeapon != null ) { this . mainBase . getAvailableWeapons ( ) . add ( oldWeapon ) ; } } } }
te	5	private LinkedList < String > extractKeywords ( String filename ) { LinkedList < String > keywords = new LinkedList < String > ( ) ; int posOfDot = filename . lastIndexOf ( . ) ; if ( posOfDot != - 1 ) { keywords . add ( filename . substring ( posOfDot ) ) ; filename = filename . substring ( 0 , posOfDot ) ; } filename = filename . replaceAll ( "[0-9]+" , " " ) . trim ( ) ; String [ ] splitCamelAndDelim = filename . split ( "((?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addAll ( Arrays . asList ( splitCamelAndDelim ) ) ; for ( Iterator < String > iter = keywords . iterator ( ) ; iter . hasNext ( ) ; ) { String item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . toUpperCase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
te	4	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
te	8	public final float getPixelUnitFactor ( boolean isHor ) { switch ( PlatformDefaults . getLogicalPixelBase ( ) ) { case PlatformDefaults . BASE_FONT_SIZE : Font font = c . getFont ( ) ; FontMetrics fm = c . getFontMetrics ( font != null ? font : SUBST_FONT ) ; Point . float p = FM_MAP . get ( fm ) ; if ( p == null ) { Rectangle2D r = fm . getStringBounds ( "X" , c . getGraphics ( ) ) ; p = new Point . float ( ( ( float ) r . getWidth ( ) ) / 6f , ( ( float ) r . getHeight ( ) ) / 13.27734375f ) ; FM_MAP . put ( fm , p ) ; } return isHor ? p . x : p . y ; case PlatformDefaults . BASE_SCALE_FACTOR : float s = isHor ? PlatformDefaults . getHorizontalScaleFactor ( ) : PlatformDefaults . getVerticalScaleFactor ( ) ; if ( s != null ) return s ; return ( isHor ? getHorizontalScreenDPI ( ) : getVerticalScreenDPI ( ) ) / ( float ) PlatformDefaults . getDefaultDPI ( ) ; default : return 1f ; } }
te	7	public void __doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = ( Context ) req . getSession ( ) . getAttribute ( Authtoken . TOKEN ) ; if ( ctx == null ) { ctx = new Context ( ) ; } String questionId = new String ( ) ; if ( req . getPathInfo ( ) != null ) { questionId = "/" + Question . RESOURCE_NAME + "/" + req . getPathInfo ( ) . replaceAll ( "/" , "" ) ; } if ( ! questionId . equals ( "" ) ) { Message request = new Message ( ctx ) ; request . put ( Question . ID , questionId ) ; Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; Message profileReq = new Message ( ctx ) ; Message profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , response . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; response . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; List < Map < String , String >> answers = new ArrayList < Map < String , String >> ( ) ; Message answerResp , voteResp ; for ( Map < String , String > ref : response . getReferences ( Question . ANSWERS ) ) { request = new Message ( ctx ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; answerResp = new Message ( ctx ) ; new AnswerService ( ) . doGet ( request , answerResp ) ; Map < String , String > answer = new HashMap < String , String > ( ) ; answer . put ( Answer . ID , answerResp . get ( Answer . ID ) ) ; answer . put ( Answer . CONTENT , answerResp . get ( Answer . CONTENT ) ) ; answer . put ( Answer . VOTES , answerResp . get ( Answer . VOTES ) ) ; answer . put ( Document . AUTHOR , answerResp . get ( Document . AUTHOR ) ) ; answer . put ( System . TIMESTAMP , answerResp . get ( System . TIMESTAMP ) ) ; profileReq = new Message ( ctx ) ; profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , answerResp . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; answer . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; if ( ctx != null ) { request = new Message ( ctx ) ; request . put ( Profile . ID , ctx . getLoggedInUserProfileId ( ) ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; voteResp = new Message ( ctx ) ; new VoteService ( ) . doGet ( request , voteResp ) ; if ( voteResp . containsField ( Vote . ID ) ) { answer . put ( Vote . ID , voteResp . get ( Vote . ID ) ) ; answer . put ( Vote . VOTE , voteResp . get ( Vote . VOTE ) ) ; } } answers . add ( answer ) ; } req . setAttribute ( Answer . RESOURCE_NAME , answers ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , Question . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "View Question" ) ; eventRequest . put ( Event . OBJECT , questionId ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_VIEW , req , resp ) ; } else { Message request = new Message ( ctx ) ; if ( req . getParameter ( QuestionSearchIndex . QUERY_STRING ) != null ) { request . put ( QuestionSearchIndex . QUERY_STRING , req . getParameter ( QuestionSearchIndex . QUERY_STRING ) ) ; } else { request . put ( QuestionSearchIndex . QUERY_STRING , "" ) ; } Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; response . put ( QuestionSearchIndex . QUERY_STRING , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , QuestionSearchIndex . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "Search Question" ) ; eventRequest . put ( Event . OBJECT , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_SEARCH_VIEW , req , resp ) ; } }
te	6	public void mouseClicked ( MouseEvent me ) { try { if ( me . getSource ( ) == jb_connexion ) { login = jtf_login . getText ( ) ; password = String . valueOf ( jpf_password . getPassword ( ) ) ; System . out . println ( "Email : " + login ) ; System . out . println ( "MotDePasse : " + password ) ; User u = null ; Connection co = bs . getConnection ( ) ; System . out . println ( "avant IF" ) ; if ( User . checkPresence ( bs , login , password ) ) { System . out . println ( "debut IF" ) ; u = User . findByLogs ( login , password , bs ) ; groupe = UserType . findById ( u . getId_ut ( ) , bs ) . getName_ut ( ) ; System . out . println ( "OK : " + groupe ) ; afficherMenuPrincipal ( ) ; setResizable ( true ) ; setExtendedState ( MAXIMIZED_BOTH ) ; } else { System . out . println ( "NON OK" ) ; } } if ( me . getSource ( ) == jb_mdp_oublie ) { if ( SwingUtilities . isLeftMouseButton ( me ) ) { } if ( SwingUtilities . isRightMouseButton ( me ) ) { } } } catch ( Exception e ) { System . out . println ( "Exception" ) ; e . printStackTrace ( ) ; } }
te	4	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
te	9X	public boolean isModifier ( DataHolder dataholderHandler , String word , String modifier , String tag ) { if ( this . checkedModifiers . containsKey ( word ) ) { if ( this . checkedModifiers . get ( word ) ) { return true ; } else { return false ; } } Set < String > nouns = new HashSet < String > ( Arrays . asList ( "s p n" . split ( " " ) ) ) ; List < Entry < WordPOSKey , WordPOSValue >> entries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , nouns ) ; if ( entries . size ( ) > 0 ) { this . checkedModifiers . put ( word , true ) ; return true ; } Set < String > bPOS = new HashSet < String > ( ) ; bPOS . add ( "b" ) ; List < Entry < WordPOSKey , WordPOSValue >> boundaries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , bPOS ) ; boolean c1 = ( boundaries . size ( ) > 0 ) ; boolean c2 = dataholderHandler . getModifierHolder ( ) . containsKey ( word ) ; if ( c1 && ! c2 ) { this . checkedModifiers . put ( word , false ) ; return false ; } if ( ! c1 && c2 ) { this . checkedModifiers . put ( word , true ) ; return true ; } int mCount = this . getMCount ( dataholderHandler , word ) ; String wCopy = "" + word ; if ( StringUtility . isMatchedNullSafe ( word , "_" ) ) { wCopy = wCopy . replaceAll ( "_" , " - " ) ; } int tCount = 0 ; String pattern = "(^| )" + wCopy + " " ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String oSentence = sentenceItem . getOriginalSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( oSentence , pattern ) ) { tCount ++ ; } } if ( tCount == 0 || tCount > 0.25 * mCount ) { this . checkedModifiers . put ( word , false ) ; return false ; } else { this . checkedModifiers . put ( word , true ) ; return true ; } }
te	6	public static String unescape ( String s ) { int len = s . length ( ) ; StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = s . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < len ) { int d = JSONTokener . dehexchar ( s . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( s . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } b . append ( c ) ; } return b . toString ( ) ; }
te	4	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
te	5	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = 1.0 ; } else if ( x [ i ] < ( a + b ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else func [ i ] = 0.0 ; } return func ; }
te	4	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
te	8	public static int searchInt ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchInt ( arr , low , mid - 1 , x ) ; else return searchInt ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchInt ( arr , mid + 1 , high , x ) ; else return searchInt ( arr , low , mid , x ) ; } }
te	6	public static ConsumptionModel getConsumptionModelForWashingMachine ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
te	5	@ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) servletRequest ; HttpServletResponse response = ( HttpServletResponse ) servletResponse ; User session = ( User ) request . getSession ( ) . getAttribute ( "user" ) ; String url = request . getRequestURI ( ) ; response . setHeader ( "Cache-Control" , "no-cache  no-store  must-revalidate" ) ; response . setHeader ( "Pragma" , "no-cache" ) ; response . setDateHeader ( "Expires" , 0 ) ; if ( session == null ) { if ( url . indexOf ( "/content/" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "/security/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } else { if ( url . indexOf ( "register.xhtml" ) >= 0 || url . indexOf ( "/login.xhtml" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexOf ( "logout.xhtml" ) >= 0 ) { request . getSession ( ) . removeAttribute ( "user" ) ; response . sendRedirect ( request . getContextPath ( ) + "/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } }
te	1	public < T > T getInstance ( class < T > c , String [ ] args ) throws Exception { AnnotatedConstructor ctor = ctors . get ( c ) ; AnnotatedCLI . ParsedCLI cli = parse ( args ) ; T obj ; if ( ctor != null ) { obj = ( T ) ctor . newInstance ( cli ) ; } else { obj = ( T ) c . newInstance ( ) ; } cli . inject ( obj ) ; return obj ; }
te	1	public void closeWriter ( ) { try { this . writer . flush ( ) ; this . writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	6	public static Integer valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof byte ) { return ( int ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( Integer ) o ; } else if ( o instanceof double ) { return ( int ) ( double ) ( double ) o ; } else if ( o instanceof float ) { return ( int ) ( float ) ( float ) o ; } else if ( o instanceof long ) { return ( int ) ( long ) ( long ) o ; } else { return null ; } }
te	6	private void initPanels ( ) { if ( attribs == null ) { attribs = new MyInternalFrame ( this , 1 ) ; jDesktopPane1 . add ( attribs , new Integer ( 10 ) ) ; } try { attribs . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } attribs . setVisible ( true ) ; if ( tools == null ) { tools = new MyInternalFrame ( this , 0 ) ; jDesktopPane1 . add ( tools , new Integer ( 10 ) ) ; } tools . setVisible ( true ) ; try { tools . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } if ( opers == null ) { opers = new MyInternalFrame ( this , 2 ) ; jDesktopPane1 . add ( opers , new Integer ( 10 ) ) ; } try { opers . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } opers . setVisible ( true ) ; }
te	5	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof EulerAngles ) { EulerAngles otherAngle = ( EulerAngles ) other ; if ( FloatingPointUtils . floatEqual ( otherAngle . psi , this . psi ) && FloatingPointUtils . floatEqual ( otherAngle . theta , this . theta ) && FloatingPointUtils . floatEqual ( otherAngle . phi , this . phi ) ) { return true ; } } return false ; }
te	3	private void processNumber ( Object value ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; if ( double . isNaN ( average ) ) { average = doubleValue ; min = doubleValue ; max = doubleValue ; sum = doubleValue ; } else { if ( doubleValue < min ) { min = doubleValue ; } if ( doubleValue > max ) { max = doubleValue ; } sum += doubleValue ; average = average + ( doubleValue - average ) / count ; } }
te	7	public void onEnable ( ) { Server = getServer ( ) ; log = Server . getLogger ( ) ; setPdfFile ( this . getDescription ( ) ) ; moveFiles ( ) ; setupPermissions ( ) ; questPlayerStorage = new iProperty ( "plugins/uQuest/uQuest_Players.txt" ) ; if ( new File ( "plugins/uQuest/uQuest_Quests.txt" ) . exists ( ) ) new QuestConverter ( ) ; if ( isUseDefaultUQuest ( ) ) { Cmd_uquest cmd_uquest = new Cmd_uquest ( this ) ; getCommand ( "uquest" ) . setExecutor ( cmd_uquest ) ; getCommand ( "quest" ) . setExecutor ( cmd_uquest ) ; try { getCommand ( "q" ) . setExecutor ( cmd_uquest ) ; } catch ( NullPointerException npe ) { useDefaultHelp = false ; } } setupEconomy ( ) ; Cmd_reloadquests cmd_reloadquests = new Cmd_reloadquests ( this ) ; getCommand ( "reloadquests" ) . setExecutor ( cmd_reloadquests ) ; Cmd_reloadquestconfig cmd_reloadquestconfig = new Cmd_reloadquestconfig ( this ) ; getCommand ( "reloadquestconfig" ) . setExecutor ( cmd_reloadquestconfig ) ; readConfig ( ) ; theQuestsLoadAllIntoArray ( ) ; if ( this . theQuests . isEmpty ( ) ) { System . err . println ( "\n\n\n" + pluginNameBracket ( ) + " You have an empty quest list!\n Disabling plugin.\n\n\n" ) ; Server . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( isUseSQLite ( ) == true ) { this . setDB ( new SqLiteKeyValStor < Quester > ( "questers" , "plugins/uQuest/uQuestQuesters" ) ) ; System . out . println ( pluginNameBracket ( ) + " Loaded with SQLite!" ) ; } if ( firstLoad == true && isUseSQLite ( ) == false ) { timerSavePlayers ( ) ; firstLoad = false ; System . out . println ( pluginNameBracket ( ) + " Loaded with Flatfile!" ) ; } registerEvents ( ) ; System . out . println ( pluginNameBracket ( ) + " v" + getPdfFile ( ) . getVersion ( ) + " enabled! With " + this . getQuestInteraction ( ) . getQuestTotal ( ) + " quests loaded!" ) ; }
te	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
te	8	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
te	9X	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
te	5	@ Override public void mousePressed ( MouseEvent me ) { int w = gridRenderer . getWidth ( ) / gridColumns ; int col = me . getX ( ) / w ; int h = gridRenderer . getHeight ( ) / gridRows ; int row = me . getY ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getButton ( ) == MouseEvent . BUTTON1 ) { if ( tilesRemaining > 0 ) { value ++ ; tilesRemaining -- ; } if ( tilesRemaining == 0 ) { saveAsButton . setEnabled ( true ) ; } } else if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( value > 0 ) { value -- ; tilesRemaining ++ ; saveAsButton . setEnabled ( false ) ; } } grid [ col ] [ row ] = value ; updateTilesRemainingLabel ( ) ; gridRenderer . repaint ( ) ; }
te	3	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
te	3	private static boolean iguales ( Nodo nodo1 , Nodo nodo2 ) { if ( nodo1 == null && nodo2 == null ) return true ; if ( nodo1 . equals ( nodo2 ) ) return iguales ( nodo1 . getSiguiente ( ) , nodo2 . getSiguiente ( ) ) ; return false ; }
te	2	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
te	2	private void botonEliminarUsuarioActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . tablaAdministracionUsuarios . getSelectedRow ( ) > - 1 ) { String codigo = ( String ) this . conectorTablaUsuarios . getValueAt ( this . tablaAdministracionUsuarios . getSelectedRow ( ) , 0 ) ; int respuesta = JOptionPane . showConfirmDialog ( this . botonEliminarUsuario , "\u00BFRealmente desea eliminar \n al usuario " + codigo + "?" , "Confirme eliminaci\u00F3n" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( respuesta == JOptionPane . YES_OPTION ) { Usuario u = this . modeloApp . obtenerUsuarioConCodigo ( codigo ) ; this . modeloApp . eliminarUsuario ( u ) ; this . conectorTablaUsuarios . cargarUsuarios ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Debe seleccionar un\nusuario de la tabla" , "Usuario no seleccionado" , JOptionPane . INFORMATION_MESSAGE ) ; } }
te	6	@ Override public byte [ ] toBytes ( Object value ) { String string = ( String ) value ; string = Normalizer . normalize ( string , Normalizer . Form . NFC ) ; if ( ! caseSensitive ) { string = string . toLowerCase ( locale ) ; } byte [ ] bytes = ENCODERS . get ( byteEncodeMode ) . toBytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new RuntimeException ( "Encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
te	2	protected void markCreatedNode ( Node newNode ) { if ( ! ( newNode instanceof ObjectNode ) ) return ; if ( ! containsAncestor ( createdNodes , newNode ) ) { Node . createdNodes . add ( newNode ) ; } }
te	2	@ NotNull @ Override public FileContent fileContentBefore ( ) { if ( filePathBefore . equals ( noFilePath ) ) return FileContent . none ; LogFileContentResult logFileContentResult = vcsRoot . get ( ) . logFileContent ( filePathBefore , revisionBefore ) ; return logFileContentResult . isSuccessful ( ) ? new FileContent ( logFileContentResult . text ( ) ) : FileContent . failedToLoad ; }
te	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isOpenV ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( toBottom [ idx ] ) { percolates = true ; } ufTop . union ( idx , theTOP ) ; } else { connectIfDestOpen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectIfDestOpen ( idx , row , col - 1 ) ; } if ( col < N ) { connectIfDestOpen ( idx , row , col + 1 ) ; } if ( row == N ) { if ( toTop [ idx ] ) { percolates = true ; } } else { connectIfDestOpen ( idx , row + 1 , col ) ; } } }
te	1	@ Test public void testGetArgument ( ) { initializeArguments ( ) ; InputDefinition definition = new InputDefinition ( ) ; definition . addArguments ( Arrays . asList ( ( InputArgument ) foo ) ) ; assertEquals ( "getArgument() returns a InputArgument by its name" , foo , definition . getArgument ( "foo" ) ) ; try { definition . getArgument ( "bar" ) ; fail ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" ) ; } catch ( Exception e ) { assertTrue ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" , e instanceof IllegalArgumentException ) ; assertEquals ( "The \"bar\" argument does not exist." , e . getMessage ( ) ) ; } }
te	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Station station = ( Station ) o ; if ( id != station . id ) return false ; if ( name != null ? ! name . equals ( station . name ) : station . name != null ) return false ; return true ; }
te	1	public static < T > FunctionExecutor < T > createGet ( final FeatureDefinition < ? extends Property < T >> propertyDefinition ) { return new FunctionExecutor < T > ( ) { @ Override public T invoke ( FunctionInvocation < T > invocation , Object ... arguments ) throws ExecutorInvocationException { invocation . next ( arguments ) ; return invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; } } ; }
te	9X	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
te	2	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
te	5	private void constructGUIControls ( ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager poseurStateManager = singleton . getStateManager ( ) ; canvasSplitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; appWindow = new AnimatedSpriteViewer ( ) ; PoseCanvasState zoomableCanvasState = poseurStateManager . getZoomableCanvasState ( ) ; zoomableCanvas = new PoseCanvas ( zoomableCanvasState ) ; zoomableCanvasState . setPoseCanvas ( zoomableCanvas ) ; zoomableCanvas . setBackground ( ZOOMABLE_CANVAS_COLOR ) ; northPanel = new JPanel ( ) ; northOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfRightCanvas = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; vertical = new JScrollPane ( southOfRightCanvas ) ; MediaTracker tracker = new MediaTracker ( this ) ; int idCounter = 0 ; fileToolbar = new JToolBar ( ) ; newButton = ( JButton ) initButton ( NEW_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , NEW_TOOLTIP ) ; openButton = ( JButton ) initButton ( OPEN_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , OPEN_TOOLTIP ) ; saveButton = ( JButton ) initButton ( SAVE_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_TOOLTIP ) ; saveAsButton = ( JButton ) initButton ( SAVE_AS_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_AS_TOOLTIP ) ; exportButton = ( JButton ) initButton ( EXPORT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXPORT_TOOLTIP ) ; exitButton = ( JButton ) initButton ( EXIT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXIT_TOOLTIP ) ; editToolbar = new JToolBar ( ) ; selectionButton = ( JButton ) initButton ( SELECTION_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , SELECT_TOOLTIP ) ; cutButton = ( JButton ) initButton ( CUT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , CUT_TOOLTIP ) ; copyButton = ( JButton ) initButton ( COPY_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , COPY_TOOLTIP ) ; pasteButton = ( JButton ) initButton ( PASTE_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , PASTE_TOOLTIP ) ; moveToBackButton = ( JButton ) initButton ( MOVE_TO_BACK_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_BACK_TOOLTIP ) ; moveToFrontButton = ( JButton ) initButton ( MOVE_TO_FRONT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_FRONT_TOOLTIP ) ; shapeToolbar = new JToolBar ( ) ; shapeButtonGroup = new ButtonGroup ( ) ; lineToggleButton = ( JToggleButton ) initButton ( LINE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , LINE_TOOLTIP ) ; rectToggleButton = ( JToggleButton ) initButton ( RECT_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , RECT_TOOLTIP ) ; ellipseToggleButton = ( JToggleButton ) initButton ( ELLIPSE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , ELLIPSE_TOOLTIP ) ; DefaultComboBoxModel lineThicknessModel = new DefaultComboBoxModel ( ) ; for ( int i = 0 ; i < NUM_STROKES_TO_CHOOSE_FROM ; i ++ ) { String imageFileName = STROKE_SELECTION_FILE_PREFIX + ( i + 1 ) + PNG_FILE_EXTENSION ; Image img = batchLoadImage ( imageFileName , tracker , idCounter ++ ) ; ImageIcon ii = new ImageIcon ( img ) ; lineThicknessModel . addElement ( ii ) ; } lineStrokeSelectionComboBox = new JComboBox ( lineThicknessModel ) ; zoomToolbar = new JToolBar ( ) ; zoomOutButton = ( JButton ) initButton ( ZOOM_OUT_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_OUT_TOOLTIP ) ; zoomInButton = ( JButton ) initButton ( ZOOM_IN_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_IN_TOOLTIP ) ; zoomLabel = new JLabel ( ) ; zoomLabel . setFont ( ZOOM_LABEL_FONT ) ; updateZoomLabel ( ) ; dimensionsButton = ( JButton ) initButton ( POSE_DIMENSIONS_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , CHANGE_POSE_DIMENSIONS_TOOLTIP ) ; colorSelectionToolbar = new JToolBar ( ) ; colorButtonGroup = new ButtonGroup ( ) ; outlineColorSelectionButton = ( ColorToggleButton ) initButton ( OUTLINE_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , OUTLINE_TOOLTIP ) ; outlineColorSelectionButton . setBackground ( Color . BLACK ) ; fillColorSelectionButton = ( ColorToggleButton ) initButton ( FILL_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , FILL_TOOLTIP ) ; fillColorSelectionButton . setBackground ( Color . WHITE ) ; outlineColorSelectionButton . setSelected ( true ) ; ColorPalletLoader cpl = new ColorPalletLoader ( ) ; ColorPalletState cps = new ColorPalletState ( ) ; cpl . initColorPallet ( COLOR_PALLET_SETTINGS_XML , cps ) ; colorPallet = new ColorPallet ( cps ) ; cps . setView ( colorPallet ) ; customColorSelectorButton = ( JButton ) initButton ( CUSTOM_COLOR_SELECTOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , JButton . class , null , CUSTOM_COLOR_TOOLTIP ) ; alphaLabel = new JLabel ( ALPHA_LABEL_TEXT ) ; alphaLabel . setFont ( ALPHA_LABEL_FONT ) ; alphaLabel . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider = new JSlider ( JSlider . HORIZONTAL , TRANSPARENT , OPAQUE , OPAQUE ) ; transparencySlider . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider . setMajorTickSpacing ( ALPHA_MAJOR_TICK_SPACING ) ; transparencySlider . setMinorTickSpacing ( ALPHA_MINOR_TICK_SPACING ) ; transparencySlider . setPaintLabels ( true ) ; transparencySlider . setPaintTicks ( true ) ; transparencySlider . setPaintTrack ( true ) ; transparencySlider . setToolTipText ( ALPHA_TOOLTIP ) ; transparencySlider . setSnapToTicks ( false ) ; labelPoses = appWindow . getLabelPoses ( ) ; try { imagePose = ImageIO . read ( new File ( EDITPOSE_IMAGE_FILE ) ) ; System . out . println ( "Image has read" ) ; picLabelPose = new JLabel ( new ImageIcon ( imagePose ) ) ; } catch ( IOException ex ) { System . out . println ( "Did not read Image" ) ; } jtbEdit = new JToolBar ( ) ; idCounter = 0 ; btnNewPose = ( JButton ) initButton ( NEWPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , NEWPOSE_TOOLTIP ) ; btnSavePose = ( JButton ) initButton ( SAVEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , SAVEPOSE_TOOLTIP ) ; btnOpenPose = ( JButton ) initButton ( OPENPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , OPENPOSE_TOOLTIP ) ; btnDeletePose = ( JButton ) initButton ( DELETEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DELETEPOSE_TOOLTIP ) ; btnDuplicatePose = ( JButton ) initButton ( DUPLICATEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DUPLICATEPOSE_TOOLTIP ) ; btnShiftLeftPose = ( JButton ) initButton ( SHIFTLEFT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , LEFTPOSE_TOOLTIP ) ; btnShifRighttPose = ( JButton ) initButton ( SHIFTRIGHT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , RIGHTPOSE_TOOLTIP ) ; btnSetDurationPose = ( JButton ) initButton ( DURATIONPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DURATIONPOSE_TOOLTIP ) ; northOfZoomableCanvasPanel = new JPanel ( ) ; northOfZoomableCanvasPanel . setLayout ( new BorderLayout ( ) ) ; try { if ( ! appWindow . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { this . setDisablePoseButton ( true ) ; } else { setDisablePoseButton ( false ) ; } } catch ( NullPointerException e ) { setDisablePoseButton ( false ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { Logger . getLogger ( PoseurGUI . class . getName ( ) ) . log ( Level . SEVERE , null , ie ) ; } }
te	7	private void populate ( ) { Random rand = Randomizer . getRandom ( ) ; field . clear ( ) ; int Number_of_foxes = 0 ; int Number_of_rabbits = 0 ; int Number_of_korenwolfs = 0 ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { if ( rand . nextDouble ( ) <= KORENWOLF_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Korenwolf korenwolf = new Korenwolf ( true , field , location ) ; actors . add ( korenwolf ) ; Number_of_korenwolfs ++ ; } else if ( rand . nextDouble ( ) <= FOX_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Fox fox = new Fox ( true , field , location ) ; actors . add ( fox ) ; Number_of_foxes ++ ; } else if ( rand . nextDouble ( ) <= RABBIT_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Rabbit rabbit = new Rabbit ( true , field , location ) ; actors . add ( rabbit ) ; Number_of_rabbits ++ ; } else if ( rand . nextDouble ( ) <= HUNTER_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Hunter hunter = new Hunter ( field , location ) ; actors . add ( hunter ) ; } else if ( rand . nextDouble ( ) <= 0.03 ) { Location location = new Location ( row , col ) ; Grass grass = new Grass ( field , location ) ; actors . add ( grass ) ; } } } Rabbit . PERFECT_NUMBER_OF_RABBITS = Number_of_rabbits ; Fox . PERFECT_NUMBER_OF_FOXES = Number_of_foxes ; Korenwolf . PERFECT_NUMBER_OF_KORENWOLFS = Number_of_korenwolfs ; }
te	2	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
te	9X	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
te	1	public boolean offerFirst ( E e ) { if ( contains ( e ) ) { return false ; } linkFirst ( e ) ; return true ; }
te	3	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
te	3	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
te	8	public ByteBuffer getBuffer ( String filePath ) { ByteBuffer buffer = fileMaps . get ( filePath ) ; if ( buffer == null ) { File requestedFile = new File ( filePath ) ; if ( requestedFile != null && requestedFile . exists ( ) ) { FileInputStream fileInput = null ; FileChannel fileChannel = null ; try { fileInput = new FileInputStream ( requestedFile ) ; fileChannel = fileInput . getChannel ( ) ; if ( fileChannel . size ( ) < ( 1024 * 1024 * 10 ) ) { MappedByteBuffer fileBuffer = fileChannel . map ( MapMode . READ_ONLY , 0 , fileChannel . size ( ) ) ; fileBuffer . load ( ) ; this . fileMaps . put ( filePath , fileBuffer ) ; buffer = fileBuffer . asReadOnlyBuffer ( ) ; } else { buffer = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fileInput != null ) { fileInput . close ( ) ; fileInput = null ; } if ( fileChannel != null ) { fileChannel . close ( ) ; fileChannel = null ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return buffer ; }
te	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
te	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
te	8	protected long skipBytes ( long bytes ) throws BasicPlayerException { long totalSkipped = 0 ; if ( m_dataSource instanceof File ) { int previousStatus = m_status ; m_status = SEEKING ; long skipped = 0 ; try { synchronized ( m_audioInputStream ) { notifyEvent ( BasicPlayerEvent . SEEKING , getEncodedStreamPosition ( ) , - 1 , null ) ; initAudioInputStream ( ) ; if ( m_audioInputStream != null ) { while ( totalSkipped < ( bytes - SKIP_INACCURACY_SIZE ) ) { skipped = m_audioInputStream . skip ( bytes - totalSkipped ) ; if ( skipped == 0 ) break ; totalSkipped = totalSkipped + skipped ; if ( totalSkipped == - 1 ) throw new BasicPlayerException ( BasicPlayerException . SKIPNOTSUPPORTED ) ; } } } notifyEvent ( BasicPlayerEvent . SEEKED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_status = OPENED ; if ( previousStatus == PLAYING ) startPlayback ( ) ; else if ( previousStatus == PAUSED ) { startPlayback ( ) ; pausePlayback ( ) ; } } catch ( IOException e ) { throw new BasicPlayerException ( e ) ; } } return totalSkipped ; }
te	6	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
te	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
te	3	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
te	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
te	5	@ Override public int compare ( Course course1 , Course course2 ) { if ( sortOrder == SortOrder . ASCENDING ) { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return - 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return - 1 ; } } }
te	5	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
te	7	@ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { if ( event . isCancelled ( ) ) { return ; } Player player = event . getPlayer ( ) ; if ( preChecks ( player , event . getTo ( ) ) ) { JumpPort port = JumpPorts . getPort ( event . getTo ( ) ) ; if ( checkInstant ( event ) ) { return ; } if ( checkJump ( event ) ) { return ; } if ( checkFall ( event ) ) { return ; } if ( ! ignoredPlayers . contains ( player . getName ( ) ) ) { player . sendMessage ( Lang . get ( "port.triggered" ) . replaceAll ( "%N" , port . getName ( ) ) . replaceAll ( "%D" , port . getDescription ( ) ) ) ; if ( port . getPrice ( ) > 0 ) { player . sendMessage ( Lang . get ( "port.price" ) . replaceAll ( "%P" , "" + port . getPrice ( ) ) ) ; } player . sendMessage ( Lang . get ( "port.triggers" ) ) ; ignoredPlayers . add ( player . getName ( ) ) ; } } }
te	6	public void addPoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
te	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
te	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
te	6	public static Player fromXml ( org . w3c . dom . Node playerRoot , MonteCarloPlayer player ) { NamedNodeMap attrs = playerRoot . getAttributes ( ) ; player . description = "" ; if ( attrs . getNamedItem ( "playout" ) != null ) { try { Field field = PlayoutStrategy . class . getField ( attrs . getNamedItem ( "playout" ) . getNodeValue ( ) ) ; player . playout = ( PlayoutStrategy ) field . get ( null ) ; player . description += String . format ( "playout=%s" , field . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "finalMove" ) != null ) { try { Field field = FinalNodeSelectionStrategy . class . getField ( attrs . getNamedItem ( "finalMove" ) . getNodeValue ( ) ) ; player . finalNode = ( FinalNodeSelectionStrategy ) field . get ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "maxTurnTime" ) != null ) { try { player . MAX_TURN_TIME = long . parseLong ( attrs . getNamedItem ( "maxTurnTime" ) . getNodeValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } player . description = String . format ( "playout=%s final=%s" , player . playout , player . finalNode ) ; return player ; }
te	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
te	3	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
te	1	public MerchantDeal getMerchantDeal ( int merchantDealId ) { MerchantDeal merchantDeal = null ; try { session = mySessionFactory . getCurrentSession ( ) ; merchantDeal = ( MerchantDeal ) session . get ( MerchantDeal . class , merchantDealId ) ; } catch ( Exception e ) { } return merchantDeal ; }
te	9X	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; int [ ] p2 ; int p3 ; double p4 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 5 } ; p3 = 10 ; p4 = 0.5D ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.0D ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 10 } ; p1 = new int [ ] { 10 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.4142135623730951D ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 11 , - 11 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 11 , - 11 } ; p2 = new int [ ] { 10 , 10 , 10 , 10 } ; p3 = 31 ; p4 = 0.3548387096774194D ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 100 } ; p1 = new int [ ] { 100 } ; p2 = new int [ ] { 1 } ; p3 = 10 ; p4 = 1.0D ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 1000000000 } ; p1 = new int [ ] { 1000000000 } ; p2 = new int [ ] { 1000000000 } ; p3 = 1000000000 ; p4 = 0.41421356237309503D ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 20 , - 20 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 20 , - 20 } ; p2 = new int [ ] { 50 , 50 , 50 , 50 } ; p3 = 100 ; p4 = 0.3D ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 , - 60 , - 62 , - 60 , 63 , - 97 } ; p1 = new int [ ] { - 72 , 67 , 61 , - 8 , - 32 , 89 } ; p2 = new int [ ] { 6 , 7 , 8 , 7 , 5 , 6 } ; p3 = 918 ; p4 = 0.9407071068962471D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 187730043 , 932334096 , 59236807 , - 602044448 , 441157147 , 569003535 , 563472630 , 493784941 , - 928345136 , - 198534684 , - 507361726 , - 486699261 , - 705601684 , - 671249417 , - 79879427 , 71698248 , 146683444 , 414416326 , 53196305 , - 666818573 , 178619454 , - 893182413 , 224302710 , 296990194 , - 885921154 , - 173521881 , - 493092068 , 900325848 , - 353242967 , - 631482448 , 112982750 , 553248219 , 264762102 , - 318102799 , - 836641673 , - 812311860 , - 73259832 , 609869565 , 650010687 , 155243096 , - 107417345 , 634247427 , - 841502473 , - 651719520 , - 958664893 , 480384188 , - 691415372 , 36346544 , 706329659 , 126652235 , 44403422 , - 263265167 , - 349491074 , 120258505 , 485027199 , - 240466308 , - 456782932 , 192953958 , - 261803363 , - 198063552 , 980391799 , 997148607 , 417112854 , - 333017353 , - 945493557 , 371446553 , 251150037 , - 960076588 , - 360362805 , - 305175580 , 208353048 , - 437834549 , - 420355623 , - 668454094 , 180494692 , 755143595 , 249998094 , 537726369 , 343336414 , 495586169 , 35446018 , 131243302 , 501744441 , 739753520 , - 876687692 , 560013605 , - 443087342 , 455209428 , 333669368 , 398118304 , - 695213876 , 527566904 , - 463103162 , - 317355625 , 641069703 , - 947785900 , - 532490870 , - 963111776 , - 727898154 , 748858912 } ; p1 = new int [ ] { 452827103 , 247175647 , 11753377 , - 611873763 , - 531081305 , 859586805 , - 868286674 , - 876539858 , 304963335 , 990345765 , - 859353631 , - 475065113 , - 574709927 , 131112520 , - 846074893 , 464742988 , - 41360301 , 899849149 , - 266820064 , - 251052777 , 226747686 , 876712903 , - 350309643 , 131456902 , - 799664596 , 453822371 , - 617483392 , 755895436 , - 72097080 , 199834107 , - 619495741 , - 922106677 , 229012084 , 419002428 , 38711443 , 293733516 , 633211140 , - 65526196 , - 776215532 , - 491310115 , - 23818472 , 792447417 , 726536324 , - 686011537 , - 140383515 , - 569321731 , - 402939093 , - 125768005 , - 18416939 , 127783325 , - 67341991 , - 322587512 , - 296995968 , - 536590267 , 437613161 , - 206640690 , - 825549222 , 102733497 , - 399947312 , 55751657 , 527107031 , - 152726436 , - 821534503 , 267030010 , - 528297582 , - 897079824 , - 521362885 , 1225411 , 460297398 , 596603062 , - 270748768 , 211858545 , - 654848212 , - 353416243 , 955853430 , - 447642704 , 739273996 , - 118039293 , 583896289 , - 253276293 , 632398992 , 560349797 , 222539806 , 677153439 , - 804423594 , - 285780470 , 782032960 , 23986706 , - 812231058 , 344193048 , 491603558 , 956077657 , - 97237599 , - 644202406 , - 311702606 , 645844112 , 47834815 , - 802896183 , 472801824 , 658244534 } ; p2 = new int [ ] { 4 , 7 , 4 , 4 , 5 , 1 , 8 , 4 , 5 , 7 , 8 , 3 , 5 , 5 , 9 , 5 , 8 , 5 , 6 , 7 , 7 , 8 , 10 , 6 , 10 , 6 , 3 , 4 , 5 , 1 , 5 , 8 , 9 , 8 , 2 , 3 , 1 , 9 , 8 , 5 , 8 , 6 , 9 , 2 , 2 , 9 , 9 , 2 , 6 , 4 , 8 , 2 , 4 , 9 , 7 , 5 , 5 , 2 , 1 , 9 , 2 , 5 , 6 , 10 , 4 , 9 , 4 , 4 , 10 , 1 , 10 , 9 , 8 , 10 , 2 , 2 , 9 , 10 , 3 , 4 , 6 , 10 , 5 , 1 , 9 , 3 , 5 , 5 , 4 , 5 , 5 , 5 , 1 , 10 , 6 , 7 , 1 , 1 , 10 , 2 } ; p3 = 1000000000 ; p4 = 0.999999094D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 196 , 450 , 79 , - 220 , - 916 , 991 , - 451 , 462 , - 58 , - 353 , - 500 , 783 , 816 , 511 } ; p1 = new int [ ] { 188 , 681 , - 234 , - 330 , - 14 , 991 , - 969 , 347 , - 458 , - 940 , 454 , - 28 , 767 , - 620 } ; p2 = new int [ ] { 64 , 31 , 60 , 49 , 65 , 100 , 1 , 98 , 33 , 66 , 52 , 45 , 69 , 2 } ; p3 = 1484 ; p4 = 0.22007657635156566D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
te	7	private String [ ] getStringArray ( JComponent comp ) { if ( comp instanceof JComboBox ) { JComboBox comboBox = ( JComboBox ) comp ; List < String > list = new ArrayList < String > ( ) ; if ( comboBox . getItemCount ( ) > 0 ) { for ( int i = 0 ; i < comboBox . getItemCount ( ) ; i ++ ) { if ( ! isEmpty ( comboBox . getItemAt ( i ) ) ) { add ( list , comboBox . getItemAt ( i ) ) ; } else if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toArray ( new String [ 1 ] ) ; } else { return null ; } } else { if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; return list . toArray ( new String [ 1 ] ) ; } } } return null ; }
te	7	@ Override public LinkedList < Individual > crossover ( int [ ] parents , Population pop ) { LinkedList < Individual > children = new LinkedList < Individual > ( ) ; Random r = new Random ( ) ; int r1 = r . nextInt ( parents . length ) ; int r2 = r . nextInt ( parents . length ) ; Individual p1 = pop . people [ parents [ r1 ] ] ; Individual p2 = pop . people [ parents [ r2 ] ] ; int dna1 [ ] [ ] = new int [ 9 ] [ 9 ] ; int dna2 [ ] [ ] = new int [ 9 ] [ 9 ] ; Sudoku parent1 = ( ( Sudoku ) p1 ) ; Sudoku parent2 = ( ( Sudoku ) p2 ) ; for ( int row = 0 ; row < 9 ; row ++ ) { int cut1 = r . nextInt ( 9 ) ; int cut2 = r . nextInt ( 9 ) ; if ( cut2 < cut1 ) { int temp = cut1 ; cut1 = cut2 ; cut2 = temp ; } for ( int col = 0 ; col < 9 ; col ++ ) { if ( col <= cut1 || col >= cut2 ) { dna1 [ row ] [ col ] = parent2 . rows [ row ] [ col ] ; dna2 [ row ] [ col ] = parent1 . rows [ row ] [ col ] ; } else { int a = parent1 . rows [ row ] [ col ] ; if ( ! contains ( a , dna2 [ row ] ) ) dna2 [ row ] [ col ] = a ; int b = parent2 . rows [ row ] [ col ] ; if ( ! contains ( b , dna1 [ row ] ) ) dna1 [ row ] [ col ] = b ; } } } children . add ( new Sudoku ( dna1 ) ) ; children . add ( new Sudoku ( dna2 ) ) ; return children ; }
te	7	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
te	1	protected String [ ] getFontStyleNames ( ) { if ( fontStyleNames == null ) { int i = 0 ; fontStyleNames = new String [ 4 ] ; fontStyleNames [ i ++ ] = ( "Plain" ) ; fontStyleNames [ i ++ ] = ( "Bold" ) ; fontStyleNames [ i ++ ] = ( "Italic" ) ; fontStyleNames [ i ++ ] = ( "BoldItalic" ) ; } return fontStyleNames ; }
te	3	private void initWindow ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . PAGE_AXIS ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; tabbedPanel = new JTabbedPane ( ) ; tabbedPanel . setPreferredSize ( new Dimension ( 500 , 800 ) ) ; connectionTabPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel . setLayout ( new BoxLayout ( userSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; userSettingsPanel . setBorder ( new TitledBorder ( "User Settings" ) ) ; userSettingsV1Panel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; usernameLabel = new JLabel ( "Username:" ) ; usernameText = new JTextField ( UserPreferences . PREF_USERNAME , 6 ) ; apiSecretLabel = new JLabel ( "API Secret:" ) ; apiSecretText = new JPasswordField ( UserPreferences . PREF_API_SECRET , 6 ) ; passwordLabel = new JLabel ( "Password:" ) ; passwordText = new JPasswordField ( UserPreferences . PREF_PASSWORD , 6 ) ; userSettingsV1Panel . add ( usernameLabel ) ; userSettingsV1Panel . add ( usernameText ) ; userSettingsV1Panel . add ( apiSecretLabel ) ; userSettingsV1Panel . add ( apiSecretText ) ; userSettingsV1Panel . add ( passwordLabel ) ; userSettingsV1Panel . add ( passwordText ) ; userTokenPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userTokenPanel . setPreferredSize ( new Dimension ( 443 , 40 ) ) ; userTokenLabel = new JLabel ( "Token:" ) ; userTokenText = new JTextField ( UserPreferences . PREF_USERTOKEN , 10 ) ; userTokenButton = new JButton ( "Get your token" ) ; userTokenButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { GetToken . browse ( ) ; } } ) ; userTokenPanel . add ( userTokenLabel ) ; userTokenPanel . add ( userTokenText ) ; userTokenPanel . add ( userTokenButton ) ; userSettingsPanel . add ( userTokenPanel ) ; proxySettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; proxyUseCheck = new JCheckBox ( "Use Proxy" , UserPreferences . PREF_USE_PROXY ) ; proxyUseCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( proxyUseCheck . isSelected ( ) ) { proxyAddressText . setEnabled ( true ) ; proxyPortText . setEnabled ( true ) ; } else { proxyAddressText . setEnabled ( false ) ; proxyPortText . setEnabled ( false ) ; } } } ) ; proxySettingsPanel . setBorder ( new TitledBorder ( "Proxy Settings" ) ) ; proxyAddressLabel = new JLabel ( "Proxy:" ) ; proxyAddressText = new JTextField ( UserPreferences . PREF_PROXY_ADDRESS , 15 ) ; proxyPortLabel = new JLabel ( "Port:" ) ; proxyPortText = new JTextField ( UserPreferences . PREF_PROXY_PORT , 3 ) ; proxySettingsPanel . add ( proxyUseCheck ) ; proxySettingsPanel . add ( proxyAddressLabel ) ; proxySettingsPanel . add ( proxyAddressText ) ; proxySettingsPanel . add ( proxyPortLabel ) ; proxySettingsPanel . add ( proxyPortText ) ; proxySettingsPanel . setPreferredSize ( new Dimension ( 455 , 60 ) ) ; serverSettingsPanel = new JPanel ( ) ; serverSettingsPanel . setLayout ( new BoxLayout ( serverSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; serverSettingsPanel . setBorder ( new TitledBorder ( "Server Settings" ) ) ; serverCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverCheckIntervalLabel = new JLabel ( "Server check interval (sec):" ) ; serverCheckIntervalText = new JTextField ( String . valueOf ( UserPreferences . PREF_SERVER_CHECK_INTERVAL ) , 3 ) ; autoCleanCheck = new JCheckBox ( "Delete empty folders (keeps account clean)" , UserPreferences . PREF_AUTO_CLEAN ) ; serverCheckPanel . add ( serverCheckIntervalLabel ) ; serverCheckPanel . add ( serverCheckIntervalText ) ; serverCheckPanel . add ( autoCleanCheck ) ; serverSortByPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverSortByLabel = new JLabel ( "Sort by default:" ) ; serverSortByCombo = new JComboBox < String > ( new String [ ] { "Name" , "Date" } ) ; serverSortByCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_SORT_BY ) ; serverSortByPanel . add ( serverSortByLabel ) ; serverSortByPanel . add ( serverSortByCombo ) ; serverFriendPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; loadSharedCheck = new JCheckBox ( "Load friends' files (this could take some time to load)" , UserPreferences . PREF_LOAD_SHARED ) ; serverFriendPanel . add ( loadSharedCheck ) ; serverSettingsPanel . add ( serverCheckPanel ) ; serverSettingsPanel . add ( serverSortByPanel ) ; serverSettingsPanel . add ( serverFriendPanel ) ; serverSettingsPanel . setPreferredSize ( new Dimension ( 455 , 120 ) ) ; connectionTabPanel . add ( userSettingsPanel ) ; connectionTabPanel . add ( proxySettingsPanel ) ; connectionTabPanel . add ( serverSettingsPanel ) ; tabbedPanel . addTab ( "Connection" , null , connectionTabPanel ) ; startupSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoConnectCheck = new JCheckBox ( "Connect on start automatically" , UserPreferences . PREF_AUTO_CONNECT ) ; startInTrayCheck = new JCheckBox ( "Start in system tray" , UserPreferences . PREF_START_IN_TRAY ) ; startupSettingsPanel . setBorder ( new TitledBorder ( "Startup Settings" ) ) ; startupSettingsPanel . add ( autoConnectCheck ) ; startupSettingsPanel . add ( startInTrayCheck ) ; tabbedPanel . addTab ( "Startup" , null , startupSettingsPanel ) ; downloadSettingsPanel = new JPanel ( ) ; downloadSettingsPanel . setLayout ( new BoxLayout ( downloadSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; downloadSettingsPanel . setBorder ( new TitledBorder ( "Download Settings" ) ) ; autoDownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoDownloadCheck = new JCheckBox ( "Download on connect" , UserPreferences . PREF_AUTO_DOWNLOAD ) ; autoDownloadPanel . add ( autoDownloadCheck ) ; downloadTargetPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadTargetLabel = new JLabel ( "Target:" ) ; downloadTargetText = new JTextField ( UserPreferences . PREF_DOWNLOAD_TARGET , 20 ) ; downloadTargetText . setEditable ( false ) ; fileChooserButton = new JButton ( "Browse" ) ; fileChooserButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( fileChooser . showOpenDialog ( preferencesScreen ) == JFileChooser . APPROVE_OPTION ) { downloadTargetText . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; fileChooser = new JFileChooser ( downloadTargetText . getText ( ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileChooser . setDialogTitle ( "Select download directory" ) ; fileChooser . setAcceptAllFileFilterUsed ( false ) ; downloadTargetPanel . add ( downloadTargetLabel ) ; downloadTargetPanel . add ( downloadTargetText ) ; downloadTargetPanel . add ( fileChooserButton ) ; downloadWhatPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadWhatLabel = new JLabel ( "Download:" ) ; everythingRadio = new JRadioButton ( "everything" ) ; selFoldersRadio = new JRadioButton ( "selected folders" ) ; selFoldersRadio . setToolTipText ( "Right clic folder -> Add to automatic download" ) ; downloadWhatGroup = new ButtonGroup ( ) ; downloadWhatGroup . add ( everythingRadio ) ; downloadWhatGroup . add ( selFoldersRadio ) ; downloadWhatPanel . add ( downloadWhatLabel ) ; downloadWhatPanel . add ( everythingRadio ) ; downloadWhatPanel . add ( selFoldersRadio ) ; downloadPartsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; maxParallelDownloadsLabel = new JLabel ( "Max parallel downloads:" ) ; maxParallelDownloadsText = new JTextField ( String . valueOf ( UserPreferences . PREF_MAX_DOWNLOADS ) , 2 ) ; downloadPartsLabel = new JLabel ( "Parts for each download:" ) ; downloadPartsText = new JTextField ( String . valueOf ( UserPreferences . PREF_DOWNLOAD_PART_COUNT ) , 2 ) ; downloadPartsPanel . add ( maxParallelDownloadsLabel ) ; downloadPartsPanel . add ( maxParallelDownloadsText ) ; downloadPartsPanel . add ( downloadPartsLabel ) ; downloadPartsPanel . add ( downloadPartsText ) ; fileSizeCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; fileSizeCheckCheck = new JCheckBox ( "Skip download if size of the file is smaller than (MB):" , UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeCheckCheck . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeDeleteCheck . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; } } ) ; fileSizeCheckText = new JTextField ( String . valueOf ( UserPreferences . PREF_FILE_SIZE_FOR_CHECK ) , 4 ) ; fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeCheckPanel . add ( fileSizeCheckCheck ) ; fileSizeCheckPanel . add ( fileSizeCheckText ) ; fileSizeDeletePanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; fileSizeDeleteCheck = new JCheckBox ( "Also delete it from server automatically" , UserPreferences . PREF_FILE_SIZE_DELETE ) ; fileSizeDeleteCheck . setEnabled ( UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeDeletePanel . add ( fileSizeDeleteCheck ) ; downloadSettingsPanel . add ( autoDownloadPanel ) ; downloadSettingsPanel . add ( downloadTargetPanel ) ; downloadSettingsPanel . add ( downloadWhatPanel ) ; downloadSettingsPanel . add ( downloadPartsPanel ) ; downloadSettingsPanel . add ( fileSizeCheckPanel ) ; downloadSettingsPanel . add ( fileSizeDeletePanel ) ; tabbedPanel . addTab ( "Download" , null , downloadSettingsPanel ) ; conflictSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; conflictSettingsPanel . setBorder ( new TitledBorder ( "Conflict Settings" ) ) ; redownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; redownloadCheck = new JCheckBox ( "Do not ask if file already downloaded. Apply following: " , UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { redownloadCombo . setEnabled ( redownloadCheck . isSelected ( ) ) ; } } ) ; redownloadCombo = new JComboBox < String > ( new String [ ] { "Download again" , "Skip" , "Skip and delete" } ) ; redownloadCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_DOWNLOAD_AGAIN ) ; redownloadCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadPanel . add ( redownloadCheck ) ; redownloadPanel . add ( redownloadCombo ) ; overwritePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCheck = new JCheckBox ( "Do not ask if file already exits on disc. Apply following: " , UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwriteCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { overwriteCombo . setEnabled ( overwriteCheck . isSelected ( ) ) ; } } ) ; overwriteComboPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCombo = new JComboBox < String > ( new String [ ] { "Overwrite" , "Skip" , "Skip and delete from server" , "Skip in case of same size" , "Skip in case of same size and delete from server" } ) ; overwriteCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_OVERWRITE ) ; overwriteCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwritePanel . add ( overwriteCheck ) ; overwriteComboPanel . add ( overwriteCombo ) ; conflictSettingsPanel . add ( redownloadPanel ) ; conflictSettingsPanel . add ( overwritePanel ) ; conflictSettingsPanel . add ( overwriteComboPanel ) ; tabbedPanel . addTab ( "Conflict" , null , conflictSettingsPanel ) ; buttonsPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; saveAndCloseButton = new JButton ( "Save & Close" ) ; saveAndCloseButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( saveSettings ( ) ) { preferencesScreen . setVisible ( false ) ; } } } ) ; closeButton = new JButton ( "Close" ) ; closeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { preferencesScreen . setVisible ( false ) ; } } ) ; buttonsPanel . add ( saveAndCloseButton ) ; buttonsPanel . add ( closeButton ) ; contentPanel . add ( tabbedPanel ) ; contentPanel . add ( buttonsPanel ) ; this . getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; this . setTitle ( "Preferences" ) ; this . setSize ( new Dimension ( 490 , 370 ) ) ; this . setResizable ( false ) ; }
te	9X	public final ExpressaoContext expressao ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; ExpressaoContext _localctx = new ExpressaoContext ( _ctx , _parentState , _p ) ; ExpressaoContext _prevctx = _localctx ; int _startState = 6 ; enterRecursionRule ( _localctx , RULE_expressao ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 54 ) ; switch ( _input . LA ( 1 ) ) { case int : { _localctx = new InteiroContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 47 ) ; match ( int ) ; } break ; case 16 : { _localctx = new LeiaContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 48 ) ; match ( 16 ) ; } break ; case ID : { _localctx = new IdContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 49 ) ; match ( ID ) ; } break ; case 10 : { _localctx = new ExpParContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 50 ) ; match ( 10 ) ; setState ( 51 ) ; expressao ( 0 ) ; setState ( 52 ) ; match ( 2 ) ; } break ; default : throw new NoViableAltException ( this ) ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 67 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 65 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 3 , _ctx ) ) { case 1 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 56 ) ; if ( ! ( 4 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "4 >= $_p" ) ; setState ( 57 ) ; match ( 7 ) ; setState ( 58 ) ; expressao ( 5 ) ; } break ; case 2 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 59 ) ; if ( ! ( 3 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "3 >= $_p" ) ; setState ( 60 ) ; match ( 6 ) ; setState ( 61 ) ; expressao ( 4 ) ; } break ; case 3 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 62 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 63 ) ; match ( 8 ) ; setState ( 64 ) ; expressao ( 3 ) ; } break ; } } } setState ( 69 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
te	9X	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
te	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
te	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
te	7	public void killHappenedAt ( PointI p , int mobSize , boolean wasSplashDamage ) { if ( ( p . x < 0 ) || ( p . y < 0 ) || ( p . x >= w ) || ( p . y >= h ) ) return ; double amount = 1f / mobSize / mobSize ; for ( int y = 0 ; y < mobSize ; y ++ ) { for ( int x = 0 ; x < mobSize ; x ++ ) { if ( wasSplashDamage ) { splashKillCounts [ p . y + y ] [ p . x + x ] += amount ; } else { normalKillCounts [ p . y + y ] [ p . x + x ] += amount ; } } } }
te	2	public TestClient ( int port , String name ) { try { count ++ ; socket = new Socket ( InetAddress . getLocalHost ( ) , port ) ; this . name = name ; this . setName ( "TestClientThread-" + count ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	4	@ Override protected void imprimirTabuleiro ( TabuleiroXadrez tabuleiro ) { imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; for ( int linha = 8 ; linha >= 1 ; linha -- ) { imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimir ( linha + " " ) ; for ( int coluna = 1 ; coluna <= 8 ; coluna ++ ) { imprimir ( "|" ) ; Peca peca = tabuleiro . espiarPeca ( new Posicao ( coluna , linha ) ) ; imprimir ( PecaToString ( peca ) ) ; if ( peca == null ) imprimir ( "       " ) ; else if ( peca . getCorJogador ( ) == TipoCorJogador . BRANCO ) imprimir ( " branco" ) ; else imprimir ( " preto " ) ; } imprimirLinha ( "| " + linha ) ; } imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; }
te	8	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
te	9X	public static void arraycopy ( final float [ ] src , final int srcPos , final FloatLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setFloat ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } } }
te	5	@ Override public void draw ( SpriteBatch batch ) { if ( object . isVisible ( ) ) { graphics . draw ( batch ) ; } if ( animate ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = explosionAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - 1f ) , ( animPos . y - 1f ) , 2 , 2 ) ; if ( explosionAnimation . isAnimationFinished ( stateTime ) ) { animate = false ; WorldObject . removelist . add ( object ) ; } } else if ( animateMiss ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = splashAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - .5f ) , ( animPos . y - .5f ) , 1 , 1 ) ; if ( splashAnimation . isAnimationFinished ( stateTime ) ) { animateMiss = false ; WorldObject . removelist . add ( object ) ; } } }
te	4	@ Override public boolean getPoint ( int mouseX , int mouseY ) { int newX = - 1 ; int newY = - 1 ; if ( mouseX < 800 ) { int cx = Boot . getPlayer ( ) . getX ( ) ; int cy = Boot . getPlayer ( ) . getY ( ) ; newX = cx + ( mouseX / Standards . TILE_SIZE ) - 12 ; newY = cy + ( ( Standards . W_HEIGHT - mouseY ) / Standards . TILE_SIZE ) - 12 ; } if ( newX != - 1 && newY != - 1 ) { if ( picks == 0 ) { this . posX = newX ; this . posY = newY ; picks = 1 ; } else { this . posX2 = newX ; this . posY2 = newY ; picks = 0 ; } } return true ; }
te	4	public void run ( ) { useful = true ; UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . pushScreen ( popup ) ; } } ) ; int iterations = 0 ; while ( useful ) { try { Thread . sleep ( timeout ) ; } catch ( Exception e ) { } if ( ++ iterations > maximum ) iterations = 1 ; gaugeField . setValue ( iterations ) ; } if ( popup . isDisplayed ( ) ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . popScreen ( popup ) ; } } ) ; } }
te	1	public void print ( TreeNode root ) { if ( root == null ) { System . out . print ( " # " ) ; return ; } else { System . out . print ( " " + root . val + " " ) ; } print ( root . left ) ; print ( root . right ) ; }
te	4	protected EncodedString decodeEncodedCharacterStringOnThirdbit ( ) throws IOException , FastInfosetException { switch ( current_octet & FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_MASK_DISCRIMINANT ) { case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF8_DISCRIMINANT : encodedStringBuffer . setUTF8 ( decodeUTF8inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF16_DISCRIMINANT : encodedStringBuffer . setUTF16 ( decodeUTF16inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALGORITHM_DISCRIMINANT : int index = decodeOctetInteger ( 5 ) ; Algorithm algo = vocabulary . algorithms . get ( index ) ; encodedStringBuffer . setAlgorithm ( index , algo , decodeNonEmptyOctetStringOnFifthBit ( ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALPHABET_DISCRIMINANT : int index2 = decodeOctetInteger ( 5 ) ; Algorithm algo2 = vocabulary . alphabets . get ( index2 ) ; encodedStringBuffer . setAlphabet ( index2 , algo2 , algo2 . fromByteArray ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; } throw new FastInfosetException ( ) ; }
te	9X	public void DesativaCampos ( ) { for ( Component c : tela . getjPFicha ( ) . getComponents ( ) ) { if ( c instanceof JComboBox ) { ( ( JComboBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JCheckBox ) { ( ( JCheckBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JTextField ) { ( ( JTextField ) c ) . setEnabled ( false ) ; } if ( c instanceof JDateChooser ) { ( ( JDateChooser ) c ) . setEnabled ( false ) ; } if ( c instanceof JScrollPane ) { for ( Component co : ( ( JScrollPane ) c ) . getComponents ( ) ) { if ( co instanceof JViewport ) { for ( Component com : ( ( JViewport ) co ) . getComponents ( ) ) { if ( com instanceof JTextArea ) { ( ( JTextArea ) com ) . setEnabled ( false ) ; } } } } } } }
te	4	public void testLineSeriesChart ( ) { LineSeriesChart < Number , Number > chart = new LineSeriesChart < Number , Number > ( "Curves" , "X" , "Y" ) ; Collection < LineSeriesItem < Number , Number >> linhaSin = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaSin . add ( new LineSeriesItem < Number , Number > ( i , Math . sin ( i ) + 4 ) ) ; } chart . addValue ( linhaSin ) ; Collection < LineSeriesItem < Number , Number >> linhaCos = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaCos . add ( new LineSeriesItem < Number , Number > ( i , Math . cos ( i ) ) ) ; } chart . addValue ( linhaCos ) ; Collection < LineSeriesItem < Number , Number >> linhaExp = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaExp . add ( new LineSeriesItem < Number , Number > ( i , Math . exp ( i ) + 1 ) ) ; } chart . addValue ( linhaExp ) ; Collection < LineSeriesItem < Number , Number >> linhaReta = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaReta . add ( new LineSeriesItem < Number , Number > ( i , i ) ) ; } chart . addValue ( linhaReta ) ; Highlighter highlighter = criarHighlighter ( ) ; chart . getChartConfiguration ( ) . setHighlighter ( highlighter ) ; chart . addSerie ( criarSerie ( "Seno" , "#489104" ) ) ; chart . addSerie ( criarSerie ( "Coseno" , "#c91212" ) ) ; chart . addSerie ( criarSerie ( "Exponensial" , "#7D02B2" ) ) ; chart . addSerie ( criarSerie ( "Reta" , "#066FA7" ) ) ; Legend legend = new Legend ( true , Location . ne ) ; legend . setPlacement ( "outsideGrid" ) ; chart . setLegend ( legend ) ; Axis < String > axis = new AxisString ( ) ; axis . setLabelRenderer ( JqPlotResources . CanvasAxisLabelRenderer ) ; chart . setAxesDefaults ( axis ) ; Axes axes = chart . getAxes ( ) ; XAxis xaxis = axes . getXaxis ( ) ; TickOptions tickOptions = new TickOptions ( ) ; tickOptions . setAngle ( 270 ) ; tickOptions . setLabelPosition ( "end" ) ; xaxis . setTickOptions ( tickOptions ) ; xaxis . setTickRenderer ( JqPlotResources . CanvasAxisTickRenderer ) ; xaxis . setTickInterval ( 1 ) ; axes . getYaxis ( ) . setTickInterval ( 0.50 ) ; axes . getYaxis ( ) . setMax ( 8.50 ) ; axes . getYaxis ( ) . setMin ( - 1.50 ) ; TickOptions tickOptionsY = new TickOptions ( ) ; tickOptionsY . setFormatString ( "%.2f" ) ; axes . getYaxis ( ) . setTickOptions ( tickOptionsY ) ; Grid grid = new Grid ( ) ; grid . setBackground ( "#ffffff" ) ; grid . setGridLineColer ( "#a0a0a0" ) ; chart . getChartConfiguration ( ) . setGrid ( grid ) ; Cursor cursor = new Cursor ( ) ; cursor . setZoom ( true ) ; cursor . setClickReset ( true ) ; chart . getChartConfiguration ( ) . setCursor ( cursor ) ; String json = JqPlotUtils . createJquery ( chart , "div3" ) ; json = json . replaceAll ( "\\$" , "jQuery" ) ; System . out . println ( json ) ; }
te	3	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( i == DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i == DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
te	3	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
te	4	public static void run ( class < ? extends Window > clazz , class < ? > [ ] args , Object [ ] param ) { try { executeInstance ( ( Window ) clazz . getConstructor ( args ) . newInstance ( param ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	9X	public static AbstractUIItem createItem ( FeatureType t , Panel panel ) { switch ( t ) { case Constant : return new ConstantUIItem ( panel ) ; case Sink : return new SinkUIItem ( panel ) ; case Source : return new SourceUIItem ( panel ) ; case Saddle : return new SaddleUIItem ( panel ) ; case Center : return new CenterUIItem ( panel ) ; case Focus : return new FocusUIItem ( panel ) ; case ConvergingElement : return new ConvergingElementUIItem ( panel ) ; case DivergingElement : return new DivergingElementUIItem ( panel ) ; case Generic : return new GenericUIItem ( panel ) ; } assert false : "Unhandled type: " + t ; return null ; }
te	0	public int getPeopleOnStation ( ) { return peopleOnStation ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Consulta_datos ( ) . setVisible ( true ) ; } } ) ; }
te	6	public String getRecords ( ) { StringBuilder resultado = new StringBuilder ( ) ; if ( tipo != null ) { Declaracion tmp = tipo ; TipoDeclaracion tdecl = null ; TipoRecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof TipoDeclaracion ) { resultado . append ( ".namespace Ejemplo{\n" ) ; tdecl = ( ( TipoDeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getNombre ( ) ) ; resultado . append ( " extends [mscorlib]System.ValueType{\n" ) ; Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tdecl . getNombre ( ) ) ; TipoRecord record = ( ( TipoRecord ) t ) ; Collections . reverse ( record . tbsimbolo . lista ) ; Collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoRecord ) { trec1 = ( ( TipoRecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype Ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoArray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . toString ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getSiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . toString ( ) ; }
te	5	public void update ( final World w ) { for ( short x = 0 ; x < sideLength ; x ++ ) { for ( short y = 0 ; y < sideLength ; y ++ ) { short tileX = ( short ) ( x + ( coords . getX ( ) * sideLength ) ) ; short tileY = ( short ) ( y + ( coords . getY ( ) * sideLength ) ) ; final Tile t = getTile ( x , y ) ; if ( ( t == Tiles . air ) || ( t == null ) ) { new Packet03Tile ( t , tileX , tileY ) . writeDataToServer ( ) ; } if ( t . doesTick ( ) ) { t . update ( w , tileX , tileY ) ; } } } }
te	8	@ Override public boolean equals ( Object cidades ) { if ( cidades == null ) { return false ; } if ( getClass ( ) != cidades . getClass ( ) ) { return false ; } final Cidades other = ( Cidades ) cidades ; if ( ( this . nome == null ) ? ( other . nome != null ) : ! this . nome . equals ( other . nome ) ) { return false ; } if ( ( this . uf == null ) ? ( other . uf != null ) : ! this . uf . equals ( other . uf ) ) { return false ; } if ( ( this . ddd == null ) ? ( other . ddd != null ) : ! this . ddd . equals ( other . ddd ) ) { return false ; } return true ; }
te	7	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Radical > radicals = new ArrayList < Radical > ( ) ; for ( int i = 0 ; i <= SIZE ; i ++ ) radicals . add ( new Radical ( i , primeList ) ) ; radicals = sort ( radicals ) ; System . out . print ( radicals . get ( SIZE / 10 ) . num ) ; }
te	8	@ Override public void computePerformanceMeasures ( ) throws InternalErrorException { totalTimer . start ( ) ; BigRational [ ] X = new BigRational [ qnm . R ] ; BigRational [ ] [ ] Q = new BigRational [ qnm . M ] [ qnm . R ] ; if ( lastG [ 0 ] . isUndefined ( ) ) { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . M ; i ++ ) { for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) + i + 1 ] . isUndefined ( ) ) { Q [ i ] [ r ] = qnm . getDemandAsBigRational ( i , r ) . multiply ( lastG [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ i + 1 ] . isUndefined ( ) ) { Q [ i ] [ qnm . R - 1 ] = qnm . getDemandAsBigRational ( i , qnm . R - 1 ) . multiply ( prevG [ i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) ] . isUndefined ( ) ) { X [ r ] = lastG [ sz * ( r + 1 ) ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ 0 ] . isUndefined ( ) ) { X [ qnm . R - 1 ] = prevG [ 0 ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } totalTimer . pause ( ) ; qnm . setPerformanceMeasures ( Q , X ) ; }
te	7	private boolean placeRandomTeleportLocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new IllegalArgumentException ( "Invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new IllegalArgumentException ( "Invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new IllegalArgumentException ( "Invalid argument: the randomlocation array-holder is not of length 2" ) ; ArrayList < int [ ] > availableLocations = new ArrayList < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availableLocations . add ( new int [ ] { i , j } ) ; } } } if ( availableLocations . size ( ) == 0 ) { java . lang . System . out . println ( "Warning: You have a teleporter in a map with no spaces" ) ; return false ; } Random random = new Random ( ) ; random . setSeed ( java . lang . System . currentTimeMillis ( ) ) ; int index = random . nextInt ( availableLocations . size ( ) ) ; int [ ] chosen = availableLocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
te	3	@ Override public void tick ( Input input , double delta ) { if ( this . dummy . getCommands ( ) . isEmpty ( ) ) { double ran = Math . random ( ) ; if ( ran >= 0.5 ) { } else { this . dummy . wait ( Math . random ( ) * 0.4 ) ; } ran = Math . random ( ) ; if ( ran >= 0.2 ) { this . dummy . getCommands ( ) . add ( new JumpCommand ( this . dummy ) ) ; } } }
te	5	private void howMany ( int [ ] [ ] paper , int n1 , int n2 , int m1 , int m2 ) { if ( counter . contains ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ) return ; counter . add ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ; for ( int d = m1 ; d <= m2 - 1 ; d ++ ) { if ( foldsVertically ( paper , n1 , n2 , m1 , m2 , d ) ) { if ( d <= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , d + 1 , m2 ) ; } if ( d >= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , m1 , d ) ; } } } }
te	0	@ XmlElementDecl ( namespace = "" , name = "xRequest" ) public JAXBElement < BigInteger > createXRequest ( BigInteger value ) { return new JAXBElement < BigInteger > ( _XRequest_QNAME , BigInteger . class , null , value ) ; }
te	2	public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case GET_LANG : return isSetGetLang ( ) ; } throw new IllegalStateException ( ) ; }
te	0	public boolean isSchoolAnnouncements ( ) { return schoolAnnouncements ; }
te	6	@ Override public void run ( ) { if ( getLocation ( ) . distance ( bankerTile ) <= 10 ) { goHome ( ) ; } Time . sleep ( rand . nextInt ( 2000 ) ) ; if ( getLocation ( ) . equals ( new Tile ( 3262 , 3322 , 0 ) ) || getLocation ( ) . equals ( new Tile ( 3262 , 3323 , 0 ) ) ) { Walking . walk ( Field ) ; Time . sleep ( 5000 ) ; } SceneObject Gate = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 45206 ; } } ) ; if ( getLocation ( ) . distance ( Gate ) <= 5 ) { Gate . interact ( "Open" ) ; Time . sleep ( 3000 ) ; } if ( getLocation ( ) . distance ( Gate ) <= 5 && ! Gate . isOnScreen ( ) ) { Camera . turnTo ( Gate ) ; Time . sleep ( 3000 ) ; } }
te	3	public static String StrFill ( String fillStr , String oldStr , int length , String place ) { StringBuffer sb = new StringBuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldStr ) ; } for ( int i = 0 ; i < ( length - oldStr . length ( ) ) ; i ++ ) { sb . append ( fillStr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldStr ) ; } return sb . toString ( ) ; }
te	1	public void update ( M m , Connection conn ) { int result = update ( m , allFields ( ) , conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , getId ( m ) ) ; if ( result != 1 ) { throw new RuntimeException ( "Failed to update record into " + tableName + " table" ) ; } }
te	8	private void bfs ( State s ) { s . id = - 1 ; Loc f = map . finish ; int counter = 0 ; LinkedList < Node > frontier = new LinkedList < Node > ( ) ; Set < State > explored = new HashSet < State > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( s , null , 0 ) ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state , f ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } System . out . println ( "found goal!" ) ; System . out . println ( "moves: " + solution . size ( ) ) ; mSolutions . addAll ( solution ) ; return ; } explored . add ( current . state ) ; if ( counter % 5000 == 0 ) { System . out . print ( "\n" ) ; } ; if ( counter % 50 == 0 ) { System . out . print ( "." ) ; } ; ArrayList < State > possibles = getMovesCorrectlyPlease ( current . state ) ; for ( int i = 0 ; i < possibles . size ( ) ; i ++ ) { State possib = possibles . get ( i ) ; if ( ! explored . contains ( possib ) ) { frontier . addLast ( new Node ( possib , current , current . distance + 1 ) ) ; } } counter ++ ; } if ( solution . isEmpty ( ) ) { System . out . println ( "FAILED TO FIND SOLUTION" ) ; } }
te	1	public T getValue ( ) { if ( available == false ) { throw new RuntimeException ( "Value not available" ) ; } return value ; }
te	2	public synchronized void produce ( ) { try { if ( product != 0 ) { wait ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } product = 1 ; System . out . println ( "Producer produce : " + product ) ; notifyAll ( ) ; }
te	9X	private void parseSpriteSheets ( ) throws IOException , ExpectedTokenException , InvalidTokenException { String line ; line = reader . readLine ( ) ; if ( ! line . equals ( "SPRITESHEETS" ) ) { throw new ExpectedTokenException ( "SPRITESHEETS" , line ) ; } line = reader . readLine ( ) ; while ( line != null && ! line . equals ( "END SPRITESHEETS" ) ) { scanner = new Scanner ( line ) ; if ( ! scanner . hasNext ( ) ) { throw new ExpectedTokenException ( "<file>" , line ) ; } String file = scanner . next ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame width>" , line ) ; } int frameWidth = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame height>" , line ) ; } int frameHeight = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding x>" , line ) ; } int paddingX = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding y>" , line ) ; } int paddingY = scanner . nextInt ( ) ; SpriteSheet sheet = new SpriteSheet ( file , new Vec2i ( frameWidth , frameHeight ) , new Vec2i ( paddingX , paddingY ) ) ; sheets . put ( file , sheet ) ; line = reader . readLine ( ) ; } if ( line == null ) { throw new ExpectedTokenException ( "END SPRITESHEET" , line ) ; } }
te	8	public ArrayList < Point > checkMove2 ( Stack < TTTBoard > boards , char player ) { ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; ArrayList < TTTBoard > tempArray = new ArrayList < TTTBoard > ( ) ; while ( ! boards . isEmpty ( ) ) { TTTBoard aBoard = boards . pop ( ) ; ArrayList < Point > spots = aBoard . getEmptySpots ( ) ; char turn = getChar ( spots . size ( ) ) ; ArrayList < TTTBoard > tempArray2 = new ArrayList < TTTBoard > ( ) ; for ( int i = 0 ; i < spots . size ( ) ; i ++ ) { TTTBoard board = new TTTBoard ( aBoard ) ; board . getBoard ( ) [ spots . get ( i ) . x ] [ spots . get ( i ) . y ] = turn ; if ( spots . size ( ) < 6 ) { if ( board . checkWin ( ) ) { if ( turn == player ) { winningSpots . add ( board . getStart ( ) ) ; break ; } else { break ; } } else { tempArray2 . add ( board ) ; } } else { tempArray . add ( board ) ; } } if ( tempArray2 . size ( ) == spots . size ( ) ) { tempArray . addAll ( tempArray2 ) ; } } if ( winningSpots . isEmpty ( ) && tempArray . get ( 0 ) . getEmptySpots ( ) . size ( ) != 0 ) { boards . addAll ( tempArray ) ; winningSpots = checkMove2 ( boards , player ) ; } return winningSpots ; }
te	1	public void setCode ( CodeFragment code ) { if ( code == null ) code = new CodeFragment ( ) ; this . code = code ; }
te	8	private static Map < UnaryRule , List < String >> computeUnaryClosure ( Collection < UnaryRule > unaryRules ) { Map < UnaryRule , String > intermediateStates = new HashMap < UnaryRule , String > ( ) ; Counter < UnaryRule > pathCosts = new Counter < UnaryRule > ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByChild = new HashMap < String , List < UnaryRule >> ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByParent = new HashMap < String , List < UnaryRule >> ( ) ; Set < String > states = new HashSet < String > ( ) ; for ( UnaryRule unaryRule : unaryRules ) { relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , unaryRule , null , unaryRule . getScore ( ) ) ; states . add ( unaryRule . getParent ( ) ) ; states . add ( unaryRule . getChild ( ) ) ; } for ( String intermediateState : states ) { List < UnaryRule > incomingRules = closedUnaryRulesByChild . get ( intermediateState ) ; List < UnaryRule > outgoingRules = closedUnaryRulesByParent . get ( intermediateState ) ; if ( incomingRules == null || outgoingRules == null ) continue ; for ( UnaryRule incomingRule : incomingRules ) { for ( UnaryRule outgoingRule : outgoingRules ) { UnaryRule rule = new UnaryRule ( incomingRule . getParent ( ) , outgoingRule . getChild ( ) ) ; double newScore = pathCosts . getCount ( incomingRule ) * pathCosts . getCount ( outgoingRule ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , rule , intermediateState , newScore ) ; } } } for ( String state : states ) { UnaryRule selfLoopRule = new UnaryRule ( state , state ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , selfLoopRule , null , 1.0 ) ; } Map < UnaryRule , List < String >> closureMap = new HashMap < UnaryRule , List < String >> ( ) ; for ( UnaryRule unaryRule : pathCosts . keySet ( ) ) { unaryRule . setScore ( pathCosts . getCount ( unaryRule ) ) ; List < String > path = extractPath ( unaryRule , intermediateStates ) ; closureMap . put ( unaryRule , path ) ; } System . out . println ( "SIZE: " + closureMap . keySet ( ) . size ( ) ) ; return closureMap ; }
te	9X	public boolean connect ( SharingPeer peer ) { boolean retry = false ; boolean sentObfuscatedHandshake = false ; do { Socket socket = new Socket ( ) ; InetSocketAddress address = new InetSocketAddress ( peer . getIp ( ) , peer . getPort ( ) ) ; logger . info ( "Connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( IOException ioe ) { logger . warn ( "Could not connect to " + peer + ": " + ioe . getMessage ( ) ) ; return false ; } try { byte [ ] remotePeerId = ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ; if ( this . forceObfuscation ) sentObfuscatedHandshake = this . sendObfuscatedHandshake ( socket , remotePeerId , this . forceObfuscation ) ; else sentObfuscatedHandshake = this . sendHandshake ( socket , remotePeerId , peer . supportsObfuscation ( ) ) ; Handshake hs = this . validateHandshake ( socket , ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ) ; this . fireNewPeerConnection ( socket , hs . getPeerId ( ) ) ; return true ; } catch ( ParseException pe ) { logger . info ( "Invalid handshake from " + this . socketRepr ( socket ) + ": " + pe . getMessage ( ) ) ; if ( sentObfuscatedHandshake && peer . supportsObfuscation ( ) ) { peer . supportsObfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( IOException e ) { } } catch ( IOException ioe ) { logger . info ( "An error occured while reading an incoming " + "handshake: " + ioe . getMessage ( ) ) ; try { if ( ! socket . isClosed ( ) ) socket . close ( ) ; } catch ( IOException e ) { } } } while ( retry ) ; return false ; }
te	1	public void divide ( int ncol , int nrow ) { canvasPads . setSize ( this . getSize ( ) . width , this . getSize ( ) . height , ncol , nrow ) ; int ncharts = canvasPads . getNPads ( ) ; series . clear ( ) ; for ( int loop = 0 ; loop < ncharts ; loop ++ ) { ScGroupSeries chart = new ScGroupSeries ( new ScRegion ( canvasPads . getX ( loop ) , canvasPads . getY ( loop ) , canvasPads . getWidth ( loop ) , canvasPads . getHeight ( loop ) ) ) ; series . add ( chart ) ; } }
te	2	public void simulateOneStep ( ) { step ++ ; startSickness ( startKans ) ; List < Actor > newActors = new ArrayList < Actor > ( ) ; for ( Iterator < Actor > it = actors . iterator ( ) ; it . hasNext ( ) ; ) { Actor actor = it . next ( ) ; actor . act ( newActors ) ; if ( ! actor . isActive ( ) ) { it . remove ( ) ; } } actors . addAll ( newActors ) ; statusUpdate ( ) ; }
te	2	int clip ( int t , int lo , int hi ) { return t < lo ? lo : t > hi ? hi : t ; }
te	1	public static GTHome getHome ( ) { if ( home == null ) home = new GTHomeImpl ( ) ; return home ; }
te	1	public int step ( int state , char c ) { if ( classmap == null ) return transitions [ state * points . length + getCharClass ( c ) ] ; else return transitions [ state * points . length + classmap [ c - Character . MIN_VALUE ] ] ; }
te	7	public static String RegexExtraction ( String patternStr , String data ) { Pattern pattern ; if ( patternStr == null || patternStr . length ( ) == 0 || patternStr . isEmpty ( ) ) return null ; if ( RegexManager . getInstance ( ) . patternList . containsKey ( patternStr ) ) { pattern = RegexManager . getInstance ( ) . patternList . get ( patternStr ) ; } else { pattern = Pattern . compile ( patternStr ) ; RegexManager . getInstance ( ) . patternList . put ( patternStr , pattern ) ; } Matcher matcher = pattern . matcher ( data ) ; String res = "" ; if ( matcher . find ( ) ) { if ( patternStr . startsWith ( ParameterSetting . REGXWORDPATTERN_V2 ) ) { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ array . length - 1 ] . replace (   ,   ) . trim ( ) ; } else { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ 0 ] . replace (   ,   ) . trim ( ) ; } } if ( StopwordsFilter . getInstance ( ) . isStopWords ( res ) ) return null ; else return res ; }
te	8	protected static byte discoverPortal ( IShape shape1 , IShape shape2 ) { getOriginRayDirection ( shape1 , shape2 ) ; MinkowskiDifference . getMinSupport ( e1 , shape1 , shape2 , e0 . v ) ; if ( e1 . v . . ( e0 . v ) >= 0 ) return - 1 ; dir . setCross ( e0 . v , e1 . v ) ; if ( dir . isZero ( ) ) { return 2 ; } MinkowskiDifference . getMaxSupport ( e2 , shape1 , shape2 , dir ) ; if ( e2 . v . . ( dir ) <= 0 ) return - 1 ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; dir . setCross ( v1v0 , v2v0 ) ; if ( dir . . ( e0 . v ) > 0 ) { final Element e = e1 ; e1 = e2 ; e2 = e ; dir . invert ( ) ; Vector3f s = v1v0 ; v1v0 = v2v0 ; v2v0 = s ; } while ( true ) { MinkowskiDifference . getMaxSupport ( e3 , shape1 , shape2 , dir ) ; if ( e3 . v . . ( dir ) <= 0 ) return - 1 ; if ( temp . setCross ( e1 . v , e3 . v ) . . ( e0 . v ) < 0 ) { set ( e2 , e3 ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; } else if ( temp . setCross ( e3 . v , e2 . v ) . . ( e0 . v ) < 0 ) { set ( e1 , e3 ) ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; } else { return 0 ; } dir . setCross ( v1v0 , v2v0 ) ; } }
te	3	public static final Course readCourse ( File definitionFile ) { LOGGER . log ( Level . INFO , "Reading course from file '" + definitionFile + "'" ) ; JSONParser parser = new JSONParser ( ) ; JSONObject jsonObject = null ; try { jsonObject = ( JSONObject ) parser . parse ( new FileReader ( definitionFile ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( org . json . simple . parser . ParseException e ) { e . printStackTrace ( ) ; } Course course = new Course ( ( String ) jsonObject . get ( "name" ) , ( String ) jsonObject . get ( "address" ) , ( int ) ( ( long ) jsonObject . get ( "bestScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "averageScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "worstScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "timesPlayed" ) ) , new ArrayList < Hole > ( ) , ( String ) jsonObject . get ( "userWithBestScore" ) , ( String ) jsonObject . get ( "description" ) ) ; LOGGER . log ( Level . INFO , "Created course '" + course . getName ( ) + "'" ) ; return course ; }
te	3	public boolean equals ( Object obj ) { boolean returnMe = true ; if ( ! obj . getClass ( ) . equals ( this . getClass ( ) ) ) { returnMe = false ; } else { if ( docID != ( ( Pair ) obj ) . docID ) { returnMe = false ; } else { if ( score != ( ( Pair ) obj ) . score ) { returnMe = false ; } } } return returnMe ; }
te	9X	private void drawMenu ( ) { int i = menuOffsetX ; int j = menuOffsetY ; int k = menuWidth ; int l = menuHeight + 1 ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 706a5e , menuWidth , menuOffsetX ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 706a5e , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY , menuHeight , 200 , 706a5e , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 2d2822 , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 2d2822 , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 3 , menuHeight - 6 , 250 , 2d2822 , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY + 19 , menuHeight - 22 , 250 , 524a3d , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 20 , menuHeight - 22 , 250 , 524a3d , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 2a291b , menuOffsetY + 2 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a261b , menuOffsetY + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 252116 , menuOffsetY + 4 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 211e15 , menuOffsetY + 5 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1e1b12 , menuOffsetY + 6 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1a170e , menuOffsetY + 7 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 2 , 15120b , menuOffsetY + 8 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 100d08 , menuOffsetY + 10 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 11 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 080703 , menuOffsetY + 12 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 13 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 14 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 15 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 16 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 17 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a291b , menuOffsetY + 18 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 564943 , menuOffsetY + 19 ) ; chatTextDrawingArea . method385 ( c6b895 , "Choose Option" , menuOffsetY + 14 , menuOffsetX + 3 ) ; int j1 = super . mouseX ; int k1 = super . mouseY ; if ( menuScreenArea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuScreenArea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuScreenArea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuScreenArea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuActionRow ; l1 ++ ) { int i2 = j + 31 + ( menuActionRow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { DrawingArea . drawPixels ( 15 , i2 - 11 , i + 3 , 26566C , menuWidth - 6 ) ; j2 = eee5c6 ; } chatTextDrawingArea . method389 ( true , i + 4 , AAA184 , menuActionName [ l1 ] , i2 + 1 ) ; } }
te	6	public Settings ( JPanel content ) { JPanel theContent = new JPanel ( new GridLayout ( 12 , 1 , 0 , 5 ) ) ; auxButton . setFocusPainted ( false ) ; radButton . setFocusPainted ( false ) ; cdButton . setFocusPainted ( false ) ; climateLabel = new JLabel ( "Climate" ) ; climateLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; climateControl . setMinorTickSpacing ( 1 ) ; Hashtable labelTable = new Hashtable ( ) ; labelTable . put ( new Integer ( 0 ) , new JLabel ( "Cold" ) ) ; labelTable . put ( new Integer ( CLIMATE_MAX ) , new JLabel ( "Hot" ) ) ; climateControl . setLabelTable ( labelTable ) ; climateControl . setPaintLabels ( true ) ; ventLabel = new JLabel ( "Ventilation Fan" ) ; ventLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; ventButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { ventButton . setText ( "On" ) ; ventButton . setBackground ( Color . decode ( "#92CD00" ) ) ; } else { ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; } } } ) ; soundLabel = new JLabel ( "Sound" ) ; soundLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; radioLabel = new JLabel ( "Volume" ) ; radioLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; frequency . setText ( "107.10" ) ; musicCards . add ( radioCard , "Radio controller" ) ; musicCards . add ( cdCard , "CD controller" ) ; musicCards . add ( auxCard , "AUX controller" ) ; Hashtable volLabelTable = new Hashtable ( ) ; volLabelTable . put ( new Integer ( 0 ) , new JLabel ( "0" ) ) ; volLabelTable . put ( new Integer ( 10 ) , new JLabel ( "1" ) ) ; volLabelTable . put ( new Integer ( 20 ) , new JLabel ( "2" ) ) ; volLabelTable . put ( new Integer ( 30 ) , new JLabel ( "3" ) ) ; volLabelTable . put ( new Integer ( 40 ) , new JLabel ( "4" ) ) ; volLabelTable . put ( new Integer ( 50 ) , new JLabel ( "5" ) ) ; volLabelTable . put ( new Integer ( 60 ) , new JLabel ( "6" ) ) ; volLabelTable . put ( new Integer ( 70 ) , new JLabel ( "7" ) ) ; volLabelTable . put ( new Integer ( 80 ) , new JLabel ( "8" ) ) ; volLabelTable . put ( new Integer ( 90 ) , new JLabel ( "9" ) ) ; volLabelTable . put ( new Integer ( 100 ) , new JLabel ( "10" ) ) ; volLabelTable . put ( new Integer ( 110 ) , new JLabel ( "11" ) ) ; radVolControl . setLabelTable ( volLabelTable ) ; radVolControl . setPaintLabels ( true ) ; freqButton . setText ( "AM" ) ; freqButton . setFocusPainted ( false ) ; freqButton . setBackground ( Color . decode ( "#393939" ) ) ; freqButton . setForeground ( Color . decode ( "#FFFFFF" ) ) ; freqButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { freqButton . setText ( "FM" ) ; } else { freqButton . setText ( "AM" ) ; } } } ) ; radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; freqLabel = new JLabel ( "Frequency:" ) ; freqLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; JPanel musicButtons = new JPanel ( new GridLayout ( 1 , 3 ) ) ; radButton . setText ( "RADIO" ) ; radButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "Radio controller" ) ; } } ) ; musicButtons . add ( radButton ) ; auxButton . setText ( "AUX" ) ; auxButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { auxButton . setBackground ( Color . decode ( "#92CD00" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "AUX controller" ) ; } } ) ; musicButtons . add ( auxButton ) ; cdButton . setText ( "CD" ) ; cdButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "CD controller" ) ; } } ) ; musicButtons . add ( cdButton ) ; radioCard . add ( freqLabel ) ; radioCard . add ( frequency ) ; radioCard . add ( freqButton ) ; auxCard . add ( new JLabel ( "AUX Connected..." ) ) ; JPanel cdButtons = new JPanel ( new GridLayout ( 1 , 6 ) ) ; JButton playBtn = new JButton ( "Play" ) ; playBtn . setFocusPainted ( false ) ; playBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( playBtn ) ; JButton pauseBtn = new JButton ( "Pause" ) ; pauseBtn . setFocusPainted ( false ) ; pauseBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Paused" ) ; } } ) ; cdButtons . add ( pauseBtn ) ; JButton stopBtn = new JButton ( "Stop" ) ; stopBtn . setFocusPainted ( false ) ; stopBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Stopped" ) ; } } ) ; cdButtons . add ( stopBtn ) ; JButton prevBtn = new JButton ( "PREV" ) ; prevBtn . setFocusPainted ( false ) ; prevBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( prevBtn ) ; JButton nextBtn = new JButton ( "next" ) ; nextBtn . setFocusPainted ( false ) ; nextBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( nextBtn ) ; JButton eject = new JButton ( "Eject" ) ; eject . setFocusPainted ( false ) ; cdButtons . add ( eject ) ; cdCard . add ( cdButtons ) ; cdCard . add ( cdStatusLabel ) ; settings . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; theContent . add ( settings ) ; theContent . add ( climateLabel ) ; theContent . add ( climateControl ) ; theContent . add ( ventLabel ) ; theContent . add ( ventButton ) ; theContent . add ( soundLabel ) ; theContent . add ( radioLabel ) ; theContent . add ( radVolControl ) ; theContent . add ( musicButtons ) ; theContent . add ( musicCards ) ; add ( theContent ) ; }
te	9X	public void storePast ( PastData past ) { if ( past . zip . equalsIgnoreCase ( "denver co" ) ) past . zip = "80201" ; String prefix = past . zip + " " + timeFormat . format ( past . date ) + " " + past . today + " " + past . occurredDate ; if ( past . overallPast . high != null || past . overallPast . precip != null ) { String str = prefix ; str = str + " " ; if ( past . overallPast . high != null ) str = str + past . overallPast . high . toString ( ) ; str = str + " " ; if ( past . overallPast . precip != null ) str = str + past . overallPast . precip . toString ( ) ; str = str + " " ; DAout . println ( str ) ; } if ( past . hourlyPast . length != 0 ) { for ( int i = 0 ; i < past . hourlyPast . length ; i ++ ) { String str = prefix ; str = str + " " + past . hourlyPast [ i ] . hour ; str = str + " " ; if ( past . hourlyPast [ i ] . temp != null ) str = str + past . hourlyPast [ i ] . temp . toString ( ) ; str = str + " " ; if ( past . hourlyPast [ i ] . conditions != null ) str = str + past . hourlyPast [ i ] . conditions ; str = str + " " ; if ( past . hourlyPast [ i ] . precip != null ) str = str + past . hourlyPast [ i ] . precip . toString ( ) ; str = str + " " ; HAout . println ( str ) ; } } }
te	7	public static boolean searchAndAdd ( TrieNode root , TrieNode prev , char [ ] str , int index ) { if ( root == null ) { return false ; } if ( root . childLinks == null ) { insertNode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( TrieNode child : root . childLinks ) { if ( child . alphabet == str [ index ] ) { return searchAndAdd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endOfWord ) { return true ; } else { insertNode ( prev , str , index ) ; return false ; } }
te	9X	@ Override public float [ ] getFloatData ( float [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { float [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new float [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) Utilities . UNSAFE . getInt ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ ( int ) i ] ; } } } return out ; } }
te	2	@ Test public void testGet ( ) { for ( int i = 0 ; i < A . length ; ++ i ) { for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) { assertTrue ( matrixA . get ( i , j ) . equals ( A [ i ] [ j ] ) ) ; } } }
te	0	@ Override public List < Apontamento > obterPorOrdemServico ( int ordemServicoId ) { return session . createQuery ( "from Apontamento where OrdemServicoId = :ordemServicoId" ) . setString ( "ordemServicoId" , String . valueOf ( ordemServicoId ) ) . list ( ) ; }
te	6	public static void main ( String [ ] args ) throws Exception { long start = System . currentTimeMillis ( ) ; Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice-1.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice1.out" ) ) ) ; int NumCase = in . nextInt ( ) ; in . nextLine ( ) ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { long min , max ; min = in . nextLong ( ) ; max = in . nextLong ( ) ; int count = 0 ; long sqrt_min = ( long ) Math . sqrt ( min ) , sqrt_max = ( long ) Math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( IsPalin ( i ) && IsPalin ( i * i ) ) { count ++ ; } } System . out . println ( " Case #" + curCase + ": " + count ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "\u8FD0\u884C\u65F6\u95F4\uFF1A" + ( end - start ) + "ms" ) ; }
te	8	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
te	1	public void set_wheelchair_boarding ( String in ) { try { _wheelchair_boarding = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
te	5	public void clicked ( Vec2f gamePosition ) { Vec2i mapPosition = new Vec2i ( ( int ) ( gamePosition . x / SQUARE_SIZE ) , ( int ) ( gamePosition . y / SQUARE_SIZE ) ) ; if ( isPlayerUnit ( mapPosition ) ) { Unit unit = units . get ( mapPosition ) ; unit . select ( ) ; if ( selected != null && ! selected . equals ( unit ) ) { selected . unselect ( ) ; } selected = unit ; } else { if ( selected != null && isPassable ( mapPosition ) ) { getPathTo ( selected , mapPosition ) ; } } }
te	4	public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) { change = false ; for ( n = all ( ) ; n . hasMoreElements ( ) ; ) { nt = ( non_terminal ) n . nextElement ( ) ; for ( p = nt . productions ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; prod_first = prod . check_first_set ( ) ; if ( ! prod_first . is_subset_of ( nt . _first_set ) ) { change = true ; nt . _first_set . add ( prod_first ) ; } } } } }
te	5	public void wc ( MainClass mc , Encounter e ) { int x = mc . getXPos ( ) ; int y = mc . getYPos ( ) ; int k = e . getKeyPress ( ) ; if ( x >= 300 && x <= 450 ) { if ( y >= 40 && y <= 140 ) { e . win = false ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } } else if ( k == 10 ) { e . win = false ; e . setKeyPress ( 0 ) ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } }
te	9X	@ Override public void run ( ) { try { while ( Settling . this . running ) { Thread . sleep ( 1 ) ; } } catch ( InterruptedException e ) { } }
te	2	private JPanel pnlCrear ( ) { lblNuevoId = new JLabel ( "Identificaci\u00F3n" ) ; lblNuevoNombre = new JLabel ( "Nombre" ) ; lblNuevoApellido = new JLabel ( "Apellido" ) ; lblNuevoTelefono = new JLabel ( "Tel\u00E9fono" ) ; lblNuevoParentesco = new JLabel ( "Parentesco" ) ; txtNuevoId = new JTextField ( ) ; txtNuevoNombre = new JTextField ( ) ; txtNuevoApellido = new JTextField ( ) ; txtNuevoTelefono = new JTextField ( ) ; txtNuevoParentesco = new JTextField ( ) ; btnNuevoElegir = new JButton ( "Elegir" ) ; btnNuevoElegir . addActionListener ( this ) ; switch ( tipo ) { case SELECCIONAR_DUENIO : btnNuevoElegir . setActionCommand ( ELEGIR_DUENIO_NUEVO ) ; break ; case SELECCIONAR_RESPONSABLE : btnNuevoElegir . setActionCommand ( ELEGIR_RESPONSABLE_NUEVO ) ; break ; } ImageIcon iconElegir = new ImageIcon ( getClass ( ) . getResource ( "/conjunto/views/icons/check.png" ) ) ; Image imgElegir = iconElegir . getImage ( ) . getScaledInstance ( - 1 , 22 , Image . SCALE_SMOOTH ) ; iconElegir . setImage ( imgElegir ) ; btnNuevoElegir . setIcon ( iconElegir ) ; Dimension cmps = new Dimension ( 180 , 27 ) ; lblNuevoId . setPreferredSize ( cmps ) ; lblNuevoNombre . setPreferredSize ( cmps ) ; lblNuevoApellido . setPreferredSize ( cmps ) ; lblNuevoTelefono . setPreferredSize ( cmps ) ; lblNuevoParentesco . setPreferredSize ( cmps ) ; txtNuevoId . setPreferredSize ( cmps ) ; txtNuevoNombre . setPreferredSize ( cmps ) ; txtNuevoApellido . setPreferredSize ( cmps ) ; txtNuevoTelefono . setPreferredSize ( cmps ) ; txtNuevoParentesco . setPreferredSize ( cmps ) ; btnNuevoElegir . setPreferredSize ( new Dimension ( 150 , 30 ) ) ; JPanel pnl = new JPanel ( new FlowLayout ( ) ) ; pnl . setBorder ( BorderFactory . createTitledBorder ( "Crear uno nuevo" ) ) ; pnl . setPreferredSize ( new Dimension ( 200 , - 1 ) ) ; pnl . add ( lblNuevoId ) ; pnl . add ( txtNuevoId ) ; pnl . add ( lblNuevoNombre ) ; pnl . add ( txtNuevoNombre ) ; pnl . add ( lblNuevoApellido ) ; pnl . add ( txtNuevoApellido ) ; pnl . add ( lblNuevoTelefono ) ; pnl . add ( txtNuevoTelefono ) ; pnl . add ( lblNuevoParentesco ) ; pnl . add ( txtNuevoParentesco ) ; pnl . add ( btnNuevoElegir ) ; return pnl ; }
te	3	public Code getCodeByDescription ( String description ) { for ( Code code : codes ) { Map < String , String > localizedStrings = code . getDescription ( ) . getLocalizedStrings ( ) ; for ( String key : localizedStrings . keySet ( ) ) { if ( localizedStrings . get ( key ) . equalsIgnoreCase ( description ) ) { return code ; } } } return null ; }
te	2	private void closeSocket ( ) { try { if ( socket != null ) { socket . close ( ) ; socket = null ; } } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not close network socket: " + e . getMessage ( ) ) ; } socket = null ; }
te	2	static List < VcsCommit > parseCommits ( String xml ) { try { CommitReadingHandler commitReadingHandler = new CommitReadingHandler ( ) ; SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; XMLReader xmlReader = parserFactory . newSAXParser ( ) . getXMLReader ( ) ; xmlReader . setContentHandler ( commitReadingHandler ) ; xmlReader . parse ( new InputSource ( new StringReader ( xml ) ) ) ; return commitReadingHandler . commits ; } catch ( SAXException e ) { throw new RuntimeException ( "Failed to parse xml: " + xml , e ) ; } catch ( ParserConfigurationException | IOException e ) { throw new RuntimeException ( e ) ; } }
te	4	private void setEventLimitFlags ( ) { Settings_Event . EVENT_LIMIT_REACHED_LOW = ( Settings_Event . RUNNING_EVENTS_LOW >= Settings_Event . MAX_RUNNING_EVENTS_LOW ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_MID = ( Settings_Event . RUNNING_EVENTS_MID >= Settings_Event . MAX_RUNNING_EVENTS_MID ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_HIGH = ( Settings_Event . RUNNING_EVENTS_HIGH >= Settings_Event . MAX_RUNNING_EVENTS_HIGH ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_ALL = ( Settings_Event . RUNNING_EVENTS_ALL >= Settings_Event . MAX_RUNNING_EVENTS_ALL ) ? true : false ; }
te	1	@ Override public E actual ( ) { if ( actual == null ) { throw new NullPointerException ( "Error: no se puede acceder el dato actual!" ) ; } return actual . getDato ( ) ; }
te	4	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] >= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
te	6	@ SuppressWarnings ( "rawtypes" ) public static List < String > getClassNamesImplementingInterface ( class interf , String basePackage ) { List < String > classNames = new ArrayList < String > ( ) ; try { class [ ] result = getClasses ( basePackage ) ; for ( class c : result ) { if ( ! Modifier . isAbstract ( c . getModifiers ( ) ) ) { for ( class implementingInterface : c . getInterfaces ( ) ) { if ( implementingInterface . getName ( ) . equals ( interf . getName ( ) ) ) { classNames . add ( c . getCanonicalName ( ) ) ; } } } } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return classNames ; }
te	4	private void initializeTokens ( ) { tokens = new Token [ 21 ] [ 10 ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] = new Token ( ) ; } } nextTokens1 = new TokenNext [ 2 ] [ 4 ] ; nextTokens2 = new TokenNext [ 2 ] [ 4 ] ; nextTokens3 = new TokenNext [ 2 ] [ 4 ] ; holdTokens = new TokenNext [ 2 ] [ 4 ] ; for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] = new TokenNext ( ) ; nextTokens2 [ i ] [ j ] = new TokenNext ( ) ; nextTokens3 [ i ] [ j ] = new TokenNext ( ) ; holdTokens [ i ] [ j ] = new TokenNext ( ) ; } } currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; }
te	0	public void setPrpMoaTipo ( String prpMoaTipo ) { this . prpMoaTipo = prpMoaTipo ; }
te	9X	public String SimplifyPath ( String path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charAt ( 0 ) != / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) == / ) start ++ ; if ( start == pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) == / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
te	3	private void compact ( ) { int from = 0 ; int to = 0 ; while ( from < this . capacity ) { Object key = this . list [ from ] ; long usage = age ( this . ticks [ from ] ) ; if ( usage > 0 ) { this . ticks [ to ] = usage ; this . list [ to ] = key ; this . map . put ( key , to ) ; to += 1 ; } else { this . map . remove ( key ) ; } from += 1 ; } if ( to < this . capacity ) { this . length = to ; } else { this . map . clear ( ) ; this . length = 0 ; } this . power = 0 ; }
te	0	@ Override public T evaluate ( T x , T y , T z ) throws AbstractException { T resFirst = first . evaluate ( x , y , z ) ; T resSecond = second . evaluate ( x , y , z ) ; return resFirst . sum ( resSecond ) ; }
te	7	@ Test public void testNavigateShowDescending ( ) { for ( int i = MockFileSystem . NUM_SEASONS ; i > 0 ; i -- ) { for ( int j = MockFileSystem . NUM_EPISODES ; j > 0 ; j -- ) { int season = ( j == 1 ) ? i - 1 : i ; int expEp = ( j == 1 ) ? MockFileSystem . NUM_EPISODES : j - 1 ; EpisodeMatch toNavigate = new EpisodeMatch ( "Scrubs" , i , j ) ; EpisodeMatch expResult = new EpisodeMatch ( season , expEp ) ; EpisodeMatch result = episode . navigate ( toNavigate , EpisodeNavigator . Pointer . PREV ) ; if ( result == null && i == 1 && j == 1 ) { return ; } System . out . println ( "Navigating: " + toNavigate + " : to : " + expResult ) ; assertEquals ( expResult . getSeason ( ) , result . getSeason ( ) ) ; assertEquals ( expResult . getEpisodes ( ) , result . getEpisodes ( ) ) ; } } }
te	3	protected int readStringHeaderImpl ( ) throws IOException , UBJFormatException { byte type = checkType ( "STRING" , STRING_COMPACT , STRING ) ; int length = 0 ; switch ( type ) { case STRING_COMPACT : length = read ( ) ; break ; case STRING : length = readInt32Impl ( ) ; break ; } if ( length < 0 ) throw new UBJFormatException ( pos , "Encountered a negative (invalid) length of [" + length + "] specified for the STRING value at stream position " + pos + ". Length must be >= 0." ) ; return length ; }
te	3	@ EventHandler ( priority = EventPriority . LOWEST ) public void lever ( PlayerInteractEvent event ) { Action action = event . getAction ( ) ; if ( action == Action . LEFT_CLICK_BLOCK || action == Action . RIGHT_CLICK_BLOCK ) { if ( event . getClickedBlock ( ) . getType ( ) == Material . LEVER ) { prevent ( event , event . getPlayer ( ) , "lever interact" ) ; } } }
te	7	private JPanel createFillInTheBlanksQuestion ( ) { _questionLabel . setText ( _fillInTheBlanks . getAnswer ( ) ) ; final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _optionsStrings = _fillInTheBlanks . getBlanks ( ) ; final int [ ] randomList = MathUtilities . generateRandomArray ( _optionsStrings . size ( ) ) ; _answers = new ArrayList < String > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final String value = _optionsStrings . get ( randomList [ x ] ) ; _answers . add ( _optionsStrings . get ( _optionsStrings . indexOf ( value ) ) ) ; } _optionComboBoxes = new ArrayList < JComboBox > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final JLabel label = new JLabel ( "Choose #" ) ; final String choice = _optionsStrings . get ( randomList [ x ] ) . toLowerCase ( ) ; springLayout . putConstraint ( SpringLayout . WEST , label , 15 , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , label , 45 + x * 35 , SpringLayout . NORTH , jPanel ) ; jPanel . add ( label ) ; Object [ ] choices = new Object [ _optionsStrings . size ( ) + 1 ] ; choices [ 0 ] = "--" ; for ( int y = 0 ; y < choices . length - 1 ; y ++ ) { choices [ y + 1 ] = "[" + y + "]" ; } final JComboBox combobox = new JComboBox ( choices ) ; springLayout . putConstraint ( SpringLayout . WEST , combobox , 10 , SpringLayout . EAST , label ) ; springLayout . putConstraint ( SpringLayout . NORTH , combobox , - 20 , SpringLayout . SOUTH , label ) ; _optionComboBoxes . add ( combobox ) ; combobox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent arg0 ) { String question = "" ; if ( _choicesMade . containsKey ( choice ) ) { _choicesMade . remove ( choice ) ; } String begin = "Question #" + new Integer ( _questionData . getQuestionNumber ( ) ) . toString ( ) + ": " ; question = begin + _questionData . getQuestionString ( ) ; final Set < String > keys = _choicesMade . keySet ( ) ; for ( final String key : keys ) { question = replace ( _choicesMade . get ( key ) , question , key ) ; } final int indexToLookFor = combobox . getSelectedIndex ( ) - 1 ; if ( indexToLookFor >= 0 ) { _choicesMade . put ( choice , "[" + indexToLookFor + "]" ) ; question = replace ( "[" + indexToLookFor + "]" , question , choice ) ; } _beginLabel . setText ( question ) ; } private String replace ( final String needle , final String haystack , final String newNeedle ) { String result = haystack ; while ( result . indexOf ( needle ) != - 1 ) { result = result . replace ( needle , newNeedle ) ; } return result ; } } ) ; jPanel . add ( combobox ) ; final JLabel option = new JLabel ( choice ) ; springLayout . putConstraint ( SpringLayout . WEST , option , 10 , SpringLayout . EAST , combobox ) ; springLayout . putConstraint ( SpringLayout . NORTH , option , 1 , SpringLayout . NORTH , combobox ) ; jPanel . add ( option ) ; } final JLabel temp = new JLabel ( ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , 600 , SpringLayout . WEST , temp ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , 250 , SpringLayout . SOUTH , temp ) ; jPanel . setOpaque ( true ) ; return jPanel ; }
te	0	public int [ ] getWarps ( ) { return new int [ ] { 0 , 0 , 0 , 0 } ; }
te	7	void updateGui ( String fieldname ) { Object fieldval = fieldvalues . get ( fieldname ) ; Object fieldcom = fieldcomponents . get ( fieldname ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; if ( fieldcom instanceof JCheckBox ) { ( ( JCheckBox ) fieldcom ) . setSelected ( ( ( boolean ) fieldval ) . booleanValue ( ) ) ; } else if ( fieldcom instanceof JColorChooser ) { JColorChooser jcc = ( JColorChooser ) fieldcom ; jcc . setColor ( ( Color ) fieldval ) ; } else if ( fieldcom instanceof KeyField ) { ( ( KeyField ) fieldcom ) . setValue ( ( ( Integer ) fieldval ) . intValue ( ) ) ; } else if ( fieldcom instanceof JTextField ) { JTextField textfield = ( JTextField ) fieldcom ; if ( fieldtype . equals ( "int" ) || fieldtype . equals ( "double" ) ) { textfield . setText ( "" + fieldval ) ; } else if ( fieldtype . equals ( "String" ) ) { textfield . setText ( "" + fieldval ) ; } } }
te	7	public char leerDato ( ) { char dato ; if ( isESTA_EN_RAM ( ) ) { if ( pos < data . length ( ) ) { dato = data . charAt ( pos ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } else { if ( "" . equals ( prox ) && lector . hasNext ( ) ) { prox = lector . next ( ) ; } else if ( "" . equals ( prox ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( pos >= prox . length ( ) ) { pos = 0 ; if ( lector . hasNext ( ) ) { prox = lector . next ( ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } dato = prox . charAt ( pos ) ; } pos ++ ; return dato ; }
te	0	public void setRunning ( boolean state ) { running = state ; }
te	0	public void setUpvote ( boolean upvote ) { this . upvote = upvote ; }
te	7	@ Override protected void performTask ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { IAction action = null ; String actionString = request . getParameter ( ConstantsJSP . ACTION ) ; if ( actionString == null ) { jump ( Constants . INDEX_JSP , request , response ) ; return ; } User user = null ; try { HttpSession session = request . getSession ( false ) ; if ( session != null ) { user = ( User ) session . getAttribute ( ConstantsJSP . USER ) ; } if ( user != null && user . getRole ( ) . ordinal ( ) >= Role . COURIER . ordinal ( ) ) { action = PlayCourierActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } else { action = PlaysActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } action . execute ( request , response ) ; if ( ! response . isCommitted ( ) ) { jump ( action . getDoneUrl ( ) , request , response ) ; } } catch ( IllegalArgumentException e ) { jumpError ( Constants . INDEX_JSP , Constants . INTERNAL_ERROR , request , response ) ; return ; } catch ( DAOException e ) { jumpError ( action . getErrorUrl ( ) , e . getMessage ( ) , request , response ) ; return ; } }
te	5	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
te	8	public String evaluateRiskColumn_innerMethod ( TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { System . err . println ( "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = columnRiskEvaluator ( mySQLFactory ) ; return result ; }
te	7	public String toString ( ) { String str = "" ; if ( frameData != null ) { for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { String st = "" ; for ( int f = 0 ; f < frameData . length ; f ++ ) if ( frameData [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + frameData [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pauseData . length ; f ++ ) if ( pauseData [ f ] ) str += " " + f ; } return str ; }
te	8	public void setActivePanel ( final PanelType type ) { if ( this . frame != null ) { this . frame . dispose ( ) ; } switch ( type ) { case START : this . frame = new PlainPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case CLUBS : this . frame = new ClubPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case GYM : this . frame = new GymPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG : this . frame = new GamePanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG_DIR : this . frame = new AllGamesPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case TEAMS : this . frame = new TeamPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case RANKING : this . frame = new RankingPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; } this . sfb . setWeights ( new int [ ] { 30 , 70 } ) ; }
te	5	@ Test public void testlimitNunberOfItems ( ) throws IOException { block = new StorageBlock ( testDir , 2 , StorageManager . DEFAULT_CAPACITY_PER_BLOCK , storageMode ) ; int limit = 1000 ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = block . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; assertTrue ( testBytes . length * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; } String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == block . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit - ( testBytes . length - smallTestBytes . length ) * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == block . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == block . getUsed ( ) ) ; block . free ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; }
te	0	public AddOrigen ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; }
te	2	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
te	2	public void run ( ) { for ( String name : names ) { Apple apple = new Apple ( name ) ; dispatcher . dataReceived ( apple ) ; System . out . println ( "Built apple: " + apple ) ; try { Thread . sleep ( 900 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } dispatcher . dataReceived ( new Key ( all ( Apple . class ) ) ) ; }
te	3	private static boolean hasAccess ( IGraph g , IGraph access ) { for ( int i = 0 ; i < g . size ( ) ; i ++ ) { for ( int j = 0 ; j < access . size ( ) ; j ++ ) { String a = g . get ( i ) . getName ( ) ; String b = access . get ( j ) . getName ( ) ; if ( a . equals ( b ) ) return true ; } } return false ; }
te	9X	private void doTransfer ( ) throws IOException { if ( ressourceInputStream == null ) { if ( sendHeaderInRsp ) { String header = new FileRequestResponseMessage ( ResponseCode . NEVER_TRY_AGAIN , 0 ) . Serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkOutputStream . write ( header . getBytes ( ) ) ; } networkOutputStream . close ( ) ; return ; } else { if ( offset > numAvailableData ) { logger . log ( Level . INFO , "Requested offset is not valid: requested " + offset + "  length of file: " + numAvailableData ) ; if ( sendHeaderInRsp ) networkOutputStream . write ( new FileRequestResponseMessage ( ResponseCode . OK , 0 ) . Serialize ( ) . getBytes ( ) ) ; networkOutputStream . close ( ) ; transferState = TransferStatus . Finished ; return ; } if ( offset + expectedTransferVolume > numAvailableData ) { logger . log ( Level . INFO , "Requested length of " + expectedTransferVolume + " was too large  shortened  it to " + expectedTransferVolume ) ; expectedTransferVolume = numAvailableData - offset ; } transferState = TransferStatus . Transfering ; if ( sendHeaderInRsp ) networkOutputStream . write ( ( new FileRequestResponseMessage ( ResponseCode . OK , expectedTransferVolume ) . Serialize ( ) ) . getBytes ( Message . ENCODING ) ) ; if ( bufferSize == - 1 ) { bufferSize = FALLBACK_BUFFER_SIZE ; logger . log ( Level . INFO , "Using fallback buffersize " + bufferSize ) ; } logger . info ( "sending data" ) ; ressourceInputStream . skip ( offset ) ; int bytesRead = 0 ; int bytesToRead = bufferSize ; byte [ ] buffer = new byte [ bufferSize ] ; while ( bytesToRead > 0 && keepTransferAlive && totalTransferedVolume < expectedTransferVolume && ( bytesRead = ressourceInputStream . read ( buffer , 0 , bytesToRead ) ) != - 1 ) { networkOutputStream . write ( buffer , 0 , bytesRead ) ; totalTransferedVolume += bytesRead ; if ( totalTransferedVolume + bytesToRead > expectedTransferVolume ) { bytesToRead = ( int ) ( expectedTransferVolume - totalTransferedVolume ) ; } } networkOutputStream . flush ( ) ; networkOutputStream . close ( ) ; ressourceInputStream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totalTransferedVolume == expectedTransferVolume ) transferState = TransferStatus . Finished ; else { if ( ! keepTransferAlive ) transferState = TransferStatus . Canceled ; else transferState = TransferStatus . LostConnection ; } } }
te	0	public byte getNotSettable ( ) { return notSettable ; }
te	9X	protected void downloadJars ( String path ) throws Exception { File versionFile = new File ( path , "md5s" ) ; Properties md5s = new Properties ( ) ; if ( versionFile . exists ( ) ) { try { FileInputStream fis = new FileInputStream ( versionFile ) ; md5s . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } state = 4 ; int [ ] fileSizes = new int [ urlList . length ] ; boolean [ ] skip = new boolean [ urlList . length ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; urlconnection . setDefaultUseCaches ( false ) ; skip [ i ] = false ; if ( ( urlconnection instanceof HttpURLConnection ) ) { ( ( HttpURLConnection ) urlconnection ) . setRequestMethod ( "HEAD" ) ; int code = ( ( HttpURLConnection ) urlconnection ) . getResponseCode ( ) ; if ( code / 100 == 3 ) { skip [ i ] = true ; } } fileSizes [ i ] = urlconnection . getContentLength ( ) ; totalSizeDownload += fileSizes [ i ] ; } int initialPercentage = this . percentage = 10 ; byte [ ] buffer = new byte [ 65536 ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { if ( skip [ i ] != false ) { percentage = ( initialPercentage + fileSizes [ i ] * 45 / totalSizeDownload ) ; } boolean downloadFile = true ; while ( downloadFile ) { downloadFile = false ; URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; String etag = "" ; if ( ( urlconnection instanceof HttpURLConnection ) ) { urlconnection . setRequestProperty ( "Cache-Control" , "no-cache" ) ; urlconnection . connect ( ) ; etag = urlconnection . getHeaderField ( "ETag" ) ; } String currentFile = getFileName ( urlList [ i ] ) ; InputStream inputstream = getJarInputStream ( currentFile , urlconnection ) ; FileOutputStream fos = new FileOutputStream ( path + currentFile ) ; long downloadStartTime = System . currentTimeMillis ( ) ; int downloadedAmount = 0 ; int fileSize = 0 ; String downloadSpeedMessage = "" ; MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; int bufferSize ; while ( ( bufferSize = inputstream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bufferSize ) ; m . update ( buffer , 0 , bufferSize ) ; currentSizeDownload += bufferSize ; fileSize += bufferSize ; percentage = ( initialPercentage + currentSizeDownload * 45 / totalSizeDownload ) ; subtaskMessage = ( "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%" ) ; downloadedAmount += bufferSize ; long timeLapse = System . currentTimeMillis ( ) - downloadStartTime ; if ( timeLapse >= 1000 ) { float downloadSpeed = downloadedAmount / ( float ) timeLapse ; downloadSpeed = ( int ) ( downloadSpeed * 100.0F ) / 100.0F ; downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec" ; downloadedAmount = 0 ; downloadStartTime += 1000 ; } subtaskMessage += downloadSpeedMessage ; } inputstream . close ( ) ; fos . close ( ) ; } } }
te	2	public void aiUp ( ) { if ( Realm . player . x == x && Realm . player . y == ( y - 1 ) ) { attack ( ) ; } else { walkUp ( ) ; } }
te	6	public AudioDevice createAudioDevice ( ) throws JavaLayerException { AudioDevice device = null ; AudioDeviceFactory [ ] factories = getFactoriesPriority ( ) ; if ( factories == null ) throw new JavaLayerException ( this + ": no factories registered" ) ; JavaLayerException lastEx = null ; for ( int i = 0 ; ( device == null ) && ( i < factories . length ) ; i ++ ) { try { device = factories [ i ] . createAudioDevice ( ) ; } catch ( JavaLayerException ex ) { lastEx = ex ; } } if ( device == null && lastEx != null ) { throw new JavaLayerException ( "Cannot create AudioDevice" , lastEx ) ; } return device ; }
