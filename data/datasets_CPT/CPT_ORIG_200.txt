tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSuppliersEntity that = ( PhpposSuppliersEntity ) o ; if ( personId != that . personId ) return false ; if ( accountNumber != null ? ! accountNumber . equals ( that . accountNumber ) : that . accountNumber != null ) return false ; return true ; }
tr	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	3	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	9X	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	2	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	9X	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	9X	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } Ѕtring data = Ѕtring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	6	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	1	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	7	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	4	@ Test public void testNaissanceSoldats ( ) { SalleSoldat testSoldat = new SalleSoldat ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testSoldat . naissanceSoldats ( 2 , sn ) ; assertEquals ( 1 , testSoldat . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testSoldat . naissanceSoldats ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testSoldat . naissanceSoldats ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	7	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	3	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	4	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	5	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	5	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	9X	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	9X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	9X	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	5	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
va	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
va	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
va	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
va	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
va	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
va	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
va	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
va	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
va	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
va	9X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
va	9X	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
va	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
va	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
va	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
va	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
va	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
va	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
va	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
va	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
va	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
va	9X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
va	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
va	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
va	9X	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
va	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
va	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
va	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
va	8	private QuerySet < T > isNull ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . trim ( ) . toLowerCase ( ) ; query = query . replace ( "__isnull" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; boolean isNull = boolean . parseBoolean ( queryComponents [ 1 ] ) ; Field field = null ; try { if ( fieldName . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { if ( isNull ) { if ( field . get ( model ) == null ) { querySet . add ( model ) ; } } else { if ( field . get ( model ) != null ) { querySet . add ( model ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
va	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
va	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
va	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
va	5	public String checkDataEntry ( ) { if ( efastAnalysisPanel1 . parameterScreen . directoryChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) . equals ( "" ) || efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . parametersModel . contains ( "None Entered" ) ) { return "No parameters have been selected" ; } else { try { Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) ) ; Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Number of curves and parameter samples must be integers" ; } } }
va	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
va	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
va	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
va	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
va	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
va	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
va	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
va	1	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
te	2	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
te	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
te	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
te	8	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
te	6	public void advance ( ) { timeUntilNext -- ; if ( timeUntilNext <= 0 ) { stoppingAt ( ) ; if ( ! reverse && nextStation . getNext ( ) == null ) { reverse = true ; timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; return ; } if ( reverse && nextStation . getPrev ( ) == null ) { reverse = false ; timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; return ; } if ( reverse ) { timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; } else { timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; } } }
te	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
te	9X	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
te	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
te	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
te	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
te	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
te	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case QUEUE_NAME : if ( value == null ) { unset_queue_name ( ) ; } else { set_queue_name ( ( String ) value ) ; } break ; case MAX_ITEMS : if ( value == null ) { unset_max_items ( ) ; } else { set_max_items ( ( Integer ) value ) ; } break ; case TIMEOUT_MSEC : if ( value == null ) { unset_timeout_msec ( ) ; } else { set_timeout_msec ( ( Integer ) value ) ; } break ; case AUTO_ABORT_MSEC : if ( value == null ) { unset_auto_abort_msec ( ) ; } else { set_auto_abort_msec ( ( Integer ) value ) ; } break ; } }
te	9X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
te	0	public java . awt . Frame getFrame ( ) { return parent ; }
te	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
te	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
te	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
te	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
te	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
te	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
te	6	public void start ( ) throws IllegalStateException { if ( instructions == null || endgamewindow == null || gameboard == null || lobby == null || loginsingup == null || newgame == null ) throw new IllegalStateException ( ) ; done = false ; attempConnection ( ) ; setState ( ModelStates . loginsingup ) ; newgame . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; endgamewindow . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; Thread myThread = new Thread ( this ) ; myThread . start ( ) ; }
te	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
te	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
te	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
te	9X	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
te	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
te	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
te	9X	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
te	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
te	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
te	7	protected static void addObject ( IUnknown o ) { if ( apartmentInitialized . get ( ) == false ) { ComThread . InitSTA ( false ) ; apartmentInitialized . set ( true ) ; } if ( ! AUTO_GC ) return ; ReferenceQueue < IUnknown > deadObjects = deadPool . get ( ) ; objects . put ( new PointerWeakReference ( o , deadObjects ) , false ) ; if ( GC_COUNT != - 1 && ( count % GC_COUNT ) == 0 ) { System . gc ( ) ; } if ( ( count ++ % CULL_COUNT ) == 0 ) { int numberCulled = cullDeadPool ( deadObjects , objects ) ; if ( IUnknown . isDebugEnabled ( ) ) { if ( numberCulled > 0 ) { IUnknown . debug ( "ROT: added instance of " + o . getClass ( ) . getSimpleName ( ) + "->[+1  -" + numberCulled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
te	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
te	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
te	7	public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
te	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
te	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
te	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
te	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
te	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
te	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
